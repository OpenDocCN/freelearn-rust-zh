- en: Reliable Integration with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库的可靠集成
- en: 'Persistent microservices have to store and load data. If you want to keep this
    data organized and reliable, you should use a database. Rust has third-party crates
    that support popular databases, and in this chapter, you''ll learn about how to
    use different databases with Rust, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化微服务需要存储和加载数据。如果您想保持这些数据组织有序且可靠，您应该使用数据库。Rust有支持流行数据库的第三方crate，在本章中，您将了解如何使用Rust与不同的数据库进行交互，包括以下内容：
- en: PostgreSQL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: MySQL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: Redis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: DynamoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB
- en: We will create utilities that will allow you to insert or remove data to and
    from the database, and to query the data held in the database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些实用工具，允许您向数据库中插入或删除数据，以及查询数据库中存储的数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you'll need database instances to run our examples. The most
    effective way to run and work with a database for testing purposes is to use Docker.
    You can install databases locally, but seeing as we'll also need Docker for the
    remaining chapters, it's best to install and use it from this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要数据库实例来运行我们的示例。最有效的方法是使用Docker进行数据库的运行和测试。您可以在本地安装数据库，但由于我们还需要在后续章节中使用Docker，因此最好从本章开始安装并使用它。
- en: 'We will use the following official images from Docker Hub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下来自Docker Hub的官方镜像：
- en: '`postgres:11`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres:11`'
- en: '`mysql:8`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysql:8`'
- en: '`redis:5`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis:5`'
- en: '`mongo:4`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongo:4`'
- en: '`amazon/dynamodb-local:latest`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amazon/dynamodb-local:latest`'
- en: 'You can get to know more about these images on the Docker Hub repository pages:
    [https://hub.docker.com/](https://hub.docker.com/).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Docker Hub的仓库页面了解更多关于这些镜像的信息：[https://hub.docker.com/](https://hub.docker.com/).
- en: 'We will also use the `DynamoDB` database, which is provided as part of Amazon
    Web Services: [https://aws.amazon.com/dynamodb/](https://aws.amazon.com/dynamodb/).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用作为Amazon Web Services一部分提供的`DynamoDB`数据库：[https://aws.amazon.com/dynamodb/](https://aws.amazon.com/dynamodb/).
- en: If you want to interact with databases to check whether our examples work successfully,
    you'll also have to install the corresponding clients for each database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想与数据库交互以检查我们的示例是否成功运行，您还必须为每个数据库安装相应的客户端。
- en: 'You can find all of the examples for this chapter in the `Chapter07` folder
    on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上的`Chapter07`文件夹中找到本章的所有示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/).
- en: PostgreSQL
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL is a reliable and mature database. In this section, we will explore
    how to start an instance of this database in a container, and how to connect to
    it from Rust using third-party crates. We will look at simple interactions with
    this database, and at the use of connection pools to get extra performance. We
    will start an instance of the database with Docker and create a tool to add records
    to a table and to query the list of added records before printing them to a console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是一个可靠且成熟的数据库。在本节中，我们将探讨如何在容器中启动该数据库的一个实例，以及如何使用第三方crate从Rust连接到它。我们将查看与该数据库的简单交互，以及使用连接池以获得额外性能的使用。我们将使用Docker启动数据库的一个实例，并创建一个工具，用于向表中添加记录，并在将它们打印到控制台之前查询已添加的记录列表。
- en: Setting up a test database
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试数据库
- en: To create our database, you can use Docker, which automatically pulls all the
    necessary layers of the images containing the preinstalled PostgreSQL database.
    It's important to note that PostgreSQL has official images on Docker Hub, and
    you should opt to use these instead of unofficial ones, because the latter have
    a greater risk of malicious updates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的数据库，您可以使用Docker，它会自动拉取包含预安装PostgreSQL数据库的所有必要层。需要注意的是，PostgreSQL在Docker
    Hub上有官方镜像，您应该选择使用这些镜像而不是非官方镜像，因为后者有更大的恶意更新风险。
- en: 'We need to start a container with a PostgreSQL database instance. You can do
    this using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动一个包含PostgreSQL数据库实例的容器。您可以使用以下命令来完成此操作：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does this command do? It starts a container from the `postgres` image (the
    latest version) and uses port `5432` on the localhost to forward it to the inner
    port, `5432`, of the container (that is, the port exposed by the image). We also
    set a name with the `--name` argument. We give the container the name `test-pg`.
    You can use this name later to stop the container. The `--rm` flag will remove
    the anonymous volumes associated with the container when it's stopped. So that
    we can interact with the database from a Terminal, we've added `-it` flags.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令做了什么？它从一个 `postgres` 镜像（最新版本）启动一个容器，并使用本地主机的 `5432` 端口将其转发到容器的内部端口 `5432`（即镜像暴露的端口）。我们还使用
    `--name` 参数设置了一个名称。我们给容器命名为 `test-pg`。你可以稍后使用这个名称来停止容器。`--rm` 标志将在容器停止时删除与容器关联的匿名卷。为了能够从终端与数据库交互，我们添加了
    `-it` 标志。
- en: 'The database instance will start and print something like the following to
    the Terminal:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库实例将启动并在终端打印出类似以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The database is now ready for use. You can check it with the `psql` client,
    if you have it locally. The default parameters of the image are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在已准备好使用。如果你本地有 `psql` 客户端，你可以使用它来检查。该镜像的默认参数如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you don''t need the database anymore, you can use the following command
    to shut it down:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再需要数据库，可以使用以下命令来关闭它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But don't shut it down yet—let's connect to it with Rust.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在不要关闭它——让我们用 Rust 连接到它。
- en: Simple interaction with a database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的数据库交互
- en: The easiest way to interact with a database is to create a single connection directly to
    the database. Simple interaction is a straightforward database connection that
    doesn't use connection pools or other abstractions to maximize performance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库交互的最简单方式是直接创建一个到数据库的单个连接。简单交互是一个直接的数据库连接，它不使用连接池或其他抽象来最大化性能。
- en: 'To connect to a PostgreSQL database, we can use two crates: `postgres` or `r2d2_postgres`.
    The first is a generic connection driver. The second, `r2d2_postgres`, is a crate
    for the `r2d2` connection pools crate. We will start by using the `postgres` crate
    directly, without a pool from the `r2d2` crate, and work on a simple utility to
    create a table, before adding commands to manipulate the data in that table.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 PostgreSQL 数据库，我们可以使用两个 crate：`postgres` 或 `r2d2_postgres`。第一个是一个通用的连接驱动程序。第二个，`r2d2_postgres`，是
    `r2d2` 连接池 crate 的一个 crate。我们将首先直接使用 `postgres` crate，而不使用 `r2d2` crate 的池，然后创建一个简单的实用工具来创建一个表，在添加命令来操作该表中的数据之前。
- en: Adding dependencies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Let''s create a new project with all the necessary dependencies. We will create
    a binary utility for managing users in a database. Create a new binary crate:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目，包含所有必要的依赖项。我们将创建一个用于管理数据库中用户的二进制实用工具。创建一个新的二进制 crate：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add the dependencies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加依赖项：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But wait! Cargo doesn''t contain an `add` command. I''ve installed `cargo-edit`
    tool for managing dependencies. You can do this with the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！货物中不包含 `add` 命令。我已经安装了用于管理依赖项的 `cargo-edit` 工具。你可以使用以下命令来完成此操作：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding command installs the `cargo-edit` tool. If you don't install it,
    your local `cargo` won't have an `add` command. Install the `cargo-edit` tool
    and add the `postgres` dependency. You can also add dependencies manually by editing
    the `Cargo.toml` file, but as we are going to create more complex projects, the
    `cargo-edit` tool can be used to save us time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令安装了 `cargo-edit` 工具。如果你没有安装它，你的本地 `cargo` 将不会有 `add` 命令。安装 `cargo-edit`
    工具并添加 `postgres` 依赖项。你也可以通过编辑 `Cargo.toml` 文件手动添加依赖项，但鉴于我们将要创建更复杂的项目，`cargo-edit`
    工具可以帮助我们节省时间。
- en: 'The Cargo tool can be found here: [https://github.com/killercup/cargo-edit](https://github.com/killercup/cargo-edit).
    This tool contains three useful commands to manage dependencies: `add` to add
    a dependency, `rm` to remove an unnecessary dependency, and `upgrade` to upgrade
    versions of dependencies to their latest versions. Furthermore, with the awesome
    Edition 2018 of Rust, you don''t need to use an `extern crate ...` declaration.
    You can simply add or remove any crates and all of them will be available immediately
    in every module. But what about if you add a crate that you don''t need, and end
    up forgetting about it? Since the Rust compiler allows unused crates, you can
    add the following crate-wide attribute, `#![deny(unused_extern_crates)]`, to your
    crate. This is necessary in case you accidentally add a crate that you won''t
    use.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo工具可以在以下位置找到：[https://github.com/killercup/cargo-edit](https://github.com/killercup/cargo-edit)。此工具包含三个有用的命令来管理依赖项：`add`用于添加依赖项，`rm`用于删除不必要的依赖项，`upgrade`用于将依赖项的版本升级到最新版本。此外，使用Rust的令人惊叹的2018版，你不需要使用`extern
    crate ...`声明。你可以简单地添加或删除任何crate，并且它们将立即在所有模块中可用。但是，如果你添加了一个不需要的crate，并且最终忘记了它怎么办？由于Rust编译器允许未使用的crate，你可以在你的crate中添加以下crate-wide属性，`#![deny(unused_extern_crates)]`，以防你意外地添加了一个不会使用的crate。
- en: 'Also, add the `clap` crate. We need it for parsing arguments for our tool.
    Add the usages of all the necessary types, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加`clap` crate。我们需要它来解析我们的工具的参数。按照以下方式添加所有必要类型的用法：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All necessary dependencies have been installed, and our types have been imported,
    so we can create the first connection to a database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的依赖都已安装，并且我们已经导入了我们的类型，因此我们可以创建到数据库的第一个连接。
- en: Creating a connection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接
- en: 'Before you can execute any query on a database, you have to establish a connection
    with the database you started in a container. Create a new `Connection` instance
    with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以在数据库上执行任何查询之前，你必须与你在容器中启动的数据库建立连接。使用以下命令创建一个新的`Connection`实例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The created `Connection` instance has `execute` and `query` methods. The first
    method is used to execute SQL statements; the second is used to query data with
    SQL. Since we want to manage users, let''s add three functions that we''ll use
    with our `Connection` instance: `create_table`, `create_user`, and `list_users`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`Connection`实例有`execute`和`query`方法。第一个方法用于执行SQL语句；第二个用于使用SQL查询数据。由于我们想要管理用户，让我们添加三个我们将与`Connection`实例一起使用的函数：`create_table`、`create_user`和`list_users`。
- en: 'The first function, `create_table`, creates a table for users:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`create_table`为用户创建一个表：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function uses a `Connection` instance to execute a statement to create
    a `users` table. Since we don't need a result, we can simply `drop` it with the `map` command
    on `Result`. As you can see, we use an immutable reference to a connection, because
    `Connection` contains a reference to a shared struct, so we don't need to change
    this value to interact with a database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用一个`Connection`实例来执行一个创建`users`表的语句。由于我们不需要结果，我们可以简单地使用`Result`上的`map`命令来`drop`它。正如你所见，我们使用了一个不可变引用来引用连接，因为`Connection`包含对共享结构的引用，所以我们不需要改变这个值来与数据库交互。
- en: 'There are a lot of discussions about which approach to use: immutable references
    with runtime locks and Mutexes, or mutable references even if we need runtime
    locks. Some crates use the first approach, while others use the second. In my
    opinion, it''s good to fit your approach to the environment in which it will be
    called. In some cases, it''s more convenient to avoid mutable references, but
    in most cases, it''s safer to require mutability for an interface object, such
    as `Connection` from the `postgres` crate. The developers of the crate also have
    a plan to move to mutable references. You can read more about it here: [https://github.com/sfackler/rust-postgres/issues/346](https://github.com/sfackler/rust-postgres/issues/346).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用哪种方法的讨论有很多：使用运行时锁和Mutex的不可变引用，还是即使需要运行时锁也使用可变引用。一些crate使用第一种方法，而其他crate使用第二种。在我看来，将你的方法适应于它将被调用的环境是好的。在某些情况下，避免可变引用可能更方便，但在大多数情况下，要求接口对象（如`postgres`
    crate中的`Connection`）的可变性更安全。crate的开发者也有一个计划将引用改为可变引用。你可以在这里了解更多信息：[https://github.com/sfackler/rust-postgres/issues/346](https://github.com/sfackler/rust-postgres/issues/346)。
- en: 'The next function is `create_user`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`create_user`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function also uses the `execute` method of `Connection` to insert a value,
    but it also adds parameters to a call to fill the provided statement with values
    (the `create_table` function leaves these parameters empty). The result of the
    execution is dropped and we keep `Error` only. You may need the returning value
    if the request returns an identifier of an inserted record.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也使用了`Connection`的`execute`方法来插入一个值，但它还向调用中添加了参数来填充提供的语句（`create_table`函数将这些参数留空）。执行的结果被丢弃，我们只保留`Error`。如果请求返回插入记录的标识符，你可能需要返回值。
- en: The last function, `list_users`, queries a database to get a list of users from
    the `users` table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数`list_users`查询数据库以从`users`表中获取用户列表。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function, `list_users`, uses the `query` method of `Connection`. We use
    a simple `SELECT` SQL statement here, convert it into an iterator of rows, and
    extract pairs of names and email addresses of the users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数`list_users`使用了`Connection`的`query`方法。在这里，我们使用了一个简单的`SELECT` SQL语句，将其转换为行的迭代器，并提取用户的名称和电子邮件地址对。
- en: Wrapping with a tool
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具包装
- en: We've prepared all queries, so now we can join them in a binary tool with a
    command-line interface. In the following code, we will parse some parameters with
    the `clap` crate, and run functions to manage users with an established `Connection`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有查询，现在我们可以将它们在一个具有命令行界面的二进制工具中连接起来。在下面的代码中，我们将使用`clap` crate解析一些参数，并运行函数来管理已建立的`Connection`的`users`表中的用户。
- en: 'Our tool will support three commands. Declare their names as constants:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将支持三个命令。将它们的名称声明为常量：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can create the `main` function using the `clap` crate to parse our
    command-line arguments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`clap` crate创建`main`函数来解析我们的命令行参数：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `main` function returns `postgres::Error` in case of failure, because all
    operations we will do relate to our Postgres database connection. We create a `clap::App` 
    instance here, and add a `--database` argument to let users change the address
    of the connection. We also added three subcommands, `create`, `add`, and `list`,
    along with extra arguments to the `add` command that requires the name and email
    address of a user so that we can insert this into a database.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，`main`函数返回`postgres::Error`，因为我们将要进行的所有操作都与我们的Postgres数据库连接相关。在这里，我们创建了一个`clap::App`实例，并添加了一个`--database`参数，让用户更改连接地址。我们还添加了三个子命令`create`、`add`和`list`，以及`add`命令的额外参数，该参数需要用户的名称和电子邮件地址，以便我们可以将其插入数据库。
- en: 'To create a `Connection` instance, we use a database argument to extract a
    connection URL provided by a user with the `--db` command-line argument, and if
    it isn''t provided, we will use the default URL value, `postgres://postgres@localhost:5432`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Connection`实例，我们使用数据库参数来提取用户通过`--db`命令行参数提供的连接URL，如果没有提供，我们将使用默认URL值`postgres://postgres@localhost:5432`：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We used a `Connection::connect` method with an address, and set the `TlsMode`
    parameter to `TlsMode::None`, because we don't use TLS in our demo. We created
    a `Connection` instance named `conn` to call our functions to interact with our
    database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个带有地址的`Connection::connect`方法，并将`TlsMode`参数设置为`TlsMode::None`，因为我们演示中不使用TLS。我们创建了一个名为`conn`的`Connection`实例来调用我们的函数与数据库交互。
- en: 'Finally, we can add branches for subcommands:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为子命令添加分支：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first branch matches the `crate` subcommand  and creates a table by calling
    the `create_table` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一分支匹配`crate`子命令，通过调用`create_table`函数创建一个表。
- en: The second branch is for the `add` subcommand. It extracts pairs of required
    arguments for the name and email of a user, and calls the `create_user` function
    to create a user record with the provided values. We use `unwrap` to extract it,
    because both arguments are required.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二分支是针对`add`子命令的。它提取用户名称和电子邮件地址所需的参数对，并调用`create_user`函数来创建一个包含提供值的用户记录。我们使用`unwrap`来提取它，因为这两个参数都是必需的。
- en: The penultimate branch handles the `list` command and takes a list of users
    with the `list_users` function call. After the value has been taken, it is used
    in a `for` loop to print all the records of the users to the console.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二个分支处理`list`命令，通过调用`list_users`函数来获取用户列表。在取值之后，它在一个`for`循环中使用，将所有用户的记录打印到控制台。
- en: The last branch is unreachable because we set `AppSettings::SubcommandRequired`
    to `clap::App`, but we leave it in for consistency. It is especially useful if
    you want to provide a default behavior when a subcommand value hasn't been set.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个分支不可达，因为我们将`AppSettings::SubcommandRequired`设置为`clap::App`，但我们保留它以保持一致性。如果你想在子命令值未设置时提供默认行为，这特别有用。
- en: Compiling and running
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行
- en: 'At the beginning of this chapter, we started an instance of the PostgreSQL
    database that we will use to check our tool. Compile the example we created with
    Cargo and print the available subcommands with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们启动了一个PostgreSQL数据库实例，我们将使用它来检查我们的工具。使用以下命令编译我们创建的示例并打印可用的子命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Cargo looks like a cute tool for managing the database of an application. Let''s
    create a table with it, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo看起来是一个管理应用程序数据库的可爱工具。让我们用它创建一个表格，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command creates a `users` table. If you try to run it again, you will
    get an error:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个`users`表。如果你再次尝试运行它，你会得到一个错误：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you check your tables with the `psql` client, you will see the table that
    resides in our database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`psql`客户端检查你的表，你将看到我们数据库中的表：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To add a new user, call the `add` subcommand with the following parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新用户，使用以下参数调用`add`子命令：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We added three users, which you can see in the list if you enter the `list`
    subcommand:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个用户，如果你输入`list`子命令，你可以在列表中看到他们：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the following example, we will use a pool of database connections to add
    multiple users in parallel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用数据库连接池来并行添加多个用户。
- en: Connection pools
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接池
- en: The tool we created uses a single connection to a database. It works fine for
    a small amount of queries. If you want to run multiple queries in parallel, you'll
    have to use connection pools. In this section, we improve the tool with the `import`
    command, which imports bulk user data from a CSV file. We will use a `Pool` type
    from the `r2d2` crate, add a command that will read users from a file, and execute
    statements to add users to a table in parallel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的工具使用数据库的单个连接。对于少量查询来说，它工作得很好。如果你想并行运行多个查询，你必须使用连接池。在本节中，我们通过`import`命令改进了工具，该命令从CSV文件导入大量用户数据。我们将使用`r2d2`
    crate的`Pool`类型，添加一个读取用户文件的命令，并执行并行将用户添加到表中的语句。
- en: Creating a pool
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接池
- en: 'To create a connection pool, we will use the `r2d2` crate that can hold multiple
    connections and provide one for us from the pool. This crate is generic, so you''ll
    need a specific implementation for every database to connect to it. The `r2d2`
    crate can connect to the following databases using adapter crates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建连接池，我们将使用可以保存多个连接并为我们从池中提供连接的`r2d2` crate。这个crate是泛型的，所以你需要为每个要连接的数据库提供一个特定的实现。`r2d2`
    crate可以使用适配器crate连接以下数据库：
- en: PostgreSQL
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Redis
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: MySQL
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: SQLite
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: Neo4j
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j
- en: Diesel ORM
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Diesel ORM
- en: CouchDB
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CouchDB
- en: MongoDB
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: ODBC
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ODBC
- en: 'For our example, we need the `r2d2-postgres` adapter crate to connect to the
    PostgreSQL database. Add it to our dependencies with the `r2d2` crate:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们需要`r2d2-postgres`适配器crate来连接到PostgreSQL数据库。使用`r2d2` crate将其添加到我们的依赖项中：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also keep the `postgres` dependency, and add `failure` for error-handling
    and `rayon` to execute SQL statements in parallel. We also added a set of `serde`
    crates to deserialize `User` records from the CSV file, along with the `csv` crate
    to read that file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还保留了`postgres`依赖项，并添加了`failure`用于错误处理和`rayon`以并行执行SQL语句。我们还添加了一套`serde` crate来从CSV文件反序列化`User`记录，以及`csv`
    crate来读取该文件。
- en: 'You will be much more comfortable using Rust structs that represent data records
    in a database. Let''s add a `User` type that represents a user record in a database
    with the following struct:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你将更习惯于使用Rust结构体来表示数据库中的数据记录。让我们添加一个`User`类型，它代表数据库中的用户记录，如下所示的结构体：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since we have our special `User` type, we can improve the `create_user` and
    `list_users` functions to use this new type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有我们的特殊`User`类型，我们可以改进`create_user`和`list_users`函数以使用这种新类型：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It hasn''t changed dramatically: we still use the same `Connection` type, but
    we use the fields from the `User` struct to fill our `create` statements and extract
    values from our `get list` query. The `create_table` function has not changed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它的变化并不大：我们仍然使用相同的`Connection`类型，但我们使用`User`结构体中的字段来填充我们的`create`语句并从我们的`get
    list`查询中提取值。`create_table`函数没有变化。
- en: 'Add a constant for the `import` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为`import`命令添加一个常量：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add it as a `SubCommand` to `App`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其作为`SubCommand`添加到`App`中：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Almost all branches have changed and we should explore those changes. The `add`
    command creates a `User` instance to call the `create_user` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有分支都有所改变，我们应该探索这些变化。`add`命令创建一个`User`实例来调用`create_user`函数：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `list` subcommand returns a list of `User` struct instances. We have to
    take this change into account:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`子命令返回一个`User`结构体实例的列表。我们必须注意这个变化：'
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `import` command is more complex, so let's discuss this in more detail in
    the following section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令更复杂，所以让我们在下一节中更详细地讨论这个问题。'
- en: Parallel imports with the rayon crate
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rayon crate进行并行导入
- en: 'Since we have a pool of connections, we can run multiple requests to a database
    in parallel. We will read users from a standard input stream in CSV format. Let''s
    add a branch to the `match` expression we declared before, for the `import` subcommand,
    and open `stdin` with `csv::Reader`. After that, we will use the `deserialize`
    method of the reader, which returns an iterator of deserialized instances to our
    desired type. In our case, we deserialize the CSV data to a list of `User` structs
    and push them to a vector:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有连接池，我们可以并行运行对数据库的多个请求。我们将从CSV格式的标准输入流中读取用户。让我们为之前声明的`match`表达式添加一个分支，用于`import`子命令，并使用`csv::Reader`打开`stdin`。之后，我们将使用读取器的`deserialize`方法，它返回我们所需类型的反序列化实例的迭代器。在我们的情况下，我们将CSV数据反序列化为`User`结构体的列表并将它们推送到向量中：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rayon
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rayon
- en: 'To run requests in parallel, we''ll use the `rayon` crate, which provides a
    parallel iterator with the `par_iter` method. The parallel iterator divides a
    list into separate tasks that run across a pool of threads:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并行运行请求，我们将使用`rayon` crate，它提供了具有`par_iter`方法的并行迭代器。并行迭代器将列表分割成在线程池中运行的单独任务：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The parallel iterator returns items much like a traditional iterator. We can
    get a connection from the pool using the `Pool::get` method, and call the `create_user`
    function with a reference to a connection. We also ignore results here, and if
    any request fails, it will be skipped silently, as in the demonstration, we cannot
    take care of values that have not been inserted. Since we use multiple connections,
    we can't use transactions to roll back changes if any statement does fail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 并行迭代器返回项目的方式与传统迭代器类似。我们可以使用`Pool::get`方法从连接池中获取一个连接，并使用连接的引用调用`create_user`函数。我们在这里也忽略结果，如果任何请求失败，它将被静默跳过，正如在演示中，我们无法处理尚未插入的值。由于我们使用多个连接，如果任何语句失败，我们无法使用事务来回滚更改。
- en: 'The `rayon` crate looks really impressive and simple to use. You may ask: *could
    you use this crate in microservices?* The answer is: *yes!* But remember that
    to collect data, you have to call the `for_each` method, which blocks the current
    thread until all tasks are completed. If you call it in reactor''s context (which
    we discussed in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml), *Understanding
    Asynchronous Operations with  Futures Crate*) in asynchronous `Future`, it will
    block the reactor for a while.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`rayon` crate看起来非常令人印象深刻且易于使用。您可能会问：*您可以在微服务中使用这个crate吗？* 答案是：*是的!* 但请记住，为了收集数据，您必须调用`for_each`方法，这将阻塞当前线程直到所有任务完成。如果您在异步`Future`的上下文中（我们在[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)，*使用Futures
    Crate理解异步操作）中调用它，它将阻塞反应器一段时间。'
- en: In the next section, we will rewrite this example for a MySQL database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重写针对MySQL数据库的此示例。
- en: MySQL
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL
- en: 'MySQL is one of the most popular databases, so Rust naturally has crates to
    interact with it. There are two good crates that I recommend that you use: the `mysql`
    crate and its asynchronous version, the `mysql_async` crate.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL是最受欢迎的数据库之一，因此Rust自然有与之交互的crate。我推荐您使用两个很好的crate：`mysql` crate及其异步版本`mysql_async`
    crate。
- en: In this section, we'll rewrite the previous example of managing users with support
    for a MySQL database. We'll also bootstrap a local instance of the database in
    a container, and create a command-line utility that connects to a database instance,
    sends queries to create table, and allows us to add and remove users. We will
    use the latest example for PostgreSQL, which uses the `r2d2` pool.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重写之前管理用户时支持MySQL数据库的示例。我们还将在一个容器中启动数据库的本地实例，并创建一个命令行实用程序，该实用程序连接到数据库实例，发送创建表的查询，并允许我们添加和删除用户。我们将使用最新的PostgreSQL示例，它使用`r2d2`连接池。
- en: Database for tests
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据库
- en: To bootstrap the database, we also will use a Docker image. You can install
    MySQL locally, but a container is a more flexible approach that doesn't clog the
    system, and you can easily start an empty database for testing purposes in seconds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动数据库，我们也将使用Docker镜像。您可以在本地安装MySQL，但容器是一种更灵活的方法，它不会阻塞系统，并且您可以轻松地在几秒钟内为测试目的启动一个空数据库。
- en: 'There is an official image, `mysql`, of the MySQL database that you can find
    here: [https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql). You can
    load and run the container using these images with the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库有一个官方镜像，`mysql`，您可以在以下位置找到：[https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql)。您可以使用以下命令使用这些镜像加载和运行容器：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are two necessary parameters that you can set with environment variables.
    First, the `MYSQL_ROOT_PASSWORD` environment variable sets a password for the
    root user. Second, the `MYSQL_DATABASE` environment variable sets the name of
    a default database that will be created on the first start of a container. We
    named our container `test-mysql` and forwarded the local port `3306` to port `3306`
    inside our container.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用环境变量设置两个必要的参数。首先，`MYSQL_ROOT_PASSWORD`环境变量为root用户设置密码。其次，`MYSQL_DATABASE`环境变量设置了一个默认数据库的名称，该数据库将在容器首次启动时创建。我们命名我们的容器为`test-mysql`，并将本地端口`3306`映射到容器内的`3306`端口。
- en: 'To make sure that our container has started, you can use the `mysql` client,
    if it''s installed locally:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的容器已启动，您可以使用本地安装的`mysql`客户端：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding command connects to `127.0.0.1` (to avoid using sockets) on port
    `3306`, with user as `root`. The `-p` argument asks for a password for the connection.
    We set a password for our testing container because the database images require
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令连接到`127.0.0.1`（为了避免使用套接字）的`3306`端口，用户名为`root`。`-p`参数请求连接的密码。我们为我们的测试容器设置了一个密码，因为数据库镜像需要它。
- en: 'Our database is ready to use. You can also stop it with the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库已准备好使用。您也可以使用以下命令停止它：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Connecting with the r2d2 adapter
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用r2d2适配器连接
- en: In the previous section, we used a connecting pool from the `r2d2` crate with
    a PostgreSQL database. There is also a connection manager for MySQL in the `r2d2-mysql`
    crate that allows you to use a MySQL connection with the `r2d2` crate. The `r2d2-mysql`
    crate is based on the `mysql` crate. Using the pool is also simple, just as we
    did for the PostgreSQL database, but here, we use the `MysqlConnectionManager`
    as a type parameter for `r2d2::Pool`. Let's modify all functions with queries
    to use a pool from our MySQL database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了来自`r2d2` crate的连接池与PostgreSQL数据库进行交互。在`r2d2-mysql` crate中也有一个MySQL的连接管理器，允许您使用`r2d2`
    crate来使用MySQL连接。`r2d2-mysql` crate基于`mysql` crate。使用连接池与PostgreSQL数据库类似简单，但在这里，我们使用`MysqlConnectionManager`作为`r2d2::Pool`的类型参数。让我们修改所有带有查询的函数，以使用我们MySQL数据库的连接池。
- en: Adding dependencies
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'First, we have to add dependencies to establish a connection to MySQL. We use
    all the same dependencies as in the previous example, but have replaced `postgres`
    with the `mysql` crate, and `r2d2_postgres` with the `r2d2_mysql` crate:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须添加依赖项以建立到MySQL的连接。我们使用与上一个示例中相同的所有依赖项，但将`postgres`替换为`mysql` crate，将`r2d2_postgres`替换为`r2d2_mysql`
    crate：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We still need the `csv`, `rayon`, `r2d2`, and `serde` family crates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要`csv`、`rayon`、`r2d2`和`serde`家族的crate。
- en: 'You also have to declare other types to use them in the code, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须声明其他类型，以便在代码中使用，如下所示：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Database interaction functions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库交互函数
- en: 'Now, we can replace our `Connection` instance from the `postgres` crate with `Conn` from
    the `mysql` crate to provide our interaction functions. The first function, `create_table`,
    uses a mutable reference to a `Conn` instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用`mysql` crate的`Conn`替换`postgres` crate中的`Connection`实例，以提供我们的交互函数。第一个函数`create_table`使用对`Conn`实例的可变引用：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Also, we used the `query` method of the `Conn` connection object to send a query.
    This method doesn't expect parameters. We still ignore the successful result of
    a query and `drop` it with `map`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了`Conn`连接对象的`query`方法来发送查询。此方法不期望参数。我们仍然忽略查询的成功结果，并用`map`将其`drop`。
- en: 'The next function, `create_user`, has transformed into the following form:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`create_user`已转换为以下形式：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the `prep_exec` method of `Conn`, which expects a tuple of parameters
    that we have extracted from `User` struct fields. As you can see, we used the `?`
    char to specify where to insert the value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Conn`的`prep_exec`方法，它期望一个参数元组，这些参数是从`User`结构体字段中提取的。如您所见，我们使用了`?`字符来指定插入值的位置。
- en: 'The last function, `list_users`, collects users from a query. It''s more complex
    than the version for PostgreSQL. We used the `query` method which returns a `QueryResult`
    type that implements the `Iterator` trait. We use this property to convert the
    result in to an iterator, and try to fold values to a vector in the `try_fold`
    method of the `Iterator` implementation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数`list_users`从查询中收集用户。它比PostgreSQL版本更复杂。我们使用了返回实现`Iterator`特质的`QueryResult`类型的`query`方法。我们使用这个属性将结果转换为迭代器，并在`Iterator`实现的`try_fold`方法中尝试将值折叠到向量中：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the `try_fold` method call, we provide a closure that expects two arguments:
    the first is a vector that we pass with the `try_fold` call, while the second
    is a `Row` instance. We use `try_fold` to return `Error` if any row conversion
    to user fails.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`try_fold`方法调用，我们提供一个闭包，它期望两个参数：第一个是我们通过`try_fold`调用传递的向量，而第二个是一个`Row`实例。我们使用`try_fold`在行转换到用户失败时返回`Error`。
- en: We use the `get_opt` method of the `Row` object to get a value of a corresponding
    type, and use the `?` operator to extract it from a result, or return `Error`
    with `try_fold`. In every iteration, we return a vector with a new, appended value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Row`对象的`get_opt`方法来获取相应类型的值，并使用`?`运算符从结果中提取它，或者使用`try_fold`返回`Error`。在每次迭代中，我们返回一个包含新附加值的向量。
- en: Creating a connection pool
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接池
- en: We will reuse the arguments parser from the previous example, but will rewrite
    the code that establish a connection, because we're using MySQL instead of PostgreSQL
    now. First, we replaced the database link with the `mysql` scheme. We will use
    the same parameters for the connection as those that we used to bootstrap the
    MySQL server instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用前一个示例中的参数解析器，但将重写建立连接的代码，因为我们现在使用的是MySQL而不是PostgreSQL。首先，我们将数据库链接替换为`mysql`方案。我们将使用与启动MySQL服务器实例相同的参数来建立连接。
- en: 'We convert the address string to the `Opts` - options of a connections, the
    type of mysql crate that''s used to set parameters for connections. But `MysqlConnectionManager`
    expects us to provide an `OptsBuilder` object. Look at the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将地址字符串转换为`Opts` - 连接的选项，这是用于设置连接参数的mysql crate的类型。但是`MysqlConnectionManager`期望我们提供一个`OptsBuilder`对象。看看下面的代码：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we can create `MysqlConnectionManager` using `builder`, and we can create
    `r2d2::Pool` with a `manager` instance. We also get a mutable `conn` reference to
    a connection to provide it for subcommands.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`builder`创建`MysqlConnectionManager`，并且我们可以使用`manager`实例创建`r2d2::Pool`。我们还得到一个可变的`conn`引用，以便为子命令提供它。
- en: 'The good news is that it''s enough to start. We don''t need to change anything
    in our branches, except the type of reference. Now, we have to pass a mutable
    reference to the connection:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这已经足够开始了。我们不需要在我们的分支中做任何改变，除了引用的类型。现在，我们必须传递一个可变的引用到连接：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Try to start and check how the tool works. We will provide it a CSV file with
    content in the following format:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试启动并检查工具的工作情况。我们将提供一个具有以下格式的CSV文件作为输入：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you want to check whether the database has really changed, try importing
    user data from our CSV file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查数据库是否真的发生了变化，请尝试从我们的CSV文件导入用户数据：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can use the `mysql` client to print the `users` table:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`mysql`客户端打印`users`表：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It works! As you can see, users were added in an unpredictable order, because
    we used multiple connections and real concurrency. Now you have knowledge of how
    to use SQL databases. It's time to look at interacting with NoSQL databases through
    the `r2d2` crate.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！正如你所见，用户以不可预测的顺序被添加，因为我们使用了多个连接和真正的并发。现在你了解了如何使用SQL数据库。是时候看看如何通过`r2d2`crate与NoSQL数据库交互了。
- en: Redis
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis
- en: When writing microservices, you may sometimes need a data store that can keep
    values by keys; for example, if you want to store session, you can store a protected
    identifier of the session and keep additional information about users in a persistent
    cache. It's not a problem if a session's data is lost; on the contrary, it is
    a best practice to clean sessions periodically in case a user's session identifier
    is stolen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写微服务时，你可能有时需要一个可以按键存储值的存储库；例如，如果你想存储会话，你可以存储会话的保护标识符，并在持久缓存中保留有关用户的其他信息。如果会话数据丢失不是问题；相反，定期清理会话是一个最佳实践，以防用户的会话标识符被盗。
- en: Redis is a popular in-memory data structure store for this use case. It can
    be used as a database, as a message broker, or as a cache. In the following section,
    we will run a Redis instance with Docker and create a command-line tool that helps
    manage a users' sessions in Redis.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个流行的内存数据结构存储，适用于此用例。它可以用作数据库、消息代理或缓存。在下一节中，我们将使用 Docker 运行 Redis 实例并创建一个命令行工具，帮助管理
    Redis 中的用户会话。
- en: Bootstrap database for tests
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试设置数据库
- en: 'Redis has an official image, `redis`, on Docker Hub. To create and run a container,
    use the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 在 Docker Hub 上有一个官方镜像，名为`redis`。要创建和运行容器，请使用以下命令：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command runs a container from the `redis` image with the name `test-redis`,
    and forwards local port `6379` to the internal port `6379` of the container.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从`redis`镜像运行一个名为`test-redis`的容器，并将本地端口`6379`转发到容器的内部端口`6379`。
- en: 'An interesting fact about Redis is that it uses a very plain and simple interaction
    protocol. You can even use `telnet` to interact with Redis:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Redis 的一个有趣的事实是，它使用一个非常简单和直接的交互协议。您甚至可以使用 `telnet` 与 Redis 交互：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The native client is more comfortable to use, but it expects the same commands
    as the raw protocol.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 原生客户端更易于使用，但它期望与原始协议相同的命令。
- en: 'To shut down a container running Redis, use this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭运行 Redis 的容器，请使用以下命令：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's create a tool to manage sessions in Redis.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于管理 Redis 会话的工具。
- en: Creating a connection pool
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接池
- en: We have started a Redis instance in a Docker container, so now, we can start
    creating a command-line tool to allow us to connect to that database instance
    and put some information into it. This utility will be different from the ones
    we created for PostgreSQL and MySQL, because Redis doesn't use the SQL language.
    We will use specific API methods that are available in Redis.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Docker 容器中启动了一个 Redis 实例，因此现在我们可以开始创建一个命令行工具，允许我们连接到该数据库实例并将一些信息放入其中。这个实用程序将不同于我们为
    PostgreSQL 和 MySQL 创建的工具，因为 Redis 不使用 SQL 语言。我们将使用 Redis 中可用的特定 API 方法。
- en: In this section, we will create a new binary crate and add functions that set
    or get data from Redis using `r2d2::Pool`. After this, we will call them in response
    to subcommands that a user specified as command-line arguments for the command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的二进制 crate 并添加使用 `r2d2::Pool` 从 Redis 设置或获取数据的函数。之后，我们将根据用户指定的命令行参数作为子命令来调用它们。
- en: Dependencies
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Create a new binary crate and add all of the necessary dependencies to the `Cargo.toml`
    file of that crate:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的二进制crate，并将所有必要的依赖项添加到该crate的`Cargo.toml`文件中：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We added the dependencies that we used in the previous examples of this chapter—`clap`,
    `failure`, and `r2d2`. Also, we need the `redis` and `r2d2_redis` crates, which
    contain a connection manager for Redis so that we can use it with `Pool` from the `r2d2`
    crate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了本章前面示例中使用的依赖项——`clap`、`failure` 和 `r2d2`。此外，我们还需要`redis`和`r2d2_redis` crate，它们包含
    Redis 的连接管理器，以便我们可以使用 `r2d2` crate 的 `Pool`。
- en: 'Next, let''s import the types we need to create a tool:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们导入创建工具所需的类型：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the usage of some types. We imported `Connection` as a main connection
    type, which we will use to connect to a Redis instance. We also imported `RedisConnectionManager`
    from the `r2d2_redis` crate. This type allows `Pool` to create new connections.
    The last thing you should note is the `Command` trait. This trait contains methods
    that reflect the Redis client API. The names of methods are the same (but in lowercase),
    as you can see in the Redis protocol. We tested it manually in a previous section.
    The `Command` trait, implemented by a `Connection` struct, allows you to call
    methods of the Redis API.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些类型的用法。我们将 `Connection` 作为主要连接类型导入，我们将使用它来连接到 Redis 实例。我们还从 `r2d2_redis`
    crate 中导入了 `RedisConnectionManager`。此类型允许 `Pool` 创建新的连接。您应该注意的最后一件事情是 `Command`
    trait。这个 trait 包含反映 Redis 客户端 API 的方法。方法名称与 Redis 协议中相同（但全部小写），如前节中手动测试的那样。`Command`
    trait，由 `Connection` 结构体实现，允许您调用 Redis API 的方法。
- en: Redis supports a lot of commands. You can find a full list at [https://redis.io/commands](https://redis.io/commands).
    The `redis` crate provides most of them as methods of the `Command` trait.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 支持许多命令。您可以在[https://redis.io/commands](https://redis.io/commands)找到完整的列表。`redis`
    crate 提供了其中大部分作为 `Command` trait 的方法。
- en: Adding commands and interaction functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加命令和交互函数
- en: 'The tool that we are creating for Redis will support three commands:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为 Redis 创建的工具将支持三个命令：
- en: '`add` - adds a new session record'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add` - 添加新的会话记录'
- en: '`remove` - removes a session record by key (that is, by username)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove` - 通过键（即用户名）删除会话记录'
- en: '`list` - prints all session records'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list` - 打印所有会话记录'
- en: 'We need constants for the name of every subcommand to prevent mistakes in strings
    in the code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个子命令的名称定义常量，以防止代码中字符串的错误：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This list also contains the `SESSION` constant as the name of the `HashMap`
    in Redis. Now, we can declare functions to manipulate session data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表还包含 `SESSION` 常量，作为 Redis 中 `HashMap` 的名称。现在，我们可以声明用于操作会话数据的函数。
- en: Data manipulation functions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据操作函数
- en: 'Our example needs three functions. The first function, `add_session`, adds
    an association between the token and user ID:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子需要三个函数。第一个函数，`add_session`，在令牌和用户 ID 之间添加关联：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function only calls the `hset` method of a `Connection` and sets the `uid`
    value by the `token` key in the `SESSIONS` map. It returns `RedisError` if something
    is wrong with a set operation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅调用 `Connection` 的 `hset` 方法，并通过 `token` 键在 `SESSIONS` 映射中设置 `uid` 值。如果设置操作出现错误，则返回
    `RedisError`。
- en: 'The next function, `remove_session`, is also pretty simple and calls the `hdel`
    method of `Connection`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数，`remove_session`，也非常简单，它调用了 `Connection` 的 `hdel` 方法：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function deletes a record with the `token` key from the `SESSIONS` map.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从 `SESSIONS` 映射中删除具有 `token` 键的记录。
- en: 'The last function, `list_sessions`, returns all token-uid pairs as a `HashMap`
    instance from the `SESSION` map. It uses the `hgetall` method of `Connection`,
    which calls the `HGETALL` method in Redis:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，`list_sessions`，从 `SESSION` 映射中返回所有令牌-uid 对，作为一个 `HashMap` 实例。它使用 `Connection`
    的 `hgetall` 方法，该方法调用 Redis 中的 `HGETALL` 方法：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, all functions map to raw Redis commands, which looks pretty
    simple. But all functions do a good job in the background too, converting values
    to their corresponding Rust types.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有函数都映射到原始 Redis 命令，看起来非常简单。但所有函数在后台也做得很好，将值转换为相应的 Rust 类型。
- en: Now, we can create an arguments parser for the session tool.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为会话工具创建一个参数解析器。
- en: Parsing arguments
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析参数
- en: 'Since our command supports three subcommands, we have to add them to a `clap::App`
    instance:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的命令支持三个子命令，我们必须将它们添加到 `clap::App` 实例中：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As in previous examples, this can also use the `--database` argument with a
    link to a Redis connection. It supports two subcommands. The `add` subcommand
    expects a session `TOKEN` and the `UID` of the user. The `remove` command expects
    a session `TOKEN` only to remove it from a map. The `list` command doesn't expect
    any parameters and prints a list of sessions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，这也可以使用带有 Redis 连接链接的 `--database` 参数。它支持两个子命令。`add` 子命令期望一个会话 `TOKEN`
    和用户的 `UID`。`remove` 命令期望一个会话 `TOKEN`，仅用于从映射中删除它。`list` 命令不期望任何参数，并打印会话列表。
- en: Imagine the structure of data in this example as a cache for sessions that holds
    associations between `token` and `uid`. After authorization, we can send the token
    as a secure cookie and extract the user's `uid` for the provided token for every
    microservice to achieve loose coupling between microservices. We will explore
    this concept in detail later.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这个例子中的数据结构是一个会话缓存，它持有 `token` 和 `uid` 之间的关联。在授权后，我们可以将令牌作为安全cookie发送，并为每个微服务提供的令牌提取用户的
    `uid`，以实现微服务之间的松耦合。我们将在稍后详细探讨这个概念。
- en: Now, we are ready to connect to Redis with `r2d2::Pool`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用 `r2d2::Pool` 连接到 Redis。
- en: Connecting to Redis
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Redis
- en: 'The `r2d2` connection to Redis looks similar to other databases:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`r2d2` 连接到 Redis 的方式与其他数据库类似：'
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We get the address from the `--database` argument, but if it isn't set, we will
    use the default value, `redis://127.0.0.1/`. After that, we will create a new
    `RedisConnectionManager` instance and pass it to the `Pool::new` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `--database` 参数中获取地址，但如果它未设置，我们将使用默认值 `redis://127.0.0.1/`。之后，我们将创建一个新的
    `RedisConnectionManager` 实例，并将其传递给 `Pool::new` 方法。
- en: Executing subcommands
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行子命令
- en: 'We use the structure of branches to match subcommands from our previous examples:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用分支的结构来匹配我们之前示例中的子命令：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the `add` subcommand, we extract the `TOKEN` and `UID` values from arguments
    and pass them to the `add_session` function with a reference to a `Connector`.
    For the `remove` subcommand, we extract only the `TOKEN` value and call the `remove_session`
    function with its corresponding parameters. For the `list` subcommand, we call
    the `list_session` function as is, because we don't need any extra parameters
    to get all values from a map. This returns a vector of pairs. The first item of
    the pair contains `token`, and the second contains `uid`. We print the values
    using a fixed width specifier of `{:20}`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Redis example
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s compile and test the tool. We will add three sessions of users:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To print the list, run the `list` command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With this, you will see all the sessions you have created:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''ve learned how to use Redis. It''s useful to store messages for caching
    something. Next in line is the last NoSQL database we''ll look at: MongoDB.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is a popular NoSQL database that has great features and good performance.
    It''s really good for data that changes structure quickly, such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Operational intelligence (logs and reports)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product data management (product catalog, hierarchies, and categories)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content management systems (posts, comments, and other records)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create an example that stores the activities of a user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a database for testing
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the official Docker image to bootstrap a MongoDB instance. You
    can do it simply with the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This command runs a container with the name `test-mongo` from the `mongo` image,
    and forwards the local port `27017` to the same internal port of the container.
    The data that container produces will be removed after container shutdown.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a `mongo` client, you can use it to connect to an instance of database
    inside the container:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When you need to shut down the container, use the `stop` subcommand of `docker` and
    specify the `name` of the container:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It can also be terminated with *Ctrl *+ *C* if you attached the container to
    a Terminal with `-it` arguments, as I did previously.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can look how to connect to a database using `mongo` and the `r2d2-mongo`
    crate.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using the r2d2 pool
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By tradition, we will use a `Pool` from the `r2d2` crate, but in this example
    (as in the Redis example), we don''t use multiple connections at once. Add all
    of the necessary dependencies to a new binary crate:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The list is not small. Besides the crates you already familiar with, we've added the
    `bson`, `chrono`, and `url` crates. The first crate we need to work with data
    in the database; the second, to use the `Utc` type; and the last to split URL
    strings into pieces.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the necessary types, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This user''s logging tool will support two commands: `add` to add a record,
    and `list` to print a list of all records. Add the following necessary constants:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To set and get structured data, we need to declare an `Activity` struct that
    will be used to create a BSON document and to restore it from BSON data, because
    MongoDB uses this format for data interaction. The `Activity` struct has three
    fields, `user_id`, `activity`, and `datetime`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置和获取结构化数据，我们需要声明一个 `Activity` 结构体，该结构体将用于创建 BSON 文档以及从 BSON 数据中恢复它，因为 MongoDB
    使用此格式进行数据交互。`Activity` 结构体有三个字段，`user_id`、`activity` 和 `datetime`：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Interaction functions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互函数
- en: 'Since we have a declared structure, we can add functions to work with databases.
    The first function we will add is `add_activity` which adds an activity record
    to a database:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已声明结构体，我们可以添加与数据库一起工作的函数。我们将添加的第一个函数是 `add_activity`，它将活动记录添加到数据库中：
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This function only converts the `Activity` struct into a BSON document, and
    does this by extracting fields from a struct and construct BSON document with
    the same fields. We can derive the `Serialize` trait for the structure and use
    automatic serialization, but I used the `doc!` macro for demonstration purposes
    to show you that you can add a free-form document that can be constructed on the
    fly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅将 `Activity` 结构体转换为 BSON 文档，通过从结构体中提取字段并使用相同字段构建 BSON 文档来实现。我们可以为结构体推导出
    `Serialize` 特性以使用自动序列化，但为了演示目的，我使用了 `doc!` 宏来展示你可以添加一个可以即时构建的自由格式文档。
- en: To add `Activity`, we get a collection called `activities` from a `Database`
    instance by reference to the `collection()` method, and call the `insert_one`
    method of `Collection` to add a record.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 `Activity`，我们通过 `collection()` 方法从 `Database` 实例中获取一个名为 `activities` 的集合，并调用
    `Collection` 的 `insert_one` 方法来添加记录。
- en: The next method is `list_activities`. This method uses a `Database` instance
    to find all values in the *activities* collection. We use the `find()` method
    of `Collection` to get data, but make sure to set filter (the first argument)
    to `None`, and options (the second argument) to `None`, to get all of the values
    from a collection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `list_activities`。此方法使用 `Database` 实例来查找 `activities` 集合中的所有值。我们使用 `Collection`
    的 `find()` 方法来获取数据，但请确保将过滤器（第一个参数）设置为 `None`，将选项（第二个参数）设置为 `None`，以获取集合中的所有值。
- en: 'You can tweak these parameters for filtering, or to limit the quantity of records
    you retrieve:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整这些参数进行过滤，或者限制你检索的记录数量：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To convert every record returned by the `find` query as a BSON document, we
    can use the `bson::from_bson` method, since we have derived the `Deserialize`
    trait for the `Activity` struct. The `try_fold` method lets us interrupt folding
    if conversion should fail. We push all successfully converted values to the vector
    that we provided as the first argument to the `try_fold` method call. Now, we
    can parse arguments so that we can prepare a pool to use for calling declared
    interaction functions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `find` 查询返回的每个记录转换为 BSON 文档，我们可以使用 `bson::from_bson` 方法，因为我们已经为 `Activity`
    结构体推导出 `Deserialize` 特性。`try_fold` 方法允许我们在转换失败时中断折叠。我们将所有成功转换的值推送到我们提供给 `try_fold`
    方法调用的第一个参数的向量中。现在，我们可以解析参数，以便我们可以准备一个池来调用声明的交互函数。
- en: Parsing arguments
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析参数
- en: 'Our tool expects two subcommands: `add` and `list`. Let''s add them to a `clap::App`
    instance. Like all previous examples, we also added a `--database` argument to
    set the connection URL. Look at the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具期望两个子命令：`add` 和 `list`。让我们将它们添加到 `clap::App` 实例中。像所有之前的示例一样，我们也添加了一个 `--database`
    参数来设置连接 URL。请看以下代码：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `add` subcommand expects two parameters: `USER_ID` and `ACTIVITY`. Both
    are represented as `String` type values in the `Activity` struct. We will require
    these arguments, but we''ll get any provided values without any restrictions.
    The `list` subcommand has no extra arguments.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 子命令期望两个参数：`USER_ID` 和 `ACTIVITY`。在 `Activity` 结构体中，这两个参数都表示为 `String`
    类型的值。我们将要求这些参数，但我们将获取任何提供的值，没有任何限制。`list` 子命令没有额外的参数。'
- en: Creating a connections pool
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接池
- en: 'To connect to a database, we extract the connection URL from the `--database`
    command-line argument. If it isn''t set, we use the `mongodb://localhost:27017/admin`
    default value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库，我们从 `--database` 命令行参数中提取连接 URL。如果没有设置，我们使用默认值 `mongodb://localhost:27017/admin`：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But we also parse it to the `Url` struct. This is necessary because MongoDB
    connections expect options sets to be collected by separate values:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也将它解析到 `Url` 结构体中。这是必要的，因为 MongoDB 连接期望选项集通过单独的值来收集：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code, we create a new `ConnectionOptionsBuilder` instance and
    populate it with values from a parsed `Url` instance. We set `host`, `port`, and
    the `db` name. As you can see, we skip the first character of the path so that
    we can use it as the name of the database. Call the `build` method to build the `ConnectionOptions`
    struct. Now, we can create a `MongodbConnectionManager` instance and use it to
    create a `Pool` instance. But, in this example, we called the `builder` method,
    instead of `new`, to show you how you can set the number of connections in a `Pool`
    instance. We set this to `4`. After that, we called the `build` method to create
    a `Pool` instance. As in previous examples, we call the `get` method of a `Pool`
    to get a `Database` connection object from a pool.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Implementing subcommands
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of subcommands is simple. For the `add` subcommand, we extract
    two arguments, `USER_ID` and `ACTIVITY`, and use them to create an `Activity`
    struct instance. We also get the current time with the `Utc::now` method and save
    it to a `datetime` field of `Activity`. Finally, we call the `add_activity` method to
    add the `Activity` instance to the MongoDB database:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The list subcommand calls the `list_activities` function, and then iterates
    over all records to print them to a Terminal. The logging tool is finished – we
    can test it now.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile and run the tool with the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Print a list of added records with the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will print the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also check the result with the `mongo` client:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You did it! It works well! Now, you know how to use all popular databases with
    Rust. In the next chapter, we will improve on this knowledge with **o****bject-relational
    mapping** (**ORM**), which helps to simplify database structure declaration, interaction,
    and migrations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We used local database instances in this chapter. The disadvantage of maintaining
    databases yourself is that you also have to take care of scalability yourself.
    There are a lot of services that provide popular databases that automatically
    scale to meet your needs. But not every database can grow without limits: traditional
    SQL databases often experience speed performance issues when tables become huge.
    For large datasets, you should choose to use key-value databases (such as NoSQL)
    that provide scalability by design. In this section, we will explore the usage
    of `DynamoDB`, which was created by Amazon, to provide an easily scalable database
    as a service.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: To use AWS services, you need the AWS SDK, but there is no official SDK for
    Rust, so we will use the `rusoto` crate, which provides the AWS API in Rust. Let's
    start by porting the tool, which we created earlier in this chapter, to `DynamoDB`.
    First, we should create a table in the `DynamoDB` instance.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a database for testing
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since AWS services are paid-for, it''s better to bootstrap a local instance
    of the `DynamoDB` database for development or testing your application. There
    is an image of `DynamoDB` on Docker Hub. Run the instance with this command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AWS服务是付费的，因此对于开发或测试你的应用程序，最好在本地启动`DynamoDB`数据库的一个实例。Docker Hub上有`DynamoDB`的镜像。使用以下命令运行实例：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This command creates an instance of a database and forwards port `8000` of a
    container to a local port with the same number.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个数据库实例，并将容器的`8000`端口转发到相同数字的本地端口。
- en: 'To work with this database instance, you need the AWS CLI tool. This can be
    installed using the instructions from [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html).
    On Linux, I use the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要与这个数据库实例一起工作，你需要AWS CLI工具。可以使用[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html)中的说明进行安装。在Linux上，我使用以下命令：
- en: '[PRE77]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This command doesn''t need administration privileges to be installed. After
    I installed the tool, I created a user with programmatic access, as detailed here:
    [https://console.aws.amazon.com/iam/home#/users$new?step=details](https://console.aws.amazon.com/iam/home#/users%24new?step=details).
    You can read more about creating a user account to access the AWS API here: [https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不需要安装管理权限。在我安装了工具之后，我创建了一个具有程序访问权限的用户，具体细节如下：[https://console.aws.amazon.com/iam/home#/users$new?step=details](https://console.aws.amazon.com/iam/home#/users%24new?step=details)。你可以在[https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html)中了解更多关于创建用户账户以访问AWS
    API的信息。
- en: 'When you have a user for programmatic access, you can configure the AWS CLI
    using the `configure` subcommand:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有程序访问权限的用户时，你可以使用`configure`子命令配置AWS CLI：
- en: '[PRE78]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The subcommand asks you for your user credentials, default region, and desired
    output format. Fill in those fields as appropriate.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令会要求你提供用户凭据、默认区域和所需的输出格式。根据适当的情况填写这些字段。
- en: 'Now, we can create a table using the AWS CLI tool. Enter the following command
    into the console:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用AWS CLI工具创建一个表格。将以下命令输入到控制台：
- en: '[PRE79]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This command creates a table from a declaration in JSON format from the `table.json`
    file in the local database, with an endpoint of `localhost:8000`. This is the
    address of the container we have started. Look at the contents of this table declaration
    file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从本地数据库中`table.json`文件的一个JSON格式的声明创建一个表格，端点为`localhost:8000`。这是我们已经启动的容器的地址。查看此表格声明文件的内容：
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This file contains a declaration of a table with two required attributes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含一个具有两个必需属性的表格声明：
- en: '`Uid` - This stores user identifiers. This attribute will be used as a partition
    key.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uid` - 此属性存储用户标识符。此属性将用作分区键。'
- en: '`TimeStamp` - This stores a timestamp when location data is produced. This
    attribute will be used as a sorting key to order records.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeStamp` - 此属性存储当位置数据被生成时的戳记。此属性将用作排序键以对记录进行排序。'
- en: 'You can check whether the database instance contains this new table with the
    following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查数据库实例是否包含此新表格：
- en: '[PRE81]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It prints the list of tables that the database instance contains, but our list
    is rather short, as we only have one table:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出数据库实例包含的表格列表，但我们的列表相当短，因为我们只有一个表格：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The database is prepared. Now, we will create a tool to add records to this
    table using Rust.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库已准备就绪。现在，我们将创建一个工具，使用Rust向此表格添加记录。
- en: Connecting to DynamoDB
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到DynamoDB
- en: In this section, we will create a tool to add records to a table in our `DynamoDB`
    database, and also print all records from the table. First, we need to add all
    of the necessary crates.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个工具，用于向我们的`DynamoDB`数据库中的表格添加记录，并打印出表格中的所有记录。首先，我们需要添加所有必要的crate。
- en: Adding dependencies
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: To work with the AWS API, we will use the `rusoto` crate. Actually, it isn't
    a single crate, but a set of crates where every single crate covers some functionality
    of the AWS API. The basic crate is `rusoto_core`, which contains the `Region`
    struct that represents an address of the AWS API endpoint. `Region` is often necessary
    for other crates. Also, the `rusoto_core` crate re-exports the `rusoto_credential`
    crate, which contains types for loading and managing AWS credentials to access
    the API.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the `DynamoDB` database, we need to add the `rusoto_dynamodb`
    dependency. The full list looks like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We also added the `chrono` dependency to generate timestamps and convert them
    to ISO-8601 format strings. We use the `clap` crate to parse command-line arguments,
    and the `failure` crate to return a generic `Error` type from the `main` function.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following types in our code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It's worth paying attention to types that are imported from the `rusoto_core` and
    `rusoto_dynamodb` crates. We imported the `Region` struct, which is used to set
    the location of the AWS endpoint. The `DynamoDb` trait, `DynamoDbClient`, is used
    to get access to a database. `AttributeValue` is a type used to represent values
    stored in DynamoDB's tables. `QueryInput` is a struct to prepare `query` and `UpdateItemInput`
    is a struct to prepare an `update_item` request.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Let's add functions to interact with the `DynamoDB` database.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Interaction functions
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a tool that stores location records to a database
    and query location points for a specific user. To represent a location in the
    code, we declare the following `Location` struct:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This struct keeps `user_id`, which represents the partition key, and `timestamp`,
    which represents the sort key.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '`DynamoDB` is a key-value storage, where every record has a unique key. When
    you declare tables, you have to decide which attributes will be the key of a record.
    You can choose up to two keys. The first is required and represents a partition
    key that''s used to distribute data across database partitions. The second key
    is optional and represents an attribute that''s used to sort items in a table.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rusoto_dynamodb` crate contains an `AttributeValue` struct, which is used
    in queries and results to insert or extract data from tables. Since every record
    (that is, every item) of a table is a set of attribute names to attribute values,
    we will add the `from_map` method to convert the `HashMap` of attributes to our
    `Location` type:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We need four attributes: `Uid`,  `TimeStamp`, `Longitude`, and `Latitude`.
    We extract every attribute from the map and convert it into a `Location` instance
    using the `attr_to_string` method:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `AttributeValue` struct contains multiple fields for different types of
    values:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '`b` - A binary value represented by `Vec<u8>`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool` - A boolean value with the `bool` type'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bs` - A binary set, but represented as `Vec<Vec<u8>>`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` - A list of attributes of a `Vec<AttributeValue>` type'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m` - A map of attributes of a `HashMap<String, AttributeValue>` type'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` - A number stored as a `String` type to keep the exact value without any
    precision loss'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ns` - A set of numbers as a `Vec<String>`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` - Used to represent a null value and stored as `bool`, which means the
    value is null'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` - A string, of the `String` type'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ss` - A set of strings, of the `Vec<String>` type'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might notice that there is no data type for timestamps. This is true, as
    `DynamoDB` uses strings for most types of data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `s` field to work with string values that we''ll add with the `add_location`
    function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This function expects two parameters: a reference to a database client, and
    a `Location` instance to store. We have to prepare data manually to get it as
    an attributes map for storage, because `DynamoDbClient` takes values of the `AttributeValue`
    type only. The attributes included in the key are inserted into the `HashMap`,
    with values extracted from the `Location` instance and converted into `AttributeValue`
    using the `s_attr` function, which has the following declaration:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: After we've filled the `key` map, we can set other attributes with expressions.
    To set attributes to an item, we have to specify them in `DynamoDB` syntax, along
    the lines of `SET Longitude = :x, Latitude = :y`. This expression means that we
    add two attributes with the names `Longitude` and `Latitude`. In the preceding
    expression, we used the placeholders of `:x` and `:y`, which will be replaced
    with real values that we pass in from the `HashMap`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about expressions can be found here: [https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.html).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: When all of the data prepared, we fill the `UpdateItemInput` struct and set
    `table_name` to `"Locations"`, because it requires this as an argument for the
    `update_item` method of `DynamoDbClient`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The `update_item` method returns `RusotoFuture`, which implements the `Future`
    trait that we explored in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml), *Understanding
    Asynchronous Operations with Futures Crate*. You can use the `rusoto` crate in
    asynchronous applications. Since we don't use a reactor or asynchronous operations
    in this example, we will call the `sync` method of `RusotoFuture`, which blocks
    the current thread and waits for `Result`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'We have implemented a method to create new data items to the table and now
    we need a function to retrieve data from this table. The following `list_locations`
    function gets a list of `Location` for a specific user from the `Locations` table:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `list_locations` function expects a reference to the `DynamoDbClient` instance
    and a string with if of user. If there are items in the table for the requested
    user, they are returned as a `Vec` of items, converted into the `Location` type.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we use the `query` method of `DynamoDbClient`, which expects
    a `QueryInput` struct as an argument. We fill it with the name of the table, the
    condition of the key expression, and values to fill that expression. We use a
    simple `Uid = :uid` expression that queries items with the corresponding value
    of the `Uid` partition key. We use a `:uid` placeholder and create a `HashMap` instance
    with a `:uid` key and a `user_id` value, which is converted into `AttributeValue`
    with the `s_attr` function call.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have two functions to insert and query data. We will use them to implement
    a command-line tool to interact with `DynamoDB`. Let's start with parsing arguments
    for our tool.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Parsing command-line arguments
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS is divided by regions, where each has its own endpoint to connect to services.
    Our tool will support two arguments to set a region and endpoint:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We add both to `App` instance. The tool will support two commands to add a
    new item and to print all items. The first subcommand is `add` and it expects
    three arguments: `USER_ID`, `LONGITUDE`, and `LATITUDE`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `list` subcommand requires `USER_ID` in arguments only:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Add all of the preceding code to the `main` function. We can use these arguments
    to create a `Region` instance that we can use for a connection with `DynamoDB`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The code works according to the following logic: if a user sets the `--endpoint-url`
    parameter, we create a `Region` with a custom name and provide an `endpoint` value.
    If `endpoint` is not set, we try to parse the `--region` parameter to the `Region`
    instance, or just use the `us-east-1` value by default.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: AWS takes the region value seriously, and if you create a table in one region,
    you can't access that table from another region. We used a custom name for the
    region, but for production tools, it's better to use the `~/.aws/config` file
    or provide the flexibility to customize these settings.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the `Region` value to create a `DynamoDbClient` instance:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `DynamoDbClient` struct is used for sending queries to our `DynamoDB` instance.
    We will use this instance in the implementation of our commands. Do you remember
    the `match` expression that parses command-line arguments? Add this implementation
    for the `add` subcommand first, which puts a new item in a table, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The implementation is simple—we extract all provided arguments, generate a timestamp
    using the `Utc::now` call, and convert it into a `String` type in the ISO-8601
    format. Lastly, we fill the `Location` instance and call the `add_location` function
    that we declared before.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever wondered why databases use the ISO-8601 format to represent dates,
    which look like `YEAR-MONTH-DATE HOUR:MINUTE:SECOND`? That''s because dates stored
    in strings in this format are ordered chronologically if sorted alphabetically.
    It''s very convenient: you can sort dates to get the earliest on top and the latest
    at the bottom.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to implement the `list` subcommand:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This command extracts `USER_ID` arguments and calls the `list_locations` function
    with the provided `user_id` value. Finally, we iterate over all locations and
    print them to the Terminal.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is finished and we can try it now.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the tool, start the `DynamoDB` instance with Docker and create a table,
    like we did before in this chapter. Let''s add four locations of two users:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We also set the `--endpoint-url` argument to target our client to a local `DynamoDB`
    instance. When all records have been added, we can use the `list` subcommand to
    print all of the values of the specified user:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This command prints something like the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As you can see, we retrieved all of the values in a sorted order, because we
    use the `TimeStamp` attribute as a sorting key of the table. Now, you know enough
    to create microservices that uses databases, but if you use the SQL database,
    you can add an extra abstraction layer and work with records of a database as
    native Rust structs, without writing glue code. In the next chapter, we will examine
    this approach with object-relational mappings.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered a lot to do with databases. We started by creating
    a plain connection to PostgreSQL. After that, we added a pool of connections with the
    `r2d2` crate and used the `rayon` crate to execute SQL statements in parallel.
    We created a tool to manage our `users` database, and reimplemented it for our
    MySQL database.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We have also mastered some ways of interacting with NoSQL databases, in particular,
    Redis and MongoDB.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The last database we explored was DynamoDB, which is part of Amazon Web Services
    and can be scaled very easily.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: For all examples, we run database instances in containers, because it's the
    simplest way to test interactions with databases. We haven't use database connections
    in microservices yet, because it requires a separate thread to avoid blocking.
    We will learn how to use background tasks with asynchronous code later, in [Chapter
    10](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml), *Background Tasks and Thread
    Pools in Microservices*.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a different approach to using databases—object-relational
    mapping with the `diesel` crate.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
