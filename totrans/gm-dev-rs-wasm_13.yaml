- en: '*Chapter 10*: Continuous Deployment'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：持续部署'
- en: The traditional way to publish a game is to create a main copy of the build
    and ship it off to manufacturing. This was frequently referred to as **going gold**
    inside and outside of the gaming industry, and it still is if you're making a
    AAA game that's being shipped to consoles and sold in stores. The process is time-consuming
    and extremely expensive; fortunately, we don't have to do it! Walk the Dog is
    a web-based game that we need to ship to a website. Since we're deploying to the
    web, we can use all the best practices of the web, including continuous deployment,
    where we'll deploy a build whenever we want directly from source control.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的游戏发布方式是创建一个主副本的构建版本，并将其发送到制造工厂。这在游戏行业内外经常被称为**黄金版**，如果你正在制作一个将被发送到游戏机并在商店销售的AAA游戏，情况也是如此。这个过程既耗时又极其昂贵；幸运的是，我们不必这样做！《Walk
    the Dog》是一款基于网页的游戏，我们需要将其发布到网站上。由于我们是在部署到网络上，我们可以使用所有最佳的网络实践，包括持续部署，这意味着我们可以直接从源代码控制中部署任何我们想要的构建版本。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a **Continuous Integration**/**Continuous Delivery** (**CI**/**CD**)
    pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**持续集成**/**持续交付**（**CI**/**CD**）管道
- en: Deploying test and production builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署测试和生产构建
- en: When this chapter is complete, you'll be able to ship your game to the web!
    How else will you become rich and famous?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当本章完成时，你将能够将你的游戏发布到网络上！否则你怎么能变得富有和出名呢？
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to a GitHub account, you''ll need a Netlify account. Both of these
    have significant free tiers, so if cost becomes a problem, then congratulations!
    Your game took off! You''ll also need to be familiar with Git. You don''t need
    to be an expert, but you''ll need to be able to create repositories and push them
    to GitHub. If Git is completely new to you, then the GitHub *Getting Started*
    guide is a good place to start: [https://docs.github.com/en/get-started](https://docs.github.com/en/get-started).
    The sample code for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了GitHub账户外，你还需要一个Netlify账户。这两个账户都有显著的免费层，所以如果成本成为问题，那么恭喜！你的游戏起飞了！你还需要熟悉Git。你不需要成为专家，但你需要能够创建仓库并将它们推送到GitHub。如果你对Git一无所知，那么GitHub的*入门指南*是一个不错的起点：[https://docs.github.com/en/get-started](https://docs.github.com/en/get-started)。本章的示例代码可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10)找到。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3DsfDsA](https://bit.ly/3DsfDsA)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际应用：[https://bit.ly/3DsfDsA](https://bit.ly/3DsfDsA)
- en: Creating a CI/CD pipeline
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CI/CD管道
- en: When you run `npm run build` locally, a release build is put inside the `dist`
    directory. Theoretically, you could take that directory and copy it to a server
    somewhere to deploy your application. This will work provided that the server
    knows about the `wasm` `MIME` type, but copying to a directory manually is a very
    old-fashioned way of deploying software. Nowadays, we automate the build and deploy
    on a server, along with additional code that's been checked into source control.
    It's significantly more complicated than the old-fashioned way, so why is it better?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地运行`npm run build`时，发布构建版本会被放入`dist`目录中。理论上，你可以将那个目录复制到某个服务器上以部署你的应用程序。只要服务器知道`wasm`
    `MIME`类型，这就会起作用，但手动复制到目录是一种非常过时的软件部署方式。如今，我们在服务器上自动化构建和部署，包括已经提交到源代码控制中的额外代码。这比传统方式复杂得多，那么为什么它更好呢？
- en: 'The practice of automating the build this way is often referred to as CD and
    its definition is pretty big. Take a look at the following quote from [https://continuousdelivery.com](https://continuousdelivery.com):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式自动化构建的实践通常被称为CD，其定义相当广泛。请看以下来自[https://continuousdelivery.com](https://continuousdelivery.com)的引用：
- en: Continuous Delivery is the ability to get changes of all types—including new
    features, configuration changes, bug fixes, and experiments—into production, or
    into the hands of users, safely and quickly in a sustainable way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是将所有类型的更改（包括新功能、配置更改、错误修复和实验）安全、快速且可持续地部署到生产环境或用户手中的能力。
- en: 'You might read this and think that yes, copying from your machine''s `dist`
    directory onto a server is exactly that, but it isn''t. A few issues can happen
    when deploying manually. We''ve listed a few of them here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会读到这里并认为，从你的机器的 `dist` 目录复制到服务器上确实是那样，但事实并非如此。在手动部署时可能会出现一些问题。我们在这里列出了一些：
- en: The documentation could be wrong or lacking, meaning only one person knows how
    to deploy.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档可能错误或缺失，意味着只有一个人知道如何部署。
- en: The deployed code might not be the same as the code in source control.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的代码可能与源控制中的代码不同。
- en: Deployments might only work based on a local configuration, such as the version
    of `rustc` that exists on an individual's machine.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署可能仅基于本地配置，例如个人机器上存在的 `rustc` 版本。
- en: 'There are many more reasons why you don''t simply want to run `npm run build`
    locally and then copy/paste to a server. But when a team is small, it''s very
    tempting to say, "I''ll worry about it later." Instead of listening to that little
    voice, let''s try to think about the qualities of a deployment that are safe and
    quick, as the definition says. We can start with the opposite of some of the preceding
    bullet points. If those are reasons why a manual deployment does not qualify as
    CD, then a process that does qualify would be able to do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多原因说明为什么你不应该在本地简单地运行 `npm run build` 然后复制粘贴到服务器上。但当一个团队规模较小时，说“我稍后再处理”是非常诱人的。而不是听从那个小声音，让我们尝试思考部署的哪些特性是安全且快速的，正如定义所说。我们可以从一些前面的要点相反开始。如果这些是手动部署不满足
    CD 的原因，那么一个符合资格的过程将能够做到以下几点：
- en: Automate the process so that it is repeatable by everybody on the team.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化流程，以便团队中的每个人都可以重复执行。
- en: Always deploy from source control.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是从源控制中部署。
- en: Declare the configuration in source control, so it's never incorrect.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源控制中声明配置，以确保它永远不会错误。
- en: 'There''s a lot more to a proper CD process than the preceding list. In fact,
    a "perfect" CD is often more of a goal to be reached than an end state that you
    hit. Since we''re a one-person band, we won''t be hitting every single bullet
    point from the *Continuous Delivery* book ([https://amzn.to/32bf9bt](https://amzn.to/32bf9bt)),
    but we will be making a `main`, it will deploy to a production site. For this,
    we''ll use two technologies: GitHub Actions and Netlify.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的 CD 流程远不止前面列表中的内容。事实上，“完美”的 CD 往往更像是一个要达到的目标，而不是一个你达到的最终状态。由于我们是一个人的乐队，我们不会从
    *持续交付* 书籍（[https://amzn.to/32bf9bt](https://amzn.to/32bf9bt)）中的每一个要点开始，但我们会创建一个
    `main` 分支，并将其部署到生产站点。为此，我们将使用两种技术：GitHub Actions 和 Netlify。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CI refers to the practice of frequently merging code into the primary branch
    (`main` in Git parlance) and running all the tests to ensure the code still works.
    CI/CD is a shorthand for combining the practices of integration and delivery,
    although it's a bit redundant since CD includes CI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CI 指的是频繁地将代码合并到主分支（在 Git 术语中为 `main`）并运行所有测试，以确保代码仍然工作。CI/CD 是将集成和交付实践结合起来的缩写，尽管它有点冗余，因为
    CD 已经包含了 CI。
- en: GitHub Actions is a relatively new technology from GitHub. It is used for running
    tasks when branches are pushed to GitHub. It's well suited for running CI/CD because
    it's built right into the source control that we're already using and has a pretty
    good free tier. If you decide to use a different tool, such as Travis CI or GitLab
    CI/CD, you can use this implementation to guide how you would use those other
    tools. At this point, the similarities outnumber the differences.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是来自 GitHub 的相对较新的技术。它在将分支推送到 GitHub 时用于运行任务。它非常适合运行 CI/CD，因为它直接构建在我们已经使用的源控制系统中，并且有一个相当不错的免费层。如果你决定使用不同的工具，例如
    Travis CI 或 GitLab CI/CD，你可以使用这个实现来指导你如何使用那些其他工具。到目前为止，相似之处多于不同之处。
- en: After running CI on GitHub Actions, we'll deploy to Netlify. You might be wondering
    why we're using Netlify if our stated goal is to reduce the number of new technologies,
    and that's because, while we can deploy directly to GitHub Pages, that won't support
    creating test builds. In my opinion, an important part of a good CD process is
    the ability to create production-like builds that can be experimented on and tried
    out. Netlify will provide that out of the box. If your team has grown from beyond
    one person, you'll be able to try out the game as part of the process of reviewing
    code in a PR. Also, Netlify is set up to work with Wasm out of the box, so that's
    handy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 上运行 CI 后，我们将部署到 Netlify。你可能想知道，如果我们声称的目标是减少新技术数量，为什么我们还要使用
    Netlify，那是因为，虽然我们可以直接部署到 GitHub Pages，但那不会支持创建测试构建。在我看来，良好的 CD 流程的一个重要部分是能够创建可以实验和尝试的生产类似构建。Netlify
    将提供这种功能。如果你的团队已经超过一个人，你将能够在代码审查 PR 的过程中尝试游戏。此外，Netlify 默认支持 Wasm，这很方便。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In GitHub parlance, a PR is a branch that you wish to merge into the `main`
    branch. You create a PR and ask for a review. This branch can run other checks
    before being allowed to be merged into the `main` branch. Other tools, such as
    GitLab, call these **merge requests** (**MRs**). I tend to stick to the term PR
    because it's what I'm used to.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 的术语中，PR 是你希望合并到 `main` 分支的分支。你创建一个 PR 并请求审查。这个分支在允许合并到 `main` 分支之前可以运行其他检查。其他工具，如
    GitLab，将这些称为 **合并请求**（**MRs**）。我倾向于坚持使用 PR 这个术语，因为我已经习惯了。
- en: Our pipeline will be fairly simple. On every push to a PR branch, we'll check
    out the code, build and run the tests, then push to Netlify. If the build is a
    branch build, you'll get a temporary URL to test out that build. If the push is
    to `main`, then it will deploy a release build. In the future, you might want
    a little more rigor around production deployments, such as tagging releases with
    release notes, but this should be fine to get us started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线将会相当简单。在每次推送到 PR 分支时，我们将检出代码，构建并运行测试，然后将代码推送到 Netlify。如果构建是分支构建，你将获得一个临时
    URL 来测试该构建。如果推送的是 `main`，那么它将部署一个发布构建。在未来，你可能希望在生产部署方面有更多的严谨性，例如用发布说明标记发布，但这应该足以让我们开始。
- en: The first step is to make sure the build machine is using the same version of
    Rust that we're using locally. The `rustup` tool allows you to install multiple
    versions of the Rust compiler along with multiple toolchains, and you'll want
    to make sure that everybody on the team and along with CI is using the same version
    of Rust. Fortunately, `rustup` provides several different ways of doing this.
    We'll use the `toolchain` file, which is a file that specifies the toolchain for
    the current project. In addition to ensuring any machine that builds this crate
    will use the same version of Rust, it also documents the version of Rust used
    for development. Every Rust project should have one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保构建机器使用与我们本地相同的 Rust 版本。`rustup` 工具允许你安装多个 Rust 编译器的多个版本以及多个工具链，你需要确保团队中的每个人都以及
    CI 都使用相同的 Rust 版本。幸运的是，`rustup` 提供了多种实现方式。我们将使用 `toolchain` 文件，这是一个指定当前项目工具链的文件。除了确保任何构建此软件包的机器都将使用相同的
    Rust 版本外，它还记录了用于开发的 Rust 版本。每个 Rust 项目都应该有一个这样的文件。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this chapter, I discovered that I had made a mistake
    in the first draft of [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*. I hadn't documented the Rust version being used or ensured
    that the `wasm32-unknown-unknown` toolchain was installed. These are the exact
    kinds of errors that come up when you try to set up a CI build, because you've
    forgotten all of those early assumptions, and it's also one of the reasons why
    it's important to have a CI build. Sadly, you can always forget documentation,
    but the build machine can't lie. This is why I frequently set up CI at the beginning
    of a project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章时，我发现我在第一稿的 [*第一章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015) 中犯了一个错误，*Hello
    WebAssembly*。我没有记录正在使用的 Rust 版本，也没有确保安装了 `wasm32-unknown-unknown` 工具链。这些正是当你尝试设置
    CI 构建时出现的错误类型，因为你已经忘记了所有那些早期假设，这也是为什么拥有 CI 构建很重要的原因之一。遗憾的是，你总是会忘记文档，但构建机器不会说谎。这就是为什么我经常在项目开始时设置
    CI 的原因。
- en: 'The `toolchain` file is named `rust-toolchain.toml` and is kept at the root
    directory of the crate. We can create one that looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolchain` 文件命名为 `rust-toolchain.toml`，并保存在软件包的根目录中。我们可以创建一个如下所示的文件：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding toolchain says we'll use version `1.57.0` of the Rust compiler
    and the `wasm32-unknown-unknown` target, so we can be sure we'll be able to compile
    to WebAssembly. Now that we've ensured the version of Rust we're using, we can
    start setting up a CI/CD pipeline in GitHub Actions. You're welcome to try newer
    versions, but this has been tested using `1.57.0`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工具链说明我们将使用Rust编译器的`1.57.0`版本和`wasm32-unknown-unknown`目标，这样我们就可以确保能够编译成WebAssembly。现在我们已经确保了使用的Rust版本，我们就可以开始在GitHub
    Actions中设置CI/CD流水线。你可以尝试使用新版本，但这里使用的是经过测试的`1.57.0`。
- en: GitHub Actions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: 'Like many other CI/CD tools, GitHub Actions is defined by the configuration
    files in your source repository. When you create the first configuration file,
    called a *workflow* in Actions, it will get picked up by GitHub, which will then
    start a *runner*. You can see the output in the **Actions** tab of a GitHub repository.
    The following screenshot shows what the tab looked like for me while writing this
    chapter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多其他CI/CD工具一样，GitHub Actions是由你的源仓库中的配置文件定义的。当你创建第一个配置文件，在Actions中称为*工作流程*时，GitHub会将其识别，然后启动一个*运行器*。你可以在GitHub仓库的**操作**标签页中查看输出。以下截图显示了我在编写本章时该标签页的样子：
- en: '![Figure 10.1 – A green build](img/Figure_10.01_B17151.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 绿色构建](img/Figure_10.01_B17151.jpg)'
- en: Figure 10.1 – A green build
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 绿色构建
- en: This is an example workflow being run on GitHub, where I have updated the version
    of the deployment to use the LTS version of Node.js. It's a little unfortunate
    that you have to go to the **Actions** tab to see the result of your *workflows*,
    but I suppose marketing won out. It's also a little confusing to hear the terms
    *workflow* and *pipeline* thrown around. A *workflow* is a specific GitHub Actions
    term referring to a series of steps run on its infrastructure via the configuration
    we'll build next. A *pipeline* is a CD term referring to a series of steps that
    are needed to deploy software. So, I can have a pipeline made up of one or more
    workflows if I'm running it on GitHub Actions and using their terminology. This
    pipeline will be made up of one workflow, so you can use them interchangeably.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在GitHub上运行的示例工作流程，其中我已更新部署版本以使用Node.js的长周期版本。你必须去**操作**标签页查看*工作流程*的结果，这有点遗憾。我想营销赢了。听到*工作流程*和*流水线*这样的术语也有些令人困惑。*工作流程*是GitHub
    Actions的一个特定术语，指的是通过我们接下来要构建的配置在其基础设施上运行的一系列步骤。*流水线*是CD术语，指的是部署软件所需的一系列步骤。所以，如果我在GitHub
    Actions上运行并使用他们的术语，我可以有一个由一个或多个工作流程组成的流水线。这个流水线将由一个工作流程组成，所以你可以互换使用它们。
- en: 'To begin building our pipeline, we''ll need to ensure we have a GitHub repository
    for Walk the Dog. You probably already have one, but if you don''t, you have two
    options to choose from:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建我们的流水线，我们需要确保我们有一个用于“遛狗”的GitHub仓库。你可能已经有了，如果没有，你有两个选择：
- en: Create a new repository from your existing code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有的代码创建一个新的仓库。
- en: Fork the example code.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分叉示例代码。
- en: You can do either, although it would be a shame if the code you've been writing
    all along didn't exist in a repository somewhere. If you do fork from my repository,
    then make sure you fork from the [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)*,
    Testing, Debugging, and Performance* sample code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9).
    Otherwise, all the work will be done for you. In either case, from now on, I'll
    assume you have your code in a repository on GitHub.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择其中之一，但如果你一直写的代码在某处仓库中不存在，那就太遗憾了。如果你决定从我的仓库中分叉，那么请确保你从[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)*，测试、调试和性能*的示例代码[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9)进行分叉。否则，所有的工作都将为你完成。在任何情况下，从现在开始，我将假设你的代码已经在GitHub上的某个仓库中。
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If, at any point, you find yourself confused, you can cross-check the GitHub
    Actions documentation at [https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).
    We'll try to keep the workflow simple, so you won't need to be an Actions expert.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你感到困惑，你可以查阅GitHub Actions文档[https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions)。我们将尽量保持工作流程简单，所以你不需要成为Actions专家。
- en: 'We can start setting up a workflow with a kind of "Hello World" for GitHub
    Actions. The workflow will simply check the code, and it should turn green almost
    immediately after pushing. Create a file, named `.github/workflows/build.yml`,
    and add the following YAML to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一种 GitHub Actions 的“Hello World”来开始设置工作流程。这个工作流程将简单地检查代码，在推送后几乎立即变绿。创建一个名为
    `.github/workflows/build.yml` 的文件，并向其中添加以下 YAML：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**YAML** (**Yet Another Markup Language**) is the markup language of many CI/CD
    pipelines. If you''ve never seen it before, note that it is whitespace sensitive.
    This means that, sometimes, if you copy/paste it from one file to another or from
    a book into code, it might not be syntactically correct. Here, I''m using two
    spaces per tab, which is the standard format, and YAML does not allow tab characters.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML**（**另一种标记语言**）是许多 CI/CD 管道的标记语言。如果你以前从未见过它，请注意它对空白字符敏感。这意味着，有时如果你从文件复制粘贴到另一个文件，或者从一本书复制到代码中，它可能不是语法正确的。在这里，我每个制表符使用两个空格，这是标准格式，YAML
    不允许使用制表符。'
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: YAML is mostly self-explanatory, and it's also not the important takeaway from
    this chapter. So, if there's some YAML syntax that confuses you, it's probably
    not worth worrying about. But just in case, there is a pretty good YAML cheat
    sheet at [https://quickref.me/yaml](https://quickref.me/yaml).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 主要是可以自我解释的，而且它也不是本章的重要收获。所以，如果你对某些 YAML 语法感到困惑，可能不值得担心。但以防万一，有一个相当不错的 YAML
    技巧表可以在 [https://quickref.me/yaml](https://quickref.me/yaml) 找到。
- en: 'For the most part, you can read YAML as a list of key-value pairs. This workflow
    starts with the `on` key, which will run this workflow on every `push` event.
    It''s an array, so you can set up workflows for multiple events, but we won''t
    be doing that. The next key, `name`, gives the workflow a name. Then, we add the
    `jobs` key, which will only have one job. In our case, it is `build`. We specify
    that our job runs on `ubuntu-latest` with the `runs-on` key. Then, finally, we
    define its list of steps. This job currently only has one step, `uses: actions/checkout@v2`,
    and that''s worth explaining in more depth. Each step can either be a shell command
    or—you guessed it—an *action*. You can create your own actions, but most actions
    are created by the GitHub community; they can be found in the GitHub Actions marketplace.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在大多数情况下，你可以将 YAML 读取为键值对的列表。这个工作流程从 `on` 键开始，它将在每次 `push` 事件上运行这个工作流程。它是一个数组，所以你可以为多个事件设置工作流程，但我们不会这么做。下一个键
    `name` 给工作流程一个名字。然后，我们添加 `jobs` 键，它将只有一个工作。在我们的例子中，它是 `build`。我们指定我们的工作在 `ubuntu-latest`
    上运行，使用 `runs-on` 键。然后，最后，我们定义它的步骤列表。这个工作目前只有一个步骤，`uses: actions/checkout@v2`，这值得深入解释。每个步骤可以是
    shell 命令，或者——你猜对了——一个 *动作*。你可以创建自己的动作，但大多数动作都是由 GitHub 社区创建的；它们可以在 GitHub Actions
    市场找到。'
- en: 'You might be able to guess that `actions/checkout@v2` checks the code, and
    you''d be right. But you''re probably wondering where that comes from and how
    you were supposed to know about it. That''s where the Actions marketplace comes
    in, which can be found at [https://github.com/marketplace?type=actions](https://github.com/marketplace?type=actions):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能够猜到 `actions/checkout@v2` 检查代码，而且你是对的。但你可能想知道它是从哪里来的，以及你应该如何知道它。这就是 Actions
    市场发挥作用的地方，可以在 [https://github.com/marketplace?type=actions](https://github.com/marketplace?type=actions)
    找到：
- en: '![Figure 10.2 – The Actions marketplace](img/Figure_10.02_B17151.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – Actions 市场place](img/Figure_10.02_B17151.jpg)'
- en: Figure 10.2 – The Actions marketplace
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Actions 市场place
- en: 'Your workflow is made up of a series of steps run in order, most of which are
    found on the GitHub marketplace. Don''t let the name "marketplace" fool you; actions
    don''t cost money. They are open source projects and free as in beer. Let''s dig
    into the first action we''ll be using ([https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作流程由一系列按顺序运行的步骤组成，其中大部分可以在 GitHub 市场找到。不要让“市场”这个名字欺骗了你；动作不需要花钱。它们是开源项目，免费如啤酒。让我们深入了解我们将要使用的第一个动作
    ([https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout))：
- en: '![Figure 10.3 – Checkout'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – Checkout'
- en: '](img/Figure_10.03_B17151.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.03_B17151.jpg)'
- en: Figure 10.3 – Checkout
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Checkout
- en: 'The checkout action can be found in almost every single workflow since it''s
    pretty hard to do anything without checking out the code first. If you browse
    this page, you''ll see there''s full-featured documentation for the action, along
    with a big green button that says **Use latest version**. If you click on that
    button, a small snippet is presented to you, showing you how to integrate the
    action into your workflow:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 检出操作几乎可以在每个工作流程中找到，因为它在没有首先检出代码的情况下很难做任何事情。如果你浏览这个页面，你会看到关于该操作的完整功能文档，以及一个写着**使用最新版本**的大绿色按钮。如果你点击那个按钮，会呈现一个小片段，展示如何将操作集成到你的工作流程中：
- en: '![Figure 10.4 – Copy and paste me!'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 复制并粘贴我！'
- en: '](img/Figure_10.04_B17151.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.04_B17151.jpg)'
- en: Figure 10.4 – Copy and paste me!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 复制并粘贴我！
- en: These actions are the building blocks of workflows. Setting up a CI/CD pipeline
    in GitHub Actions means searching through the marketplace, adding actions to your
    workflow, and reading the docs. This is significantly easier than the tangle of
    Bash scripts that I used in the past, although don't worry, you can call trusty
    Bash scripts, too.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作是工作流程的构建块。在GitHub Actions中设置CI/CD管道意味着在市场上搜索，将操作添加到你的工作流程中，并阅读文档。这比过去我使用的Bash脚本混乱要容易得多，尽管不必担心，你仍然可以调用可靠的Bash脚本。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I want to emphasize that this isn't meant to be taken as an endorsement of GitHub
    Actions over any other CI/CD solution. Nowadays, there are so many great tools
    for this kind of work that it's hard to recommend one tool over another. I've
    used Travis CI and GitLab CI/CD quite a bit over the years, and they are also
    great. That said, GitHub Actions is also pretty great.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调，这并不是要表明GitHub Actions优于其他任何CI/CD解决方案。如今，有这么多优秀的工具可以用于这项工作，很难推荐一个工具而不是另一个。多年来，我相当多地使用了Travis
    CI和GitLab CI/CD，它们也非常出色。话虽如此，GitHub Actions也非常出色。
- en: 'If you commit this change and push it to a branch (do *not* use `main` for
    now) inside your repository, you can check the **Actions** tab to see the workflow
    running successfully, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提交这个更改并将其推送到你的仓库内的一个分支（现在不要使用`main`），你可以检查**操作**选项卡以查看工作流程成功运行，如下面的截图所示：
- en: '![Figure 10.5 – Checking out the code](img/Figure_10.05_B17151.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 检出代码](img/Figure_10.05_B17151.jpg)'
- en: Figure 10.5 – Checking out the code
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 检出代码
- en: 'We have checked out the code, and now we need to build it on the GitHub *runner*.
    A runner is just a fancy name for a machine. To build Rust on your local machine,
    you need the `rustup` program with an installed compiler and toolchain. We could
    run a series of shell scripts; however, instead, we will look to see whether any
    Rust actions exist in the marketplace. I won''t hold you in suspense—there''s
    an entire library of Rust-related actions to be found at [https://actions-rs.github.io/](https://actions-rs.github.io/).
    It''s a great collection, and it will make it easier to create our build. We''ll
    add steps to do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检出了代码，现在我们需要在GitHub *runner*上构建它。runner只是一个机器的别称。要在本地机器上构建Rust，你需要安装`rustup`程序，并带有已安装的编译器和工具链。我们可以运行一系列shell脚本；然而，我们将查看市场上是否有任何Rust操作。我不会让你悬而未决——在[https://actions-rs.github.io/](https://actions-rs.github.io/)可以找到一个完整的Rust相关操作库。这是一个很棒的集合，这将使我们的构建更容易。我们将添加以下步骤：
- en: Install a toolchain ([https://actions-rs.github.io/#toolchain](https://actions-rs.github.io/#toolchain)).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装工具链 ([https://actions-rs.github.io/#toolchain](https://actions-rs.github.io/#toolchain))。
- en: Install wasm-pack ([https://actions-rs.github.io/#install](https://actions-rs.github.io/#install)).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装wasm-pack ([https://actions-rs.github.io/#install](https://actions-rs.github.io/#install))。
- en: Run Clippy ([https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check)).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Clippy ([https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check))。
- en: The preceding links will take you to the official documentation for each of
    the actions, all of which have been created and maintained by Nikita Kuznetsov
    ([https://svartalf.info/](https://svartalf.info/)). Since each action is specified
    in YAML, it can use any keys it likes. Potentially, this means a lot of flags
    and configurations to document, but we'll stick to the straightforward flag.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述链接将带你去每个操作的官方文档，所有这些文档都是由Nikita Kuznetsov ([https://svartalf.info/](https://svartalf.info/))创建和维护的。由于每个操作都在YAML中指定，它可以使用它喜欢的任何键。潜在地，这意味着有很多标志和配置需要记录，但我们将坚持使用简单的标志。
- en: 'So, what are we waiting for? Let''s add the step required to install a toolchain,
    as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么呢？让我们添加安装工具链所需的步骤，如下所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I''ve left the checkout step in the sample for reference, but the code we''ve
    added starts with `- uses: actions-rs/toolchain@v1`. The `-` character is important—that''s
    YAML syntax for an entry in a sequence. So, step 1 is the first `- uses: actions/checkout@v2`
    line. Step 2 begins with `uses: actions-rs/toolchain@v1`, which is the name of
    the action we are using. Note that the next line, `with:`, does not have a dash
    in front of it. That''s because it''s part of the same step, which is a YAML hash
    with the `uses:` and `hash:` keys. Those fields must line up because YAML is whitespace
    sensitive. If you''re still confused by YAML, I recommend you do not think about
    it too much; it''s really just a plain text markup format that works in the way
    it looks.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '我在示例中保留了 checkout 步骤以供参考，但我们添加的代码以 `- uses: actions-rs/toolchain@v1` 开始。`-`
    字符很重要——这是 YAML 语法中序列条目的表示。所以，步骤 1 是第一行 `- uses: actions/checkout@v2`。步骤 2 以 `uses:
    actions-rs/toolchain@v1` 开始，这是我们使用的动作的名称。请注意，下一行 `with:` 前面没有减号。这是因为它是同一步骤的一部分，这是一个具有
    `uses:` 和 `hash:` 键的 YAML 哈希。这些字段必须对齐，因为 YAML 对空白字符敏感。如果你对 YAML 仍然感到困惑，我建议你不要想得太多；它实际上只是一个简单的纯文本标记格式，它以它看起来的方式工作。'
- en: 'In turn, the `with` key is set to another map with the keys of `toolchain`,
    `target`, `override`, and `components`. They set the `toolchain` (1.57.0) and
    `target` (wasm32-unknown-unknown) values, and make sure they install the `clippy`
    component. Finally, the `override: true` flag ensures that this version of Rust
    is the one in this directory.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '依次，`with` 键被设置为另一个包含 `toolchain`、`target`、`override` 和 `components` 键的映射。它们设置了
    `toolchain`（1.57.0）和 `target`（wasm32-unknown-unknown）的值，并确保安装了 `clippy` 组件。最后，`override:
    true` 标志确保这个版本的 Rust 是在这个目录中的版本。'
- en: 'With this step, you''ve added the toolchain you need. However, if you try to
    run a build in the workflow, it will still fail because you haven''t installed
    `wasm-pack` onto the build machine. You can add that step next, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个步骤，你已经添加了所需的工具链。然而，如果你在工作流程中尝试运行构建，它仍然会失败，因为你还没有在构建机器上安装 `wasm-pack`。你可以按以下方式添加这个步骤：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You're probably starting to see the pattern. A new step is started with the
    `-` character, and it `uses` an action. In this case, it is `actions-rs/install@v0.1`.
    It's parameters are the `wasm-pack` crate, and version 0.9.1\. However, we also
    specify the important `use-tool-cache`, which will ensure that if that version
    of `wasm-pack` can use a pre-built binary, it will do so. This shaves several
    minutes off of your build, so use it whenever possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经开始看到模式了。一个新的步骤以 `-` 字符开始，并 `使用` 一个动作。在这种情况下，它是 `actions-rs/install@v0.1`。它的参数是
    `wasm-pack` 包，版本 0.9.1。然而，我们还指定了重要的 `use-tool-cache`，这将确保如果该版本的 `wasm-pack` 可以使用预构建的二进制文件，它将这样做。这可以节省你几分钟的构建时间，所以尽可能使用它。
- en: 'So, we''re ready to build WebAssembly, but there''s one more thing to do before
    we start worrying about building Wasm, and that''s running Clippy. When we ran
    it in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*, we did it once manually, but it''s important to get
    this kind of linting into the build so that you catch those kinds of errors early.
    Typically, I install this kind of check even on my solo projects, because I forget
    to run it locally. We can add that step like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们准备构建 WebAssembly，但在我们开始担心构建 Wasm 之前，还有一件事要做，那就是运行 Clippy。当我们它在 [*第 9 章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)
    中运行时，*测试、调试和性能*，我们手动运行了一次，但将这种代码检查集成到构建中以便及早捕获这类错误是很重要的。通常，我甚至在我的独立项目中也会安装这种检查，因为我忘记在本地运行它。我们可以像这样添加这个步骤：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, I''ve left the `name` field, which was taken straight from the
    [https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check)
    documentation. This is because that name will show up on the GitHub Actions UI
    when it runs, and I might forget what `clippy-check` is. The only parameter it
    needs is the `token` field, which is set to the magic `${{ secrets.GITHUB_TOKEN
    }}` field. That field will expand to your actual GitHub API token, which is automatically
    generated on each workflow run by GitHub Actions. That token is necessary because
    this action can actually annotate the commit with any warnings that were generated
    by Clippy, so it needs to be able to write to the repository. The following screenshot
    shows an example of this where I intentionally introduced a Clippy error:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我保留了 `name` 字段，它直接来自 [https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check)
    文档。这是因为当它运行时，这个名字将出现在 GitHub Actions UI 上，我可能会忘记 `clippy-check` 是什么。它需要的唯一参数是
    `token` 字段，设置为魔法 `${{ secrets.GITHUB_TOKEN }}` 字段。该字段将展开为你的实际 GitHub API 令牌，这是
    GitHub Actions 在每次工作流程运行时自动生成的。这个令牌是必要的，因为此操作实际上可以注释提交中 Clippy 生成的任何警告，因此它需要能够写入存储库。以下截图显示了这样一个例子，我故意引入了一个
    Clippy 错误：
- en: '![Figure 10.6 – A Clippy error in GitHub Actions](img/Figure_10.06_B17151.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – GitHub Actions 中的 Clippy 错误](img/Figure_10.06_B17151.jpg)'
- en: Figure 10.6 – A Clippy error in GitHub Actions
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – GitHub Actions 中的 Clippy 错误
- en: 'This error also shows up in the commit itself:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误也出现在提交本身中：
- en: '![Figure 10.7 – A Clippy error in the commit'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 提交中的 Clippy 错误'
- en: '](img/Figure_10.07_B17151.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.07_B17151.jpg)'
- en: Figure 10.7 – A Clippy error in the commit
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 提交中的 Clippy 错误
- en: This functionality is awesome, but don't introduce Clippy errors to show it
    off unless you're writing a book; otherwise, it's not safe. Now that we've checked
    the Rust code for idiomatic errors, it's time to build and run tests. Since this
    is a Wasm project, for that step, we're going to need Node.js.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能很棒，但除非你正在写一本书，否则不要引入 Clippy 错误来炫耀；否则，这并不安全。现在我们已经检查了 Rust 代码中的惯用错误，是时候构建和运行测试了。由于这是一个
    Wasm 项目，为此步骤，我们需要 Node.js。
- en: Node.js and webpack
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 和 webpack
- en: 'The `actions-rs` family of actions is for Rust code, hence the addition of
    `-rs` at the end of `actions`. So, we''re going to need to look elsewhere to install
    Node.js. Fortunately, installing Node is so common that it''s one of the default
    actions provided by GitHub. We can add another step to set up Node, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`actions-rs` 家族的操作是为 Rust 代码设计的，因此在 `actions` 的末尾添加了 `-rs`。因此，我们需要在其他地方查找来安装
    Node.js。幸运的是，安装 Node.js 是如此普遍，以至于它是 GitHub 提供的默认操作之一。我们可以添加另一个步骤来设置 Node.js，如下所示：'
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any of the actions provided by GitHub can be found in the `actions` repository,
    and this one is called `setup-node`. In this case, we only need one parameter,
    `node-version`, which I''ve set to the `setup-node` step. They look like the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 提供的任何操作都可以在 `actions` 存储库中找到，这个操作叫做 `setup-node`。在这种情况下，我们只需要一个参数，`node-version`，我已经将其设置为
    `setup-node` 步骤。它们看起来如下：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how none of these steps have a `uses` key—they just call `run`, which
    runs the command as written in the shell. Since `Node.js` is installed, you can
    safely assume `npm` is available, and install, test, and run the build as three
    more steps in your workflow. This is a great time to commit your workflow and
    give it a try.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些步骤中没有一个有 `uses` 键——它们只是调用 `run`，这会按照在 shell 中编写的命令运行。由于已经安装了 Node.js，你可以安全地假设
    `npm` 也是可用的，并在你的工作流程中作为三个额外的步骤安装、测试和运行构建。这是一个提交你的工作流程并尝试它的好时机。
- en: Tip
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before committing and pushing your code, it can be helpful to run it through
    a YAML syntax validator. This won't ensure that it's valid for GitHub Actions,
    but it will at least ensure that it's valid YAML syntax and prevent wasted time
    pushing simple errors in indentation. [https://onlineyamltools.com/validate-yaml](https://onlineyamltools.com/validate-yaml)
    is an example of a simple online one, and Visual Studio Code has a plugin for
    it at [https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交和推送代码之前，运行它通过一个 YAML 语法验证器可能会有所帮助。这不能保证它在 GitHub Actions 中有效，但至少可以确保它是有效的
    YAML 语法，并防止在缩进中推送简单的错误而浪费时间。[https://onlineyamltools.com/validate-yaml](https://onlineyamltools.com/validate-yaml)
    是一个简单的在线示例，Visual Studio Code 在 [https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml)
    提供了一个插件。
- en: 'This build might actually fail at `-run: npm test`, with the following error
    highlighted:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '这个构建可能会在`-run: npm test`时失败，以下错误被突出显示：'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*, we ran our browser-based tests with the `wasm-pack
    test --headless --chrome` command. The build script runs `npm test`, which corresponds
    to the test script in the `package.json` file that was created for us in [*Chapter
    1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*. If that
    filename doesn''t sound familiar, that''s because we haven''t spent any time in
    it. Open it up, and you''ll see the test entry, which should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)，“测试、调试和性能”中，我们使用`wasm-pack
    test --headless --chrome`命令运行了基于浏览器的测试。构建脚本运行`npm test`，这对应于在[*第1章*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015)，“Hello
    WebAssembly”中为我们创建的`package.json`文件中的测试脚本。如果这个文件名听起来不熟悉，那是因为我们还没有花时间在上面。打开它，你会看到测试条目，它应该看起来像这样：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding highlighted code, you can see that it runs `cargo test` and
    then `wasm-pack test --headless`, but without specifying a browser. There's our
    build error! You can fix that by adding `--chrome` to the list of parameters passed
    to `wasm-pack test` and pushing that up to GitHub.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面高亮的代码中，你可以看到它运行了`cargo test`然后是`wasm-pack test --headless`，但没有指定浏览器。这就是我们的构建错误！你可以通过将`--chrome`添加到传递给`wasm-pack
    test`的参数列表中，并将其推送到GitHub来修复它。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible that this code has been fixed in newer versions of the project
    skeleton, so you do not see this error. If that's the case, you're already finished—congratulations!
    It's still useful to understand what tasks are being run under the hood of `npm
    test`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能这个代码在项目骨架的新版本中已经被修复，所以你没有看到这个错误。如果是这样，你已经完成了——恭喜！了解`npm test`背后正在运行的任务仍然是有用的。
- en: At this point, you should have a build that takes about 4 minutes, which is
    a little longer than I'd like for a small project, but we'll leave optimizing
    the build to the DevOps team. You've completed the CI step of this section, and
    now you can move on to the CD part.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有一个大约需要4分钟的构建，这比我想的小项目要长一点，但我们把优化构建留给DevOps团队。你已经完成了本节CI步骤，现在可以继续CD部分。
- en: Deploying test and production builds
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署测试和生产构建
- en: For deployments, we'll use Netlify, which is a cloud computing company that
    specializes in `main`, it will perform the production build. Production is defined
    loosely here, as we won't go in great depth into tasks such as getting a custom
    domain for your app or monitoring for errors, but it's the version of the app
    that will be publicly available.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署，我们将使用Netlify，这是一家专注于`main`的云计算公司，它将执行生产构建。在这里，生产被定义得比较宽松，因为我们不会深入讨论诸如为您的应用获取自定义域名或监控错误等任务，但这是将公开可用的应用版本。
- en: In order to deploy from GitHub to Netlify, we'll have to do some wiring so that
    GitHub has access to push to your Netlify account, and we have a site to push
    to. So, we're going to use the Netlify CLI to set up a site and prepare it for
    GitHub pushes. We're not going to use the built-in Netlify-GitHub connection that
    Netlify provides because it doesn't work with repositories unless you are an administrator
    on them. In this case, it's also more applicable if you are using other Git providers
    since the Netlify CLI will work with any of them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从GitHub部署到Netlify，我们不得不做一些配置，以便GitHub可以访问您的Netlify账户，并且我们有一个可以推送的网站。因此，我们将使用Netlify
    CLI来设置一个网站并为其GitHub推送做准备。我们不会使用Netlify提供的内置Netlify-GitHub连接，因为它除非你是管理员，否则不适用于存储库。在这种情况下，如果你使用其他Git提供商，这也更适用，因为Netlify
    CLI可以与它们中的任何一个一起工作。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There's an argument to be made that we're not practicing CD here because we
    won't have our machine completely configured in a tool such as Ansible or Terraform.
    The Netlify configuration isn't disposable, so it's not CD or DevOps. That's true,
    but this is not a book about how to configure Netlify in code, so we're not going
    to concern ourselves with that here. We had to draw a line somewhere.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个论点可以提出，我们在这里没有练习CD，因为我们不会在我们的机器上完全配置像Ansible或Terraform这样的工具。Netlify配置是不可丢弃的，所以它不是CD或DevOps。这是真的，但这本书不是关于如何在代码中配置Netlify的，所以我们不会在这里关心这个问题。我们不得不在某处划一条线。
- en: The first step is to install the CLI itself, which can be installed with `npm
    install netlify-cli --save` running at the root directory. This will install `netlify-cli`
    locally, which is in the `node_modules` directory of this project, so it won't
    pollute your local environment. The `--save` flag automatically adds `netlify-cli`
    to the list of dependencies in `package.json`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装 CLI 本身，这可以通过在根目录下运行`npm install netlify-cli --save`来完成。这将本地安装`netlify-cli`，位于此项目的`node_modules`目录中，因此它不会污染你的本地环境。`--save`标志会自动将`netlify-cli`添加到`package.json`中依赖项列表。
- en: Tip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have trouble running the Netlify CLI, make sure you're using version
    `16.13.0` of Node.js or higher. There were issues with the earlier versions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 Netlify CLI 时遇到问题，请确保你使用的是 Node.js 的`16.13.0`版本或更高版本。早期版本存在一些问题。
- en: After installing the Netlify CLI, you'll need to call `npm exec netlify login`
    to log in to your Netlify account. At the time of writing, `npm exec` is the way
    to ensure you're using the local copy of the `netlify` command, but you could
    also use `npx` or directly call the copy in `node_modules\.bin`. This will probably
    change again in the future, so it pays to Google it. The important part is that
    you probably don't want to install a global version of the `netlify` command unless
    you know what you're doing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Netlify CLI 后，你需要调用`npm exec netlify login`来登录你的 Netlify 账户。在撰写本文时，`npm exec`是确保你使用本地`netlify`命令的方式，但你也可以使用`npx`或直接调用`node_modules\.bin`中的副本。这可能会在未来再次改变，所以最好在
    Google 上搜索一下。重要的是，除非你知道自己在做什么，否则你可能不想安装全局版本的`netlify`命令。
- en: 'When you call `npm exec netlify login`, it will take you through the web browser
    to complete the login process. Then, you''ll want to call `npm exec netlify init
    -- --manual`. The addition of `--` in the middle is important so that `--manual`
    is passed through to the `netlify` command and not to `npm exec`. You will want
    to choose `rust-games-webassembly`. Your build command is `npm run build`, and
    the directory to deploy is `dist`. You can accept the default settings until the
    instructions say **Give this Netlify SSH public key access to your repository**.
    Then, you''ll want to copy the provided key and add it to GitHub under your repository''s
    **Settings** | **Deploy keys** page, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`npm exec netlify login`时，它将通过网页浏览器引导你完成登录过程。然后，你将想要调用`npm exec netlify
    init -- --manual`。中间添加`--`很重要，这样`--manual`就会传递给`netlify`命令，而不是`npm exec`。你将想要选择`rust-games-webassembly`。你的构建命令是`npm
    run build`，要部署的目录是`dist`。你可以接受默认设置，直到说明说**给这个 Netlify SSH 公钥访问你的仓库**。然后，你将想要复制提供的密钥并将其添加到
    GitHub 下的你的仓库的**设置** | **部署密钥**页面，如下面的截图所示：
- en: '![Figure 10.8 – Deploying keys'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – 部署密钥'
- en: '](img/Figure_10.08_B17151.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.08_B17151.jpg)'
- en: Figure 10.8 – Deploying keys
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 部署密钥
- en: You can accept the default settings, but do not configure the `webhook` setting
    that is provided. While you can do this, I want to make sure we only push a test
    build if the build passes, so we'll add this to GitHub Actions instead. That also
    keeps more of the behavior inside source control. This is because we'll explicitly
    push to Netlify in a workflow step, whereas configuring through the GitHub GUI
    means there will be more settings we might forget about if we ever move the repository.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以接受默认设置，但不要配置提供的`webhook`设置。虽然你可以这样做，但我想要确保只有当构建通过时才推送测试构建，所以我们将这添加到 GitHub
    Actions 中。这也将更多的行为保留在源代码控制中。这是因为我们将在工作流程步骤中明确地推送到 Netlify，而通过 GitHub GUI 进行配置意味着可能会有更多我们可能会忘记的设置。
- en: When the command is complete, you should see a message that reads **Success!
    Netlify CI/CD Configured!**. It will tell you that branches will be automatically
    deployed when you push to them. Since we didn't set up the webhook, this is incorrect,
    and there's a little more still to do.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令完成时，你应该会看到一个显示**成功！Netlify CI/CD 已配置**的消息。它会告诉你，当你向这些分支推送时，它们将自动部署。由于我们没有设置
    webhook，这是不正确的，还有更多的事情要做。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, the CLI might have changed its interface since this book was published.
    The important takeaway is you want to create the site in Netlify, and do not want
    to set up a webhook because we'll be using GitHub Actions instead. If the choices
    have changed, you can look at the official Netlify documentation at [https://docs.netlify.com/cli/get-started/](https://docs.netlify.com/cli/get-started/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，自本书出版以来，CLI 可能已经更改了其界面。重要的是你想要在 Netlify 中创建网站，并且不想要设置 webhook，因为我们将使用 GitHub
    Actions。如果选项已更改，你可以查看官方 Netlify 文档，网址为 [https://docs.netlify.com/cli/get-started/](https://docs.netlify.com/cli/get-started/)。
- en: 'To add the step to deploy to Netlify, we''re going to need to add a step to
    the workflow. That step is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要将部署到 Netlify 的步骤添加到工作流程中，我们需要在工作流程中添加一个步骤。该步骤如下：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're using the action at `nwtgck/actions-netlify@v1.2` because it has the cool
    feature of commenting on the commit that does a deployment. There are other actions
    that use Netlify, and you could also just use the `runs` command after installing
    the CLI if you so choose. There are many options, and all of this should be considered
    as an example of one way to set up this workflow and not the actual way to set
    it up.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是 `nwtgck/actions-netlify@v1.2` 动作，因为它有一个酷炫的功能，就是可以在执行部署的提交上评论。还有其他使用 Netlify
    的动作，如果你愿意，你可以在安装 CLI 后使用 `runs` 命令。有很多选项，所有这些都应该被视为设置此工作流程的一种示例，而不是实际设置它的方式。
- en: The first few flags are somewhat self-explanatory. The build directory is `dist`
    so that's what we'll publish. The production branch is `main`, and we need `github-token`
    again so that the action can annotate the commits. The next three flags will enable
    a PR comment, telling you where the app was deployed to. Put that same comment
    on the comment, and then overwrite `pull-request-comment` if you deploy the same
    branch more than once. We've set all of these to true.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个标志有些是自我解释的。构建目录是 `dist`，所以这就是我们将要发布的。生产分支是 `main`，我们还需要再次使用 `github-token`，以便操作可以注释提交。接下来的三个标志将启用一个
    PR 注释，告诉你应用部署到了哪里。将相同的注释放在评论上，然后如果你部署同一个分支多次，覆盖 `pull-request-comment`。我们已经将这些全部设置为
    true。
- en: 'The two `env` fields are probably the most confusing, as they specify a `NETLIFY_AUTH_TOKEN`
    token and the `NETLIFY_SITE_ID` site ID that you don''t have yet. The site ID
    is the easier of the two to find, and you can get it through the GUI or the CLI.
    To get it from the CLI, run `npm exec netlify status` in Command Prompt. You should
    get an output that looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 `env` 字段可能是最令人困惑的，因为它们指定了一个你还没有的 `NETLIFY_AUTH_TOKEN` 令牌和 `NETLIFY_SITE_ID`
    网站ID。网站ID是两者中更容易找到的，你可以通过图形用户界面或命令行界面来获取它。要从命令行界面获取它，请在命令提示符中运行 `npm exec netlify
    status`。你应该会得到一个看起来像这样的输出：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last line displays your `NETLIFY_SITE_ID` site ID. You can then take that
    site ID and add it to the `Secrets` section of your GitHub repository, which is
    located in the `NETLIFY_SITE_ID`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示了你的 `NETLIFY_SITE_ID` 网站ID。然后你可以将那个网站ID添加到 GitHub 仓库的 `Secrets` 部分中，它位于
    `NETLIFY_SITE_ID`：
- en: '![Figure 10.9 – Setting the site ID in GitHub](img/Figure_10.09_B17151.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 在 GitHub 中设置网站 ID](img/Figure_10.09_B17151.jpg)'
- en: Figure 10.9 – Setting the site ID in GitHub
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 在 GitHub 中设置网站 ID
- en: 'Also, you''ll need a personal access token to access the deployment. That''s
    tricky to find in the Netlify UI, but it''s there under **User settings**, which
    you can find by clicking on your user icon in the upper-right corner of the screen:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要一个个人访问令牌来访问部署。在 Netlify UI 中找到它有点棘手，但它确实在**用户设置**下，你可以通过点击屏幕右上角的用户图标来找到它：
- en: '![Figure 10.10 – User settings'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – 用户设置'
- en: '](img/Figure_10.10_B17151.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B17151.jpg)'
- en: Figure 10.10 – User settings
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 用户设置
- en: 'Then, choose **Applications**, not **Security**, and you''ll see the **Personal
    access tokens** section, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择**应用程序**，而不是**安全**，你将看到**个人访问令牌**部分，如下面的截图所示：
- en: '![Figure 10.11 – The personal access token](img/Figure_10.11_B17151.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 个人访问令牌](img/Figure_10.11_B17151.jpg)'
- en: Figure 10.11 – The personal access token
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 个人访问令牌
- en: 'You can see the `Netlify Deploy` or something similar. Copy that token and
    add it to the secrets in GitHub, this time, named `NETLIFY_AUTH_TOKEN`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `Netlify Deploy` 或类似的内容。复制该令牌并将其添加到 GitHub 的秘密中，这次命名为 `NETLIFY_AUTH_TOKEN`：
- en: '![Figure 10.12 – Showing two secrets'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.12 – 显示两个密钥'
- en: '](img/Figure_10.12_B17151.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.12_B17151.jpg)'
- en: Figure 10.12 – Showing two secrets
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 显示两个密钥
- en: 'Once you''ve added those two keys, you can commit the changes to the workflow,
    push them up, and you will get an email from the GitHub Actions bot telling you
    that your app was deployed to a test URL. It''s also commented to the commit,
    which you can see in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了这两个键，你就可以将更改提交到工作流程，将它们推上去，你将收到来自 GitHub Actions 机器人的电子邮件，告诉你你的应用程序已被部署到一个测试
    URL。它也被注释到了提交中，你可以在下面的屏幕截图中看到：
- en: '![Figure 10.13 – Deployed to test'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.13 – 部署以测试'
- en: '](img/Figure_10.13_B17151.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.13 – 部署以测试](img/Figure_10.13_B17151.jpg)'
- en: Figure 10.13 – Deployed to test
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 部署以测试
- en: Alternatively, you can go to the sample repository where you can see the comment
    at [https://bit.ly/3DR1dS5](https://bit.ly/3DR1dS5). The deploy link in the commit
    message won't work anymore because it's a test URL, but it did work at one time.
    That leaves us with one other thing to test. So far, we've been pushing to a branch—at
    least, you should have been if you paid attention—but if we deploy to the `main`
    branch, we will get a production deploy. You can get your code over to `main`
    however you like, merge locally, and push or create a PR. In any case, you just
    need to push a branch to `main` and you should get a production deployment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问样本仓库，在那里你可以看到评论在 [https://bit.ly/3DR1dS5](https://bit.ly/3DR1dS5)。提交信息中的部署链接将不再工作，因为它是一个测试
    URL，但它曾经是有效的。这让我们还有另一件事要测试。到目前为止，我们一直在向一个分支推送——至少，如果你注意到了，你应该会这样——但如果我们将部署到 `main`
    分支，我们将得到一个生产部署。你可以以任何你喜欢的方式将你的代码推送到 `main`，本地合并，然后推送或创建一个 PR。无论如何，你只需要将一个分支推送到
    `main`，你应该会得到一个生产部署。
- en: I know I did—you can play Walk the Dog at [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/).
    We shipped!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我做到了——你可以在 [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/)
    上玩“Walk the Dog”。我们发布了！
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Did I mention we shipped? In this chapter, we built a small but functional CI/CD
    pipeline for the Walk the Dog game. We learned how to create a GitHub Actions
    workflow and took a tour of how to find actions in the marketplace. Additionally,
    we started creating both test and production deployments in Netlify. We even get
    emails when it's done! You could extend this process to do things such as only
    making the test build on a PR or adding integration tests, and you could use this
    as a model for other CI/CD pipelines on different systems. This chapter was short,
    but vital since games must actually ship.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到我们发布了吗？在本章中，我们为“Walk the Dog”游戏构建了一个小型但功能齐全的 CI/CD 管道。我们学习了如何创建 GitHub Actions
    工作流程，并参观了如何在市场上找到操作。此外，我们开始在 Netlify 上创建测试和生产部署。我们甚至在完成后会收到电子邮件！你可以扩展这个流程来做诸如仅在
    PR 上进行测试构建或添加集成测试之类的事情，你可以将其用作其他系统上不同 CI/CD 管道的模型。本章虽然简短，但至关重要，因为游戏实际上必须发布。
- en: Of course, while the game might be shipped, it's never finished. In the next
    chapter, we'll discuss some challenges that you can take on to make your version
    of Walk the Dog superior to the book version. I'm excited to see what you'll do!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虽然游戏可能已经发布，但它永远不会完成。在下一章中，我们将讨论一些你可以承担的挑战，以使你的“Walk the Dog”版本优于书本版本。我迫不及待地想看看你会做什么！
