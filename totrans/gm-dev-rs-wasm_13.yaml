- en: '*Chapter 10*: Continuous Deployment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional way to publish a game is to create a main copy of the build
    and ship it off to manufacturing. This was frequently referred to as **going gold**
    inside and outside of the gaming industry, and it still is if you're making a
    AAA game that's being shipped to consoles and sold in stores. The process is time-consuming
    and extremely expensive; fortunately, we don't have to do it! Walk the Dog is
    a web-based game that we need to ship to a website. Since we're deploying to the
    web, we can use all the best practices of the web, including continuous deployment,
    where we'll deploy a build whenever we want directly from source control.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a **Continuous Integration**/**Continuous Delivery** (**CI**/**CD**)
    pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying test and production builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this chapter is complete, you'll be able to ship your game to the web!
    How else will you become rich and famous?
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to a GitHub account, you''ll need a Netlify account. Both of these
    have significant free tiers, so if cost becomes a problem, then congratulations!
    Your game took off! You''ll also need to be familiar with Git. You don''t need
    to be an expert, but you''ll need to be able to create repositories and push them
    to GitHub. If Git is completely new to you, then the GitHub *Getting Started*
    guide is a good place to start: [https://docs.github.com/en/get-started](https://docs.github.com/en/get-started).
    The sample code for this chapter is available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_10).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3DsfDsA](https://bit.ly/3DsfDsA)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run `npm run build` locally, a release build is put inside the `dist`
    directory. Theoretically, you could take that directory and copy it to a server
    somewhere to deploy your application. This will work provided that the server
    knows about the `wasm` `MIME` type, but copying to a directory manually is a very
    old-fashioned way of deploying software. Nowadays, we automate the build and deploy
    on a server, along with additional code that's been checked into source control.
    It's significantly more complicated than the old-fashioned way, so why is it better?
  prefs: []
  type: TYPE_NORMAL
- en: 'The practice of automating the build this way is often referred to as CD and
    its definition is pretty big. Take a look at the following quote from [https://continuousdelivery.com](https://continuousdelivery.com):'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery is the ability to get changes of all types—including new
    features, configuration changes, bug fixes, and experiments—into production, or
    into the hands of users, safely and quickly in a sustainable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might read this and think that yes, copying from your machine''s `dist`
    directory onto a server is exactly that, but it isn''t. A few issues can happen
    when deploying manually. We''ve listed a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation could be wrong or lacking, meaning only one person knows how
    to deploy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployed code might not be the same as the code in source control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployments might only work based on a local configuration, such as the version
    of `rustc` that exists on an individual's machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more reasons why you don''t simply want to run `npm run build`
    locally and then copy/paste to a server. But when a team is small, it''s very
    tempting to say, "I''ll worry about it later." Instead of listening to that little
    voice, let''s try to think about the qualities of a deployment that are safe and
    quick, as the definition says. We can start with the opposite of some of the preceding
    bullet points. If those are reasons why a manual deployment does not qualify as
    CD, then a process that does qualify would be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automate the process so that it is repeatable by everybody on the team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always deploy from source control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the configuration in source control, so it's never incorrect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a lot more to a proper CD process than the preceding list. In fact,
    a "perfect" CD is often more of a goal to be reached than an end state that you
    hit. Since we''re a one-person band, we won''t be hitting every single bullet
    point from the *Continuous Delivery* book ([https://amzn.to/32bf9bt](https://amzn.to/32bf9bt)),
    but we will be making a `main`, it will deploy to a production site. For this,
    we''ll use two technologies: GitHub Actions and Netlify.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: CI refers to the practice of frequently merging code into the primary branch
    (`main` in Git parlance) and running all the tests to ensure the code still works.
    CI/CD is a shorthand for combining the practices of integration and delivery,
    although it's a bit redundant since CD includes CI.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions is a relatively new technology from GitHub. It is used for running
    tasks when branches are pushed to GitHub. It's well suited for running CI/CD because
    it's built right into the source control that we're already using and has a pretty
    good free tier. If you decide to use a different tool, such as Travis CI or GitLab
    CI/CD, you can use this implementation to guide how you would use those other
    tools. At this point, the similarities outnumber the differences.
  prefs: []
  type: TYPE_NORMAL
- en: After running CI on GitHub Actions, we'll deploy to Netlify. You might be wondering
    why we're using Netlify if our stated goal is to reduce the number of new technologies,
    and that's because, while we can deploy directly to GitHub Pages, that won't support
    creating test builds. In my opinion, an important part of a good CD process is
    the ability to create production-like builds that can be experimented on and tried
    out. Netlify will provide that out of the box. If your team has grown from beyond
    one person, you'll be able to try out the game as part of the process of reviewing
    code in a PR. Also, Netlify is set up to work with Wasm out of the box, so that's
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub parlance, a PR is a branch that you wish to merge into the `main`
    branch. You create a PR and ask for a review. This branch can run other checks
    before being allowed to be merged into the `main` branch. Other tools, such as
    GitLab, call these **merge requests** (**MRs**). I tend to stick to the term PR
    because it's what I'm used to.
  prefs: []
  type: TYPE_NORMAL
- en: Our pipeline will be fairly simple. On every push to a PR branch, we'll check
    out the code, build and run the tests, then push to Netlify. If the build is a
    branch build, you'll get a temporary URL to test out that build. If the push is
    to `main`, then it will deploy a release build. In the future, you might want
    a little more rigor around production deployments, such as tagging releases with
    release notes, but this should be fine to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to make sure the build machine is using the same version of
    Rust that we're using locally. The `rustup` tool allows you to install multiple
    versions of the Rust compiler along with multiple toolchains, and you'll want
    to make sure that everybody on the team and along with CI is using the same version
    of Rust. Fortunately, `rustup` provides several different ways of doing this.
    We'll use the `toolchain` file, which is a file that specifies the toolchain for
    the current project. In addition to ensuring any machine that builds this crate
    will use the same version of Rust, it also documents the version of Rust used
    for development. Every Rust project should have one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this chapter, I discovered that I had made a mistake
    in the first draft of [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*. I hadn't documented the Rust version being used or ensured
    that the `wasm32-unknown-unknown` toolchain was installed. These are the exact
    kinds of errors that come up when you try to set up a CI build, because you've
    forgotten all of those early assumptions, and it's also one of the reasons why
    it's important to have a CI build. Sadly, you can always forget documentation,
    but the build machine can't lie. This is why I frequently set up CI at the beginning
    of a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toolchain` file is named `rust-toolchain.toml` and is kept at the root
    directory of the crate. We can create one that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding toolchain says we'll use version `1.57.0` of the Rust compiler
    and the `wasm32-unknown-unknown` target, so we can be sure we'll be able to compile
    to WebAssembly. Now that we've ensured the version of Rust we're using, we can
    start setting up a CI/CD pipeline in GitHub Actions. You're welcome to try newer
    versions, but this has been tested using `1.57.0`.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many other CI/CD tools, GitHub Actions is defined by the configuration
    files in your source repository. When you create the first configuration file,
    called a *workflow* in Actions, it will get picked up by GitHub, which will then
    start a *runner*. You can see the output in the **Actions** tab of a GitHub repository.
    The following screenshot shows what the tab looked like for me while writing this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A green build](img/Figure_10.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A green build
  prefs: []
  type: TYPE_NORMAL
- en: This is an example workflow being run on GitHub, where I have updated the version
    of the deployment to use the LTS version of Node.js. It's a little unfortunate
    that you have to go to the **Actions** tab to see the result of your *workflows*,
    but I suppose marketing won out. It's also a little confusing to hear the terms
    *workflow* and *pipeline* thrown around. A *workflow* is a specific GitHub Actions
    term referring to a series of steps run on its infrastructure via the configuration
    we'll build next. A *pipeline* is a CD term referring to a series of steps that
    are needed to deploy software. So, I can have a pipeline made up of one or more
    workflows if I'm running it on GitHub Actions and using their terminology. This
    pipeline will be made up of one workflow, so you can use them interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin building our pipeline, we''ll need to ensure we have a GitHub repository
    for Walk the Dog. You probably already have one, but if you don''t, you have two
    options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new repository from your existing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fork the example code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do either, although it would be a shame if the code you've been writing
    all along didn't exist in a repository somewhere. If you do fork from my repository,
    then make sure you fork from the [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203)*,
    Testing, Debugging, and Performance* sample code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9).
    Otherwise, all the work will be done for you. In either case, from now on, I'll
    assume you have your code in a repository on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If, at any point, you find yourself confused, you can cross-check the GitHub
    Actions documentation at [https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).
    We'll try to keep the workflow simple, so you won't need to be an Actions expert.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start setting up a workflow with a kind of "Hello World" for GitHub
    Actions. The workflow will simply check the code, and it should turn green almost
    immediately after pushing. Create a file, named `.github/workflows/build.yml`,
    and add the following YAML to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**YAML** (**Yet Another Markup Language**) is the markup language of many CI/CD
    pipelines. If you''ve never seen it before, note that it is whitespace sensitive.
    This means that, sometimes, if you copy/paste it from one file to another or from
    a book into code, it might not be syntactically correct. Here, I''m using two
    spaces per tab, which is the standard format, and YAML does not allow tab characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: YAML is mostly self-explanatory, and it's also not the important takeaway from
    this chapter. So, if there's some YAML syntax that confuses you, it's probably
    not worth worrying about. But just in case, there is a pretty good YAML cheat
    sheet at [https://quickref.me/yaml](https://quickref.me/yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, you can read YAML as a list of key-value pairs. This workflow
    starts with the `on` key, which will run this workflow on every `push` event.
    It''s an array, so you can set up workflows for multiple events, but we won''t
    be doing that. The next key, `name`, gives the workflow a name. Then, we add the
    `jobs` key, which will only have one job. In our case, it is `build`. We specify
    that our job runs on `ubuntu-latest` with the `runs-on` key. Then, finally, we
    define its list of steps. This job currently only has one step, `uses: actions/checkout@v2`,
    and that''s worth explaining in more depth. Each step can either be a shell command
    or—you guessed it—an *action*. You can create your own actions, but most actions
    are created by the GitHub community; they can be found in the GitHub Actions marketplace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be able to guess that `actions/checkout@v2` checks the code, and
    you''d be right. But you''re probably wondering where that comes from and how
    you were supposed to know about it. That''s where the Actions marketplace comes
    in, which can be found at [https://github.com/marketplace?type=actions](https://github.com/marketplace?type=actions):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Actions marketplace](img/Figure_10.02_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The Actions marketplace
  prefs: []
  type: TYPE_NORMAL
- en: 'Your workflow is made up of a series of steps run in order, most of which are
    found on the GitHub marketplace. Don''t let the name "marketplace" fool you; actions
    don''t cost money. They are open source projects and free as in beer. Let''s dig
    into the first action we''ll be using ([https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Checkout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.03_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Checkout
  prefs: []
  type: TYPE_NORMAL
- en: 'The checkout action can be found in almost every single workflow since it''s
    pretty hard to do anything without checking out the code first. If you browse
    this page, you''ll see there''s full-featured documentation for the action, along
    with a big green button that says **Use latest version**. If you click on that
    button, a small snippet is presented to you, showing you how to integrate the
    action into your workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Copy and paste me!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.04_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Copy and paste me!
  prefs: []
  type: TYPE_NORMAL
- en: These actions are the building blocks of workflows. Setting up a CI/CD pipeline
    in GitHub Actions means searching through the marketplace, adding actions to your
    workflow, and reading the docs. This is significantly easier than the tangle of
    Bash scripts that I used in the past, although don't worry, you can call trusty
    Bash scripts, too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I want to emphasize that this isn't meant to be taken as an endorsement of GitHub
    Actions over any other CI/CD solution. Nowadays, there are so many great tools
    for this kind of work that it's hard to recommend one tool over another. I've
    used Travis CI and GitLab CI/CD quite a bit over the years, and they are also
    great. That said, GitHub Actions is also pretty great.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you commit this change and push it to a branch (do *not* use `main` for
    now) inside your repository, you can check the **Actions** tab to see the workflow
    running successfully, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Checking out the code](img/Figure_10.05_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Checking out the code
  prefs: []
  type: TYPE_NORMAL
- en: 'We have checked out the code, and now we need to build it on the GitHub *runner*.
    A runner is just a fancy name for a machine. To build Rust on your local machine,
    you need the `rustup` program with an installed compiler and toolchain. We could
    run a series of shell scripts; however, instead, we will look to see whether any
    Rust actions exist in the marketplace. I won''t hold you in suspense—there''s
    an entire library of Rust-related actions to be found at [https://actions-rs.github.io/](https://actions-rs.github.io/).
    It''s a great collection, and it will make it easier to create our build. We''ll
    add steps to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install a toolchain ([https://actions-rs.github.io/#toolchain](https://actions-rs.github.io/#toolchain)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install wasm-pack ([https://actions-rs.github.io/#install](https://actions-rs.github.io/#install)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run Clippy ([https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding links will take you to the official documentation for each of
    the actions, all of which have been created and maintained by Nikita Kuznetsov
    ([https://svartalf.info/](https://svartalf.info/)). Since each action is specified
    in YAML, it can use any keys it likes. Potentially, this means a lot of flags
    and configurations to document, but we'll stick to the straightforward flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are we waiting for? Let''s add the step required to install a toolchain,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve left the checkout step in the sample for reference, but the code we''ve
    added starts with `- uses: actions-rs/toolchain@v1`. The `-` character is important—that''s
    YAML syntax for an entry in a sequence. So, step 1 is the first `- uses: actions/checkout@v2`
    line. Step 2 begins with `uses: actions-rs/toolchain@v1`, which is the name of
    the action we are using. Note that the next line, `with:`, does not have a dash
    in front of it. That''s because it''s part of the same step, which is a YAML hash
    with the `uses:` and `hash:` keys. Those fields must line up because YAML is whitespace
    sensitive. If you''re still confused by YAML, I recommend you do not think about
    it too much; it''s really just a plain text markup format that works in the way
    it looks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the `with` key is set to another map with the keys of `toolchain`,
    `target`, `override`, and `components`. They set the `toolchain` (1.57.0) and
    `target` (wasm32-unknown-unknown) values, and make sure they install the `clippy`
    component. Finally, the `override: true` flag ensures that this version of Rust
    is the one in this directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this step, you''ve added the toolchain you need. However, if you try to
    run a build in the workflow, it will still fail because you haven''t installed
    `wasm-pack` onto the build machine. You can add that step next, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You're probably starting to see the pattern. A new step is started with the
    `-` character, and it `uses` an action. In this case, it is `actions-rs/install@v0.1`.
    It's parameters are the `wasm-pack` crate, and version 0.9.1\. However, we also
    specify the important `use-tool-cache`, which will ensure that if that version
    of `wasm-pack` can use a pre-built binary, it will do so. This shaves several
    minutes off of your build, so use it whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re ready to build WebAssembly, but there''s one more thing to do before
    we start worrying about building Wasm, and that''s running Clippy. When we ran
    it in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*, we did it once manually, but it''s important to get
    this kind of linting into the build so that you catch those kinds of errors early.
    Typically, I install this kind of check even on my solo projects, because I forget
    to run it locally. We can add that step like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, I''ve left the `name` field, which was taken straight from the
    [https://actions-rs.github.io/#clippy-check](https://actions-rs.github.io/#clippy-check)
    documentation. This is because that name will show up on the GitHub Actions UI
    when it runs, and I might forget what `clippy-check` is. The only parameter it
    needs is the `token` field, which is set to the magic `${{ secrets.GITHUB_TOKEN
    }}` field. That field will expand to your actual GitHub API token, which is automatically
    generated on each workflow run by GitHub Actions. That token is necessary because
    this action can actually annotate the commit with any warnings that were generated
    by Clippy, so it needs to be able to write to the repository. The following screenshot
    shows an example of this where I intentionally introduced a Clippy error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A Clippy error in GitHub Actions](img/Figure_10.06_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – A Clippy error in GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'This error also shows up in the commit itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – A Clippy error in the commit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.07_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – A Clippy error in the commit
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is awesome, but don't introduce Clippy errors to show it
    off unless you're writing a book; otherwise, it's not safe. Now that we've checked
    the Rust code for idiomatic errors, it's time to build and run tests. Since this
    is a Wasm project, for that step, we're going to need Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `actions-rs` family of actions is for Rust code, hence the addition of
    `-rs` at the end of `actions`. So, we''re going to need to look elsewhere to install
    Node.js. Fortunately, installing Node is so common that it''s one of the default
    actions provided by GitHub. We can add another step to set up Node, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of the actions provided by GitHub can be found in the `actions` repository,
    and this one is called `setup-node`. In this case, we only need one parameter,
    `node-version`, which I''ve set to the `setup-node` step. They look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice how none of these steps have a `uses` key—they just call `run`, which
    runs the command as written in the shell. Since `Node.js` is installed, you can
    safely assume `npm` is available, and install, test, and run the build as three
    more steps in your workflow. This is a great time to commit your workflow and
    give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Before committing and pushing your code, it can be helpful to run it through
    a YAML syntax validator. This won't ensure that it's valid for GitHub Actions,
    but it will at least ensure that it's valid YAML syntax and prevent wasted time
    pushing simple errors in indentation. [https://onlineyamltools.com/validate-yaml](https://onlineyamltools.com/validate-yaml)
    is an example of a simple online one, and Visual Studio Code has a plugin for
    it at [https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'This build might actually fail at `-run: npm test`, with the following error
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*, we ran our browser-based tests with the `wasm-pack
    test --headless --chrome` command. The build script runs `npm test`, which corresponds
    to the test script in the `package.json` file that was created for us in [*Chapter
    1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*. If that
    filename doesn''t sound familiar, that''s because we haven''t spent any time in
    it. Open it up, and you''ll see the test entry, which should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding highlighted code, you can see that it runs `cargo test` and
    then `wasm-pack test --headless`, but without specifying a browser. There's our
    build error! You can fix that by adding `--chrome` to the list of parameters passed
    to `wasm-pack test` and pushing that up to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It's possible that this code has been fixed in newer versions of the project
    skeleton, so you do not see this error. If that's the case, you're already finished—congratulations!
    It's still useful to understand what tasks are being run under the hood of `npm
    test`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a build that takes about 4 minutes, which is
    a little longer than I'd like for a small project, but we'll leave optimizing
    the build to the DevOps team. You've completed the CI step of this section, and
    now you can move on to the CD part.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying test and production builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For deployments, we'll use Netlify, which is a cloud computing company that
    specializes in `main`, it will perform the production build. Production is defined
    loosely here, as we won't go in great depth into tasks such as getting a custom
    domain for your app or monitoring for errors, but it's the version of the app
    that will be publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: In order to deploy from GitHub to Netlify, we'll have to do some wiring so that
    GitHub has access to push to your Netlify account, and we have a site to push
    to. So, we're going to use the Netlify CLI to set up a site and prepare it for
    GitHub pushes. We're not going to use the built-in Netlify-GitHub connection that
    Netlify provides because it doesn't work with repositories unless you are an administrator
    on them. In this case, it's also more applicable if you are using other Git providers
    since the Netlify CLI will work with any of them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There's an argument to be made that we're not practicing CD here because we
    won't have our machine completely configured in a tool such as Ansible or Terraform.
    The Netlify configuration isn't disposable, so it's not CD or DevOps. That's true,
    but this is not a book about how to configure Netlify in code, so we're not going
    to concern ourselves with that here. We had to draw a line somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to install the CLI itself, which can be installed with `npm
    install netlify-cli --save` running at the root directory. This will install `netlify-cli`
    locally, which is in the `node_modules` directory of this project, so it won't
    pollute your local environment. The `--save` flag automatically adds `netlify-cli`
    to the list of dependencies in `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble running the Netlify CLI, make sure you're using version
    `16.13.0` of Node.js or higher. There were issues with the earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the Netlify CLI, you'll need to call `npm exec netlify login`
    to log in to your Netlify account. At the time of writing, `npm exec` is the way
    to ensure you're using the local copy of the `netlify` command, but you could
    also use `npx` or directly call the copy in `node_modules\.bin`. This will probably
    change again in the future, so it pays to Google it. The important part is that
    you probably don't want to install a global version of the `netlify` command unless
    you know what you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call `npm exec netlify login`, it will take you through the web browser
    to complete the login process. Then, you''ll want to call `npm exec netlify init
    -- --manual`. The addition of `--` in the middle is important so that `--manual`
    is passed through to the `netlify` command and not to `npm exec`. You will want
    to choose `rust-games-webassembly`. Your build command is `npm run build`, and
    the directory to deploy is `dist`. You can accept the default settings until the
    instructions say **Give this Netlify SSH public key access to your repository**.
    Then, you''ll want to copy the provided key and add it to GitHub under your repository''s
    **Settings** | **Deploy keys** page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Deploying keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.08_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Deploying keys
  prefs: []
  type: TYPE_NORMAL
- en: You can accept the default settings, but do not configure the `webhook` setting
    that is provided. While you can do this, I want to make sure we only push a test
    build if the build passes, so we'll add this to GitHub Actions instead. That also
    keeps more of the behavior inside source control. This is because we'll explicitly
    push to Netlify in a workflow step, whereas configuring through the GitHub GUI
    means there will be more settings we might forget about if we ever move the repository.
  prefs: []
  type: TYPE_NORMAL
- en: When the command is complete, you should see a message that reads **Success!
    Netlify CI/CD Configured!**. It will tell you that branches will be automatically
    deployed when you push to them. Since we didn't set up the webhook, this is incorrect,
    and there's a little more still to do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the CLI might have changed its interface since this book was published.
    The important takeaway is you want to create the site in Netlify, and do not want
    to set up a webhook because we'll be using GitHub Actions instead. If the choices
    have changed, you can look at the official Netlify documentation at [https://docs.netlify.com/cli/get-started/](https://docs.netlify.com/cli/get-started/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the step to deploy to Netlify, we''re going to need to add a step to
    the workflow. That step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're using the action at `nwtgck/actions-netlify@v1.2` because it has the cool
    feature of commenting on the commit that does a deployment. There are other actions
    that use Netlify, and you could also just use the `runs` command after installing
    the CLI if you so choose. There are many options, and all of this should be considered
    as an example of one way to set up this workflow and not the actual way to set
    it up.
  prefs: []
  type: TYPE_NORMAL
- en: The first few flags are somewhat self-explanatory. The build directory is `dist`
    so that's what we'll publish. The production branch is `main`, and we need `github-token`
    again so that the action can annotate the commits. The next three flags will enable
    a PR comment, telling you where the app was deployed to. Put that same comment
    on the comment, and then overwrite `pull-request-comment` if you deploy the same
    branch more than once. We've set all of these to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two `env` fields are probably the most confusing, as they specify a `NETLIFY_AUTH_TOKEN`
    token and the `NETLIFY_SITE_ID` site ID that you don''t have yet. The site ID
    is the easier of the two to find, and you can get it through the GUI or the CLI.
    To get it from the CLI, run `npm exec netlify status` in Command Prompt. You should
    get an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line displays your `NETLIFY_SITE_ID` site ID. You can then take that
    site ID and add it to the `Secrets` section of your GitHub repository, which is
    located in the `NETLIFY_SITE_ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Setting the site ID in GitHub](img/Figure_10.09_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Setting the site ID in GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you''ll need a personal access token to access the deployment. That''s
    tricky to find in the Netlify UI, but it''s there under **User settings**, which
    you can find by clicking on your user icon in the upper-right corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – User settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – User settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, choose **Applications**, not **Security**, and you''ll see the **Personal
    access tokens** section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The personal access token](img/Figure_10.11_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The personal access token
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the `Netlify Deploy` or something similar. Copy that token and
    add it to the secrets in GitHub, this time, named `NETLIFY_AUTH_TOKEN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Showing two secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Showing two secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve added those two keys, you can commit the changes to the workflow,
    push them up, and you will get an email from the GitHub Actions bot telling you
    that your app was deployed to a test URL. It''s also commented to the commit,
    which you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Deployed to test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Deployed to test
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can go to the sample repository where you can see the comment
    at [https://bit.ly/3DR1dS5](https://bit.ly/3DR1dS5). The deploy link in the commit
    message won't work anymore because it's a test URL, but it did work at one time.
    That leaves us with one other thing to test. So far, we've been pushing to a branch—at
    least, you should have been if you paid attention—but if we deploy to the `main`
    branch, we will get a production deploy. You can get your code over to `main`
    however you like, merge locally, and push or create a PR. In any case, you just
    need to push a branch to `main` and you should get a production deployment.
  prefs: []
  type: TYPE_NORMAL
- en: I know I did—you can play Walk the Dog at [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/).
    We shipped!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did I mention we shipped? In this chapter, we built a small but functional CI/CD
    pipeline for the Walk the Dog game. We learned how to create a GitHub Actions
    workflow and took a tour of how to find actions in the marketplace. Additionally,
    we started creating both test and production deployments in Netlify. We even get
    emails when it's done! You could extend this process to do things such as only
    making the test build on a PR or adding integration tests, and you could use this
    as a model for other CI/CD pipelines on different systems. This chapter was short,
    but vital since games must actually ship.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, while the game might be shipped, it's never finished. In the next
    chapter, we'll discuss some challenges that you can take on to make your version
    of Walk the Dog superior to the book version. I'm excited to see what you'll do!
  prefs: []
  type: TYPE_NORMAL
