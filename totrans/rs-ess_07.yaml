- en: Chapter 7. Organizing Code and Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start this chapter by discussing the large-scale code-organizing structures
    in Rust, namely modules and crates. We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visibility of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing modules and file hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing external crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting a public interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding external crates to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also touch upon how to build macros in order to generate code and save
    time and effort, particularly in these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using macros from crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we only looked at the situation where our code fitted in one file.
    However, when a project evolves, we will want to split the code across several
    files, for example, if we put all the data structures and methods that describe
    a certain functionality in the same file, how will the main code file be able
    to call these functions in other files?
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when we start using multiple functions in varied files, it sometimes
    happens that we want to use the same name for two different functions. How can
    we properly differentiate between such functions? How can we make it so that some
    functions are callable everywhere and others are not? For this, we need what other
    languages call namespaces and access modifiers; in Rust, this is done through
    the module system.
  prefs: []
  type: TYPE_NORMAL
- en: Building crates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the highest level of building crates, there is the crate. The Rust distribution
    contains a number of crates, such as the `std` crate of the standard library,
    which we have already used often. Other built-in crates are the `collections`
    crate, with the functionality to work with strings, vectors, lists, and key-value
    maps, and the `test` crate, with unit-testing and micro-benchmarking functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A crate is the equivalent of a package or library in other languages. It is
    also the unit of compilation; `rustc` only compiles one crate at a time. What
    does this mean? When our project has a code file containing a `main()` function,
    then it is clear that our project is an executable program (which is also called
    a binary) that starts execution in `main()`. For example, if we compile `structs.rs`
    as `rustc structs.rs, a .exe` file `structs.exe` will be produced in Windows (and
    equivalent formats on other operating systems) that can be executed on its own.
    This is the standard behavior when you invoke `rustc`. When working with Cargo
    (refer to [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Starting with Rust"),
    *Starting with Rust*), we have to indicate that we want a binary project at its
    creation with the `--bin` flag: `cargo new projname --bin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, often your intention is to write a project whose code will be called
    from other projects, a so-called shared library (this is a `.dll` file in Windows,
    a `.so` file in Linux, and a `.dylib` file in Mac OS X.) In this case, your code
    will only contain the data structures and functions to work on them. Then, you
    must explicitly indicate this to the compiler using the `--crate-type` flag with
    the `lib` option: `rustc --crate-type=lib structs.rs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting file is far smaller in size and is called `libstructs.rlib`;
    the suffix is now `.rlib` (for the Rust library) and `lib` is prepended before
    the filename. If you want the crate to have another name such as `mycrate`, then
    use the `--crate-name` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rustc --crate-type=lib --crate-name=mycrate structs.rs`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a `libmycrate.rlib` as the output file. An alternative to using
    the `rustc` flags is to put this information as an attribute at the top of the
    code file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `crate_type` attribute can take the `bin`, `lib`, `rlib`, `dylib`, or `staticlib`
    values, according to whether you want an executable binary or a library of a certain
    type that is dynamic or statically linked. (In general, when an `attr` attribute
    applies to a whole crate, the syntax to use in the code is `#![crate_attr]`.)
  prefs: []
  type: TYPE_NORMAL
- en: Each library used in an application is a separate crate. In any case, you need
    an executable (binary) crate that uses the library crates.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo's job is to handle crates (for more information on Cargo, refer to the
    *Working with Cargo* section of [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Starting
    with Rust"), *Starting with Rust*); it creates a library project by default. You
    can install other crates into your project from the crates repository at [https://crates.io](https://crates.io);
    in the *Adding external crates to a project* section of this chapter, we will
    see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Crates are the compiled entities that get distributed on machines to execute.
    All of the code of a crate is contained in an implicit root module. This code
    can then be split up by the developer into code units called modules, which in
    fact, form a hierarchy of submodules under the root module. This way the organization
    of our code can be greatly improved. An evident candidate for a module is the
    test code—we'll use this in the *The test module* section.
  prefs: []
  type: TYPE_NORMAL
- en: Modules can also be defined inside other modules as the so-called nested modules.
    Modules do not get compiled individually; only crates get compiled. All the module's
    code is inserted into the crate's source file before compilation starts.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we used built-in modules, such as `io`, `str`, and
    `vec` from the `std` crate. The `std` crate contains many modules and functions
    that are used in real projects; the most common types, traits, functions, and
    macros (such as `println!`) are declared in the prelude module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A module typically contains a collection of code items such as traits, structs,
    methods, other functions, and even nested modules. The module''s name defines
    a namespace for all the objects that it contains. We define a module with the
    `mod` keyword and a lowercase name (such as `game1`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similar as in Java each file is a module, for every code file the compiler defines
    an implicit module, even when it does not contain the `mod` keyword. As we will
    see in the *Importing modules and file hierarchy* section, such a code file can
    be imported into the current code file with `mod` filename. Suppose `game1` is
    the name of a module that contains a `func2` function. If you want to use this
    function in a code that is external to this module, you would address it as `game1::func2`.
    However, whether this is possible will depend on the visibility of `func2`.
  prefs: []
  type: TYPE_NORMAL
- en: The visibility of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Items in a module are by default, only visible in the module itself; they are
    private to the module. If you want to make an item callable from a code that is
    external to the module, you must explicitly indicate this by prefixing the item
    with `pub` (which stands for public). In the following code, trying to call `func1()`
    is not allowed by the compiler: ``error: function `func1` is private:``.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you call `func2()`, it will work without any problem because it
    is public, and this prints out: `You called func2 in game1!`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function in a nested module can only be called if it is public, provided
    the nested module itself is declared public, as shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints out: `You called subfunc1 in subgame1!`'
  prefs: []
  type: TYPE_NORMAL
- en: A function in a module must be prefixed with its module name when it is called.
    This distinguishes it from another function with the same name so that no name
    conflicts occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a struct is accessed from outside the module in which it is defined, it
    is only visible when it is declared with `pub`. Moreover, its fields are private
    by default, so you have to explicitly declare as `pub` the fields that you want
    to be visible outside. This is the encapsulation property (also called information
    hiding) from traditional object-oriented languages. In the following example,
    the name and age fields of the `Magician` struct belong to the public interface
    but `power` does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to the compiler error: `field ''power'' of struct ''game1::Magician''
    is private`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that we cannot make instances from a struct with private fields?
    Try to think of a way around this. (As a hint, think about a constructor-like
    `new` function; refer to `Chapter 7/code/priv_struct.rs`.)
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules and file hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `use` keyword in `use game1::func2;` imports a `func2` function from the
    `game1` module so that it can be simply called with its name, `func2()`. You can
    even give it a shorter name with `use game1::func2` as `gf2`; so that it can be
    called as `gf2()`.
  prefs: []
  type: TYPE_NORMAL
- en: When the `game1` module contains two (or more) functions such as `func2` and
    `func3` that we want to import, this can be done with `use game1::{func2, func3};`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to import all the (public) functions of the `game1` module, you
    can do it with `*`: `use game1::*;`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, using such a global import is not the best practice, except in modules
    for testing. The main reason for this is that a global import makes it harder
    to see where names are bound. Furthermore, they are forwards-incompatible, since
    new upstream exports can clash with existing names.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a module, `self::` and `super::` can be prepended to a path similar to
    `game1::func2` to distinguish between a function in the current module itself
    and a function in the parent scope, outside of the module. The `use` statements
    are preferably written at the top of the code file, so that they work for the
    whole of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the module was defined in the main source file itself;
    in most cases, a module will be defined in another source file. So, how do we
    import such modules? In Rust, we can insert the entire contents of a module''s
    source file into the current file by declaring the module at the top of the code
    (but after any `use` statements) like this: `mod modul1;`, this can be optionally
    preceded by `pub`. This statement will look for a `modul1.rs` file in the same
    folder as the current source file and import its code within the current code
    inside a `modul1` module. If a `modul1.rs` file is not found, it will look for
    a `mod.rs` file in the `modul1` subfolder and insert its code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple `import_modules.rs` example that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `modul1` subfolder, we have the `mod.rs` file that contains the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modul2.rs` file in the same folder as `import_modules.rs` contains the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these source files of the module don't contain the `mod` declaration
    anymore because they were already declared in `import_modules.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `import_modules` prints out the following output: `called func1 from
    modul1 and called func1 from modul2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you simply call `func1()` in `main()`? Now, the compiler doesn''t
    know which `func1` to call, from `modul1` or from `modul2`, resulting in the error:
    `unresolved name ''func1''` message. However, if we add `use modul1::func1` and
    then call `func1()`, it will work as the ambiguity is resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing external crates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Traits* section of [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*, we developed the `traits.rs` structs
    for `Alien`, `Zombie`, and `Predator` characters that implemented a `Monster`
    trait. The code file contained a `main()` function to make it executable. We will
    now incorporate this code (without the `main()` part) in a library project called
    monsters and see how we can call this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the project with cargo new monsters and create a folder structure in
    the `monsters/src/lib.rs` file with the `template` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove this code and replace it with the code from `traits.rs`, but omit the
    `main()` function. In addition, add a simple `print_from_monsters()` function
    to test whether you can call it from the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, compile the library with cargo build, producing a `libmonsters-hash.rlib`
    library file in the `target`/`debug` folder (where hash is a random string similar
    to `547968b7c0a4d435`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create a `main.rs` file in the `src` folder to make an executable file
    that can call into our `monsters` library and copy the original `main()` code
    from `traits.rs` in it, adding a call to `print_from_monsters()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a common design pattern—a library project containing an executable program
    that can be used to demonstrate or test the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cargo build` function will now compile both the projects if there are
    no problems. However, the code will not compile, and the compiler will give the
    error: `unresolved name ''print_from_monsters''` message, clearly the code for
    the function is not found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we have to do is make the library code available to our
    program, which can be done by placing the following statement at the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement will import all the (public) items contained in the crate monsters
    under a module with the same name. However, this is not enough; we must also indicate
    that the `print_from_monsters` function can be found in the `monsters` module.
    Indeed, the monsters crate creates an implicit module with the same name. So,
    we have to call our function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get the error: `function ''print_from_monsters'' is private` message,
    which tells us that the function is found, but it is inaccessible. This is easy
    to fix. In the *Visibility of Items* section, we saw how to remedy this; we must
    prefix the function header with `pub`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, this part of our code works! Open a terminal, go (`cd`) to the `target/debug`
    folder and start the monsters executable. This will give the output as `Printing
    from crate monsters!`.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that `extern crate abc` (with `abc` a crate name) is often used
    in code, but you will never see `extern crate std;` why does this happen? The
    reason is that `std` is imported by default in every other crate. For the same
    reason, the contents of the prelude module are imported by default in to every
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a public interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiler throws the following error at us: `error: Zombie does not name
    a structure`. Clearly, the code for the `Zombie` struct is not found. Since this
    struct also resides in the monsters module, the solution to fix this is easy;
    prefix `Zombie` with `monsters::` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another error: `struct ''Zombie'' is private`, makes it clear that we must
    mark the `Zombie` struct with `pub`, that is, `pub struct Zombie { … }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will get an error on the line that contains `zmb1.noise()`: `error:
    type ''monsters::Zombie''` does not implement any method in scope named `''noise''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The accompanying help note explains to us what to do and why we should do it:
    ``help: methods from traits can only be called if the trait is in scope; the following
    trait is implemented but not in scope, perhaps add a `use` for it:``'
  prefs: []
  type: TYPE_NORMAL
- en: '`help: candidate #1: use ''monsters::Monster''`. So, let''s add this to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last error—`error: trait ''Monster'' is private - source trait is private`—
    that we have to solve occurs at the `use` line. Again very logical; if we want
    to use a trait, it must be publicly visible: `p` `ub trait Monster { … }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, cargo build is successful, if we execute monsters the output will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This makes it clear that the things we want to make visible in our module (or
    put in another way, that we want to export) must be annotated with `pub`; they
    form the interface that our module exposes to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Adding external crates to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to use libraries written by others (that is, choose from the multitude of
    libraries available at [https://crates.io](https://crates.io)) in our project?
    Cargo makes this very easy.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to use both the `log` and the `mac` libraries in the monsters
    project. The `log` function is a simple logging framework by the Rust Project
    Developers that gives us a number of macros such as `info!`, `warn!`, and `trace!`
    to log information messages. The `mac` function is an amazing collection of useful
    macros, which is maintained by Jonathan Reem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get these libraries, we need to edit our `Cargo.toml` configuration file
    and add a `[dependencies]` section when it isn''t already present. Beneath it,
    we specify the versions of the libraries that we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A `*` character denotes that any version is okay, and the most recent version
    will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and, in the `monsters` folder, issue the `cargo build` command.
    Cargo will take care of locally installing and compiling the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding external crates to a project](img/image00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It will also automatically update the `Cargo.lock` file to register the installed
    versions of the libraries so that subsequent project builds will always use the
    same versions (here, `log v0.3.1` and `mac v0.0.1`). If you later want to update
    to the most recent version of a library, for example for the `log` library, do
    a cargo update `–p log` or a `cargo` update to update all libraries. This will
    download the latest crate versions for the crates that are indicated with the
    `*` version. If you want a higher version for a crate, change its version number
    in `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start using the libraries by importing their crates in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#[macro_use]` attribute allows the use of macros defined in the external
    crate. (See the next section for more information). Then, we can for example,
    use the `info!` macro from `crate mac` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The test module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s apply this code organization to a module that contains our tests. In
    a larger project, tests are separated from the application code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are collected in a `test` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests are collected in a `lib.rs` file in a `tests` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make a concrete example by using our `cube` function from [Chapter 3](part0032.xhtml#aid-UGI01
    "Chapter 3. Using Functions and Control Structures"), *Using Functions and Control
    Structures*, and start its project with cargo new cube. We must replace the code
    in `src\lib.rs` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`#[cfg(test)]` ensures that the test module is only compiled when testing.
    In the second line, we declare our `test` module, which is preceded by the `test`
    attribute. The code of this module goes into a `test.rs` file in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We need to use `super::*` to import all the functions that need to test; here,
    this is cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests go into a `lib.rs` file in a tests folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to import the `cube` crate with an `extern` command and qualify
    the `cube` function name with its module name, `cube` (or else do a `use cube::cube;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The test code will only be compiled and run when we give the `cargo test` command,
    which will give these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test module](img/image00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our two tests passed. The end of the output also shows that
    tests in the documentation are also executed if they are present.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are not new to you as we have already used them. Every time we called
    an expression that ended with an exclamation mark (`!`), we called a built-in
    macro; the `!` sign distinguishes it from a function. In our code until now, we
    have already used `println!`, `assert_eq!`, `panic!`, and `vec!` macros.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use macros?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros make powerful language or syntax extensions; therefore, they make metaprogramming
    possible. For example, Rust has a `regex!` macro that allows you to define regular
    expressions in your program, which are compiled while your code is compiled. This
    way the regular expressions are verified, they can be optimized at compile time,
    and there is no runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros can capture repetitive or resembling code patterns and replace them
    with other source code: the macro expands the original code into new code. This
    expansion happens early in compilation, before any static checking is done, so
    the resulting code is compiled together with the original code. In this sense,
    they resemble Lisp macros much more than C macros. Rust macros allow you to write
    **Don''t Repeat Yourself** (**DRY**) code by factoring out the common parts of
    functions. However, a macro is at a higher level than a function because a macro
    allows you to generate the code for many functions at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: A Rust developer can also write his/her own macros, replacing repetitive code
    with much simpler code and thereby automating tasks. On the other side of the
    spectrum, it could even make it possible to write domain-specific languages. Macro
    coding follows a specific set of declarative pattern-based rules. Rust's macro
    system is also hygienic, which means that no conflict is possible between the
    variables used in the macro and those outside the macro. Each macro expansion
    happens in a distinct syntax context, and each variable is tagged with the syntax
    context where it was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Macro code itself is harder to understand than normal Rust code, so it is not
    that easy to make. However, you won't code macros every day; if a macro is tested,
    just use it. The full story of macro writing extends into advanced regions of
    Rust, but in the following sections, we will discuss the basic techniques to develop
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: Developing macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic structure of a macro definition for a macro with the `mac1` name
    is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The definition of a macro is also done through a macro, that is, the `macro_rules`
    macro! As you can see a macro is similar to a match block as it defines one or
    more rules for pattern matching, and each rule ends with a semicolon. Every rule
    consists of a pattern before the `=>` sign (which also called a matcher) that
    is replaced with the expansion part during compilation, and not while executing
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `welcome!` macro expects no pattern and expands into a print
    statement by using the `println!` macro; this is simple, but it demonstrates how
    macros work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is invoked by adding an exclamation sign (`!`) to its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out: `Welcome to the Game!`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A matcher can contain an expression of the `$arg:frag` form:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$arg` function binds an `arg` meta-variable to a value when the macro is
    called. Variables used inside a macro such as `$arg`, are prefixed with a `$`
    sign to distinguish them from normal variables in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `frag` function is a *fragment specifier* and can be either `expr`, `item`,
    `block`, `stmt`, `pat`, `ty` (type), `ident`, `path`, or `tt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (You can find more information on the meaning of these fragments in the official
    documentation at [http://doc.rust-lang.org/1.0.0/book](http://doc.rust-lang.org/1.0.0/book).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other Rust literals (tokens) that appear in a matcher must match exactly.
    For example, the following `mac1` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When you call `mac1!(42);`, it will print out `arg is 42`. The `mac1` function
    looks at its argument, `42`, as an expression (`expr`) and binds `arg` to the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a `mac2` macro that triples its argument. Test it out for these arguments:
    5 and 2 + 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `mac3` macro that takes an identifier name and replaces it with a binding
    of that name to 42\. (As a hint, use `$arg:ident` instead of `$arg:expr; ident`
    is used for variable and function names.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `mac4` macro that when invoked like `mac4!("Where am I?");`, prints
    out `start - Where am I? - end`. (Refer to the example code in `Chapter 7/exercises/macro_ex.rs`.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repetition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What would we do if there is more than one argument? We will enclose the pattern
    with a `$(...)*`, where `*` means zero or more (instead of `*`, you can use `+`,
    which means one or more). For example, the following `printall` macro invokes
    `println!` on each of its arguments, which can be of the arbitrary type and are
    separated by `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When called with `printall!("hello", 42, 3.14);` it will print out: `hello
    / 42 / 3.14 /`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, each argument (separated by commas) is substituted by a corresponding
    invocation of `print!` that is separated by a `/`. Note that on the right-hand
    side, we have to make a code block of the resulting print statements by enclosing
    them in `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a `create_fn` macro to create a new function at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `stringify!` macro simply makes a string from its argument. Now, we can
    invoke this macro with `create_fn!(fn1);`. This statement does not sit inside
    `main()` or another function; it is transformed during compilation into the function
    definition. Then, a normal call to the `fn1()` function will call it, here printing
    `Called the function "fn1"()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `massert` macro, we mimic the behavior of the `assert!` macro,
    which does nothing when its expression argument is true but panics when it is
    false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For example, `massert!(1 == 42);` will print out `thread '<main>' panicked at
    'Assertion failed!'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following statements, we test whether the `v` vector contains certain
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unless` macro mimics an `unless` statement where a branch is executed
    if the `arg` condition is not true. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This should print out `v does not contain 25` because the condition is not true.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a one-line macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example combines the techniques that we have seen so far. In the *Attributes
    - Testing* section of [Chapter 3](part0032.xhtml#aid-UGI01 "Chapter 3. Using Functions
    and Control Structures"), *Using Functions and Control Structures*, we saw how
    to make a test function with the `#[test]` attribute. Let us create a `test_eq`
    macro that generates a test function when it is invoked with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want a test that fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument of `test_eq` is the test''s name and the second and third
    arguments are values to be compared for equality, so in general, the format is:
    `test_eq!(name, left, right);`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `name` is an identifier; `left` and `right` are expressions. Like the
    `create_fn` invocation, the `test_eq!` calls are written outside a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can compose our macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can create the test runner by calling `rustc --test macros.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the macros executable is run, it prints out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A macro can also be recursive and call itself in the expansion branch. This
    is useful for processing tree-structured input, for example, when parsing HTML
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Using macros from crates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we demonstrated at the end of the *Adding external crates to a project*
    section, loading all the macros from an external crate should done by preceding
    the extern crate `abc` with the `#[macro_use]` attribute. If you only need the
    `mac1` and `mac2` macros, you can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If the attribute is not present, no macros are loaded from `abc`. Moreover,
    inside the `abc` module, only macros defined with the `#[macro_export]` attribute
    can be loaded in another module. To distinguish macros with the same name in different
    modules, use the `$crate` variable in the macro. Within the code of a macro imported
    from an `abc` crate, the special `$crate` macro variable will expand to `::abc`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to structure modules into crates to make our
    code more flexible and modular. Now, you also know the basic rules for writing
    macros for more compact and less repetitive code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore the power of Rust when it comes to
    the concurrent and parallel execution of code, and how Rust also preserves memory
    safety in this area.
  prefs: []
  type: TYPE_NORMAL
