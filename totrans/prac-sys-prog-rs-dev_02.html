<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-17"><em class="italic">Chapter 1</em>: <a id="_idTextAnchor016"/>Tools of the Trade – Rust Toolchains and Project Structures</h1>
			<p>Rust, as a modern systems programming language, has many inherent characteristics that make it easier to write safe, reliable, and performant code. Rust also has a compiler that enables a relatively fearless code refactoring experience as a project grows in size and complexity. But any programming language in itself is incomplete without the toolchains that support the software development life cycle. After all, where would software engineers be without their tools?</p>
			<p>This chapter specifically discusses the Rust toolchain and its ecosystem, and techniques to structure code within Rust projects to write safe, testable, performant, documented, and maintainable code that is also optimized to run in the intended target environment.</p>
			<p>The following are the key learning outcomes for this chapter:</p>
			<ul>
				<li>Choosing the right configuration of Rust for your project</li>
				<li>Cargo introduction and project structure</li>
				<li>Cargo build management</li>
				<li>Cargo dependencies</li>
				<li>Writing test scripts and doing automated unit and integration testing </li>
				<li>Automating the generation of technical documentation</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to select the right project type and toolchain; organize project code efficiently; add external and internal libraries as dependencies; build the project for development, test, and production environments; automate testing; and generate documentation for your Rust code.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>Rustup must be installed in the local development environment. Use this link for installation: <a href="https://github.com/rust-lang/rustup">https://github.com/rust-lang/rustup</a>.</p>
			<p>Refer to the following link for official installation instructions: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>.</p>
			<p>After installation, check <strong class="source-inline">rustc</strong>, and <strong class="source-inline">cargo</strong> have been installed correctly with the following commands:</p>
			<p class="source-code">rustc --version </p>
			<p class="source-code">cargo --version</p>
			<p>You must have access to any code editor of your choice.</p>
			<p>Some of the code and commands in this chapter, especially those related to shared libraries and setting paths, require a Linux system environment. It is recommended to install a local virtual machine such as VirtualBox or equivalent with a Linux installation for working with the code in this chapter. Instructions to install VirtualBox can be found at <a href="https://www.virtualbox.org">https://www.virtualbox.org</a>.</p>
			<p>The Git repo for the examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01</a>.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Choosing the right Rust configuration for your project</h1>
			<p>When you <a id="_idIndexMarker000"/>start with Rust programming, you have to first select a Rust release channel and a Rust project type.</p>
			<p>This section discusses details of the Rust <em class="italic">release channels</em> and gives guidance on how to choose among them for your project.</p>
			<p>Rust also allows you to build different types of binaries – standalone executables, static libraries, and dynamic libraries. If you know upfront what you will be building, you can create the right project type with the scaffolding code generated for you.</p>
			<p>We will cover these in this section.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Choosing a Rust release channel</h2>
			<p>The Rust programming language is developed continually and there are three releases being developed<a id="_idTextAnchor020"/> <a id="_idIndexMarker001"/>simultaneously at any point in time, each called a <strong class="bold">release channel</strong>. Each channel <a id="_idIndexMarker002"/>has a purpose and has varying features and stability characteristics. The three release channels are <em class="italic">stable</em>, <em class="italic">beta</em>, and <em class="italic">nightly</em>. Unstable <a id="_idIndexMarker003"/>language features and libraries <a id="_idIndexMarker004"/>are developed in the <strong class="bold">nightly</strong> and <strong class="bold">beta</strong> channels, while stability <a id="_idIndexMarker005"/>guarantees are provided on the <strong class="bold">stable</strong> channel.</p>
			<p><strong class="bold">Rustup</strong> is the tool <a id="_idIndexMarker006"/>that installs the Rust compiler, the Rust Standard Library, the Cargo package manager, and other core tools for activities such as code formatting, testing, benchmarking, and documentation. All these tools are available in multiple flavors called <em class="italic">toolchains</em>. A <em class="italic">toolchain</em> is <a id="_idIndexMarker007"/>a combination of a <em class="italic">release channel</em> and a <em class="italic">host</em>, and optionally also has an associated archive date. </p>
			<p><em class="italic">Rustup</em> can install a toolchain from a <em class="italic">release channel</em>, or from other sources such as official archives <a id="_idIndexMarker008"/>and local builds. <em class="italic">Rustup</em> also determines the toolchain depending on the host platform. Rust is officially available on Linux, Windows, and macOS. Rustup thus is called a <em class="italic">tool multiplexer</em> as it <a id="_idIndexMarker009"/>installs and manages multiple toolchains, and in this sense is similar to <em class="italic">rbenv</em>, <em class="italic">pyenv</em>, or <em class="italic">nvm</em> in <em class="italic">Ruby</em>, <em class="italic">Python</em>, and <em class="italic">Node.js</em> respectively.</p>
			<p>Rustup manages the complexity associated with toolchains but makes the installation process fairly straightforward as it provides sensible defaults. These can later be modified by the developer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Rust's stable version is released every 6 weeks; for example, Rust 1.42.0 was released on March 12, 2020, and 6 weeks later to the day, Rust 1.43 was released on April 23, 2020.</p>
			<p class="callout">A new nightly version of Rust is released every day. Once every 6 weeks, the latest master branch of nightly becomes the beta version.</p>
			<p>Most Rust developers primarily use the <em class="italic">stable</em> channel. Beta channel releases are not used actively, but only to test for any regressions in the Rust language releases.</p>
			<p>The <em class="italic">nightly</em> channel is for active language development and is published every night. The <em class="italic">nightly</em> channel lets Rust develop new and experimental features and allows early adopters to test them before they are stabilized. The price to be paid for early access is that there may be breaking changes to these features before they get into stable releases. Rust uses feature flags to determine what features are enabled in a given nightly release. A user who wants to use a cutting-edge feature in nightly version has to annotate the code with the appropriate <em class="italic">feature flag</em>.</p>
			<p>An example of a feature flag is shown here:</p>
			<p class="source-code">#![feature(try_trait)]</p>
			<p>Note that <a id="_idIndexMarker010"/>beta and stable releases cannot use feature flags.</p>
			<p>Rustup is configured to use the stable channel by default. To work with other channels, here are <a id="_idIndexMarker011"/>a few commands. For a complete list, refer to the official link: <a href="https://github.com/rust-lang/rustup">https://github.com/rust-lang/rustup</a>.</p>
			<p>To install nightly Rust, use this command:</p>
			<p class="source-code">rustup toolchain install nightly</p>
			<p>To activate nightly Rust globally, use this command:</p>
			<p class="source-code">rustup default nightly</p>
			<p>To activate nightly at a directory level, use this command:</p>
			<p class="source-code">rustup override set nightly</p>
			<p>To get the version of the compiler in nightly Rust, use this command:</p>
			<p class="source-code">rustup run nightly rustc –-version</p>
			<p>To reset <strong class="source-inline">rustup</strong> to use the stable channel, use this command:</p>
			<p class="source-code">rustup default stable</p>
			<p>To show the installed toolchains and which is currently active, use this command:</p>
			<p class="source-code">rustup show</p>
			<p>To update the installed toolchains to the latest versions, use this command:</p>
			<p class="source-code">rustup update</p>
			<p>Note that once <strong class="source-inline">rustup default &lt;channel-name&gt;</strong> is set, other related tools, such as Cargo and Rustc, use the default channel set.</p>
			<p>Which Rust <a id="_idIndexMarker012"/>channel should you use for your project? For any <strong class="bold">production-bound</strong> projects, it is advisable to use only the <strong class="bold">stable</strong> release channel. For any <strong class="bold">experimental</strong> projects, the <strong class="bold">nightly</strong> or <strong class="bold">beta</strong> channels may be used, with caution as there may be breaking changes needed for the code in future releases.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Selecting a Rust project type</h2>
			<p>There are <a id="_idIndexMarker013"/>two basic types of projects in Rust: <strong class="bold">libraries</strong> and <strong class="bold">binaries</strong> (or executables).</p>
			<p>A <em class="italic">library</em> is a <a id="_idIndexMarker014"/>self-contained <a id="_idIndexMarker015"/>piece of code that is intended for use by other programs. The <a id="_idIndexMarker016"/>purpose of a library is to enable code reuse and speed up <a id="_idIndexMarker017"/>the development cycle by leveraging the hard work of other open source developers. Libraries, also <a id="_idIndexMarker018"/>called a <strong class="bold">library crate</strong> (or <strong class="bold">lib crate</strong>) in Rust, can be published to a public package repository (such as <strong class="source-inline">crates.io</strong>) that can be discovered and downloaded by other developers for use in their own programs. Program execution for a library crate begins in the <strong class="source-inline">src/lib.rs</strong> file.</p>
			<p>A <em class="italic">binary</em> is a standalone <a id="_idIndexMarker019"/>executable that <a id="_idIndexMarker020"/>may download and link other libraries into a single binary. A binary project type <a id="_idIndexMarker021"/>is also called a <strong class="bold">binary crate</strong> (or <strong class="bold">bin crate</strong>). Program execution for a bin crate starts in the <strong class="source-inline">main()</strong> function that is present in the <strong class="source-inline">src/main.rs</strong> file.</p>
			<p>It is important to determine whether you want to build a binary or a library program in Rust while initializing the project. We will see examples of these two types of projects later in this chapter. It's time to introduce the star tool and Swiss-Army knife in the Rust ecosystem, <em class="italic">Cargo</em>.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>Introducing Cargo and project structures</h1>
			<p>Cargo is the <a id="_idIndexMarker022"/>official build and dependency management tool for Rust. It has <a id="_idIndexMarker023"/>many of the features of the other popular tools in this segment, such as Ant, Maven, Gradle, npm, CocoaPods, pip, and yarn, but provides a far more seamless and integrated developer experience for compiling code, downloading and compiling dependent libraries (called <strong class="bold">crates</strong> in Rust), linking libraries, and building development <a id="_idIndexMarker024"/>and release binaries. It also performs the incremental build of the code to reduce the compilation time as the programs evolve. In addition, it creates an idiomatic project structure while creating new Rust projects.</p>
			<p>In short, Cargo as an integrated toolchain gives a seamless experience in the day-to-day tasks of creating a new project, building it, managing <a id="_idIndexMarker025"/>external dependencies, debugging, testing, generating documentation, and release management.</p>
			<p>Cargo is the tool that can be used to set up the basic project scaffolding structure for a new Rust project. Before <a id="_idIndexMarker026"/>we create a new Rust project with Cargo, let's first understand the options for organizing code within Rust projects:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B16405.jpg" alt="Figure 1.1 – Cargo project structure and hierarchy"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Cargo project structure and hierarchy</p>
			<p><em class="italic">Figure 1.1</em> shows how code <a id="_idIndexMarker027"/>can be organized within a Cargo-generated Rust project.</p>
			<p>The smallest standalone unit of organization of code in a Rust project is a <strong class="bold">function</strong>. (Technically, the smallest unit of code organization is a block of code, but it is part of a function.) A function can accept zero or more input parameters, performs processing, and optionally, returns a value. A set of functions are organized as a <strong class="bold">source file</strong> with a specific name, for example, <strong class="source-inline">main.rs</strong> is a source file.</p>
			<p>The next highest level of code organization is a <strong class="bold">module</strong>. Code within modules has its own unique namespace. A module can contain user-defined data types (such as structs, traits, and enums), constants, type aliases, other module imports, and function declarations. Modules can be nested within one another. Multiple module definitions can be defined within a single source file for smaller projects, or a module can contain code spread across multiple source files for larger projects. This type of organization is also referred to <a id="_idIndexMarker028"/>as a module system.</p>
			<p>Multiple modules can be organized into <strong class="bold">crates</strong>. Crates also serve as the unit of code sharing across Rust projects. A crate is either a <em class="italic">library</em> or a <em class="italic">binary</em>. A crate developed by one developer <a id="_idIndexMarker029"/>and published to a public repository can be reused by another <a id="_idIndexMarker030"/>developer or team. The crate root is the source file that the Rust compiler starts from. For binary crates, the crate root is <strong class="source-inline">main.rs</strong> and for library crates it is <strong class="source-inline">lib.rs</strong>.</p>
			<p>One or more crates can be combined into a <strong class="bold">package</strong>. A <em class="italic">package</em> contains a <strong class="source-inline">Cargo.toml</strong> file, which contains information on how to build the package, including downloading and linking the dependent crates. When Cargo is used to create a new Rust project, it creates a <em class="italic">package</em>. A <em class="italic">package</em> must contain at least one crate – either a library or a binary crate. A package may contain any number of binary crates, but it can contain either zero or only one library crate.</p>
			<p>As Rust projects grow in size, there may be a need to split up a package into multiple units and manage them independently. A set of related packages can be organized as a <strong class="bold">workspace</strong>. A <em class="italic">workspace</em> is a set of packages that share the same <strong class="source-inline">Cargo.lock</strong> file (containing details of specific versions of dependencies that are shared across all packages in the workspace) and output directory.</p>
			<p>Let's see a few examples to understand various types of project structures in Rust.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>Automating build management with Cargo</h1>
			<p>When <a id="_idIndexMarker031"/>Rust code is compiled and built, the generated binary can either be a standalone executable binary or a library that can be <a id="_idIndexMarker032"/>used by other projects. In this section, we will look at how Cargo can be used to create Rust binaries and libraries, and how to configure metadata in <strong class="source-inline">Cargo.toml</strong> to provide build instructions.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Building a basic binary crate</h2>
			<p>In this section, we will build a basic binary crate. A binary crate when built, produces an executable binary file. This is the default crate type for the cargo tool. Let's now look at the command to create a binary crate.</p>
			<ol>
				<li>The first step is <a id="_idIndexMarker033"/>to generate a Rust source package using the <strong class="source-inline">cargo new</strong> command.</li>
				<li>Run the <a id="_idIndexMarker034"/>following command in a terminal session inside your working directory to create a new package:<p class="source-code"><strong class="bold">cargo new --bin first-program &amp;&amp; cd first-program</strong></p><p>The <strong class="source-inline">--bin</strong> flag is to tell Cargo to generate a package that, when compiled, would produce a binary crate (executable).</p><p><strong class="source-inline">first-program</strong> is the name of the package given. You can specify a name of your choice.</p></li>
				<li>Once the command executes, you will see the following directory structure:<p class="figure-caption"> </p><div id="_idContainer007" class="IMG---Figure"><img src="image/Figure_1.2_B16405.jpg" alt="Figure 1.2 – Directory structure"/></div><p class="figure-caption">Figure 1.2 – Directory structure</p><p>The <strong class="source-inline">Cargo.toml</strong> file contains the metadata for the package: </p><p class="source-code">[package]  </p><p class="source-code">name = "first-program"  </p><p class="source-code">version = "0.1.0"  </p><p class="source-code">authors = [&lt;your email&gt;]  </p><p class="source-code">edition = "2018"</p><p>And the <strong class="source-inline">src</strong> directory contains one file called <strong class="source-inline">main.rs</strong>:</p><p class="source-code">fn main() {</p><p class="source-code">    println!("Hello, world!");</p><p class="source-code">}</p></li>
				<li>To generate a binary crate (or executable) from this package, run the following command:<p class="source-code"><strong class="bold">cargo build</strong></p><p>This command creates a folder called <strong class="source-inline">target</strong> in the project root and creates a binary crate (executable) with the same name as the package name (<strong class="source-inline">first-program</strong>, in our case) in the location <strong class="source-inline">target/debug</strong>.</p></li>
				<li>Execute the following <a id="_idIndexMarker035"/>from the command line:<p class="source-code"><strong class="bold">cargo run</strong></p><p>You will <a id="_idIndexMarker036"/>see the following printed to your console:</p><p class="source-code"><strong class="bold">Hello, world!  </strong></p><p class="callout-heading">Note on path setting to execute binaries</p><p class="callout">Note that <strong class="source-inline">LD_LIBRARY_PATH</strong> should be set to include the toolchain library in the path. Execute the following command for Unix-like platforms. If your executable fails with the error <strong class="bold">Image not found</strong>, for Windows, alter the syntax suitably:</p><p class="callout"><strong class="source-inline">export LD_LIBRARY_PATH=$(rustc --print sysroot)/lib:$LD_LIBRARY_PATH</strong></p><p class="callout">Alternatively, you can build and run code with one command – <strong class="source-inline">cargo run</strong>, which is convenient for development purposes.</p><p>By default, the name of the binary crate (executable) generated is the same as the name of the source package. If you wish to change the name of the binary crate, add the following lines to <strong class="source-inline">Cargo.toml</strong>:</p><p class="source-code">[[bin]]</p><p class="source-code">name = "new-first-program" </p><p class="source-code">path = "src/main.rs"</p></li>
				<li>Run the following in the command line:<p class="source-code"><strong class="bold">cargo run  –-bin new-first-program </strong></p><p>You will see a new executable with the name <strong class="source-inline">new-first-program</strong> in the <strong class="source-inline">target/debug</strong> folder. You will see <strong class="bold">Hello, world!</strong> printed to your console.</p></li>
				<li>A cargo package can <a id="_idIndexMarker037"/>contain the source for <a id="_idIndexMarker038"/>multiple binaries. Let's learn how to add another binary to our project. In <strong class="source-inline">Cargo.toml</strong>, add a new <strong class="source-inline">[[bin]]</strong> target below the first one:<p class="source-code">[[bin]]  </p><p class="source-code">name = "new-first-program"  </p><p class="source-code">path = "src/main.rs"  </p><p class="source-code">[[bin]]  </p><p class="source-code">name = "new-second-program"  </p><p class="source-code">path = "src/second.rs"</p></li>
				<li>Next, create a new file, <strong class="source-inline">src/second.rs</strong>, and add the following code:<p class="source-code">fn main() {</p><p class="source-code">    println!("Hello, for the second time!");</p><p class="source-code">}</p></li>
				<li>Run the following:<p class="source-code"><strong class="bold">cargo run --bin new-second-program</strong></p></li>
			</ol>
			<p>You will see the statement <strong class="bold">Hello, for the second time!</strong> printed to your console. You'll also find a new executable created in the <strong class="source-inline">target/debug</strong> directory with the name <strong class="source-inline">new-second-program</strong>.</p>
			<p>Congratulations! You have learned how to do the following:</p>
			<ul>
				<li>Create your first Rust source package and compile it into an executable binary crate </li>
				<li>Give a new <a id="_idIndexMarker039"/>name to the binary, different <a id="_idIndexMarker040"/>from the package name </li>
				<li>Add a second binary to the same cargo package</li>
			</ul>
			<p>Note that a <strong class="source-inline">cargo</strong> package can contain one or more binary crates.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Configuring Cargo</h2>
			<p>A cargo package has <a id="_idIndexMarker041"/>an associated <strong class="source-inline">Cargo.toml</strong> file, which is also <a id="_idIndexMarker042"/>called the <strong class="bold">manifest</strong>. </p>
			<p>The manifest, at a minimum, contains the <strong class="source-inline">[package]</strong> section but can contain many other sections. A subset of the sections are listed here:</p>
			<p><strong class="bold">Specifying output targets for the package</strong>: Cargo <a id="_idIndexMarker043"/>packages can have <a id="_idIndexMarker044"/>five types of targets:</p>
			<ul>
				<li><strong class="source-inline">[[bin]]</strong>: A binary target is an executable program that can be run after it is built.</li>
				<li><strong class="source-inline">[lib]</strong>: A library target produces a library that can be used by other libraries and executables.</li>
				<li><strong class="source-inline">[[example]]</strong>: This target is useful for libraries to demonstrate the use of external APIs to users through example code. The example source code located in the <strong class="source-inline">example</strong> directory can be built into executable binaries using this target.</li>
				<li><strong class="source-inline">[[test]]</strong>: Files located in the <strong class="source-inline">tests</strong> directory represent integration tests and each of these can be compiled into a separate executable binary.</li>
				<li><strong class="source-inline">[[bench]]</strong>: Benchmark <a id="_idIndexMarker045"/>functions defined in libraries and binaries are compiled into separate executables.</li>
			</ul>
			<p>For each of these targets, the configuration can be specified, including parameters such as the name of the target, the source file of the target, and whether you want cargo to automatically run test scripts and generate documentation for the target. You may recall that in the previous section, we changed the name and set the source file for the generated binary executable.</p>
			<p><strong class="bold">Specifying dependencies for the package</strong>: The source files in a package may depend on other internal or external libraries, which <a id="_idIndexMarker046"/>are also called <em class="italic">dependencies</em>. Each of <a id="_idIndexMarker047"/>these in turn may depend on other libraries and so on. Cargo downloads the list of dependencies specified under this section and links them to the final output targets. The various types of dependencies <a id="_idIndexMarker048"/>include the following:</p>
			<ul>
				<li><strong class="source-inline">[dependencies]</strong>: Package library or binary dependencies</li>
				<li><strong class="source-inline">[dev-dependencies]</strong>: Dependencies for examples, tests, and benchmarks</li>
				<li><strong class="source-inline">[build-dependencies]</strong>: Dependencies for build scripts (if any are specified)</li>
				<li><strong class="source-inline">[target]</strong>: This is for the cross-compilation of code for various target architectures. Note that this is not to be confused with the output targets of the package, which can be lib, bin, and so on.</li>
			</ul>
			<p><strong class="bold">Specifying build profiles</strong>: There <a id="_idIndexMarker049"/>are four types of profiles that can be <a id="_idIndexMarker050"/>specified while building a cargo package:</p>
			<ul>
				<li><strong class="source-inline">dev</strong>: The <strong class="source-inline">cargo build</strong> command uses the <strong class="source-inline">dev</strong> profile by default. Packages built with this option are optimized for compile-time speed.</li>
				<li><strong class="source-inline">release</strong>: The <strong class="source-inline">cargo build –-release</strong> command enables the release profile, which is suitable for production release, and is optimized for runtime speed.</li>
				<li><strong class="source-inline">test</strong>: The <strong class="source-inline">cargo test</strong> command uses this profile. This is used to build test executables.</li>
				<li><strong class="source-inline">bench</strong>: The <strong class="source-inline">cargo bench</strong> command creates the benchmark executable, which automatically runs all functions annotated with the <strong class="source-inline">#[bench]</strong> attribute.</li>
			</ul>
			<p><strong class="bold">Specifying the package as a workspace</strong>: A workspace is <a id="_idIndexMarker051"/>a unit of organization where multiple packages can be grouped together into a project and is useful to save disk space and compilation time when there are shared dependencies across a set of related packages. The <strong class="source-inline">[workspace]</strong> section can be used to define the list of packages that are part of the workspace.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Building a static library crate</h2>
			<p>We have seen how to <a id="_idIndexMarker052"/>create binary crates. Let's <a id="_idIndexMarker053"/>now learn how to create a library crate:</p>
			<p class="source-code"> cargo new --lib my-first-lib</p>
			<p>The default directory structure of a new cargo project is as follows:</p>
			<p class="source-code">├── Cargo.toml</p>
			<p class="source-code">├── src</p>
			<p class="source-code">│   └── lib.rs</p>
			<p>Add the following code in <strong class="source-inline">src/lib.rs</strong>:</p>
			<p class="source-code">pub fn hello_from_lib(message: &amp;str) {</p>
			<p class="source-code">    println!("Printing Hello {} from library",message);</p>
			<p class="source-code">}</p>
			<p>Run the following:</p>
			<p class="source-code">cargo build </p>
			<p>You will see the library built under <strong class="source-inline">target/debug</strong> and it will have the name <strong class="source-inline">libmy_first_lib.rlib</strong>.</p>
			<p>To invoke the function in this library, let's build a small binary crate. Create a <strong class="source-inline">bin</strong> directory under <strong class="source-inline">src</strong>, and a new file, <strong class="source-inline">src/bin/mymain.rs</strong>.</p>
			<p>Add the following code:</p>
			<p class="source-code">use my_first_lib::hello_from_lib;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Going to call library function");</p>
			<p class="source-code">    hello_from_lib("Rust system programmer");</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">use my_first_lib::hello_from_lib</strong> statement <a id="_idIndexMarker054"/>tells the compiler <a id="_idIndexMarker055"/>to bring the library function into the scope of this program.</p>
			<p>Run the following:</p>
			<p class="source-code">cargo run  --bin mymain </p>
			<p>You will see the <strong class="source-inline">print</strong> statement in your console. Also, the binary <strong class="source-inline">mymain</strong> will be placed in the <strong class="source-inline">target/debug</strong> folder along with the library we wrote earlier. The binary crate looks for the library in the same folder, which it finds in this case. Hence it is able to invoke the function within the library.</p>
			<p>If you want to place the <strong class="source-inline">mymain.rs</strong> file in another location (instead of within <strong class="source-inline">src/bin</strong>), then add a target in <strong class="source-inline">Cargo.toml</strong> and mention the name and path of the binary as shown in the following example, <a id="_idIndexMarker056"/>and move the <strong class="source-inline">mymain.rs</strong> file to the specified location:</p>
			<p class="source-code">[[bin]]  </p>
			<p class="source-code">name = "mymain"  </p>
			<p class="source-code">path = "src/mymain.rs"</p>
			<p>Run <strong class="source-inline">cargo run --bin mymain</strong> and you will see the <strong class="source-inline">println</strong> output in your console.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Automating dependency management</h1>
			<p>You learned in the previous <a id="_idIndexMarker057"/>section how Cargo <a id="_idIndexMarker058"/>can be used to <a id="_idIndexMarker059"/>set up the base project directory <a id="_idIndexMarker060"/>structure and scaffolding for a new project, and how to build various types of binary and library crates. We will look at the dependency management features of Cargo in this section.</p>
			<p>Rust comes with a built-in standard library consisting of language primitives and commonly used functions, but it is small by design (compared to other languages). Most real-world programs in Rust depend on additional external libraries to improve functionality and developer productivity. Any such external code that is used is a <em class="italic">dependency</em> for the program. Cargo makes it easy to specify and manage dependencies.</p>
			<p>In the Rust ecosystem, <em class="italic">crates.io</em> is the central public package registry for discovering and downloading <a id="_idIndexMarker061"/>libraries (called <strong class="bold">packages</strong> or <strong class="bold">crates</strong> in Rust). It is similar to <em class="italic">npm</em> in the <a id="_idIndexMarker062"/>JavaScript world. Cargo uses <strong class="source-inline">crates.io</strong> as the default package registry.</p>
			<p>Dependencies are specified in the <strong class="source-inline">[dependencies]</strong> section of <strong class="source-inline">Cargo.toml</strong>. Let's see an example.</p>
			<p>Start a new project with this command:</p>
			<p class="source-code">cargo new deps-example &amp;&amp; cd deps-example</p>
			<p>In <strong class="source-inline">Cargo.toml</strong>, make the following entry to include an external library:</p>
			<p class="source-code">[dependencies]  </p>
			<p class="source-code">chrono = "0.4.0"</p>
			<p><strong class="source-inline">Chrono</strong> is a datetime library. This is called a dependency because our <strong class="source-inline">deps-example</strong> crate depends on this external library for its functionality.</p>
			<p>When you run <strong class="source-inline">cargo build</strong>, cargo looks for a crate on <strong class="source-inline">crates.io</strong> with this name and version. If found, it downloads this crate along with all of its dependencies, compiles them all, and updates <a id="_idIndexMarker063"/>a file called <strong class="source-inline">Cargo.lock</strong> with the exact versions of packages downloaded. The <strong class="source-inline">Cargo.lock</strong> file is a generated file and not meant for editing.</p>
			<p>Each dependency in <strong class="source-inline">Cargo.toml</strong> is specified in a new line and takes the format <strong class="source-inline">&lt;crate-name&gt; = "&lt;semantic-version-number&gt;"</strong>. <strong class="bold">Semantic versioning or Semver</strong> has the form X.Y.Z, where X is <a id="_idIndexMarker064"/>the major version number, Y is the minor version, and Z is the patch version.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Specifying the location of a dependency</h2>
			<p>There are <a id="_idIndexMarker065"/>many ways to specify the location and version of dependencies in <strong class="source-inline">Cargo.toml</strong>, some of which are summarized here:</p>
			<ul>
				<li><strong class="bold">Crates.io registry</strong>: This is the default option and all that is needed is to specify the <a id="_idIndexMarker066"/>package name and version string as we did earlier in this section.</li>
				<li><strong class="bold">Alternative registry</strong>: While <strong class="source-inline">crates.io</strong> is the default registry, Cargo provides the <a id="_idIndexMarker067"/>option to use an alternate registry. The registry name has to be configured in the <strong class="source-inline">.cargo/config</strong> file, and in <strong class="source-inline">Cargo.toml</strong>, an entry is to be made with the registry name, as shown in the example here:<p class="source-code">[dependencies]     </p><p class="source-code"> cratename = { version = "2.1", registry = "alternate-</p><p class="source-code">     registry-name" }</p></li>
				<li><strong class="bold">Git repository</strong>: A Git repo <a id="_idIndexMarker068"/>can be specified as the dependency. Here is how to do it:<p class="source-code">[dependencies]</p><p class="source-code">chrono = { git = "https://github.com/chronotope/chrono" , </p><p class="source-code">    branch = "master" }</p><p>Cargo will get the repo at the branch and location specified, and look for its <strong class="source-inline">Cargo.toml</strong> file in order to fetch its dependencies.</p></li>
				<li><strong class="bold">Specify a local path</strong>: Cargo supports path dependencies, which means the library <a id="_idIndexMarker069"/>can be a sub-crate within the main cargo package. While building the main cargo package, the sub-crates that have also been specified as dependencies will be built. But dependencies with only a path dependency cannot be uploaded to the <em class="italic">crates.io</em> public registry.</li>
				<li><strong class="bold">Multiple locations</strong>: Cargo supports the option to specify both a registry version <em class="italic">and</em> either a <a id="_idIndexMarker070"/>Git or path location. For local builds, the Git or path version is used, and the registry version will be used when the package is published to <em class="italic">crates.io</em>.</li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Using dependent packages in source code</h2>
			<p>Once the dependencies are specified in the <strong class="source-inline">Cargo.toml</strong> file in any of the preceding formats, we can <a id="_idIndexMarker071"/>use the external library in the package code as shown in the following example. Add the following code to <strong class="source-inline">src/main.rs</strong>:</p>
			<p class="source-code">use chrono::Utc;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Hello, time now is {:?}", Utc::now());</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">use</strong> statement tells the compiler to bring the <strong class="source-inline">chrono</strong> package <strong class="source-inline">Utc</strong> module into the scope of this program. We can then access the function <strong class="source-inline">now()</strong> from the <strong class="source-inline">Utc</strong> module to print out the current date and time. The <strong class="source-inline">use</strong> statement is not mandatory. An alternative way to print datetime would be as follows:</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Hello, time now is {:?}", chrono::Utc::now());</p>
			<p class="source-code">}</p>
			<p>This would give the same result. But if you have to use functions from the <strong class="source-inline">chrono</strong> package multiple times in code, it is more convenient to bring <strong class="source-inline">chrono</strong> and required modules into scope once using the <strong class="source-inline">use</strong> statement, and it becomes easier to type.</p>
			<p>It is also <a id="_idIndexMarker072"/>possible to rename the imported package with the <strong class="source-inline">as</strong> keyword:</p>
			<p class="source-code">use chrono as time;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("Hello, time now is {:?}", time::Utc::now());</p>
			<p class="source-code">}</p>
			<p>For more <a id="_idIndexMarker073"/>details on managing dependencies, refer to the Cargo docs: <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html</a>.</p>
			<p>In this section, we have seen how to add dependencies to a package. Any number of dependencies can be added to <strong class="source-inline">Cargo.toml</strong> and used within the program. Cargo makes the dependency management process quite a pleasant experience.</p>
			<p>Let's now look at another useful feature of Cargo – running automated tests.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Writing and running automated tests</h1>
			<p>The Rust <a id="_idIndexMarker074"/>programming language has built-in support for writing <a id="_idIndexMarker075"/>automated tests.</p>
			<p>Rust tests are basically Rust functions that verify whether the other non-test functions written in <a id="_idIndexMarker076"/>the package work as intended. They basically invoke <a id="_idIndexMarker077"/>the other functions with the specified data and assert that the return values are as expected.</p>
			<p>Rust has two types of tests – unit tests and integration tests.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Writing unit tests in Rust</h2>
			<p>Create a new Rust package with the following command:</p>
			<p class="source-code">cargo new test-example &amp;&amp; cd test-example</p>
			<p>Write a <a id="_idIndexMarker078"/>new function that returns the process ID of the currently running process. We will look at the details of process handling in a later chapter, so you <a id="_idIndexMarker079"/>may just type in the following code, as the focus here is on writing unit tests:</p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    println!("{}", get_process_id());</p>
			<p class="source-code">}</p>
			<p class="source-code">fn get_process_id() -&gt; u32 {</p>
			<p class="source-code">    process::id()</p>
			<p class="source-code">}</p>
			<p>We have written a simple (silly) function to use the standard library process module and retrieve the process ID of the currently running process.</p>
			<p>Run the code using <strong class="source-inline">cargo check</strong> to confirm there are no syntax errors.</p>
			<p>Let's now write a unit test. Note that we cannot know upfront what the process ID is going to be, so all we can test is whether a number is being returned:</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn test_if_process_id_is_returned() {</p>
			<p class="source-code">    assert!(get_process_id() &gt; 0);</p>
			<p class="source-code">}</p>
			<p>Run <strong class="source-inline">cargo test</strong>. You will see that the test has passed successfully, as the function returns a non-zero positive integer.</p>
			<p>Note that we have written the unit tests in the same source file as the rest of the code. In order to tell the compiler that this is a test function, we use the <strong class="source-inline">#[test]</strong> annotation. The <strong class="source-inline">assert!</strong> macro (available in standard Rust library) is used to check whether a condition evaluates to true. There are two other macros available, <strong class="source-inline">assert_eq!</strong> and <strong class="source-inline">assert_ne!</strong>, which are used to test whether the two arguments passed to these macros are equal or not.</p>
			<p>A custom error message can also be specified:</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn test_if_process_id_is_returned() {</p>
			<p class="source-code">    assert_ne!(get_process_id(), 0, "There is error in code");</p>
			<p class="source-code">}</p>
			<p>To compile <a id="_idIndexMarker080"/>but not run the <a id="_idIndexMarker081"/>tests, use the <strong class="source-inline">--no-run</strong> option with the <strong class="source-inline">cargo test</strong> command.</p>
			<p>The preceding example has only one simple <strong class="source-inline">test</strong> function, but as the number of tests increases, the following problems arise:</p>
			<ul>
				<li>How do we write any helper functions needed for test code and differentiate it from the rest of the package code?</li>
				<li>How can we prevent the compiler from compiling tests as part of each build (to save time) and not include test code as part of the normal build (saving disk/memory space)?</li>
			</ul>
			<p>In order to provide more modularity and to address the preceding questions, it is idiomatic in Rust to group test functions in a <strong class="source-inline">test</strong> module:</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::get_process_id;</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn test_if_process_id_is_returned() {</p>
			<p class="source-code">        assert_ne!(get_process_id(), 0, "There is </p>
			<p class="source-code">            error in code");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here are the changes made to the code:</p>
			<ul>
				<li>We have moved the <strong class="source-inline">test</strong> function under the <strong class="source-inline">tests</strong> module.</li>
				<li>We have added the <strong class="source-inline">cfg</strong> attribute, which tells the compiler to compile test code only if we are trying to run tests (that is, only for <strong class="source-inline">cargo test</strong>, not for <strong class="source-inline">cargo build</strong>).</li>
				<li>There is a <strong class="source-inline">use</strong> statement, which brings the <strong class="source-inline">get_process_id</strong> function into the scope of the <strong class="source-inline">tests</strong> module. Note that <strong class="source-inline">tests</strong> is an inner module and so we use <strong class="source-inline">super:: prefix</strong> to bring the function that is being tested into the scope of the <strong class="source-inline">tests</strong> module.</li>
			</ul>
			<p><strong class="source-inline">cargo test</strong> will now <a id="_idIndexMarker082"/>give the same results. But what we have <a id="_idIndexMarker083"/>achieved is greater modularity, and we've also allowed for the conditional compilation of test code.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Writing integration tests in Rust</h2>
			<p>In the <em class="italic">Writing unit tests in Rust</em> section, we saw how to define a <strong class="source-inline">tests</strong> module to hold the unit tests. This is <a id="_idIndexMarker084"/>used to test fine-grained pieces of <a id="_idIndexMarker085"/>code such as an individual function call. Unit tests are small and have a narrow focus.</p>
			<p>For testing broader test scenarios involving a larger scope of code such as a workflow, integration tests are needed. It is important to write both types of tests to fully ensure that the library works as expected.</p>
			<p>To write integration tests, the convention in Rust is to create a <strong class="source-inline">tests</strong> directory in the package root and create one or more files under this folder, each containing one integration test. Each file under the <strong class="source-inline">tests</strong> directory is treated as an individual crate.</p>
			<p>But there is a catch. Integration tests in Rust are not available for binary crates, only library crates. So, let's create a new library crate:</p>
			<p class="source-code">cargo new --lib integ-test-example &amp;&amp; cd integ-test-example</p>
			<p>In <strong class="source-inline">src/lib.rs</strong>, replace the existing code with the following. This is the same code we wrote earlier, but this time it is in <strong class="source-inline">lib.rs</strong>:</p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">pub fn get_process_id() -&gt; u32 {</p>
			<p class="source-code">    process::id()</p>
			<p class="source-code">}</p>
			<p>Let's <a id="_idIndexMarker086"/>create a <strong class="source-inline">tests</strong> folder and create a file, <strong class="source-inline">tests/integration_test1.rs</strong>. Add the <a id="_idIndexMarker087"/>following code in this file:</p>
			<p class="source-code">use integ_test_example;</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn test1() {</p>
			<p class="source-code">    assert_ne!(integ_test_example::get_process_id(), 0, "Error </p>
			<p class="source-code">        in code");</p>
			<p class="source-code">}</p>
			<p>Note the following changes to the test code compared to unit tests:</p>
			<ul>
				<li>Integration tests are external to the library, so we have to bring the library into the scope of the integration test. This is simulating how an external user of our library would call a function from the public interface of our library. This is in place of <strong class="source-inline">super:: prefix</strong> used in unit tests to bring the tested function into scope.</li>
				<li>We did not have to specify the <strong class="source-inline">#[cfg(test)]</strong> annotation with integration tests, because these are stored in a separate folder and cargo compiles files in this directory only when we run <strong class="source-inline">cargo test</strong>.</li>
				<li>We still have to specify the <strong class="source-inline">#[test]</strong> attribute for each <strong class="source-inline">test</strong> function to tell the compiler these <a id="_idIndexMarker088"/>are the test functions (and not helper/utility code) to be executed.</li>
			</ul>
			<p>Run <strong class="source-inline">cargo test</strong>. You will <a id="_idIndexMarker089"/>see that this integration test has been run successfully.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Controlling test execution</h2>
			<p>The <strong class="source-inline">cargo test</strong> command compiles the source code in test mode and runs the resultant binary. <strong class="source-inline">cargo test</strong> can be <a id="_idIndexMarker090"/>run in various modes by specifying command-line options. The following is a summary of the key options.</p>
			<h3>Running a subset of tests by name </h3>
			<p>If there <a id="_idIndexMarker091"/>are a large number of tests in a package, <strong class="source-inline">cargo test</strong> runs all tests by default each time. To run any particular test cases by name, the following option can be used:</p>
			<p class="source-code">cargo test —- testfunction1, testfunction2</p>
			<p>To verify this, let's replace the code in the <strong class="source-inline">integration_test1.rs</strong> file with the following:</p>
			<p class="source-code">use integ_test_example;</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn files_test1() {</p>
			<p class="source-code">    assert_ne!(integ_test_example::get_process_id(),0,"Error </p>
			<p class="source-code">        in code");</p>
			<p class="source-code">}</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn files_test2() {</p>
			<p class="source-code">    assert_eq!(1+1, 2);</p>
			<p class="source-code">}</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn process_test1() {</p>
			<p class="source-code">    assert!(true);</p>
			<p class="source-code">}</p>
			<p>This last <a id="_idIndexMarker092"/>dummy <strong class="source-inline">test</strong> function is for purposes of the demonstration of running selective cases.</p>
			<p>Run <strong class="source-inline">cargo test</strong> and you can see both tests executed.</p>
			<p>Run <strong class="source-inline">cargo test files_test1</strong> and you can see <strong class="source-inline">files_test1</strong> executed.</p>
			<p>Run <strong class="source-inline">cargo test files_test2</strong> and you can see <strong class="source-inline">files_test2</strong> executed.</p>
			<p>Run <strong class="source-inline">cargo test files</strong> and you will see both <strong class="source-inline">files_test1</strong> and <strong class="source-inline">files_test2</strong> tests executed, but <strong class="source-inline">process_test1</strong> is not executed. This is because cargo looks for all test cases containing the term <strong class="source-inline">'files'</strong> and executes them.</p>
			<h3>Ignoring some tests</h3>
			<p>In some cases, you want to execute most of the tests every time but exclude a few. This can be <a id="_idIndexMarker093"/>achieved by annotating the <strong class="source-inline">test</strong> function with the <strong class="source-inline">#[ignore]</strong> attribute.</p>
			<p>In the previous example, let's say we want to exclude <strong class="source-inline">process_test1</strong> from regular execution because it is computationally intensive and takes a lot of time to execute. The following snippet shows how it's done:</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">#[ignore]</p>
			<p class="source-code">fn process_test1() {</p>
			<p class="source-code">    assert!(true);</p>
			<p class="source-code">}</p>
			<p>Run <strong class="source-inline">cargo test</strong>, and you will see that <strong class="source-inline">process_test1</strong> is marked as ignored, and hence not executed.</p>
			<p>To run only the ignored tests in a separate iteration, use the following option:</p>
			<p class="source-code">cargo test —- --ignored</p>
			<p>The first <strong class="source-inline">--</strong> is a separator between the command-line options for the <strong class="source-inline">cargo</strong> command and those <a id="_idIndexMarker094"/>for the <strong class="source-inline">test</strong> binary. In this case, we are passing the <strong class="source-inline">--ignored</strong> flag for the test binary, hence the need for this seemingly confusing syntax.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Running tests sequentially or in parallel</h2>
			<p>By default, <strong class="source-inline">cargo test</strong> runs the various tests in parallel in separate threads. To support this mode of execution, the <strong class="source-inline">test</strong> functions must be written in a way that there is no common <a id="_idIndexMarker095"/>data sharing across test cases. However if there is indeed <a id="_idIndexMarker096"/>such a need (for example, one test case writes some data to a location and another test case reads it), then we can run the tests in sequence as follows:</p>
			<p class="source-code">cargo test -- --test-threads=1</p>
			<p>This command tells cargo to use only one thread for executing tests, which indirectly means that tests have to be executed in sequence.</p>
			<p>In summary, Rust's strong built-in type system and strict ownership rules enforced by the compiler, coupled with the ability to script and execute unit and integration test cases as an integral part of the language and tooling, makes it very appealing to write robust, reliable systems.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Documenting your project</h1>
			<p>Rust ships with <a id="_idIndexMarker097"/>a tool called <strong class="source-inline">Rustdoc</strong>, which can generate documentation for Rust projects. Cargo has <a id="_idIndexMarker098"/>integration with <strong class="source-inline">Rustdoc</strong>, so you can use either tool to generate documentation.</p>
			<p>To get an idea of what it means to have documentation generated for Rust projects, go to <a href="http://docs.rs">http://docs.rs</a>.</p>
			<p>This is a documentation repository for all the crates in <em class="italic">crates.io</em>. To see a sample of the generated documentation, select a crate and view the docs. For example, you can go to <strong class="source-inline">docs.rs/serde</strong> to see docs for the popular serialization/deserialization library in Rust.</p>
			<p>To generate similar documentation for your Rust projects, it is important to think through what to document, and how to document it.</p>
			<p>But what can you document? The following are some of the aspects of a crate that it would be useful to document:</p>
			<ul>
				<li>An overall short description of what your Rust library does</li>
				<li>A list of modules and public functions in the library</li>
				<li>A list of other items, such as <strong class="source-inline">traits</strong>, <strong class="source-inline">macros</strong>, <strong class="source-inline">structs</strong>, <strong class="source-inline">enums</strong>, and <strong class="source-inline">typedefs</strong>, that a public user of the library needs to be familiar with to use various features</li>
				<li>For binary crates, installation instructions and command-line parameters.</li>
				<li>Examples that demonstrate to users how to use the crate</li>
				<li>Optionally, design details for the crate</li>
			</ul>
			<p>Now that <a id="_idIndexMarker099"/>we know <strong class="bold">what</strong> to document, we have to learn <strong class="bold">how</strong> to document it. There are two ways to document your crate:</p>
			<ul>
				<li>Inline documentation comments within the crate </li>
				<li>Separate markdown files</li>
			</ul>
			<p>You can use either approach, and the <strong class="source-inline">rustdoc</strong> tool will convert them into <strong class="source-inline">HTML</strong>, <strong class="source-inline">CSS</strong>, and <strong class="source-inline">JavaScript</strong> code that can be viewed from a browser.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Writing inline documentation comments within crate</h2>
			<p>Rust <a id="_idIndexMarker100"/>has two types <a id="_idIndexMarker101"/>of comments: <strong class="bold">code comments</strong> (aimed at <a id="_idIndexMarker102"/>developers) and <strong class="bold">documentation comments</strong> (aimed at users of the library/crate).</p>
			<p>Code <a id="_idIndexMarker103"/>comments are written using:</p>
			<ul>
				<li><strong class="source-inline">//</strong> for single-line comments and writing inline documentation comments within crate</li>
				<li><strong class="source-inline">/* */</strong>  for multi-line comments</li>
			</ul>
			<p>Documentation <a id="_idIndexMarker104"/>comments are written using two styles:</p>
			<p>The first style is to use three slashes <strong class="source-inline">///</strong> for commenting on individual items that follow the comments. Markdown notation can be used to style the comments (for example, bold or italic). <em class="italic">This is typically used for item-level documentation.</em></p>
			<p>The second style is to use <strong class="source-inline">//!</strong>. This is used to add documentation for the item that contains these comments (as opposed to the first style, which is used to comment items that follow the comments). <em class="italic">This is typically used for crate-level documentation.</em></p>
			<p>In both <a id="_idIndexMarker105"/>cases, <strong class="source-inline">rustdoc</strong> extracts documentation from <a id="_idIndexMarker106"/>the crate's documentation comments.</p>
			<p>Add the <a id="_idIndexMarker107"/>following comments to the <strong class="source-inline">integ-test-example</strong> project, in <strong class="source-inline">src/lib.rs</strong>:</p>
			<p class="source-code">//! This is a library that contains functions related to </p>
			<p class="source-code">//! dealing with processes,  </p>
			<p class="source-code">//! and makes these tasks more convenient.  </p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">/// This function gets the process ID of the current </p>
			<p class="source-code">/// executable. It returns a non-zero  number  </p>
			<p class="source-code">pub fn get_process_id() -&gt; u32 {</p>
			<p class="source-code">    process::id()</p>
			<p class="source-code">}</p>
			<p>Run <strong class="source-inline">cargo doc –open</strong> to see the generated HTML documentation corresponding to the documentation comments.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Writing documentation in markdown files</h2>
			<p>Create a <a id="_idIndexMarker108"/>new folder, <strong class="source-inline">doc</strong>, under the crate root, and <a id="_idIndexMarker109"/>add a new file, <strong class="source-inline">itest.md</strong>, with the <a id="_idIndexMarker110"/>following markdown content:</p>
			<p class="source-code"># Docs for integ-test-example crate</p>
			<p class="source-code">  </p>
			<p class="source-code">This is a project to test `rustdoc`.</p>
			<p class="source-code">[Here is a link!](https://www.rust-lang.org)</p>
			<p class="source-code">// Function signature</p>
			<p class="source-code">pub fn get_process_id() -&gt; u32 {}</p>
			<p>This function returns the process ID of the currently running executable:</p>
			<p class="source-code">// Example</p>
			<p class="source-code">```rust</p>
			<p class="source-code">use integ_test_example;</p>
			<p class="source-code">fn get_id() -&gt; i32 {</p>
			<p class="source-code"> let my_pid = get_process_id();</p>
			<p class="source-code"> println!("Process id for current process is: {}", my_pid);</p>
			<p class="source-code">}</p>
			<p class="source-code">```</p>
			<p>Note that the preceding code example is only representational.</p>
			<p>Unfortunately, cargo does not directly support generating HTML from standalone markdown <a id="_idIndexMarker111"/>files (at the time of this writing), so <a id="_idIndexMarker112"/>we have to use <strong class="source-inline">rustdoc</strong> as <a id="_idIndexMarker113"/>follows:</p>
			<p class="source-code">rustdoc doc/itest.md</p>
			<p>You will find the generated HTML document <strong class="source-inline">itest.html</strong> in the same folder. View it in your browser.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Running documentation tests</h2>
			<p>If there are any code examples written as part of the documentation, <strong class="source-inline">rustdoc</strong> can execute <a id="_idIndexMarker114"/>the code examples as tests.</p>
			<p>Let's write <a id="_idIndexMarker115"/>a code example for our library. Open <strong class="source-inline">src/lib.rs</strong> and add the following code example to existing code:</p>
			<p class="source-code">//! Integration-test-example crate</p>
			<p class="source-code">//!</p>
			<p class="source-code">//! This is a library that contains functions related to </p>
			<p class="source-code">//! dealing with processes</p>
			<p class="source-code">//! , and makes these tasks more convenient.</p>
			<p class="source-code">use std::process;</p>
			<p class="source-code">/// This function gets the process id of the current </p>
			<p class="source-code">/// executable. It returns a non-zero number</p>
			<p class="source-code">/// ```</p>
			<p class="source-code">/// fn get_id() {</p>
			<p class="source-code">/// let x = integ_test_example::get_process_id();</p>
			<p class="source-code">/// println!("{}",x);</p>
			<p class="source-code">/// }</p>
			<p class="source-code">/// ```</p>
			<p class="source-code">pub fn get_process_id() -&gt; u32 {</p>
			<p class="source-code">    process::id()</p>
			<p class="source-code">}</p>
			<p>If you <a id="_idIndexMarker116"/>run <strong class="source-inline">cargo test --doc</strong>, it will run this example <a id="_idIndexMarker117"/>code and provide the status of the execution.</p>
			<p>Alternatively, running <strong class="source-inline">cargo test</strong> will run all the test cases from the <strong class="source-inline">tests</strong> directory (except those that are marked as ignored), and then run the documentation tests (that is, code samples provided as part of the documentation).</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Summary</h1>
			<p>Understanding the Cargo ecosystem of toolchains is very important to be effective as a Rust programmer, and this chapter has provided the foundational knowledge that will be used in future chapters.</p>
			<p>We learned that there are three release channels in Rust – stable, beta, and nightly. Stable is recommended for production use, nightly is for experimental features, and beta is an interim stage to verify that there isn't any regression in Rust language releases before they are marked <strong class="source-inline">stable</strong>. We also learned how to use rustup to configure the toolchain to use for the project.</p>
			<p>We saw different ways to organize code in Rust projects. We also learned how to build executable binaries and shared libraries. We also looked at how to use Cargo to specify and manage dependencies.</p>
			<p>We covered how to write unit tests and integration tests for a Rust package using Rust's built-in test framework, how to invoke automated tests using cargo, and how to control test execution. We learned how to document packages both through inline documentation comments and using standalone markdown files.</p>
			<p>In the next chapter, we will take a quick tour of the Rust programming language, through a hands-on project.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Further reading</h1>
			<ul>
				<li>The Cargo Book (<a href="https://doc.rust-lang.org/cargo">https://doc.rust-lang.org/cargo</a>)</li>
				<li>The Rust Book (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>)</li>
				<li>Rust Forge (<a href="https://forge.rust-lang.org/">https://forge.rust-lang.org/</a>)</li>
				<li>The Rustup book (<a href="https://rust-lang.github.io/rustup/index.html">https://rust-lang.github.io/rustup/index.html</a>)</li>
				<li>The Rust style guide – the Rust style guide contains conventions, guidelines, and best practices to write idiomatic Rust code, and can be found at the following link: <a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md</a></li>
			</ul>
		</div>
	</body></html>