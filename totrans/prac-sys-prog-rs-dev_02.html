<html><head></head><body>
		<div><h1 id="_idParaDest-17"><em class="italic">Chapter 1</em>: <a id="_idTextAnchor016"/>Tools of the Trade – Rust Toolchains and Project Structures</h1>
			<p>Rust, as a modern systems programming language, has many inherent characteristics that make it easier to write safe, reliable, and performant code. Rust also has a compiler that enables a relatively fearless code refactoring experience as a project grows in size and complexity. But any programming language in itself is incomplete without the toolchains that support the software development life cycle. After all, where would software engineers be without their tools?</p>
			<p>This chapter specifically discusses the Rust toolchain and its ecosystem, and techniques to structure code within Rust projects to write safe, testable, performant, documented, and maintainable code that is also optimized to run in the intended target environment.</p>
			<p>The following are the key learning outcomes for this chapter:</p>
			<ul>
				<li>Choosing the right configuration of Rust for your project</li>
				<li>Cargo introduction and project structure</li>
				<li>Cargo build management</li>
				<li>Cargo dependencies</li>
				<li>Writing test scripts and doing automated unit and integration testing </li>
				<li>Automating the generation of technical documentation</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to select the right project type and toolchain; organize project code efficiently; add external and internal libraries as dependencies; build the project for development, test, and production environments; automate testing; and generate documentation for your Rust code.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>Rustup must be installed in the local development environment. Use this link for installation: <a href="https://github.com/rust-lang/rustup">https://github.com/rust-lang/rustup</a>.</p>
			<p>Refer to the following link for official installation instructions: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>.</p>
			<p>After installation, check <code>rustc</code>, and <code>cargo</code> have been installed correctly with the following commands:</p>
			<pre>rustc --version 
cargo --version</pre>
			<p>You must have access to any code editor of your choice.</p>
			<p>Some of the code and commands in this chapter, especially those related to shared libraries and setting paths, require a Linux system environment. It is recommended to install a local virtual machine such as VirtualBox or equivalent with a Linux installation for working with the code in this chapter. Instructions to install VirtualBox can be found at <a href="https://www.virtualbox.org">https://www.virtualbox.org</a>.</p>
			<p>The Git repo for the examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01</a>.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Choosing the right Rust configuration for your project</h1>
			<p>When you <a id="_idIndexMarker000"/>start with Rust programming, you have to first select a Rust release channel and a Rust project type.</p>
			<p>This section discusses details of the Rust <em class="italic">release channels</em> and gives guidance on how to choose among them for your project.</p>
			<p>Rust also allows you to build different types of binaries – standalone executables, static libraries, and dynamic libraries. If you know upfront what you will be building, you can create the right project type with the scaffolding code generated for you.</p>
			<p>We will cover these in this section.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Choosing a Rust release channel</h2>
			<p>The Rust programming language is developed continually and there are three releases being developed<a id="_idTextAnchor020"/> <a id="_idIndexMarker001"/>simultaneously at any point in time, each called a <strong class="bold">release channel</strong>. Each channel <a id="_idIndexMarker002"/>has a purpose and has varying features and stability characteristics. The three release channels are <em class="italic">stable</em>, <em class="italic">beta</em>, and <em class="italic">nightly</em>. Unstable <a id="_idIndexMarker003"/>language features and libraries <a id="_idIndexMarker004"/>are developed in the <strong class="bold">nightly</strong> and <strong class="bold">beta</strong> channels, while stability <a id="_idIndexMarker005"/>guarantees are provided on the <strong class="bold">stable</strong> channel.</p>
			<p><strong class="bold">Rustup</strong> is the tool <a id="_idIndexMarker006"/>that installs the Rust compiler, the Rust Standard Library, the Cargo package manager, and other core tools for activities such as code formatting, testing, benchmarking, and documentation. All these tools are available in multiple flavors called <em class="italic">toolchains</em>. A <em class="italic">toolchain</em> is <a id="_idIndexMarker007"/>a combination of a <em class="italic">release channel</em> and a <em class="italic">host</em>, and optionally also has an associated archive date. </p>
			<p><em class="italic">Rustup</em> can install a toolchain from a <em class="italic">release channel</em>, or from other sources such as official archives <a id="_idIndexMarker008"/>and local builds. <em class="italic">Rustup</em> also determines the toolchain depending on the host platform. Rust is officially available on Linux, Windows, and macOS. Rustup thus is called a <em class="italic">tool multiplexer</em> as it <a id="_idIndexMarker009"/>installs and manages multiple toolchains, and in this sense is similar to <em class="italic">rbenv</em>, <em class="italic">pyenv</em>, or <em class="italic">nvm</em> in <em class="italic">Ruby</em>, <em class="italic">Python</em>, and <em class="italic">Node.js</em> respectively.</p>
			<p>Rustup manages the complexity associated with toolchains but makes the installation process fairly straightforward as it provides sensible defaults. These can later be modified by the developer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Rust's stable version is released every 6 weeks; for example, Rust 1.42.0 was released on March 12, 2020, and 6 weeks later to the day, Rust 1.43 was released on April 23, 2020.</p>
			<p class="callout">A new nightly version of Rust is released every day. Once every 6 weeks, the latest master branch of nightly becomes the beta version.</p>
			<p>Most Rust developers primarily use the <em class="italic">stable</em> channel. Beta channel releases are not used actively, but only to test for any regressions in the Rust language releases.</p>
			<p>The <em class="italic">nightly</em> channel is for active language development and is published every night. The <em class="italic">nightly</em> channel lets Rust develop new and experimental features and allows early adopters to test them before they are stabilized. The price to be paid for early access is that there may be breaking changes to these features before they get into stable releases. Rust uses feature flags to determine what features are enabled in a given nightly release. A user who wants to use a cutting-edge feature in nightly version has to annotate the code with the appropriate <em class="italic">feature flag</em>.</p>
			<p>An example of a feature flag is shown here:</p>
			<pre>#![feature(try_trait)]</pre>
			<p>Note that <a id="_idIndexMarker010"/>beta and stable releases cannot use feature flags.</p>
			<p>Rustup is configured to use the stable channel by default. To work with other channels, here are <a id="_idIndexMarker011"/>a few commands. For a complete list, refer to the official link: <a href="https://github.com/rust-lang/rustup">https://github.com/rust-lang/rustup</a>.</p>
			<p>To install nightly Rust, use this command:</p>
			<pre>rustup toolchain install nightly</pre>
			<p>To activate nightly Rust globally, use this command:</p>
			<pre>rustup default nightly</pre>
			<p>To activate nightly at a directory level, use this command:</p>
			<pre>rustup override set nightly</pre>
			<p>To get the version of the compiler in nightly Rust, use this command:</p>
			<pre>rustup run nightly rustc –-version</pre>
			<p>To reset <code>rustup</code> to use the stable channel, use this command:</p>
			<pre>rustup default stable</pre>
			<p>To show the installed toolchains and which is currently active, use this command:</p>
			<pre>rustup show</pre>
			<p>To update the installed toolchains to the latest versions, use this command:</p>
			<pre>rustup update</pre>
			<p>Note that once <code>rustup default &lt;channel-name&gt;</code> is set, other related tools, such as Cargo and Rustc, use the default channel set.</p>
			<p>Which Rust <a id="_idIndexMarker012"/>channel should you use for your project? For any <strong class="bold">production-bound</strong> projects, it is advisable to use only the <strong class="bold">stable</strong> release channel. For any <strong class="bold">experimental</strong> projects, the <strong class="bold">nightly</strong> or <strong class="bold">beta</strong> channels may be used, with caution as there may be breaking changes needed for the code in future releases.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Selecting a Rust project type</h2>
			<p>There are <a id="_idIndexMarker013"/>two basic types of projects in Rust: <strong class="bold">libraries</strong> and <strong class="bold">binaries</strong> (or executables).</p>
			<p>A <em class="italic">library</em> is a <a id="_idIndexMarker014"/>self-contained <a id="_idIndexMarker015"/>piece of code that is intended for use by other programs. The <a id="_idIndexMarker016"/>purpose of a library is to enable code reuse and speed up <a id="_idIndexMarker017"/>the development cycle by leveraging the hard work of other open source developers. Libraries, also <a id="_idIndexMarker018"/>called a <code>crates.io</code>) that can be discovered and downloaded by other developers for use in their own programs. Program execution for a library crate begins in the <code>src/lib.rs</code> file.</p>
			<p>A <em class="italic">binary</em> is a standalone <a id="_idIndexMarker019"/>executable that <a id="_idIndexMarker020"/>may download and link other libraries into a single binary. A binary project type <a id="_idIndexMarker021"/>is also called a <code>main()</code> function that is present in the <code>src/main.rs</code> file.</p>
			<p>It is important to determine whether you want to build a binary or a library program in Rust while initializing the project. We will see examples of these two types of projects later in this chapter. It's time to introduce the star tool and Swiss-Army knife in the Rust ecosystem, <em class="italic">Cargo</em>.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>Introducing Cargo and project structures</h1>
			<p>Cargo is the <a id="_idIndexMarker022"/>official build and dependency management tool for Rust. It has <a id="_idIndexMarker023"/>many of the features of the other popular tools in this segment, such as Ant, Maven, Gradle, npm, CocoaPods, pip, and yarn, but provides a far more seamless and integrated developer experience for compiling code, downloading and compiling dependent libraries (called <strong class="bold">crates</strong> in Rust), linking libraries, and building development <a id="_idIndexMarker024"/>and release binaries. It also performs the incremental build of the code to reduce the compilation time as the programs evolve. In addition, it creates an idiomatic project structure while creating new Rust projects.</p>
			<p>In short, Cargo as an integrated toolchain gives a seamless experience in the day-to-day tasks of creating a new project, building it, managing <a id="_idIndexMarker025"/>external dependencies, debugging, testing, generating documentation, and release management.</p>
			<p>Cargo is the tool that can be used to set up the basic project scaffolding structure for a new Rust project. Before <a id="_idIndexMarker026"/>we create a new Rust project with Cargo, let's first understand the options for organizing code within Rust projects:</p>
			<div><div><img src="img/Figure_1.1_B16405.jpg" alt="Figure 1.1 – Cargo project structure and hierarchy"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Cargo project structure and hierarchy</p>
			<p><em class="italic">Figure 1.1</em> shows how code <a id="_idIndexMarker027"/>can be organized within a Cargo-generated Rust project.</p>
			<p>The smallest standalone unit of organization of code in a Rust project is a <code>main.rs</code> is a source file.</p>
			<p>The next highest level of code organization is a <strong class="bold">module</strong>. Code within modules has its own unique namespace. A module can contain user-defined data types (such as structs, traits, and enums), constants, type aliases, other module imports, and function declarations. Modules can be nested within one another. Multiple module definitions can be defined within a single source file for smaller projects, or a module can contain code spread across multiple source files for larger projects. This type of organization is also referred to <a id="_idIndexMarker028"/>as a module system.</p>
			<p>Multiple modules can be organized into <code>main.rs</code> and for library crates it is <code>lib.rs</code>.</p>
			<p>One or more crates can be combined into a <code>Cargo.toml</code> file, which contains information on how to build the package, including downloading and linking the dependent crates. When Cargo is used to create a new Rust project, it creates a <em class="italic">package</em>. A <em class="italic">package</em> must contain at least one crate – either a library or a binary crate. A package may contain any number of binary crates, but it can contain either zero or only one library crate.</p>
			<p>As Rust projects grow in size, there may be a need to split up a package into multiple units and manage them independently. A set of related packages can be organized as a <code>Cargo.lock</code> file (containing details of specific versions of dependencies that are shared across all packages in the workspace) and output directory.</p>
			<p>Let's see a few examples to understand various types of project structures in Rust.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>Automating build management with Cargo</h1>
			<p>When <a id="_idIndexMarker031"/>Rust code is compiled and built, the generated binary can either be a standalone executable binary or a library that can be <a id="_idIndexMarker032"/>used by other projects. In this section, we will look at how Cargo can be used to create Rust binaries and libraries, and how to configure metadata in <code>Cargo.toml</code> to provide build instructions.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Building a basic binary crate</h2>
			<p>In this section, we will build a basic binary crate. A binary crate when built, produces an executable binary file. This is the default crate type for the cargo tool. Let's now look at the command to create a binary crate.</p>
			<ol>
				<li>The first step is <a id="_idIndexMarker033"/>to generate a Rust source package using the <code>cargo new</code> command.</li>
				<li>Run the <a id="_idIndexMarker034"/>following command in a terminal session inside your working directory to create a new package:<pre><code>--bin</code> flag is to tell Cargo to generate a package that, when compiled, would produce a binary crate (executable).</p><p><code>first-program</code> is the name of the package given. You can specify a name of your choice.</p></li>
				<li>Once the command executes, you will see the following directory structure:<pre>[package]  
name = "first-program"  
version = "0.1.0"  
authors = [&lt;your email&gt;]  
edition = "2018"</pre><p>And the <code>src</code> directory contains one file called <code>main.rs</code>:</p><pre>fn main() {
    println!("Hello, world!");
}</pre></li>
				<li>To generate a binary crate (or executable) from this package, run the following command:<pre><code>target</code> in the project root and creates a binary crate (executable) with the same name as the package name (<code>first-program</code>, in our case) in the location <code>target/debug</code>.</p></li>
				<li>Execute the following <a id="_idIndexMarker035"/>from the command line:<pre><strong class="bold">cargo run</strong></pre><p>You will <a id="_idIndexMarker036"/>see the following printed to your console:</p><pre><strong class="bold">Hello, world!  </strong>
[[bin]]
name = "new-first-program" 
path = "src/main.rs"</pre></li>
				<li>Run the following in the command line:<pre><code>new-first-program</code> in the <code>target/debug</code> folder. You will see <strong class="bold">Hello, world!</strong> printed to your console.</p></li>
				<li>A cargo package can <a id="_idIndexMarker037"/>contain the source for <a id="_idIndexMarker038"/>multiple binaries. Let's learn how to add another binary to our project. In <code>Cargo.toml</code>, add a new <code>[[bin]]</code> target below the first one:<pre>[[bin]]  
name = "new-first-program"  
path = "src/main.rs"  
[[bin]]  
name = "new-second-program"  
path = "src/second.rs"</pre></li>
				<li>Next, create a new file, <code>src/second.rs</code>, and add the following code:<pre>fn main() {
    println!("Hello, for the second time!");
}</pre></li>
				<li>Run the following:<pre><strong class="bold">cargo run --bin new-second-program</strong></pre></li>
			</ol>
			<p>You will see the statement <code>target/debug</code> directory with the name <code>new-second-program</code>.</p>
			<p>Congratulations! You have learned how to do the following:</p>
			<ul>
				<li>Create your first Rust source package and compile it into an executable binary crate </li>
				<li>Give a new <a id="_idIndexMarker039"/>name to the binary, different <a id="_idIndexMarker040"/>from the package name </li>
				<li>Add a second binary to the same cargo package</li>
			</ul>
			<p>Note that a <code>cargo</code> package can contain one or more binary crates.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Configuring Cargo</h2>
			<p>A cargo package has <a id="_idIndexMarker041"/>an associated <code>Cargo.toml</code> file, which is also <a id="_idIndexMarker042"/>called the <strong class="bold">manifest</strong>. </p>
			<p>The manifest, at a minimum, contains the <code>[package]</code> section but can contain many other sections. A subset of the sections are listed here:</p>
			<p><strong class="bold">Specifying output targets for the package</strong>: Cargo <a id="_idIndexMarker043"/>packages can have <a id="_idIndexMarker044"/>five types of targets:</p>
			<ul>
				<li><code>[[bin]]</code>: A binary target is an executable program that can be run after it is built.</li>
				<li><code>[lib]</code>: A library target produces a library that can be used by other libraries and executables.</li>
				<li><code>[[example]]</code>: This target is useful for libraries to demonstrate the use of external APIs to users through example code. The example source code located in the <code>example</code> directory can be built into executable binaries using this target.</li>
				<li><code>[[test]]</code>: Files located in the <code>tests</code> directory represent integration tests and each of these can be compiled into a separate executable binary.</li>
				<li><code>[[bench]]</code>: Benchmark <a id="_idIndexMarker045"/>functions defined in libraries and binaries are compiled into separate executables.</li>
			</ul>
			<p>For each of these targets, the configuration can be specified, including parameters such as the name of the target, the source file of the target, and whether you want cargo to automatically run test scripts and generate documentation for the target. You may recall that in the previous section, we changed the name and set the source file for the generated binary executable.</p>
			<p><strong class="bold">Specifying dependencies for the package</strong>: The source files in a package may depend on other internal or external libraries, which <a id="_idIndexMarker046"/>are also called <em class="italic">dependencies</em>. Each of <a id="_idIndexMarker047"/>these in turn may depend on other libraries and so on. Cargo downloads the list of dependencies specified under this section and links them to the final output targets. The various types of dependencies <a id="_idIndexMarker048"/>include the following:</p>
			<ul>
				<li><code>[dependencies]</code>: Package library or binary dependencies</li>
				<li><code>[dev-dependencies]</code>: Dependencies for examples, tests, and benchmarks</li>
				<li><code>[build-dependencies]</code>: Dependencies for build scripts (if any are specified)</li>
				<li><code>[target]</code>: This is for the cross-compilation of code for various target architectures. Note that this is not to be confused with the output targets of the package, which can be lib, bin, and so on.</li>
			</ul>
			<p><strong class="bold">Specifying build profiles</strong>: There <a id="_idIndexMarker049"/>are four types of profiles that can be <a id="_idIndexMarker050"/>specified while building a cargo package:</p>
			<ul>
				<li><code>dev</code>: The <code>cargo build</code> command uses the <code>dev</code> profile by default. Packages built with this option are optimized for compile-time speed.</li>
				<li><code>release</code>: The <code>cargo build –-release</code> command enables the release profile, which is suitable for production release, and is optimized for runtime speed.</li>
				<li><code>test</code>: The <code>cargo test</code> command uses this profile. This is used to build test executables.</li>
				<li><code>bench</code>: The <code>cargo bench</code> command creates the benchmark executable, which automatically runs all functions annotated with the <code>#[bench]</code> attribute.</li>
			</ul>
			<p><code>[workspace]</code> section can be used to define the list of packages that are part of the workspace.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Building a static library crate</h2>
			<p>We have seen how to <a id="_idIndexMarker052"/>create binary crates. Let's <a id="_idIndexMarker053"/>now learn how to create a library crate:</p>
			<pre> cargo new --lib my-first-lib</pre>
			<p>The default directory structure of a new cargo project is as follows:</p>
			<pre>├── Cargo.toml
├── src
│   └── lib.rs</pre>
			<p>Add the following code in <code>src/lib.rs</code>:</p>
			<pre>pub fn hello_from_lib(message: &amp;str) {
    println!("Printing Hello {} from library",message);
}</pre>
			<p>Run the following:</p>
			<pre>cargo build </pre>
			<p>You will see the library built under <code>target/debug</code> and it will have the name <code>libmy_first_lib.rlib</code>.</p>
			<p>To invoke the function in this library, let's build a small binary crate. Create a <code>bin</code> directory under <code>src</code>, and a new file, <code>src/bin/mymain.rs</code>.</p>
			<p>Add the following code:</p>
			<pre>use my_first_lib::hello_from_lib;
fn main() {
    println!("Going to call library function");
    hello_from_lib("Rust system programmer");
}</pre>
			<p>The <code>use my_first_lib::hello_from_lib</code> statement <a id="_idIndexMarker054"/>tells the compiler <a id="_idIndexMarker055"/>to bring the library function into the scope of this program.</p>
			<p>Run the following:</p>
			<pre>cargo run  --bin mymain </pre>
			<p>You will see the <code>print</code> statement in your console. Also, the binary <code>mymain</code> will be placed in the <code>target/debug</code> folder along with the library we wrote earlier. The binary crate looks for the library in the same folder, which it finds in this case. Hence it is able to invoke the function within the library.</p>
			<p>If you want to place the <code>mymain.rs</code> file in another location (instead of within <code>src/bin</code>), then add a target in <code>Cargo.toml</code> and mention the name and path of the binary as shown in the following example, <a id="_idIndexMarker056"/>and move the <code>mymain.rs</code> file to the specified location:</p>
			<pre>[[bin]]  
name = "mymain"  
path = "src/mymain.rs"</pre>
			<p>Run <code>cargo run --bin mymain</code> and you will see the <code>println</code> output in your console.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Automating dependency management</h1>
			<p>You learned in the previous <a id="_idIndexMarker057"/>section how Cargo <a id="_idIndexMarker058"/>can be used to <a id="_idIndexMarker059"/>set up the base project directory <a id="_idIndexMarker060"/>structure and scaffolding for a new project, and how to build various types of binary and library crates. We will look at the dependency management features of Cargo in this section.</p>
			<p>Rust comes with a built-in standard library consisting of language primitives and commonly used functions, but it is small by design (compared to other languages). Most real-world programs in Rust depend on additional external libraries to improve functionality and developer productivity. Any such external code that is used is a <em class="italic">dependency</em> for the program. Cargo makes it easy to specify and manage dependencies.</p>
			<p>In the Rust ecosystem, <em class="italic">crates.io</em> is the central public package registry for discovering and downloading <a id="_idIndexMarker061"/>libraries (called <code>crates.io</code> as the default package registry.</p>
			<p>Dependencies are specified in the <code>[dependencies]</code> section of <code>Cargo.toml</code>. Let's see an example.</p>
			<p>Start a new project with this command:</p>
			<pre>cargo new deps-example &amp;&amp; cd deps-example</pre>
			<p>In <code>Cargo.toml</code>, make the following entry to include an external library:</p>
			<pre>[dependencies]  
chrono = "0.4.0"</pre>
			<p><code>Chrono</code> is a datetime library. This is called a dependency because our <code>deps-example</code> crate depends on this external library for its functionality.</p>
			<p>When you run <code>cargo build</code>, cargo looks for a crate on <code>crates.io</code> with this name and version. If found, it downloads this crate along with all of its dependencies, compiles them all, and updates <a id="_idIndexMarker063"/>a file called <code>Cargo.lock</code> with the exact versions of packages downloaded. The <code>Cargo.lock</code> file is a generated file and not meant for editing.</p>
			<p>Each dependency in <code>Cargo.toml</code> is specified in a new line and takes the format <code>&lt;crate-name&gt; = "&lt;semantic-version-number&gt;"</code>. <strong class="bold">Semantic versioning or Semver</strong> has the form X.Y.Z, where X is <a id="_idIndexMarker064"/>the major version number, Y is the minor version, and Z is the patch version.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Specifying the location of a dependency</h2>
			<p>There are <a id="_idIndexMarker065"/>many ways to specify the location and version of dependencies in <code>Cargo.toml</code>, some of which are summarized here:</p>
			<ul>
				<li><strong class="bold">Crates.io registry</strong>: This is the default option and all that is needed is to specify the <a id="_idIndexMarker066"/>package name and version string as we did earlier in this section.</li>
				<li><code>crates.io</code> is the default registry, Cargo provides the <a id="_idIndexMarker067"/>option to use an alternate registry. The registry name has to be configured in the <code>.cargo/config</code> file, and in <code>Cargo.toml</code>, an entry is to be made with the registry name, as shown in the example here:<pre>[dependencies]     
 cratename = { version = "2.1", registry = "alternate-
     registry-name" }</pre></li>
				<li><code>Cargo.toml</code> file in order to fetch its dependencies.</p></li>
				<li><strong class="bold">Specify a local path</strong>: Cargo supports path dependencies, which means the library <a id="_idIndexMarker069"/>can be a sub-crate within the main cargo package. While building the main cargo package, the sub-crates that have also been specified as dependencies will be built. But dependencies with only a path dependency cannot be uploaded to the <em class="italic">crates.io</em> public registry.</li>
				<li><strong class="bold">Multiple locations</strong>: Cargo supports the option to specify both a registry version <em class="italic">and</em> either a <a id="_idIndexMarker070"/>Git or path location. For local builds, the Git or path version is used, and the registry version will be used when the package is published to <em class="italic">crates.io</em>.</li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Using dependent packages in source code</h2>
			<p>Once the dependencies are specified in the <code>Cargo.toml</code> file in any of the preceding formats, we can <a id="_idIndexMarker071"/>use the external library in the package code as shown in the following example. Add the following code to <code>src/main.rs</code>:</p>
			<pre>use chrono::Utc;
fn main() {
    println!("Hello, time now is {:?}", Utc::now());
}</pre>
			<p>The <code>use</code> statement tells the compiler to bring the <code>chrono</code> package <code>Utc</code> module into the scope of this program. We can then access the function <code>now()</code> from the <code>Utc</code> module to print out the current date and time. The <code>use</code> statement is not mandatory. An alternative way to print datetime would be as follows:</p>
			<pre>fn main() {
    println!("Hello, time now is {:?}", chrono::Utc::now());
}</pre>
			<p>This would give the same result. But if you have to use functions from the <code>chrono</code> package multiple times in code, it is more convenient to bring <code>chrono</code> and required modules into scope once using the <code>use</code> statement, and it becomes easier to type.</p>
			<p>It is also <a id="_idIndexMarker072"/>possible to rename the imported package with the <code>as</code> keyword:</p>
			<pre>use chrono as time;
fn main() {
    println!("Hello, time now is {:?}", time::Utc::now());
}</pre>
			<p>For more <a id="_idIndexMarker073"/>details on managing dependencies, refer to the Cargo docs: <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html</a>.</p>
			<p>In this section, we have seen how to add dependencies to a package. Any number of dependencies can be added to <code>Cargo.toml</code> and used within the program. Cargo makes the dependency management process quite a pleasant experience.</p>
			<p>Let's now look at another useful feature of Cargo – running automated tests.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Writing and running automated tests</h1>
			<p>The Rust <a id="_idIndexMarker074"/>programming language has built-in support for writing <a id="_idIndexMarker075"/>automated tests.</p>
			<p>Rust tests are basically Rust functions that verify whether the other non-test functions written in <a id="_idIndexMarker076"/>the package work as intended. They basically invoke <a id="_idIndexMarker077"/>the other functions with the specified data and assert that the return values are as expected.</p>
			<p>Rust has two types of tests – unit tests and integration tests.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Writing unit tests in Rust</h2>
			<p>Create a new Rust package with the following command:</p>
			<pre>cargo new test-example &amp;&amp; cd test-example</pre>
			<p>Write a <a id="_idIndexMarker078"/>new function that returns the process ID of the currently running process. We will look at the details of process handling in a later chapter, so you <a id="_idIndexMarker079"/>may just type in the following code, as the focus here is on writing unit tests:</p>
			<pre>use std::process;
fn main() {
    println!("{}", get_process_id());
}
fn get_process_id() -&gt; u32 {
    process::id()
}</pre>
			<p>We have written a simple (silly) function to use the standard library process module and retrieve the process ID of the currently running process.</p>
			<p>Run the code using <code>cargo check</code> to confirm there are no syntax errors.</p>
			<p>Let's now write a unit test. Note that we cannot know upfront what the process ID is going to be, so all we can test is whether a number is being returned:</p>
			<pre>#[test]
fn test_if_process_id_is_returned() {
    assert!(get_process_id() &gt; 0);
}</pre>
			<p>Run <code>cargo test</code>. You will see that the test has passed successfully, as the function returns a non-zero positive integer.</p>
			<p>Note that we have written the unit tests in the same source file as the rest of the code. In order to tell the compiler that this is a test function, we use the <code>#[test]</code> annotation. The <code>assert!</code> macro (available in standard Rust library) is used to check whether a condition evaluates to true. There are two other macros available, <code>assert_eq!</code> and <code>assert_ne!</code>, which are used to test whether the two arguments passed to these macros are equal or not.</p>
			<p>A custom error message can also be specified:</p>
			<pre>#[test]
fn test_if_process_id_is_returned() {
    assert_ne!(get_process_id(), 0, "There is error in code");
}</pre>
			<p>To compile <a id="_idIndexMarker080"/>but not run the <a id="_idIndexMarker081"/>tests, use the <code>--no-run</code> option with the <code>cargo test</code> command.</p>
			<p>The preceding example has only one simple <code>test</code> function, but as the number of tests increases, the following problems arise:</p>
			<ul>
				<li>How do we write any helper functions needed for test code and differentiate it from the rest of the package code?</li>
				<li>How can we prevent the compiler from compiling tests as part of each build (to save time) and not include test code as part of the normal build (saving disk/memory space)?</li>
			</ul>
			<p>In order to provide more modularity and to address the preceding questions, it is idiomatic in Rust to group test functions in a <code>test</code> module:</p>
			<pre>#[cfg(test)]
mod tests {
    use super::get_process_id;
    #[test]
    fn test_if_process_id_is_returned() {
        assert_ne!(get_process_id(), 0, "There is 
            error in code");
    }
}</pre>
			<p>Here are the changes made to the code:</p>
			<ul>
				<li>We have moved the <code>test</code> function under the <code>tests</code> module.</li>
				<li>We have added the <code>cfg</code> attribute, which tells the compiler to compile test code only if we are trying to run tests (that is, only for <code>cargo test</code>, not for <code>cargo build</code>).</li>
				<li>There is a <code>use</code> statement, which brings the <code>get_process_id</code> function into the scope of the <code>tests</code> module. Note that <code>tests</code> is an inner module and so we use <code>super:: prefix</code> to bring the function that is being tested into the scope of the <code>tests</code> module.</li>
			</ul>
			<p><code>cargo test</code> will now <a id="_idIndexMarker082"/>give the same results. But what we have <a id="_idIndexMarker083"/>achieved is greater modularity, and we've also allowed for the conditional compilation of test code.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Writing integration tests in Rust</h2>
			<p>In the <em class="italic">Writing unit tests in Rust</em> section, we saw how to define a <code>tests</code> module to hold the unit tests. This is <a id="_idIndexMarker084"/>used to test fine-grained pieces of <a id="_idIndexMarker085"/>code such as an individual function call. Unit tests are small and have a narrow focus.</p>
			<p>For testing broader test scenarios involving a larger scope of code such as a workflow, integration tests are needed. It is important to write both types of tests to fully ensure that the library works as expected.</p>
			<p>To write integration tests, the convention in Rust is to create a <code>tests</code> directory in the package root and create one or more files under this folder, each containing one integration test. Each file under the <code>tests</code> directory is treated as an individual crate.</p>
			<p>But there is a catch. Integration tests in Rust are not available for binary crates, only library crates. So, let's create a new library crate:</p>
			<pre>cargo new --lib integ-test-example &amp;&amp; cd integ-test-example</pre>
			<p>In <code>src/lib.rs</code>, replace the existing code with the following. This is the same code we wrote earlier, but this time it is in <code>lib.rs</code>:</p>
			<pre>use std::process;
pub fn get_process_id() -&gt; u32 {
    process::id()
}</pre>
			<p>Let's <a id="_idIndexMarker086"/>create a <code>tests</code> folder and create a file, <code>tests/integration_test1.rs</code>. Add the <a id="_idIndexMarker087"/>following code in this file:</p>
			<pre>use integ_test_example;
#[test]
fn test1() {
    assert_ne!(integ_test_example::get_process_id(), 0, "Error 
        in code");
}</pre>
			<p>Note the following changes to the test code compared to unit tests:</p>
			<ul>
				<li>Integration tests are external to the library, so we have to bring the library into the scope of the integration test. This is simulating how an external user of our library would call a function from the public interface of our library. This is in place of <code>super:: prefix</code> used in unit tests to bring the tested function into scope.</li>
				<li>We did not have to specify the <code>#[cfg(test)]</code> annotation with integration tests, because these are stored in a separate folder and cargo compiles files in this directory only when we run <code>cargo test</code>.</li>
				<li>We still have to specify the <code>#[test]</code> attribute for each <code>test</code> function to tell the compiler these <a id="_idIndexMarker088"/>are the test functions (and not helper/utility code) to be executed.</li>
			</ul>
			<p>Run <code>cargo test</code>. You will <a id="_idIndexMarker089"/>see that this integration test has been run successfully.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Controlling test execution</h2>
			<p>The <code>cargo test</code> command compiles the source code in test mode and runs the resultant binary. <code>cargo test</code> can be <a id="_idIndexMarker090"/>run in various modes by specifying command-line options. The following is a summary of the key options.</p>
			<h3>Running a subset of tests by name </h3>
			<p>If there <a id="_idIndexMarker091"/>are a large number of tests in a package, <code>cargo test</code> runs all tests by default each time. To run any particular test cases by name, the following option can be used:</p>
			<pre>cargo test —- testfunction1, testfunction2</pre>
			<p>To verify this, let's replace the code in the <code>integration_test1.rs</code> file with the following:</p>
			<pre>use integ_test_example;
#[test]
fn files_test1() {
    assert_ne!(integ_test_example::get_process_id(),0,"Error 
        in code");
}
#[test]
fn files_test2() {
    assert_eq!(1+1, 2);
}
#[test]
fn process_test1() {
    assert!(true);
}</pre>
			<p>This last <a id="_idIndexMarker092"/>dummy <code>test</code> function is for purposes of the demonstration of running selective cases.</p>
			<p>Run <code>cargo test</code> and you can see both tests executed.</p>
			<p>Run <code>cargo test files_test1</code> and you can see <code>files_test1</code> executed.</p>
			<p>Run <code>cargo test files_test2</code> and you can see <code>files_test2</code> executed.</p>
			<p>Run <code>cargo test files</code> and you will see both <code>files_test1</code> and <code>files_test2</code> tests executed, but <code>process_test1</code> is not executed. This is because cargo looks for all test cases containing the term <code>'files'</code> and executes them.</p>
			<h3>Ignoring some tests</h3>
			<p>In some cases, you want to execute most of the tests every time but exclude a few. This can be <a id="_idIndexMarker093"/>achieved by annotating the <code>test</code> function with the <code>#[ignore]</code> attribute.</p>
			<p>In the previous example, let's say we want to exclude <code>process_test1</code> from regular execution because it is computationally intensive and takes a lot of time to execute. The following snippet shows how it's done:</p>
			<pre>#[test]
#[ignore]
fn process_test1() {
    assert!(true);
}</pre>
			<p>Run <code>cargo test</code>, and you will see that <code>process_test1</code> is marked as ignored, and hence not executed.</p>
			<p>To run only the ignored tests in a separate iteration, use the following option:</p>
			<pre>cargo test —- --ignored</pre>
			<p>The first <code>--</code> is a separator between the command-line options for the <code>cargo</code> command and those <a id="_idIndexMarker094"/>for the <code>test</code> binary. In this case, we are passing the <code>--ignored</code> flag for the test binary, hence the need for this seemingly confusing syntax.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Running tests sequentially or in parallel</h2>
			<p>By default, <code>cargo test</code> runs the various tests in parallel in separate threads. To support this mode of execution, the <code>test</code> functions must be written in a way that there is no common <a id="_idIndexMarker095"/>data sharing across test cases. However if there is indeed <a id="_idIndexMarker096"/>such a need (for example, one test case writes some data to a location and another test case reads it), then we can run the tests in sequence as follows:</p>
			<pre>cargo test -- --test-threads=1</pre>
			<p>This command tells cargo to use only one thread for executing tests, which indirectly means that tests have to be executed in sequence.</p>
			<p>In summary, Rust's strong built-in type system and strict ownership rules enforced by the compiler, coupled with the ability to script and execute unit and integration test cases as an integral part of the language and tooling, makes it very appealing to write robust, reliable systems.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Documenting your project</h1>
			<p>Rust ships with <a id="_idIndexMarker097"/>a tool called <code>Rustdoc</code>, which can generate documentation for Rust projects. Cargo has <a id="_idIndexMarker098"/>integration with <code>Rustdoc</code>, so you can use either tool to generate documentation.</p>
			<p>To get an idea of what it means to have documentation generated for Rust projects, go to <a href="http://docs.rs">http://docs.rs</a>.</p>
			<p>This is a documentation repository for all the crates in <em class="italic">crates.io</em>. To see a sample of the generated documentation, select a crate and view the docs. For example, you can go to <code>docs.rs/serde</code> to see docs for the popular serialization/deserialization library in Rust.</p>
			<p>To generate similar documentation for your Rust projects, it is important to think through what to document, and how to document it.</p>
			<p>But what can you document? The following are some of the aspects of a crate that it would be useful to document:</p>
			<ul>
				<li>An overall short description of what your Rust library does</li>
				<li>A list of modules and public functions in the library</li>
				<li>A list of other items, such as <code>traits</code>, <code>macros</code>, <code>structs</code>, <code>enums</code>, and <code>typedefs</code>, that a public user of the library needs to be familiar with to use various features</li>
				<li>For binary crates, installation instructions and command-line parameters.</li>
				<li>Examples that demonstrate to users how to use the crate</li>
				<li>Optionally, design details for the crate</li>
			</ul>
			<p>Now that <a id="_idIndexMarker099"/>we know <strong class="bold">what</strong> to document, we have to learn <strong class="bold">how</strong> to document it. There are two ways to document your crate:</p>
			<ul>
				<li>Inline documentation comments within the crate </li>
				<li>Separate markdown files</li>
			</ul>
			<p>You can use either approach, and the <code>rustdoc</code> tool will convert them into <code>HTML</code>, <code>CSS</code>, and <code>JavaScript</code> code that can be viewed from a browser.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Writing inline documentation comments within crate</h2>
			<p>Rust <a id="_idIndexMarker100"/>has two types <a id="_idIndexMarker101"/>of comments: <strong class="bold">code comments</strong> (aimed at <a id="_idIndexMarker102"/>developers) and <strong class="bold">documentation comments</strong> (aimed at users of the library/crate).</p>
			<p>Code <a id="_idIndexMarker103"/>comments are written using:</p>
			<ul>
				<li><code>//</code> for single-line comments and writing inline documentation comments within crate</li>
				<li><code>/* */</code>  for multi-line comments</li>
			</ul>
			<p>Documentation <a id="_idIndexMarker104"/>comments are written using two styles:</p>
			<p>The first style is to use three slashes <code>///</code> for commenting on individual items that follow the comments. Markdown notation can be used to style the comments (for example, bold or italic). <em class="italic">This is typically used for item-level documentation.</em></p>
			<p>The second style is to use <code>//!</code>. This is used to add documentation for the item that contains these comments (as opposed to the first style, which is used to comment items that follow the comments). <em class="italic">This is typically used for crate-level documentation.</em></p>
			<p>In both <a id="_idIndexMarker105"/>cases, <code>rustdoc</code> extracts documentation from <a id="_idIndexMarker106"/>the crate's documentation comments.</p>
			<p>Add the <a id="_idIndexMarker107"/>following comments to the <code>integ-test-example</code> project, in <code>src/lib.rs</code>:</p>
			<pre>//! This is a library that contains functions related to 
//! dealing with processes,  
//! and makes these tasks more convenient.  
use std::process;
/// This function gets the process ID of the current 
/// executable. It returns a non-zero  number  
pub fn get_process_id() -&gt; u32 {
    process::id()
}</pre>
			<p>Run <code>cargo doc –open</code> to see the generated HTML documentation corresponding to the documentation comments.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Writing documentation in markdown files</h2>
			<p>Create a <a id="_idIndexMarker108"/>new folder, <code>doc</code>, under the crate root, and <a id="_idIndexMarker109"/>add a new file, <code>itest.md</code>, with the <a id="_idIndexMarker110"/>following markdown content:</p>
			<pre># Docs for integ-test-example crate
  
This is a project to test `rustdoc`.
[Here is a link!](https://www.rust-lang.org)
// Function signature
pub fn get_process_id() -&gt; u32 {}</pre>
			<p>This function returns the process ID of the currently running executable:</p>
			<pre>// Example
```rust
use integ_test_example;
fn get_id() -&gt; i32 {
 let my_pid = get_process_id();
 println!("Process id for current process is: {}", my_pid);
}
```</pre>
			<p>Note that the preceding code example is only representational.</p>
			<p>Unfortunately, cargo does not directly support generating HTML from standalone markdown <a id="_idIndexMarker111"/>files (at the time of this writing), so <a id="_idIndexMarker112"/>we have to use <code>rustdoc</code> as <a id="_idIndexMarker113"/>follows:</p>
			<pre>rustdoc doc/itest.md</pre>
			<p>You will find the generated HTML document <code>itest.html</code> in the same folder. View it in your browser.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Running documentation tests</h2>
			<p>If there are any code examples written as part of the documentation, <code>rustdoc</code> can execute <a id="_idIndexMarker114"/>the code examples as tests.</p>
			<p>Let's write <a id="_idIndexMarker115"/>a code example for our library. Open <code>src/lib.rs</code> and add the following code example to existing code:</p>
			<pre>//! Integration-test-example crate
//!
//! This is a library that contains functions related to 
//! dealing with processes
//! , and makes these tasks more convenient.
use std::process;
/// This function gets the process id of the current 
/// executable. It returns a non-zero number
/// ```
/// fn get_id() {
/// let x = integ_test_example::get_process_id();
/// println!("{}",x);
/// }
/// ```
pub fn get_process_id() -&gt; u32 {
    process::id()
}</pre>
			<p>If you <a id="_idIndexMarker116"/>run <code>cargo test --doc</code>, it will run this example <a id="_idIndexMarker117"/>code and provide the status of the execution.</p>
			<p>Alternatively, running <code>cargo test</code> will run all the test cases from the <code>tests</code> directory (except those that are marked as ignored), and then run the documentation tests (that is, code samples provided as part of the documentation).</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Summary</h1>
			<p>Understanding the Cargo ecosystem of toolchains is very important to be effective as a Rust programmer, and this chapter has provided the foundational knowledge that will be used in future chapters.</p>
			<p>We learned that there are three release channels in Rust – stable, beta, and nightly. Stable is recommended for production use, nightly is for experimental features, and beta is an interim stage to verify that there isn't any regression in Rust language releases before they are marked <code>stable</code>. We also learned how to use rustup to configure the toolchain to use for the project.</p>
			<p>We saw different ways to organize code in Rust projects. We also learned how to build executable binaries and shared libraries. We also looked at how to use Cargo to specify and manage dependencies.</p>
			<p>We covered how to write unit tests and integration tests for a Rust package using Rust's built-in test framework, how to invoke automated tests using cargo, and how to control test execution. We learned how to document packages both through inline documentation comments and using standalone markdown files.</p>
			<p>In the next chapter, we will take a quick tour of the Rust programming language, through a hands-on project.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Further reading</h1>
			<ul>
				<li>The Cargo Book (<a href="https://doc.rust-lang.org/cargo">https://doc.rust-lang.org/cargo</a>)</li>
				<li>The Rust Book (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>)</li>
				<li>Rust Forge (<a href="https://forge.rust-lang.org/">https://forge.rust-lang.org/</a>)</li>
				<li>The Rustup book (<a href="https://rust-lang.github.io/rustup/index.html">https://rust-lang.github.io/rustup/index.html</a>)</li>
				<li>The Rust style guide – the Rust style guide contains conventions, guidelines, and best practices to write idiomatic Rust code, and can be found at the following link: <a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md</a></li>
			</ul>
		</div>
	</body></html>