<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing Generics, Impl, and Traits</h1>
                
            
            
                
<p class="calibre1">One of the key benefits of any modern language is the ability to be able to use a type which can be anything. Not only does this reduce the amount of code required, but it allows for greater flexibility in code creation. Rust not only allows for generic types and functions, but introduces traits; these can be considered as a logical extension of generics, as they tell the compiler the functionality the type must provide.</p>
<p class="calibre1">In this chapter, we will take a look at the following topics:</p>
<ul class="calibre12">
<li class="calibre13">Generics in Rust</li>
<li class="calibre13">Impl and traits</li>
<li class="calibre13">Generic types</li>
<li class="calibre13">Trait objects</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generics 101</h1>
                
            
            
                
<p class="calibre1">For those coming from the likes of C++ and C#, generics will be nothing new to you. It is typically represented as <kbd class="calibre10">T</kbd>. It is used in the same way as a standard type. As <kbd class="calibre10">T</kbd> doesn't actually have a type, it's known a <strong class="calibre8">polymorphic parameter</strong>.</p>
<p class="calibre1">There's a simple rule regarding generic types.</p>
<p class="calibre1">The types have to match—if we define <kbd class="calibre10">T</kbd> as being <kbd class="calibre10">f64</kbd> and attempt to assign a <kbd class="calibre10">String</kbd> to it, the compiler will fail to build that code.</p>
<p class="calibre1">While <kbd class="calibre10">T</kbd> is also (probably) the most commonly used letter for a generic type, in reality you can have any letter, or even words.</p>
<p class="calibre1">For example, this is perfectly acceptable code:</p>
<pre class="calibre21">enum Result&lt;Y, N&gt; 
{ 
    Ok(Y), 
    Err(N), 
} </pre>
<p class="calibre1"><kbd class="calibre10">Y</kbd> and <kbd class="calibre10">N</kbd> do not need to be the same type either; therefore, <kbd class="calibre10">Y</kbd> could be a <kbd class="calibre10">String</kbd> and <kbd class="calibre10">N</kbd> a <kbd class="calibre10">bool</kbd>.</p>
<p class="calibre1">In practice, the following shows how the generic type works. <kbd class="calibre10">Option</kbd> is provided as part of the standard library:</p>
<pre class="calibre21">enum Option&lt;T&gt; 
{ 
    Some_Type(T), 
    None 
} 
let varname: Option&lt;f32&gt; = Some_Type(3.1416f32); </pre>
<p class="calibre1">Generics also provide another useful facility: they allow for the production of generic functions.</p>
<p class="calibre1">Generic functions—the functions that you can throw anything at! A standard function may look like this:</p>
<pre class="calibre21">fn defined_type_fn(x: i32) 
{ 
    // do something with x 
} </pre>
<p>The example code for this section can be found in <kbd class="calibre22">09/multiply_generic_return_t</kbd>.</p>
<p class="calibre1">The parameter being passed in is an <kbd class="calibre10">i32</kbd> and is called <kbd class="calibre10">x</kbd>. If we attempt to pass in a float, bool, string, or any other type that is not an <kbd class="calibre10">i32</kbd>, the compiler will fail the build as the types don't match.</p>
<p class="calibre1">The generic function looks very similar:</p>
<pre class="calibre21">fn generic_type_fn&lt;T&gt;(x: T) 
{ 
    // do something with x 
} </pre>
<p class="calibre1">In style, this is very similar to how a generic method is written in C#:</p>
<pre class="calibre21">void generic_type_method&lt;T&gt;(T x) 
{ 
    // do something 
} </pre>
<p class="calibre1">This can be extended to take multiple parameters with the same type:</p>
<pre class="calibre21">fn generic_type_fn&lt;T&gt;(x: T, y: T) 
{ 
    // do something 
} </pre>
<p class="calibre1">Or with multiple types and parameters:</p>
<pre class="calibre21">fn generic_types_fn&lt;T, U, V&gt;(x: T, y: U, z: V) 
{ 
    // do something 
} </pre>
<p class="calibre1">Finally, we can use a generic as a return type. Recall that a standard function returns a value like this:</p>
<pre class="calibre21">fn multiply(a: i32, b: i32) -&gt; i32 
{ 
    return a * b; 
} </pre>
<p class="calibre1">The generic return would be as follows:</p>
<pre class="calibre21">fn multiply_generic&lt;T&gt;(a: T, b: T) -&gt; T 
{ 
    return a * b; 
} </pre>
<p class="calibre1">This will only work for simplesome types; you cannot multiply string types, though you can concatenate them—this means you add one string to another. The problem though is we cannot do this... yet.</p>
<p class="calibre1">When we attempt to build this, an error is generated:</p>
<pre class="calibre21"><strong class="calibre8">Binary operation '*' cannot be applied to type 'T'; an implementation of 'std::ops::Mul' might be missing for 'T'</strong></pre>
<p class="calibre1">Let's see if we can break this down a bit to see why we're getting the error.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Understanding the error</h1>
                
            
            
                
<p class="calibre1">We know that both <kbd class="calibre10">a</kbd> and <kbd class="calibre10">b</kbd> are of type <kbd class="calibre10">T</kbd>, but what is the <em class="calibre9">real</em> type of <kbd class="calibre10">a</kbd>?</p>
<p class="calibre1">Here, <kbd class="calibre10">a</kbd> needs to be any type that implements <kbd class="calibre10">std::ops::Mul</kbd>—that is, the <kbd class="calibre10">*</kbd> operator. Moreover, the output of this function needs to be explicitly filled in also.</p>
<p>When you see something akin to <kbd class="calibre22">std::ops::Mul</kbd>, it is just saying we're going to use the equivalent of <kbd class="calibre22">namespace std.ops</kbd> (if we are using C#). It's just the library in use.</p>
<p class="calibre1">Let's alter the type to tell the compiler that <kbd class="calibre10">T</kbd> needs to implement <kbd class="calibre10">Mul</kbd> and that we are going yield a result of type <kbd class="calibre10">T</kbd>:</p>
<pre class="calibre21">fn multiply_generic&lt;T: Mul&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T <br class="calibre2"/>{<br class="calibre2"/>  return a * b; <br class="calibre2"/>}</pre>
<p class="calibre1">All <kbd class="calibre10">&lt;T: Mul&lt;Output = T&gt;&gt;</kbd> means is that we're going to use <kbd class="calibre10">Mul</kbd> and that the output is going to be of type <kbd class="calibre10">T</kbd>.</p>
<p class="calibre1">This time, we can build and the code works fine, as shown in the following screenshot:</p>
<div><img class="image-border6" src="img/00064.jpeg"/></div>
<p class="calibre1">Pretty handy! By the way, there's another way to declare this:</p>
<pre class="calibre21">fn multiply_generic&lt;T&gt;(a: T, b: T) -&gt; T <br class="calibre2"/>  where T: Mul&lt;Output = T&gt; <br class="calibre2"/>{<br class="calibre2"/>  return a * b; <br class="calibre2"/>}</pre>
<p class="calibre1">Whichever is neater is up to the programmer, so you may see and use both styles.</p>
<p class="calibre1">The question is: What happens if we do something like send in a string? Thankfully, in this form, the compiler throws an error and won't allow the code to build:</p>
<div><img class="image-border6" src="img/00065.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A generic problem</h1>
                
            
            
                
<p class="calibre1">An aspect of generics is the determination of what <kbd class="calibre10">T</kbd> is and therefore how we can handle it. In C#, we can use <kbd class="calibre10">System.Reflection</kbd> and use the <kbd class="calibre10">GetType</kbd> method to find the type or use <kbd class="calibre10">typeof</kbd> when comparing types.</p>
<p>The source code for this part can be found in <kbd class="calibre22">09/generic_typeof</kbd>.</p>
<p class="calibre1">In Rust, we use <kbd class="calibre10">std::any:Any</kbd>. This is a type to emulate dynamic typing:</p>
<div><img src="img/00066.jpeg" class="image-border6"/></div>
<p class="calibre1">Just by looking at this output, you may be thinking: <em class="calibre9">What on earth are those numbers? I expected something like f32</em>.</p>
<p>The associated code for this part can be found in <kbd class="calibre22">09/generic_typeof_print</kbd>.</p>
<p class="calibre1">What we're seeing here is the <em class="calibre9">ID</em> for the type rather than the type. To actually show the variable type, we have do something slightly different:</p>
<pre class="calibre21">#![feature(core_intrinsics)] <br class="calibre2"/>fn display_type&lt;T&gt;(_: &amp;T)<br class="calibre2"/>{<br class="calibre2"/>  let typename = unsafe {std::intrinsics::type_name::&lt;T&gt;()};<br class="calibre2"/>  println!("{}", typename);<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>fn main()<br class="calibre2"/>{<br class="calibre2"/>  display_type(&amp;3.14f32);<br class="calibre2"/>  display_type(&amp;1i32);<br class="calibre2"/>  display_type(&amp;1.555);<br class="calibre2"/>  display_type(&amp;(vec!(1,3,5)));<br class="calibre2"/>}</pre>
<p>At the time of writing, this code will only build on the nightly branch. Chances are that by the time you read this book, it will be in the stable branch.</p>
<p class="calibre1">When the preceding code is run on the Rust Playground website, the following results are obtained:</p>
<div><img src="img/00067.jpeg" class="calibre32"/></div>
<p class="calibre1">While most of the code we have seen many times, we have not yet come across <kbd class="calibre10">unsafe</kbd> and the shebang (<kbd class="calibre10">#!</kbd>) in the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The unsafe directive</h1>
                
            
            
                
<p class="calibre1">We have seen many times so far the lengths to which the Rust compiler will go to ensure the code you have written will not only compile, but is also not going to do something stupid (such as exceed the bounds of an array, use the wrong type, or plain use a variable that has not been given a value first).</p>
<p class="calibre1">This is known as <em class="calibre9">safe</em> code. That's not to say that all safe code is good code—you can still end up with memory leaks, integer overflows, or threading deadlocks which you don't want, but aren't actually defined as unsafe.</p>
<p class="calibre1">In Rust, <kbd class="calibre10">unsafe</kbd> surrounding code means exactly that—you're telling the compiler that you know what you're writing is to be ignored by the inbuilt protection.</p>
<p class="calibre1">Using <kbd class="calibre10">unsafe</kbd> should only be done with care. We will come across <kbd class="calibre10">unsafe</kbd> later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The whole #!</h1>
                
            
            
                
<p class="calibre1">For those used to Linux shell scripting, you will have certainly seen <kbd class="calibre10">#!</kbd>—in Rust, the <kbd class="calibre10">#</kbd> is a declaration with the name in <kbd class="calibre10">[]</kbd> an attribute. They can be written as either <kbd class="calibre10">#[attr]</kbd> or <kbd class="calibre10">#![attr]</kbd>.</p>
<p class="calibre1">However, the meaning of <kbd class="calibre10">#[attr]</kbd> and <kbd class="calibre10">#![attr]</kbd> is different. <kbd class="calibre10">#[attr]</kbd> only applies directly to what comes after it. The <kbd class="calibre10">#!</kbd> changes what the attribute is applied to.</p>
<p class="calibre1">We have seen this back in Chapter 2, <em class="calibre9">Variables and Variable Types</em>, when we discussed writing tests. We would have something like this:</p>
<pre class="calibre21">#[test]<br class="calibre2"/>fn do_check()<br class="calibre2"/>{<br class="calibre2"/>  // perform check <br class="calibre2"/>}</pre>
<p class="calibre1">This <kbd class="calibre10">do_check</kbd> function will only be run when we're running the tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Traits and Impl</h1>
                
            
            
                
<p class="calibre1">A very powerful feature of Rust that is commonly seen when dealing with generics is that it is possible to tell the compiler that a particular type will provide certain functionality. This is provided by a special feature known as a <kbd class="calibre10">trait</kbd>.</p>
<p class="calibre1">However, to appreciate traits, we first have to look at the <kbd class="calibre10">impl</kbd> keyword (short for implement).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Impl</h1>
                
            
            
                
<p class="calibre1">The <kbd class="calibre10">impl</kbd> keyword works in a very similar way to a function. The structure of an implementation needs to considered as being closer to a static class (in C#) or as a function within a function:</p>
<pre class="calibre21">impl MyImpl<br class="calibre2"/>{<br class="calibre2"/>  fn reference_name (&amp;self) ... <br class="calibre2"/>}</pre>
<p class="calibre1">This would be more for a non-generic type. For generics, the preceding code becomes the following:</p>
<pre class="calibre21">impl &lt;T&gt; MyGenericImpl&lt;T&gt;<br class="calibre2"/>{<br class="calibre2"/>  fn reference_name(&amp;self) ... <br class="calibre2"/>}</pre>
<p class="calibre1">Note that the <kbd class="calibre10">&lt;T&gt;</kbd> is required to tell the compiler that the <kbd class="calibre10">impl</kbd> is for a generic. <kbd class="calibre10">reference_name</kbd> is the name used to access the <kbd class="calibre10">impl</kbd> function. It can be anything you wish.</p>
<p>An example of <kbd class="calibre22">impl</kbd> can be found in <kbd class="calibre22">09/impl_example</kbd>.</p>
<p class="calibre1">If you build and run the <kbd class="calibre10">impl_example</kbd> code, you will get a result like this:</p>
<div><img src="img/00068.jpeg" class="image-border6"/></div>
<p class="calibre1">The code creates two implementations for two functions that provide a defined functionality.</p>
<p class="calibre1">The <kbd class="calibre10">impl_example</kbd> is a very simple example. An <kbd class="calibre10">impl</kbd> can be as complex as required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The impl lifetime</h1>
                
            
            
                
<p class="calibre1">As mentioned in Chapter 8, <em class="calibre9">The Rust Application Lifetime</em>, we can use a lifetime with an <kbd class="calibre10">impl</kbd>:</p>
<pre class="calibre21">impl&lt;'a&gt; MyFunction&lt;'a&gt;(varname: &amp;'a as i32) {...}</pre>
<p class="calibre1"><kbd class="calibre10">'a</kbd> is denoted directly after both the <kbd class="calibre10">impl</kbd> and <kbd class="calibre10">MyFunction</kbd>. For the <kbd class="calibre10">impl</kbd>, it's to say we're using it, while after <kbd class="calibre10">MyFunction</kbd>, it's to say we're using it within <kbd class="calibre10">MyFunction</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">And back to traits we go...</h1>
                
            
            
                
<p class="calibre1">The simplest way to think of a trait is that it creates a signature to the implementation. If you're used to C (or C++), then you will have seen this in code akin to this:</p>
<pre class="calibre21">// mylib.h <br class="calibre2"/>int myFunction(int a, int b, float c);<br class="calibre2"/> <br class="calibre2"/>// mylib.c<br class="calibre2"/>#include "mylib.h"<br class="calibre2"/>int myFunction(int a, int b, float c)<br class="calibre2"/>{<br class="calibre2"/>  // implement the code <br class="calibre2"/>  return some_value; <br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>// myotherfile.c <br class="calibre2"/>#include "mylib.h"<br class="calibre2"/>int some_function()<br class="calibre2"/>{<br class="calibre2"/>  int value = myFunction(1, 2, 3.14f); <br class="calibre2"/>  return value; <br class="calibre2"/>}</pre>
<p class="calibre1">The compiler accepts this code is correct as there is a signature in the <kbd class="calibre10">.h</kbd> file that says somewhere there is a compiled function that provides the implementation of this call. When the compiler comes to link everything together, the code that was promised by the signature is found and <kbd class="calibre10">myFunction</kbd> does whatever it's supposed to do and returns the <kbd class="calibre10">int</kbd>.</p>
<p class="calibre1">In C#, this would be supplied via an <kbd class="calibre10">interface</kbd>.</p>
<p class="calibre1">With Rust, we have something very similar.</p>
<p class="calibre1">The <kbd class="calibre10">trait</kbd> supplies the signature, the <kbd class="calibre10">impl</kbd> supplies the implementation, and the code calls the <kbd class="calibre10">impl</kbd>.</p>
<p class="calibre1">Now this may seem somewhat like overkill. Why would you create a stub when the implementation is typically in the same source file? The answer is we can use traits in a Rust library known as a <strong class="calibre8">crate</strong>. The trait tells the compiler that somewhere the code is implemented and it will be linked at the last stage of the build.</p>
<p class="calibre1">We will look at crates in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A simple crate example</h1>
                
            
            
                
<p class="calibre1">In this example, we will create a trait that will contain the signature for two functions: <kbd class="calibre10">calc_perimeter</kbd> and <kbd class="calibre10">calc_area</kbd>. To start with, we construct a <kbd class="calibre10">struct</kbd>. In this case, we will have two <kbd class="calibre10">struct</kbd>s:</p>
<pre class="calibre21">struct Perimeter <br class="calibre2"/>{<br class="calibre2"/>  side_one: i32,<br class="calibre2"/>  side_two: i32, <br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>struct Oval <br class="calibre2"/>{<br class="calibre2"/>  radius: f32,<br class="calibre2"/>  height: f32,<br class="calibre2"/>}</pre>
<p class="calibre1">We need to create a trait for each. The general format for a trait looks like this:</p>
<pre class="calibre21">trait TraitName <br class="calibre2"/>{ <br class="calibre2"/>  fn function_name(&amp;self) -&gt; return_type; <br class="calibre2"/>}</pre>
<p class="calibre1">In our case, we would have the following:</p>
<pre class="calibre21">trait CalcPerimeter<br class="calibre2"/>{<br class="calibre2"/>  fn calc_perimeter(&amp;self) -&gt; i32; <br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>trait CalcArea <br class="calibre2"/>{<br class="calibre2"/>  fn calc_area(&amp;self) -&gt; f32; <br class="calibre2"/>}</pre>
<p class="calibre1">We now need to create an implementation for both of these traits. The <kbd class="calibre10">impl</kbd>, though, will not look quite the same.</p>
<p class="calibre1">Before, we had the following:</p>
<pre class="calibre21">impl SomeImplement<br class="calibre2"/>{ <br class="calibre2"/>  ...<br class="calibre2"/>}</pre>
<p class="calibre1">This time, we have to give the name of the struct it relates to:</p>
<pre class="calibre21">impl SomeImplement for MyStruct <br class="calibre2"/>{<br class="calibre2"/>  ...<br class="calibre2"/>}</pre>
<p class="calibre1">If the <kbd class="calibre10">impl</kbd> defines the trait and the trait is just a stub, why do we need to say which struct it is for?</p>
<p class="calibre1">This is a fair question.</p>
<p class="calibre1">Without the trait, an <kbd class="calibre10">impl</kbd> operates in a similar way to a function. We supply the parameters to the <kbd class="calibre10">impl</kbd> via <kbd class="calibre10">&amp;self</kbd>. When we have a trait, the <kbd class="calibre10">impl</kbd> has to say what <kbd class="calibre10">&amp;self</kbd> refers to.</p>
<p>The code for this can be found in <kbd class="calibre22">09/non_generic_trait</kbd>.</p>
<p class="calibre1">Our <kbd class="calibre10">impl</kbd> for the first trait will be as follows:</p>
<pre class="calibre21">impl CalcPerimeter for Perimeter <br class="calibre2"/>{ <br class="calibre2"/>  fn calc_perimeter(&amp;self) -&gt; i32 <br class="calibre2"/>  {<br class="calibre2"/>    self.side_one * 2 + self.side_two * 2 <br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="calibre1">Note that the function can access <kbd class="calibre10">side_one</kbd> and <kbd class="calibre10">side_two</kbd> from the <kbd class="calibre10">Perimeter struct</kbd>.</p>
<p class="calibre1">The second <kbd class="calibre10">impl</kbd> will look like this:</p>
<pre class="calibre21">impl CalcArea for Oval<br class="calibre2"/>{ <br class="calibre2"/>  fn calc_area(&amp;self) -&gt; f32 <br class="calibre2"/>  { <br class="calibre2"/>    3.1415927f32 * self.radius * self.height <br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="calibre1">Finally, the calls to the implementations. Unlike previous examples, both of the structures have to be initialized and then the implementation call given:</p>
<pre class="calibre21">fn main() <br class="calibre2"/>{ <br class="calibre2"/>  let peri = Perimeter <br class="calibre2"/>  {<br class="calibre2"/>    side_one: 5, side_two: 12 };<br class="calibre2"/>    println!("Side 1 = 5, Side 2 = 12, Perimeter = {}", <br class="calibre2"/>              peri.calc_perimeter());<br class="calibre2"/>    let area = Oval <br class="calibre2"/>    {<br class="calibre2"/>      radius: 5.1f32,<br class="calibre2"/>      height: 12.3f32<br class="calibre2"/>    };<br class="calibre2"/>    println!("Radius = 5.1, Height = 12.3, Area = {}", <br class="calibre2"/>              area.calc_area()); }</pre>
<p class="calibre1">Once the code has been compiled, the expected answer is as shown in the following screenshot:</p>
<div><img src="img/00069.jpeg" class="image-border6"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Traits and generics</h1>
                
            
            
                
<p class="calibre1">If we look at the code, we have two structures that effectively do the same thing, with the only difference being the types for the parameters aren't the same. We can alter the member names for the structures without an issue to make life simpler:</p>
<pre class="calibre21">struct Perimeter { side_one: i32, side_two: i32, } <br class="calibre2"/>struct Oval { radius: f32, height: f32, }</pre>
<p class="calibre1">This would become the following:</p>
<pre class="calibre21">struct Shape&lt;T&gt; { line_one: T, line_two: T, }</pre>
<p class="calibre1">The calculation cannot be altered as they are totally different, but will need the parameter names to be altered. The other aspect to alter will be the name for the functions. Let's create a version of the code that only uses part of the code.</p>
<p class="calibre1">As we have the generic version of the <kbd class="calibre10">struct</kbd>, we next need to create the trait:</p>
<pre class="calibre21">trait Calculate&lt;T&gt; { fn calc(&amp;self) -&gt; T; }</pre>
<p class="calibre1">We have to use <kbd class="calibre10">&lt;T&gt;</kbd> as the <kbd class="calibre10">trait</kbd> has to take a generic.</p>
<p class="calibre1">The construction for the implementation can be achieved in one of two ways.</p>
<p>The code for this section can be found in <kbd class="calibre22">09/generic_traits_simple</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining the impl for specific types</h1>
                
            
            
                
<p class="calibre1">This is by far the simplest way of creating the code. We define the types that <kbd class="calibre10">Shape</kbd> can take:</p>
<pre class="calibre21">impl Calculate&lt;i32&gt; for Shape&lt;i32&gt; <br class="calibre2"/>{ <br class="calibre2"/>  fn calc(&amp;self) -&gt; i32<br class="calibre2"/>  {<br class="calibre2"/>    self.line_one * 2 + self.line_two * 2 <br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="calibre1">Writing the code like this ensures that we cannot pass anything into the implementations that don't make any sense (for example, types that cannot have <kbd class="calibre10">+</kbd> or <kbd class="calibre10">*</kbd> applied to them).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using where</h1>
                
            
            
                
<p class="calibre1">If you're used to programming using generics in C#, this should be familiar to you.</p>
<p class="calibre1">Rust contains an implementation of <kbd class="calibre10">where</kbd>, so we are able to define what <kbd class="calibre10">where</kbd> is. This means that, as we had in an earlier example for this chapter, the construct <kbd class="calibre10">&lt;T: Mul&lt;Output = T&gt;&gt;</kbd> can be used in a modified way:</p>
<pre class="calibre21">impl&lt;T&gt; Calculate&lt;T&gt; for Shape&lt;T&gt; where T: Mul&lt;Output = T&gt;</pre>
<p class="calibre1">This does, though, give rise to a number of other issues. Two simple ones are that we multiply by <kbd class="calibre10">2</kbd>—however, that value isn't clear if it's <kbd class="calibre10">2u8</kbd> or <kbd class="calibre10">2i32</kbd>. We also try to add values together, but as with multiplying <kbd class="calibre10">T</kbd> together, there is no guarantee you can add by <kbd class="calibre10">T</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Making it work</h1>
                
            
            
                
<p class="calibre1">The final step is to add a <kbd class="calibre10">main</kbd> function. We can use the same function as was in the non-generic trait example but with the oval removed:</p>
<pre class="calibre21">fn main() <br class="calibre2"/>{<br class="calibre2"/>  let peri = Shape<br class="calibre2"/>  {<br class="calibre2"/>    line_one: 5,<br class="calibre2"/>    line_two: 12<br class="calibre2"/>  };<br class="calibre2"/>  println!("line_one = 5, line_two = 12, Perimeter = {}", <br class="calibre2"/>            peri.calc ()); <br class="calibre2"/>}</pre>
<p class="calibre1">When compiled, this gives the following output:</p>
<div><img src="img/00070.jpeg" class="image-border6"/></div>
<p class="calibre1">As we have created the second implementation, extending the <kbd class="calibre10">main</kbd> function to include the second calculation should be trivial.</p>
<p>See <kbd class="calibre22">09/generic_trait_full</kbd> for the code files of this part.</p>
<p class="calibre1">We also need to implement the <kbd class="calibre10">f32</kbd> calculation:</p>
<pre class="calibre21">impl Calculate&lt;f32&gt; for Shape&lt;f32&gt; <br class="calibre2"/>{<br class="calibre2"/>  fn calc(&amp;self) -&gt; f32 <br class="calibre2"/>  {<br class="calibre2"/>    3.1415927f32 * self.line_one * self.line_two<br class="calibre2"/>  } <br class="calibre2"/>}</pre>
<p class="calibre1">When this is compiled, we see the following:</p>
<div><img src="img/00071.jpeg" class="image-border6"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Something you may have noticed</h1>
                
            
            
                
<p class="calibre1">If we compare the two different implementations of the code (generic and non-generic), the main difference is that we have reduced the amount of code we need as the two structs were the same in all but the name. We have also simplified the code so that we have a single call to calc and allow the compiler to decide which one we need based on the type passed in.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generics - a small aside</h1>
                
            
            
                
<p class="calibre1">Code reduction and simplification is always a good thing (well, mostly at least!). However, with generics, there is always a trade-off and it's not always apparent.</p>
<p class="calibre1">Let's consider the following piece of code:</p>
<pre class="calibre21">fn my_multiply&lt;T: Mul&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T { return a * b; }</pre>
<p class="calibre1">This returns a value of type <kbd class="calibre10">T</kbd> by multiplying two variables (of type <kbd class="calibre10">T</kbd>).</p>
<p class="calibre1">The question is: You can send a number of types into that function - how will the compiler know what to do if it doesn't know what type <kbd class="calibre10">T</kbd> is? The only safe way is to create a version of <kbd class="calibre10">my_multiply</kbd> for each possible type. Fortunately, the compiler does this automatically for you in a process called monomorphization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">So what does happen?</h1>
                
            
            
                
<p class="calibre1">To give all of these generated functions unique names, compilers that work with generics use a process called <strong class="calibre8">name mangling</strong> (or <em class="calibre9">name munging</em>). This creates a unique name for each internally created function that takes generic parameters.</p>
<p class="calibre1">For which one to use, during linking, the linker analyzes the code <em class="calibre9">signatures</em> required. If the linker sees a signature requiring <kbd class="calibre10">f32</kbd> for <kbd class="calibre10">T</kbd>, that munged name object code is included in the final object list. Once the linker has finished with the analysis, the unused objects (those not on the final list) are stripped out. The final binary therefore only contains the required code and not every variation of the types possible.</p>
<p>While different compilers treat generics differently, the process for compilation, name munging, and then final stripping is common among them all!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Back to the where version</h1>
                
            
            
                
<p class="calibre1">The <kbd class="calibre10">where</kbd> version of the code is more complex than the non-where version.</p>
<p>The source for this version can be found in <kbd class="calibre22">09/generic_trait_where</kbd>.</p>
<p class="calibre1">Let's examine the code:</p>
<pre class="calibre21">extern crate num; <br class="calibre2"/>use std::ops::{Add, Mul}; <br class="calibre2"/>use num::FromPrimitive;</pre>
<p class="calibre1">We have seen <kbd class="calibre10">std::ops::Mul</kbd> before in the generic multiplication example. If we need to include multiple items from <kbd class="calibre10">std::ops</kbd> (or indeed any library), they are held in curly braces; <kbd class="calibre10">{}</kbd>. Here, we include <kbd class="calibre10">Add</kbd> and <kbd class="calibre10">Mul</kbd>.</p>
<p class="calibre1">Up until this point, we have not seen the <kbd class="calibre10">extern crate</kbd> directive. For now, it is enough to know that this will include an external library. Crates are covered in Chapter 9, <em class="calibre9">Generics and Traits</em>.</p>
<p class="calibre1">Finally, we use <kbd class="calibre10">FromPrimitive</kbd> from the <kbd class="calibre10">num</kbd> library.</p>
<p class="calibre1">Our <kbd class="calibre10">struct</kbd> and <kbd class="calibre10">trait</kbd> are the same as before. The implementation, though, is different:</p>
<pre class="calibre21">impl&lt;T&gt; Calculate&lt;T&gt; for Shape&lt;T&gt; <br class="calibre2"/>  where T: Copy + FromPrimitive + Add&lt;Output = T&gt; + <br class="calibre2"/>  Mul&lt;Output = T&gt; <br class="calibre2"/>{<br class="calibre2"/>  fn calc(&amp;self) -&gt; T {<br class="calibre2"/>    let two = T::from_u8(2).expect("Unable to create a value of 2");<br class="calibre2"/>    self.line_one * two + self.line_two * two<br class="calibre2"/>  } <br class="calibre2"/>}</pre>
<p class="calibre1">There are two important lines in this code: <kbd class="calibre10">where T:Copy + FromPrimitive + Add&lt;Output = T&gt; + Mul&lt;Output = T&gt;</kbd> and <kbd class="calibre10">let two = T::from_u8(2).expect("Unable to create a value of 2");</kbd>.</p>
<p class="calibre1">Here, we are saying that we want to copy the type, we'll be using <kbd class="calibre10">FromPrimitive</kbd> to cast a primitive to <kbd class="calibre10">T</kbd>, and both the <kbd class="calibre10">Add</kbd> and <kbd class="calibre10">Mul</kbd> outputs will be of type <kbd class="calibre10">T</kbd>. Rust concatenates the parameters that a <kbd class="calibre10">where</kbd> uses using <kbd class="calibre10">+</kbd>.</p>
<p class="calibre1">The <kbd class="calibre10">let two</kbd> line creates a variable that takes an unsigned 8-bit value and casts that to <kbd class="calibre10">T</kbd>. If it fails, the error is thrown.</p>
<p class="calibre1">We have to use <kbd class="calibre10">Add&lt;Output = T&gt;</kbd> to ensure we can add the types together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Try to compile</h1>
                
            
            
                
<p class="calibre1">If you use the standard <kbd class="calibre10">cargo run</kbd>, you will be met with an error that the compiler is <kbd class="calibre10">unable to find extern crate num</kbd>. This is down to cargo not knowing where the dependencies are held. At the first time of grabbing an external reference, Rust will update the list of available crates (the registry) and then download the ones required. To do this, the <kbd class="calibre10">Cargo.toml</kbd> file needs to be edited and the following code inserted:</p>
<pre class="calibre21">[dependencies] <br class="calibre2"/>num = "*"</pre>
<p class="calibre1">Once this has been saved and the <kbd class="calibre10">cargo run</kbd> executed, you will see output like this:</p>
<div><img src="img/00072.jpeg" class="image-border6"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Trait bounds</h1>
                
            
            
                
<p class="calibre1">A trait can also have a bound placed upon it. In effect, a bound is a rule that the trait has to abide by and is added to the declaring type parameter.</p>
<p>The source for this part is in <kbd class="calibre22">09/trait_bound_gen_struct</kbd>.</p>
<p class="calibre1">In the code example, the <kbd class="calibre10">impl</kbd> has a <kbd class="calibre10">PartialEq</kbd> bound placed upon the generic type. Our <kbd class="calibre10">struct</kbd> contains four parameters within it and so we only want to test for partial equality within that <kbd class="calibre10">struct</kbd>. If we didn't have the <kbd class="calibre10">PartialEq</kbd> on the declared type parameter, the compilation would fail as we're not testing everything within that <kbd class="calibre10">struct</kbd>.</p>
<p class="calibre1">When the code is compiled, we get the following output:</p>
<div><img src="img/00073.jpeg" class="image-border6"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Can we reduce the amount of code further?</h1>
                
            
            
                
<p class="calibre1">Yes. It is possible to completely omit the requirement to create an implementation of a trait if that trait contains a default method:</p>
<pre class="calibre21">trait MyTrait <br class="calibre2"/>{<br class="calibre2"/>  fn test_code(&amp;self) -&gt; bool;<br class="calibre2"/>  fn self_test_code(&amp;self) -&gt; bool { self.test_code() } }</pre>
<p class="calibre1"><kbd class="calibre10">test_code</kbd> is just the stub which requires an implementation. The <kbd class="calibre10">self_test_code</kbd> function doesn't need an implementation as it has a default method already.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Can the default method be overridden?</h1>
                
            
            
                
<p class="calibre1">It can.</p>
<p>The code for this section is in <kbd class="calibre22">09/override_default_method</kbd>.</p>
<p class="calibre1">Let's start the code off by defining a <kbd class="calibre10">trait</kbd>. This has a default method for <kbd class="calibre10">is_not_done</kbd>. We will still need to implement <kbd class="calibre10">is_done</kbd> though, which we do for the <kbd class="calibre10">UseFirstTime</kbd> struct:</p>
<pre class="calibre21">struct UseFirstTime; <br class="calibre2"/>impl MyTrait for UseFirstTime <br class="calibre2"/>{<br class="calibre2"/>  fn is_done(&amp;self) -&gt; bool <br class="calibre2"/>  {<br class="calibre2"/>    println!("UseFirstTime.is_done"); <br class="calibre2"/>    true<br class="calibre2"/>  } <br class="calibre2"/>}</pre>
<p class="calibre1">We next want to override the default method for <kbd class="calibre10">is_not_done</kbd>. Again, we create an empty <kbd class="calibre10">struct</kbd> and write both the implementations for <kbd class="calibre10">is_done</kbd> and <kbd class="calibre10">is_not_done</kbd>. When we call <kbd class="calibre10">is_not_done</kbd> from the second <kbd class="calibre10">struct</kbd>, the <kbd class="calibre10">println!</kbd> from the second <kbd class="calibre10">struct</kbd> is shown and not the first:</p>
<pre class="calibre21">struct OverrideFirstTime;<br class="calibre2"/>impl MyTrait for OverrideFirstTime <br class="calibre2"/>{<br class="calibre2"/>  fn is_done(&amp;self) -&gt; bool <br class="calibre2"/>  {<br class="calibre2"/>    println!("OverrideFirstTime.is_done");<br class="calibre2"/>    true<br class="calibre2"/>  }<br class="calibre2"/>  fn is_not_done(&amp;self) -&gt; bool <br class="calibre2"/>  {<br class="calibre2"/>    println!("OverrideFirstTime.is_not_done");<br class="calibre2"/>    true<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="calibre1">When compiled, we get the following output:</p>
<div><img src="img/00074.jpeg" class="image-border6"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rounding off traits</h1>
                
            
            
                
<p class="calibre1">This has been a large topic, but we have two more aspects to consider for traits: inheritance and deriving. One that should be familiar if you're used to any form of object-oriented programming.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inheritance</h1>
                
            
            
                
<div><p class="calibre1">This is very similar to inheritance within C++ and C#:</p>
<pre class="calibre21">trait One <br class="calibre2"/>{<br class="calibre2"/>  fn one(&amp;self); <br class="calibre2"/>}<br class="calibre2"/>trait OneTwo : One <br class="calibre2"/>{<br class="calibre2"/>  fn onetwo(&amp;self); <br class="calibre2"/>}</pre></div>
<p>Code for this part is in <kbd class="calibre22">09/inheritance</kbd>.</p>
<p class="calibre1">The code that implements <kbd class="calibre10">OneTwo</kbd> must also implement <kbd class="calibre10">One</kbd> (the same as when we overrode the default method, we still had to define <kbd class="calibre10">is_done</kbd>), therefore:</p>
<pre class="calibre21">struct Three; <br class="calibre2"/>impl One for Three <br class="calibre2"/>{ <br class="calibre2"/>  fn one(&amp;self) <br class="calibre2"/>  {<br class="calibre2"/>    println!("one");<br class="calibre2"/>  }<br class="calibre2"/>}<br class="calibre2"/>impl OneTwo for Three <br class="calibre2"/>{<br class="calibre2"/>  fn onetwo(&amp;self) <br class="calibre2"/>  {<br class="calibre2"/>    println!("onetwo");<br class="calibre2"/>  } <br class="calibre2"/>}</pre>
<p class="calibre1">And the result is as follows:</p>
<div><img src="img/00075.jpeg" class="image-border6"/></div>
<p class="calibre1">If we omitted the <kbd class="calibre10">impl One</kbd> block, we would get a compilation error complaining that <kbd class="calibre10">impl OneTwo</kbd> requires <kbd class="calibre10">impl One</kbd> to exist.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deriving</h1>
                
            
            
                
<p class="calibre1">Rust provides a handy attribute that allows you to access a number of commonly used traits without having to implement them yourself time and again. They are called using <kbd class="calibre10">#[derive(Trait_Name)]</kbd>.</p>
<p class="calibre1">The traits available are as follows:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Clone</kbd>: This creates a clone of the object</li>
<li class="calibre13"><kbd class="calibre10">Copy</kbd>: This creates a copy of the object</li>
<li class="calibre13"><kbd class="calibre10">Debug</kbd>: This provides debugging code</li>
<li class="calibre13"><kbd class="calibre10">Default</kbd>: This gives a useful default value for a type</li>
<li class="calibre13"><kbd class="calibre10">Eq</kbd>: <kbd class="calibre10">Equality</kbd>, this is similar to <kbd class="calibre10">PartialEq</kbd> except for all parameters within a struct</li>
<li class="calibre13"><kbd class="calibre10">Hash</kbd>: This is a hashable type</li>
<li class="calibre13"><kbd class="calibre10">Ord</kbd>: <kbd class="calibre10">Order</kbd>, these are the types that form a total order on all types</li>
<li class="calibre13"><kbd class="calibre10">PartialEq</kbd>: <kbd class="calibre10">Partial Equality</kbd>, this only tests on a subset of the struct</li>
<li class="calibre13"><kbd class="calibre10">PartialOrd</kbd>: <kbd class="calibre10">Partial Order</kbd>, values that can compared to create a sort order</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Trait objects</h1>
                
            
            
                
<p class="calibre1">Typically, when we call a function in Rust, we will have a line in the code similar to this:</p>
<pre class="calibre21">call_some_method(some_value);</pre>
<p class="calibre1">When we have a <kbd class="calibre10">struct</kbd> in the code which has an <kbd class="calibre10">impl</kbd> attached to it, we will have this:</p>
<pre class="calibre21">let m = MyStruct {a: 3, b: 4, c: 1, d: 4}; m.call_some_method();</pre>
<p class="calibre1">These are both fine.</p>
<p class="calibre1">If you recall, back in the <kbd class="calibre10">generic_trait_full</kbd> example, we had <kbd class="calibre10">Calc</kbd> defined and <kbd class="calibre10">T</kbd> could be either an <kbd class="calibre10">f32</kbd> or <kbd class="calibre10">i32</kbd>. We also talked about how the application knew what to include in the final binary. This is known as <strong class="calibre8">static dispatch</strong> (which Rust prefers).</p>
<p class="calibre1">Rust uses a system called a <strong class="calibre8">dispatch</strong>, of which there are two types: static (favored by Rust) and dynamic. Dynamic dispatch relies on something called a <strong class="calibre8">trait object</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Let's create a sample test setup</h1>
                
            
            
                
<div><p class="calibre1">The test code is very simple. We have a trait with a function that returns a <kbd class="calibre10">String</kbd>. We then have a couple of implementations and a parameter bound function that will display the result from the implementations:</p>
<pre class="calibre21">trait StaticObject <br class="calibre2"/>{ <br class="calibre2"/>  fn static_method(&amp;self) -&gt; String; <br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/>impl StaticObject for u8 <br class="calibre2"/>{<br class="calibre2"/>  fn static_method(&amp;self) -&gt; String {format!("u8 : {}, ", *self)} <br class="calibre2"/>} <br class="calibre2"/><br class="calibre2"/>impl StaticObject for String <br class="calibre2"/>{ <br class="calibre2"/>  fn static_method(&amp;self) -&gt; String {format!("string : {}", *self)} <br class="calibre2"/>} <br class="calibre2"/><br class="calibre2"/>fn display_code&lt;T: StaticObject&gt;(data : T) <br class="calibre2"/>{<br class="calibre2"/>  println!("{}", data.static_method()); <br class="calibre2"/>} <br class="calibre2"/><br class="calibre2"/>fn main() <br class="calibre2"/>{<br class="calibre2"/>  let test_one = 8u8;<br class="calibre2"/>  let test_two = "Some text".to_string();<br class="calibre2"/>  display_code(test_one);<br class="calibre2"/>  display_code(test_two); <br class="calibre2"/>}</pre></div>
<p>The code for this part can be found in <kbd class="calibre22">09/trait_object_static</kbd>.</p>
<p class="calibre1">When compiled and executed, we get the following:</p>
<div><img src="img/00076.jpeg" class="image-border6"/></div>
<p class="calibre1">From the previous explanation, we know that the compiler will generate the various types that <kbd class="calibre10">T</kbd> can be.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Let's see dynamic dispatch</h1>
                
            
            
                
<p class="calibre1">Dynamic dispatch uses trait objects. A trait object can store a value of any type that implements the <kbd class="calibre10">trait</kbd>. The actual type of the value is only known at runtime.</p>
<p>The code for this section can be found in <kbd class="calibre22">09/dynamic_dispatch</kbd>.</p>
<p class="calibre1">Let's look at some code to explain how this works.</p>
<p class="calibre1">Previously, we had for <kbd class="calibre10">display_code</kbd> the following:</p>
<pre class="calibre21">fn display_code&lt;T: StaticObject&gt;(data: T) <br class="calibre2"/>{<br class="calibre2"/>  println!("{}", data.static_method()); <br class="calibre2"/>}</pre>
<p class="calibre1">We now have this:</p>
<pre class="calibre21">fn display_code(data : &amp;DynamicObject) <br class="calibre2"/>{<br class="calibre2"/>  println!("{}", data.dynamic_method()); <br class="calibre2"/>}</pre>
<p class="calibre1">We no longer have the <kbd class="calibre10">T</kbd> parameter.</p>
<p class="calibre1">In the static version, <kbd class="calibre10">display_code</kbd> was called like this:</p>
<pre class="calibre21">display_code(test_one);</pre>
<p class="calibre1">For the dynamic version, we use the following:</p>
<pre class="calibre21">display_code(&amp;test_one as &amp;DynamicObject);</pre>
<p class="calibre1">The trait object has been obtained from the pointer (<kbd class="calibre10">&amp;DynamicObject</kbd>) which implemented the trait by using the cast (<kbd class="calibre10">&amp;test_one as &amp;DynamicObject</kbd>). It is also acceptable to use <kbd class="calibre10">display_code(&amp;test_one)</kbd>. This is known as coercion: <kbd class="calibre10">&amp;test_one</kbd> has been used as an argument to a function that takes <kbd class="calibre10">&amp;DynamicObject</kbd>.</p>
<p class="calibre1">The only issue with dynamic dispatch is that it can be slower, as each time the code is run, the runtime <em class="calibre9">forgets</em> the type of the pointer and has to create a new implementation for the different type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Keeping your object safe</h1>
                
            
            
                
<p class="calibre1">We can't use all traits to create a trait object. Take the following:</p>
<pre class="calibre21">let my_vec = vec![1,3,5,7,9]; <br class="calibre2"/>let dupe = &amp;my_vec as &amp;Clone;</pre>
<p class="calibre1">This will not compile as <kbd class="calibre10">Clone</kbd> is not object-safe as <kbd class="calibre10">Clone</kbd> contains <kbd class="calibre10">Self: Sized</kbd>, which a trait cannot have.</p>
<p class="calibre1">If the trait doesn't require <kbd class="calibre10">Self: Sized</kbd> and all of the methods are object-safe, it is an object-safe trait. For a method to be object-safe, it must require <kbd class="calibre10">Self: Sized</kbd>. If the method doesn't require <kbd class="calibre10">Self: Sized</kbd>, it can still be object-safe if the method doesn't require any parameters and doesn't use <kbd class="calibre10">Self</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre1">Traits and generics are a key feature for development and Rust is feature-rich for these. We have seen how to create implementations, how to use generics, how to ensure that the types can be bound, and the power of traits. Hopefully, you should be appreciating now the sheer power that generics provide to the developer in terms of flexibility. Generics also allow for reducing the amount of code we (as developers) have to write by essentially removing the need to worry too much about what the generic represents.</p>
<p class="calibre1">In the next chapter, we will be looking at extending our Rust applications by the use of external libraries, known as crates.</p>


            

            
        
    </body></html>