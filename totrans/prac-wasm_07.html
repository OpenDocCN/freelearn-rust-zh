<html><head></head><body>
		<div><h1 id="_idParaDest-61"><em class="italic"><a id="_idTextAnchor069"/>Chapter 5</em>: Understanding Sections in WebAssembly Modules</h1>
			<p>A WebAssembly module is composed of zero or more sections. Each section has its own functionality. In the previous chapters, we saw how functions are defined inside a WebAssembly module. A function is a section inside a WebAssembly module. </p>
			<p>In this chapter, we will explore the various other sections inside a WebAssembly module. Understanding the various sections inside a WebAssembly module will make it easier for us to identify, debug, and write efficient WebAssembly modules. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Exports and imports</li>
				<li>Globals</li>
				<li>Start </li>
				<li>Memory</li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections">https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections</a>.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor071"/>Exports and imports</h1>
			<p>A WebAssembly module consists of export and import sections. These sections are responsible for exporting functions out of and importing functions into the WebAssembly module.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor072"/>Exports</h2>
			<p>In order to call the functions defined in a WebAssembly module from JavaScript, we need to export the <a id="_idIndexMarker217"/>functions from the WebAssembly module. The export section is <a id="_idIndexMarker218"/>where we will define all the functions that are exported out of the WebAssembly module. </p>
			<p>Let's go back to our classic <code>add.wat</code> example from the previous chapter:</p>
			<pre>; add.wat
(module
    (func $add (param $lhs i32) (param $rhs i32) 
      (result i32)
        get_local $lhs
        get_local $rhs
        i32.add)
    (export "add" (func $add))
)</pre>
			<p>Here, we have exported the <code>add</code> function using the <code>(export "add" (func $add))</code> statement. To export a function, we have used the <code>export</code> keyword followed by the name of the function and then the pointer to the exported function itself. </p>
			<p>Remember that WebAssembly is compact-sized. Thus, we can represent the export statement along with the function definition itself, like so:</p>
			<pre>; add.wat
(module
    (func $add (export "add") (param $lhs i32) 
      (param $rhs i32) (result i32)
        get_local $lhs
        get_local $rhs
        i32.add)
)</pre>
			<p>Let's use WABT's <code>wat2wasm</code> tool to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<pre>$ /path/to/wabt/bin/wat2wasm add.wat</pre>
			<p>Let's analyze the generated byte code using the <code>hexdump</code> tool:</p>
			<pre>$ hexdump add.wasm
0000000 00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 01
0000010 7f 03 02 01 00 07 07 01 03 61 64 64 00 00 0a 09
0000020 01 07 00 20 00 20 01 6a 0b
0000029</pre>
			<p>As expected, the <a id="_idIndexMarker219"/>first byte consists of the magic header <a id="_idIndexMarker220"/>and version of the binary <code>00 61 73 6d 01 00 00 00</code>: </p>
			<pre>0000000: 0061 736d                   ; WASM_BINARY_MAGIC
0000004: 0100 0000                   ; WASM_BINARY_VERSION</pre>
			<p>The next bit is <code>01</code>, which represents the section index of the type section. Following that, we have the size of the type section, which is <code>07</code>. The next seven bits are the type section. <code>01</code> represents the number of type definitions available:</p>
			<pre>; section "Type" (1)
0000008: 01                          ; section code
0000009: 07                          ; section size
000000a: 01                          ; num types</pre>
			<p>Then, we have <code>60</code>, which represents <code>func</code>. Following that, we have <code>02</code>, representing the two parameters. <code>7f</code> is the opcode for defining the i32 type. Since both the parameters are i32, we have consecutive <code>7f</code> opcodes. Following that, the last two bits represent the return type and there is also <code>7f</code> representing i32:</p>
			<pre>; type 0
000000b: 60                          ; func
000000c: 02                          ; num params
000000d: 7f                          ; i32
000000e: 7f                          ; i32
000000f: 01                          ; num results
0000010: 7f                          ; i32</pre>
			<p>After the <code>type</code> section, we have the <code>func</code> section. The unique identifier for the <code>func</code> section is <code>03</code>. Following that, we have <code>02</code>, which defines the size of the function section. That is the size of the function section is just 2 bits. But we defined the function definition for <code>add</code> in the WebAssembly text format and the function is more than 2 bits in size. So, how is it possible? <a id="_idIndexMarker221"/>The reason is that <a id="_idIndexMarker222"/>the function section does not have the body of the function; instead, it just defines the available functions. The functions are defined in the code section. The next <code>01</code> defines that there is only one function defined in the module:</p>
			<pre>; section "Function" (3)
0000011: 03                          ; section code
0000012: 02                          ; section size
0000013: 01                          ; num functions
0000014: 00                          ; function 0 signature
  index</pre>
			<p>Then, we have the export section, which starts with <code>07</code>. The next <code>07</code> represents the size of the export section. Then, we define the number of exports exported in the export section. The next bit represents the length of the exported function name. The next <code>03</code> bits represent the function name, <code>add</code>. Then, the export section has the kind of export and function index of the exported function:</p>
			<pre>; section "Export" (7)
0000015: 07                          ; section code
0000016: 07                          ; section size
0000017: 01                          ; num exports
0000018: 03                          ; string length
0000019: 6164 64                add  ; export name
000001c: 00                          ; export kind
000001d: 00                          ; export func index</pre>
			<p>The last segment starts with <code>0a</code>. <code>0a</code> is a unique identifier for the code section. The code section is of length <code>09</code>. Next, <code>01</code> represents the number of functions defined in the code block.</p>
			<p>Next, <code>07</code> represents the length of the function definition. The next seven bits actually define the <a id="_idIndexMarker223"/>function block. <code>00</code> indicates that the function <a id="_idIndexMarker224"/>block does not have any local declarations. <code>20</code> is the opcode for <code>get_local</code> and we take the <code>00</code> index, and then again we have <code>20</code> opcode to <code>get_local</code> and we take the <code>01</code> index. Then, we add them using <code>i32.add</code>. The opcode for the i32 addition is <code>6a</code>. Finally, we use <code>0b</code> to end the function code block:</p>
			<pre>; section "Code" (10)
000001e: 0a                          ; section code
000001f: 09                          ; section size
0000020: 01                          ; num functions
  ; function body 0
0000021: 07                          ; func body size
 
0000022: 00                          ; local decl count
0000023: 20                          ; local.get
0000024: 00                          ; local index
0000025: 20                          ; local.get
0000026: 01                          ; local index
0000027: 6a                          ; i32.add
0000028: 0b                          ; end</pre>
			<p>We have seen how the export section is represented in a WebAssembly module. In the next section, let's see how the import section is represented in a WebAssembly module.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor073"/>Imports</h2>
			<p>In order to import a <a id="_idIndexMarker225"/>function from another WebAssembly <a id="_idIndexMarker226"/>module or JavaScript module, we need to import the functions in the WebAssembly module. The import section is where we will import all the external dependencies into the WebAssembly module.</p>
			<p>Now, let's imagine that a JavaScript module exports a function named <code>jsAdd</code>. We can import the <code>jsAdd</code> function using the <code>import</code> keyword. Create a file called <code>jsAdd.wat</code> and add the following content to it:</p>
			<pre>(module
    (func $i (import "imports" "jsAdd") (param i32))
)</pre>
			<p>Here, we are defining a function with the <code>func</code> keyword, followed by the name of the function, <code>$i</code>. We use <code>$i</code> to call the function inside the WebAssembly module. Then, we have the <code>import</code> keyword. The <code>import</code> keyword is followed by the module name. The module name here refers to the JavaScript module, and then we have the name of the function to import from the JavaScript module. </p>
			<p>Finally, we have <code>param</code>. Since a WebAssembly module is typed, we have to define the input parameters and return types in the function definition.</p>
			<p>Let's use WABT's <code>wat2wasm</code> to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<pre>$ /path/to/wabt/bin/wat2wasm jsAdd.wat</pre>
			<p>Let's analyze the generated byte code using the <code>hexdump</code> tool:</p>
			<pre>$ hexdump jsAdd.wasm
0000000 00 61 73 6d 01 00 00 00 01 05 01 60 01 7f 00 02
0000010 11 01 07 69 6d 70 6f 72 74 73 05 6a 73 41 64 64
0000020 00 00
0000022</pre>
			<p>The binary consists of the import section, which starts at the index of 16. The import section starts with <code>02</code> because the unique section index of the import section is <code>02</code>. After that, we have <code>11</code>, which represents the size of the import section in the binary. The next bit represents the number of imports, <code>01</code>.</p>
			<p>Then, we have the definition for the import. <code>07</code> here represents the length of the imported <a id="_idIndexMarker227"/>function. The next seven bits represent the name <a id="_idIndexMarker228"/>of the import module. The next bit represents the length of the function name, <code>05</code>, and the next five bits represent the function name. Finally, we have the kind and type signature of the index:</p>
			<pre>; Other information
; section "Import" (2)
000000f: 02                          ; section code
0000010: 11                          ; section size
0000011: 01                          ; num imports
; import header 0
0000012: 07                          ; string length
0000013: 696d 706f 7274 73           imports  ; import
  module name
000001a: 05                          ; string length
000001b: 6a73 4164 64         jsAdd  ; import field name
0000020: 00                          ; import kind
0000021: 00                          ; import signature
  index</pre>
			<p>Now, you can call the <code>jsAdd</code> function like you would other functions inside a WebAssembly module using the <code>$i</code> identifier. </p>
			<p>We have explored how both the import and export sections are defined inside a WebAssembly module and how they help to import and export a function. Now, let's explore how to import and export values in and out of a WebAssembly module. </p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor074"/>Globals</h1>
			<p>The globals section is where we can import and export values in and out of WebAssembly <a id="_idIndexMarker229"/>modules. In a WebAssembly module, you <a id="_idIndexMarker230"/>can import either mutable or immutable values from JavaScript. Additionally, WebAssembly also supports <code>wasmValue</code>, an internal immutable value inside the WebAssembly module itself.</p>
			<p>Let's create a file called <code>globals.wat</code> and add the following contents to it:</p>
			<pre>$ touch globals.wat
(module
     (global $mutableValue (import "js" "mutableGlobal")
       (mut i32))
     (global $immutableValue (import "js"
       "immutableGlobal") i32)
     (global $wasmValue i32 (i32.const 10))
     (func (export "getWasmValue") (result i32)
        (global.get $wasmValue))
     (func (export "getMutableValue") (result i32)
        (global.get $mutableValue))
     (func (export "getImmutableValue") (result i32)
        (global.get $immutableValue))
     (func (export "setMutableValue") (param $v i32)
        (global.set $mutableValue
            (local.get $v)))
)</pre>
			<p>We created a module (<code>module</code>) and three global variables:</p>
			<ul>
				<li><code>$mutableValue</code> – This value is imported from the <code>js</code> JavaScript module and the <code>mutableGlobal</code> variable. We also define the global variable to be of the <code>mut i32</code> type.</li>
				<li><code>$immutableValue</code> – This value is imported from the <code>js</code> JavaScript module and the <code>immutableGlobal</code> variable. We also define the global variable to be of the <code>i32</code> type.</li>
				<li><code>$wasmValue</code> – This is a global constant. We define the <code>global</code> keyword followed by the name of the global variable, <code>$wasmValue</code>, then the type of <code>i32</code>, and finally the actual value (<code>i32.const 10</code>). <p class="callout-heading">Note</p><p class="callout"><code>$wasmValue</code> is immutable and cannot be exported to the external world.</p></li>
			</ul>
			<p>Then, we have <a id="_idIndexMarker231"/>a set of functions that helps to get and set <a id="_idIndexMarker232"/>the global variables. <code>getWasmValue</code>, <code>getImmutableValue</code>, and <code>getMutableValue</code> get the values of the <code>wasmValue</code> global constant, the <code>immutableValue</code> global constant, and the <code>mutableValue</code> global variable, respectively.</p>
			<p>Finally, a function that sets <code>mutableValue</code> to a new value is <code>setMutableValue</code>. <code>setMutableValue</code> takes in <code>param $v</code>, which sets the value to <code>$mutableValue</code>.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<pre>$ /path/to/wabt/bin/wat2wasm globals.wat</pre>
			<p>Create a <code>globals.html</code> with the following content:</p>
			<pre>// globals.html
&lt;html&gt;
    &lt;head&gt; &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            async function run() {  }
            run()
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>Let's define the <code>run</code> function inside <code>&lt;script&gt;</code>.</p>
			<p>A <code>WebAssembly.Global</code> object represents a global variable instance, accessible from JavaScript and importable/exportable across one or more <code>WebAssembly.Module</code> instances. The <code>WebAssembly.Global</code> constructor expects a <a id="_idIndexMarker233"/>descriptor and value. The descriptor defines <a id="_idIndexMarker234"/>the type and mutability of the global variable defined:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This global variable constructor provides an option to dynamically link multiple WebAssembly modules.</p>
			<pre>let immutableGlobal = new WebAssembly.Global({value:'i32',
  mutable:false}, 1000)
let mutableGlobal = new WebAssembly.Global({value:'i32',
  mutable:true}, 0)</pre>
			<p>We create two global values using the <code>WebAssembly.Global</code> constructor. They are <code>immutableGlobal</code> and <code>mutableGlobal</code>. The former is <code>mutable:false</code>, while the latter is <code>mutable:true</code>. So, we can change the value of the latter using <code>mutableGlobal.value</code> but not the former. If we try changing the value of <code>immutableGlobal</code>, then we will receive an error:</p>
			<pre>mutableGlobal.value = 1337  // valid.
immutableGlobal.value = 7331 // Error</pre>
			<p>After that, we fetch the <code>globals.wasm</code> WebAssembly module. Then, we instantiate <code>arrayBuffer</code> with the response and <code>arrayBuffer</code> with the <code>WebAssembly.instantiate</code> constructor. In addition to this, the <code>WebAssembly.instantiate</code> constructor accepts <code>importsObject</code>. We can send the JavaScript module via <code>importsObject</code>:</p>
			<pre>const response = await fetch('./globals.wasm')
const bytes = await response.arrayBuffer()
const wasm = await WebAssembly.instantiate(bytes, { js: {
  mutableGlobal, immutableGlobal } })</pre>
			<p>In this case, we are <a id="_idIndexMarker235"/>sending in the <code>js</code> module along with the <code>mutableGlobal</code> and <code>immutableGlobal</code> values. The <code>wasm</code> variable now <a id="_idIndexMarker236"/>holds the WebAssembly module. We invoke <code>wasm.instance.exports</code> to get all the exported functions from the WebAssembly module:</p>
			<pre>const {
    getWasmValue,
    getMutableValue,
    setMutableValue,
    getImmutableValue
} =  wasm.instance.exports</pre>
			<p><code>getWasmValue</code>, <code>getMutableValue</code>, <code>setMutableValue</code>, and <code>getImmutableValue</code> are the functions exported from the WebAssembly module.</p>
			<p>The <code>getWasmValue</code> function returns the value of the <code>wasmValue</code> inside the WebAssembly module:</p>
			<pre>console.log(getWasmValue()) // 10</pre>
			<p>The <code>getMutableValue</code> and <code>setMutableValue</code> functions return and set the <code>mutableGlobal</code> field defined in JavaScript and passed into the WebAssembly module:</p>
			<pre>console.log(getMutableValue()) // 1337
setMutableValue(1338)
console.log(getMutableValue()) // 1338</pre>
			<p>Finally, we get the immutable value using the <code>getImmutableValue</code> function:</p>
			<pre>console.log(getImmutableValue()) // 1000</pre>
			<p>Let's run an example in the browser using the following command: </p>
			<pre>$ python -m http.server</pre>
			<p>Now, launch the URL <code>http://localhost:8000/globals.html</code> and open the developer tools.</p>
			<p>The WebAssembly <a id="_idIndexMarker237"/>binary contains an import section. The import section has <a id="_idIndexMarker238"/>a unique identifier, <code>02</code>, followed by the size of the section, which is <code>2b</code> (which is 43 in decimal). The next 43 bits represent the import section.</p>
			<p><code>02</code> at the <code>000015</code> index represents the number of imports. Then, we have two sections that define the imported global functions:</p>
			<pre> 
; section "Import" (2)
0000013: 02                          ; section code
0000014: 2b                          ; section size
0000015: 02                          ; num imports</pre>
			<p>Each global segment consists of the module string length and the module name, followed by the function string length and the function name. Finally, it has the kind of import, the type, and the mutability of the variable:</p>
			<pre> 
; import header 0
0000016: 02                          ; string length
0000017: 6a73                    js  ; import module name
0000019: 0d                          ; string length
000001a: 6d75 7461 626c 6547 6c6f 6261 6c
         mutableGlobal  ; import field name
0000027: 03                          ; import kind
0000028: 7f                          ; i32
0000029: 01                          ; global mutability
  ; import header 1
000002a: 02                          ; string length
000002b: 6a73                    js  ; import module name
000002d: 0f                          ; string length
000002e: 696d 6d75 7461 626c 6547 6c6f 6261 6c
    immutableGlobal  ; import field name
000003d: 03                          ; import kind
000003e: 7f                          ; i32
000003f: 00                          ; global mutability</pre>
			<p>After that, we have the <code>Global</code> section. The <code>Global</code> section has the unique section ID of <code>6</code>. The next bit defines the size of the <code>Global</code> section, which is <code>06</code>.</p>
			<p>After that, we <a id="_idIndexMarker239"/>have the number of globals available. The number <a id="_idIndexMarker240"/>of globals is <code>01</code>. This is because the other two globals are imported. The type, mutability, and value are the next 4 bytes:</p>
			<pre>; section "Global" (6)
0000047: 06                          ; section code
0000048: 06                          ; section size
0000049: 01                          ; num globals
000004a: 7f                          ; i32
000004b: 00                          ; global mutability
000004c: 41                          ; i32.const
000004d: 0a                          ; i32 literal
000004e: 0b                          ; end</pre>
			<p>The first <code>function</code> body inside the code section looks as follows:</p>
			<pre>; function body 0
000009c: 04                          ; func body size
000009d: 00                          ; local decl count
000009e: 23                          ; global.get
000009f: 02                          ; global index
00000a0: 0b                          ; end</pre>
			<p><code>function</code> is four bits in length. The first <code>00</code> says that the function has no local declaration. The next <code>23</code> is the opcode for getting the global value. The next <code>02</code> defines the index of the global value. Even though the preceding global section specifies there is only one global value, the entire module takes the imported globals into account. Since there are two <a id="_idIndexMarker241"/>imported global values, we index the local global values <a id="_idIndexMarker242"/>after the imported global value. So, the <code>$wasmValue</code> global has an index of 3. Finally, we end the function code with the <code>0b</code> opcode. Similarly, the second and third function bodies define how we get the other two imported global values:</p>
			<pre>; function body 3
00000ab: 06                          ; func body size
00000ac: 00                          ; local decl count
00000ad: 20                          ; local.get
00000ae: 00                          ; local index
00000af: 24                          ; global.set
00000b0: 00                          ; global index
00000b1: 0b                          ; end</pre>
			<p>In function body 4, we set the global value using <code>global.set</code>, which has an opcode of <code>24</code>.</p>
			<p>We have explored <a id="_idIndexMarker243"/>how to import and export values in and <a id="_idIndexMarker244"/>out of WebAssembly modules. Now, let's explore the special <code>start</code> function in the WebAssembly module. </p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor075"/>Start</h1>
			<p>Start is a special function <a id="_idIndexMarker245"/>that runs after the WebAssembly module <a id="_idIndexMarker246"/>is initialized. Let's take the same example that we used for the globals. We add the following content to <code>globals.wat</code>:</p>
			<pre>(module
    ; Code is elided
    (func $initMutableValue
          (global.set $mutableValue
               (i32.const 200))) 
     (start $initMutableValue)
)</pre>
			<p>We define the <code>initMutableValue</code> function, which sets <code>mutableValue</code> to <code>200</code>. After that, we add a start block, which starts with <code>startkeyword</code> followed by the name of the function.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The function referenced at the start should not return any value.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<pre>$ /path/to/wabt/bin/wat2wasm globals.wat</pre>
			<p>Let's run the example in a browser using the following command: </p>
			<pre>$ python -m http.server</pre>
			<p>Now, launch the URL <code>http://localhost:8000/globals.html</code> and open the developer tools.</p>
			<p>The start function is similar to other functions, except that it is not classified into any type. The types <a id="_idIndexMarker247"/>may or may not be initialized at the time <a id="_idIndexMarker248"/>of the function. The start section of a WebAssembly module points to a function index (the index of the location of the function section inside the function component).</p>
			<p>The section ID of the start function is <code>8</code>. When decoded, the start function represents the start component of the module:</p>
			<pre>; section "Start" (8)
0000085: 08                          ; section code
0000086: 01                          ; section size
0000087: 03                          ; start func index</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">At this moment, tools such as webpack do not support the <code>start</code> function. The start section is rewritten into a normal function and then the function is invoked when the JavaScript is initialized by the bundler itself.</p>
			<p><code>start</code> is an interesting and useful function that enables setting up some values when the module is initialized to prevent unnecessary side effects that the module might cause. Now, let's explore the memory section. The memory section is responsible for transferring memory between JavaScript and WebAssembly.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor076"/>Memory</h1>
			<p>Transferring data between JavaScript and WebAssembly is an expensive operation. In order to reduce <a id="_idIndexMarker249"/>the transfer of data between JavaScript <a id="_idIndexMarker250"/>and WebAssembly modules, WebAssembly uses <code>sharedArrayBuffer</code>. With <code>sharedArrayBuffer</code> both the JavaScript and WebAssembly modules can access the same memory and use it to share the data from one to the other.</p>
			<p>The memory section of a WebAssembly module is a vector of linear memories. The linear memory model is a memory addressing technique in which the memory is organized in a <a id="_idIndexMarker251"/>single contiguous address space. It is also known <a id="_idIndexMarker252"/>as a flat memory model. The linear memory model makes it easier to understand, program, and represent the memory. But the linear memory model comes with a huge disadvantage of high execution time for rearranging elements in the memory and the wastage of memory space. Here, the memory represents a vector of raw bytes of uninterpreted data. They use resizable array buffers to hold the raw bytes of memory. We use <code>sharedArrayBuffers</code> for defining and maintaining this memory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to note that this memory is accessible and mutable by JavaScript and WebAssembly.</p>
			<p>We allocate the memory using the <code>WebAssembly.Memory()</code> constructor. The constructor can accept an argument that defines the initial and maximum value of memory, like so:</p>
			<pre>$ touch memory.html
$ vi memory.html
let memory = new WebAssembly.Memory({initial: 10, maximum: 100})</pre>
			<p>Here, we define that <code>WebAssembly.Memory</code> has an initial memory of <code>10</code> and a maximum memory of <code>100</code>. Then, we instantiate the WebAssembly module with the following code:</p>
			<pre>const response = await fetch('./memory.wasm')
const bytes = await response.arrayBuffer()
const wasm = await WebAssembly.instantiate(bytes, { js: { memory } })</pre>
			<p>Similar to the global example, here we are passing <code>importObject</code>, which takes in the <code>js</code> module and the memory object.</p>
			<p>Let's create a new file called <code>memory.wat</code> and add the following content to it:</p>
			<pre>(module
     (memory (import "js" "memory") 1)
     (func (export "sum") (param $ptr i32) (param $len i32)
       (result i32)
          (local $end i32)
          (local $sum i32)
          (local.set $end (i32.add (local.get $ptr)
            (i32.mul (local.get $len) (i32.const 4))))
          (block $break (loop $top
               (br_if $break (i32.eq (local.get $ptr)
               (local.get $end)))
               (local.set $sum (i32.add (local.get $sum)
                 (i32.load (local.get $ptr))))
               (local.set $ptr (i32.add (local.get $ptr)
                 (i32.const 4)))
               (br $top)
          ))
          (local.get $sum)
     )
)</pre>
			<p>Inside the module, we import the memory from the <code>js</code> module with the name memory. After that, we define a function sum and export the function outside the module. The <a id="_idIndexMarker253"/>function accepts two parameters as arguments <a id="_idIndexMarker254"/>and returns an i32 as an output. The first parameter is named <code>$ptr</code>. It is a pointer to the index of where the value is present in <code>sharedArrayBuffer</code>. The next argument is <code>$len</code>, which defines the length of the shared memory.</p>
			<p>Then, we create two local variables, <code>$end</code> and <code>$sum</code>. First, we set <code>$end</code> to the value of <code>$ptr</code> plus four times the value of <code>$len</code>. Then, we create a block and start a loop. The loop ends when the <a id="_idIndexMarker255"/>value of <code>$end</code> is equal to the <a id="_idIndexMarker256"/>value of <code>$ptr</code>. We then set the value of <code>$sum</code> by adding the existing value of <code>$sum</code> with the value of <code>$ptr</code>. Then, we increment <code>$ptr</code> to the next value. Finally, we exit the loop and return <code>$sum</code>.</p>
			<p>The previous code is analogous to the following in JavaScript:</p>
			<pre>function sum(ptr, len) {
    let end = ptr + (len * 4)
    let tmp = 0
    while (ptr &lt; end) {
        tmp = memory[ptr]
        ptr = ptr + 4
    }
    return tmp;
}</pre>
			<p>Let's go back to <code>memory.html</code> and initialize the buffer:</p>
			<pre>let i32Arr = new Uint32Array(memory.buffer)
for (var i = 0; i &lt; 50; i++) {
    i32Arr[i] = i * i * i
}</pre>
			<p>We create an unsigned array using <code>Uint32Array</code> using the memory object we created. Then, we populate the array buffer with the cube of numbers from 1 to 50:</p>
			<pre>var sum = wasm.instance.exports.sum(0, 50)
console.log(sum) // 1500625</pre>
			<p>Finally, we call the sum inside the WebAssembly module and ask it to provide the sum of all the cubic numbers in the shared array buffer starting at 0 up to the length of 50.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<pre>$ /path/to/wabt/bin/wat2wasm memory.wat</pre>
			<p>Let's run an example in the browser using the following command:</p>
			<pre>$ python -m http.server</pre>
			<p>Now, launch <a id="_idIndexMarker257"/>the URL <code>http://localhost:8000/globals.html</code> and <a id="_idIndexMarker258"/>open the developer tools.</p>
			<p>Memory sections are very useful when we have to transfer a large amount of data between two worlds. The memory sections make it easier to define, share, and access memory between the WebAssembly and JavaScript world.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor077"/>Summary</h1>
			<p>In this chapter, we learned about the import, export, start, and memory sections in a WebAssembly module. We saw how they are structured and defined inside a WebAssembly module. Each of these sections carries one specific function and it is essential to understand, analyze, and debug the WebAssembly modules. In the next chapter, we will explore Binaryen. </p>
		</div>
	</body></html>