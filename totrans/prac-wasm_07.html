<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-61"><em class="italic"><a id="_idTextAnchor069"/>Chapter 5</em>: Understanding Sections in WebAssembly Modules</h1>
			<p>A WebAssembly module is composed of zero or more sections. Each section has its own functionality. In the previous chapters, we saw how functions are defined inside a WebAssembly module. A function is a section inside a WebAssembly module. </p>
			<p>In this chapter, we will explore the various other sections inside a WebAssembly module. Understanding the various sections inside a WebAssembly module will make it easier for us to identify, debug, and write efficient WebAssembly modules. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Exports and imports</li>
				<li>Globals</li>
				<li>Start </li>
				<li>Memory</li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections">https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/05-wasm-sections</a>.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor071"/>Exports and imports</h1>
			<p>A WebAssembly module consists of export and import sections. These sections are responsible for exporting functions out of and importing functions into the WebAssembly module.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor072"/>Exports</h2>
			<p>In order to call the functions defined in a WebAssembly module from JavaScript, we need to export the <a id="_idIndexMarker217"/>functions from the WebAssembly module. The export section is <a id="_idIndexMarker218"/>where we will define all the functions that are exported out of the WebAssembly module. </p>
			<p>Let's go back to our classic <strong class="source-inline">add.wat</strong> example from the previous chapter:</p>
			<p class="source-code">; add.wat</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (func $add (param $lhs i32) (param $rhs i32) </p>
			<p class="source-code">      (result i32)</p>
			<p class="source-code">        get_local $lhs</p>
			<p class="source-code">        get_local $rhs</p>
			<p class="source-code">        i32.add)</p>
			<p class="source-code">    (export "add" (func $add))</p>
			<p class="source-code">)</p>
			<p>Here, we have exported the <strong class="source-inline">add</strong> function using the <strong class="source-inline">(export "add" (func $add))</strong> statement. To export a function, we have used the <strong class="source-inline">export</strong> keyword followed by the name of the function and then the pointer to the exported function itself. </p>
			<p>Remember that WebAssembly is compact-sized. Thus, we can represent the export statement along with the function definition itself, like so:</p>
			<p class="source-code">; add.wat</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (func $add (export "add") (param $lhs i32) </p>
			<p class="source-code">      (param $rhs i32) (result i32)</p>
			<p class="source-code">        get_local $lhs</p>
			<p class="source-code">        get_local $rhs</p>
			<p class="source-code">        i32.add)</p>
			<p class="source-code">)</p>
			<p>Let's use WABT's <strong class="source-inline">wat2wasm</strong> tool to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<p class="source-code">$ /path/to/wabt/bin/wat2wasm add.wat</p>
			<p>Let's analyze the generated byte code using the <strong class="source-inline">hexdump</strong> tool:</p>
			<p class="source-code">$ hexdump add.wasm</p>
			<p class="source-code">0000000 00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 01</p>
			<p class="source-code">0000010 7f 03 02 01 00 07 07 01 03 61 64 64 00 00 0a 09</p>
			<p class="source-code">0000020 01 07 00 20 00 20 01 6a 0b</p>
			<p class="source-code">0000029</p>
			<p>As expected, the <a id="_idIndexMarker219"/>first byte consists of the magic header <a id="_idIndexMarker220"/>and version of the binary <strong class="source-inline">00 61 73 6d 01 00 00 00</strong>: </p>
			<p class="source-code">0000000: 0061 736d                   ; WASM_BINARY_MAGIC</p>
			<p class="source-code">0000004: 0100 0000                   ; WASM_BINARY_VERSION</p>
			<p>The next bit is <strong class="source-inline">01</strong>, which represents the section index of the type section. Following that, we have the size of the type section, which is <strong class="source-inline">07</strong>. The next seven bits are the type section. <strong class="source-inline">01</strong> represents the number of type definitions available:</p>
			<p class="source-code">; section "Type" (1)</p>
			<p class="source-code">0000008: 01                          ; section code</p>
			<p class="source-code">0000009: 07                          ; section size</p>
			<p class="source-code">000000a: 01                          ; num types</p>
			<p>Then, we have <strong class="source-inline">60</strong>, which represents <strong class="source-inline">func</strong>. Following that, we have <strong class="source-inline">02</strong>, representing the two parameters. <strong class="source-inline">7f</strong> is the opcode for defining the i32 type. Since both the parameters are i32, we have consecutive <strong class="source-inline">7f</strong> opcodes. Following that, the last two bits represent the return type and there is also <strong class="source-inline">7f</strong> representing i32:</p>
			<p class="source-code">; type 0</p>
			<p class="source-code">000000b: 60                          ; func</p>
			<p class="source-code">000000c: 02                          ; num params</p>
			<p class="source-code">000000d: 7f                          ; i32</p>
			<p class="source-code">000000e: 7f                          ; i32</p>
			<p class="source-code">000000f: 01                          ; num results</p>
			<p class="source-code">0000010: 7f                          ; i32</p>
			<p>After the <strong class="source-inline">type</strong> section, we have the <strong class="source-inline">func</strong> section. The unique identifier for the <strong class="source-inline">func</strong> section is <strong class="source-inline">03</strong>. Following that, we have <strong class="source-inline">02</strong>, which defines the size of the function section. That is the size of the function section is just 2 bits. But we defined the function definition for <strong class="source-inline">add</strong> in the WebAssembly text format and the function is more than 2 bits in size. So, how is it possible? <a id="_idIndexMarker221"/>The reason is that <a id="_idIndexMarker222"/>the function section does not have the body of the function; instead, it just defines the available functions. The functions are defined in the code section. The next <strong class="source-inline">01</strong> defines that there is only one function defined in the module:</p>
			<p class="source-code">; section "Function" (3)</p>
			<p class="source-code">0000011: 03                          ; section code</p>
			<p class="source-code">0000012: 02                          ; section size</p>
			<p class="source-code">0000013: 01                          ; num functions</p>
			<p class="source-code">0000014: 00                          ; function 0 signature</p>
			<p class="source-code">  index</p>
			<p>Then, we have the export section, which starts with <strong class="source-inline">07</strong>. The next <strong class="source-inline">07</strong> represents the size of the export section. Then, we define the number of exports exported in the export section. The next bit represents the length of the exported function name. The next <strong class="source-inline">03</strong> bits represent the function name, <strong class="source-inline">add</strong>. Then, the export section has the kind of export and function index of the exported function:</p>
			<p class="source-code">; section "Export" (7)</p>
			<p class="source-code">0000015: 07                          ; section code</p>
			<p class="source-code">0000016: 07                          ; section size</p>
			<p class="source-code">0000017: 01                          ; num exports</p>
			<p class="source-code">0000018: 03                          ; string length</p>
			<p class="source-code">0000019: 6164 64                add  ; export name</p>
			<p class="source-code">000001c: 00                          ; export kind</p>
			<p class="source-code">000001d: 00                          ; export func index</p>
			<p>The last segment starts with <strong class="source-inline">0a</strong>. <strong class="source-inline">0a</strong> is a unique identifier for the code section. The code section is of length <strong class="source-inline">09</strong>. Next, <strong class="source-inline">01</strong> represents the number of functions defined in the code block.</p>
			<p>Next, <strong class="source-inline">07</strong> represents the length of the function definition. The next seven bits actually define the <a id="_idIndexMarker223"/>function block. <strong class="source-inline">00</strong> indicates that the function <a id="_idIndexMarker224"/>block does not have any local declarations. <strong class="source-inline">20</strong> is the opcode for <strong class="source-inline">get_local</strong> and we take the <strong class="source-inline">00</strong> index, and then again we have <strong class="source-inline">20</strong> opcode to <strong class="source-inline">get_local</strong> and we take the <strong class="source-inline">01</strong> index. Then, we add them using <strong class="source-inline">i32.add</strong>. The opcode for the i32 addition is <strong class="source-inline">6a</strong>. Finally, we use <strong class="source-inline">0b</strong> to end the function code block:</p>
			<p class="source-code">; section "Code" (10)</p>
			<p class="source-code">000001e: 0a                          ; section code</p>
			<p class="source-code">000001f: 09                          ; section size</p>
			<p class="source-code">0000020: 01                          ; num functions</p>
			<p class="source-code">  ; function body 0</p>
			<p class="source-code">0000021: 07                          ; func body size</p>
			<p class="source-code"> </p>
			<p class="source-code">0000022: 00                          ; local decl count</p>
			<p class="source-code">0000023: 20                          ; local.get</p>
			<p class="source-code">0000024: 00                          ; local index</p>
			<p class="source-code">0000025: 20                          ; local.get</p>
			<p class="source-code">0000026: 01                          ; local index</p>
			<p class="source-code">0000027: 6a                          ; i32.add</p>
			<p class="source-code">0000028: 0b                          ; end</p>
			<p>We have seen how the export section is represented in a WebAssembly module. In the next section, let's see how the import section is represented in a WebAssembly module.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor073"/>Imports</h2>
			<p>In order to import a <a id="_idIndexMarker225"/>function from another WebAssembly <a id="_idIndexMarker226"/>module or JavaScript module, we need to import the functions in the WebAssembly module. The import section is where we will import all the external dependencies into the WebAssembly module.</p>
			<p>Now, let's imagine that a JavaScript module exports a function named <strong class="source-inline">jsAdd</strong>. We can import the <strong class="source-inline">jsAdd</strong> function using the <strong class="source-inline">import</strong> keyword. Create a file called <strong class="source-inline">jsAdd.wat</strong> and add the following content to it:</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (func $i (import "imports" "jsAdd") (param i32))</p>
			<p class="source-code">)</p>
			<p>Here, we are defining a function with the <strong class="source-inline">func</strong> keyword, followed by the name of the function, <strong class="source-inline">$i</strong>. We use <strong class="source-inline">$i</strong> to call the function inside the WebAssembly module. Then, we have the <strong class="source-inline">import</strong> keyword. The <strong class="source-inline">import</strong> keyword is followed by the module name. The module name here refers to the JavaScript module, and then we have the name of the function to import from the JavaScript module. </p>
			<p>Finally, we have <strong class="source-inline">param</strong>. Since a WebAssembly module is typed, we have to define the input parameters and return types in the function definition.</p>
			<p>Let's use WABT's <strong class="source-inline">wat2wasm</strong> to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<p class="source-code">$ /path/to/wabt/bin/wat2wasm jsAdd.wat</p>
			<p>Let's analyze the generated byte code using the <strong class="source-inline">hexdump</strong> tool:</p>
			<p class="source-code">$ hexdump jsAdd.wasm</p>
			<p class="source-code">0000000 00 61 73 6d 01 00 00 00 01 05 01 60 01 7f 00 02</p>
			<p class="source-code">0000010 11 01 07 69 6d 70 6f 72 74 73 05 6a 73 41 64 64</p>
			<p class="source-code">0000020 00 00</p>
			<p class="source-code">0000022</p>
			<p>The binary consists of the import section, which starts at the index of 16. The import section starts with <strong class="source-inline">02</strong> because the unique section index of the import section is <strong class="source-inline">02</strong>. After that, we have <strong class="source-inline">11</strong>, which represents the size of the import section in the binary. The next bit represents the number of imports, <strong class="source-inline">01</strong>.</p>
			<p>Then, we have the definition for the import. <strong class="source-inline">07</strong> here represents the length of the imported <a id="_idIndexMarker227"/>function. The next seven bits represent the name <a id="_idIndexMarker228"/>of the import module. The next bit represents the length of the function name, <strong class="source-inline">05</strong>, and the next five bits represent the function name. Finally, we have the kind and type signature of the index:</p>
			<p class="source-code">; Other information</p>
			<p class="source-code">; section "Import" (2)</p>
			<p class="source-code">000000f: 02                          ; section code</p>
			<p class="source-code">0000010: 11                          ; section size</p>
			<p class="source-code">0000011: 01                          ; num imports</p>
			<p class="source-code">; import header 0</p>
			<p class="source-code">0000012: 07                          ; string length</p>
			<p class="source-code">0000013: 696d 706f 7274 73           imports  ; import</p>
			<p class="source-code">  module name</p>
			<p class="source-code">000001a: 05                          ; string length</p>
			<p class="source-code">000001b: 6a73 4164 64         jsAdd  ; import field name</p>
			<p class="source-code">0000020: 00                          ; import kind</p>
			<p class="source-code">0000021: 00                          ; import signature</p>
			<p class="source-code">  index</p>
			<p>Now, you can call the <strong class="source-inline">jsAdd</strong> function like you would other functions inside a WebAssembly module using the <strong class="source-inline">$i</strong> identifier. </p>
			<p>We have explored how both the import and export sections are defined inside a WebAssembly module and how they help to import and export a function. Now, let's explore how to import and export values in and out of a WebAssembly module. </p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor074"/>Globals</h1>
			<p>The globals section is where we can import and export values in and out of WebAssembly <a id="_idIndexMarker229"/>modules. In a WebAssembly module, you <a id="_idIndexMarker230"/>can import either mutable or immutable values from JavaScript. Additionally, WebAssembly also supports <strong class="source-inline">wasmValue</strong>, an internal immutable value inside the WebAssembly module itself.</p>
			<p>Let's create a file called <strong class="source-inline">globals.wat</strong> and add the following contents to it:</p>
			<p class="source-code">$ touch globals.wat</p>
			<p class="source-code">(module</p>
			<p class="source-code">     (global $mutableValue (import "js" "mutableGlobal")</p>
			<p class="source-code">       (mut i32))</p>
			<p class="source-code">     (global $immutableValue (import "js"</p>
			<p class="source-code">       "immutableGlobal") i32)</p>
			<p class="source-code">     (global $wasmValue i32 (i32.const 10))</p>
			<p class="source-code">     (func (export "getWasmValue") (result i32)</p>
			<p class="source-code">        (global.get $wasmValue))</p>
			<p class="source-code">     (func (export "getMutableValue") (result i32)</p>
			<p class="source-code">        (global.get $mutableValue))</p>
			<p class="source-code">     (func (export "getImmutableValue") (result i32)</p>
			<p class="source-code">        (global.get $immutableValue))</p>
			<p class="source-code">     (func (export "setMutableValue") (param $v i32)</p>
			<p class="source-code">        (global.set $mutableValue</p>
			<p class="source-code">            (local.get $v)))</p>
			<p class="source-code">)</p>
			<p>We created a module (<strong class="source-inline">module</strong>) and three global variables:</p>
			<ul>
				<li><strong class="source-inline">$mutableValue</strong> – This value is imported from the <strong class="source-inline">js</strong> JavaScript module and the <strong class="source-inline">mutableGlobal</strong> variable. We also define the global variable to be of the <strong class="source-inline">mut i32</strong> type.</li>
				<li><strong class="source-inline">$immutableValue</strong> – This value is imported from the <strong class="source-inline">js</strong> JavaScript module and the <strong class="source-inline">immutableGlobal</strong> variable. We also define the global variable to be of the <strong class="source-inline">i32</strong> type.</li>
				<li><strong class="source-inline">$wasmValue</strong> – This is a global constant. We define the <strong class="source-inline">global</strong> keyword followed by the name of the global variable, <strong class="source-inline">$wasmValue</strong>, then the type of <strong class="source-inline">i32</strong>, and finally the actual value (<strong class="source-inline">i32.const 10</strong>). <p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">$wasmValue</strong> is immutable and cannot be exported to the external world.</p></li>
			</ul>
			<p>Then, we have <a id="_idIndexMarker231"/>a set of functions that helps to get and set <a id="_idIndexMarker232"/>the global variables. <strong class="source-inline">getWasmValue</strong>, <strong class="source-inline">getImmutableValue</strong>, and <strong class="source-inline">getMutableValue</strong> get the values of the <strong class="source-inline">wasmValue</strong> global constant, the <strong class="source-inline">immutableValue</strong> global constant, and the <strong class="source-inline">mutableValue</strong> global variable, respectively.</p>
			<p>Finally, a function that sets <strong class="source-inline">mutableValue</strong> to a new value is <strong class="source-inline">setMutableValue</strong>. <strong class="source-inline">setMutableValue</strong> takes in <strong class="source-inline">param $v</strong>, which sets the value to <strong class="source-inline">$mutableValue</strong>.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<p class="source-code">$ /path/to/wabt/bin/wat2wasm globals.wat</p>
			<p>Create a <strong class="source-inline">globals.html</strong> with the following content:</p>
			<p class="source-code">// globals.html</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">    &lt;head&gt; &lt;/head&gt;</p>
			<p class="source-code">    &lt;body&gt;</p>
			<p class="source-code">        &lt;script&gt;</p>
			<p class="source-code">            async function run() {  }</p>
			<p class="source-code">            run()</p>
			<p class="source-code">        &lt;/script&gt;</p>
			<p class="source-code">    &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Let's define the <strong class="source-inline">run</strong> function inside <strong class="source-inline">&lt;script&gt;</strong>.</p>
			<p>A <strong class="source-inline">WebAssembly.Global</strong> object represents a global variable instance, accessible from JavaScript and importable/exportable across one or more <strong class="source-inline">WebAssembly.Module</strong> instances. The <strong class="source-inline">WebAssembly.Global</strong> constructor expects a <a id="_idIndexMarker233"/>descriptor and value. The descriptor defines <a id="_idIndexMarker234"/>the type and mutability of the global variable defined:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This global variable constructor provides an option to dynamically link multiple WebAssembly modules.</p>
			<p class="source-code">let immutableGlobal = new WebAssembly.Global({value:'i32',</p>
			<p class="source-code">  mutable:false}, 1000)</p>
			<p class="source-code">let mutableGlobal = new WebAssembly.Global({value:'i32',</p>
			<p class="source-code">  mutable:true}, 0)</p>
			<p>We create two global values using the <strong class="source-inline">WebAssembly.Global</strong> constructor. They are <strong class="source-inline">immutableGlobal</strong> and <strong class="source-inline">mutableGlobal</strong>. The former is <strong class="source-inline">mutable:false</strong>, while the latter is <strong class="source-inline">mutable:true</strong>. So, we can change the value of the latter using <strong class="source-inline">mutableGlobal.value</strong> but not the former. If we try changing the value of <strong class="source-inline">immutableGlobal</strong>, then we will receive an error:</p>
			<p class="source-code">mutableGlobal.value = 1337  // valid.</p>
			<p class="source-code">immutableGlobal.value = 7331 // Error</p>
			<p>After that, we fetch the <strong class="source-inline">globals.wasm</strong> WebAssembly module. Then, we instantiate <strong class="source-inline">arrayBuffer</strong> with the response and <strong class="source-inline">arrayBuffer</strong> with the <strong class="source-inline">WebAssembly.instantiate</strong> constructor. In addition to this, the <strong class="source-inline">WebAssembly.instantiate</strong> constructor accepts <strong class="source-inline">importsObject</strong>. We can send the JavaScript module via <strong class="source-inline">importsObject</strong>:</p>
			<p class="source-code">const response = await fetch('./globals.wasm')</p>
			<p class="source-code">const bytes = await response.arrayBuffer()</p>
			<p class="source-code">const wasm = await WebAssembly.instantiate(bytes, { js: {</p>
			<p class="source-code">  mutableGlobal, immutableGlobal } })</p>
			<p>In this case, we are <a id="_idIndexMarker235"/>sending in the <strong class="source-inline">js</strong> module along with the <strong class="source-inline">mutableGlobal</strong> and <strong class="source-inline">immutableGlobal</strong> values. The <strong class="source-inline">wasm</strong> variable now <a id="_idIndexMarker236"/>holds the WebAssembly module. We invoke <strong class="source-inline">wasm.instance.exports</strong> to get all the exported functions from the WebAssembly module:</p>
			<p class="source-code">const {</p>
			<p class="source-code">    getWasmValue,</p>
			<p class="source-code">    getMutableValue,</p>
			<p class="source-code">    setMutableValue,</p>
			<p class="source-code">    getImmutableValue</p>
			<p class="source-code">} =  wasm.instance.exports</p>
			<p><strong class="source-inline">getWasmValue</strong>, <strong class="source-inline">getMutableValue</strong>, <strong class="source-inline">setMutableValue</strong>, and <strong class="source-inline">getImmutableValue</strong> are the functions exported from the WebAssembly module.</p>
			<p>The <strong class="source-inline">getWasmValue</strong> function returns the value of the <strong class="source-inline">wasmValue</strong> inside the WebAssembly module:</p>
			<p class="source-code">console.log(getWasmValue()) // 10</p>
			<p>The <strong class="source-inline">getMutableValue</strong> and <strong class="source-inline">setMutableValue</strong> functions return and set the <strong class="source-inline">mutableGlobal</strong> field defined in JavaScript and passed into the WebAssembly module:</p>
			<p class="source-code">console.log(getMutableValue()) // 1337</p>
			<p class="source-code">setMutableValue(1338)</p>
			<p class="source-code">console.log(getMutableValue()) // 1338</p>
			<p>Finally, we get the immutable value using the <strong class="source-inline">getImmutableValue</strong> function:</p>
			<p class="source-code">console.log(getImmutableValue()) // 1000</p>
			<p>Let's run an example in the browser using the following command: </p>
			<p class="source-code">$ python -m http.server</p>
			<p>Now, launch the URL <strong class="source-inline">http://localhost:8000/globals.html</strong> and open the developer tools.</p>
			<p>The WebAssembly <a id="_idIndexMarker237"/>binary contains an import section. The import section has <a id="_idIndexMarker238"/>a unique identifier, <strong class="source-inline">02</strong>, followed by the size of the section, which is <strong class="source-inline">2b</strong> (which is 43 in decimal). The next 43 bits represent the import section.</p>
			<p><strong class="source-inline">02</strong> at the <strong class="source-inline">000015</strong> index represents the number of imports. Then, we have two sections that define the imported global functions:</p>
			<p class="source-code"> </p>
			<p class="source-code">; section "Import" (2)</p>
			<p class="source-code">0000013: 02                          ; section code</p>
			<p class="source-code">0000014: 2b                          ; section size</p>
			<p class="source-code">0000015: 02                          ; num imports</p>
			<p>Each global segment consists of the module string length and the module name, followed by the function string length and the function name. Finally, it has the kind of import, the type, and the mutability of the variable:</p>
			<p class="source-code"> </p>
			<p class="source-code">; import header 0</p>
			<p class="source-code">0000016: 02                          ; string length</p>
			<p class="source-code">0000017: 6a73                    js  ; import module name</p>
			<p class="source-code">0000019: 0d                          ; string length</p>
			<p class="source-code">000001a: 6d75 7461 626c 6547 6c6f 6261 6c</p>
			<p class="source-code">         mutableGlobal  ; import field name</p>
			<p class="source-code">0000027: 03                          ; import kind</p>
			<p class="source-code">0000028: 7f                          ; i32</p>
			<p class="source-code">0000029: 01                          ; global mutability</p>
			<p class="source-code">  ; import header 1</p>
			<p class="source-code">000002a: 02                          ; string length</p>
			<p class="source-code">000002b: 6a73                    js  ; import module name</p>
			<p class="source-code">000002d: 0f                          ; string length</p>
			<p class="source-code">000002e: 696d 6d75 7461 626c 6547 6c6f 6261 6c</p>
			<p class="source-code">    immutableGlobal  ; import field name</p>
			<p class="source-code">000003d: 03                          ; import kind</p>
			<p class="source-code">000003e: 7f                          ; i32</p>
			<p class="source-code">000003f: 00                          ; global mutability</p>
			<p>After that, we have the <strong class="source-inline">Global</strong> section. The <strong class="source-inline">Global</strong> section has the unique section ID of <strong class="source-inline">6</strong>. The next bit defines the size of the <strong class="source-inline">Global</strong> section, which is <strong class="source-inline">06</strong>.</p>
			<p>After that, we <a id="_idIndexMarker239"/>have the number of globals available. The number <a id="_idIndexMarker240"/>of globals is <strong class="source-inline">01</strong>. This is because the other two globals are imported. The type, mutability, and value are the next 4 bytes:</p>
			<p class="source-code">; section "Global" (6)</p>
			<p class="source-code">0000047: 06                          ; section code</p>
			<p class="source-code">0000048: 06                          ; section size</p>
			<p class="source-code">0000049: 01                          ; num globals</p>
			<p class="source-code">000004a: 7f                          ; i32</p>
			<p class="source-code">000004b: 00                          ; global mutability</p>
			<p class="source-code">000004c: 41                          ; i32.const</p>
			<p class="source-code">000004d: 0a                          ; i32 literal</p>
			<p class="source-code">000004e: 0b                          ; end</p>
			<p>The first <strong class="source-inline">function</strong> body inside the code section looks as follows:</p>
			<p class="source-code">; function body 0</p>
			<p class="source-code">000009c: 04                          ; func body size</p>
			<p class="source-code">000009d: 00                          ; local decl count</p>
			<p class="source-code">000009e: 23                          ; global.get</p>
			<p class="source-code">000009f: 02                          ; global index</p>
			<p class="source-code">00000a0: 0b                          ; end</p>
			<p><strong class="source-inline">function</strong> is four bits in length. The first <strong class="source-inline">00</strong> says that the function has no local declaration. The next <strong class="source-inline">23</strong> is the opcode for getting the global value. The next <strong class="source-inline">02</strong> defines the index of the global value. Even though the preceding global section specifies there is only one global value, the entire module takes the imported globals into account. Since there are two <a id="_idIndexMarker241"/>imported global values, we index the local global values <a id="_idIndexMarker242"/>after the imported global value. So, the <strong class="source-inline">$wasmValue</strong> global has an index of 3. Finally, we end the function code with the <strong class="source-inline">0b</strong> opcode. Similarly, the second and third function bodies define how we get the other two imported global values:</p>
			<p class="source-code">; function body 3</p>
			<p class="source-code">00000ab: 06                          ; func body size</p>
			<p class="source-code">00000ac: 00                          ; local decl count</p>
			<p class="source-code">00000ad: 20                          ; local.get</p>
			<p class="source-code">00000ae: 00                          ; local index</p>
			<p class="source-code">00000af: 24                          ; global.set</p>
			<p class="source-code">00000b0: 00                          ; global index</p>
			<p class="source-code">00000b1: 0b                          ; end</p>
			<p>In function body 4, we set the global value using <strong class="source-inline">global.set</strong>, which has an opcode of <strong class="source-inline">24</strong>.</p>
			<p>We have explored <a id="_idIndexMarker243"/>how to import and export values in and <a id="_idIndexMarker244"/>out of WebAssembly modules. Now, let's explore the special <strong class="source-inline">start</strong> function in the WebAssembly module. </p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor075"/>Start</h1>
			<p>Start is a special function <a id="_idIndexMarker245"/>that runs after the WebAssembly module <a id="_idIndexMarker246"/>is initialized. Let's take the same example that we used for the globals. We add the following content to <strong class="source-inline">globals.wat</strong>:</p>
			<p class="source-code">(module</p>
			<p class="source-code">    ; Code is elided</p>
			<p class="source-code">    (func $initMutableValue</p>
			<p class="source-code">          (global.set $mutableValue</p>
			<p class="source-code">               (i32.const 200))) </p>
			<p class="source-code">     (start $initMutableValue)</p>
			<p class="source-code">)</p>
			<p>We define the <strong class="source-inline">initMutableValue</strong> function, which sets <strong class="source-inline">mutableValue</strong> to <strong class="source-inline">200</strong>. After that, we add a start block, which starts with <strong class="source-inline">startkeyword</strong> followed by the name of the function.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The function referenced at the start should not return any value.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<p class="source-code">$ /path/to/wabt/bin/wat2wasm globals.wat</p>
			<p>Let's run the example in a browser using the following command: </p>
			<p class="source-code">$ python -m http.server</p>
			<p>Now, launch the URL <strong class="source-inline">http://localhost:8000/globals.html</strong> and open the developer tools.</p>
			<p>The start function is similar to other functions, except that it is not classified into any type. The types <a id="_idIndexMarker247"/>may or may not be initialized at the time <a id="_idIndexMarker248"/>of the function. The start section of a WebAssembly module points to a function index (the index of the location of the function section inside the function component).</p>
			<p>The section ID of the start function is <strong class="source-inline">8</strong>. When decoded, the start function represents the start component of the module:</p>
			<p class="source-code">; section "Start" (8)</p>
			<p class="source-code">0000085: 08                          ; section code</p>
			<p class="source-code">0000086: 01                          ; section size</p>
			<p class="source-code">0000087: 03                          ; start func index</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At this moment, tools such as webpack do not support the <strong class="source-inline">start</strong> function. The start section is rewritten into a normal function and then the function is invoked when the JavaScript is initialized by the bundler itself.</p>
			<p><strong class="source-inline">start</strong> is an interesting and useful function that enables setting up some values when the module is initialized to prevent unnecessary side effects that the module might cause. Now, let's explore the memory section. The memory section is responsible for transferring memory between JavaScript and WebAssembly.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor076"/>Memory</h1>
			<p>Transferring data between JavaScript and WebAssembly is an expensive operation. In order to reduce <a id="_idIndexMarker249"/>the transfer of data between JavaScript <a id="_idIndexMarker250"/>and WebAssembly modules, WebAssembly uses <strong class="source-inline">sharedArrayBuffer</strong>. With <strong class="source-inline">sharedArrayBuffer</strong> both the JavaScript and WebAssembly modules can access the same memory and use it to share the data from one to the other.</p>
			<p>The memory section of a WebAssembly module is a vector of linear memories. The linear memory model is a memory addressing technique in which the memory is organized in a <a id="_idIndexMarker251"/>single contiguous address space. It is also known <a id="_idIndexMarker252"/>as a flat memory model. The linear memory model makes it easier to understand, program, and represent the memory. But the linear memory model comes with a huge disadvantage of high execution time for rearranging elements in the memory and the wastage of memory space. Here, the memory represents a vector of raw bytes of uninterpreted data. They use resizable array buffers to hold the raw bytes of memory. We use <strong class="source-inline">sharedArrayBuffers</strong> for defining and maintaining this memory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to note that this memory is accessible and mutable by JavaScript and WebAssembly.</p>
			<p>We allocate the memory using the <strong class="source-inline">WebAssembly.Memory()</strong> constructor. The constructor can accept an argument that defines the initial and maximum value of memory, like so:</p>
			<p class="source-code">$ touch memory.html</p>
			<p class="source-code">$ vi memory.html</p>
			<p class="source-code">let memory = new WebAssembly.Memory({initial: 10, maximum: 100})</p>
			<p>Here, we define that <strong class="source-inline">WebAssembly.Memory</strong> has an initial memory of <strong class="source-inline">10</strong> and a maximum memory of <strong class="source-inline">100</strong>. Then, we instantiate the WebAssembly module with the following code:</p>
			<p class="source-code">const response = await fetch('./memory.wasm')</p>
			<p class="source-code">const bytes = await response.arrayBuffer()</p>
			<p class="source-code">const wasm = await WebAssembly.instantiate(bytes, { js: { memory } })</p>
			<p>Similar to the global example, here we are passing <strong class="source-inline">importObject</strong>, which takes in the <strong class="source-inline">js</strong> module and the memory object.</p>
			<p>Let's create a new file called <strong class="source-inline">memory.wat</strong> and add the following content to it:</p>
			<p class="source-code">(module</p>
			<p class="source-code">     (memory (import "js" "memory") 1)</p>
			<p class="source-code">     (func (export "sum") (param $ptr i32) (param $len i32)</p>
			<p class="source-code">       (result i32)</p>
			<p class="source-code">          (local $end i32)</p>
			<p class="source-code">          (local $sum i32)</p>
			<p class="source-code">          (local.set $end (i32.add (local.get $ptr)</p>
			<p class="source-code">            (i32.mul (local.get $len) (i32.const 4))))</p>
			<p class="source-code">          (block $break (loop $top</p>
			<p class="source-code">               (br_if $break (i32.eq (local.get $ptr)</p>
			<p class="source-code">               (local.get $end)))</p>
			<p class="source-code">               (local.set $sum (i32.add (local.get $sum)</p>
			<p class="source-code">                 (i32.load (local.get $ptr))))</p>
			<p class="source-code">               (local.set $ptr (i32.add (local.get $ptr)</p>
			<p class="source-code">                 (i32.const 4)))</p>
			<p class="source-code">               (br $top)</p>
			<p class="source-code">          ))</p>
			<p class="source-code">          (local.get $sum)</p>
			<p class="source-code">     )</p>
			<p class="source-code">)</p>
			<p>Inside the module, we import the memory from the <strong class="source-inline">js</strong> module with the name memory. After that, we define a function sum and export the function outside the module. The <a id="_idIndexMarker253"/>function accepts two parameters as arguments <a id="_idIndexMarker254"/>and returns an i32 as an output. The first parameter is named <strong class="source-inline">$ptr</strong>. It is a pointer to the index of where the value is present in <strong class="source-inline">sharedArrayBuffer</strong>. The next argument is <strong class="source-inline">$len</strong>, which defines the length of the shared memory.</p>
			<p>Then, we create two local variables, <strong class="source-inline">$end</strong> and <strong class="source-inline">$sum</strong>. First, we set <strong class="source-inline">$end</strong> to the value of <strong class="source-inline">$ptr</strong> plus four times the value of <strong class="source-inline">$len</strong>. Then, we create a block and start a loop. The loop ends when the <a id="_idIndexMarker255"/>value of <strong class="source-inline">$end</strong> is equal to the <a id="_idIndexMarker256"/>value of <strong class="source-inline">$ptr</strong>. We then set the value of <strong class="source-inline">$sum</strong> by adding the existing value of <strong class="source-inline">$sum</strong> with the value of <strong class="source-inline">$ptr</strong>. Then, we increment <strong class="source-inline">$ptr</strong> to the next value. Finally, we exit the loop and return <strong class="source-inline">$sum</strong>.</p>
			<p>The previous code is analogous to the following in JavaScript:</p>
			<p class="source-code">function sum(ptr, len) {</p>
			<p class="source-code">    let end = ptr + (len * 4)</p>
			<p class="source-code">    let tmp = 0</p>
			<p class="source-code">    while (ptr &lt; end) {</p>
			<p class="source-code">        tmp = memory[ptr]</p>
			<p class="source-code">        ptr = ptr + 4</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return tmp;</p>
			<p class="source-code">}</p>
			<p>Let's go back to <strong class="source-inline">memory.html</strong> and initialize the buffer:</p>
			<p class="source-code">let i32Arr = new Uint32Array(memory.buffer)</p>
			<p class="source-code">for (var i = 0; i &lt; 50; i++) {</p>
			<p class="source-code">    i32Arr[i] = i * i * i</p>
			<p class="source-code">}</p>
			<p>We create an unsigned array using <strong class="source-inline">Uint32Array</strong> using the memory object we created. Then, we populate the array buffer with the cube of numbers from 1 to 50:</p>
			<p class="source-code">var sum = wasm.instance.exports.sum(0, 50)</p>
			<p class="source-code">console.log(sum) // 1500625</p>
			<p>Finally, we call the sum inside the WebAssembly module and ask it to provide the sum of all the cubic numbers in the shared array buffer starting at 0 up to the length of 50.</p>
			<p>Let's use WABT to convert the WebAssembly text format into a WebAssembly module with the following command:</p>
			<p class="source-code">$ /path/to/wabt/bin/wat2wasm memory.wat</p>
			<p>Let's run an example in the browser using the following command:</p>
			<p class="source-code">$ python -m http.server</p>
			<p>Now, launch <a id="_idIndexMarker257"/>the URL <strong class="source-inline">http://localhost:8000/globals.html</strong> and <a id="_idIndexMarker258"/>open the developer tools.</p>
			<p>Memory sections are very useful when we have to transfer a large amount of data between two worlds. The memory sections make it easier to define, share, and access memory between the WebAssembly and JavaScript world.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor077"/>Summary</h1>
			<p>In this chapter, we learned about the import, export, start, and memory sections in a WebAssembly module. We saw how they are structured and defined inside a WebAssembly module. Each of these sections carries one specific function and it is essential to understand, analyze, and debug the WebAssembly modules. In the next chapter, we will explore Binaryen. </p>
		</div>
	</body></html>