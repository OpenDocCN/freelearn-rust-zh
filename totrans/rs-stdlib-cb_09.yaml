- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an HTTP server to perform echoing and routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an HTTP server to perform file serving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests to APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a basic UDP Socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a UDP socket to perform echoing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a secure connection via TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the internet, the world is getting smaller every day. The web connects
    people in amazing ways. Countless services are available at your fingertips for
    free. Millions of people can use your apps without even installing it.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer wanting to take advantage of this, porting your app to the internet
    can be quite easy if you have set your architecture up in a clean way. The only
    thing you need to change is the layer that interacts with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is going to show you how to create this layer by allowing your
    application to accept requests, respond to them, and show you how to create requests
    to other web services on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start our chapter by bringing the famous Hello World program into the
    21^(st) century by hosting it on a server. We are going to use the `hyper` crate
    for this, which is a strongly typed wrapper around all things HTTP. In addition
    to being one of the fastest HTTP implementations in the world ([https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext](https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext)),
    it is used by nearly *all* major high-level frameworks ([https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks](https://github.com/flosse/rust-web-framework-comparison#high-level-frameworks)),
    the only exception being the ones that reimplemented it all on the extremely basic
    *stringly-typed* TCP library that Rust provides under `std::net::TcpStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All `hyper` recipes work with `futures`, so you should read all of [Chapter
    8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml), *Working with Futures*, before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, `hyper` has not yet upgraded to `futures v0.2` (tracking
    issue: [https://github.com/hyperium/hyper/issues/1448](https://github.com/hyperium/hyper/issues/1448)),
    so we going to use `futures v0.1`. This should be no problem in the future (no
    pun intended), as all relevant code is written in a way that should be compatible
    with `0.2` when it''s released.'
  prefs: []
  type: TYPE_NORMAL
- en: If some unexpected API change breaks the recipes, you will be able to find a
    fixed version of them at the book's GitHub repository ([https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin](https://github.com/jnferner/rust-standard-library-cookbook/tree/master/chapter-nine/src/bin)),
    which will always be updated in order to work with the newest versions of all
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-nine`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly created `chapter-nine` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the folder `src`, create a new folder called `bin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `hello_world_server.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin hello_world_server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a server by creating a service with `service_fn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a server by manually creating a `struct` that implements `Service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `main`, we first parse a string representing our IPv6 loopback address (think
    `localhost`) as an `std::net::SocketAddr`, which is a type holding an IP address
    and a port [13]. Granted, we could have used a constant for our address, but we
    are showing how to parse it from a string, because in a real application you will
    probably fetch the address from an environment variable, as shown in [Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*; *Interacting
    with environment variables*.
  prefs: []
  type: TYPE_NORMAL
- en: We then run our `hyper` server, which we create in `run_with_service_function`
    [17]. Let's take a look at that function by learning a bit about `hyper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most fundamental trait in `hyper` is the `Service`. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be easy to read the signature of `call`: It takes a `Request` and
    returns a `Future` of a `Response`. `hyper` uses this trait to answer to an incoming
    request. We generally have two ways to define a `Service`:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually create a `struct` that implements `Service`, explicitly setting its
    associated types to whatever `call` returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let a `Service` be built for you by passing a closure that returns a `Result`
    to `service_fn`, which you wrap in a `const_service`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both variants result in the exact same thing, so this example contains both
    versions to give you a taste of them.
  prefs: []
  type: TYPE_NORMAL
- en: '`run_with_service_function` uses the second style [22]. It returns a `Result`
    of a `Response`, which `service_fn` converts to a `Future` of `Response` because
    `Result` implements `Future`. `service_fn` then does some type deduction for us
    and creates a kind of `Service`. But we aren''t done yet. You see, when `hyper`
    receives a new connection, it will not call our `Service` directly with the `Request`,
    but first makes a copy of it in order to handle every connection with its very
    own `Service`. This means that our `Service` must have the ability to create new
    instances of itself, which is indicated by the `NewService` trait. Luckily, we
    don''t need to implement it ourselves either. The closure at the heart of our `Service`
    doesn''t manage any state, so we can call it a constant function. Constants are
    very easy to copy, as all copies are guaranteed to be identical. We can mark our
    `Service` as constant by calling `const_service` on it, which basically just wraps
    the `Service` in an `Arc` and then implements `NewService` by simply returning
    a copy of it. But what exactly is our `Service` returning anyways?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Response<hyper::Body>` creates a new HTTP response [25] and manages its body
    as a `hyper::Body`, which is a future `Stream<Chunk>`. A `Chunk` is just a piece
    of an HTTP message. This `Response` is a builder, so we can change the contents
    of it by calling various methods. In our code, we set its `Content-Type` header
    to `plaintext`, which is a `hyper` shortcut for the MIME type `text/plain` [27].'
  prefs: []
  type: TYPE_NORMAL
- en: 'A MIME type is a label for data served over HTTP. It tells the client how to
    treat the data it receives. For example, most browsers will not render the message
    `<p>Hello World!</p>` as HTML unless it comes with the header `Content-Type: text/html`.'
  prefs: []
  type: TYPE_NORMAL
- en: We also set its `Content-Length` header to the length (in bytes) of our message
    so the client knows how much data they should expect [29]. Finally, we set the
    message's body to the message, which then gets sent to the client as `"Hello World!"`
    [31].
  prefs: []
  type: TYPE_NORMAL
- en: Our service can now be bound to a new instance of `hyper::server::Http`, which
    we then run [34 and 35]. You can now open your browser of choice and point it
    to `http://localhost:3000`. If everything went right, you should be greeted by
    a `Hello World!` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing would happen if we called `run_with_service_struct` instead,
    which uses a manually created `Service` instead [40]. A quick inspection of its
    implementation shows us the key differences to the last approach [45 to 63]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need to explicitly specify the concrete type of basically
    everything [48 to 52]. We also can't simply return a `Result` in our `call` method
    and need to return the actual `Future`, wrapped in a `Box` [56], so we don't need
    to think about which exact flavor of `Future` we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, this approach has one big advantage over the other: It can
    manage state in the form of members. Because all `hyper` recipes in this chapter
    work with constant Services, that is Services that will return the same `Response`
    to equal Requests, we will use the first variant to create Services. This is simply
    a stylistic decision based on simplicity, as they are all small enough that it
    wouldn''t be worth it to extract them into an own `struct`. In your projects,
    use whichever form suits the current use case best.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the builder pattern* and *Interacting with environment variables* recipe
    in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an HTTP server to perform echoing and routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to serve the same response forever, but that would get pretty
    dull after a while. In this recipe, you are going to learn how to read requests
    and respond to them individually. For this, we will use routing to differentiate
    between requests to different endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test this recipe, you will need a way to easily send HTTP requests. An excellent
    free tool for this is Postman ([https://www.getpostman.com/](https://www.getpostman.com/)),
    which features a nice and self-explanatory UI. If you''d rather not download anything,
    you can use your terminal for this. If you''re on Windows, you can open PowerShell
    and enter the following to do an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you wanted to POST the message `hello there, my echoing friend` to `http://localhost:3000/echo`,
    as you will be asked to later in the recipe, you''d need to enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On Unix systems, you can use cURL for that ([https://curl.haxx.se/](https://curl.haxx.se/)).
    The analog command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'cURL will resolve `localhost` to its entry in `/etc/hosts`. In some configurations,
    this will only be the IPv4 loopback address (`127.0.0.1`). In some others, you
    will have to use `ip6-localhost`. Check your `/etc/hosts` to find out what to
    use. In any case, an explicit `[::1]` will always work. As an example, the following
    command will again POST the message `hello there, my echoing friend` to `http://localhost:3000/echo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `echo_server_with_routing.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin echo_server_with_routing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions are handling the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe begins like the last one, so let''s skip straight into the definition
    of our `Service`[14 to 22]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are now using the `Request` parameter that the last recipe simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Because Rust allows us to pattern match on tuples, we can directly differentiate
    between HTTP methods and path combinations. We then pass on the control flow of
    our program to dedicated route handlers, which in turn are responsible for returning
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: In bigger programs with tons of routes, we would not specify them all in one
    function, but spread them across namespaces and split them into subrouters.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `handle_root` [29] looks nearly identical to the hello world `Service`
    from the last chapter, but instructs the caller to POST at the `/post` route.
  prefs: []
  type: TYPE_NORMAL
- en: Our match for said POST leads to `handle_echo` [37], which simply returns the
    request's body as the response's body [40]. You can try this for yourself by POSTing
    a message to `http://localhost:3000/echo`, as described in the *Getting ready*
    section. If everything goes right, your message will come right back at you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not least, `handle_not_found` [43] is called when no routes matched.
    This time, we don''t send a message back, but instead, return the possible most
    famous status code of the world: `404 Not Found` [45].'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an HTTP server to perform file serving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last recipes were really useful for building web services, but let''s take
    a look at how to do the thing HTTP was originally created for: serving HTML files
    to the web.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to futures' ([https://crates.io/crates/futures](https://crates.io/crates/futures))
    and hyper's ([https://crates.io/crates/hyper](https://crates.io/crates/hyper))
    *crates.io* pages to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `chapter-nine`, create a folder called `files`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the folder `files`, create a file called `index.html` and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the folder `files`, create a file called `foo.html` and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the folder `files`, create a file called `bar.html` and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the folder `files`, create a file called `not_found.html` and add the following
    code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the folder `files`, create a file called `invalid_method.html` and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the folder `src/bin`, create a file called `file_server.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin echo_server_with_routing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the route handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the functions returning the futures with our
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! That was a lot of files. Of course, the exact content of the HTML and CSS
    doesn't matter for this recipe, as we're going to be focused on Rust. We've put
    them all in the `files` folder because we are going to make its contents publicly
    accessible by name for any client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics of the server setup are the same as with the echoing recipe: create
    a `Service` with `const_service` and `service_fn` [21], match the request''s method
    and path, and then handle the routes in different functions. When looking at our
    return type, however, we can notice a difference [36]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are no longer returning a `Response` directly, but instead, wrapping it in
    a `Future`. This allows us to not block the server when loading a file into memory;
    we can continue handling requests in the main thread while the file serving `Future`
    is run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at our route handlers, you can see that they all use the `send_file_or_404`
    function. Let''s take a look at it [56]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, the function sanitizes our input. The implementation of `sanitize_path`
    [130 to 141] should be pretty straightforward. It filters out potential troublemakers
    so that a malicious client cannot do any shenanigans, such as requesting the file
    `localhost:3000/../../../../home/admin/.ssh/id_rsa`.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `try_to_send_file` on the sanitized path [72]. We are going to
    look at that function in a minute, but for now, it's enough to look at its signature.
    It tells us that it returns a `Future` of a `Result` that can be a `Response`
    or an `io::Error`, as that's the error encountered on invalid filesystem access.
    We cannot return this `Future` directly, since we already told `hyper` that we
    are going to return a `Future` of `Response`, so we need to convert the types.
    If the file retrieving `Future` generated from `try_to_send_file` succeeded, we
    act on its item, which is a `Result<Response, io::Error>`.
  prefs: []
  type: TYPE_NORMAL
- en: Because `hyper::Error` implements `From<io::Error>`, we can convert them easily
    by calling `.into()` [63] (see [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*; *Converting types*, for an introduction to the `From`
    trait). This will return a `Result<Response, hyper::Error>`. Because a `Future`
    is constructable from a `Result`, it will be implicitly converted to a `Future<Response,
    hyper::Error>` for us, which is exactly what we want. A little cherry on top is
    our handling of `try_to_send_file` returning an error, in which case we can safely
    assume that the file doesn't exist, so we return a `Future` with a custom `404
    Not Found` page by calling `send_404()` [65]. Before looking at its implementation,
    let's check out `try_to_send_file` first [72].
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we convert the requested path into a local filesystem path with `path_on_disk`
    [74], which is simply implemented as follows [144]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We created an own function for this so it will be easy for you to extend the
    filesystem logic. For example, for Unix systems, it is usual to put all static
    HTML in `/var/www/`, while Windows web servers usually put all of their data in
    their own installation folder. Or you may want to read a configuration file provided
    by the user and store its value in a `lazy_static`, as shown in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*; *Using lazy static variable*, and use that path instead.
    You can implement all of those rules in this function.
  prefs: []
  type: TYPE_NORMAL
- en: Back in `try_to_send_file`, we create a `oneshot::channel` to send data as a
    `Future` [77]. This concept is explained in detail in [Chapter 8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml),
    *Working with Futures*; *Using the* *oneshot channel*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the function now creates a new thread to load the file into memory
    in the background [78]. We first open the file [79] and return an error through
    the channel if it doesn''t exist. We then copy the entire file into a local vector
    of bytes [91] and again propagate any error that might occur [107]. If the process
    of copying into RAM succeeded, we return a `Response` with the content of the
    file as its body [100]. Along the way, we have to figure out the file''s appropriate
    MIME type [96], as promised in the recipe *Setting up a basic HTTP server*. For
    that, we simply match the extension of the file [147 to 158]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think this implementation is pretty lazy and that there should be a
    better way, but, trust me, this is exactly how all big web servers do it. Case
    in point, you can find `nginx` ([https://nginx.org/en/](https://nginx.org/en/))
    mime detection algorithm here: [https://github.com/nginx/nginx/blob/master/conf/mime.types](https://github.com/nginx/nginx/blob/master/conf/mime.types).
    If you plan on serving new file types, you can extend the `match` for their extensions.
    The `nginx` source is a good resource for this.'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_content_type` returns `None` if there was no match [155] instead of a
    default content type, so that every caller can decide on a default for themselves.
    In `try_to_send_file`, we use `.unwrap_or_else(ContentType::plaintext);` [96]
    to set the fallback MIME type to `text/plain`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last unexplained function left in our example is `send_404`, which we use
    a lot as a fallback. You can see that all it really does is call `try_to_send_file`
    on the 404 page [117] and on error send a static message instead [124].
  prefs: []
  type: TYPE_NORMAL
- en: The fallback in `send_404` really shows us the beauty in Rust's error handling
    concept. Because strongly typed errors are part of a function's signature, as
    opposed to languages such as C++, where you never know who might throw an exception,
    you are forced to consciously handle the error cases. Try to remove `and_then`
    and its associated closure and you'll see that the compiler doesn't let you compile
    your program because you didn't handle the `Result` of `try_to_send_file` in any
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead now and see the results of our file server with your own eyes by pointing
    your browser to `http://localhost:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite being relatively easy to understand, our implementation of `try_to_send_file`
    is not endlessly scalable. Imagine serving and loading huge files into memory
    for millions of clients at the same time. That would bring your RAM to its limits
    pretty quickly. A more scalable solution is to send the file in chunks, that is
    part by part, so that you only need to hold a small part of it in memory at any
    given time. To implement this, you'll need to copy the contents of your file to
    a limited `[u8]` buffer with a fixed size and send that through an additional
    channel as an instance of `hyper::Chunk`, which implements `From<Vec<T>>`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Converting types into each other* and *Creating* *lazy static variables *recipe
    in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the oneshot channel* recipe in [Chapter 8](dccc0c20-85ff-46a7-a1b8-463a5dd92ba0.xhtml),
    *Working with Futures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests to APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last destination in this chapter brings us away from the server in favor
    of the other party participating in internet communication: the client. We will
    use `reqwest`, which is built around `hyper`, to create HTTPS requests to web
    services and parse their data into nicely usable Rust structures. You can also
    use the content of this recipe to write integration tests for your own web services.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to `request`'s ([https://crates.io/crates/reqwest](https://crates.io/crates/reqwest)),
    `serde`'s ([https://crates.io/crates/serde](https://crates.io/crates/serde)),
    and `serde_derive`'s ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    *crates.io* pages to check for the newest versions and use those ones instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `making_requests.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin making_requests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the requests being implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows us using our CRUD client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the top, we define our structures. `Post`[11], `NewPost` [20], and `UpdatedPost`
    [29] all just represent convenient ways to handle the different requirements of
    the API. The particular JSON API we are interacting with uses camelCase variables,
    so we need to specify this on every `struct`, otherwise `serde` won't be able
    to parse them correctly [10, 19 and 27].
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `PATCH` method we''re communicating with doesn''t accept null values
    on unchanged variables, we mark them all in `UpdatedPost` as not serialized when
    equal to `None` [30, 32 and 34]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we implement the `fmt::Display` trait on `Post`, so we can print
    it nicely [43 to 51].
  prefs: []
  type: TYPE_NORMAL
- en: But enough about our models; let's take a look at `PostCrud` [53]. Its purpose
    is to abstract a CRUD (Create, Read, Update, Delete) service. For this, it is
    equipped with a reusable HTTP client via `reqwest::Client` [57] and a mock JSON
    API endpoint from [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Its methods show you how easy `reqwest` is to use: you simply use the required
    HTTP method directly as a function on the client, pass optional data to it, which
    it will automatically deserialize for you with `.json()`, `.send()` the request,
    and then parse the response again as JSON with a second call to  `.json()` [64].'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, `reqwest` is able to work with non-JSON-based web services as well.
    It has various methods for this such as `query`, which adds an array of key-value
    queries to the URL, or `form`, which will add `url-encoded` form bodies to the
    request. While using all these methods, `reqwest` will manage the headers for
    you, but you can manage them however explicitly you want using the `headers` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serialization basics with Serde* recipe in [Chapter 4](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml),
    *Serialization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
