<html><head></head><body>
		<div><h1 id="_idParaDest-245" class="chapter-number"><a id="_idTextAnchor246"/>12</h1>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor247"/>Recreating Our Application in Rocket</h1>
			<p>At this point, we have built a fully functioning to-do application with the <strong class="bold">Actix Web framework</strong>. In this chapter, we will go through the core concepts so that there will be nothing holding us back if we decide to completely recreate the to-do application in <strong class="bold">Rocket</strong>. This framework might appeal to some developers because it does not need as much boilerplate code.</p>
			<p>In this chapter, we will fully utilize our isolated modular code to completely recreate our application in one chapter by copying over and plugging in our existing modules, views, database connection configuration, and test pipeline. Even if you are not interested in building web applications in Rocket, I still suggest you still complete this chapter because you will get to experience why it is important to perform well-decoupled testing and write well-structured code, as good tests and structure will enable you to switch web frameworks will little effort.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>What is Rocket?</li>
				<li>Setting up our server</li>
				<li>Plugging in our existing modules</li>
				<li>Returning status with JSON</li>
				<li>Returning multiple statuses</li>
				<li>Registering our views with Rocket</li>
				<li>Plugging in our existing tests</li>
			</ul>
			<p>By the end of this chapter, you will have a fully working to-do application in Rocket with minimal coding. Not only will you understand the basics of configuring and running a Rocket server but you will also be able to port over modules, views, and tests from other code bases that have used Actix Web and plug them into your Rocket server, and vice versa. Not only is this a valuable skill but it also concretes the need for good-quality, isolated code. You will see firsthand how and why you should structure your code the way we have.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor248"/>Technical requirements</h1>
			<p>In this chapter, we’ll build on the code built in <a href="B18722_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Configuring HTTPS with NGINX on AWS</em>. This can be found at the following URL: <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws</a>.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12</a>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor249"/>What is Rocket?</h1>
			<p>Rocket is a Rust web framework, like Actix Web. It’s newer than Actix Web and has a lower user base at the <a id="_idIndexMarker1153"/>time of writing. In the previous edition of this book, Rocket was running on nightly Rust, meaning that the releases were not stable. However, now, Rocket is running on stable Rust.</p>
			<p>The framework does have some advantages, depending on your style of coding. Rocket is simpler to write, since it <a id="_idIndexMarker1154"/>implements boilerplate code itself, so the developer does not have to write boilerplate themselves. Rocket also supports JSON parsing, forms, and type checking out of the box, which can all be implemented with just a few lines of code. Features such as logging are already implemented as soon as you start a Rocket server. If you want to just get an application off the ground with little effort, then Rocket is a good framework. However, it is not as established as Actix Web, meaning that as you get more advanced, you might find yourself envying some of the features and implementations Actix Web has. However, in all my years of web development, I have never come across a problem that has been severely held back by the choice of framework. It will mainly come down to preference. To really feel the difference, it makes sense to take Rocket for a spin. In the next section, we will create a basic server.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor250"/>Setting up our server</h1>
			<p>When it comes to setting up a basic server in Rocket, we are going to start with everything <a id="_idIndexMarker1155"/>defined in the <code>main.rs</code> file. First, start a new Cargo project and then define the Rocket dependency in the <code>Cargo.toml</code> file with the following code:</p>
			<pre class="source-code">
[dependencies]
rocket = "0.5.0-rc.2"</pre>
			<p>This is all we need for now in terms of dependencies. Now, we can move to our <code>src/main.rs</code> file to define the application. Initially, we need to import the Rocket crate and the macros associated with the Rocket crate with the following code:</p>
			<pre class="source-code">
#[macro_use] extern crate rocket;</pre>
			<p>We can now define a basic <em class="italic">hello world</em> view with the following code:</p>
			<pre class="source-code">
#[get("/")]
fn index() -&gt; &amp;'static str {
    "Hello, world!"
}</pre>
			<p>With the preceding code, we can deduce that the macro before the function defines the method and URL endpoint. The function is the logic that is executed when the call is made to the view, and whatever the function returns is what is returned to the user. To get a feel for how powerful the URL macro is, we can create two more views – one saying <code>hello</code> and the other saying <code>goodbye</code>:</p>
			<pre class="source-code">
#[get("/hello/&lt;name&gt;/&lt;age&gt;")]
fn hello(name: String, age: u8) -&gt; String {
    format!("Hello, {} year old named {}!", age, name)
}
#[get("/bye/&lt;name&gt;/&lt;age&gt;")]
fn bye(name: String, age: u8) -&gt; String {
    format!("Goodbye, {} year old named {}!", age, name)
}</pre>
			<p>Here, we can see that we can pass parameters from the URL into the function. Again, this code is clear and straightforward. There is nothing left for us to do, apart from attaching these views to the server and starting it with the following code:</p>
			<pre class="source-code">
#[launch]
fn rocket() -&gt; _ {
    rocket::build().mount("/", routes![index, hello, bye])
}</pre>
			<p>Here, we can see that we must decorate the <code>main</code> function with a macro from Rocket, and we are attaching <a id="_idIndexMarker1156"/>the views that we defined with no prefix. We can then run the <code>cargo run</code> command to launch the server. Once we have done the <code>run</code> command, we get the following output:</p>
			<pre class="console">
<img src="img/01.png" alt=""/> Configured for debug.
   &gt;&gt; address: 127.0.0.1
   &gt;&gt; port: 8000
   &gt;&gt; workers: 8
   &gt;&gt; ident: Rocket
   &gt;&gt; limits: bytes = 8KiB, data-form = 2MiB, file = 1MiB, form =
   32KiB, json = 1MiB, msgpack = 1MiB, string = 8KiB
   &gt;&gt; temp dir: /var/folders/l7/q2pdx7lj0l72s0lsf3kc34fh0000gn/T/
   &gt;&gt; http/2: true
   &gt;&gt; keep-alive: 5s
   &gt;&gt; tls: disabled
   &gt;&gt; shutdown: ctrlc = true, force = true, signals = [SIGTERM],
   grace = 2s, mercy = 3s
   &gt;&gt; log level: normal
   &gt;&gt; cli colors: true
<img src="img/03.png" alt=""/> Routes:
   &gt;&gt; (index) GET /
   &gt;&gt; (bye) GET /bye/&lt;name&gt;/&lt;age&gt;
   &gt;&gt; (hello) GET /hello/&lt;name&gt;/&lt;age&gt;
<img src="img/02.png" alt=""/> Fairings:
   &gt;&gt; Shield (liftoff, response, singleton)
<img src="img/04.png" alt=""/> Shield:
   &gt;&gt; X-Content-Type-Options: nosniff
   &gt;&gt; X-Frame-Options: SAMEORIGIN
   &gt;&gt; Permissions-Policy: interest-cohort=()
<img src="img/05.png" alt=""/> Rocket has launched from http://127.0.0.1:8000</pre>
			<p>Here, we can see that the logging is comprehensive. It defines the port, address, and configuration of the server. It then defines the routes that have been attached, as well as fairings. With the <a id="_idIndexMarker1157"/>preceding logging, we can see that the server is healthy, and we have the routes that we expected. Here, we can see that logging comes out of the box. We do not have to define anything, unlike in Actix Web. We also get a note stating what views are mounted and the URL that the server is listening on.</p>
			<p>We can now call our <em class="italic">hello</em> view in the browser, which gives us the following output:</p>
			<div><div><img src="img/Figure_12.1_B18722.jpg" alt="Figure 12.1 – The result of calling our hello view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The result of calling our hello view</p>
			<p>Calling this view also gives us the following log:</p>
			<pre class="console">
GET /hello/maxwell/33 text/html:
   &gt;&gt; Matched: (hello) GET /hello/&lt;name&gt;/&lt;age&gt;
   &gt;&gt; Outcome: Success
   &gt;&gt; Response succeeded.</pre>
			<p>From looking at the logs, it seems that we cannot ask any more of it. We now have a basic server up and <a id="_idIndexMarker1158"/>running; however, this does not have all the functionality that we had in our previous application, built in Actix Web. Recoding all the features that we had would result in an excessively long chapter. In the next section, we will take advantage of our modular code and slot all our functionality into our Rocket application.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor251"/>Plugging in our existing modules</h1>
			<p>Throughout the book, we have been building isolated modules in their own files or directories <a id="_idIndexMarker1159"/>that only concern themselves with one process. For instance, the database file only focuses on creating and managing database connections. The to-do module only focuses on constructing to-do items, and the JSON serialization module is entirely concerned with serializing data structures to and from JSON. With all this in mind, we will see how easily these modules can be copied into our application and used. Once we have done this, you will get to appreciate firsthand why isolated modules are important.</p>
			<p>First, we must define our dependencies in the <code>Cargo.toml</code> file with the following code:</p>
			<pre class="source-code">
[dependencies]
rocket = {version = "0.5.0-rc.2", features = ["json"]}
bcrypt = "0.13.0"
serde_json = "1.0.59"
serde_yaml = "0.8.23"
chrono = {version = "0.4.19", features = ["serde"]}
serde = { version = "1.0.136", features = ["derive"] }
uuid = {version = "1.0.0", features = ["serde", "v4"]}
diesel = { version = "1.4.8", features = ["postgres",
                              "chrono", "r2d2"] }
lazy_static = "1.4.0"</pre>
			<p>These are the crates that we have used in our previous modules. We can now copy over our old modules <a id="_idIndexMarker1160"/>from the Actix Web application in the <code>web_app</code> directory to our Rocket application, with the following Bash commands:</p>
			<pre class="console">
cp -r ./web_app/src/json_serialization ./rocket_app/src/json_serialization
cp -r ./web_app/src/to_do ./rocket_app/src/to_do
cp -r ./web_app/src/models ./rocket_app/src/models
cp web_app/src/config.rs rocket_app/src/config.rs
cp web_app/config.yml rocket_app/config.yml
cp web_app/src/schema.rs rocket_app/src/schema.rs
cp ./web_app/src/database.rs ./rocket_app/src/database.rs
cp -r ./web_app/migrations ./rocket_app/migrations
cp ./web_app/docker-compose.yml ./rocket_app/docker-compose.yml
cp ./web_app/.env ./rocket_app/.env</pre>
			<p>Everything is close to working; however, we do have some references to the Actix web framework. These can be deleted by deleting the trait implications. As we can see in the following diagram, isolated modules can be directly referenced, and the advanced integration can be implemented using traits:</p>
			<div><div><img src="img/Figure_12.2_B18722.jpg" alt="Figure 12.2 – How our modules can interact with different frameworks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – How our modules can interact with different frameworks</p>
			<p>Once we have deleted the Actix Web trait implementations in the <code>src/database.rs</code> and <code>src/json_serialization/to_do_items.rs</code> files, we can define and import our <a id="_idIndexMarker1161"/>modules in the <code>main.rs</code> file. The top of the <code>main.rs</code> file should look like the following:</p>
			<pre class="source-code">
#[macro_use] extern crate rocket;
#[macro_use] extern crate diesel;
use diesel::prelude::*;
use rocket::serde::json::Json;
mod schema;
mod database;
mod json_serialization;
mod models;
mod to_do;
mod config;
use crate::models::item::item::Item;
use crate::json_serialization::to_do_items::ToDoItems;
use crate::models::item::new_item::NewItem;
use database::DBCONNECTION;</pre>
			<p>With the <a id="_idIndexMarker1162"/>modules imported, we can recreate the <code>create</code> view with the following code:</p>
			<pre class="source-code">
#[post("/create/&lt;title&gt;")]
fn item_create(title: String) -&gt; Json&lt;ToDoItems&gt; {
    let db = DBCONNECTION.db_connection.get().unwrap();
    let items = schema::to_do::table
        .filter(schema::to_do::columns::title.eq(&amp;title.as_str()))
        .order(schema::to_do::columns::id.asc())
        .load::&lt;Item&gt;(&amp;db)
        .unwrap();
    if items.len() == 0 {
        let new_post = NewItem::new(title, 1);
        let _ = diesel::insert_into(schema::to_do::table)
                        .values(&amp;new_post)
                        .execute(&amp;db);
    }
    return Json(ToDoItems::get_state(1));
}</pre>
			<p>We can see from the preceding code that it is like our Actix Web implementation because we are using our existing modules. The only difference is that we pass the <code>ToDoItems</code> struct into the <code>Json</code> function from the Rocket crate. We have not implemented authentication yet, so we are just passing the user ID value of <code>1</code> for now into all the operations that require a user ID.</p>
			<p>Now that our <code>create</code> view is done, we can attach it to our server with the following code:</p>
			<pre class="source-code">
#[launch]
fn rocket() -&gt; _ {
    rocket::build().mount("/", routes![index, hello, bye])
                   .mount("/v1/item", routes![item_create])
}</pre>
			<p>We can see that we do not have to build our own configuration functions. We can just line up the views in the <a id="_idIndexMarker1163"/>array associated with the prefix, and the macro decorating the view functions defines the rest of the URL. We can now run our Rocket server with the following command:</p>
			<pre class="console">
cargo run config.yml</pre>
			<p>We must remember to spin up our <code>docker-compose</code> so the database is accessible and run migrations on the database using the <code>diesel</code> client. We can then create our first to-do item with a <code>post</code> request, using the following URL:</p>
			<pre class="source-code">
http://127.0.0.1:8000/v1/item/create/coding</pre>
			<p>After making the <code>post</code> request, we will get the following response body:</p>
			<pre class="console">
{
    "pending_items": [
        {
            "title": "coding",
            "status": "PENDING"
        }
    ],
    "done_items": [],
    "pending_item_count": 1,
    "done_item_count": 0
}</pre>
			<p>And there you have it! Our application is functioning, and we did not have to recode our entire code base. I know I am repeating myself throughout this book, but the importance of well-structured, isolated code cannot be overstated. What we have done here is useful when refactoring systems. For instance, I have worked on microservices systems where we have <a id="_idIndexMarker1164"/>had to rip functionality out of one server because the scope of it was getting too big and create another one. As you have seen here, isolated modules make such tasks a dream that can be completed in record time with minimal effort.</p>
			<p>Now that we have integrated our existing modules in a basic sense, we can move on to advanced integration by implementing Rocket traits for our modules.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor252"/>Implementing Rocket traits</h1>
			<p>Most of the logic that we have defined in our modules that we copied over can be directly <a id="_idIndexMarker1165"/>referenced in our code. However, we do have to utilize the database connection and the JWT struct that had Actix Web trait implementations. If we are to copy over our views, we are going to have to implement Rocket traits for the database connection and JWT authentication because we pass them into our view functions in the Actix Web application.</p>
			<p>Before we implement the Rocket traits, we must copy over the JWT file with the following command:</p>
			<pre class="console">
cp web_app/src/jwt.rs rocket_app/src/jwt.rs</pre>
			<p>We then must declare the following dependency in the <code>Cargo.toml</code> file with the following code:</p>
			<pre class="source-code">
jsonwebtoken = "8.1.0"</pre>
			<p>We can now move on to the <code>src/jwt.rs</code> file for our Rocket trait implementation. First, we must import the following traits and structs at the top of the file with the following code:</p>
			<pre class="source-code">
use rocket::http::Status;
use rocket::request::{self, Outcome, Request, FromRequest};</pre>
			<p>The core logic of the implementation of <code>FromRequest</code> will be the same because we are concerned <a id="_idIndexMarker1166"/>with the decoding and authentication of our token. However, there will be some minor differences because we are implementing a trait from the Rocket framework, as opposed to an Actix Web crate. The main difference is that we must build our own <code>enum</code> that defines the possible outcomes with the following code:</p>
			<pre class="source-code">
#[derive(Debug)]
pub enum JwTokenError {
    Missing,
    Invalid,
    Expired
}</pre>
			<p>We have picked the different possibilities here because the token might not be in the header, so it would be missing. Alternatively, the token might not be one of ours, so it could be invalid. And remember, we have a timestamp to force an expiry time. If the token has expired, it will have an expired status.</p>
			<p>The next step is merely implementing the <code>FromRequest</code> trait. We do not have to touch our <code>JwToken</code> struct because the code is isolated and only concerned with the encoding and decoding of tokens. The outline of our trait implementation can be defined with the following code:</p>
			<pre class="source-code">
#[rocket::async_trait]
impl&lt;'r&gt; FromRequest&lt;'r&gt; for JwToken {
    type Error = JwTokenError;
    async fn from_request(req: &amp;'r Request&lt;'_&gt;)
                          -&gt; Outcome&lt;Self, Self::Error&gt; {
        . . .
    }
}</pre>
			<p>Here, we can see that we have decorated the implementation of the trait with an <code>async</code> trait macro. This is because requests happen in an async fashion. We also must define lifetime <a id="_idIndexMarker1167"/>notation. This is because we must declare that the lifetime of the request will be the same as that of the trait implementation. We can see this with the <code>request</code> parameter in the <code>from_request</code> function. We can now lift the logic from our old Actix Web implementation into our <code>from_request</code> function with a few changes in the types we return. The lifted code should end up looking like the following:</p>
			<pre class="source-code">
match req.headers().get_one("token") {
    Some(data) =&gt; {
        let raw_token = data.to_string();
        let token_result = JwToken::from_token(raw_token);
        match token_result {
            Ok(token) =&gt; {
                return Outcome::Success(token)
            },
            Err(message) =&gt; {
                if message == "ExpiredSignature".to_owned() {
                    return Outcome::Failure((Status::BadRequest,
                                           JwTokenError::Expired))
                }
                return Outcome::Failure((Status::BadRequest,
                    JwTokenError::Invalid))
            }
        }
    },
    None =&gt; {
        return Outcome::Failure((Status::BadRequest,
                                 JwTokenError::Missing))
    }
}</pre>
			<p>We can see that we have wrapped our returns in the Rocket <code>Outcome</code>, which is not too surprising. We have also included our <code>enum</code> when decoding or accessing the token from the header has failed.</p>
			<p>Our <code>JwToken</code> struct can now be plugged into our Rocket application, but we do have to remember to remove <a id="_idIndexMarker1168"/>the old Actix implementation and all references to the Actix Web framework. We also must declare our <code>jwt</code> module in the <code>main.rs</code> file with the following code:</p>
			<pre class="source-code">
mod jwt;</pre>
			<p>Our next step is to implement the <code>FromRequest</code> trait for our database connection. At this point, it is a good idea for you to try and implement the <code>FromRequest</code> trait for the database connection by yourself. There is nothing new that you must know to achieve this.</p>
			<p>If you have tried to implement the <code>FromRequest</code> trait for the database connection yourself, then it should be like the following steps.</p>
			<p>First, we must import the required Rocket structs and traits in the <code>src/database.rs</code> file with the following code:</p>
			<pre class="source-code">
use rocket::http::Status;
use rocket::request::{self, Outcome, Request, FromRequest};</pre>
			<p>We then must define the outcomes. We either get the connection or we do not, so there is only one possible error for our <code>enum</code>, which takes the following form:</p>
			<pre class="source-code">
#[derive(Debug)]
pub enum DBError {
    Unavailable
}</pre>
			<p>We then implement the <code>FromRequest</code> trait for the database connection with the following <a id="_idIndexMarker1169"/>code:</p>
			<pre class="source-code">
#[rocket::async_trait]
impl&lt;'r&gt; FromRequest&lt;'r&gt; for DB {
    type Error = DBError;
    async fn from_request(_: &amp;'r Request&lt;'_&gt;)
                          -&gt; Outcome&lt;Self, Self::Error&gt; {
      match DBCONNECTION.db_connection.get() {
         Ok(connection) =&gt; {
            return Outcome::Success(DB{connection})
         },
         Err(_) =&gt; {
            return Outcome::Failure((Status::BadRequest,
                                     DBError::Unavailable))
         }
      }
    }
}</pre>
			<p>The preceding code should not be too much of a surprise; we have merely fused the existing logic of <a id="_idIndexMarker1170"/>getting a database connection with the implementation of a <code>FromRequest</code> trait that was laid out in the <code>JwToken</code> implementation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have noticed that we have annotated our <code>FromRequest</code> implementation with <code>[rocket::async_trait]</code>. We use this because, at the time of writing, the stabilization for the <code>async</code> feature in Rust does not include support for <code>async</code> functions in traits. If we try and implement an <code>async</code> function in a trait without the annotation, we will get the following error:</p>
			<pre class="source-code">
trait fns cannot be declared `async`</pre>
			<p class="callout">The <code>[rocket::async_trait]</code> annotation enables us to define <code>async</code> functions in a trait implementation. There are reasons why we cannot simply desugar the <code>async</code> function and have the following function signature:</p>
			<pre class="source-code">
async fn from_request(_: &amp;'r Request&lt;'_&gt;)
                      -&gt; Pin&lt;Box&lt;dyn Future&lt;Output
                      = Outcome&lt;Self, Self::Error&gt;&gt;
                      + Send + '_&gt;&gt; {</pre>
			<p class="callout">However, it will not work because we cannot return the <code>impl</code> trait in trait functions because this is not supported. For in-depth reading on why <code>async</code> functions in traits are hard, please visit the following blog post: <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/</a>.</p>
			<p>We can now implement our database connection in the <code>create</code> view in the <code>main.rs</code> file. Again, this is a good opportunity for you to try and implement the database connection using the <code>FromRequest</code> trait yourself.</p>
			<p>If you have <a id="_idIndexMarker1171"/>attempted to utilize the Rocket <code>FromRequest</code> trait in the <code>create</code> view, your code should look as follows:</p>
			<pre class="source-code">
#[post("/create/&lt;title&gt;")]
fn item_create(title: String, db: DB) -&gt; Json&lt;ToDoItems&gt; {
    let items = schema::to_do::table
        .filter(schema::to_do::columns::title.eq(&amp;title.as_            str()))
        .order(schema::to_do::columns::id.asc())
        .load::&lt;Item&gt;(&amp;db.connection)
        .unwrap();
    if items.len() == 0 {
        let new_post = NewItem::new(title, 1);
        let _ = diesel::insert_into(schema::to_do::table)
            .values(&amp;new_post)
            .execute(&amp;db.connection);
    }
    return Json(ToDoItems::get_state(1));
}</pre>
			<p>If we run our application again and then hit the <code>create</code> endpoint, we will see that our implementation works! This is a revelation that our views with a few alterations can be copied and pasted <a id="_idIndexMarker1172"/>over to our Rocket application from our Actix Web application. In the next section, we will integrate our existing views into our Rocket web application.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor253"/>Plugging in our existing views</h1>
			<p>When it comes to our views, they are also isolated, and we can copy our views over to the Rocket <a id="_idIndexMarker1173"/>application with a few minor changes to recycle the views that we built for our Actix Web application. We can copy the views with the following command:</p>
			<pre class="console">
cp -r web_app/src/views rocket_app/src/views</pre>
			<p>With this copy, it goes without saying now that we must go through and scrub the views of any mentions of the Actix Web framework, as we are not using it. Once we have cleaned our views of any mention of Actix Web, we can refactor our existing code so that it works with the Rocket framework. We will start with our <code>login</code> view, as this takes in a JSON body and returns JSON in the following subsection.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor254"/>Accepting and returning JSON</h2>
			<p>Before we change <a id="_idIndexMarker1174"/>our view, we need to make sure that we <a id="_idIndexMarker1175"/>have imported <a id="_idIndexMarker1176"/>all we need in the <code>src/views/auth/login.rs</code> file <a id="_idIndexMarker1177"/>with the following code:</p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use rocket::serde::json::Json;
use crate::database::DB;
use crate::models::user::user::User;
use crate::json_serialization::{login::Login,
                login_response::LoginResponse};
use crate::schema::users;
use crate::jwt::JwToken;</pre>
			<p>We can see that there is not much that has changed apart from the <code>Json</code> struct coming from the Rocket crate. Implementing those Rocket traits really helped us sever a link in our code to the Actix framework and connect to the Rocket framework, without having to change how the structs that are implementing those traits are imported or used. With this in mind, the following outline of our login view should not be a shock:</p>
			<pre class="source-code">
#[post("/login", data = "&lt;credentials&gt;", format = "json")]
pub async fn login&lt;'a&gt;(credentials: Json&lt;Login&gt;, db: DB) -&gt;
                                        Json&lt;LoginResponse&gt; {
    . . .
}</pre>
			<p>We can see that we reference our incoming JSON body and database connection in the same way as we <a id="_idIndexMarker1178"/>did before in the Actix login view. The major difference <a id="_idIndexMarker1179"/>is the macro that highlights what the data is and <a id="_idIndexMarker1180"/>what format that incoming data takes. Inside the <code>login</code> view, we <a id="_idIndexMarker1181"/>have the following logic:</p>
			<pre class="source-code">
let username: String = credentials.username.clone();
let password: String = credentials.password.clone();
let users = users::table
    .filter(users::columns::username.eq(username.as_str()))
    .load::&lt;User&gt;(&amp;db.connection).unwrap();
match users[0].clone().verify(password) {
    true =&gt; {
        let user_id = users[0].clone().id;
        let token = JwToken::new(user_id);
        let raw_token = token.encode();
        let body = LoginResponse{token: raw_token.clone()};
        return Json(body)
    },
    false =&gt; panic!("unauthorised")
}</pre>
			<p>We can see in the code that the only difference is instead of returning multiple different codes, we merely throw an error. This approach is not optimal. In previous builds, the Rocket framework used to implement a straightforward response builder, like in Actix. However, at the time <a id="_idIndexMarker1182"/>of writing, Rocket has implemented a lot of <a id="_idIndexMarker1183"/>breaking changes in its recent releases. Standard response <a id="_idIndexMarker1184"/>builders simply do not work now, and convoluted implementations <a id="_idIndexMarker1185"/>of traits are needed just to return a response with a code, body, and values in the header. Documentation and examples of this are also limited at the time of writing. Further reading on constructing more advanced responses is supplied in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
			<p>Now that our <code>login</code> view is defined, we can move on to our <code>logout</code> view that returns raw HTML.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor255"/>Returning raw HTML</h2>
			<p>If you recall, our <a id="_idIndexMarker1186"/>logout mechanism returns raw HTML that runs <a id="_idIndexMarker1187"/>JavaScript in a browser to remove our token. When it comes to Rocket, returning raw HTML is simple. In our <code>src/views/auth/logout.rs</code> file, the entire code takes the following form:</p>
			<pre class="source-code">
use rocket::response::content::RawHtml;
#[get("/logout")]
pub async fn logout() -&gt; RawHtml&lt;&amp;'static str&gt; {
        return RawHtml("&lt;html&gt;\
                &lt;script&gt;\
                    localStorage.removeItem('user-token'); \
                    window.location.replace(
                        document.location.origin);\
                &lt;/script&gt;\
              &lt;/html&gt;")
}</pre>
			<p>We can see that it is returning a string, just like in the previous Actix Web view, but this string is <a id="_idIndexMarker1188"/>wrapped in a <code>RawHtml</code> struct. We can now start updating <a id="_idIndexMarker1189"/>our to-do action views so that our users can manipulate to-do items, as discussed in the next section.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor256"/>Returning status with JSON</h1>
			<p>So far, we have <a id="_idIndexMarker1190"/>returned JSON and raw HTML. However, remember <a id="_idIndexMarker1191"/>that our to-do applications return JSON with different statuses. To explore this concept, we can revisit our <code>create</code> view in the <code>src/views/to_do/create.rs</code> file, where we must return a created status with a JSON body. First, all our imports are the same as they were before, apart from the status and JSON structs from the Rocket framework with the following code:</p>
			<pre class="source-code">
use rocket::serde::json::Json;
use rocket::response::status::Created;</pre>
			<p>With these imports, we can define the outline of our <code>create</code> view function with the following code:</p>
			<pre class="source-code">
#[post("/create/&lt;title&gt;")]
pub async fn create&lt;'a&gt;(token: JwToken, title: String, db: DB)
                                 -&gt; Created&lt;Json&lt;ToDoItems&gt;&gt; {
    . . .
}</pre>
			<p>We can see that our return value is the <code>Created</code> struct, containing the <code>Json</code> struct, which in turn contains the <code>ToDoItems</code> struct. We can also see that our JWT authentication <a id="_idIndexMarker1192"/>is implemented in a view the same way because, again, we <a id="_idIndexMarker1193"/>are implementing the Rocket traits. Our database logic is the same as the previous view, as seen with the following code:</p>
			<pre class="source-code">
let items = to_do::table
    .filter(to_do::columns::title.eq(&amp;title.as_str()))
    .order(to_do::columns::id.asc())
    .load::&lt;Item&gt;(&amp;db.connection)
    .unwrap();
if items.len() == 0 {
    let new_post = NewItem::new(title, token.user_id);
    let _ = diesel::insert_into(to_do::table).values(&amp;new_post)
        .execute(&amp;db.connection);
}</pre>
			<p>If the task is already not present in the database, we will insert our new to-do item. Once we have done this, we get the state of our system and return it with the following code:</p>
			<pre class="source-code">
let body = Json(ToDoItems::get_state(token.user_id));
return Created::new("").body(body)</pre>
			<p>The empty string is the location. This can be left blank with no consequences. We then attach our body with the <code>body</code> function of the status. This is all that is needed to get our <code>create</code> view running as we want it.</p>
			<p>When it comes to the other views for our to-do tasks, they will all be some variation of what we have done for the <code>create</code> view. All to-do views need to take the following steps:</p>
			<ol>
				<li>Authenticate using JWT.</li>
				<li>Connect to a database.</li>
				<li>Take in data from the JSON body and/or user data from the JWT.</li>
				<li>Make some manipulation of the data in the database (apart from the <code>GET</code> view).</li>
				<li>Return the state of the database for the user.</li>
			</ol>
			<p>After seeing what we have done with the <code>create</code> view, you should be able to work through all the other views to make them compatible with the Rocket framework. We have covered <a id="_idIndexMarker1194"/>everything needed to make these changes. Spelling out these <a id="_idIndexMarker1195"/>changes in the book will lead to needless repetitive steps being carried out, excessively bloating it. These changes are available on the book’s GitHub repository.</p>
			<p>Once the to-do item views have been carried out, we can move on to the final view that’s needed, the creation of a user, where we must return different statuses depending on the outcome.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor257"/>Returning multiple statuses</h1>
			<p>When it comes to creating a user, we merely return a created status code or a conflict status code and <a id="_idIndexMarker1196"/>nothing else. We do not need to return data because the person who has just created the user already knows the user details. In Rocket, we can return multiple different status codes with no body. We can explore this concept in the <code>src/views/to_do/create.rs</code> file, but first, we must ensure that we import the following:</p>
			<pre class="source-code">
use crate::diesel;
use diesel::prelude::*;
use rocket::serde::json::Json;
use rocket::http::Status;
use crate::database::DB;
use crate::json_serialization::new_user::NewUserSchema;
use crate::models::user::new_user::NewUser;
use crate::schema::users;</pre>
			<p>Now that we have everything we need, we can define the outline of the view with the following code:</p>
			<pre class="source-code">
#[post("/create", data = "&lt;new_user&gt;", format = "json")]
pub async fn create_user(new_user: Json&lt;NewUserSchema&gt;, db: DB)
    -&gt; Status {
    . . .
}</pre>
			<p>Here, we can see <a id="_idIndexMarker1197"/>that there is nothing new, apart from returning a single <code>Status</code> struct. Our database logic takes the following form:</p>
			<pre class="source-code">
let name: String = new_user.name.clone();
let email: String = new_user.email.clone();
let password: String = new_user.password.clone();
let new_user = NewUser::new(name, email, password);
let insert_result = diesel::insert_into(users::table)
            .values(&amp;new_user).execute(&amp;db.connection);</pre>
			<p>And we return a status out of two possible ones with the following code:</p>
			<pre class="source-code">
match insert_result {
    Ok(_) =&gt; Status::Created,
    Err(_) =&gt; Status::Conflict
}</pre>
			<p>Our views are <a id="_idIndexMarker1198"/>complete. We can now move on to the next section to register our views with the Rocket application.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor258"/>Registering our views with Rocket</h1>
			<p>Before we <a id="_idIndexMarker1199"/>move on to the <code>src/main.rs</code> file, we must ensure <a id="_idIndexMarker1200"/>that our view functions are available to the <code>src/main.rs</code>. This means going through all the <code>mod.rs</code> files in each view module and declaring the functions that define these views as public. We can then move on to the <code>src/main.rs</code> file and ensure that the following is imported:</p>
			<pre class="source-code">
#[macro_use] extern crate rocket;
#[macro_use] extern crate diesel;
use rocket::http::Header;
use rocket::{Request, Response};
use rocket::fairing::{Fairing, Info, Kind};</pre>
			<p>The <code>macro_use</code> declarations should not be a surprise; however, we import the Rocket structs to define our CORS policy. With these crates imported, we now must ensure that the following modules have been declared:</p>
			<pre class="source-code">
mod schema;
mod database;
mod json_serialization;
mod models;
mod to_do;
mod config;
mod jwt;
mod views;</pre>
			<p>These modules should all look familiar to you. We then must import our views with the following code:</p>
			<pre class="source-code">
use views::auth::{login::login, logout::logout};
use views::to_do::{create::create, delete::delete,
                   edit::edit, get::get};
use views::users::create::create_user;</pre>
			<p>We now have everything we need imported. Before declaring our views on the server, we need to <a id="_idIndexMarker1201"/>define our CORS policy. This is achieved by <a id="_idIndexMarker1202"/>declaring a struct with no fields. We then implement the <code>Fairing</code> trait for this struct, allowing traffic. Fairings essentially define middleware. Further information on fairings is provided in the <em class="italic">Further reading</em> section. Our CORS policy can be defined with the following code:</p>
			<pre class="source-code">
pub struct CORS;
#[rocket::async_trait]
impl Fairing for CORS {
    fn info(&amp;self) -&gt; Info {
        Info {
            name: "Add CORS headers to responses",
            kind: Kind::Response
        }
    }
    async fn on_response&lt;'r&gt;(&amp;self, _request: &amp;'r Request&lt;'_&gt;,
                                response: &amp;mut Response&lt;'r&gt;) {
        response.set_header(Header::new(
                         "Access-Control-Allow-Origin", "*"));
        response.set_header(Header::new(
                        "Access-Control-Allow-Methods",
                        "POST, GET, PATCH, OPTIONS"));
        response.set_header(Header::new(
                        "Access-Control-Allow-Headers", "*"));
        response.set_header(Header::new(
                        "Access-Control-Allow-Credentials",
                        "true"));
    }
}</pre>
			<p>By this point in the book, we are now familiar with the concept of CORS and how to implement a Rocket trait. The preceding code needs no elaboration.</p>
			<p>We now have <a id="_idIndexMarker1203"/>everything needed to mount our views to the <a id="_idIndexMarker1204"/>server with the following code:</p>
			<pre class="source-code">
#[launch]
fn rocket() -&gt; _ {
    rocket::build().mount("/", routes![index, hello, bye])
                   .mount("/v1/item/", routes![create, delete,
                                               edit, get])
                   .mount("/v1/auth/", routes![login, logout])
                   .mount("/v1/user/", routes![create_user])
                   .attach(CORS)
                   .manage(CORS)
}</pre>
			<p>Again, there is no explanation needed. You may have noticed that we have started to simply show code with little to no explanation. This is good, as we have become familiar with the building blocks that we are using. Do not worry – we have come to the end of building the <a id="_idIndexMarker1205"/>main Rocket application, as it will run and do everything <a id="_idIndexMarker1206"/>we need. We could manually test this. However, this would take time and is error-prone.</p>
			<p>Remember, we built our tests in Newman using Postman! In the next section, we will test all our endpoints with a few commands using the existing testing pipeline.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor259"/>Plugging in our existing tests</h1>
			<p>Because we have <a id="_idIndexMarker1207"/>used Newman in our testing pipeline, we do not have to worry about high coupling with our choice of web framework. First, we need to copy over our tests in the <code>scripts</code> directory with the following command:</p>
			<pre class="console">
cp -r web_app/scripts rocket_app/scripts</pre>
			<p>However, before running it, we must add a <code>GET</code> method for our <code>login</code> view with the following outline:</p>
			<pre class="source-code">
#[get("/login", data = "&lt;credentials&gt;", format = "json")]
pub async fn login_get&lt;'a&gt;(credentials: Json&lt;Login&gt;, db: DB)
                                    -&gt; Json&lt;LoginResponse&gt; {
    // same logic as in the login view
}</pre>
			<p>We then need to import this view into the <code>src/main.rs</code> file and declare it in the <code>auth</code> mounting for our server. We are now ready to run our full tests with the following command:</p>
			<pre class="console">
sh scripts/run_test_pipeline.sh</pre>
			<p>This will run our full pipeline and give the following results:</p>
			<div><div><img src="img/Figure_12.3_B18722.jpg" alt="Figure 12.3 – Results from our full test pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Results from our full test pipeline</p>
			<p>We can see that out of 64 checks, only 3 have failed. If we scroll further down, we can see that the errors <a id="_idIndexMarker1208"/>occur only because we are returning different response codes for the <code>create</code> view, as seen here:</p>
			<pre class="console">
  #  failure                   detail
 1.  AssertionError            response is ok
                               expected response to have status
                               code 200 but got 201
                               at assertion:0 in test-script
                               inside "1_create"
 2.  AssertionError            response is ok
                               expected response to have status
                               code 200 but got 201
                               at assertion:0 in test-script
                               inside "2_create"
 3.  AssertionError            response is ok
                               expected response to have status
                               code 200 but got 201
                               at assertion:0 in test-script
                               inside "3_create"</pre>
			<p>Everything else, in <a id="_idIndexMarker1209"/>terms of the logging in, authentication, migrations, and state of the data in the database between every step, has behaved just like we expected it to.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor260"/>Summary</h1>
			<p>In this chapter, we have gone through the main concepts needed to replicate our to-do application. We built and ran a Rocket server. We then defined routes and established a database connection for our server. After that, we explored middleware and built authentication and data processing, using guards for our views. With this, we created a view that utilized everything we have covered in this book.</p>
			<p>What we gained here was a deeper appreciation for the modular code that we have built throughout this book. Even though some of the concepts we revisited had not been touched since the start of this book, these modules were isolated, did one thing, and did what their labels proposed. Because of this, they can easily be copied over and utilized in a completely different framework. Our test pipeline also came in handy, instantly confirming that our Rocket application behaves in the same way our Actix Web application does. With this in mind, our Rocket application could be seamlessly integrated into our build and deployment pipelines instead of our Actix Web application.</p>
			<p>In the next chapter, we will cover the best practices for building a web application, resulting in a clean web application repository. Here, you will not only learn how to structure a web application repository in terms of testing and configuration but also how to package a web application in Docker as a distroless distribution, resulting in tiny Docker images that are roughly 50 MB.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor261"/>Further reading</h1>
			<ul>
				<li>Rocket documentation: <a href="https://rocket.rs/">https://rocket.rs/</a></li>
				<li>Fairings documentation: <a href="https://rocket.rs/v0.4/guide/fairings/">https://rocket.rs/v0.4/guide/fairings/</a></li>
				<li><em class="italic">Rust Web Development with Rocket: A practical guide to starting your journey in Rust web development using the Rocket framework</em>, <em class="italic">Karuna Murti</em> (2022), <em class="italic">Packt Publishing</em></li>
			</ul>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor262"/>Questions</h1>
			<ol>
				<li value="1">We have witnessed firsthand the importance of isolating processes such as our test pipeline. Looking at the test pipeline, is there a dependency that could be removed to further decouple the pipeline so that it isn’t even dependent on us testing a Rust server?</li>
				<li>How do we attach and detach all functionality in our modules with frameworks such as Actix and Rocket?</li>
				<li>How would we deploy our Rocket server on AWS?</li>
			</ol>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor263"/>Answers</h1>
			<ol>
				<li value="1">Right now, our test pipeline relies on Diesel to do the migrations. We could simply build our own SQL scripts, housed in directories that define our version with a version table in the database. This would completely decouple our testing pipeline from the server that we are testing. If the server has the same endpoints and access to a PostgreSQL database, it can be tested using our pipeline, no matter what language the server is coded in.</li>
				<li>If the module is simple with a good interface, we can merely copy it over and import it where we want to use it. If the module relies on advanced functionality with the framework, we must delete the trait implementations for the framework and implement traits for the new one.</li>
				<li>We need to note that our test pipeline ran the Rocket server without any alterations. This is because we are using the same config and using Cargo to build and run the application. We would merely just have to point our build to the Rocket application and copy over our Dockerfile to the Rocket application. Our build process would then build the Rocket application in Docker and deploy it to Docker Hub. Our deployment process would then pull the image from Docker Hub and deploy it. We know our endpoints are the same and behave in the same way, so integration should be painless.</li>
			</ol>
		</div>
	</body></html>