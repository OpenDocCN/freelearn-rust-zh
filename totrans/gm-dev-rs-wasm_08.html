<html><head></head><body>
		<div><h1 id="_idParaDest-94"><em class="italic"><a id="_idTextAnchor139"/>Chapter 6</em>: Creating an Endless Runner</h1>
			<p><strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) can run, jump on a platform, and even crash into a rock and fall over. But once he starts running to his right, he just goes off the screen and is never seen again. There isn't much to it, and if you wait long enough, the game even crashes with a buffer overflow error. In this chapter, we'll make our game truly endless by generating new scenes as RHB runs that contain new obstacles and challenges. They will even contain randomness, and it all starts with RHB staying in one place! It's a real trick.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Scrolling the background</li>
				<li>Refactoring for endless running</li>
				<li>Creating a dynamic level</li>
			</ul>
			<p>By the end of this chapter, you'll have a functioning endless runner and be able to create obstacles for RHB to hop over and slide under.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>For this chapter, you'll need all the assets at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. Just like in the previous chapters, you can find the source code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/35pES1T">https://bit.ly/35pES1T</a></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor141"/>Scrolling the background </h1>
			<p>To run RHB<a id="_idIndexMarker479"/> left to right<a id="_idIndexMarker480"/> with an infinite background, we have two choices, as follows:</p>
			<ul>
				<li>Procedurally generate a background, based on a pattern or mathematical formula.</li>
				<li>Use the Hanna-Barbera technique.</li>
			</ul>
			<p>While the first option<a id="_idIndexMarker481"/> may appear more interesting or dynamic, the Hanna-Barbera technique<a id="_idIndexMarker482"/> is much simpler, and it's <a id="_idIndexMarker483"/>what we'll be using for Walk the Dog. What is the Hanna-Barbera technique? Well, for starters, it may not even go by that name, but that's what I'm calling it. Hanna-Barbera was an animation studio that ran a series of very popular cartoons from the '50s through to the '90s, including Tom and Jerry, The Flintstones, Scooby-Doo, Yogi Bear, and many more. If you were a child in any of those decades, you would wake up to "Saturday morning cartoons," which were dominated by Hanna-Barbera properties. While the studio was known for their beloved characters, they were also known for cutting costs. They produced a lot of cartoons and needed to maximize the ways they could create them quickly and cheaply.</p>
			<p>One of the most common traits of Hanna-Barbera cartoons was a repeating background. At the end of an episode of Yogi Bear, for example, Ranger Smith would start chasing Yogi Bear across Jellystone park. However, if you looked closely, Jellystone park appeared to have the same series of trees repeating (see <a href="https://bit.ly/3BNuNXZ">https://bit.ly/3BNuNXZ</a> for an example). This money-saving technique is going to work great for our endless runner. We'll use the same background element we're using now and move it to the left as RHB runs to the right. Immediately after, it will become a copy of the same background, making two <code>Image</code> elements with the same source image. Once the first image moves completely off screen, we'll move it so that it's to the right of the second image. These two backgrounds will loop, creating the illusion of the background moving forever:</p>
			<div><div><img alt="Figure 6.1 – Sliding the canvas over the background&#13;&#10;" src="img/Figure_6.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Sliding the canvas over the background</p>
			<p>This technique relies on three things. The first is that the background has to be seamless so that there<a id="_idIndexMarker484"/> is no visible seam between the two images. Fortunately, our background was built for this and it will work fine. The second is that the canvas window needs to be smaller than the background so that the entire background is never shown on screen. If we do this, then the first background can go entirely off screen to the left and then be moved to the right of the second background, all without any noticeable gaps or tearing. This is because this all happens outside the window's boundaries. I like to think of it as being offstage in a play, then scrambling over to the right-hand side behind the curtain.</p>
			<p>Finally, we must use another illusion and freeze the main character in place. Instead of moving the character from left to right on the screen, the objects will move right to left, almost as if on a treadmill. Visually, this will look the same as if the character were running, and it has the advantage of fixing a bug where if the player keeps running right, their <em class="italic">x</em> position eventually overflows (becomes bigger than the i16 we are using to hold it) and the game crashes. We'll have to adjust our brains by changing the <em class="italic">x</em> velocity from what we expect, but <a id="_idIndexMarker485"/>once you get used to it, you'll find that it works quite easily. Let's get started with our scrolling background.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For another example of this technique, go to <a href="https://bit.ly/3BPNBGc">https://bit.ly/3BPNBGc</a>, which explains how this works in a game<a id="_idIndexMarker486"/> that continuously moves up, such as Doodle Jump.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor142"/>Fixing RHB in x </h2>
			<p>We can scroll the background as much as we want, but if we continue to simultaneously move RHB to the <a id="_idIndexMarker487"/>right<a id="_idIndexMarker488"/> at the same time, the effect will be having him run at double speed. Instead, we want RHB to run in place while the rocks and platforms move toward him as if they were on a conveyor belt. At the end of this section, we will see RHB run to the right into an empty white void as everything passes past him as if he were running past the end of the world.</p>
			<p>Let's start in the <code>game::red_hat_boy_states</code> module and not update <code>x</code> in the <code>update</code> method of <code>RedHatBoyContext</code>:</p>
			<pre>impl RedHatBoyContext {
    fn update(mut self, frame_count: u8) -&gt; Self {
         ...
         // DELETE THIS LINE! self.position.x += 
           self.velocity.x
         self.position.y += self.velocity.y;
         ...</pre>
			<p>With this change, RHB will<a id="_idIndexMarker489"/> run in place, with nothing moving around<a id="_idIndexMarker490"/> him. We are keeping <code>velocity</code> as is because that value is going to be used by the rest of the code base. For ease of use, we'll add a few methods. First, let's add an accessor to the <code>RedHatBoy</code> implementation, as shown here:</p>
			<pre>impl RedHatBoy {
    ...
    fn walking_speed(&amp;self) -&gt; i16 {
        self.state_machine.context().velocity.x
    }</pre>
			<p>This function works similar to several of our other accessors for <code>RedHatBoy</code>, making it easier to get at the <code>context</code> values. Next, let's add a new implementation – <code>Walk</code> for the <code>Walk</code> struct:</p>
			<pre>impl Walk {
    fn velocity(&amp;self) -&gt; i16 {
        -self.boy.walking_speed()
    }
}</pre>
			<p>The <code>Walk</code> implementation is only available when the <code>WalkTheDog</code> enum is in the <code>Loaded</code> state and it flips <code>walking_speed</code> of <code>boy</code>. While <code>boy</code> is moving to the right, this means everything else is moving to the left. Now, in the <code>update</code> function of <code>WalkTheDog</code>, we can use that value to move everything else to the left. Right after updating <code>walk.boy</code>, we can update the <code>stone</code> and <code>platform</code> positions so that they match the following code:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            walk.boy.update();
            walk.platform.position.x += walk.velocity();
            walk.stone.move_horizontally(walk.velocity());
            ...</pre>
			<p>You should get a<a id="_idIndexMarker491"/> compiler error<a id="_idIndexMarker492"/> because <code>stone</code> doesn't have a <code>move_horizontally</code> function. <code>Stone</code> is of the <code>Image</code> type and can be found in the <code>engine</code> module, while <code>position</code> on <code>Image</code> is private. We'll keep things that way, and instead add <code>move_horizontally</code> to the <code>Image</code> implementation, as shown here:</p>
			<pre>impl Image {
    ...
    pub fn move_horizontally(&amp;mut self, distance: i16) {
        self.bounding_box.x += distance as f32;
        self.position.x += distance;
    }
}</pre>
			<p>Two things may bother you about this code. The first is that we are directly manipulating <code>position</code> on <code>Platform</code> but used a method on <code>Image</code>. This inconsistency is a <em class="italic">smell</em> that tells us that something isn't right with our code – in this case, <code>stone</code> and <code>platform</code> have two different interfaces to modify their positions, even though the code has been duplicated. For now, we'll leave this as is, but it's a hint regarding changes we may want to make later. The other is that we're updating the <code>bounding_box</code> and <code>position</code> values<a id="_idIndexMarker493"/> with the same thing. That's a refactoring <a id="_idIndexMarker494"/>we'll leave for the next section (putting a <code>position</code> on <code>Rect Point</code>), although you can do it now if you're feeling ambitious.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Code smell is a programming term that was coined by Kent Beck and popularized by Martin Fowler in his book <em class="italic">Refactoring</em>. If you're getting paid money to program, gaming or not, you should check this book out.</p>
			<p>Now, you should see RHB running in place as the rock and platform move beneath him:</p>
			<div><div><img alt="Figure 6.2 – Where did the rock go?&#13;&#10;" src="img/Figure_6.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Where did the rock go?</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't forget to restart the server if changes don't seem to be showing up. I had to when deleting code, for some reason.</p>
			<p>We can start moving the <a id="_idIndexMarker495"/>background<a id="_idIndexMarker496"/> by matching the <code>stone</code> and <code>platform</code> movement in the <code>update</code> function of <code>WalkTheDogupdate</code>. This change will look as follows:</p>
			<pre>fn update(&amp;mut self, keystate: &amp;KeyState) {
    if let WalkTheDog::Loaded(walk) = self {
        ...
        walk.platform.position.x += walk.velocity();
        walk.stone.move_horizontally(walk.velocity());
        <strong class="bold">walk.background.move_horizontally(walk.velocity());</strong>
        ...</pre>
			<p>This small change will mean that RHB can now walk off the edge of the world:</p>
			<div><div><img alt="Figure 6.3 – Look, the empty void!" src="img/Figure_6.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Look, the empty void!</p>
			<p>However, we don't want this, so <a id="_idIndexMarker497"/>let's learn<a id="_idIndexMarker498"/> how to use two tiling backgrounds to simulate an infinite one.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor143"/>An infinite background </h2>
			<p>To get an infinite<a id="_idIndexMarker499"/> background, we'll need two background<a id="_idIndexMarker500"/> images instead of one. We'll start by storing <code>background</code> as an array instead of just one <code>Image</code> in <code>Walk</code>, as shown here:</p>
			<pre>struct Walk {
    boy: RedHatBoy,
    <strong class="bold">backgrounds: [Image; 2],</strong>
    stone: Image,
    platform: Platform,
}</pre>
			<p>This will cause several compiler errors because <code>backgrounds</code> doesn't exist; even if it did, the code<a id="_idIndexMarker501"/> expects it to be an <code>Imagearray</code>. Fortunately, the errors largely <a id="_idIndexMarker502"/>make sense and we can figure out what needs to be done. Moving once again to <code>initialize</code> in the <code>Game</code> implementation, let's set up an array of <code>backgrounds</code> instead of just one when initializing <code>Walk</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let background_width = background.width() 
                 as i16;
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    boy: rhb,
                    backgrounds: [
                        Image::new(background.clone(), 
                        Point { x: 0, y: 0 }),
                        Image::new(
                            background,
                            Point {
                                x: background_width,
                                y: 0,
                            },
                        ),
                    ],
                    stone: Image::new(stone, Point { x: 
                     150, y: 546 }),
                    platform,
                })))
                ...</pre>
			<p>There's a little more going on here compared to our previous changes, so let's go through this code in more detail. The first thing<a id="_idIndexMarker503"/> we do is get the <code>width</code> property <a id="_idIndexMarker504"/>of <code>background</code>. This is the temporary variable that we created when we loaded <code>HtmlImageElement</code>, not the <code>background</code> property that's attached to <code>Walk</code> that we have been using. We have done this to prevent a borrow-after-move error during the initialization of <code>Walk</code>. Then. we made <code>Walk</code> take an array of <code>Image</code> objects, making sure to clone the <code>background</code> property the first time we create it. Finally, we made sure to position the second <code>Image</code> at <code>background_width</code> so that it will be lined up to the right of the first background, off screen.</p>
			<p>However, we still aren't done with compiler errors. This is because the background is being updated and drawn. We'll make the simplest changes we can so that we can start compiling and running again. First, replace the <code>move_horizontally</code> code we just wrote in the <code>update</code> function with the following code, which loops through all the backgrounds and moves them:</p>
			<pre>fn update(&amp;mut self, keystate: &amp;KeyState) {
   if let WalkTheDog::Loaded(walk) = self {
        ...
        walk.platform.position.x += walk.velocity();
        walk.stone.move_horizontally(walk.velocity());
<strong class="bold">        let velocity = walk.velocity();</strong>
<strong class="bold">        walk.backgrounds.iter_mut().for_each(|background| {</strong>
<strong class="bold">            background.move_horizontally(velocity);</strong>
<strong class="bold">        });</strong></pre>
			<p>Make sure you use <code>iter_mut</code> so that <code>background</code> is mutable. Note that<a id="_idIndexMarker505"/> you'll <a id="_idIndexMarker506"/>need to bind <code>walk.velocity()</code> to a temporary variable; otherwise, you'll get a compiler error saying <code>cannot borrow '*walk' as immutable because it is also borrowed as mutable</code>. Now, you can update the <code>draw</code> function to draw all the backgrounds:</p>
			<pre>fn draw(&amp;self, renderer: &amp;Renderer) {
    ...
        if let WalkTheDog::Loaded(walk) = self {
            walk.backgrounds.iter().for_each(|background| {
                background.draw(renderer);
            });
           ...</pre>
			<p>Here, we are looping through <code>backgrounds</code> again and drawing them, relying on the canvas to only show the backgrounds that are on screen. If you play the game while running this code, you'll see that RHB runs farther but doesn't run infinitely. This is because we aren't cycling the backgrounds. If you run the game for long enough, you'll see that the game also crashes with a buffer overflow error, but we'll fix that in the next section. First, we need to get the backgrounds cycling. We can do that by replacing the loop in the <code>update</code> function with code that explicitly destructures the array, as shown here:</p>
			<pre>fn update(&amp;mut self, keystate: &amp;KeyState) {
   if let WalkTheDog::Loaded(walk) = self {
       ...
       walk.platform.position.x += walk.velocity();
       walk.stone.move_horizontally(walk.velocity());
       let velocity = walk.velocity();
       let [first_background, second_background] = &amp;mut 
        walk.backgrounds;
       first_background.move_horizontally(velocity);
       second_background.move_horizontally(velocity);
       if first_background.right() &lt; 0 {
            first_background.set_x(
             second_background.right());
       }
       if second_background.right() &lt; 0 {
            second_background.set_x(
             first_background.right());
       }
       ...</pre>
			<p>Here, we start by replacing the <code>for</code> loop with <code>let [first_background, second_background] = &amp;mut walk.backgrounds;</code> to get access to both backgrounds. Then, we <a id="_idIndexMarker507"/>move them both<a id="_idIndexMarker508"/> to the left, the same as we did in the loop, and we check whether the right-hand side of the image is negative. This means that the image is off screen, so we can go ahead and move it to the right-hand side of the other background. If you type this in, it won't compile because <code>set_x</code> and <code>right</code> don't exist on the <code>Image</code> struct. Open the <code>engine</code> module again so that we can add those to <code>Image</code>, as follows:</p>
			<pre>impl Image {
    ...
    pub fn move_horizontally(&amp;mut self, distance: i16) {
        self.set_x(self.position.x + distance);
    }
    pub fn set_x(&amp;mut self, x: i16) {
        self.bounding_box.x = x as f32;
        self.position.x = x;
    }
    pub fn right(&amp;self) -&gt; i16 {
        (self.bounding_box.x + self.bounding_box.width) as 
         i16
    }
}</pre>
			<p>Here, we <a id="_idIndexMarker509"/>added a <code>set_x</code> function<a id="_idIndexMarker510"/> that updates <code>position</code> and <code>bounding_box</code>, just like we did previously, and we had <code>move_horizontally</code> call it to avoid duplication. We also added a <code>right</code> function that calculates the right-hand side of <code>bounding_box</code> based on the current position. With that, RHB now runs to the right, forever! Well, until the buffer overflows and it crashes. Fortunately, we'll take care of that in the next section.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor144"/>Refactoring for endless running</h1>
			<p>By now, you've properly noticed a pattern. Every time we add a new feature, we start by refactoring the old code<a id="_idIndexMarker511"/> to make it easier to add it. This is generally a good practice in most forms of software development, and we'll be following that same pattern now. We identified a couple of code smells while creating the infinite background, so let's clean those up now, starting with dealing with all those casts.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor145"/>f32 versus i16</h2>
			<p>We had to cast values<a id="_idIndexMarker512"/> several times to go<a id="_idIndexMarker513"/> from <code>i16</code> to <code>f32</code> and back<a id="_idIndexMarker514"/> again. This isn't a safe operation; the maximum of <code>f32</code> is orders of magnitude larger than the maximum of <code>i16</code>, so there's the potential for our program to crash on a big <code>f32</code>. <code>HtmlImageElement</code> uses <code>u32</code> types, so all the casting to make the compiler shut up isn't even correct. We have two choices here:</p>
			<ul>
				<li>Take our data types (such as <code>Rect</code> and <code>Point</code>) and make them match <code>HtmlImageElement</code>.</li>
				<li>Set <code>Rect</code> and any other domain object to be our preferred, smaller, type and cast to the larger type on demand.</li>
			</ul>
			<p>I suppose we've been using the second choice so far – that is, cast at random to get the compiler to compile – but that's hardly ideal. While the first option is tempting as we won't have any casts, I prefer <code>Rect</code> and <code>Point</code> to be as small as possible, so we'll set those up to use <code>i16</code> as their values. This is more than large enough for any of our game objects, and the smaller size is potentially beneficial for performance.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The WebAssembly specification does not have an <code>i32</code> type, so an <code>i32</code> would be just as effective here. It also doesn't have an unsigned type, so it may be worth profiling to see which type is fastest. For our purposes, we'll go with the smallest reasonable size – <code>i16</code>. As a professor I once had would say, "We got to the moon on 16 bits!"</p>
			<p>To get started with this approach, change all the fields in <code>engine::Rect</code> to be <code>i16</code> instead of <code>f32</code>. Then, follow the compiler errors. Start by getting it to compile, casting <code>i16</code> to <code>f32</code> as necessary. After getting it to compile and run again, look for anywhere we can cast from <code>i16</code> to <code>f32</code>, and remove it if possible. This will include looking at the <code>Land</code> event in the <code>Event</code> enum, which holds an <code>f32</code>, and switching it to an <code>i16</code>. Finally, look for anywhere you cast to <code>i16</code>, and see whetherit's still necessary. It will end up being in a lot of places but it shouldn't be too painful; in the end, there should only be a few necessary<a id="_idIndexMarker515"/> casts <a id="_idIndexMarker516"/>left. Do this slowly and carefully so that <a id="_idIndexMarker517"/>you don't get stuck as you work through the errors.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor146"/>A more useful Rect</h2>
			<p>The <code>Rect</code> implementation<a id="_idIndexMarker518"/> only contains the <code>intersects</code> method, but there are two<a id="_idIndexMarker519"/> very useful methods it could use: <code>right</code> and <code>bottom</code>. If you look at the method we just wrote on <code>Image</code>, you will see that it's a natural fit for a <code>right</code> function. Let's go ahead and add it to <code>Rect</code>:</p>
			<pre>impl Rect {
    pub fn intersects(&amp;self, rect: &amp;Rect) -&gt; bool {
        self.x &lt; rect.right()
        &amp;&amp; self.right() &gt; rect.x
        &amp;&amp; self.y &lt; rect.bottom()
        &amp;&amp; self.bottom() &gt; rect.y
    }
    pub fn right(&amp;self) -&gt; i16 {
        self.x + self.width
    }
    pub fn bottom(&amp;self) -&gt; i16 {
        self.y + self.height
    }</pre>
			<p>Adding the <code>right</code> and <code>bottom</code> methods will prevent that addition logic from getting smeared across the game logic. We've also refactored <code>intersects</code> to use these new methods. Now, let's go back to the <code>Image</code> code we just wrote and update it to use the new <code>right</code> method, as shown here:</p>
			<pre>impl Image {
    ...
    pub fn right(&amp;self) -&gt; i16 {
    <a id="_idTextAnchor147"/>    self.bounding_box.right()
    }
}</pre>
			<p>While we're in <code>Image</code>, let's deal<a id="_idIndexMarker520"/> with the duplication<a id="_idIndexMarker521"/> of <code>position</code> and <code>bounding_box</code>.</p>
			<h3>Setting Rect's position</h3>
			<p>An image<a id="_idIndexMarker522"/> containing a bounding_box <code>Rect</code> and a position <code>Point</code> is an accident that occurred due to our code evolving. So, the question is, which one do we want to keep? We could always keep <code>bounding_box</code> for the image, which would mean constructing a <code>Point</code> every time we draw because we need that for the <code>draw_entire_element</code> call. We could also create a <code>Dimens</code> structure that just has <code>width</code> and <code>height</code>, and construct a <code>Rect</code> every time we need it on the update. While I doubt that the cost of creating those objects is going to be noticeable, the fact that it's on every frame is bothersome.</p>
			<p>What we'll do instead is give <code>Rect</code> a <code>position</code> field – after all, that's what the <code>x</code> and <code>y</code> coordinates of <code>Rect</code> are. This is a seemingly minor change but with far-reaching implications because we constantly initialize <code>Rect</code> with <code>x</code> and <code>y</code>. Fortunately, we can use the compiler to make this simpler for us. We'll start by changing <code>Rect</code> to hold a <code>position</code> field, instead of <code>x</code> and <code>y</code>:</p>
			<pre>pub struct Rect {
    pub position: Point,
    pub width: i16,
    pub height: i16,
}</pre>
			<p>Adding <code>position</code> is going to cause compiler errors all over the place, as expected. We know that we frequently want to both access the <code>x</code> and <code>y</code> values and create a <code>Rect</code> using <code>x</code> and <code>y</code>, so to make it easier to work with, we'll add two <code>factory</code> methods for <code>Rect</code>, as shown here:</p>
			<pre>impl Rect {
    pub fn new(position: Point, width: i16, height: i16) -&gt; 
     Self {
        Rect {
            position,
            width,
            height,
        }
    }
    pub fn new_from_x_y(x: i16, y: i16, width: i16, height: 
     i16) -&gt; Self {
        Rect::new(Point { x, y }, width, height)
    }
    ...</pre>
			<p>Now, when we fix <code>Rect</code> everywhere, we will stop<a id="_idIndexMarker523"/> creating a <code>Rect</code> directly and instead use the new constructor methods. We'll also add getters for <code>x</code> and <code>y</code> because we access those frequently, as shown here:</p>
			<pre>impl Rect {
    ...
    pub fn x(&amp;self) -&gt; i16 {
        self.position.x
    }
    pub fn y(&amp;self) -&gt; i16 {
        self.position.y
    }</pre>
			<p>This gives you most of the tools<a id="_idIndexMarker524"/> you will need to fix the compiler errors. I won't reproduce all of them, because there are quite a few and it's repetitive. There are two examples you can use to make take care of all but one error. The first is replacing every reference to <code>.x</code> or <code>.y</code> with references to the methods. </p>
			<p>This is how you do that in the <code>intersects</code> method of <code>Rect</code>:</p>
			<pre>impl Rect {
    ...
    pub fn intersects(&amp;self, rect: &amp;Rect) -&gt; bool {
        self.x() &lt; self.right()
        &amp;&amp; self.right() &gt; rect.x()
        &amp;&amp; self.y() &lt; rect.bottom()
        &amp;&amp; self.bottom() &gt; rect.y()
    }</pre>
			<p>As you can see, it's the same but with <code>x</code> and <code>y</code> replaced with <code>x()</code> and <code>y()</code>. In addition to seeing errors while accessing <code>x</code> or <code>y</code>, you'll see errors around creating <code>Rect</code> because the <code>position</code> field isn't specified. You'll want to replace creating <code>Rect</code> directly with using one of the constructor methods, as shown here in the implementation of <code>Image</code>:</p>
			<pre>impl Image {
     pub fn new(element: HtmlImageElement, position: Point) 
      -&gt; Self {
        let bounding_box = Rect::new(position, 
         element.width() as i16, element.height() as i16);
        ...</pre>
			<p>Taking care of those compiler errors, which will show up in both the <code>engine</code> and <code>game</code> modules, will leave you with only one remaining failure. This can be found in the <code>set_x</code> method of <code>Image</code>. This is because we need to set the <code>bounding_box.x</code> value. Rather than using <code>position.x</code>, which will compile but expose us to errors if the internals of <code>Rect</code> change again, we'll add a setter<a id="_idIndexMarker525"/> to the <code>Rect</code> implementation, as shown here:</p>
			<pre>impl Rect {
    ...
    pub fn set_x(&amp;mut self, x: i16) {
        self.position.x = x
    }
}</pre>
			<p>Now, in <code>Image</code>, we can fix the last compiler error by using <code>set_x</code>, as shown here:</p>
			<pre>impl Image {
    ...
    pub fn set_x(&amp;mut self, x: i16) {
        self.bounding_box.set_x(x);
        self.position.x = x;
    }</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have noticed that the code is inconsistent when it uses setters versus when it uses public variables directly. In general, my rule of thumb is that dumb structures such as <code>Rect</code> don't need setters and getters, especially if we keep them immutable. However, if the internal structure changes, which it did here, then it's time to add an abstraction to hide the internals. This change, from <code>x</code> and <code>y</code> to a position, demonstrated the necessity of the setter after all.</p>
			<p>At this point, you should see RHB running to the right and jumping on and off the platform again. Make sure you check out this behavior each time you get to a successful compile since it is easy to make a mistake as you make a large number of small changes.</p>
			<p>Now that we've prepared <code>Rect</code> to hold a <code>position</code>, we can remove the duplication of that data in <code>Image</code>. We'll start<a id="_idIndexMarker526"/> by removing <code>position</code> from the <code>Image</code> struct, as shown here:</p>
			<pre>pub struct Image {
    element: HtmlImageElement,
    bounding_box: Rect,
}</pre>
			<p>Now, let's follow the compiler and remove all references to <code>position</code> in the <code>Image</code> implementation. Fortunately, there are no longer any references to <code>position</code> outside of the <code>Image</code> implementation, so we can do this by making a few quick changes. These changes are shown here. Note how wherever we previously used <code>position</code>, we are now using <code>bounding_box.position</code> or <code>bounding_box.x()</code>:</p>
			<pre>impl Image {
    pub fn new(element: HtmlImageElement, position: Point) 
     -&gt; Self {
        let bounding_box = Rect::new(position, 
         element.width() as i16, element.height() as i16);
        Self {
            element,
            bounding_box,
        }
    }
    pub fn draw(&amp;self, renderer: &amp;Renderer) {
        renderer.draw_entire_image(&amp;self.element, 
         &amp;self.bounding_box<strong class="bold">.position</strong>)
    }
    pub fn bounding_box(&amp;self) -&gt;&amp;Rect {
        &amp;self.bounding_box
    }
    pub fn move_horizontally(&amp;mut self, distance: i16) {
        self.set_x(self.bounding_box<code>.x()</code> + distance);
    }
    pub fn set_x(&amp;mut self, x: i16) {
        self.bounding_box.set_x(x);
    }
    ...</pre>
			<p>Now that we've removed the duplication on <code>Image</code>, we're ready to get all of the obstacles in a level<a id="_idIndexMarker527"/> into one shared <code>trait</code> so that we can use them all in one list. Doing that will allow us to fix a bug that occurs when the buffer overflows due to running infinitely and prepare the code for dynamically <a id="_idTextAnchor148"/>adding many shared segments. Let's get to it!</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor149"/>Obstacle traits</h2>
			<p>Currently, the stone and the platform are separate objects on the <code>Walk</code> struct. If we want to add more obstacles<a id="_idIndexMarker528"/> to the game, we must add more fields to<a id="_idIndexMarker529"/> this struct. This is an issue if we want to have an endlessly generated list of things to jump over and slide under. What we'd like to do instead is keep a list of <code>Obstacles</code>, go through each one, and check what to do when <code>RedHatBoy</code> intersects them. Why do we want to do that? Let's have a look:</p>
			<ul>
				<li>It will eliminate the duplication for knocking out RHB, and eliminate <em class="italic">future</em> duplication that we'd have to create to continue with our current pattern.</li>
				<li>We want to treat each <code>Obstacle</code> as the same so that we can create obstacles on the fly.</li>
				<li>We'll be able to remove any obstacles that have gone off screen.</li>
			</ul>
			<p>We'll start by creating an <code>Obstacle</code> trait<a id="_idIndexMarker530"/> in the <code>game</code> module, with one new method<a id="_idIndexMarker531"/> named <code>check_intersection</code> and two that exist already on <code>Platform</code>:</p>
			<pre>pub trait Obstacle {
    fn check_intersection(&amp;self, boy: &amp;mut RedHatBoy);
    fn draw(&amp;self, renderer: &amp;Renderer);
    fn move_horizontally(&amp;mut self, x: i16);
}</pre>
			<p>Why these three methods? <code>stone</code> and <code>platform</code> are both going to implement <code>Obstacle</code>, and we'll need to loop through them, <code>draw</code> them, and move them. So, that's why the trait contains <code>move_horizontally</code> and <code>draw</code>. The new method, <code>check_intersection</code>, exists because a <code>platform</code> lets you land on it, whereas a <code>stone</code> doesn't. So, we'll need an abstraction that can handle intersections differently depending on the type of <code>Obstacle</code>. Now that we've created our <code>trait</code>, we can implement it on the <code>Platform</code> structure. We can start by pulling <code>draw</code> out of the <code>Platform</code> implementation and creating a <code>move_horizontally</code> method, as shown here:</p>
			<pre>impl Obstacle for Platform {
    fn draw(&amp;self, renderer: &amp;Renderer) {
    ...
    }
    fn move_horizontally(&amp;mut self, x: i16) {
        self.position.x += x;
    }
}</pre>
			<p>I've elided the implementation of <code>draw</code> here because this method does not change. Meanwhile, <code>move_horizontally</code> mimics the code<a id="_idIndexMarker532"/> that is currently in <code>update</code>, which we identified<a id="_idIndexMarker533"/> as a code smell earlier. </p>
			<p>Finally, let's add the <code>check_intersection</code> function, which currently exists in the <code>update</code> method of <code>WalkTheDog</code>:</p>
			<pre>for bounding_box in &amp;walk.platform.bounding_boxes() {
    if walk.boy.bounding_box().intersects(bounding_box) {
        if walk.boy.velocity_y() &gt; 0 &amp;&amp; walk.boy.pos_y() &lt; 
         walk.platform.position.y {
            walk.boy.land_on(bounding_box.y);
        } else {
            walk.boy.knock_out();
        }
    }
}</pre>
			<p>The version that's been implemented for <code>Platform</code> should be very similar, without the references to <code>walk</code>, as shown here:</p>
			<pre>impl Obstacle for Platform {
    ...
    fn check_intersection(&amp;self, boy: &amp;mut RedHatBoy) {
        if let Some(box_to_land_on) = self
            .bounding_boxes()
            .iter()
            .find(|&amp;bounding_box| boy.bounding_box()
             .intersects(bounding_box))
        {
            if boy.velocity_y() &gt; 0 &amp;&amp; boy.pos_y() &lt; 
             self.position.y {
                boy.land_on(box_to_land_on.y());
            } else {
                boy.knock_out();
            }
        }
    }
}</pre>
			<p>This code is largely the same but with one fairly significant optimization: instead of looping through every bounding<a id="_idIndexMarker534"/> box in <code>Platform</code>, this code uses <code>find</code> to get the first<a id="_idIndexMarker535"/> bounding box that's intersected. If there is one (<code>if let Some(box_to_land_on)</code>), then we handle the collision. This prevents redundant checks after a collision is found. The rest of the code is a little bit shorter without the references to <code>walk</code>, which is nice. Now, we need to replace <code>Platform</code> in <code>Walk</code> with a reference to it on the heap, like so:</p>
			<pre>struct Walk {
    boy: RedHatBoy,
    backgrounds: [Image; 2],
    stone: Image,
    <strong class="bold">platform: Box&lt;dyn Obstacle&gt;,</strong>
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">We do have an alternative to using a trait object here, which would be using<a id="_idIndexMarker536"/> an enum containing every type of obstacle, just like we did with our state machine. The tradeoff to using dynamic dispatch, via the <code>dyn</code> keyword, is that a lookup<a id="_idIndexMarker537"/> table is stored in memory. The benefit of this is that we write less boilerplate code, and the code doesn't need to be updated every time we add an obstacle. In this case, I think <code>trait</code> works better in the same way that an enum works better for a state machine, but it's worth keeping that in mind.</p>
			<p>This will cause two compiler<a id="_idIndexMarker538"/> errors that we can fix by making small<a id="_idIndexMarker539"/> changes. In the <code>initialize</code> method of <code>WalkTheDog</code>, we are not setting <code>platform</code> correctly when we create <code>Walk</code>, so let's make a small change, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    ...
                    <strong class="bold">platform: Box::new(platform)</strong>,
                })))
            }
            ...</pre>
			<p>This is only a one-line change that involves replacing <code>platform</code> with <code>platform: Box::new(platform)</code>. The other fix is something you'll remember being a smell – setting the position on <code>x</code> directly when <code>stone</code> uses a method called <code>move_horizontally</code>. This is why we created that method on the <code>Obstacle</code> trait on the <code>Platform</code> struct. This change can be found in the <code>update</code> function for <code>WalkTheDog</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            let velocity = walk.velocity();
            walk.platform.move_horizontally(velocity);
            <strong class="bold">walk.stone.move_horizontally(velocity);</strong></pre>
			<p>Having both <code>platform</code> and <code>stone</code> have a <code>move_horizontally</code> function is a sign that those interfaces<a id="_idIndexMarker540"/> can be brought together, which we'll do in a moment. Finally, we must<a id="_idIndexMarker541"/> replace the code that we moved into <code>check_intersection</code> with a call to that function. Just a little further down the <code>update</code> function, you'll want to update the following code:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            if second_background.right() &lt; 0 {
                second_background.set_x(
                 first_background.right());
            }
            <strong class="bold">walk.platform.check_intersection(&amp;mut </strong>
<strong class="bold">             walk.boy);</strong>
            if walk
                .boy
                .bounding_box()
                .intersects(walk.stone.bounding_box())
            {
                 walk.boy.knock_out()
            }</pre>
			<p>The call to <code>check_intersection</code> goes before the check to see whether you've crashed into a stone and after the background<a id="_idIndexMarker542"/> updates. You may notice that the code for checking<a id="_idIndexMarker543"/> for collisions with a stone is different, in the sense that <code>boy</code> is always knocked out when you collide with it, but is it also conceptually the same because you are, once again, checking for a collision with an obstacle and then doing something. This is why we need to turn <code>stone</code>, which is currently<a id="_idTextAnchor150"/> an <code>Image type</code>, into an <code>Obstacle</code> type. But what type should it be?</p>
			<h3>Barriers versus platforms</h3>
			<p>We need another type of <code>Obstacle</code> that cannot<a id="_idIndexMarker544"/> be landed on, and right<a id="_idIndexMarker545"/> now a <code>stone</code> is an <code>Image</code>. Adding features to <code>Image</code> isn't appropriate<a id="_idIndexMarker546"/> because an <code>Obstacle trait</code> is a <code>game</code> concept and <code>Image</code> is part of <code>engine</code>. Instead, we'll create a type of <code>Obstacle</code> that always causes the user to crash into it, called <code>Barrier</code>, and turn <code>stone</code> into that. It's a very dangerous stone.</p>
			<p>We'll start by creating a <code>Barrier</code> struct and implementing the <code>Obstacle</code> trait with placeholders, as shown here:</p>
			<pre>pub struct Barrier {
    image: Image,
}
impl Obstacle for Barrier {
    fn check_intersection(&amp;self, boy: &amp;mut RedHatBoy) {
        todo!()
    }
    fn draw(&amp;self, renderer: &amp;Renderer) {
        todo!()
    }
    fn move_horizontally(&amp;mut self, x: i16) {
        todo!()
    }
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">I generated this skeleton<a id="_idIndexMarker547"/> with <code>rust-analyzer</code> while using the <code>add-missing-members</code> action. In my<a id="_idIndexMarker548"/> editor (emacs), this is as simple as typing <code>c v</code>. In Visual Studio Code, simply click<a id="_idIndexMarker549"/> the lightbulb and choose <code>todo!</code> macro throws a runtime exception if this code is called without any implementation, and it is meant to signal temporary code that is there to please the compiler.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Right now, all <code>Barrier</code> objects have to be an <code>Image</code>, whereas a <code>Platform</code> uses a sprite sheet. You may want to use sprite sheets for everything, or even one sprite sheet for everything, and that's fine – better, even. We'll leave things as is here because we've redesigned this application enough already.</p>
			<p>Before we fill in all those <code>todo!</code> blocks, let's add a typical <code>new</code> method to create the <code>Barrier</code> object:</p>
			<pre>impl Barrier {
    pub fn new(image: Image) -&gt; Self {
        Barrier { image }
    }
}</pre>
			<p>Now, we can fill<a id="_idIndexMarker550"/> in the functions. The <code>draw</code> and <code>move_horizontally</code> functions<a id="_idIndexMarker551"/> can delegate to <code>Image</code>, as shown<a id="_idIndexMarker552"/> here:</p>
			<pre>impl Obstacle for Barrier {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        self.image.draw(renderer);
    }
    fn move_horizontally(&amp;mut self, x: i16) {
        self.image.move_horizontally(x);
    }
}</pre>
			<p>The final function, <code>check_intersection</code>, will be a little different. Unlike a <code>Platform</code>, which <code>boy</code> can land on, a <code>Barrier</code> is always crashed into. The code for this already exists in the <code>update</code> method of <code>WalkTheDog</code> because it's what we used for <code>stone</code>. Let's mimic that implementation here:</p>
			<pre>impl Obstacle for Barrier {
    ...
    fn check_intersection(&amp;self, boy: &amp;mut RedHatBoy) {
        if boy.bounding_box().intersects(
         self.image.bounding_box()) {
              boy.knock_out()
        }
    }
}</pre>
			<p><code>Barrier</code> isn't being used anywhere yet. So, we could start by changing <code>stone</code> from an <code>Image</code> into a <code>Barrier</code>. However, we're going<a id="_idIndexMarker553"/> to go a little further than that. We're going<a id="_idIndexMarker554"/> to create a list in <code>Walk</code> that contains <em class="italic">all</em> the <code>Obstacle</code> types. This will let<a id="_idIndexMarker555"/> us reduce the amount of specific code in <code>Walk</code>, and it will make it far simpler to generate new obstacles on the fly. Remember that's what we're refactoring for. Let's make our list and add it to the <code>Walk</code> struct, as shown here:</p>
			<pre>struct Walk {
    boy: RedHatBoy,
    backgrounds: [Image; 2],
    <strong class="bold">obstacles: Vec&lt;Box&lt;dyn Obstacle&gt;&gt;,</strong>
}</pre>
			<p>Note that we've removed <code>platform</code> and <code>stone</code> from <code>Walk</code>, we'll need to update the rest of its implementation and replace direct references to <code>stone</code> and <code>platform</code> with references to the <code>Obstacle</code> vector. This doesn't mean we won't ever mention <code>platform</code> and <code>stone</code> again; we still have to load the image and sprite sheet, but we'll only mention it once. Once again, we'll look at the compiler error messages, which are complaining a lot about the <code>initialize</code>, <code>update</code>, and <code>draw</code> methods in <code>WalkTheDog</code>. Let's start by making changes to the <code>initialize</code> function, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
                ...
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    ...
                    <strong class="bold">obstacles: vec![</strong>
                        <strong class="bold">Box::new(Barrier::new(Image::new(</strong>
<strong class="bold">                        stone, Point { x: 150, y: 546 }))),</strong>
                        <strong class="bold">Box::new(platform),</strong>
                    <strong class="bold">],</strong>
                })))
                ...</pre>
			<p>We're only changing the construction of the <code>Walk</code> construct, replacing the references to <code>stone</code> and <code>platform</code> by initializing the <code>obstacles</code> vector. The first item in the vector is now a <code>Barrier</code> but that's just the <code>stone</code> object that we created earlier wrapped in the new <code>Barrier</code> struct. The second<a id="_idIndexMarker556"/> is the <code>platform</code> object that we created previously. Everything<a id="_idIndexMarker557"/> has to be in a <code>Box</code> so that we can use the <code>Obstacle</code> trait. The next<a id="_idIndexMarker558"/> few changes we'll make must be done in the <code>update</code> method. We'll rearrange the code a little bit to update <code>boy</code> first, then our backgrounds, and finally our <code>obstacles</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            if second_background.right() &lt; 0 {
                second_background.set_x(
                 first_background.right());
            }
            <strong class="bold">walk.obstacles.iter_mut().for_each(|obstacle| {</strong>
                <strong class="bold">obstacle.move_horizontally(velocity);</strong>
                <strong class="bold">obstacle.check_intersection(&amp;mut walk.boy);</strong>
           <strong class="bold"> });</strong>
        }
    }
    ...</pre>
			<p>There should be no direct references to <code>stone</code> or <code>platform</code> in <code>update</code>. Now, the code for checking<a id="_idIndexMarker559"/> for the movement of obstacles and whether they intersect<a id="_idIndexMarker560"/> should only be four lines long and be at the bottom<a id="_idIndexMarker561"/> of the <code>update</code> method – and that's generously counting the closing brace. Make sure you use the <code>iter_mut</code> method since we are mutating <code>obstacle</code> in the loop. One of the ways we can tell that we are moving in the right direction in our design is that we're writing <em class="italic">less</em> code that works with <em class="italic">more</em> things. Finally, we will need to draw all our <code>obstacles</code>, which can be handled by updating the <code>draw</code> method, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        ...
        if let WalkTheDog::Loaded(walk) = self {
            ...
            walk.obstacles.iter().for_each(|obstacle| {
                obstacle.draw(renderer);
            });
        }
    }
}</pre>
			<p>In this case, we can use <code>for_each</code> and a plain <code>iter()</code>. As you may have guessed, when we want to add more obstacles<a id="_idIndexMarker562"/> to the screen, we will just add them to the <code>obstacles</code> list. At this point, the code should be working again; RHB should hop his way<a id="_idIndexMarker563"/> over a platform and a stone and then crash<a id="_idIndexMarker564"/> into it. Now, all we need to take ca<a id="_idTextAnchor151"/>re of is the crash that occurs if we let RHB keep running. We'll handle that next.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor152"/>Removing obstacles as they go off screen</h2>
			<p>If you let RHB run to the right<a id="_idIndexMarker565"/> for long enough, you'll see a crash<a id="_idIndexMarker566"/> message that looks like this:</p>
			<pre>panicked at 'attempt to add with overflow', src/engine.rs:289:20
Stack:</pre>
			<p>The preceding code is from the log in the browser. Here, the images move farther and farther to the left until they eventually reach the maximum length of the signed 16-bit integer. This is happening because we're never removing an obstacle from the obstacles Vec when they go off screen, and we should. Let's add a line of code to the <code>update</code> function that goes right before we move and collide with the obstacles, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            <strong class="bold">walk.obstacles.retain(|obstacle| </strong>
<strong class="bold">             obstacle.right() &gt; 0);</strong>
            walk.obstacles.iter_mut().for_each(|obstacle| {
                obstacle.move_horizontally(velocity);
                obstacle.check_intersection(&amp;mut walk.boy);
            });
            ...</pre>
			<p>The <code>retain</code> function will keep any <code>obstacles</code> that match the predicate that's been passed in. In this case, this will happen if the rightmost<a id="_idIndexMarker567"/> point of the obstacle is to the right of the left edge of the screen. This means<a id="_idIndexMarker568"/> we're looping through the list of obstacles twice. If we were using the nightly build of Rust, we could use the <code>drain_filter</code> function to avoid that, but our <code>obstacles</code> list should never be long enough for that to be an issue. For this code to compile, you'll need to add one more method to the <code>Obstacle</code> trait – the <code>right</code> method for the rightmost point of <code>Obstacle</code>. This can be seen in the following code:</p>
			<pre>trait Obstacle {
    ...
    fn right(&amp;self) -&gt; i16;
}</pre>
			<p>This method will need to be added to both the <code>Platform</code> and <code>Barrier</code> implementations of <code>Obstacle</code>. <code>Barrier</code> can just delegate to the image it's holding, <code>Platform</code> is a little trickier because it has more than one box. We want to use the right edge of the last bounding box, as shown here:</p>
			<pre>impl Obstacle for Platform {
    ...
    fn right(&amp;self) -&gt; i16 {
        self.bounding_boxes()
            .last()
            .unwrap_or(<strong class="bold">&amp;Rect::default()</strong>)
            .right()
    }
}</pre>
			<p>This code gets the last bounding box with <code>last</code> and unwraps it since <code>last</code> returns an <code>Option</code>. We don't want to return a <code>Result</code> and then force everybody to use a <code>Result</code>, so we are using <code>unwrap_or(&amp;Rect::default())</code> to return an empty <code>Rect</code> when <code>Platform</code> has no bounding boxes. One empty bounding box is effectively the same as no bounding boxes. Then, we get the rightmost value of the last <code>Rect</code> with <code>right</code>. </p>
			<p><code>Rect</code> doesn't have a default implementation yet, so we'll need to add a  <code>#[derive(Default)]</code> annotation to the <code>Rect</code> and <code>Point</code> structures in <code>engine</code>. The annotation automatically implements the <code>Default</code> trait for a <code>struct</code> by using the default value of every field in that <code>struct</code>. <code>Point</code> will need the annotation because it is in the <code>Rectstructure</code>, so for the macro to work for <code>Rect</code>, it must also work for <code>Point</code>. Fortunately, there's no real harm in adding this to them.</p>
			<p>With that, you can let RHB run<a id="_idIndexMarker569"/> for as long as he wants, with no buffer<a id="_idIndexMarker570"/> overflow. Now, we need to give RHB many platforms to jump on. W<a id="_idTextAnchor153"/>e will start by sharing the sprite sheet. Let's dig into this last piece of refactoring.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor154"/>Sharing a sprite sheet</h2>
			<p>Each <code>Platform</code> has a reference<a id="_idIndexMarker571"/> to an <code>Image</code> and a <code>Sheet</code> that we've casually been referring<a id="_idIndexMarker572"/> to as "the sprite sheet." When we start generating more <code>Platform</code> objects, we'll want to share a reference to the sheet. So, the time has come<a id="_idIndexMarker573"/> to add a <code>Sprit<a id="_idTextAnchor155"/>eSheetstruct</code> to our engine to enable that. Let's open the <code>engine</code> module and add that new concept.</p>
			<h3>Creating a sprite sheet</h3>
			<p>We will start by creating a <code>struct</code> that holds<a id="_idIndexMarker574"/> both <code>HtmlImageElement</code> and <code>Sheet</code> in the <code>engine</code> module:</p>
			<pre>pub struct SpriteSheet {
    sheet: Sheet,
    image: HtmlImageElement,
}</pre>
			<p>Now, let's create an implementation that will wrap the common behaviors of the sheet that we're using in <code>Platform</code>:</p>
			<pre>impl SpriteSheet {
    pub fn new(sheet: Sheet, image: HtmlImageElement) -&gt; 
     Self {
        SpriteSheet { sheet, image }
    }
    pub fn cell(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Cell&gt; {
        self.sheet.frames.get(name)
    }
    pub fn draw(&amp;self, renderer: &amp;Renderer, source: &amp;Rect, 
     destination: &amp;Rect) {
        renderer.draw_image(&amp;self.image, source, destination);
    }
}</pre>
			<p>I initially considered having <code>draw</code> take the name of the <code>cell</code> property we were drawing, but right now, our <code>Platform</code> draws more than one <code>cell</code> at a time, and we want to keep that functionality. Let's replace <code>HtmlImageElement</code> and <code>Sheet</code> in <code>Platform</code> with<a id="_idIndexMarker575"/> the <code>SpriteSheet</code> field, as shown here:</p>
			<pre>pub struct Platform {
    sheet: SpriteSheet,
    position: Point,
}</pre>
			<p>Don't forget to import <code>SpriteSheet</code> from the <code>engine</code> module. Now, you can follow the compiler to simplify <code>Platform</code> by removing references to <code>Sheet</code> and <code>HtmlImageElement</code> and just using <code>SpriteSheet</code>. In particular, you'll need to change the <code>new</code> function so that it takes one <code>SpriteSheet</code> instead of the two parameters. The following code shows how this can be initialized in the <code>initialize</code> method of <code>WalkTheDog</code>:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; 
    {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let platform = Platform::new(
                    SpriteSheet::new(
                        platform_sheet.into_serde::
                         &lt;Sheet&gt;()?,
                        engine::load_image(
                         "tiles.png").await?,
                    ),
                    Point { x: 200, y: 400 },
                );
                ...</pre>
			<p>The rest of <code>Platform</code> can be modified to fit the new interface. Note how you no longer need to say <code>frames</code> and can just call <code>sheet.cell</code>. The <code>draw</code> method will now delegate to <code>self.sheet.draw</code> and pass it the <code>renderer</code> instead of an <code>Image</code>. This structure is small and wouldn't be worth the effort if we didn't want to share the same <code>SpriteSheet</code> across multiple <code>Platform</code> objects. But we do want to share one <code>SpriteSheet</code>, instead<a id="_idTextAnchor156"/> of duplicating<a id="_idIndexMarker576"/> that memory everywhere. Due to this, we need to make it possible to share it.</p>
			<h3>Sharing a sprite sheet</h3>
			<p>To share <code>SpriteSheet</code> across more<a id="_idIndexMarker577"/> than one <code>Platform</code>, we'll need to store it somewhere that all of the platforms can point to, and designate something to be the owner of <code>SpriteSheet</code>. We could give <code>SpriteSheet</code> a <code>static</code> lifetime, and make it global, but that would mean making it an <code>Option</code> since it's not available until <code>initialize</code> is used. Instead, we'll store a reference-counted version of <code>SpriteSheet</code> in the <code>Walk</code> structure. This is a tradeoff since we'll be using reference counting instead of ownership to track when we should delete <code>SpriteSheet</code>, but in exchange, we'll only be duplicating the pointer in memory instead of an entire <code>SpriteSheet</code>.</p>
			<p>Let's add <code>obstacle_sheet</code> to the <code>Walk</code> struct, as shown here:</p>
			<pre>struct Walk {
    obstacle_sheet: Rc&lt;SpriteSheet&gt;,
    ...
}</pre>
			<p>You'll need to make sure you add <code>use std::rc::Rc</code> to the top of the <code>game</code> module. We'll also need to make sure that <code>Platform</code> can take a reference-counted <code>SpriteSheet</code> instead of taking ownership of <code>SpriteSheet</code>, as shown here:</p>
			<pre>pub struct Platform {
    sheet: Rc&lt;SpriteSheet&gt;,
    ...
}
impl Platform {
    pub fn new(sheet: Rc&lt;SpriteSheet&gt;, position: Point) -&gt; 
     Self {
        Platform { sheet, position }
    }
    ...</pre>
			<p>Here, we're replacing <code>SpriteSheet</code> with <code>Rc&lt;SpriteSheet&gt;</code>. This leaves us with one last modification we need<a id="_idIndexMarker578"/> to make – we must initialize the <code>Walk</code> struct and set up <code>obstacle_sheet</code> and the platform, as shown here:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; 
    {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let tiles = browser::fetch_json(
                 "tiles.json").await?;
                let sprite_sheet = 
                 Rc::new(SpriteSheet::new(
                    tiles.into_serde::&lt;Sheet&gt;()?,
                    engine::load_image("tiles.png").await?,
                ));
                let platform = Platform::new(
                    sprite_sheet.clone(),
                    Point {
                        x: FIRST_PLATFORM,
                        y: LOW_PLATFORM,
                    },
                );
                ...
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    ...
                    obstacles: vec![
                        Box::new(Barrier::new(Image::new(
                        stone, Point { x: 150, y: 546 }))),
                        Box::new(platform),
                    ],
                    <strong class="bold">obstacle_sheet: sprite_sheet</strong>,
                })))</pre>
			<p>Two sections change in <code>initialize</code>. First, after we call <code>fetch_json</code> to get <code>tiles.json</code>, we use that to create<a id="_idIndexMarker579"/> a reference-counted <code>SpriteSheet</code> named <code>sprite_sheet</code> with <code>Rc::new</code>. Note that we've replaced <code>let platform_sheet</code> with <code>let tiles</code> because that's a better name – it's loading <code>tiles.json</code> after all. Then, when we create <code>platform</code> with <code>Platform::new</code>, we pass it a clone of the created sprite <code>_sheet</code>. Previously, this was done inline, but we're going to need <code>sprite_sheet</code> again in a minute.</p>
			<p>Then, when we're creating the <code>Walk</code> struct, we need to pass that created sheet to the <code>obstacle_sheet</code> field. This doesn't need to be cloned because <code>Walk</code> is the ultimate owner of <code>sprite_sheet</code>, so <code>sprite_sheet</code> can be moved into it. This will increment the reference counter and will not clone the entire <code>SpriteSheet</code>. We will need to clone <code>obstacle_sheet</code> every time we create a <code>Platform</code> to ensure the references are counted correctly, but don't worry about this – the compiler will force us to do this.</p>
			<p>With that, we're now ready to reevaluate how our <code>Platform</code> object works. Currently, it can only create one <code>Platform</code>, but there's no reason it can't creat<a id="_idTextAnchor157"/>e many things the player can stand on. We'll want<a id="_idIndexMarker580"/> that as we generate levels. We'll do that next.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor158"/>Many different platforms</h2>
			<p>The current <code>Platform</code> struct assumes<a id="_idIndexMarker581"/> it's using the same three cells in the sprite sheet, including calculating the bounding boxes. So, to allow many kinds of platforms to be used, we'll need to pass in the cells we want to be rendered from the sheet, and we'll need to pass in custom bounding boxes for each potential <code>Platform</code>. For example, imagine that you wanted to take the provided tileset (<code>tiles.json</code>) and arrange them into a little cliff:</p>
			<div><div><img alt="Figure 6.4 – Look out below!&#13;&#10;" src="img/Figure_6.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Look out below!</p>
			<p>This would require passing the <code>11</code>, <code>2</code>, and <code>3</code> platform tiles. Those tiles aren't arranged horizontally or neatly, and the bounding boxes don't match our other platform. When we create this platform, we'll need to look up the tile dimensions in <code>tiles.json</code> and work out the bounding boxes from the provided dimensions manually. This means changing the way <code>Platform</code> works so that it's less specific.</p>
			<p>Let's start by changing the <code>Platform</code> struct so that it can hold the bounding boxes and a list of the sprites, as shown here:</p>
			<pre>pub struct Platform {
    sheet: Rc&lt;SpriteSheet&gt;,
    bounding_boxes: Vec&lt;Rect&gt;,
    sprites: Vec&lt;<strong class="bold">Cell</strong>&gt;,
    position: Point,
}</pre>
			<p>While we're changing <code>Platform</code> to make it less specific, we're also going to introduce an optimization: <code>Platform</code> will hold the sprite cells instead of looking them up every time they are drawn. There are two optimizations<a id="_idIndexMarker582"/> here because we are also storing the bounding boxes for <code>Platform</code> instead of calculating them every time they're created.</p>
			<p>This change will break pretty much everything in the implementation of <code>Platform</code>, most notably the <code>new</code> constructor, which will need to take a list of sprite names and bounding boxes and then convert the sprite names into cells, as shown here:</p>
			<pre>impl Platform {
    pub fn new(
        sheet: Rc&lt;SpriteSheet&gt;,
        position: Point,
        sprite_names: &amp;[&amp;str],
        bounding_boxes: &amp;[Rect],
    ) -&gt; Self {
        let sprites = sprite_names
            .iter()
            .filter_map(|sprite_name| 
             sheet.cell(sprite_name).cloned())
            .collect();
        ...</pre>
			<p>This isn't the entire <code>new</code> method, just the beginning. We started by changing the signature so that it takes four parameters. <code>sheet</code> and <code>position</code> were already there but the <code>new</code> method now takes a list of sprite names as a reference to an array of string slices. You can take a <code>Vec</code> of <code>String</code> objects, but it's a lot nicer to use the reference to string slices because it's much easier to call it. Clippy will also object to the code taking a <code>Vec&lt;String&gt;</code>, which we will cover in <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>.</p>
			<p>The first thing we do in the constructor <a id="_idIndexMarker583"/>is to use an iterator to look up every <code>Cell</code> in the sprite sheet via the <code>filter_map</code> call. We use <code>filter_map</code> instead of <code>map</code> because <code>sheet.cell</code> can return <code>None</code>, so we'll need to skip any invalid sprite names. <code>filter_map</code> combines <code>filter</code> and <code>map</code> to automatically reject any options that have a value of <code>None</code> but <code>map</code> the inner value if it is present. The <code>cloned</code> method on <code>Option</code> will return an <code>Option&lt;T&gt;</code> for any <code>Option&lt;&amp;T&gt;</code> by cloning the inner value. We use this to take ownership of the inner <code>Cell</code>. Let's continue with our constructor:</p>
			<pre>        ...
        let bounding_boxes = bounding_boxes
            .iter()
            .map(|bounding_box| {
                Rect::new_from_x_y(
                    bounding_box.x() + position.x,
                    bounding_box.y() + position.y,
                    bounding_box.width,
                    bounding_box.height,
                )
            })
            .collect();
        Platform {
            sheet,
            position,
            sprites,
            bounding_boxes,
        }
    }</pre>
			<p>We continue by taking the passed-in bounding<a id="_idIndexMarker584"/> boxes, which are of the <code>&amp;[Rect]</code> type, and converting them into a <code>Vec&lt;Rect&gt;</code> to be owned by the <code>Platform</code> struct. However, instead of just calling <code>collect</code> or <code>to_owned</code>, we take each <code>Rect</code> and adjust its <code>position</code> by the actual <code>position</code> of <code>Platform</code>. So, <code>bounding_boxes</code> will need to be passed in relative to its image, where the image starts at <code>(0,0)</code>. Imagine that the image you're drawing is positioned in the top-left corner. The bounding boxes are then "drawn" around them, skipping any transparency that's relative to the top-left corner. Then, everything is moved to the right spot in the game. That's the mental model I use to prevent confusion when I'm specifying the bounding boxes later.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Rust has some pretty good tools for functional-style programming, such as <code>filter</code> and <code>map</code>. It's worth getting to know them.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Having four parameters is a lot for a constructor, so you should probably consider replacing this code with the <code>Builder</code> pattern. We did not do this here because it would distract from the topic at hand, but it is a worthwhile code improvement. For an example of this, take a look at the unofficial <em class="italic">Rust Design Patterns</em> book here: <code>https://bit.ly/3GKxMld</code>.</p>
			<p>You'll also need to change the function for retrieving <code>bounding_boxes</code>, which gets a lot smaller:</p>
			<pre>impl Platform {
    ...
    fn bounding_boxes(&amp;self) -&gt; <strong class="bold">&amp;</strong>Vec&lt;Rect&gt; {
        &amp;self.bounding_boxes
    }
}</pre>
			<p>Well, that was a lot easier! Make sure you return a reference to <code>Vec</code> and not a <code>Vec</code>.instance We don't need to make<a id="_idIndexMarker585"/> any more calculations here; <code>Platform</code> is being passed its bounding boxes. The rest of the implementation for <code>Platform</code> won't be so easy, as we'll need to modify <code>move_horizontally</code> and <code>draw</code> to account for these changes. The change that needs to be made to <code>move_horizontally</code> is shown here:</p>
			<pre>impl Obstacle for Platform {
    ...
    fn move_horizontally(&amp;mut self, x: i16) {
        self.position.x += x;
        self.bounding_boxes.iter_mut()
         .for_each(|bounding_box| {
            bounding_box.set_x(bounding_box.position.x + 
             x);
        });
    }</pre>
			<p>The original code only moved position because <code>bounding_boxes</code> was calculated on demand. Now that <code>bounding_boxes</code> is stored on <code>Platform</code>, this needs to be adjusted every time we move <code>Platform</code>. Otherwise, you'll have images for <code>Platform</code> in one place, the bounding boxes in another, and very strange bugs. Ask me how I know.</p>
			<p>Finally, let's update the <code>draw</code> function for the new structure. Whereas the original implementation assumed that it was three cells wide and looked up each cell on each draw, the new implementation will loop through every cell and draw it individually. It will also need to account for the width of each cell. So, if the cells are <code>50</code> pixels wide, then the first cell<a id="_idIndexMarker586"/> will be positioned at <code>0</code>, the second at <code>50</code>, and so on:</p>
			<pre>impl Obstacle for Platform {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        let mut x = 0;
        self.sprites.iter().for_each(|sprite| {
            self.sheet.draw(
                renderer,
                &amp;Rect::new_from_x_y(
                    sprite.frame.x,
                    sprite.frame.y,
                    sprite.frame.w,
                    sprite.frame.h,
                ),
                // Just use position and the standard 
                   widths in the tileset
                &amp;Rect::new_from_x_y(
                    self.position.x + x,
                    self.position.y,
                    sprite.frame.w,
                    sprite.frame.h,
                ),
            );
            x += sprite.frame.w;
        });
    }</pre>
			<p>This isn't my favorite code<a id="_idIndexMarker587"/> in the world, but it gets the job done. It starts by creating a local, temporary <code>x</code> that will calculate the offset from <code>position</code> for each <code>Cell</code>. Then, it loops through the sprites, drawing each one but adjusting them for both <code>position</code> and <code>x</code>. Note how, in the destination <code>Rect</code>, we advance the <code>x</code> position with <code>self.position.x + x</code>. This ensures each <code>cell</code> is drawn to the right of the previous one. Finally, we calculate the next <code>x</code> position based on the width of <code>cell</code>. This implementation of <code>draw</code> does not use the <code>destination_box</code> method, which means nobody uses it, and you can safely delete it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This code assumes that <code>width</code> is variable but <code>height</code> is constant and that the sprites move from left to right. Here, a two-level platform would need to be constructed with two platforms.</p>
			<p><code>Platform</code> should now work with any list of sprites that we can construct it with. Now, all we need to do is initialize <code>Platform</code> properly in <code>WalkTheDog::initialize</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; 
    {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let platform = Platform::new(
                    sprite_sheet.clone(),
                    Point {
                        x: FIRST_PLATFORM,
                        y: LOW_PLATFORM,
                    },
                    &amp;["13.png", "14.png", "15.png"],
                    &amp;[
                        Rect::new_from_x_y(0, 0, 60, 54),
                        Rect::new_from_x_y(60, 0, 384 - (60 
                         * 2), 93),
                        Rect::new_from_x_y(384 - 60, 0, 60, 
                         54),
                    ],
                );
                ...</pre>
			<p>With that, <code>Platform</code> has been created with two more parameters – the list of tiles and the list of bounding boxes – making up<a id="_idIndexMarker588"/> the platform we've had all along. Notice that we can now pass in a simple array of strings for the names of the sprites. This is because we accept the <code>&amp;[&amp;str]</code> type as a parameter instead of a <code>Vec&lt;String&gt;</code>. You may be wondering where I got the three bounding box rectangles from. After all, previously, we were calculating them in the <code>bounding_boxes</code> method, using offsets. I simply looked in <code>tiles.json</code> and did the math, factoring in the offsets we used earlier. These are the same measurements as the bounding boxes were when we calculated them. You may also be wondering why these don't use constants, especially after I extolled the virtues of using constants in <a href="B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Collision Detection</em>. That's because we're going to create those in the next section.</p>
			<p>At this point, you should be back to where you started – with RHB waiting to jump over a rock. Now, we are ready to create a stream of dynamic segments. At the end of the next section, you'll<a id="_idIndexMarker589"/> have the constructs you will need for an endless runner.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor159"/>Creating a dynamic level</h1>
			<p>The initial screen we've been looking<a id="_idIndexMarker590"/> at for so long, with RHB jumping from a stone onto a platform, is what we're going to call a "segment." It's not a technical term, just a concept we've made up for the sake of generating them. As RHB moves to the right (that is, when all the obstacles move to the left), we'll generate new segments to the right, which is just off screen. We'll create these as segments so that we can control what is generated and how they fit together. Think of it like this: if we generated obstacles at random, then our platforms would look messy and would arrange themselves in an unbeatable fashion, like so:</p>
			<div><div><img alt="Figure 6.5 – A truly random level" src="img/Figure_6.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – A truly random level</p>
			<p>Instead, what we'll do is create a segment where the first one looks exactly like our one platform and one rock, and have them string together via a "timeline" value that's stored in <code>Walk</code>. This timeline will represent the right-hand side of the last segment in <code>x</code>. As that value gets closer to the edge of the screen, we'll generate another new segment and move the timeline back out. With this approach, RHB will be able to run for as long as we like, and we will have<a id="_idIndexMarker591"/> the freedom of a level designer. We will be able to create segments that are both easy and <a id="_idTextAnchor160"/>hard to navigate, though we'll need to make sure they all interlock and can be beaten. This is the fun part!</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor161"/>Creating one segment</h2>
			<p>We'll start by taking the introductory screen<a id="_idIndexMarker592"/> and creating it as a segment. Let's do this by creating<a id="_idIndexMarker593"/> a new file called <code>segments.rs</code>, making sure to add <code>mod segments</code> to the <code>lib.rs</code> file. This module isn't created for the typical software design reasons; usually, it's because <code>game.rs</code> is getting pretty long and these segments are closer to being levels than they are true code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember that <code>game.rs</code> can be broken down into a module with separate files using a directory with a <code>mod.rs</code> file. We're not doing this here because I find it gets harder to explain where new code goes – at least in book form – when we have a large number of files. If you are comfortable with doing this, then feel free to break this down into smaller chunks.</p>
			<p>Each segment will be a function that returns a list of obstacles. Let's create a public function in <code>segments.rs</code> that returns the same list that the game is initialized with:</p>
			<pre>pub fn stone_and_platform(
    stone: HtmlImageElement,
    sprite_sheet: Rc&lt;SpriteSheet&gt;,
    offset_x: i16,
) -&gt; Vec&lt;Box&lt;dyn Obstacle&gt;&gt; {
    const INITIAL_STONE_OFFSET: i16 = 150;
    vec![
        Box::new(Barrier::new(Image::new(
            stone,
            Point {
                x: offset_x + INITIAL_STONE_OFFSET,
                y: STONE_ON_GROUND,
            },
        ))),
        Box::new(<strong class="bold">create_floating_platform</strong>(
            sprite_sheet,
            Point {
                x: offset_x + FIRST_PLATFORM,
                y: LOW_PLATFORM,
            },
        )),
    ]
}</pre>
			<p>Look, constants! We want the segments<a id="_idIndexMarker594"/> module to look as data-driven as possible, so we'll be using<a id="_idIndexMarker595"/> constants throughout this file. This section of code doesn't compile because the <code>create_floating_platform</code> function doesn't exist yet, but it does the same things that the corresponding code in the <code>initialize</code> method of <code>WalkTheDog</code> does. The only differences are that it uses the <code>create_floating_platform</code> function, which doesn't exist, and some constants that also do not exist.</p>
			<p>The function itself takes <code>HtmlImageElement</code> from <code>stone</code> and <code>Rc&lt;SpriteSheet&gt;</code> to create <code>Barrier</code> and <code>Platform</code>, respectively, but it also takes an <code>offset_x value</code>. That's because while the first <code>Barrier</code> and <code>Platform</code> may be at <code>150</code> and <code>200</code>, respectively, in the future, we'll want those to be that many pixels away from the timeline. It returns a vector of obstacles, which we can use in the <code>initialize</code> method of <code>WalkTheDog</code> and anywhere else that we generate segments.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">You may have noticed that we used an <code>Rc</code> for <code>SpriteSheet</code> but just take ownership of <code>HtmlImageElement</code>, which may need to be cloned when it's called. Nice catch! You may wish to consider making <code>HtmlImageElement</code> an <code>Rc</code> as well. <code>HtmlImageElement</code> is small enough that it's probably fine if we clone it, but it may be worth investigating in <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>.</p>
			<p>Let's continue by creating<a id="_idIndexMarker596"/> the function<a id="_idIndexMarker597"/> that's missing – that is, <code>create_floating_platform</code>: </p>
			<pre>fn create_floating_platform(sprite_sheet: Rc&lt;SpriteSheet&gt;, position: Point) -&gt; Platform {
    Platform::new(
        sprite_sheet,
        position,
        &amp;FLOATING_PLATFORM_SPRITES,
        &amp;FLOATING_PLATFORM_BOUNDING_BOXES,
    )
}</pre>
			<p>This is a pretty small function in that it just delegates to the <code>Platform</code> constructor and passes along important information. As you can see, there are two new constants to go along with the others in <code>stone_and_platform</code>. I told you that the constants would come back!</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to use <code>Rect::new_from_x_y</code> when you're declaring <code>FLOATING_PLATFORM_BOUNDING_BOXES</code>, you'll need to declare it and <code>Rect::new</code> as <code>pub const fn</code>.</p>
			<p>The rest of the segments<a id="_idIndexMarker598"/> module consists of constants and <code>use</code> statements. You can infer<a id="_idIndexMarker599"/> the values for all the constants from the code we used earlier, or just check out <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs</a>. Reproducing that code here would amount to padding. By putting all the values in constants, the code looks increasingly data-driven, with functions just returning the data we want for every segment.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It's possible to serialize these segments into JSON using <code>serde</code> and then read them in from JSON files instead of having the levels be written in Rust code. This is an experiment that you can undertake; I prefer the Rust code version.</p>
			<p>Once you've filled in the constants and the <code>use</code> statements, you can use the new <code>stone_and_platform</code> function in the <code>initialize</code> method of <code>WalkTheDog</code>. Yeah, that one again. Let's replace the hardcoded list of obstacles with a call to this new function:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; 
    {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    ...
                    <strong class="bold">obstacles: stone_and_platform(stone, </strong>
<strong class="bold">                    sprite_sheet.clone(), 0),</strong>
                    obstacle_sheet: sprite_sheet,
                })))</pre>
			<p>Make sure you import <code>stone_and_platform</code> from <code>segments</code>! Now that we've got a function to create<a id="_idIndexMarker600"/> the initial scene, we can add a timeline and start generating scenes<a id="_idIndexMarker601"/> again and again. Let's get started.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You may have noticed that this puts a circular dependency between <code>segments</code> and <code>game</code>. You're right. To fix this, take anything that <code>segments</code> depends on that is in <code>game</code> and put it in another module that both <code>game</code> and <code>segments</code> depend on. This has been left as an exercise for you.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor162"/>Adding a timeline </h2>
			<p>We need to initialize the timeline<a id="_idIndexMarker602"/> at the width of a segment. We can calculate this by finding<a id="_idIndexMarker603"/> the right-most point in the list of obstacles, and we'll use those cool functional constructs we used earlier. This will be a standalone function that we can keep in the <code>game</code> module, which looks like this:</p>
			<pre>fn rightmost(obstacle_list: &amp;Vec&lt;Box&lt;dyn Obstacle&gt;&gt;) -&gt; i16 {
    obstacle_list
        .iter()
        .map(|obstacle| obstacle.right())
        .max_by(|x, y| x.cmp(&amp;y))
        .unwrap_or(0)
}</pre>
			<p>This function goes through a <code>vec</code> of <code>Obstacle</code> and gets its <code>right</code> value. Then, it uses the <code>max_by</code> function<a id="_idIndexMarker604"/> to figure out the maximum<a id="_idIndexMarker605"/> value on the right. Finally, it uses <code>unwrap_or</code> because while <code>max_by</code> can technically return <code>None</code>, if it does that here, then we have completely screwed up and may as well shove all the graphics onto the leftmost part of the screen. Now that we have this function, we can add a <code>timeline</code> value to the <code>Walk</code> struct, as shown here:</p>
			<pre>struct Walk {
    ...
    stone: HtmlImageElement,
    timeline: i16,
}</pre>
			<p>We also added a reference to <code>HtmlImageElement</code> because we'll need that later. We will now initialize <code>Walk</code> – yes, we're back in that function again – with <code>stone</code> and <code>timeline</code>. We'll have to tweak the code slightly to deal with the borrow checker:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; 
    {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let starting_obstacles = stone_and_platform
                 (stone.clone(), sprite_sheet.clone(), 0);
                let timeline = rightmost(
                 &amp;starting_obstacles);
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    ...
                    obstacles: starting_obstacles,
                    obstacle_sheet: sprite_sheet,
                    stone,
                    timeline,
                })))
            }</pre>
			<p>Here, we bind <code>starting_obstacles</code> and <code>timeline</code> before we initialize <code>Walk</code> since we wouldn't be able to get <code>timeline</code> as we've moved <code>obstacles</code> already. Note how<a id="_idIndexMarker606"/> we now clone <code>stone</code> when we pass it into <code>stone_and_platform</code>. We'll need to do<a id="_idIndexMarker607"/> this from now on because each <code>Barrier</code> obstacle owns an <code>Image</code> and, ultimately, its <code>HtmlImageElement</code>. Finally, we pass <code>stone</code> and <code>timeline</code> into the <code>Walk</code> struct. Now that we have a <code>timeline field</code> we can update it, by moving the rightmost edge of the generated obstacles to the left on each update, and respond to it by generating more obstacles as necessary. Our <code>Canvas</code> is still <code>600</code> pixels wide, so let's say that if there are no obstacles at the rightmost point past <code>1000</code>, we need to generate more.</p>
			<p>These changes belong in the <code>update</code> method of <code>WalkTheDog</code>, at the end of the update logic:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            walk.obstacles.iter_mut().for_each(|obstacle| {
                obstacle.move_horizontally(velocity);
                obstacle.check_intersection(&amp;mut walk.boy);
            });
            if walk.timeline &lt; TIMELINE_MINIMUM {
                let mut next_obstacles = 
                 stone_and_platform(
                    walk.stone.clone(),
                    walk.obstacle_sheet.clone(),
                    walk.timeline + OBSTACLE_BUFFER,
                );
                walk.timeline = rightmost(&amp;next_obstacles);
                walk.obstacles.append(&amp;mut next_obstacles);
            } else {
                walk.timeline += velocity;
            }
        }</pre>
			<p>After moving the obstacles, we check whether <code>walk.timeline</code> is <code>&lt; TIMELINE_MINIMUM</code>, which is set to <code>1000</code> at the top<a id="_idIndexMarker608"/> of the module. If it is, we create<a id="_idIndexMarker609"/> another <code>stone_and_platform</code> segment at <code>walk.timeline + OBSTACLE_BUFFER</code>, which is another constant that's set to <code>20</code>. Why <code>20</code>? We needed a little buffer to make sure the segments weren't right on top of each other, and <code>20</code> seemed fine. You could use a larger number or none at all. Then, we update <code>walk.timeline</code> to the <code>rightmost</code> point of the new obstacles, and we append those obstacles to the list, ready to be drawn.</p>
			<p>If <code>walk.timeline</code> is beyond <code>TIMELINE_MINIMUM</code>, we simply decrease it by RHB's walking speed until the next update. Upon adding this code, you should see something similar to the following:</p>
			<div><div><img alt="Figure 6.6 – As one platform ends, another beckons" src="img/Figure_6.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – As one platform ends, another beckons</p>
			<p>That's right – you have an endless<a id="_idIndexMarker610"/> runner! So, how come we're only halfway through this book? Well, our runner<a id="_idIndexMarker611"/> is a little dull, seeing as it only has the same two objects over and over again. How about we add some randomness and creativity with multiple segments?</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor163"/>Creating segments </h2>
			<p>Creating random segments<a id="_idIndexMarker612"/> means using the random library<a id="_idIndexMarker613"/> to choose a different segment each time one is needed. Let's start by extracting the code we wrote previously into a function, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            if walk.timeline &lt; TIMELINE_MINIMUM {
                walk.generate_next_segment()
            } else {
                walk.timeline += velocity;
            }
        }
        ...
    }
}
impl Walk {
    ...
    fn generate_next_segment(&amp;mut self) {
        let mut next_obstacles = stone_and_platform(
            self.stone.clone(),
            self.obstacle_sheet.clone(),
            self.timeline + OBSTACLE_BUFFER,
        );
        self.timeline = rightmost(&amp;next_obstacles);
        self.obstacles.append(&amp;mut next_obstacles);
    }
}</pre>
			<p class="callout-heading">Information</p>
			<p class="callout"><code>WalkTheDog</code> has a bad case of <code>WalkTheDog</code> and into <code>Walk</code>.</p>
			<p>Now that <code>Walk</code> can generate<a id="_idIndexMarker615"/> the next segment, we'll use the <code>random</code> crate<a id="_idIndexMarker616"/> from <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, to choose the next segment. Of course, we only have one segment, so that won't mean much. It looks like this:</p>
			<pre>impl Walk {
    ...
    fn generate_next_segment(&amp;mut self) {
        let mut rng = thread_rng();
        let next_segment = rng.gen_range(0..1);
        let mut next_obstacles = match next_segment {
            0 =&gt; stone_and_platform(
                self.stone.clone(),
                self.obstacle_sheet.clone(),
                self.timeline + OBSTACLE_BUFFER,
            ),
            _ =&gt;vec![],
        };
        self.timeline = rightmost(&amp;next_obstacles);
        self.obstacles.append(&amp;mut next_obstacles);
    }
}</pre>
			<p>Don't forget to add <code>use rand::prelude::*;</code> at the top of the file. This generates a random number between <code>0</code> and, well, <code>0</code>. Then, it matches that value and generates the selected<a id="_idIndexMarker617"/> segment, which in this case will always be <code>stone_and_platform</code>. There's a default<a id="_idIndexMarker618"/> case here, but that's just to quiet the compiler – it can't happen. I'll create a second segment called <code>platform_and_stone</code> that is the same as the first one except it flips the position of <code>stone</code> and <code>platform</code>, and then puts the platform higher by using the <code>HIGH_PLATFORM</code> constant we created earlier. Now, the <code>generate_next_segment</code> function looks like this:</p>
			<pre>impl Walk {
    ...
    fn generate_next_segment(&amp;mut self) {
        let mut rng = thread_rng();
        let next_segment = rng.gen_range(0..<strong class="bold">2</strong>);
        let mut next_obstacles = match next_segment {
            0 =&gt; stone_and_platform(
                self.stone.clone(),
                self.obstacle_sheet.clone(),
                self.timeline + OBSTACLE_BUFFER,
            ),
            1 =&gt; platform_and_stone(
                self.stone.clone(),
                self.obstacle_sheet.clone(),
                self.timeline + OBSTACLE_BUFFER,
            ),
            _ =&gt;vec![],
        };
        self.timeline = rightmost(&amp;next_obstacles);
        self.obstacles.append(&amp;mut next_obstacles);
    }
}</pre>
			<p>Here, you can see that I get two segments, both of which are called<a id="_idIndexMarker619"/> in the same way. Make sure <code>gen_range</code> now generates a number from <code>0</code> to <code>2</code>. Upon running<a id="_idIndexMarker620"/> this code, I get to see a new segment:</p>
			<div><div><img alt="Figure 6.7 – Who moved that rock?" src="img/Figure_6.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Who moved that rock?</p>
			<p>If you try to copy/paste the preceding code, it won't work since you don't have <code>platform_and_stone</code>. This hasn't been included here because you have all the knowledge you need to create your <em class="italic">own</em> segments. You can start by copying/pasting <code>stone_and_platform</code> and tweaking its values. Then, you can try creating platforms with the sprite sheet. Remember that you're not limited to just the three images in our sprite sheet. The entire sheet looks like this:</p>
			<div><div><img alt="Figure 6.8 – The sprite sheet" src="img/Figure_6.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The sprite sheet</p>
			<p>You can use this to make larger <a id="_idIndexMarker621"/>platforms, steps, and even cliffs. Try making<a id="_idIndexMarker622"/> a few different shapes. Try making smaller platforms by skipping the middle tile in the platform we've been using. RHB can slide; can you make something for him to slide under?</p>
			<p>For a real challenge, take a look at the water sprites. Currently, RHB can't fall through the ground sinc<a id="_idTextAnchor164"/>e we're using a <code>FLOOR</code> variable, but what if we didn't? Could RHB drown? Fall off a cliff, perhaps? It's time to become a game designer!</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor165"/>Summary</h1>
			<p>It's time for a confession. If you're like me, a programmer, that means you're probably sitting in a room with a bunch of books like this one behind you. Of those books, you've probably only opened half of them, and you've probably only read one or two of them cover-to-cover. Harry Potter notwithstanding.</p>
			<p>Great news! At this point, you've made an endless runner. It's got no sound, the collision boxes are pretty big (have you tried to go under a platform yet?), and there's no menu system, but at this point, you have a game. You have the skeleton to make it more fun as you play around, and you're welcome to use this to make even larger or completely different endless runners. I wouldn't hold it against you if you stopped following along at this point, because you've learned a ton.</p>
			<p>But if you do decide to stick around for the next chapter, we'll be adding a requirement for immersion that's required for any game – <em class="italic">sound</em>. Don't you want to hear what RHB sounds like?</p>
		</div>
		<div><div></div>
		</div>
	</body></html>