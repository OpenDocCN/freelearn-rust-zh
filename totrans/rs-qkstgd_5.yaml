- en: One Data Type Representing Multiple Kinds of Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种数据类型表示多种数据类型
- en: 'Sometimes, a data value might need to be one of multiple different data types.
    Rust has three ways of addressing that situation without breaking strict type
    safety: enumerations, trait objects, and `Any`. Each approach has strengths and
    weaknesses, so we''ll examine them all and talk about when each is appropriate.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个数据值可能需要是多种不同数据类型之一。Rust 有三种方法来处理这种情况，同时不破坏严格的类型安全：枚举、特质对象和 `Any`。每种方法都有其优点和缺点，所以我们将逐一检查它们，并讨论何时适用。
- en: 'In this chapter, we''re going to learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What an enumeration is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举是什么
- en: How to create an enumeration type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建枚举类型
- en: How to create enumeration values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建枚举值
- en: How to use the information stored in an enumeration value
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用枚举值中存储的信息
- en: What a trait and a trait object are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特质和特质对象是什么
- en: How to create a trait
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个特质
- en: How to create a trait object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个特质对象
- en: How to use a trait object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用特质对象
- en: What `Any` is
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any` 是什么'
- en: How to use `Any`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `Any`
- en: What enumerations are good for, what trait objects are good for, and what `Any`
    is good for
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举有什么好处，特质对象有什么好处，`Any` 有什么好处
- en: Enumerations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Like structures, enumerations allow us to establish a new data type. The content
    is different from a structure, though. When we say that the data type of a variable
    is an enumeration, we're telling Rust that its contained value is required to
    be one of the specific choices we've described for that enumeration and can't
    be anything else.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构体类似，枚举允许我们建立一个新的数据类型。尽管内容与结构体不同。当我们说一个变量的数据类型是枚举时，我们是在告诉 Rust，其包含的值必须是我们为该枚举描述的特定选择之一，不能是其他任何东西。
- en: Basic enumerations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本枚举
- en: 'In Rust, an enumeration is a data type representing one of a fixed set of values.
    For example, we could define an enumeration of the commonly recognized seven colors
    of the rainbow, as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，枚举是一种表示一组固定值之一的 数据类型。例如，我们可以定义一个表示彩虹中常见的七种颜色的枚举，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we define this enumeration, we can use `Color` as a data type and `Color::Red` or
    the like as data values of that type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这个枚举，我们就可以使用 `Color` 作为数据类型，以及 `Color::Red` 等类似的数据值：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An enumeration is created with the `enum` keyword. Notice that, like a structure,
    an enumeration needs the `pub` keyword if we want it to be directly accessible
    outside the current module. Between the `{` and `}`, we have the list of possible
    values for the data type, listed by name and separated by commas.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是通过 `enum` 关键字创建的。注意，就像结构体一样，如果我们想让枚举在当前模块外部直接可访问，它需要 `pub` 关键字。在 `{` 和 `}`
    之间，我们有数据类型的可能值列表，按名称列出，并用逗号分隔。
- en: Rust is somewhat opinionated about capitalization, so it will warn us if any
    of the enumeration values start with a lowercase letter, though that is not actually
    an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 对大小写有些意见，所以如果枚举值以小写字母开头，它会警告我们，尽管这实际上不是一个错误。
- en: Parameterized enumerations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化枚举
- en: 'Okay, so what do enumerations have to do with representing different kinds
    of data in one variable? Well, there''s one more feature that enumeration values
    can have that changes everything: parameters.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么枚举与在一个变量中表示不同类型的数据有什么关系呢？嗯，枚举值还有一个可以改变一切的特性：参数。
- en: 'Imagine we wanted to create a representation of a sequence of driving directions,
    such as *turn right*, *forward three blocks*, or *stop.* This example is simple
    enough that we could probably get by with a simple enumeration, but even this
    will be easier with parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一系列驾驶方向的表示，例如 *向右转*，*向前行驶三个街区*，或 *停车*。这个例子足够简单，我们可能可以用简单的枚举就能应付，但即使这样，使用参数也会更容易：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we have here is an enumeration with parameterized values. The `Forward`
    value has a `u8` parameter (unsigned 8 bit integer) , while the `Turn` value has
    two `bool` parameters with names. `Stop` doesn't need any parameters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个具有参数化值的枚举。`Forward` 值有一个 `u8` 参数（无符号 8 位整数），而 `Turn` 值有两个带有名称的 `bool`
    参数。`Stop` 不需要任何参数。
- en: Essentially, the `Forward` value carries a 1-tuple along with it, while the
    `Turn` value carries along a structure with two members. That's why parentheses
    are used around the `Forward` parameter and braces are used around the `Turn` parameters.
    Whether we want the parameters to be tuple-like or structure-like is our decision
    to make. Either way, we can have as many or as few parameters as we need.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Forward`值携带一个1元组，而`Turn`值携带一个具有两个成员的结构。这就是为什么在`Forward`参数周围使用括号，而在`Turn`参数周围使用花括号的原因。我们是否希望参数是类似元组或类似结构的是我们的决定。无论如何，我们可以根据需要添加或删除参数。
- en: Now, we can create a variable of the `Drive` type, and it might contain a `Forward`, `Turn`,
    or `Stop` parameter. If it's a `Forward` parameter, that means the variable also
    contains a `u8` number telling us how far to drive. If it's a `Turn` parameter,
    that means the variable also contains a pair of Boolean values that tell us whether
    to turn right or left, and whether or not the turn is slight. In other words,
    the variable might contain any one of several different kinds of information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`Drive`类型的变量，它可能包含一个`Forward`、`Turn`或`Stop`参数。如果是一个`Forward`参数，这意味着该变量还包含一个`u8`数字，告诉我们需要驾驶多远。如果是一个`Turn`参数，这意味着该变量还包含一对布尔值，告诉我们是否向右或向左转弯，以及转弯是否轻微。换句话说，该变量可能包含几种不同类型的信息之一。
- en: If you're familiar with C++, or a similar language, keep in mind that Rust enumerations
    are not very much like C++ enumerations. A Rust enumeration with parameterized
    values is more like a C++ union, except it's type checked and safe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C++或类似的语言，请注意，Rust枚举与C++枚举不太一样。带有参数值的Rust枚举更像是一个C++联合体，但它进行了类型检查并且是安全的。
- en: 'Better still, we can create an array of driving instructions, to represent
    a complete journey:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以创建一个包含驾驶指令的数组，以表示一次完整的旅程：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This array of `Drive` values represents driving forward three blocks, turning
    right, driving forward one more block, and stopping.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Drive`值数组表示向前驾驶三个街区，向右转，再向前驾驶一个街区，然后停止。
- en: Checking the value type and extracting parameter values
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查值类型和提取参数值
- en: 'When the program runs, it can take different actions depending on the specific
    enumeration type it''s looking at, and it has access to the data values that were
    stored as parameters. We''ve already seen the best tool for doing that, `match`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它可以根据它正在查看的具体枚举类型采取不同的行动，并且它可以访问存储为参数的数据值。我们已经看到了完成这项工作的最佳工具，即`match`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have a `for` loop that processes each item in our array of directions,
    one at a time, starting with the first one. Step by step, here''s what is going
    on:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`for`循环，它逐个处理方向数组中的每个项目，从第一个开始。一步一步地，以下是正在发生的事情：
- en: We asked `directions` to provide us with an iterator, which it's happy to do.
    The iterator will give us a borrow of each value contained in the array, one at
    a time.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要求`directions`提供一个迭代器，它很乐意这样做。迭代器将逐个提供数组中每个值的借用。
- en: The `for` loop requests a value from the iterator, and assigns the returned
    borrow to a variable called `step`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`循环从迭代器请求一个值，并将返回的借用分配给名为`step`的变量。'
- en: 'The match expression uses the `step` variable to provide the value that it
    will match against. Because that variable changes each time the loop goes through,
    the match expression compares against a different value each time:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配表达式使用`step`变量来提供它将与之匹配的值。因为这个变量每次循环都会改变，所以匹配表达式每次都会与不同的值进行比较：
- en: If the `step` variable contains (a borrow of) `Drive::Forward`, its parameter
    is assigned to the variable named `blocks`. Because `step` *is* a borrow, the
    value in `blocks` is a borrow as well, but, in this instance that doesn't make
    a significant difference. We pass it on to `println!`, which calls a function
    on it to turn it into a text string, which in turn, dereferences it automatically.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`step`变量包含`Drive::Forward`的借用，其参数将被分配给名为`blocks`的变量。因为`step`是一个借用，所以`blocks`中的值也是一个借用，但在这个例子中这并没有造成重大差异。我们将其传递给`println!`，它调用一个函数将其转换为文本字符串，然后自动解引用。
- en: If the `step` variable contains (a borrow of) `Drive::Turn`, borrows of its
    parameters are assigned to the `slight` and `right` names, and we can use the
    shorthand notation we've seen before for that because `slight` and `right` are
    the names of the variables in both the source and the destination. Then comes
    a print command, but we're using `if` expressions to decide exactly what to print.
    Notice that we have explicitly dereferenced the `slight` and `right` values; they
    *are* borrows and, unlike when we call functions, `if` expressions don't automatically
    dereference for us, so we need to do it ourselves.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`step`变量包含（对`Drive::Turn`的借用），则其参数的借用被分配给`slight`和`right`名称，并且我们可以使用之前看到的简写符号，因为`slight`和`right`是源和目标中变量的名称。然后是一个打印命令，但我们使用`if`表达式来决定打印什么。注意，我们明确地解引用了`slight`和`right`值；它们是借用，并且与调用函数不同，`if`表达式不会自动为我们解引用，所以我们需要自己来做。
- en: If the `step` variable contains (a borrow of) `Drive::Stop`, there are no parameters
    to deal with and we just print out a message.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`step`变量包含（对`Drive::Stop`的借用），则没有要处理的参数，我们只需打印一条消息。
- en: If there are any values left in the iterator, got back to step 2.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果迭代器中还有任何值，则回到步骤2。
- en: Pretty cool. We've got some code here that does something kind of real. That's
    when the fun really starts!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷。我们这里有一些做些实际事情的代码。那时真正的乐趣才真正开始！
- en: Result is an enumeration, accessed via the prelude
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果是一个枚举，通过前缀访问
- en: You may have noticed already, but the `Result` type with its `Ok` and `Err`
    values looks an awful lot like an enumeration. That's because it is an enumeration,
    which is how it's able to contain different data types depending on whether it
    represents an error or a success. It's an enumeration with generic type parameters,
    so we won't be able to pull off quite the same functionality until we learn about
    those but, at its base, it's still just an enumeration.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，但带有`Ok`和`Err`值的`Result`类型看起来非常像枚举。这是因为它确实是一个枚举，这就是它能够根据它表示错误还是成功来包含不同数据类型的原因。它是一个具有泛型类型参数的枚举，所以在我们了解那些之前，我们无法实现完全相同的功能，但在其基础上，它仍然只是一个枚举。
- en: We can use `Ok` and `Err` instead of `Result::Ok` and `Result::Err` when we
    write functions that might fail or handle the results of such functions, because
    those values are added directly to the Rust *prelude* for our convenience. Actually,
    we can use the `Result` type without saying where it came from for the same reason.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写可能失败或处理此类函数的结果的函数时，我们可以使用`Ok`和`Err`而不是`Result::Ok`和`Result::Err`，因为这些值直接添加到Rust
    *前缀*中，方便我们使用。实际上，我们可以使用`Result`类型而不必说明它来自哪里，原因相同。
- en: The prelude is a collection of very basic and useful data types, values, and
    traits that is automatically made available in every Rust module. It contains
    such things as `String`, `Vec` (a *vector*, which has the same relation to arrays
    that `String` does to `str`), and `Box` (which we'll talk about in the next chapter).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀是一个包含非常基本和有用的数据类型、值和特性的集合，它自动在每个Rust模块中可用。它包含诸如`String`、`Vec`（一个*向量*，它与数组的关系类似于`String`与`str`的关系），以及`Box`（我们将在下一章中讨论）等东西。
- en: Traits and trait objects
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性和特性对象
- en: Trait objects are another mechanism Rust has for storing a data value that might
    be one of several possible types into a single variable, but before we can talk
    about trait objects, we need to talk about traits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 特性对象是Rust存储可能为几种可能类型之一的数据值到单个变量中的另一种机制，但在我们讨论特性对象之前，我们需要讨论特性。
- en: Traits
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: 'A trait is a name and formal definition for a specific bit of functionality
    that a data type may provide. Previously, we''ve talked about how data types might
    have the `Copy` trait, and how, when they do, the compiler copies them instead
    of moving them. That is the general idea: when a trait is implemented for a data
    type, that data type gains the ability to interact with the rest of the program
    in some specific way.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是为数据类型可能提供的一块特定功能命名和正式定义。之前，我们讨论了数据类型可能具有`Copy`特性，以及当它们具有该特性时，编译器会复制它们而不是移动它们。这就是一般想法：当特性为数据类型实现时，该数据类型就获得了以某种特定方式与程序的其他部分交互的能力。
- en: Some of the built-in traits, such as `Copy`, actually affect how the *compiler*
    interacts with the type, but we're more interested in creating our own traits
    here. We'll talk about those built-in traits in a later chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置的特性，如`Copy`，实际上会影响编译器与类型的交互方式，但在这里我们更感兴趣的是创建我们自己的特性。我们将在后面的章节中讨论这些内置特性。
- en: 'That''s all very abstract, so let''s get more concrete by looking at the same
    "driving directions" problem that we previously solved with an enumeration. We
    still want to be able to have an array of driving instructions, and print them
    out in order, so let''s create a trait that represents the ability to print out
    a driving instruction:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很抽象，所以让我们通过查看我们之前用枚举解决的同一个“驾驶方向”问题来更加具体化。我们仍然希望能够有一个驾驶指令数组，并按顺序打印它们，所以让我们创建一个代表打印驾驶指令能力的特性：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `trait` keyword introduces a trait, unsurprisingly. Inside of it, we have
    the signatures of the functions that make up the *interface* of this trait. In
    other words, if a data type is going to have the `PrintableDirection` trait, it
    needs to provide implementations of these functions that are specialized for that
    type and trait.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`trait`关键字引入了一个特性，不出所料。在其中，我们有组成这个特性*接口*的函数签名。换句话说，如果一个数据类型将要拥有`PrintableDirection`特性，它需要提供针对该类型和特性的特定函数的实现。'
- en: It's possible for one data type to have multiple implemented functions with
    the same name, as long as each of those functions is part of a different trait.
    Traits don't need to worry about name collisions with other traits or the basic
    data type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只要每个函数是不同特性的一个部分，一个数据类型就可以有多个具有相同名称的实现函数。特性不需要担心与其他特性或基本数据类型发生名称冲突。
- en: We've expanded the functionality beyond what we did with enumerations, by specifying
    that a data value that has the `PrintableDirection` trait knows how to print itself
    out in both the *going to* and *coming from* directions of travel—or, at least,
    that's what we intend for the `forward` and `reverse` functions to mean.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定具有`PrintableDirection`特性的数据值知道如何以*前往*和*返回*的方向打印自身，或者至少这是我们希望`forward`和`reverse`函数的含义。
- en: Traits can specify functions by just providing a signature, as before, or they
    can also provide a default implementation of the function, by simply filling in
    a complete function definition instead. When the trait is implemented for a particular
    data type, functions with default implementations do not have to be implemented,
    though they can be, if necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可以通过只提供签名来指定函数，就像之前一样，或者它们也可以通过简单地填写一个完整的函数定义来提供函数的默认实现。当特性为特定数据类型实现时，具有默认实现的函数不必实现，尽管如果需要，它们可以。
- en: Notice that the function signatures inside the trait do not have the `pub` keyword.
    The trait itself is public or not, as a whole. In this case (and most cases),
    the trait is public, so the functions that it requires are automatically public.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，特性内部函数的签名没有`pub`关键字。特性本身是公开的或不是，作为一个整体。在这种情况下（以及大多数情况下），特性是公开的，因此它所要求的函数自动是公开的。
- en: Implementing our PrintableDirection trait
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的PrintableDirection特性
- en: 'Traits don''t exist independently; they are something that data types have.
    So, the first thing we need to do is create data types to represent the various
    kinds of driving directions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 特性不是独立存在的；它们是数据类型拥有的东西。因此，我们首先需要做的是创建数据类型来表示各种驾驶方向：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're just using basic structures here, but traits can be implemented for *any*
    data type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是使用基本结构，但特性可以为*任何*数据类型实现。
- en: These structures contain the same information that we included in the enumeration
    parameters before. The `Stop` structure is interesting, because it's empty. It
    stores no information at all. Its only purpose is to be a data type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构包含的信息与我们之前在枚举参数中包含的信息相同。`Stop`结构很有趣，因为它为空。它不存储任何信息。它的唯一目的是作为一个数据类型。
- en: 'Now, we have a trait and we have data types, but so far they are not related
    in any way. Let''s implement our trait for each of these types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个特性和数据类型，但到目前为止，它们之间没有任何关系。让我们为这些类型中的每一个实现我们的特性：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These implementation blocks look similar to the ones we've seen before, but
    this time instead of just saying `impl` and the type name, they say to implement
    the trait for the type name. Then, inside of it, we place the specific versions
    of the trait's functions that apply to that data type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现块看起来与我们之前看到的类似，但这次它们不仅仅是说`impl`和类型名，而是要为类型名实现特性。然后，在内部，我们放置适用于该数据类型的特性函数的具体版本。
- en: The `Forward`, `Turn`, and `Stop` data types now each have the `PrintableDirection`
    trait, which means that each of them knows how to display the information it contains
    as a driving instruction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Forward`、`Turn` 和 `Stop` 数据类型各自都具有 `PrintableDirection` 特质，这意味着它们都知道如何将其包含的信息作为驾驶指令显示出来。
- en: Trait objects
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质对象
- en: '`Forward`, `Turn`, and `Stop` are still three different data types. There''s
    no data type that represents *Forward, Turn, Stop*, and though we could create
    one using an enumeration, there''s another way. There is a data type that represents
    a borrow of *any* data type that has the `PrintableDirection` trait. It''s written
    as `&dyn PrintableDirection` and is called a trait object reference.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Forward`、`Turn` 和 `Stop` 仍然是三种不同的数据类型。没有表示 `Forward`、`Turn`、`Stop` 的数据类型，尽管我们可以使用枚举来创建一个，但还有另一种方法。有一个数据类型可以表示任何具有
    `PrintableDirection` 特质的 `any` 数据类型的借用。它被写成 `&dyn PrintableDirection`，被称为特质对象引用。'
- en: 'We *can''t* just write something like `let x: dyn PrintableDirection` and create
    a variable that can store anything with the `PrintableDirection` trait. It needs
    to be a borrow, or something that stores contained data outside the stack, such
    as the `Box` type we''ll look at in the next chapter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '我们**不能**只写像 `let x: dyn PrintableDirection` 这样的东西，并创建一个可以存储具有 `PrintableDirection`
    特质的任何内容的变量。它需要是一个借用，或者某种存储包含在栈外数据的数据，例如我们将在下一章中看到的 `Box` 类型。'
- en: The `dyn` keyword is short for *dynamic dispatch*, and it means that what looks
    and acts like a borrow in most ways is actually a little more complicated. The
    memory address stored in the borrow itself is actually the address of a hidden
    data structure.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`dyn` 关键字代表动态分派，它意味着在大多数情况下看起来和表现像借用，实际上要复杂一些。借用本身存储的内存地址实际上是隐藏数据结构的地址。'
- en: That hidden data structure contains the actual borrow address and the memory
    addresses of the functions that implement the trait for the borrowed data value.
    When we assign a data value to a trait object, Rust initializes that hidden data
    structure, and when we call one of the trait functions, Rust looks up which function
    to actually call in the same hidden data structure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那个隐藏的数据结构包含了实际借用地址以及实现借用数据值特质的函数的内存地址。当我们将一个数据值赋给特质对象时，Rust 会初始化那个隐藏的数据结构，当我们调用特质函数中的一个时，Rust
    会查找在同一个隐藏数据结构中实际要调用的函数。
- en: That means that calling a function through a trait object will always have a
    few extra steps that the computer needs to perform, compared to calling a function
    on a data value with a concrete type. On the other hand, if we think about it,
    any mechanism that could possibly allow us to work with arbitrary data types has
    to allocate time and memory for keeping track of what kind of data it's working
    with and where the data value is stored. If we tried to create the same functionality
    from scratch, we'd end up doing the same thing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过特质对象调用函数将始终需要计算机执行一些额外的步骤，与在具有具体类型的数据值上调用函数相比。另一方面，如果我们仔细思考，任何可能允许我们处理任意数据类型的机制都必须分配时间和内存来跟踪它正在处理的数据类型以及数据值存储的位置。如果我们从头开始尝试创建相同的功能，我们最终会做同样的事情。
- en: Using our PrintableDirection trait
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的 `PrintableDirection` 特质
- en: 'So, instead of an array of enumeration values, this time we''re going to create
    an array of trait object references:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次我们不是创建枚举值的数组，而是创建一个特质对象引用的数组：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Unfortunately, if we try to compile that, we get an error, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们尝试编译它，我们会得到一个错误，如下所示：
- en: '![](img/a5617fdb-e14d-40db-8366-99a306a591cb.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5617fdb-e14d-40db-8366-99a306a591cb.png)'
- en: This time, Rust can't figure out the data type of the array just by looking
    at the value we're assigning to it, because that value looks like an array containing
    multiple data types, which is not something we can even do in Rust. The compiler
    is not going to go looking for traits they all implement, pick one arbitrarily,
    and decide that the array is actually an array of trait objects. That would be
    bad more often than it was helpful, so we have to tell Rust what data type the `directions` variable
    should have.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Rust 不能仅通过查看我们分配给它的值来确定数组的数据类型，因为那个值看起来像是一个包含多个数据类型的数组，而这在我们甚至不能在 Rust 中做到。编译器不会去寻找它们都实现的特质，任意选择一个，并决定数组实际上是一个特质对象数组。这会比有帮助的情况更常见，所以我们必须告诉
    Rust `directions` 变量应该有什么数据类型。
- en: 'What we actually tell it is that `directions` is `[&dyn PrintableDirection;
    6]`. That means that it''s an array of `PrintableDirection` trait object references
    and has room for six of them. Now, the compiler knows how to correctly interpret
    our array expression:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上告诉它`directions`是`[&dyn PrintableDirection; 6]`。这意味着它是一个`PrintableDirection`特质对象引用的数组，并且有空间容纳六个。现在，编译器知道如何正确解释我们的数组表达式：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we''re ready to actually print out the driving directions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好实际打印出驾驶方向：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just for fun, we''ll also print out the directions for returning home:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，我们还会打印出回家的方向：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are two function calls to reverse here, and *they're not calling the same
    function*. The `directions.reverse()` call is calling a reverse function implemented
    on arrays, which reverses the order of the items stored in the array. Meanwhile,
    the `step.reverse()` call is calling the reverse function, which all types that
    have the `PrintableDirection` trait must implement, as appropriate for the specific
    concrete type of the step value. These functions happen to have the same name,
    but they're not at all the same thing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数调用来反转，但*它们并不是调用同一个函数*。`directions.reverse()`调用调用的是在数组上实现的反转函数，它反转数组中存储的项目顺序。同时，`step.reverse()`调用调用的是反转函数，这是所有具有`PrintableDirection`特质的类型必须实现的，适用于步骤值的特定具体类型。这些函数碰巧有相同的名字，但它们根本不是同一回事。
- en: 'When we compile and run all of the trait object code, we get output like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行所有特质对象代码时，我们得到如下输出：
- en: '![](img/006f1694-07e1-47f4-b677-690f9b100861.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/006f1694-07e1-47f4-b677-690f9b100861.png)'
- en: Yay, it works!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈，它工作了！
- en: Trait objects only provide access to the trait interface
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质对象只提供对特质接口的访问
- en: 'When we use a trait object, the *only* parts of the original object that we
    have access to are the parts that are defined by the trait. That means that we
    can call the `forward` and `reverse` functions, but we have no direct access to
    the `blocks` member of the `Forward` type, or the `slight` member of the `Turn`
    type, and so on. A trait object only gives us the things that are guaranteed to
    be present in *any* of the data types it can represent: the trait''s own interface.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用特质对象时，我们*唯一*可以访问的原始对象的部分是特质定义的部分。这意味着我们可以调用`forward`和`reverse`函数，但我们无法直接访问`Forward`类型的`blocks`成员或`Turn`类型的`slight`成员等。特质对象只给我们提供它所代表的任何数据类型中保证存在的那些东西：特质的自身接口。
- en: That makes sense, when we think about it. What's the computer supposed to do
    if we ask it to access `slight`, but the value we're looking at is actually a
    `Forward` type? Some languages would let us try and just crash the program if
    we tried it at the wrong time, while others would spend time while the program
    was running checking things like that and catching errors as they happen, but
    neither of those is the Rust way. In Rust, if the compiler can't be sure that
    something is okay, it's usually an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考时，这很有道理。如果我们要访问`slight`，但查看的值实际上是`Forward`类型，计算机应该做什么呢？一些语言会让我们尝试，如果我们在错误的时间这样做，程序就会崩溃，而其他语言会在程序运行时花费时间检查这些事情，并在发生错误时捕获它们，但都不是Rust的方式。在Rust中，如果编译器不能确定某件事是正确的，通常是一个错误。
- en: That means that a trait's interface needs to be complete, in the sense that
    anything you can reasonably do with a data value that has the trait should be
    part of the interface. That's not a burden most of the time. After all, why would
    we want it any other way?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着特质的接口需要是完整的，从意义上说，你可以用具有特质的任何数据值合理做的事情都应该包含在接口中。这通常不是负担。毕竟，我们为什么要以任何其他方式呢？
- en: We've been using the word **interface** a lot. Some languages, such as Java,
    have a feature that's actually *called* interface, and yes, Rust traits are similar
    to Java interfaces, although not identical.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用**接口**这个词。一些语言，如Java，有一个实际上*称为*接口的功能，是的，Rust特质与Java接口相似，尽管并不相同。
- en: Any
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Any
- en: '`Any` is a trait that most data types in Rust implement automatically, which
    means we can store almost anything in a trait object of `Any` type. However, as
    we''ve mentioned before, we can only access the stored value in a trait object
    in terms of that trait''s interface, so what does the `Any` interface let us do?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`是一个Rust中大多数数据类型自动实现的特质，这意味着我们可以在`Any`类型的特质对象中存储几乎所有东西。然而，正如我们之前提到的，我们只能根据特质的接口来访问特质对象中存储的值，所以`Any`接口让我们做什么呢？'
- en: Any can store almost anything
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Any可以存储几乎所有东西
- en: 'The Rust compiler automatically implements `Any` for any data type, *unless*
    that data type contains non-static references. So, our `Forward`, `Turn`, and
    `Stop` structures that we used in the trait objects section already automatically
    implement `Any`, but something like this would not:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编译器会自动为任何数据类型实现`Any`，*除非*该数据类型包含非静态引用。所以，我们在特质对象部分使用的`Forward`、`Turn`和`Stop`结构已经自动实现了`Any`，但像这样的事情就不会：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: More accurately, `DoesNotHaveAnyTrait` only has the `Any` trait when `'a` is
    equal to `'static`, which it is if we use a simple string expression such as `this
    is a static string` to initialize it, but not if we use some other mechanism for
    retrieving or constructing an `&str` value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，当`'a`等于`'static`时，`DoesNotHaveAnyTrait`才只有`Any`特质，如果我们使用一个简单的字符串表达式，如`this
    is a static string`来初始化它，它就是`'static`，但如果我们使用其他机制来检索或构造一个`&str`值，则不是。
- en: 'The error the compiler will give if we try something impossible along these
    lines will probably be about lifetimes rather than explicitly about the `Any`
    trait, as in the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试做不可能的事情，编译器可能会给出关于生命周期而不是关于`Any`特质的错误，如下面的例子所示：
- en: '![](img/c1403c83-927e-4e6e-8cac-41c977e6bae8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1403c83-927e-4e6e-8cac-41c977e6bae8.png)'
- en: Do you see the note? The code that caused the error was trying to create an
    `&dyn Any`, which told the compiler that the `'a` lifetime needed to be compatible
    with `'static`, which told it that the lifetime of `wrong.as_str()` was too short,
    so it reported an error.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到注释了吗？导致错误的代码尝试创建一个`&dyn Any`，这告诉编译器`'a`生命周期需要与`'static`兼容，这告诉它`wrong.as_str()`的生命周期太短，因此它报告了一个错误。
- en: Usually, that's not much of a problem, because we have several other reasons
    to avoid using non-static references in our data types, and we can use `String`,
    `Vec`, `Box`, and the like to achieve the same result. It's just something to
    keep in mind.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这并不是什么大问题，因为我们有其他几个原因避免在我们的数据类型中使用非静态引用，我们可以使用`String`、`Vec`、`Box`等来实现相同的结果。这只是我们需要记住的事情。
- en: But to access it we have to already know about the real data type
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但要访问它，我们首先必须了解真实的数据类型
- en: Getting back to our example, we'll create our array of driving directions, and
    we'll add a something else that isn't a driving direction, just to prove that
    we can.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，我们将创建我们的驾驶方向数组，并且我们会添加一些不是驾驶方向的东西，只是为了证明我们可以做到。
- en: 'Here, we have an array of `Any` trait references containing driving directions
    and one other thing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含驾驶方向和另一件事的`Any`特质引用数组：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So far, it looks rather similar to our trait object example, which makes sense
    since `Any` is a trait too, and this is still an array of trait object references.
    The huge difference here is that we've added one more item to the array, and it
    doesn't have anything at all to do with driving directions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它看起来与我们的特质对象示例非常相似，这是有道理的，因为`Any`也是一个特质，而且这仍然是一个特质对象引用的数组。这里巨大的不同之处在于，我们向数组中添加了一个额外的项目，而且它与驾驶方向完全没有关系。
- en: 'Trait object references only give us access to the trait''s functions. Now
    that we''ve got an array of `Any` trait object references, what functions does
    `Any` provide that let us do something useful? `Any` gives us two important functions:
    there is a function that checks whether the contained value has a particular data
    type, and there is a family of functions that lets us extract the contained value.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 特质对象引用只给我们提供了访问特质函数的权限。现在我们有了`Any`特质对象引用的数组，`Any`提供了哪些函数让我们能够做些有用的事情？`Any`提供了两个重要的函数：有一个函数可以检查包含的值是否具有特定的数据类型，还有一个函数族允许我们提取包含的值。
- en: 'For a first example, we''ll look at the function that allows us to check the
    data type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将查看允许我们检查数据类型的函数：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's some new syntax here. When we say `step.is::<Forward>()`, we're saying
    that we want to call the `is` function that was defined within the (automatically
    created) `impl Any for Forward` implementation. The compiler knows we're talking
    about `Any` because `step` is an `&dyn Any`, but it wouldn't know we wanted the
    `Forward` version rather than one of the countless other implementations of `Any`
    for specific types, so we needed to tell it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的语法。当我们说`step.is::<Forward>()`时，我们是在说我们想要调用在（自动创建的）`impl Any for Forward`实现中定义的`is`函数。编译器知道我们在谈论`Any`，因为`step`是一个`&dyn
    Any`，但它不知道我们想要的是`Forward`版本而不是无数其他特定类型的`Any`实现之一，所以我们需要告诉它。
- en: 'This syntax is a little confusing, since it''s backwards from what we would
    write in a `use` statement, but it otherwise looks similar. It does read well,
    though: *if step is forward* almost works as a sentence.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法有点令人困惑，因为它与我们通常在`use`语句中写的顺序相反，但除此之外看起来很相似。不过读起来倒是挺顺的：*如果步骤是向前*几乎可以作为一个句子。
- en: 'This version is a little unsatisfying, though, because the printout is entirely
    based on the data type, without taking into account the information stored in
    the data values. We could do just as well with an unparameterized enumeration.
    Fortunately, we can also use the downcast functions of `Any` to get access to
    the referenced value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个版本有点令人不满意，因为打印输出完全基于数据类型，而没有考虑到数据值中存储的信息。我们可以用一个未参数化的枚举做得一样好。幸运的是，我们还可以使用`Any`的downcast函数来获取对引用值的访问：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once again, we're telling Rust that we want to call the versions of the `Any`
    functions that come from specific type implementations of that trait. In the first
    if let branch, we're asking `Any` to give us a reference to a `Forward` data value.
    If the value actually *is* a `Forward` data value, that function will return an
    enumeration value called `Some`, which has the reference as its parameter. If
    the value *is not* a `Forward` data value, the function will return an enumeration
    value called `None`, which naturally does not match the `if let` pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们正在告诉Rust我们想要调用来自特定类型实现的`Any`函数版本。在第一个`if let`分支中，我们要求`Any`给我们一个`Forward`数据值的引用。如果该值实际上*是*一个`Forward`数据值，该函数将返回一个名为`Some`的枚举值，其中引用作为其参数。如果该值*不是*一个`Forward`数据值，该函数将返回一个名为`None`的枚举值，它自然不匹配`if
    let`模式。
- en: '`Some` and `None` are the two possible values of the `Option` enumeration,
    which is another thing included in the prelude. It is used widely to represent
    data values that might or might not exist, especially when they are not required
    to exist. It''s common in other languages to have a special value such as `NULL`,
    `null`, `None`, or `nil`, which can be assigned to anything. Rust''s `None` can
    only be assigned to `Option`, which helps the compiler ensure that everything
    is correct.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Some`和`None`是`Option`枚举的可能值，这是预定义中包含的另一件事。它被广泛用于表示可能存在或不存在的数据值，尤其是在它们不是必须存在的情况下。在其他语言中，通常有一个特殊值，如`NULL`、`null`、`None`或`nil`，它可以分配给任何东西。Rust的`None`只能分配给`Option`，这有助于编译器确保一切正确。'
- en: The `x` variables in this example are actual references to `Forward`, `Turn`,
    or `Stop` data values, respectively, and so if we make it into the code block
    for one of the `if` branches, we have access to everything that it is possible
    to do with that data type, not just the features defined by a particular trait.
    In fact, we're calling the `forward` functions implemented in the `PrintableDirection`
    trait for those types, which is a pretty good demonstration that we have full
    access.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的`x`变量实际上是`Forward`、`Turn`或`Stop`数据值的实际引用，因此如果我们进入其中一个`if`分支的代码块，我们就能够访问该数据类型可以执行的所有操作，而不仅仅是特定特质定义的功能。实际上，我们正在调用为这些类型在`PrintableDirection`特质中实现的`forward`函数，这是一个很好的证明我们拥有完全访问权限的例子。
- en: 'Notice that, with both `is` and `downcast_ref`, there''s no way to use them
    without specifying which concrete data type we''re interested in. If we try to
    use those functions without specifying exactly which data type to use, we get
    an error like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`is`和`downcast_ref`时，如果不指定我们感兴趣的特定数据类型，就无法使用它们。如果我们尝试在不指定确切使用哪种数据类型的情况下使用这些函数，我们会得到一个类似这样的错误：
- en: '![](img/e4ede84a-0394-4e2a-bec2-6202629427f5.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4ede84a-0394-4e2a-bec2-6202629427f5.png)'
- en: That means that while `Any` can be used to store almost anything, we can't access
    the stored information unless we explicitly handle the correct data type for the
    stored value. In our example, we didn't have an if branch to handle `DoesHaveAnyTrait`
    values, so the last value in the array ended up being ignored.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然`Any`可以存储几乎任何东西，但除非我们明确处理存储值的正确数据类型，否则我们无法访问存储的信息。在我们的例子中，我们没有if分支来处理`DoesHaveAnyTrait`值，所以数组中的最后一个值最终被忽略。
- en: In addition to `downcast_ref`, the `Any` trait also provides `downcast_mut`,
    which gives us a mutable reference. In some circumstances, a `downcast` function
    is also available, which moves the value into our current scope instead of borrowing
    it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`downcast_ref`之外，`Any`特质还提供了`downcast_mut`，它给我们一个可变引用。在某些情况下，还可用`downcast`函数，它将值移动到我们的当前作用域而不是借用它。
- en: Comparison of these techniques
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这些技术的比较
- en: The Rust community tends to prefer using enumerations to address one-variable-multiple-types
    problems. In terms of runtime cost, a simple enumeration is maximally efficient,
    and efficiency is important to Rust programmers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Rust社区倾向于使用枚举来解决单变量多类型问题。在运行时成本方面，简单的枚举是最有效率的，效率对Rust程序员来说很重要。
- en: However, there is a downside to using enumerations, which is that the `match`
    expressions (or similar) that decide how to handle a particular enumeration value
    and associated data might be spread throughout the source code of the program.
    If we discover a need to add or remove an enumeration value, or change an enumeration
    value's parameters, we have to find and change every one of those match expressions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用枚举有一个缺点，那就是决定如何处理特定枚举值及其相关数据的`match`表达式（或类似）可能会分散在程序的源代码中。如果我们发现需要添加或删除枚举值，或者更改枚举值的参数，我们必须找到并更改所有这些匹配表达式。
- en: 'If we decide to add a `Reverse` value to the `Drive` enumeration, the match
    expressions have to be changed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定在`Drive`枚举中添加一个`Reverse`值，匹配表达式就必须进行更改：
- en: '![](img/ee4b68b0-a7c7-43e0-93a7-77da803950e9.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee4b68b0-a7c7-43e0-93a7-77da803950e9.png)'
- en: The compiler will point out each `match` expression that needs to be updated,
    but it won't catch places where an `if let` expression would need similar changes
    (because `if let` is allowed to handle only some of the possibilities), so this
    can be a significant problem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会指出需要更新的每个`match`表达式，但它不会捕获需要类似更改的`if let`表达式的地方（因为`if let`只能处理一些可能性），因此这可能会成为一个重大问题。
- en: Trait objects on the other hand let us keep all the related code close together,
    by making the behavior for different data types actually be part of the data type.
    They also allow us to write code that works with data types we haven't even created
    yet, but they are less efficient, because the computer needs to maintain and use
    the hidden trait object structure while the program is running.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，特质对象通过使不同数据类型的行为实际上成为数据类型的一部分，使我们能够将所有相关代码放在一起。它们还允许我们编写可以与尚未创建的数据类型一起工作的代码，但它们效率较低，因为计算机需要在程序运行时维护和使用隐藏的特质对象结构。
- en: We might think we could get the best of both worlds by creating an enumeration
    and then implementing functions on it that contain match expressions and handle
    each of the enumeration values differently, and to an extent, we can. However,
    if those functions work by picking another enumeration value-specific function
    and calling *that*, we've just recreated trait objects all over again, but less
    efficiently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为通过创建一个枚举并在其上实现包含匹配表达式和针对枚举的每个值进行不同处理的函数，我们可以得到两者的最佳结合，并且在某种程度上，我们可以做到。然而，如果这些函数通过选择另一个枚举值特定的函数并调用*那个*来工作，我们只是再次重新创建了特质对象，但效率更低。
- en: 'If we try something like the following to avoid trait objects, we''re better
    off just using trait objects:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试以下方法来避免特质对象，我们最好还是使用特质对象：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's not to say that such constructions are useless, because they're not.
    However, if the *only* reason for doing something like that is to avoid using
    trait object references, it's a mistake.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说这样的结构没有用，因为它们是有用的。然而，如果这样做*唯一*的原因是避免使用特质对象引用，那是一个错误。
- en: It may seem like `Any` is actually the best option, since it can store such
    a wide range of values *and* gives us full access to the stored value data, but
    usually one of the other choices is better. Using `Any` means we need to check
    for all of the possibilities in various places throughout the code, as we would
    with an enumeration and, unlike an enumeration, the compiler can't give us any
    help at all in finding places that need to change because, like a trait object
    reference, there's no defined list of possibilities. `Any` is, in many ways, the
    worst of both worlds.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来`Any`实际上是最佳选择，因为它可以存储如此广泛的值*并且*给我们提供了对存储值数据的完全访问，但通常其他选项中的一个是更好的。使用`Any`意味着我们需要在代码的各个地方检查所有可能性，就像使用枚举一样，而且与枚举不同，编译器在寻找需要更改的地方时不能提供任何帮助，因为，就像特质对象引用一样，没有定义的可能性的列表。在许多方面，`Any`是两者的最差结合。
- en: There are *some* problems that `Any` is the right choice for, though. If we
    really need to handle a collection of unrelated data types, we need `Any`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些问题`Any`是正确的选择，尽管如此。如果我们真的需要处理一组无关的数据类型，我们需要`Any`。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Okay, so we have three different ways to approach the same problem, each with
    different strengths and weaknesses:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有三种不同的方法来处理相同的问题，每种方法都有其不同的优势和劣势：
- en: We learned that enumerations are the most efficient, especially for simple cases
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到枚举是最有效率的，尤其是在简单情况下
- en: We learned that trait object references produce the simplest code, at the cost
    of additional overhead
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到特性对象引用可以产生最简单的代码，但代价是额外的开销
- en: We learned that the `Any` trait gives us a way to refer to almost anything,
    but we have to explicitly extract the type of information we need
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到`Any`特性为我们提供了一种几乎可以引用任何事物的途径，但我们必须明确提取所需的信息类型
- en: In the next chapter, we're going to learn how to store data outside the stack,
    and why we would want to.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将数据存储在栈外，以及为什么我们想要这样做
