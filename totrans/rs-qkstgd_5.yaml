- en: One Data Type Representing Multiple Kinds of Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, a data value might need to be one of multiple different data types.
    Rust has three ways of addressing that situation without breaking strict type
    safety: enumerations, trait objects, and `Any`. Each approach has strengths and
    weaknesses, so we''ll examine them all and talk about when each is appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What an enumeration is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an enumeration type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create enumeration values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the information stored in an enumeration value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a trait and a trait object are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a trait object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a trait object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What `Any` is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `Any`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What enumerations are good for, what trait objects are good for, and what `Any`
    is good for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like structures, enumerations allow us to establish a new data type. The content
    is different from a structure, though. When we say that the data type of a variable
    is an enumeration, we're telling Rust that its contained value is required to
    be one of the specific choices we've described for that enumeration and can't
    be anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Basic enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Rust, an enumeration is a data type representing one of a fixed set of values.
    For example, we could define an enumeration of the commonly recognized seven colors
    of the rainbow, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we define this enumeration, we can use `Color` as a data type and `Color::Red` or
    the like as data values of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An enumeration is created with the `enum` keyword. Notice that, like a structure,
    an enumeration needs the `pub` keyword if we want it to be directly accessible
    outside the current module. Between the `{` and `}`, we have the list of possible
    values for the data type, listed by name and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is somewhat opinionated about capitalization, so it will warn us if any
    of the enumeration values start with a lowercase letter, though that is not actually
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so what do enumerations have to do with representing different kinds
    of data in one variable? Well, there''s one more feature that enumeration values
    can have that changes everything: parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we wanted to create a representation of a sequence of driving directions,
    such as *turn right*, *forward three blocks*, or *stop.* This example is simple
    enough that we could probably get by with a simple enumeration, but even this
    will be easier with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is an enumeration with parameterized values. The `Forward`
    value has a `u8` parameter (unsigned 8 bit integer) , while the `Turn` value has
    two `bool` parameters with names. `Stop` doesn't need any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `Forward` value carries a 1-tuple along with it, while the
    `Turn` value carries along a structure with two members. That's why parentheses
    are used around the `Forward` parameter and braces are used around the `Turn` parameters.
    Whether we want the parameters to be tuple-like or structure-like is our decision
    to make. Either way, we can have as many or as few parameters as we need.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create a variable of the `Drive` type, and it might contain a `Forward`, `Turn`,
    or `Stop` parameter. If it's a `Forward` parameter, that means the variable also
    contains a `u8` number telling us how far to drive. If it's a `Turn` parameter,
    that means the variable also contains a pair of Boolean values that tell us whether
    to turn right or left, and whether or not the turn is slight. In other words,
    the variable might contain any one of several different kinds of information.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with C++, or a similar language, keep in mind that Rust enumerations
    are not very much like C++ enumerations. A Rust enumeration with parameterized
    values is more like a C++ union, except it's type checked and safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Better still, we can create an array of driving instructions, to represent
    a complete journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This array of `Drive` values represents driving forward three blocks, turning
    right, driving forward one more block, and stopping.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the value type and extracting parameter values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the program runs, it can take different actions depending on the specific
    enumeration type it''s looking at, and it has access to the data values that were
    stored as parameters. We''ve already seen the best tool for doing that, `match`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a `for` loop that processes each item in our array of directions,
    one at a time, starting with the first one. Step by step, here''s what is going
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: We asked `directions` to provide us with an iterator, which it's happy to do.
    The iterator will give us a borrow of each value contained in the array, one at
    a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `for` loop requests a value from the iterator, and assigns the returned
    borrow to a variable called `step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The match expression uses the `step` variable to provide the value that it
    will match against. Because that variable changes each time the loop goes through,
    the match expression compares against a different value each time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `step` variable contains (a borrow of) `Drive::Forward`, its parameter
    is assigned to the variable named `blocks`. Because `step` *is* a borrow, the
    value in `blocks` is a borrow as well, but, in this instance that doesn't make
    a significant difference. We pass it on to `println!`, which calls a function
    on it to turn it into a text string, which in turn, dereferences it automatically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `step` variable contains (a borrow of) `Drive::Turn`, borrows of its
    parameters are assigned to the `slight` and `right` names, and we can use the
    shorthand notation we've seen before for that because `slight` and `right` are
    the names of the variables in both the source and the destination. Then comes
    a print command, but we're using `if` expressions to decide exactly what to print.
    Notice that we have explicitly dereferenced the `slight` and `right` values; they
    *are* borrows and, unlike when we call functions, `if` expressions don't automatically
    dereference for us, so we need to do it ourselves.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `step` variable contains (a borrow of) `Drive::Stop`, there are no parameters
    to deal with and we just print out a message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are any values left in the iterator, got back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pretty cool. We've got some code here that does something kind of real. That's
    when the fun really starts!
  prefs: []
  type: TYPE_NORMAL
- en: Result is an enumeration, accessed via the prelude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed already, but the `Result` type with its `Ok` and `Err`
    values looks an awful lot like an enumeration. That's because it is an enumeration,
    which is how it's able to contain different data types depending on whether it
    represents an error or a success. It's an enumeration with generic type parameters,
    so we won't be able to pull off quite the same functionality until we learn about
    those but, at its base, it's still just an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `Ok` and `Err` instead of `Result::Ok` and `Result::Err` when we
    write functions that might fail or handle the results of such functions, because
    those values are added directly to the Rust *prelude* for our convenience. Actually,
    we can use the `Result` type without saying where it came from for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: The prelude is a collection of very basic and useful data types, values, and
    traits that is automatically made available in every Rust module. It contains
    such things as `String`, `Vec` (a *vector*, which has the same relation to arrays
    that `String` does to `str`), and `Box` (which we'll talk about in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Traits and trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trait objects are another mechanism Rust has for storing a data value that might
    be one of several possible types into a single variable, but before we can talk
    about trait objects, we need to talk about traits.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A trait is a name and formal definition for a specific bit of functionality
    that a data type may provide. Previously, we''ve talked about how data types might
    have the `Copy` trait, and how, when they do, the compiler copies them instead
    of moving them. That is the general idea: when a trait is implemented for a data
    type, that data type gains the ability to interact with the rest of the program
    in some specific way.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the built-in traits, such as `Copy`, actually affect how the *compiler*
    interacts with the type, but we're more interested in creating our own traits
    here. We'll talk about those built-in traits in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all very abstract, so let''s get more concrete by looking at the same
    "driving directions" problem that we previously solved with an enumeration. We
    still want to be able to have an array of driving instructions, and print them
    out in order, so let''s create a trait that represents the ability to print out
    a driving instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `trait` keyword introduces a trait, unsurprisingly. Inside of it, we have
    the signatures of the functions that make up the *interface* of this trait. In
    other words, if a data type is going to have the `PrintableDirection` trait, it
    needs to provide implementations of these functions that are specialized for that
    type and trait.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible for one data type to have multiple implemented functions with
    the same name, as long as each of those functions is part of a different trait.
    Traits don't need to worry about name collisions with other traits or the basic
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: We've expanded the functionality beyond what we did with enumerations, by specifying
    that a data value that has the `PrintableDirection` trait knows how to print itself
    out in both the *going to* and *coming from* directions of travel—or, at least,
    that's what we intend for the `forward` and `reverse` functions to mean.
  prefs: []
  type: TYPE_NORMAL
- en: Traits can specify functions by just providing a signature, as before, or they
    can also provide a default implementation of the function, by simply filling in
    a complete function definition instead. When the trait is implemented for a particular
    data type, functions with default implementations do not have to be implemented,
    though they can be, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the function signatures inside the trait do not have the `pub` keyword.
    The trait itself is public or not, as a whole. In this case (and most cases),
    the trait is public, so the functions that it requires are automatically public.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our PrintableDirection trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traits don''t exist independently; they are something that data types have.
    So, the first thing we need to do is create data types to represent the various
    kinds of driving directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're just using basic structures here, but traits can be implemented for *any*
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: These structures contain the same information that we included in the enumeration
    parameters before. The `Stop` structure is interesting, because it's empty. It
    stores no information at all. Its only purpose is to be a data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a trait and we have data types, but so far they are not related
    in any way. Let''s implement our trait for each of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These implementation blocks look similar to the ones we've seen before, but
    this time instead of just saying `impl` and the type name, they say to implement
    the trait for the type name. Then, inside of it, we place the specific versions
    of the trait's functions that apply to that data type.
  prefs: []
  type: TYPE_NORMAL
- en: The `Forward`, `Turn`, and `Stop` data types now each have the `PrintableDirection`
    trait, which means that each of them knows how to display the information it contains
    as a driving instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Forward`, `Turn`, and `Stop` are still three different data types. There''s
    no data type that represents *Forward, Turn, Stop*, and though we could create
    one using an enumeration, there''s another way. There is a data type that represents
    a borrow of *any* data type that has the `PrintableDirection` trait. It''s written
    as `&dyn PrintableDirection` and is called a trait object reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We *can''t* just write something like `let x: dyn PrintableDirection` and create
    a variable that can store anything with the `PrintableDirection` trait. It needs
    to be a borrow, or something that stores contained data outside the stack, such
    as the `Box` type we''ll look at in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The `dyn` keyword is short for *dynamic dispatch*, and it means that what looks
    and acts like a borrow in most ways is actually a little more complicated. The
    memory address stored in the borrow itself is actually the address of a hidden
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: That hidden data structure contains the actual borrow address and the memory
    addresses of the functions that implement the trait for the borrowed data value.
    When we assign a data value to a trait object, Rust initializes that hidden data
    structure, and when we call one of the trait functions, Rust looks up which function
    to actually call in the same hidden data structure.
  prefs: []
  type: TYPE_NORMAL
- en: That means that calling a function through a trait object will always have a
    few extra steps that the computer needs to perform, compared to calling a function
    on a data value with a concrete type. On the other hand, if we think about it,
    any mechanism that could possibly allow us to work with arbitrary data types has
    to allocate time and memory for keeping track of what kind of data it's working
    with and where the data value is stored. If we tried to create the same functionality
    from scratch, we'd end up doing the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Using our PrintableDirection trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, instead of an array of enumeration values, this time we''re going to create
    an array of trait object references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, if we try to compile that, we get an error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5617fdb-e14d-40db-8366-99a306a591cb.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, Rust can't figure out the data type of the array just by looking
    at the value we're assigning to it, because that value looks like an array containing
    multiple data types, which is not something we can even do in Rust. The compiler
    is not going to go looking for traits they all implement, pick one arbitrarily,
    and decide that the array is actually an array of trait objects. That would be
    bad more often than it was helpful, so we have to tell Rust what data type the `directions` variable
    should have.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we actually tell it is that `directions` is `[&dyn PrintableDirection;
    6]`. That means that it''s an array of `PrintableDirection` trait object references
    and has room for six of them. Now, the compiler knows how to correctly interpret
    our array expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to actually print out the driving directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for fun, we''ll also print out the directions for returning home:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are two function calls to reverse here, and *they're not calling the same
    function*. The `directions.reverse()` call is calling a reverse function implemented
    on arrays, which reverses the order of the items stored in the array. Meanwhile,
    the `step.reverse()` call is calling the reverse function, which all types that
    have the `PrintableDirection` trait must implement, as appropriate for the specific
    concrete type of the step value. These functions happen to have the same name,
    but they're not at all the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we compile and run all of the trait object code, we get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/006f1694-07e1-47f4-b677-690f9b100861.png)'
  prefs: []
  type: TYPE_IMG
- en: Yay, it works!
  prefs: []
  type: TYPE_NORMAL
- en: Trait objects only provide access to the trait interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use a trait object, the *only* parts of the original object that we
    have access to are the parts that are defined by the trait. That means that we
    can call the `forward` and `reverse` functions, but we have no direct access to
    the `blocks` member of the `Forward` type, or the `slight` member of the `Turn`
    type, and so on. A trait object only gives us the things that are guaranteed to
    be present in *any* of the data types it can represent: the trait''s own interface.'
  prefs: []
  type: TYPE_NORMAL
- en: That makes sense, when we think about it. What's the computer supposed to do
    if we ask it to access `slight`, but the value we're looking at is actually a
    `Forward` type? Some languages would let us try and just crash the program if
    we tried it at the wrong time, while others would spend time while the program
    was running checking things like that and catching errors as they happen, but
    neither of those is the Rust way. In Rust, if the compiler can't be sure that
    something is okay, it's usually an error.
  prefs: []
  type: TYPE_NORMAL
- en: That means that a trait's interface needs to be complete, in the sense that
    anything you can reasonably do with a data value that has the trait should be
    part of the interface. That's not a burden most of the time. After all, why would
    we want it any other way?
  prefs: []
  type: TYPE_NORMAL
- en: We've been using the word **interface** a lot. Some languages, such as Java,
    have a feature that's actually *called* interface, and yes, Rust traits are similar
    to Java interfaces, although not identical.
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Any` is a trait that most data types in Rust implement automatically, which
    means we can store almost anything in a trait object of `Any` type. However, as
    we''ve mentioned before, we can only access the stored value in a trait object
    in terms of that trait''s interface, so what does the `Any` interface let us do?'
  prefs: []
  type: TYPE_NORMAL
- en: Any can store almost anything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rust compiler automatically implements `Any` for any data type, *unless*
    that data type contains non-static references. So, our `Forward`, `Turn`, and
    `Stop` structures that we used in the trait objects section already automatically
    implement `Any`, but something like this would not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: More accurately, `DoesNotHaveAnyTrait` only has the `Any` trait when `'a` is
    equal to `'static`, which it is if we use a simple string expression such as `this
    is a static string` to initialize it, but not if we use some other mechanism for
    retrieving or constructing an `&str` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error the compiler will give if we try something impossible along these
    lines will probably be about lifetimes rather than explicitly about the `Any`
    trait, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1403c83-927e-4e6e-8cac-41c977e6bae8.png)'
  prefs: []
  type: TYPE_IMG
- en: Do you see the note? The code that caused the error was trying to create an
    `&dyn Any`, which told the compiler that the `'a` lifetime needed to be compatible
    with `'static`, which told it that the lifetime of `wrong.as_str()` was too short,
    so it reported an error.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, that's not much of a problem, because we have several other reasons
    to avoid using non-static references in our data types, and we can use `String`,
    `Vec`, `Box`, and the like to achieve the same result. It's just something to
    keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: But to access it we have to already know about the real data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting back to our example, we'll create our array of driving directions, and
    we'll add a something else that isn't a driving direction, just to prove that
    we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have an array of `Any` trait references containing driving directions
    and one other thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So far, it looks rather similar to our trait object example, which makes sense
    since `Any` is a trait too, and this is still an array of trait object references.
    The huge difference here is that we've added one more item to the array, and it
    doesn't have anything at all to do with driving directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trait object references only give us access to the trait''s functions. Now
    that we''ve got an array of `Any` trait object references, what functions does
    `Any` provide that let us do something useful? `Any` gives us two important functions:
    there is a function that checks whether the contained value has a particular data
    type, and there is a family of functions that lets us extract the contained value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a first example, we''ll look at the function that allows us to check the
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's some new syntax here. When we say `step.is::<Forward>()`, we're saying
    that we want to call the `is` function that was defined within the (automatically
    created) `impl Any for Forward` implementation. The compiler knows we're talking
    about `Any` because `step` is an `&dyn Any`, but it wouldn't know we wanted the
    `Forward` version rather than one of the countless other implementations of `Any`
    for specific types, so we needed to tell it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax is a little confusing, since it''s backwards from what we would
    write in a `use` statement, but it otherwise looks similar. It does read well,
    though: *if step is forward* almost works as a sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This version is a little unsatisfying, though, because the printout is entirely
    based on the data type, without taking into account the information stored in
    the data values. We could do just as well with an unparameterized enumeration.
    Fortunately, we can also use the downcast functions of `Any` to get access to
    the referenced value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're telling Rust that we want to call the versions of the `Any`
    functions that come from specific type implementations of that trait. In the first
    if let branch, we're asking `Any` to give us a reference to a `Forward` data value.
    If the value actually *is* a `Forward` data value, that function will return an
    enumeration value called `Some`, which has the reference as its parameter. If
    the value *is not* a `Forward` data value, the function will return an enumeration
    value called `None`, which naturally does not match the `if let` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`Some` and `None` are the two possible values of the `Option` enumeration,
    which is another thing included in the prelude. It is used widely to represent
    data values that might or might not exist, especially when they are not required
    to exist. It''s common in other languages to have a special value such as `NULL`,
    `null`, `None`, or `nil`, which can be assigned to anything. Rust''s `None` can
    only be assigned to `Option`, which helps the compiler ensure that everything
    is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: The `x` variables in this example are actual references to `Forward`, `Turn`,
    or `Stop` data values, respectively, and so if we make it into the code block
    for one of the `if` branches, we have access to everything that it is possible
    to do with that data type, not just the features defined by a particular trait.
    In fact, we're calling the `forward` functions implemented in the `PrintableDirection`
    trait for those types, which is a pretty good demonstration that we have full
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, with both `is` and `downcast_ref`, there''s no way to use them
    without specifying which concrete data type we''re interested in. If we try to
    use those functions without specifying exactly which data type to use, we get
    an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4ede84a-0394-4e2a-bec2-6202629427f5.png)'
  prefs: []
  type: TYPE_IMG
- en: That means that while `Any` can be used to store almost anything, we can't access
    the stored information unless we explicitly handle the correct data type for the
    stored value. In our example, we didn't have an if branch to handle `DoesHaveAnyTrait`
    values, so the last value in the array ended up being ignored.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `downcast_ref`, the `Any` trait also provides `downcast_mut`,
    which gives us a mutable reference. In some circumstances, a `downcast` function
    is also available, which moves the value into our current scope instead of borrowing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of these techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust community tends to prefer using enumerations to address one-variable-multiple-types
    problems. In terms of runtime cost, a simple enumeration is maximally efficient,
    and efficiency is important to Rust programmers.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a downside to using enumerations, which is that the `match`
    expressions (or similar) that decide how to handle a particular enumeration value
    and associated data might be spread throughout the source code of the program.
    If we discover a need to add or remove an enumeration value, or change an enumeration
    value's parameters, we have to find and change every one of those match expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide to add a `Reverse` value to the `Drive` enumeration, the match
    expressions have to be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee4b68b0-a7c7-43e0-93a7-77da803950e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The compiler will point out each `match` expression that needs to be updated,
    but it won't catch places where an `if let` expression would need similar changes
    (because `if let` is allowed to handle only some of the possibilities), so this
    can be a significant problem.
  prefs: []
  type: TYPE_NORMAL
- en: Trait objects on the other hand let us keep all the related code close together,
    by making the behavior for different data types actually be part of the data type.
    They also allow us to write code that works with data types we haven't even created
    yet, but they are less efficient, because the computer needs to maintain and use
    the hidden trait object structure while the program is running.
  prefs: []
  type: TYPE_NORMAL
- en: We might think we could get the best of both worlds by creating an enumeration
    and then implementing functions on it that contain match expressions and handle
    each of the enumeration values differently, and to an extent, we can. However,
    if those functions work by picking another enumeration value-specific function
    and calling *that*, we've just recreated trait objects all over again, but less
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try something like the following to avoid trait objects, we''re better
    off just using trait objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's not to say that such constructions are useless, because they're not.
    However, if the *only* reason for doing something like that is to avoid using
    trait object references, it's a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like `Any` is actually the best option, since it can store such
    a wide range of values *and* gives us full access to the stored value data, but
    usually one of the other choices is better. Using `Any` means we need to check
    for all of the possibilities in various places throughout the code, as we would
    with an enumeration and, unlike an enumeration, the compiler can't give us any
    help at all in finding places that need to change because, like a trait object
    reference, there's no defined list of possibilities. `Any` is, in many ways, the
    worst of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: There are *some* problems that `Any` is the right choice for, though. If we
    really need to handle a collection of unrelated data types, we need `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so we have three different ways to approach the same problem, each with
    different strengths and weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned that enumerations are the most efficient, especially for simple cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that trait object references produce the simplest code, at the cost
    of additional overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that the `Any` trait gives us a way to refer to almost anything,
    but we have to explicitly extract the type of information we need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn how to store data outside the stack,
    and why we would want to.
  prefs: []
  type: TYPE_NORMAL
