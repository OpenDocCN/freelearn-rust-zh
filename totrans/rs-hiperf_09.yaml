- en: Creating Your Own Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we saw how macros and metaprogramming, in general, can
    make your life much easier. We saw both, macros that reduce the required boilerplate
    code and macros that will speed up your final code. It's time for you to learn
    how to create your own macros.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create your own standard macros, how
    to create your own procedural macros and custom derives, and finally, how to use
    nightly features to create your own plugins. You will also see how the new declarative
    macros work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is divided into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Macrosystem**: Understanding the `macro_rules!{}` macro'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedural macros**: Learning how to create your own custom derives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nightly metaprogramming**: Plugins and declarative macros'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own standard macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Rust 1.0, we have had a great macro system. Macros allow us to apply some
    code to multiple types or expressions, as they work by expanding themselves at
    compile time. This means that when you use a macro, you are effectively writing
    a lot of code before the actual compilation starts. This has two main benefits,
    first, the codebase can be easier to maintain by being smaller and reusing code,
    and second, since macros expand before starting the creation of object code, you
    can abstract at the syntactic level.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can have a function like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function restricts the input to `u32` types and the return type to `u32`.
    We could add some more accepted types by using generics, which may accept `&u32`
    if we use the `Add` trait. Macros allow us to create this kind of code for any
    element that can be written to the left of the `+` sign and it will be expanded
    differently for each type of element, creating different code for each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a macro, you will need to use a macro built in to the language, the
    `macro_rules!{}` macro. This macro receives the name of the new macro as a first
    parameter and a block with the macro code as a second element. The syntax can
    be a bit complex the first time you see it, but it can be learned quickly. Let''s
    start with a macro that does just the same as the function we saw before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can now call that macro from your `main()` function by calling `add_one!(integer);`.
    Note that the macro needs to be defined before the first call, even if it's in
    the same file. It will work with any integer, which wasn't possible with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze how the syntax works. In the block after the name of the new macro
    (`add_one`), we can see two sections. In the first part, on the left of the `=>`,
    we see `$input:expr` inside parentheses. Then, to the right, we see a Rust block
    where we do the actual addition.
  prefs: []
  type: TYPE_NORMAL
- en: The left part works similarly (in some ways) to a pattern match. You can add
    any combination of characters and then some variables, all of them starting with
    a dollar sign (`$`) and showing the type of variable after a colon. In this case,
    the only variable is the `$input` variable and it's an expression. This means
    that you can insert any kind of expression there and it will be written in the
    code to the right, substituting the variable with the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Macro variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, it''s not as complicated as you might think. As I wrote, you
    can have almost any pattern to the left of the `macro_rules!{}` side. Not only
    that, you can also have multiple patterns, as if it were a match statement, so
    that if one of them matches, it will be the one expanded. Let''s see how this
    works by creating a macro which, depending on how we call it, will add one or
    two to the given integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see a couple of clear changes to the macro. First, we swapped braces
    for parentheses and parentheses for braces in the macro. This is because in a
    macro, you can use interchangeable braces (`{` and `}`), square brackets (`[`
    and `]`), and parentheses (`(` and `)`). Not only that, you can use them when
    calling the macro. You have probably already used the `vec![]` macro and the `format!()`
    macro, and we saw the `lazy_static!{}` macro in the last chapter. We use brackets
    and parentheses here just for convention, but we could call the `vec!{}` or the
    `format![]` macros the same way, because we can use braces, brackets, and parentheses
    in any macro call.
  prefs: []
  type: TYPE_NORMAL
- en: The second change was to add some extra text to our left-hand side patterns.
    We now call our macro by writing the text `one to` or `two to`, so I also removed
    the `one` redundancy to the macro name and called it `add!()`. This means that
    we now call our macro with literal text. That is not valid Rust, but since we
    are using a macro, we modify the code we are writing before the compiler tries
    to understand actual Rust code and the generated code is valid. We could add any
    text that does not end the pattern (such as parentheses or braces) to the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The final change was to add a second possible pattern. We can now add one or
    two and the only difference will be that the right side of the macro definition
    must now end with a trailing semicolon for each pattern (the last one is optional)
    to separate each of the options.
  prefs: []
  type: TYPE_NORMAL
- en: A small detail that I also added in the example was when calling the macro in
    the `main()` function. As you can see, I could have added `one` or `two` to `5`,
    but I wrote `25/5` for a reason. When compiling this code, this will be expanded
    to `25/5 + 1` (or `2`, if you use the second variant). This will later be optimized
    at compile time, since it will know that `25/5 + 1` is `6`, but the compiler will
    receive that expression, not the final result. The macro system will not calculate
    the result of the expression; it will simply copy in the resulting code whatever
    you give to it and then pass it to the next compiler phase.
  prefs: []
  type: TYPE_NORMAL
- en: You should be especially careful with this when a macro you are creating calls
    another macro. They will get expanded recursively, one inside the other, so the
    compiler will receive a bunch of final Rust code that will need to be optimized.
    Issues related to this were found in the CLAP crate that we saw in the last chapter,
    since the exponential expansions were adding a lot of bloat code to their executables.
    Once they found out that there were too many macro expansions inside the other
    macros and fixed it, they reduced the size of their binary contributions by more
    than 50%.
  prefs: []
  type: TYPE_NORMAL
- en: Macros allow for an extra layer of customization. You can repeat arguments more
    than once. This is common, for example, in the `vec![]` macro, where you create
    a new vector with information at compile time. You can write something like `vec![3,
    4, 76, 87];`. How does the `vec![]` macro handle an unspecified number of arguments?
  prefs: []
  type: TYPE_NORMAL
- en: Complex macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can specify that we want multiple expressions in the left-hand side pattern
    of the macro definition by adding a `*` for *zero or more* matches or a `+` for
    *one or more* matches. Let''s see how we can do that with a simplified `my_vec![]`
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what is happening here. First, we see that on the left side, we have
    two variables, denoted by the two `$` signs. The first makes reference to the
    actual repetition. Each comma-separated expression will generate a `$x` variable.
    Then, on the right side, we use the various repetitions to push `$x` to the vector
    once for every expression we receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another new thing on the right-hand side. As you can see, the macro
    expansion starts and ends with a double brace instead of using only one. This
    is because, once the macro gets expanded, it will substitute the given expression
    for a new expression: the one that gets generated. Since what we want is to return
    the vector we are creating, we need a new scope where the last sentence will be
    the value of the scope once it gets executed. You will be able to see it more
    clearly in the next code snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this code with the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be expanded to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need those extra braces to create the scope that will return
    the vector so that it gets assigned to the `my_vector` binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have multiple repetition patterns on the left expression and they will
    be repeated for every use, as needed on the right. There is a nice example illustrating
    this behavior in the first edition of the official Rust book, which I have adapted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the macro can receive one or more `$x; [$y1, $y2,...]` input.
    So, for each input, it will have one expression, then a semicolon, then a bracket
    with multiple sub-expressions separated by a comma, and finally, another bracket
    and a semicolon. But what does the macro do with this input? Let's check to the
    right-hand side of it.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this will create multiple repetitions. We can see that it creates
    a slice (`&[T]`) of whatever we feed to it, so all the expressions we use must
    be of the same type. Then, it will start iterating over all `$x` variables, one
    per input group. So if we feed it only one input, it will iterate once for the
    expression to the left of the semicolon. Then, it will iterate once for every
    `$y` expression associated with the `$x` expression, add them to the `+` operator,
    and include the result in the slice.
  prefs: []
  type: TYPE_NORMAL
- en: If this was too complex to understand, let's look at an example. Let's suppose
    we call the macro with `65; [22, 34]` as input. In this case, `65` will be `$x`,
    and `22`, `24`, and so on will be `$y` variables associated with `65`. So, the
    result will be a slice like this: `&[65+22, 65+34]`. Or, if we calculate the results: `&[87,
    99]`.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we give two groups of variables by using `65; [22, 34];
    23; [56, 35]` as input, in the first iteration, `$x` will be `65`, while in the
    second one, it will be `23`. The `$y` variables of `64` will be `22` and `34`,
    as before, and the ones associated with `23` will be `56` and `35`. This means
    that the final slice will be `&[87, 99, 79, 58]`, where `87` and `99` work the
    same way as before and `79` and `58` are the extension of adding `23` to `56`
    and `23` to `35`.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you much more flexibility than the functions, but remember, all this
    will be expanded during compile time, which can make your compilation time much
    slower and the final codebase larger and slower still if the macro used duplicates
    too much code. In any case, there is more flexibility to it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, all variables have been of the `expr` kind. We have used this by declaring
    `$x:expr` and `$y:expr` but, as you can imagine, there are other kinds of macro
    variables. The list follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expr`: Expressions that you can write after an `=` sign, such as `76+4` or
    `if a==1 {"something"} else {"other thing"}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ident`: An identifier or binding name, such as `foo` or `bar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: A qualified path. This will be a path that you could write in a use
    sentence, such as `foo::bar::MyStruct` or `foo::bar::my_func`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ty`: A type, such as `u64` or `MyStruct`. It can also be a path to the type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pat`: A pattern that you can write at the left side of an `=` sign or in a
    match expression, such as `Some(t)` or `(a, b, _)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stmt`: A full statement, such as a let binding like `let a = 43;`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block`: A block element that can have multiple statements and a possible expression
    between braces, such as `{vec.push(33); vec.len()}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item`: What Rust calls *items*. For example, function or type declarations,
    complete modules, or trait definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`: A meta element, which you can write inside of an attribute (`#[]`).
    For example, `cfg(feature = "foo")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tt`: Any token tree that will eventually get parsed by a macro pattern, which
    means almost anything. This is useful for creating recursive macros, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can imagine, some of these kinds of macro variables overlap and some
    of them are just more specific than the others. The use will be verified on the
    right-hand side of the macro, in the expansion, since you might try to use a statement
    where an expression must be used, even though you might use an identifier too,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: There are some extra rules, too, as we can see in the Rust documentation ([https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements](https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements)).
    Statements and expressions can only be followed by `=>`, a comma, or a semicolon.
    Types and paths can only be followed by `=>`, the `as` or `where` keywords, or
    any commas, `=`, `|`, `;`, `:`, `>`, `[`, or `{`. And finally, patterns can only
    be followed by `=>`, the `if` or `in` keywords, or any commas, `=`, or `|`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this in practice by implementing a small `Mul` trait for a currency
    type we can create. This is an adapted example of some work we did when creating
    the Fractal Credits digital currency. In this case, we will look to the implementation
    of the `Amount` type ([https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102](https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102)),
    which represents a currency amount. Let''s start with the basic type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This amount will be divisible by up to three decimals, but it will always be
    an exact value. We should be able to add an `Amount` to the current `Amount`,
    or to subtract it. I will not explain these trivial implementations, but there
    is one implementation where macros can be of great help. We should be able to
    multiply the amount by any positive integer, so we should implement the `Mul`
    trait for `u8`, `u16`, `u32`, and `u64` types. Not only that, we should be able
    to implement the `Div` and the `Rem` traits, but I will leave those out, since
    they are a little bit more complex. You can check them in the implementation linked
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing the multiplication of an `Amount` with an integer should do
    is to multiply the value by the integer given. Let''s see a simple implementation
    for `u8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I implemented it both ways so that you can put the `Amount` to
    the left and to the right of the multiplication. If we had to do this for all
    integers, it would be a big waste of time and code. And if we had to modify one
    of the implementations (especially for `Rem` functions), it would be troublesome
    to do it in multiple code points. Let's use macros to help us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a macro, `impl_mul_int!{}`, which will receive a list of integer
    types and then implement the `Mul` trait back and forward between all of them
    and the `Amount` type. Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we specifically ask for the given elements to be types and then
    we implement the trait for all of them. So, for any code that you want to implement
    for multiple types, you might as well try this approach, since it will save you
    from writing a lot of code and it will make it more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating procedural macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen what standard macros can do for our crate. We can create complex
    compile-time code that can both reduce the verbosity of our code, making it more
    maintainable, and improve the performance of the final executable by performing
    operations at compile time instead of at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, standard macros can only do so much. With them, you can only modify
    some of the Rust grammar token processing, but you are still bound to what the
    `macro_rules!{}` macro can understand. This is where procedural macros, also known
    as macros 1.1 or custom derives, come into play.
  prefs: []
  type: TYPE_NORMAL
- en: With procedural macros, you can create libraries that will be called by the
    compiler when deriving their name in some structure or enumeration. You can effectively
    create a custom trait, `derive`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how this can be done by implementing a simple trait for a structure
    or enumeration. The trait we will be implementing is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `trait` should return the name of the current structure or enumeration
    as a string. Implementing that by hand is really easy, but it doesn't make sense
    to implement it manually, one by one, for our types. The best thing to do is to
    derive it with a procedural macro. Let's see how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create a library crate. As per convention, it should
    have the parent crate''s name and then the `-derive` suffix. In this case, we
    do not have a name for the crate, but let''s call the library `type-name-derive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a new folder next to the `src/` folder, named `type-name-derive`.
    We can now add it to the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.rs` file of our crate, we will need to add the crate and use its
    macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now start with the actual derivation development. We will need to use
    two crates—`syn` and `quote`. We will add them to the `Cargo.toml` file inside
    the `type-name-derive` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `syn` crate gives us some useful types and functions to work with the source
    tree and token streams of Rust. We need this because all our macro will see is
    a bunch of information about the source code of our structure or enumeration.
    We will need to parse it and get information from it. The `syn` crate is a `Nom`
    parser that will transform that Rust source code into something we can easily
    use.
  prefs: []
  type: TYPE_NORMAL
- en: The `quote` crate gives us the `quote!{}` macro, which we will use to implement
    the source code of our implementation directly. It basically allows us to write
    almost *normal* Rust code instead of compiler tokens to implement the trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is other extra information we will need to include in the `Cargo.toml`
    file. We need to inform cargo and the Rust compiler that this crate is a procedural
    macro crate. For that, we will need to add this to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to start with the initial schema of the `./type-name-derive/src/lib.rs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first imported the required definitions. The `proc_macro`
    crate is built in the compiler and gives us the `TokenStream` type. This type
    represents a stream of Rust tokens (characters in your source files). We then
    import the `syn` and `quote` crates. As we saw earlier, we will need to use the
    `quote!{}` macro from the quote crate, so we import the macros too.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for implementing a custom derive is really simple. We need to define
    a function with a `proc_macro_derive` attribute of the value of the trait we want
    to derive. The function will take ownership of a token stream and return another
    (or the same) token stream so that the compiler can later process the new generated
    Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the trait, I prefer to divide the token parsing and the actual
    trait implementation into two functions. For that, let''s first write the code
    inside our `type_name()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The token stream first gets converted into a `DeriveInput` structure. This structure
    contains the properly parsed data from the input token stream; deserialized into
    the information of the type here, we will add the `#[derive]` attribute. In a
    production environment, those `unwrap()` functions should probably be changed
    for `expect()`, so that we can add some text if things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we use that information to call the `impl_type_name()` function, which
    we haven't  yet defined. That function will take that information about the structure
    or enumeration and will return a series of tokens. Since we will use the quote
    crate to create those tokens, they will need to be converted into Rust compiler
    token streams later and returned to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the `impl_type_name()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this implementation is really simple. We get the name of the
    structure or enumeration from the **advanced source tree** (**AST**), and then
    use it inside the `quote!{}` macro, where we implement the `TypeName` macro for
    the structure or enumeration with that name. The `stringify!()` macro is a native
    Rust macro that gets a token and returns a compile time string representation
    of it. In this case, the `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if this works by adding some code in the `main()` function of our
    parent crate and adding a couple of types that will derive our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute `cargo run`, you will see that the output is the following,
    as one would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implementing complex derivations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `syn` and `quote` crates allow for really complex derivations. And, not
    only that, we do not necessarily need to derive a trait; we can implement any
    kind of code for the given structure or enumeration. This means that we can derive
    builder patterns, as we saw in the previous chapter, which will actually create
    a new structure or `Getters` and `Setters` for our structure.
  prefs: []
  type: TYPE_NORMAL
- en: That is what we are going to do for our next example. We will create structures
    and give them some methods to `get` and `set` the fields of the structure. In
    Rust, convention says that `Getters` should have the name of the field, without
    any prefix or a suffix such as `get`. So, for a field named `foo`, the `Getter`
    should be `foo()`. For mutable `Getters`, the function should have the `_mut`
    suffix, so in this case it would be `foo_mut()`. Setters should have the name
    of the field preceded by a `set_` prefix. So for a field named `bar`, it should
    be `set_bar()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the creation of this new `getset-derive` procedural macro crate.
    As before, remember to set the `proc_macro` variable in the `[lib]` section of
    the `Cargo.toml` file to true and to add the `syn` and `quote` crates as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add two derives, `Getters` and `Setters`. We will start with the first
    one by creating the required boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will not only need the name of the structure, we will also need any further
    generics added to the structure and `where` clauses. We didn't bother with these
    in our previous example, but we should add them in this more complex one. Gladly,
    the `syn` crate gives us all we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the next piece of code in the `impl_getters()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have a lot going on here. First, as you can see, we get the generics from
    the `ast.generics` field and we use them later in the `quote!` macro. We then
    check which type of data we have. We cannot implement getters or setters for enumerations,
    unit structs, or structures with no named fields, such as `Foo(T)`, so we panic
    in those cases. Even though it's still not possible to derive anything for unions
    yet, we can specifically filter the options with the `syn` crate, so we just add
    that for potential future changes in the language.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a structure with named fields, we get a list of the fields and,
    for each of them, we implement the getter. For that, we map them to the `generate_getter()`
    function, defined at the bottom but still unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the list of getters, we call the quote `!{}` macro to generate
    the tokens. As you can see, we add the generics for the `impl` block so that if
    we had any in the structure, such as `Bar<T, F, G>`, they would be added to the
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To add all the getters from a vector, we use the `#(#var)*` syntax and the same
    as with the `macro_rules!{}` macro, it will add one after the other. We can use
    this syntax with any type implementing the `IntoIterator` trait, in this case,
    `Vec<quote::Tokens>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we have to actually implement one getter. We have the `generate_getter()`
    function which receives a `syn::Field`, so we have all the information we need.
    The function will return `quote::Tokens`, so we will need to use the `quote!{}`
    macro inside. You can probably implement it yourself if you have been following,
    by checking the `syn` crate documentation at `docs.rs`. Let''s see how it looks
    fully implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is really simple. We get the identifier or name of the
    attribute, which should exist given that we are only implementing it for structures
    for named fields, and then get the type of the field. We then create the getter
    and return a reference to the internal data.
  prefs: []
  type: TYPE_NORMAL
- en: We could improve this further by adding exceptions for types that have their
    borrowed counterparts, such as `String` or `PathBuf`, returning `&str` and `Path`
    respectively, but I don't think it's worth it.
  prefs: []
  type: TYPE_NORMAL
- en: We could also add the documentation of the field to the generated getter. For
    that, we would use the `field.attrs` variable and get the contents of the attribute
    named `doc`, which is the one that includes the documentation text. Nevertheless,
    it's not so easy, because the name of the attribute is stored as a path and we
    would need to convert it to a string. But I invite you to try it with the `syn`
    crate documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second part of this exercise will be to implement setters for our structure.
    Usually this is done by creating a `set_{field}()` function for each field. Moreover,
    it's common practice to use generics for it so that they can be used with many
    different types. For example, for a `String` field, it would be great if we didn't
    need to always use an actual `String` type and we could use a `&str`, a `Cow<_,
    str>`, or a `Box<str>`.
  prefs: []
  type: TYPE_NORMAL
- en: We only need to declare the input as `Into<String>`. This makes things a little
    bit more complex, but our API will look much better. To implement the new setters,
    it would only mean changing a little bit of what we saw earlier and most of the
    code would be duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid that, we will use the strategy pattern so that we simply change the
    `generate_getter()` function to the `generate_setter()`, one for each field. I
    also moved the field retrieving a new function. Let''s see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better, right? It returns an iterator over the fields, which is what we
    need for our functions. We now create the method implementation function, which
    will receive a function as an argument, and will then be used for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, apart from small naming changes to make the meaning of bindings
    clearer, the only big change was to add a `FnMut` in the `where` signature of
    the function, which will be the `getter` or `setter` implementer. Therefore, to
    call this new function, we will need to change the `derive_getters()` method and
    add the new `derive_setters()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both methods are exactly the same, except that, when calling
    the `impl_methods()` function, they use a different strategy. The first one will
    generate getters and the second one setters. Finally, let''s see what the `generate_setters()`
    function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar in most aspects to the `generate_getter()` function, but
    it has some differences. First, the function name is not the same as the `name`,
    since it needs the `set_` prefix. For that, we create a string with the field
    name after it and we create an identifier with that name.
  prefs: []
  type: TYPE_NORMAL
- en: We then construct the setter by using the new function name, using a mutable
    `self` and adding a new input variable to the function, the value. Since we want
    this value to be generic, we use the `T` type that we define later in the where
    clause as being a type that can be transformed into our field type (`Into<#ty>`).
    We finally assign the converted value to our field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this getter and setter setup works by creating a short example
    in the `main.rs` file of our parent crate. We add the procedural macro dependency
    to the `Cargo.toml` file and we define a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special about it; except the `Getters` and `Setters` derive. As you
    see, we don''t need to derive an actual trait. Now, we add a simple `main()` function
    to test the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `Alice` structure and set the two fields in it. When printing
    the structure, we can see that the `Alice::x()` and `Alice::y()` getters can be
    used directly. Note that the double braces are for escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, since we have a mutable variable, we use the setters to change the values
    of the `x` and `y` fields. As you can see, we don''t have to provide a `String`
    or a `u32`; we can provide any type that can be converted directly to those without
    failing. Finally, since we implemented the `Debug` trait for `Alice`, we can print
    its contents without using the getters. The result after executing `cargo run`
    should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Procedural macros or custom derives allow for really complex code generation,
    and you can even further customize the user experience. As we saw in the previous
    chapter, with the `serde` crate we could use the `#[serde]` attribute. You can
    add custom attributes to your derive crate by defining them in the `#[proc_macro_derive]`
    attribute, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can then use them by checking the attributes of the structure/enumeration
    or its fields via the `attrs` fields in `Field`, `DeriveInput`, `Variant`, or
    `FieldValue` structures. You could, for example, let the developer decide whether
    they wanted generics in the setters or to fine-tune the attributes that should
    be generic.
  prefs: []
  type: TYPE_NORMAL
- en: Extra information can be found in the official documentation at [https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes](https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming in nightly Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have stayed in stable Rust, since it allows forward compatibility.
    There are some nightly features, though, that can help us improve our control
    over the code we generate. Nevertheless, all of them are experimental and they
    might change or even get removed before being stabilized.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should take into account that using nightly features will probably
    break your code in the future and it will take more effort to maintain it to be
    compatible with new Rust versions. Nevertheless, we will have a quick look at
    two new features that are coming to Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding compiler plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust nightly compiler accepts loading extensions, called **plugins**. They
    effectively change the way the compiler behaves, so they can modify the language
    itself. A plugin is a crate, similar to the procedural macro crate we created
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a procedural or standard macro and a plugin is that,
    while the first two modify the Rust code they are given, a plugin is able to perform
    extra computations that can greatly improve the performance of your crate.
  prefs: []
  type: TYPE_NORMAL
- en: Since these plugins get loaded inside the compiler, they will have access to
    a lot of information that standard macros don't have. Moreover, this requires
    using the `rustc` compiler and the `libsyntax` library as external crates, which
    means that you will be loading a lot of the compiler code when compiling the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, do not add your plugin as an external crate to your binaries as it
    will create a huge executable with a lot of compiler code. To use a plugin without
    adding it as a library, you will need the nightly compiler and you will have to
    add `#![feature(plugin)]` and `#![plugin({plugin_name})]` attributes to your crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing a new plugin, you will need to create the crate with some extra
    information in the `Cargo.toml` file, as we did with the procedural macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `lib.rs` file, you will need to import the required libraries
    and define the plugin registrar. The bare minimum for the plugin to work would
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Even though, in this example, the `rustc`, `syntax`, and `syntax_pos` crates
    are not being used, it's almost certain you will need them when developing the
    plugin, since they have the required types for you to change any behaviour. The
    `Registry` object lets you register multiple types of new language items, such
    as macros or syntax extensions. For each of them, you will need to define a function
    to receive the compiler tokens and modify them to produce the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: The `#![crate_type = "dylib"]` attribute tells the compiler to create a dynamic
    library with the crate, instead of the normal static one. This enables the library
    to be loaded by the compiler. The `plugin_registrar` nightly feature lets us create
    the actual plugin registrar function and the `rustc_private` feature allows us
    to use the private Rust compiler types so that we can use the compiler internals.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the only online documentation for these crates is the
    one hosted by Manish Goregaokar, but that should change soon. On his website,
    you can find the API documentation for `rustc_plugin` ([https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html](https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html)),
    for `rustc` ([https://manishearth.github.io/rust-internals-docs/rustc/index.html](https://manishearth.github.io/rust-internals-docs/rustc/index.html)),
    for `syntax` ([https://manishearth.github.io/rust-internals-docs/syntax/index.html](https://manishearth.github.io/rust-internals-docs/syntax/index.html)),
    and for `syntax_pox` ([https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html](https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html)).
    I invite you to read the API of those crates and to create small plugins for the
    compiler. Nevertheless, remember that the syntax will probably change, which makes
    it more difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing that is coming to Rust are declarative macros, macros 2.0, or
    macros by example. It's true that some call standard macros declarative macros
    too, since they are based on the same principle. But I wanted to make this difference
    known so that we learn about some improvements that these new macros will bring
    to the language.
  prefs: []
  type: TYPE_NORMAL
- en: These new macros introduce the `macro` keyword, which will work similarly to
    the `macro_rules!{}` macro, but using a syntax more close to the function syntax
    than to the current syntax. Not only that, it will also add modularization to
    macros so that you can have two macros with the same name in the same crate, as
    long as they are in different modules. This extra modularization will make integration
    between crates much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, there is still no syntax proposition for these macros, and the current
    nightly implementation is not much more than a placeholder for what is yet to
    come. I invite you to keep yourself up to date on the standardization of these
    new macros and even to define a future syntax for them by contributing to the
    community.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to create your own macros. First, we saw
    the standard macros and created some that could help you develop more quickly
    and create more efficient code. Then, you learned about procedural macros and
    how to derive your own code for your structures and enumeration. Finally, you
    found out about two features that might be coming to stable Rust in the future,
    which can currently be used in nightly Rust—plugins and declarative macros.
  prefs: []
  type: TYPE_NORMAL
- en: In the two remaining chapters, we will talk about concurrency in Rust. As you
    will see, once our single-threaded code is fast enough, the next step toward faster
    execution is to compute it in parallel.
  prefs: []
  type: TYPE_NORMAL
