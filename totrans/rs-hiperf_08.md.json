["```rs\nstruct MyData {\n    field1: String,\n    field2: u32,\n    field3: Vec<u8>,\n}\n```", "```rs\n[dependencies]\nserde = \"1.0.0\"\nserde_derive = \"1.0.0\"\n```", "```rs\nextern crate serde;\n#[macro_use]\nextern crate serde_derive;\n\n#[derive(Debug, Serialize)]\nstruct MyData {\n    field1: String,\n    field2: u32,\n    field3: Vec<u8>,\n}\n```", "```rs\nserde_json = \"1.0.0\"\n```", "```rs\nextern crate serde_json;\n\nfn main() {\n    let example = MyData {\n        field1: \"Test field\".to_owned(),\n        field2: 33_940,\n        field3: vec![65, 22, 96, 43],\n    };\n\n    let json = serde_json::to_string_pretty(&example)\n                .expect(\"could not generate JSON string\");\n    println!(\"{}\", json);\n}\n```", "```rs\n#[derive(Debug, Serialize, Deserialize)]\nstruct MyData {\n    field1: String,\n    field2: u32,\n    field3: Vec<u8>,\n}\n\nfn main() {\n    let example = MyData {\n        field1: \"Test field\".to_owned(),\n        field2: 33_940,\n        field3: vec![65, 22, 96, 43],\n    };\n\n    let json = serde_json::to_string_pretty(&example)\n                .expect(\"could not generate JSON string\");\n    println!(\"JSON:\");\n    println!(\"{}\", json);\n\n    let example_back: MyData = serde_json::from_str(&json)\n                        .expect(\"could not parse JSON string\");\n    println!(\"Back from JSON:\");\n    println!(\"{:?}\", example_back);\n}\n```", "```rs\n{\n    \"FirstData\": 56,\n    \"SecondData\": \"hello, world\",\n    \"ThirdData\": -1.23\n}\n```", "```rs\nstruct MyData {\n    first_data: u32,\n    second_data: String,\n    third_data: f32,\n}\n```", "```rs\nextern crate serde;\n#[macro_use]\nextern crate serde_derive;\nextern crate serde_json;\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"PascalCase\")]\nstruct MyData {\n    first_data: u32,\n    second_data: String,\n    third_data: f32,\n}\n\nfn main() {\n    let json = r#\"{\n        \"FirstData\": 56,\n        \"SecondData\": \"hello, world\",\n        \"ThirdData\": -1.23\n    }\"#;\n\n    let in_rust: MyData = serde_json::from_str(json)\n                            .expect(\"JSON parsing failed\");\n    println!(\"In Rust: {:?}\", in_rust);\n\n    let back_to_json = serde_json::to_string_pretty(&in_rust)\n                        .expect(\"Rust to JSON failed\");\n    println!(\"In JSON: {}\", back_to_json);\n}\n```", "```rs\n{\n    \"timestamp\": \"2018-01-16T15:43:04\",\n    \"type\": 1,\n}\n```", "```rs\n#[derive(Debug)]\nenum DateType {\n    FirstType,\n    SecondType,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct MyDate {\n    timestamp: NaiveDateTime,\n    #[serde(rename = \"type\")]\n    date_type: DateType,\n}\n```", "```rs\n[dependencies.chrono]\nversion = \"0.4.0\"\nfeatures = [\"serde\"]\n```", "```rs\nextern crate chrono;\nuse chrono::NaiveDateTime;\n```", "```rs\n#[derive(Debug, Serialize, Deserialize)]\nstruct MyDate {\n    timestamp: NaiveDateTime,\n    #[serde(rename = \"type\",\n            deserialize_with = \"deserialize_date_type\")]    \n    date_type: DateType,\n}\n```", "```rs\nuse serde::{Deserializer, Serializer};\n\nfn deserialize_date_type<'de, D>(deserializer: D)\n    -> Result<DateType, D::Error>\n    where D: Deserializer<'de>\n{\n    unimplemented!()\n}\n\nfn serialize_date_type<S>(date_type: &DateType, serializer: S)\n    -> Result<S::Ok, S::Error>\n    where S: Serializer\n{\n    unimplemented!()\n}\n```", "```rs\nfn serialize_date_type<S>(date_type: &DateType, serializer: S)\n    -> Result<S::Ok, S::Error>\n    where S: Serializer\n{\n    use serde::Serializer;\n\n    serializer.serialize_u8(match date_type {\n        DateType::FirstType => 1,\n        DateType::SecondType => 2,\n    })\n}\n```", "```rs\nfn deserialize_date_type<'de, D>(deserializer: D)\n    -> Result<DateType, D::Error>\n    where D: Deserializer<'de>\n{\n    use std::fmt;\n    use serde::Deserializer;\n    use serde::de::{self, Visitor};\n\n    struct DateTypeVisitor;\n\n    impl<'de> Visitor<'de> for DateTypeVisitor {\n        type Value = DateType;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter)\n            -> fmt::Result\n        {\n            formatter.write_str(\"an integer between 1 and 2\")\n        }\n\n        fn visit_u64<E>(self, value: u64)\n            -> Result<Self::Value, E>\n            where E: de::Error\n        {\n            match value {\n                1 => Ok(DateType::FirstType),\n                2 => Ok(DateType::SecondType),\n                _ => {\n                    let error =\n                        format!(\"type out of range: {}\", value);\n                    Err(E::custom(error))\n                }\n            }\n        }\n\n        // Similar for other methods, if you want:\n        //   - visit_i8\n        //   - visit_i16\n        //   - visit_i32\n        //   - visit_i64\n        //   - visit_u8\n        //   - visit_u16\n        //   - visit_u32\n    }\n\n    deserializer.deserialize_u64(DateTypeVisitor)\n}\n```", "```rs\nfn main() {\n    let json = r#\"{\n        \"timestamp\": \"2018-01-16T15:43:04\",\n        \"type\": 1\n    }\"#;\n\n    let in_rust: MyDate = serde_json::from_str(json)\n                            .expect(\"JSON parsing failed\");\n    println!(\"In Rust: {:?}\", in_rust);\n\n```", "```rs\n    let back_to_json = serde_json::to_string_pretty(&in_rust)\n                        .expect(\"Rust to JSON failed\");\n    println!(\"In JSON: {}\", back_to_json);\n}\n```", "```rs\nlet first_line = b\"GET /home/ HTTP/1.1\\r\\n\";\n```", "```rs\n#[macro_use]\nextern crate nom;\n\nnamed!(parse_method, \n    alt!(\n        tag!(\"GET\") |\n        tag!(\"POST\") |\n        tag!(\"PUT\") |\n        tag!(\"DELETE\")\n    )\n);\n\nfn main() {\n    let first_line = b\"GET /home/ HTTP/1.1\\r\\n\";\n    println!(\"{:?}\", parse_method(&first_line[..]));\n}\n```", "```rs\nOk(([32, 47, 104, 111, 109, 101, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], [71, 69, 84]))\n```", "```rs\nnamed!(parse_method<&[u8], &str>,\n    alt!(\n        map_res!(tag!(\"GET\"), str::from_utf8) |\n        map_res!(tag!(\"POST\"), str::from_utf8) |\n        map_res!(tag!(\"PUT\"), str::from_utf8) |\n        map_res!(tag!(\"DELETE\"), str::from_utf8)\n    )\n);\n```", "```rs\nOk(([32, 47, 104, 111, 109, 101, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], \"GET\"))\n```", "```rs\n#[derive(Debug)]\nenum Method {\n    Get,\n    Post,\n    Put,\n    Delete,\n}\n\nimpl Method {\n    fn from_bytes(b: &[u8]) -> Result<Self, String> {\n        match b {\n            b\"GET\" => Ok(Method::Get),\n            b\"POST\" => Ok(Method::Post),\n            b\"PUT\" => Ok(Method::Put),\n            b\"DELETE\" => Ok(Method::Delete),\n            _ => {\n                let error = format!(\"invalid method: {}\",\n                                    str::from_utf8(b)\n                                        .unwrap_or(\"not UTF-8\"));\n                Err(error)\n            }\n        }\n    }\n}\n\nnamed!(parse_method<&[u8], Method>,\n    alt!(\n        map_res!(tag!(\"GET\"), Method::from_bytes) |\n        map_res!(tag!(\"POST\"), Method::from_bytes) |\n        map_res!(tag!(\"PUT\"), Method::from_bytes) |\n        map_res!(tag!(\"DELETE\"), Method::from_bytes)\n    )\n);\n```", "```rs\nuse std::str;\n\n#[derive(Debug)]\nstruct Request {\n    method: Method,\n    url: String,\n    version: String,\n}\n\nnamed!(parse_request<&[u8], Request>, ws!(do_parse!(\n    method: parse_method >>\n    url: map_res!(take_until!(\" \"), str::from_utf8) >>\n    tag!(\"HTTP/\") >>\n    version: map_res!(take_until!(\"\\r\"), str::from_utf8) >>\n    (Request {\n        method,\n        url: url.to_owned(),\n        version: version.to_owned()\n    })\n)));\n\nfn main() {\n    let first_line = b\"GET /home/ HTTP/1.1\\r\\n\";\n    println!(\"{:?}\", parse_request(&first_line[..]));\n}\n```", "```rs\nOk(([], Request { method: Get, url: \"/home/\", version: \"1.1\" }))\n```", "```rs\n#[macro_use]\nextern crate lazy_static;\n\nuse std::collections::HashMap;\n\nlazy_static! {\n    static ref MY_MAP: HashMap<&'static str, &'static str> = {\n        use std::env;\n\n        let mut map = HashMap::new();\n        if let Ok(val) = env::var(\"GEN_MAP\") {\n            if val == \"true\" {\n                map.insert(\"firstKey\", \"firstValue\");\n                map.insert(\"secondKey\", \"secondValue\");\n            }\n        }\n\n        map\n    };\n}\n\nfn main() {\n    for (key, value) in MY_MAP.iter() {\n        println!(\"{}: {}\", key, value);\n    }\n}\n```", "```rs\n#[macro_use]\nextern crate derive_builder;\n\nuse std::path::PathBuf;\n\n#[derive(Default, Debug, Builder)]\n#[builder(setter(into), default)]\nstruct MyData {\n    field1: u8,\n    field2: PathBuf,\n    field3: String,\n}\n\nfn main() {\n    let data = MyDataBuilder::default()\n                .field2(\"path/to/file.png\")\n                .field3(\"Some string\")\n                .build().unwrap();\n\n    println!(\"{:?}\", data);\n}\n```", "```rs\nextern crate failure;\n\nuse std::fs::File;\nuse std::io::Read;\n\nuse failure::{Error, ResultExt};\n\nfn main() {\n    match read_file() {\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n\n            for cause in e.causes().skip(1) {\n                eprintln!(\"Caused by: {}\", cause);\n            }\n        },\n        Ok(content) => {\n            println!(\"{}…\",\n                     content.chars()\n                            .take(15)\n                            .collect::<String>());\n        }\n    }\n}\n\nfn read_file() -> Result<String, Error> {\n    let file_name = \"Cargo.toml\";\n    let mut file = File::open(file_name)\n                    .context(\"error opening the file\")?;\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)\n        .context(\"error reading the file\")?;\n\n    Ok(content)\n}\n```", "```rs\n#[macro_use]\nextern crate log;\nextern crate env_logger;\n\nfn main() {\n    env_logger::init();\n\n    trace!(\"Logging {} small thing(s)\", 1);\n    debug!(\"Some debug information:  {}\",\n            \"the answer is 42\");\n    info!(\"This is an interesting information\");\n    error!(\"An error happened, do something!\");\n}\n```", "```rs\n#[macro_use]\nextern crate clap;\n\nuse clap::{App, Arg};\n\nfn main() {\n    let matches = App::new(crate_name!())\n                    .version(crate_version!())\n                    .about(crate_description!())\n                    .author(crate_authors!())\n                    .arg(\n                       Arg::with_name(\"user\")\n                           .help(\"The user to say hello to\")\n                           .value_name(\"username\")\n                           .short(\"u\")\n                           .long(\"username\")\n                           .required(true)\n                           .takes_value(true)\n                    )\n                    .get_matches();\n\n    let user = matches.value_of(\"user\")\n            .expect(\"somehow the user did not give the username\");\n\n    println!(\"Hello, {}\", user);\n}\n```", "```rs\n[dependencies]\nmaud = \"0.17.2\n```", "```rs\n#![feature(proc_macro)]\n\nextern crate maud;\nuse maud::html;\n```", "```rs\nfn main() {\n    use maud::PreEscaped;\n\n    let user_name = \"FooBar\";\n    let markup = html! {\n        (PreEscaped(\"<!DOCTYPE html>\"))\n        html {\n            head {\n                title { \"Test website\" }\n                meta charset=\"UTF-8\";\n            }\n            body {\n                header {\n                    nav {\n                        ul {\n                            li { \"Home\" }\n                            li { \"Contact Us\" }\n                        }\n                    }\n                }\n                main {\n                    h1 { \"Welcome to our test template!\" }\n                    p { \"Hello, \" (user_name) \"!\" }\n                }\n                footer {\n                    p { \"Copyright © 2017 - someone\" }\n                }\n            }\n        }\n    };\n    println!(\"{}\", markup.into_string());\n}\n```", "```rs\ncargo install --no-default-features --features sqlite diesel_cli\n```", "```rs\nDATABASE_URL=test.sqlite\n```", "```rs\nCREATE TABLE 'users' (\n  'username' TEXT NOT NULL PRIMARY KEY,\n  'password' TEXT NOT NULL,\n  'email' TEXT UNIQUE\n);\n```", "```rs\nDROP TABLE `users`;\n```", "```rs\n[dependencies]\ndotenv = \"0.10.1\"\n\n[dependencies.diesel]\nversion = \"1.1.1\"\ndefault-features = false\nfeatures = [\"sqlite\"]\n\n[dependencies.diesel_infer_schema]\nversion = \"1.1.0\"\ndefault-features = false\nfeatures = [\"sqlite\"]\n```", "```rs\n#[macro_use]\nextern crate diesel;\n#[macro_use]\nextern crate diesel_infer_schema;\nextern crate dotenv;\n\nuse diesel::prelude::*;\nuse diesel::sqlite::SqliteConnection;\nuse dotenv::dotenv;\nuse std::env;\n\n#[derive(Debug, Queryable)]\nstruct User {\n    username: String,\n    password: String,\n    email: Option<String>,\n}\n\nfn establish_connection() -> SqliteConnection {\n dotenv().ok();\n\n let database_url = env::var(\"DATABASE_URL\")\n .expect(\"DATABASE_URL must be set\");\n SqliteConnection::establish(&database_url)\n .expect(&format!(\"error connecting to {}\", database_url))\n}\n\nmod schema {\n infer_schema!(\"dotenv:DATABASE_URL\");\n}\n```", "```rs\nfn main() {\n    use schema::users::dsl::*;\n\n    let connection = establish_connection();\n    let all_users = users\n       .load::<User>(&connection)\n       .expect(\"error loading users\");\n\n    println!(\"{:?}\", all_users);\n}\n```", "```rs\n#![feature(plugin)]\n#![plugin(rocket_codegen)]\n\nextern crate rocket;\n\n#[get(\"/\")]\nfn index() -> &'static str {\n    \"Hello, world!\"\n}\n\nfn main() {\n    rocket::ignite().mount(\"/\", routes![index]).launch();\n}\n```"]