<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor032"/>Chapter 2</em>: Building Our First Rocket Web Application</h1>
			<p>In this chapter, we're going to explore Rocket, a framework to create web applications using the Rust programming language. We will learn a little bit about Rocket before we create our first web application using the Rocket framework. After that, we will learn how to configure our Rocket web application. Finally, we will explore how to get help for this web framework at the end of this chapter.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing Rocket – a web framework written in the Rust language</li>
				<li>Creating our first Rocket web application</li>
				<li>Configuring our Rocket web application</li>
				<li>Getting help</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Technical requirements</h1>
			<p>For this and subsequent chapters, you will need to have the requirements mentioned in <a href="B16825_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the Rust Language</em>, and the Rust toolchain installed. If you still don't have the Rust compiler toolchain installed, please follow the installation guide in <a href="B16825_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the Rust Language</em>. Also, it would be helpful to have a text editor with a Rust extension installed and Rust tools such as <strong class="source-inline">rustfmt</strong> or <strong class="source-inline">clippy</strong>. If you don't have a text editor installed already, you can use open source software such as Visual Studio Code with the <strong class="source-inline">rust-analyzer</strong> extension. As we're going to make HTTP requests to the application that we're going to create, you should have a web browser or other HTTP client installed.</p>
			<p>Finally, the Rocket framework has a few releases, all of which are slightly different. We will only be discussing Rocket <em class="italic">0.5.0</em>. Don't worry if you are planning to use a different version of Rocket, as the terminology and concepts are almost the same. Use the API documentation mentioned in the <em class="italic">Getting help</em> section of this chapter to see the correct documentation for your Rocket framework version.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Introducing Rocket – a web framework written in the Rust language</h1>
			<p>The development of the Rocket web framework<a id="_idIndexMarker086"/> began as a project of Sergio Benitez in 2016. For a long time, it was being created with a lot of Rust macrosystems to simplify the development process; because of this, a stable Rust compiler could not be used until recently, in 2021. During the development process, async/await capabilities were added to Rust. Rocket began to incorporate async/await until the issue tracker for it closed in 2021.</p>
			<p>Rocket is a fairly simple web framework without many bells and whistles, such as database <strong class="bold">Object-relational mapping</strong> (<strong class="bold">ORM</strong>) or mailing systems. Programmers can extend Rocket's capabilities using other Rust crates, for example, by adding third-party logging or connecting to memory store applications.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>The HTTP request life cycle in Rocket</h2>
			<p>Handling HTTP requests is an integral part<a id="_idIndexMarker087"/> of web applications. The Rocket web framework<a id="_idIndexMarker088"/> treats incoming HTTP requests as a life cycle. The first thing the web application does is checks and determines which function<a id="_idIndexMarker089"/> or functions will be able to handle the incoming request. This part is called <strong class="bold">routing</strong>. For example, if there's a <em class="italic">GET/something</em> incoming request, Rocket will check all the registered routes for matches.</p>
			<p>After routing, Rocket will perform the <strong class="bold">validation</strong> of the incoming request<a id="_idIndexMarker090"/> against types and guards declared in the first function. If the result does not match and the next route handling function is available, Rocket will continue validation against the next function until there are no more functions available to handle that incoming request.</p>
			<p>After validation, Rocket<a id="_idIndexMarker091"/> will then <strong class="bold">process</strong> with what the programmer wrote in the body of the function. For example, a programmer creates a SQL query with the data from the request, sends the query to the database, retrieves the result from the database, and creates an HTML using the result.</p>
			<p>Rocket will finally return a <strong class="bold">response</strong>, which contains the HTTP status, headers, and body. The request<a id="_idIndexMarker092"/> life cycle is then complete.</p>
			<p>To recap, the life cycle<a id="_idIndexMarker093"/> of a Rocket request is <strong class="bold">Routing → Validation → Processing → Response</strong>. Next, let's discuss how the Rocket application starts.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Rocket launch sequence</h2>
			<p>Like a real-life rocket, we start <a id="_idIndexMarker094"/>by building the Rocket application. In the building process, we mount the <strong class="bold">routes</strong> (functions that handle incoming requests) to<a id="_idIndexMarker095"/> the Rocket application.</p>
			<p>In the building process, the Rocket application<a id="_idIndexMarker096"/> also manages various <strong class="bold">states</strong>. A state is a Rust object that can be accessed in a route handler. For example, let's say we want a logger that sends events to a logging server. We initialize the logger object when we build the Rocket application, and when there's an incoming request, we can use the already managed logger object in the request handler.</p>
			<p>Still in the building process, we can also attach <strong class="bold">fairings</strong>. In many web frameworks, there is usually a middleware<a id="_idIndexMarker097"/> component that filters, inspects, authorizes, or modifies incoming HTTP requests or responses. In the Rocket framework, the function that provides<a id="_idIndexMarker098"/> middleware functionality is called a fairing. For<a id="_idIndexMarker099"/> example, if we want to have a <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>) for every HTTP request for audit purposes, we first create a fairing that generates a random UUID and appends it to the request HTTP header. We also make the fairing append the same UUID to the generated HTTP response. Next, we attach it to Rocket. This fairing will then intercept the incoming request and response and modify it.</p>
			<p>After the Rocket application<a id="_idIndexMarker100"/> is built and ready, the next step is, of course, launching it. Yay, the launch is successful! Now, our Rocket application is operational and ready to serve incoming requests.</p>
			<p>Now that we have an overview of the Rocket application, let's try creating a simple Rocket application.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Creating our first Rocket web application</h1>
			<p>In this section, we are going<a id="_idIndexMarker101"/> to create a very simple web application that handles only one HTTP path. Follow these steps to create our first Rocket web application:</p>
			<ol>
				<li>Create a new Rust application using Cargo:<p class="source-code"><strong class="bold">cargo new 01hello_rocket --name hello_rocket</strong></p></li>
			</ol>
			<p>We are creating an application named <strong class="source-inline">hello_rocket</strong> in a folder named <strong class="source-inline">01hello_rocket</strong>.</p>
			<ol>
				<li value="2">After that, let's modify the <strong class="source-inline">Cargo.toml</strong> file. Add the following line after <strong class="source-inline">[dependencies]</strong>:<p class="source-code">rocket = "0.5.0-rc.1"</p></li>
				<li>Append the following lines at the top of the <strong class="source-inline">src/main.rs</strong> file:<p class="source-code">#[macro_use]</p><p class="source-code">extern crate rocket;</p></li>
			</ol>
			<p>Here, we are telling the Rust compiler to use macros from the Rocket crate by using the <strong class="source-inline">#[macro_use]</strong> attribute. We can skip using that attribute, but that would mean we must specify <strong class="source-inline">use</strong> for every single macro that we are going to use.</p>
			<ol>
				<li value="4">Add the following line to tell the compiler that we are using the definition from the Rocket crate:<p class="source-code">use rocket::{Build, Rocket};</p></li>
				<li>After that, let's create our first HTTP handler. Add the following lines after the preceding ones:<p class="source-code">#[get("/")]</p><p class="source-code">fn index() -&gt; &amp;'static str {</p><p class="source-code">    "Hello, Rocket!"</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we define a function<a id="_idIndexMarker102"/> that returns a reference to a <strong class="source-inline">str</strong>. The <strong class="source-inline">'a</strong> in the Rust language means that a variable has a <strong class="source-inline">'a</strong> lifetime. The life span of a reference depends on many things. We will discuss these in <a href="B16825_09_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 9</em></a>, <em class="italic">Displaying User's Post</em>, when we discuss object scope and lifetime in more depth. But, a <strong class="source-inline">'static</strong> notation is special because it means that it will last as long as the application is still alive. We can also see that the return value is <strong class="source-inline">"Hello, Rocket"</strong> since it is the last line and we did not put a semicolon at the end.</p>
			<p>But, what is the <strong class="source-inline">#[get("/")]</strong> attribute? Remember before when we used the <strong class="source-inline">#[macro_use]</strong> attribute? The <strong class="source-inline">rocket::get</strong> attribute is a macro attribute that specifies the HTTP method a function handles, and the route, HTTP paths, and parameters it handles. There are seven method-specific route attributes that we can use: <strong class="source-inline">get</strong>, <strong class="source-inline">put</strong>, <strong class="source-inline">post</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">head</strong>, <strong class="source-inline">options</strong>, and <strong class="source-inline">patch</strong>. All of them correspond to their respective HTTP method name.</p>
			<p>We can also use alternate macros to specify route handlers by replacing the attribute macro with the following:</p>
			<p class="source-code">#[route(GET, path = "/")]</p>
			<ol>
				<li value="6">Next, delete the <strong class="source-inline">fn main()</strong> function and add the following lines:<p class="source-code">#[launch]</p><p class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</p><p class="source-code">    rocket::build().mount("/", routes![index])</p><p class="source-code">}</p></li>
			</ol>
			<p>We have created a function that will generate the <strong class="source-inline">main</strong> function because we used the <strong class="source-inline">#[launch]</strong> attribute. Inside the function, we built the Rocket and mounted the routes that have an <strong class="source-inline">index</strong> function to the <strong class="source-inline">"/"</strong> path.</p>
			<ol>
				<li value="7">Let's try running<a id="_idIndexMarker103"/> the <strong class="source-inline">hello_rocket</strong> application:<p class="source-code"><strong class="bold">&gt; cargo run</strong></p><p class="source-code"><strong class="bold">   Updating crates.io index</strong></p><p class="source-code"><strong class="bold">   Compiling proc-macro2 v1.0.28</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">   Compiling hello_rocket v0.1.0 (/Users/karuna/</strong></p><p class="source-code"><strong class="bold">   Chapter02/01hello_rocket)</strong></p><p class="source-code"><strong class="bold">    Finished dev [unoptimized + debuginfo] target(s) </strong></p><p class="source-code">    <strong class="bold">in 1m 39s</strong></p><p class="source-code"><strong class="bold">     Running `target/debug/hello_rocket`</strong></p><p class="source-code"><strong class="bold"><img src="image/01.png" alt=""/> Configured for debug.</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; address: 127.0.0.1</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; port: 8000</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; workers: 8</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; ident: Rocket</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; keep-alive: 5s</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; limits: bytes = 8KiB, data-form = 2MiB, file = </strong></p><p class="source-code"><strong class="bold">   1MiB, form = 32KiB, json = 1MiB, msgpack = 1MiB, </strong></p><p class="source-code"><strong class="bold">   string = 8KiB</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; tls: disabled</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; temp dir: /var/folders/gh/</strong></p><p class="source-code"><strong class="bold">   kgsn28fn3hvflpcfq70x6f1w0000gp/T/</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; log level: normal</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; cli colors: true</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; shutdown: ctrlc = true, force = true, signals = </strong></p><p class="source-code"><strong class="bold">   [SIGTERM], grace = 2s, mercy = 3s</strong></p><p class="source-code"><strong class="bold"><img src="image/04.png" alt=""/>  Routes:</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; (index) GET /</strong></p><p class="source-code"><strong class="bold"><img src="image/02.png" alt=""/> Fairings:</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; Shield (liftoff, response, singleton)</strong></p><p class="source-code"><strong class="bold"><img src="image/05.png" alt=""/> Shield:</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; X-Content-Type-Options: nosniff</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; X-Frame-Options: SAMEORIGIN</strong></p><p class="source-code"><strong class="bold">   &gt;&gt; Permissions-Policy: interest-cohort=()</strong></p><p class="source-code"><strong class="bold"><img src="image/03.png" alt=""/> Rocket has launched from http://127.0.0.1:8000</strong></p></li>
			</ol>
			<p>You can see the application<a id="_idIndexMarker104"/> printed the application configuration, such as keep-alive timeout duration, request size limits, log level, routes, and many more that you typically see in an HTTP server to the terminal. After that, the application printed the various parts of the Rocket. We created a single-route <strong class="source-inline">index</strong> function, which handles <strong class="source-inline">GET /</strong>.</p>
			<p>Then, there is the default built-in fairing, <strong class="bold">Shield</strong>. Shield works by injecting<a id="_idIndexMarker105"/> HTTP security and privacy headers to all responses by default.</p>
			<p>We also see that the application was successfully launched and is now accepting requests on the address <strong class="source-inline">127.0.0.1</strong> and port <strong class="source-inline">8000</strong>.</p>
			<ol>
				<li value="8">Now, let's test whether the application is really accepting requests. You can use a web browser or any HTTP client since it's a very simple request, but if you use the command line, don't stop the running application; open another terminal:<p class="source-code"><strong class="bold">&gt; curl http://127.0.0.1:8000</strong></p><p class="source-code"><strong class="bold">Hello, Rocket!</strong></p></li>
			</ol>
			<p>You can see that the application responded perfectly. You can also see the log of the application:</p>
			<p class="source-code"><strong class="bold">GET /:</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; Matched: (index) GET /</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; Outcome: Success</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; Response succeeded.</strong></p>
			<ol>
				<li value="9">Now, let's try requesting<a id="_idIndexMarker106"/> something that does not exist in our application:<p class="source-code"><strong class="bold">&gt; curl http://127.0.0.1:8000/somepath</strong></p><p class="source-code"><strong class="bold">&lt;!DOCTYPE html&gt;</strong></p><p class="source-code"><strong class="bold">&lt;html lang="en"&gt;</strong></p><p class="source-code"><strong class="bold">&lt;head&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;meta charset="utf-8"&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;title&gt;404 Not Found&lt;/title&gt;</strong></p><p class="source-code"><strong class="bold">&lt;/head&gt;</strong></p><p class="source-code"><strong class="bold">&lt;body align="center"&gt;</strong></p><p class="source-code"><strong class="bold">    …</strong></p><p class="source-code"><strong class="bold">&lt;/body&gt;</strong></p><p class="source-code"><strong class="bold">&lt;/html&gt;</strong></p></li>
			</ol>
			<p>Now, let's see what's going on in the application terminal output:</p>
			<p class="source-code"><strong class="bold">GET /somepath:</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; No matching routes for GET /somepath.</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; No 404 catcher registered. Using Rocket default.</strong></p>
			<p class="source-code"><strong class="bold">   &gt;&gt; Response succeeded.</strong></p>
			<p>We now know that Rocket already has default handlers for <strong class="source-inline">404</strong> status situations.</p>
			<p>Let's recall the Rocket life cycle, <em class="italic">Routing → Validation → Processing → Response</em>. The first request to http://127<strong class="source-inline">.0.0.1:8000/</strong> was successful because the application found the handler for the <strong class="source-inline">GET /</strong> route. Since we didn't create any validation in the application, the function<a id="_idIndexMarker107"/> then performed some very simple processing, returning a string. The Rocket framework already implemented the <strong class="source-inline">Responder</strong> trait for <strong class="source-inline">&amp;str</strong>, so it created and returned an appropriate HTTP response. The other request to <strong class="source-inline">/somepath</strong> did not pass the routing part, and we did not create any error handler, so the Rocket application returned a default error handler for this request.</p>
			<p>Try opening it in the browser and inspecting the response using developer tools, or try running the <strong class="source-inline">curl</strong> command again in verbose mode to see the complete HTTP response, <strong class="source-inline">curl -v </strong>http://127<strong class="source-inline">.0.0.1:8000/</strong> and <strong class="source-inline">curl -v http://127.0.0.1:8000/somepath</strong>:</p>
			<p class="source-code">$ curl -<strong class="bold">v http://127</strong><strong class="bold">.0.0</strong>.1:8000/somepath</p>
			<p class="source-code">*   Trying 127.0.0.1...</p>
			<p class="source-code">* TCP_NODELAY set</p>
			<p class="source-code">* Connected to 127.0.0.1 (127.0.0.1) port 8000 (#0)</p>
			<p class="source-code">&gt; GET /somepath HTTP/1.1</p>
			<p class="source-code">&gt; Host: 127.0.0.1:8000</p>
			<p class="source-code">&gt; User-Agent: curl/7.64.1</p>
			<p class="source-code">&gt; Accept: */*</p>
			<p class="source-code">&gt; </p>
			<p class="source-code">&lt; HTTP/1.1 404 Not Found</p>
			<p class="source-code">&lt; content-type: text/html; charset=utf-8</p>
			<p class="source-code">&lt; server: Rocket</p>
			<p class="source-code">&lt; x-frame-options: SAMEORIGIN</p>
			<p class="source-code">&lt; x-content-type-options: nosniff</p>
			<p class="source-code">&lt; permissions-policy: interest-cohort=()</p>
			<p class="source-code">&lt; content-length: 383</p>
			<p class="source-code">&lt; date: Fri, 17 Aug 1945 03:00:00 GMT</p>
			<p class="source-code">&lt; </p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">...</p>
			<p class="source-code">* Connection #0 to host 127.0.0.1 left intact</p>
			<p class="source-code">&lt;/html&gt;* Closing connection 0</p>
			<p>You can see that access to <strong class="source-inline">/</strong> worked perfectly and access to <strong class="source-inline">/somepath</strong> returned an HTTP response with a <strong class="source-inline">404</strong> status and with some HTML content. There are some default privacy and security HTTP headers too, which were injected by the Shield fairing.</p>
			<p>Congratulations! You just created<a id="_idIndexMarker108"/> your first Rocket-powered web application. What you just built is a regular Rocket web application. Next, let's modify it to be an asynchronous web application.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>An asynchronous application</h2>
			<p>What is an asynchronous<a id="_idIndexMarker109"/> application? Let's say our web <a id="_idIndexMarker110"/>application is sending a query to a database. While waiting for the response for a few milliseconds, our application thread is just doing nothing. For a single user and a single request, this is not a problem. An asynchronous application is an application that allows a processor to do other tasks while there are blocking tasks, such as waiting for the response from the database. We will discuss this in detail later; right now, we just want to convert our application into an asynchronous application.</p>
			<p>Let's modify the application that we created earlier and make it asynchronous. You can find the example folder in <strong class="source-inline">02hello_rocket_async</strong>: </p>
			<ol>
				<li value="1">Remove the <strong class="source-inline">use rocket::{Build, Rocket};</strong> line, since we are not going to use it.</li>
				<li>After that, let's add the <strong class="source-inline">async</strong> keyword before <strong class="source-inline">fn index()</strong>.</li>
				<li>Replace the <strong class="source-inline">#[launch]</strong> attribute with <strong class="source-inline">#[rocket::main]</strong>. This is to signify that this function is going to be the main function in our application.</li>
				<li>Add the <strong class="source-inline">async</strong> keyword and rename <strong class="source-inline">fn launch()</strong> to <strong class="source-inline">fn main()</strong>.</li>
				<li>We also don't want<a id="_idIndexMarker111"/> the main function<a id="_idIndexMarker112"/> to return anything, so use <strong class="source-inline">remove -&gt; Rocket&lt;build&gt;</strong>.</li>
				<li>Add <strong class="source-inline">.launch().await;</strong> after calling <strong class="source-inline">mount</strong>.</li>
			</ol>
			<p>The final code should look like this:</p>
			<pre class="source-code">#[macro_use]</pre>
			<pre class="source-code">extern crate rocket;</pre>
			<pre class="source-code">#[get("/")]</pre>
			<pre class="source-code">async fn index() -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "Hello, Rocket!"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[rocket::main]</pre>
			<pre class="source-code">async fn main() {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![</pre>
			<pre class="source-code">    index]).launch().await;</pre>
			<pre class="source-code">}</pre>
			<p>Stop the old version from running on the server by using the <em class="italic">Ctrl</em> + <em class="italic">C</em> command. You should see something like this: </p>
			<p class="source-code">Warning: Received SIGINT. Requesting shutdown.</p>
			<p class="source-code">Received shutdown request. Waiting for pending I/O...</p>
			<p>We don't have any blocking<a id="_idIndexMarker113"/> task in our <strong class="source-inline">"/"</strong> handler right now, so we will not<a id="_idIndexMarker114"/> see any noticeable benefit. Now that we have created our application, let's configure it in the next section.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Configuring our Rocket web application</h1>
			<p>Let's learn how to configure<a id="_idIndexMarker115"/> our Rocket web application, starting with different profiles for different situations. Then, we will use the <strong class="source-inline">Rocket.toml</strong> file to configure it. And finally, we will learn how to use environment variables to configure our application.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Starting the Rocket application in different profiles</h2>
			<p>Let's run our synchronous<a id="_idIndexMarker116"/> application server without a release flag, and in another terminal, let's see whether we can benchmark it:</p>
			<ol>
				<li value="1">First, let's install the application using <strong class="source-inline">cargo install benchrs</strong>. That's right, you can install the application using Cargo too! There are very good Rust programs that you can use in your terminal, for example, <strong class="source-inline">ripgrep</strong>, which is one of the fastest applications for grepping string in your code.</li>
			</ol>
			<p>If you want to call the Cargo-installed application, you can use the full path or add it to your terminal path if you are using a Unix-based terminal. Append the following line to your <strong class="source-inline">~/.profile</strong> or any other profile file that will be loaded by your terminal:</p>
			<p class="source-code">export PATH="$HOME/.cargo/bin:$PATH"</p>
			<p>Rustup should already have added Cargo's <strong class="source-inline">bin</strong> folder to your path if you are using Windows.</p>
			<ol>
				<li value="2">Run the benchmark against your running application:<p class="source-code"><strong class="bold">benchrs -c 30 -n 3000 -k </strong>http://127<strong class="bold">.0.0.1:8000/</strong></p><p class="source-code"><strong class="bold">07:59:04.934 [INFO] benchrs:0.1.8</strong></p><p class="source-code"><strong class="bold">07:59:04.934 [INFO] Spawning 8 threads</strong></p><p class="source-code"><strong class="bold">07:59:05.699 [INFO] Ran in 0.7199552s 30 connections, 3000 requests with avg request time: 6.5126667ms, median: 6ms, 95th percentile: 11ms and 99th percentile: 14ms</strong></p></li>
			</ol>
			<p>You can see that our application handles around 3,000 requests in <strong class="source-inline">0.7199552</strong> seconds. Not a bad<a id="_idIndexMarker117"/> value for a simple application if we compare it to other heavy frameworks. After that, stop the application for now.</p>
			<ol>
				<li value="3">Now, let's run the application again but this time in release mode. Do you still remember how to do it from the previous chapter?<p class="source-code"><strong class="bold">&gt; cargo run –release</strong></p></li>
			</ol>
			<p>It should then compile our application for release and run it.</p>
			<ol>
				<li value="4">After the application is ready to accept the request again, in another terminal, run the benchmark again:<p class="source-code"><strong class="bold">$ benchrs -c 30 -n 3000 -k </strong>http://127<strong class="bold">.0.0.1:8000/</strong></p><p class="source-code"><strong class="bold">08:12:51.388 [INFO] benchrs:0.1.8</strong></p><p class="source-code"><strong class="bold">08:12:51.388 [INFO] Spawning 8 threads</strong></p><p class="source-code"><strong class="bold">08:12:51.513 [INFO] Ran in 0.07942524s 30 connections, 3000 requests with avg request time: 0.021333333ms, median: 0ms, </strong></p><p class="source-code"><strong class="bold">5th percentile: 0ms and 99th percentile: 1ms</strong></p></li>
			</ol>
			<p>Again, the result is very impressive, but what's going on here? The total benchmark time now becomes roughly 0.08 seconds, almost 10 times faster than the previous total benchmark time.</p>
			<p>To understand the reason<a id="_idIndexMarker118"/> for the speed increase, we need to know about Rocket <strong class="bold">profiles</strong>. A profile is a name we give for a set of configurations.</p>
			<p>Rocket application has two meta-profiles: <strong class="bold">default</strong> and <strong class="bold">global</strong>. The default profile has all the default<a id="_idIndexMarker119"/> configuration values. If we create<a id="_idIndexMarker120"/> a profile and do not set the values of its configuration, the values from the default configuration will be used. As for the global profile, if we set the configuration values, then it will override the values set in a profile.</p>
			<p>Besides those two meta-profiles, the Rocket framework also provides two configurations. When running<a id="_idIndexMarker121"/> or compiling the application in release<a id="_idIndexMarker122"/> mode, Rocket will use the <strong class="bold">release</strong> profile, and while running or compiling<a id="_idIndexMarker123"/> in debug mode, Rocket will select the <strong class="bold">debug</strong> profile. Running the application in release mode will obviously generate an optimized executable binary, but there are other optimizations in the application itself. For example, you will see the difference in the application output. The debug profile by default shows the output on the terminal, but the release profile by default will not show any request in the terminal output.</p>
			<p>We can create any name for a profile, for example, <strong class="source-inline">development</strong>, <strong class="source-inline">test</strong>, <strong class="source-inline">staging</strong>, <strong class="source-inline">sandbox</strong>, or <strong class="source-inline">production</strong>. Use any name that makes sense to your development process. For example, in a machine used for QA testing, you might want to give the profile the name <strong class="source-inline">testing</strong>.</p>
			<p>To choose which profile we want to use, we can specify it in the environment variable. Use <strong class="source-inline">ROCKET_PROFILE=profile_name cargo run</strong> in the command line. For example, you can write <strong class="source-inline">ROCKET_PROFILE=profile_name cargo run –release</strong>.</p>
			<p>Now that we know how to start the application with a certain profile, let's learn how to create a profile and configure the Rocket application.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Configuring the Rocket web application</h2>
			<p>Rocket has a way to configure<a id="_idIndexMarker124"/> web applications. The web framework uses the <strong class="bold">figment</strong> crate (<a href="https://crates.io/crates/figment">https://crates.io/crates/figment</a>) <a id="_idIndexMarker125"/>for configuration. There are many<a id="_idIndexMarker126"/> providers (that is, types that implement a <strong class="source-inline">Provider</strong> trait). Someone can make a type that reads JSON from a file and implements a <strong class="source-inline">Provider</strong> trait for that type. That type can then be consumed by an application that uses the figment crate as the source of the configuration.</p>
			<p>In Rust, there's a convention to initialize a struct with a default value if it implements a standard library trait, <strong class="source-inline">std::default::Default</strong>. That trait is written as follows:</p>
			<pre class="source-code">pub trait Default {</pre>
			<pre class="source-code">    fn default() -&gt; Self;</pre>
			<pre class="source-code">}</pre>
			<p>For example, a struct named <strong class="source-inline">StructName</strong>, which implements the <strong class="source-inline">Default</strong> trait, will then be called <strong class="source-inline">StructName::default()</strong>. Rocket has a <strong class="source-inline">rocket::Config</strong> struct that implements the <strong class="source-inline">Default</strong> trait. The default value<a id="_idIndexMarker127"/> is then used to configure the application.</p>
			<p>If you look at the source for the <strong class="source-inline">rocket::Config</strong> struct, it is written as follows:</p>
			<pre class="source-code">pub struct Config {</pre>
			<pre class="source-code">    pub profile: Profile,</pre>
			<pre class="source-code">    pub address: IpAddr,</pre>
			<pre class="source-code">    pub port: u16,</pre>
			<pre class="source-code">    pub workers: usize,</pre>
			<pre class="source-code">    pub keep_alive: u32,</pre>
			<pre class="source-code">    pub limits: Limits,</pre>
			<pre class="source-code">    pub tls: Option&lt;TlsConfig&gt;,</pre>
			<pre class="source-code">    pub ident: Ident,</pre>
			<pre class="source-code">    pub secret_key: SecretKey,</pre>
			<pre class="source-code">    pub temp_dir: PathBuf,</pre>
			<pre class="source-code">    pub log_level: LogLevel,</pre>
			<pre class="source-code">    pub shutdown: Shutdown,</pre>
			<pre class="source-code">    pub cli_colors: bool,</pre>
			<pre class="source-code">    // some fields omitted</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, there are fields such as <strong class="source-inline">address</strong> and <strong class="source-inline">port</strong>, which will obviously dictate how the application behaves. If you check further in the source code, you can see the <strong class="source-inline">Default</strong> trait implementation for the <strong class="source-inline">Config</strong> struct.</p>
			<p>Rocket also has a couple of figment providers that override the default <strong class="source-inline">rocket::Config</strong> value when we use the <strong class="source-inline">rocket::build()</strong> method in our application.</p>
			<p>The first figment provider<a id="_idIndexMarker128"/> reads from the <strong class="source-inline">Rocket.toml</strong> file, or the file that we specify if we run the application with the <strong class="source-inline">ROCKET_CONFIG</strong> environment variable. If we specify <strong class="source-inline">ROCKET_CONFIG</strong> (for example, <strong class="source-inline">ROCKET_CONFIG=our_config.toml</strong>), it will search <strong class="source-inline">our_config.toml</strong> at the root directory of the application. If the application cannot find that configuration file, then the application will look in the parent folder until it reaches the root of the filesystem. If we specify an absolute path, for example, <strong class="source-inline">ROCKET_CONFIG=/some/directory/our_config.toml</strong>, then the application will only search for the file in that location.</p>
			<p>The second figment provider reads the value from Environment variables. We will see how to do it later, but first, let's try configuring the Rocket application using the <strong class="source-inline">Rocket.toml</strong> file.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Configuring the Rocket application using Rocket.toml</h2>
			<p>The first thing we need to know<a id="_idIndexMarker129"/> is the list of keys we can use<a id="_idIndexMarker130"/> in the configuration file. These are the keys that we can use in the configuration file:</p>
			<ul>
				<li><strong class="source-inline">address</strong>: The application will serve at this address.</li>
				<li><strong class="source-inline">port</strong>: The application will serve on this port.</li>
				<li><strong class="source-inline">workers</strong>: The application will use this number of threads.</li>
				<li><strong class="source-inline">ident</strong>: If we specify <strong class="source-inline">false</strong>, the application will not put an identity in the server HTTP header; if we specify <strong class="source-inline">string</strong>, the application will use it as an identity in the server HTTP header.</li>
				<li><strong class="source-inline">keep_alive</strong>: Keep-alive timeout in seconds. Use <strong class="source-inline">0</strong> to disable <strong class="source-inline">keep_alive</strong>.</li>
				<li><strong class="source-inline">log_level</strong>: The maximum level to log (off/normal/debug/critical).</li>
				<li><strong class="source-inline">temp_dir</strong>: The path to a directory to store temporary files.</li>
				<li><strong class="source-inline">cli_colors</strong>: Use colors and emojis on the log, or not. This is useful to disable bells and whistles in the release environment.</li>
				<li><strong class="source-inline">secret_key</strong>: The Rocket application<a id="_idIndexMarker131"/> has a type to store private cookies<a id="_idIndexMarker132"/> in the application. The private cookies are encrypted by this key. The key length is 256 bits, and you can generate it using tools such as <strong class="source-inline">openssl rand -base64 32</strong>. Since this is an important key, you might want to keep it in a safe place.</li>
				<li><strong class="source-inline">tls</strong>: Use <strong class="source-inline">tls.key</strong> and <strong class="source-inline">tls.certs</strong> to enter the path to your TLS (Transport Layer Security) key and certificate file.</li>
				<li><strong class="source-inline">limits</strong>: This configuration is nested and is used to limit the server read size. You can write the value in multibyte units such as 1 MB (megabyte) or 1 MiB (mebibyte). There are several default options:<ul><li><strong class="source-inline">limits.form</strong> – 32 KiB</li><li><strong class="source-inline">limits.data-form</strong> – 2 MiB</li><li><strong class="source-inline">limits.file</strong> – 1 MiB</li><li><strong class="source-inline">limits.string</strong> – 8 KiB</li><li><strong class="source-inline">limits.bytes</strong> – 8 KiB</li><li><strong class="source-inline">limits.json</strong> – 1 MiB</li><li><strong class="source-inline">limits.msgpack</strong> – 1 MiB</li></ul></li>
				<li><strong class="source-inline">shutdown</strong>: If a web application is terminated abruptly when it's still processing something, the data being processed might accidentally get corrupted. For example, let's say a Rocket application is in the middle of sending updated data to the database server, but the process is then terminated suddenly. As a result, there is data inconsistency. This option configures Rocket's smooth shutdown behavior. Like <strong class="source-inline">limits</strong>, it has several subconfigurations:<ul><li><strong class="source-inline">shutdown.ctrlc</strong> – Does the application ignore the <em class="italic">Ctrl</em> + <em class="italic">C</em> keystrokes or not?</li><li><strong class="source-inline">shutdown.signals</strong> – An array of Unix signals that trigger a shutdown. Only works on Unix or Unix-like operating systems.</li><li><strong class="source-inline">shutdown.grace</strong> – The number of seconds in which to finish outstanding server I/O before stopping it.</li><li><strong class="source-inline">shutdown.mercy</strong> – The number of seconds in which to finish outstanding connection I/O before stopping it.</li><li><strong class="source-inline">shutdown.force</strong> – Specifies whether or not to kill a process that refuses to cooperate.</li></ul></li>
			</ul>
			<p>Now that we know what keys<a id="_idIndexMarker133"/> we can use, let's try configuring<a id="_idIndexMarker134"/> our application. Remember what port our application is running on? Suppose now we want to run the application on port <strong class="source-inline">3000</strong>. Let's create a <strong class="source-inline">Rocket.toml</strong> file in the root folder of our application:</p>
			<pre class="source-code">[default]</pre>
			<pre class="source-code">port = 3000</pre>
			<p>Now, try running the application again:</p>
			<p class="source-code">$ cargo run</p>
			<p class="source-code">...</p>
			<p class="source-code"><img src="image/031.png" alt=""/> Rocket has launched from http://127.0.0.1:3000</p>
			<p>You can see that it's working; we're running the application in port <strong class="source-inline">3000</strong>. But, what if we want to run the application in a different configuration for a different profile? Let's try adding these lines in the <strong class="source-inline">Rocket.toml</strong> file and running the application in release mode:</p>
			<pre class="source-code">[release]</pre>
			<pre class="source-code">port = 9999</pre>
			<p class="source-code">$ cargo run --release</p>
			<p class="source-code">...</p>
			<p class="source-code"><img src="image/031.png" alt=""/> Rocket has launched from http://127.0.0.1:9999</p>
			<p>That's right, we can specify<a id="_idIndexMarker135"/> the configuration for a different profile. What<a id="_idIndexMarker136"/> do we do if our option is nested? Because this file is a <strong class="source-inline">.toml</strong> file, we can write it as follows:</p>
			<pre class="source-code">[default.tls]</pre>
			<pre class="source-code">certs = "/some/directory/cert-chain.pem"</pre>
			<pre class="source-code">key = "/some/directory/key.pem"</pre>
			<p>Or, we can write it in the following way:</p>
			<pre class="source-code">[default]</pre>
			<pre class="source-code">tls = { certs = "/some/directory/cert-chain.pem", key = "/some/directory/key.pem" }</pre>
			<p>Now, let's see the whole file with the default configuration:</p>
			<pre class="source-code">[default]</pre>
			<pre class="source-code">address = "127.0.0.1"</pre>
			<pre class="source-code">port = 8000</pre>
			<pre class="source-code">workers = 16</pre>
			<pre class="source-code">keep_alive = 5</pre>
			<pre class="source-code">ident = "Rocket"</pre>
			<pre class="source-code">log_level = "normal"</pre>
			<pre class="source-code">temp_dir = "/tmp"</pre>
			<pre class="source-code">cli_colors = true</pre>
			<pre class="source-code">## Please do not use this key, but generate your own with `openssl rand -base64 32`</pre>
			<pre class="source-code">secret_key = " BCbkLMhRRtYMerGKCcboyD4Mhf6/XefvhW0Wr8Q0s1Q="</pre>
			<pre class="source-code">[default.limits]</pre>
			<pre class="source-code">form = "32KiB"</pre>
			<pre class="source-code">data-form = "2MiB"</pre>
			<pre class="source-code">file = "1MiB"</pre>
			<pre class="source-code">string = "8KiB"</pre>
			<pre class="source-code">bytes = "8KiB"</pre>
			<pre class="source-code">json = "1MiB"</pre>
			<pre class="source-code">msgpack = "1MiB"</pre>
			<pre class="source-code">[default.tls]</pre>
			<pre class="source-code">certs = "/some/directory/cert-chain.pem</pre>
			<pre class="source-code">key = "/some/directory/key.pem</pre>
			<pre class="source-code">[default.shutdown]</pre>
			<pre class="source-code">ctrlc = true</pre>
			<pre class="source-code">signals = ["term"]</pre>
			<pre class="source-code">grace = 5</pre>
			<pre class="source-code">mercy = 5</pre>
			<pre class="source-code">force = true</pre>
			<p>Even though we can create the file<a id="_idIndexMarker137"/> with the whole configuration, the best<a id="_idIndexMarker138"/> practice for using <strong class="source-inline">Rocket.toml</strong> is to rely on the default value and only write what we really need to override.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Overriding the configuration with environment variables</h2>
			<p>After checking <strong class="source-inline">Rocket.toml</strong>, the application<a id="_idIndexMarker139"/> then overrides the <strong class="source-inline">rocket::Config</strong> value again with environment<a id="_idIndexMarker140"/> variables. The application will check the availability of the <strong class="source-inline">ROCKET_*</strong> environment variables. For example, we might define <strong class="source-inline">ROCKET_IDENT="Merpay"</strong> or <strong class="source-inline">ROCKET_TLS={certs="abc.pem",key="def.pem"}</strong>. This is very useful if we are doing development and have multiple<a id="_idIndexMarker141"/> team members, or if we don't want something to exist in the configuration files and rely on environment variables, for example, when we store <strong class="source-inline">secret_key</strong> in Kubernetes Secrets. In this case, getting the <strong class="source-inline">secret</strong> value from environment variables is more secure compared to writing the value in <strong class="source-inline">Rocket.toml</strong> and committing it to your source code versioning system.</p>
			<p>Let's try overriding the configuration by running the application with <strong class="source-inline">ROCKET_PORT=4000</strong>:</p>
			<p class="source-code">$ ROCKET_PORT=4000 cargo run</p>
			<p class="source-code">...</p>
			<p class="source-code"><img src="image/032.png" alt=""/> Rocket has launched from http://127.0.0.1:4000</p>
			<p>The environment variable override works; we are running the application in port <strong class="source-inline">4000</strong> even though we specified port <strong class="source-inline">3000</strong> in the <strong class="source-inline">Rocket.toml</strong> file. We will learn how to extend the default <strong class="source-inline">rocket::Config</strong> with custom configuration when we configure the application to connect to a database in <a href="B16825_04_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 4</em></a>, <em class="italic">Building, Igniting, and Launching Rocket</em>. Now that we have learned how to configure the Rocket application, let's find out where we can get documentation and help for the Rocket web framework.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Getting help</h1>
			<p>Getting help with a web framework<a id="_idIndexMarker142"/> is essential. In this part, we will see where we can get help and documentation for the Rocket framework.</p>
			<p>You can get help from the website<a id="_idIndexMarker143"/> of the Rocket framework itself: <a href="https://rocket.rs/">https://rocket.rs/</a>. On that website, there is a guide as follows: <a href="https://rocket.rs/v0.5-rc/guide/">https://rocket.rs/v0.5-rc/guide/</a>. In the top-left corner of that page, there is a dropdown where you can choose documentation for previous versions of the Rocket web framework.</p>
			<p>At <a href="https://api.rocket.rs">https://api.rocket.rs</a>, you can see the documentation<a id="_idIndexMarker144"/> for the API, but, unfortunately, this documentation is for the master branch of the Rocket web framework. If you want to see the API documentation for your framework version, you have to manually search for it, such as <strong class="source-inline">https://api.rocket.rs/v0.3/rocket/</strong> or <strong class="source-inline">https://api.rocket.rs/v0.4/rocket/</strong>.</p>
			<p>There is an alternative way to generate offline documentation for the Rocket framework. Go and download the source code of Rocket from the official repository at <a href="https://github.com/SergioBenitez/Rocket">https://github.com/SergioBenitez/Rocket</a>. Then, inside the folder, type <strong class="source-inline">./scripts/mk-docs.sh</strong> to run the shell script. The generated documentation is useful<a id="_idIndexMarker145"/> because, sometimes, there are items that are different from those at <a href="https://api.rocket.rs">https://api.rocket.rs</a>. For example, the definition for <strong class="source-inline">rocket::Config</strong> and its default value in the code is a little bit different from the one in the API documentation. </p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Summary</h1>
			<p>In this chapter, we learned a little bit about the Rocket start sequence and request life cycle. We also created a very simple application and converted it to an asynchronous application. After that, we learned about the Rocket configuration, wrote the configuration using <strong class="source-inline">Rocket.toml</strong>, and overrode it using environment variables. Finally, we learned where to find the documentation for the Rocket framework.</p>
			<p>Now that we have created a simple application with the Rocket web framework, let's discuss requests and responses further in the next chapter.</p>
		</div>
	</body></html>