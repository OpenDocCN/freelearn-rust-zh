["```rs\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, \n    /// one that moves each value out of\n    /// the vector (from start to end). \n    /// The vector cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```", "```rs\n    #[inline]\n    fn into_iter(mut self) -> IntoIter<T> {\n        unsafe {\n            let begin = self.as_mut_ptr();\n            assume(!begin.is_null());\n            let end = if mem::size_of::<T>() == 0 {\n                arith_offset(begin as *const i8, self.len() \n                             as isize) as *const T\n            } else {\n                begin.add(self.len()) as *const T\n            };\n            let cap = self.buf.cap();\n            mem::forget(self);\n            IntoIter {\n                buf: NonNull::new_unchecked(begin),\n                phantom: PhantomData,\n                cap,\n                ptr: begin,\n                end,\n            }\n        }\n    }\n}\n```", "```rs\nimpl<'a, T> IntoIterator for &'a Vec<T> {\n    type Item = &'a T;\n    type IntoIter = slice::Iter<'a, T>;\n\n    fn into_iter(self) -> slice::Iter<'a, T> {\n        self.iter()\n    }\n}\n\nimpl<'a, T> IntoIterator for &'a mut Vec<T> {\n    type Item = &'a mut T;\n    type IntoIter = slice::IterMut<'a, T>;\n\n    fn into_iter(self) -> slice::IterMut<'a, T> {\n        self.iter_mut()\n    }\n}\n```", "```rs\nfn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n    Self: Sized,\n    P: FnMut(Self::Item) -> bool,\n{\n    // The addition might panic on overflow\n    self.try_fold(0, move |i, x| {\n        if predicate(x) { LoopState::Break(i) }\n        else { LoopState::Continue(i + 1) }\n    }).break_value()\n}\n```", "```rs\npub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n        where F: FnMut(&'a T) -> Ordering\n    {\n        let s = self;\n        let mut size = s.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0usize;\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n            // mid is always in [0, size), \n            // that means mid is >= 0 and < size.\n            // mid >= 0: by definition\n            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n            let cmp = f(unsafe { s.get_unchecked(mid) });\n            base = if cmp == Greater { base } else { mid };\n            size -= half;\n        }\n        // base is always in [0, size) because base <= mid.\n        let cmp = f(unsafe { s.get_unchecked(base) });\n        if cmp == Equal { Ok(base) } else { \n                     Err(base + (cmp == Less) as usize) }\n\n    }\n```", "```rs\npub fn sort(&mut self)\n    where T: Ord\n{\n    merge_sort(self, |a, b| a.lt(b));\n}\n```", "```rs\nfn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    // Slices of up to this length get sorted using insertion sort.\n    const MAX_INSERTION: usize = 20;\n    // Very short runs are extended using insertion sort \n    // to span at least this many elements.\n    const MIN_RUN: usize = 10;\n\n    // Sorting has no meaningful behavior on zero-sized types.\n    if size_of::<T>() == 0 {\n        return;\n    }\n\n    let len = v.len();\n\n    // Short arrays get sorted in-place via insertion \n    // sort to avoid allocations.\n    if len <= MAX_INSERTION {\n        if len >= 2 {\n            for i in (0..len-1).rev() {\n                insert_head(&mut v[i..], &mut is_less);\n            }\n        }\n        return;\n    }\n```", "```rs\n    // Allocate a buffer to use as scratch memory. \n    // We keep the length 0 so we can keep in it\n    // shallow copies of the contents of `v` without risking the dtors     \n    // running on copies if `is_less` panics. \n    // When merging two sorted runs, this buffer holds a copy of the \n    // shorter run, which will always have length at most `len / 2`.\n    let mut buf = Vec::with_capacity(len / 2);\n\n    // In order to identify natural runs in `v`, we traverse it \n    // backwards. That might seem like a strange decision, but consider \n    // the fact that merges more often go in the opposite direction\n    // (forwards). According to benchmarks, merging forwards is \n    // slightly faster than merging backwards. To conclude, identifying \n    // runs by traversing backwards improves performance.\n    let mut runs = vec![];\n    let mut end = len;\n    while end > 0 {\n        // Find the next natural run, \n        // and reverse it if it's strictly descending.\n        let mut start = end - 1;\n        if start > 0 {\n            start -= 1;\n            unsafe {\n                if is_less(v.get_unchecked(start + 1), \n                           v.get_unchecked(start)) {\n                    while start > 0 && is_less(v.get_unchecked(start),\n                                       v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                    v[start..end].reverse();\n                } else {\n                    while start > 0 && !is_less(v.get_unchecked(start),\n                                       v.get_unchecked(start - 1)) {\n                        start -= 1;\n                    }\n                }\n            }\n        }\n\n        // Insert some more elements into the run if it's too short. \n        // Insertion sort is faster than\n        // merge sort on short sequences, \n        // so this significantly improves performance.\n        while start > 0 && end - start < MIN_RUN {\n            start -= 1;\n            insert_head(&mut v[start..end], &mut is_less);\n        }\n\n        // Push this run onto the stack.\n        runs.push(Run {\n            start,\n            len: end - start,\n        });\n        end = start;\n```", "```rs\n        while let Some(r) = collapse(&runs) {\n            let left = runs[r + 1];\n            let right = runs[r];\n            unsafe {\n                merge(&mut v[left.start .. right.start + right.len], \n                      left.len, buf.as_mut_ptr(), &mut is_less);\n            }\n            runs[r] = Run {\n                start: left.start,\n                len: left.len + right.len,\n            };\n            runs.remove(r + 1);\n        }\n    }\n```", "```rs\n    // [...]\n    fn collapse(runs: &[Run]) -> Option<usize> {\n        let n = runs.len();\n        if n >= 2 && (runs[n - 1].start == 0 ||\n                      runs[n - 2].len <= runs[n - 1].len ||\n                      (n >= 3 && runs[n - 3].len <= \n                       runs[n - 2].len + runs[n - 1].len) ||\n                      (n >= 4 && runs[n - 4].len <= \n                       runs[n - 3].len + runs[n - 2].len)) {\n            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n                Some(n - 3)\n            } else {\n                Some(n - 2)\n            }\n        } else {\n            None\n        }\n    }\n    // [...]\n}\n```", "```rs\n    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n        where F: FnMut(&T, &T) -> Ordering\n    {\n        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n    }\n```", "```rs\n/// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\npub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n    where F: FnMut(&T, &T) -> bool\n{\n    // Sorting has no meaningful behavior on zero-sized types.\n    if mem::size_of::<T>() == 0 {\n        return;\n    }\n    // Limit the number of imbalanced \n    // partitions to `floor(log2(len)) + 1`.\n    let limit = mem::size_of::<usize>() * 8 - v.len()\n                .leading_zeros() as usize;\n\n    recurse(v, &mut is_less, None, limit);\n}\n```", "```rs\n/// Sorts `v` recursively.\n///\n/// If the slice had a predecessor in the original array, \n/// it is specified as `pred`.\n///\n/// `limit` is the number of allowed imbalanced partitions \n///  before switching to `heapsort`. If zero,\n/// this function will immediately switch to heapsort.\nfn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n    where F: FnMut(&T, &T) -> bool\n{\n    // Slices of up to this length get sorted using insertion sort.\n    const MAX_INSERTION: usize = 20;\n\n    // True if the last partitioning was reasonably balanced.\n    let mut was_balanced = true;\n    // True if the last partitioning didn't shuffle elements \n    // (the slice was already partitioned).\n    let mut was_partitioned = true;\n\n    loop {\n        let len = v.len();\n        // Very short slices get sorted using insertion sort.\n        if len <= MAX_INSERTION {\n            insertion_sort(v, is_less);\n            return;\n        }\n        // If too many bad pivot choices were made, \n        // simply fall back to heapsort in order to\n        // guarantee `O(n log n)` worst-case.\n        if limit == 0 {\n            heapsort(v, is_less);\n            return;\n        }\n        // If the last partitioning was imbalanced, \n        // try breaking patterns in the slice by shuffling\n        // some elements around. \n        // Hopefully we'll choose a better pivot this time.\n        if !was_balanced {\n            break_patterns(v);\n            limit -= 1;\n        }\n        // Choose a pivot and try guessing \n        // whether the slice is already sorted.\n        let (pivot, likely_sorted) = choose_pivot(v, is_less);\n\n        // If the last partitioning was decently balanced \n        // and didn't shuffle elements, and if pivot\n        // selection predicts the slice is likely already sorted...\n        if was_balanced && was_partitioned && likely_sorted {\n            // Try identifying several out-of-order elements \n            // and shifting them to correct\n            // positions. If the slice ends up being completely sorted, \n            // we're done.\n            if partial_insertion_sort(v, is_less) {\n                return;\n            }\n        }\n        // If the chosen pivot is equal to the predecessor, \n        // then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and \n        // elements greater than the pivot.\n        // This case is usually hit when the slice contains many \n        // duplicate elements.\n        if let Some(p) = pred {\n            if !is_less(p, &v[pivot]) {\n                let mid = partition_equal(v, pivot, is_less);\n\n                // Continue sorting elements greater than the pivot.\n                v = &mut {v}[mid..];\n                continue;\n            }\n        }\n        // Partition the slice.\n        let (mid, was_p) = partition(v, pivot, is_less);\n        was_balanced = cmp::min(mid, len - mid) >= len / 8;\n        was_partitioned = was_p;\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = {v}.split_at_mut(mid);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        // Recurse into the shorter side only in order to \n        // minimize the total number of recursive\n        // calls and consume less stack space. \n        // Then just continue with the longer side (this is\n        // akin to tail recursion).\n        if left.len() < right.len() {\n            recurse(left, is_less, pred, limit);\n            v = right;\n            pred = Some(pivot);\n        } else {\n            recurse(right, is_less, Some(pivot), limit);\n            v = left;\n        }\n    }\n}\n```"]