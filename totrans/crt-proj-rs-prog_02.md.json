["```rs\n[input]\nxml_file = \"../data/sales.xml\"\njson_file = \"../data/sales.json\"\n```", "```rs\ndatabase = \"Rust2018\"\n```", "```rs\nOriginal: Table(\n    {\n        \"input\": Table(\n            {\n                \"json_file\": String(\n                    \"../data/sales.json\",\n                ),\n                \"xml_file\": String(\n                    \"../data/sales.xml\",\n                ),\n            },\n        ),\n```", "```rs\n [Postgresql].Database: Rust2018\n```", "```rs\nlet config_const_values =\n```", "```rs\n{\n    let config_path = std::env::args().nth(1).unwrap();\n    let config_text = \n     std::fs::read_to_string(&config_path).unwrap();\n    config_text.parse::<toml::Value>().unwrap()\n};\n```", "```rs\nprintln!(\"Original: {:#?}\", config_const_values);\nprintln!(\"[Postgresql].Database: {}\",\n    config_const_values.get(\"postgresql\").unwrap()\n    .get(\"database\").unwrap()\n    .as_str().unwrap());\n```", "```rs\n[postgresql].database: Rust2018\n```", "```rs\n#[allow(unused)]\n#[derive(Deserialize)]\nstruct Input {\n    xml_file: String,\n    json_file: String,\n}\n```", "```rs\ntoml::from_str(&config_text).unwrap()\n```", "```rs\n let config_const_values: Config =\n```", "```rs\n  \"products\": [\n    {\n      \"id\": 591,\n      \"category\": \"fruit\",\n      \"name\": \"orange\"\n    },\n    {\n      \"id\": 190,\n      \"category\": \"furniture\",\n      \"name\": \"chair\"\n    }\n  ],\n```", "```rs\n\"sales\": [\n    {\n      \"id\": \"2020-7110\",\n      \"product_id\": 190,\n      \"date\": 1234527890,\n      \"quantity\": 2.0,\n      \"unit\": \"u.\"\n    },\n    {\n      \"id\": \"2020-2871\",\n      \"product_id\": 591,\n      \"date\": 1234567590,\n      \"quantity\": 2.14,\n      \"unit\": \"Kg\"\n    },\n    {\n      \"id\": \"2020-2583\",\n      \"product_id\": 190,\n      \"date\": 1234563890,\n      \"quantity\": 4.0,\n      \"unit\": \"u.\"\n    }\n  ]\n```", "```rs\nsales_and_products[\"sales\"][1][\"quantity\"]\n```", "```rs\nsales_and_products[\"sales\"][1][\"quantity\"]\n    = Value::Number(Number::from_f64(\n        n.as_f64().unwrap() + 1.5).unwrap());\n```", "```rs\nstd::fs::write(\n    output_path,\n    serde_json::to_string_pretty(&sales_and_products).unwrap(),\n).unwrap();\n```", "```rs\n#[derive(Deserialize, Serialize, Debug)]\n```", "```rs\nsales_and_products.sales[1].quantity += 1.5\n```", "```rs\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<sales-and-products>\n    <product>\n        <id>862</id>\n    </product>\n    <sale>\n        <id>2020-3987</id>\n    </sale>\n</sales-and-products>\n```", "```rs\nGot product.id: 862.\nGot product.category: fruit.\nGot product.name: cherry.\n  Exit product: Product { id: 862, category: \"fruit\", name: \"cherry\" }\n```", "```rs\nlet file = std::fs::File::open(pathname).unwrap();\nlet file = std::io::BufReader::new(file);\nlet parser = EventReader::new(file);\nfor event in parser {\n    match &location_item {\n        LocationItem::Other => ...\n        LocationItem::InProduct => ...\n        LocationItem::InSale => ...\n    }\n}\n```", "```rs\nOk(XmlEvent::Characters(characters)) => {\n    product.category = characters.clone();\n    println!(\"Got product.category: {}.\", characters);\n}\n```", "```rs\nAt instant 1234567890, 7.439 Kg of pears were sold. \n```", "```rs\nrusqlite = \"0.23\"\n```", "```rs\nfn main() -> Result<()> {\n    let conn = create_db()?;\n    populate_db(&conn)?;\n    print_db(&conn)?;\n    Ok(())\n}\n```", "```rs\nfn create_db() -> Result<Connection> {\n    let database_file = \"sales.db\";\n    let conn = Connection::open(database_file)?;\n    let _ = conn.execute(\"DROP TABLE Sales\", params![]);\n    let _ = conn.execute(\"DROP TABLE Products\", params![]);\n    conn.execute(\n        \"CREATE TABLE Products (\n            id INTEGER PRIMARY KEY,\n            category TEXT NOT NULL,\n            name TEXT NOT NULL UNIQUE)\",\n        params![],\n    )?;\n    conn.execute(\n        \"CREATE TABLE Sales (\n            id TEXT PRIMARY KEY,\n            product_id INTEGER NOT NULL REFERENCES Products,\n            sale_date BIGINT NOT NULL,\n            quantity DOUBLE PRECISION NOT NULL,\n            unit TEXT NOT NULL)\",\n        params![],\n    )?;\n    Ok(conn)\n}\n```", "```rs\nconn.execute(\n    \"INSERT INTO Products (\n        id, category, name\n        ) VALUES ($1, $2, $3)\",\n    params![1, \"fruit\", \"pears\"],\n)?;\n```", "```rs\nINSERT INTO Products (\n        id, category, name\n        ) VALUES (1, 'fruit', 'pears')\n```", "```rs\nfn print_db(conn: &Connection) -> Result<()> {\n    let mut command = conn.prepare(\n        \"SELECT p.name, s.unit, s.quantity, s.sale_date\n        FROM Sales s\n        LEFT JOIN Products p\n        ON p.id = s.product_id\n        ORDER BY s.sale_date\",\n    )?;\n    for sale_with_product in command.query_map(params![], |row| {\n        Ok(SaleWithProduct {\n            category: \"\".to_string(),\n            name: row.get(0)?,\n            quantity: row.get(2)?,\n            unit: row.get(1)?,\n            date: row.get(3)?,\n        })\n    })? {\n        if let Ok(item) = sale_with_product {\n            println!(\n                \"At instant {}, {} {} of {} were sold.\",\n                item.date, item.quantity, item.unit, item.name\n            );\n        }\n    }\n    Ok(())\n}\n```", "```rs\nAt instant 1234567890, 7.439 Kg of pears were sold.\n```", "```rs\nfor row in &conn.query(\n    \"SELECT p.name, s.unit, s.quantity, s.sale_date\n    FROM Sales s\n    LEFT JOIN Products p\n    ON p.id = s.product_id\n    ORDER BY s.sale_date\",\n    &[],\n)? {\n    let sale_with_product = SaleWithProduct {\n        category: \"\".to_string(),\n        name: row.get(0),\n        quantity: row.get(2),\n        unit: row.get(1),\n        date: row.get(3),\n    };\n    println!(\n        \"At instant {}, {} {} of {} were sold.\",\n        sale_with_product.date,\n        sale_with_product.quantity,\n        sale_with_product.unit,\n        sale_with_product.name\n    );\n}\n```", "```rs\na string, 4567, 12345, Err(Response was of incompatible type: \"Response type not string compatible.\" (response was nil)), false.\n```", "```rs\nfn main() -> redis::RedisResult<()> {\n    let client = redis::Client::open(\"redis://localhost/\")?;\n    let mut conn = client.get_connection()?;\n```", "```rs\nconn.set(\"aKey\", \"a string\")?;\nconn.set(\"anotherKey\", 4567)?;\nconn.set(45, 12345)?;\n```", "```rs\nconn.get::<_, String>(\"aKey\")?,\nconn.get::<_, u64>(\"anotherKey\")?,\nconn.get::<_, u16>(45)?,\nconn.get::<_, String>(40),\nconn.exists::<_, bool>(40)?);\n```", "```rs\nSQLite #Products=4\\. \nSQLite #Sales=5\\. \nPostgreSQL #Products=4\\. \nPostgreSQL #Sales=5\\. \n```"]