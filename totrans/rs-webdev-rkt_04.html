<html><head></head><body>
		<div><h1 id="_idParaDest-47"><em class="italic"><a id="_idTextAnchor046"/>Chapter 3</em>: Rocket Requests and Responses</h1>
			<p>We will discuss Rocket <strong class="bold">requests</strong> and <strong class="bold">responses</strong> more in this chapter. The first section will discuss how Rocket handles incoming requests in the form of routes. We will learn about various parts of a route including HTTP methods, URIs, and paths. Then, we will create an application that uses various parts in routes. We will also talk about Rust <strong class="bold">traits</strong> and implement a Rust trait to create a request handler.</p>
			<p>We are also going to discuss responses in a Rocket route handler and implement returning responses. After that, we will talk more about various built-in responder implementations and learn how to create an error handler to create a custom error when a route handler fails. Finally, we will implement a generic error handler to handle common HTTP status codes such as <code>404</code> and <code>500</code>.</p>
			<p>By the end of the chapter, you will be able to create the most important part of the Rocket framework: functions to handle incoming requests and return responses.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding Rocket routes</li>
				<li>Implementing route handlers</li>
				<li>Creating responses</li>
				<li>Making default error handlers</li>
			</ul>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p>We still have the same technical requirements from <a href="B16825_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Our First Rocket Web Application</em> for this chapter. We require a Rust compiler to be installed, along with a text editor, and an HTTP client.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Understanding Rocket routes</h1>
			<p>We begin our chapter by<a id="_idIndexMarker146"/> discussing how Rocket handles incoming requests in the form of routes. We write functions that can be used to handle incoming requests, put route attribute above those functions, and attach the route handling functions to the Rocket. A route <a id="_idIndexMarker147"/>has an HTTP method and <a id="_idIndexMarker148"/>a <code>src/main.rs</code> file:</p>
			<pre class="source-code">#[macro_use]</pre>
			<pre class="source-code">extern crate rocket;</pre>
			<pre class="source-code">use rocket::{Build, Rocket};</pre>
			<pre class="source-code">#[derive(FromForm)]</pre>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    age: u8,</pre>
			<pre class="source-code">    active: bool,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">#[route(GET, uri = "/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</strong></pre>
			<pre class="source-code">fn user(uuid: &amp;str) { /* ... */ }</pre>
			<pre class="source-code"><strong class="bold">#[route(GET, uri = "/users/&lt;grade&gt;?&lt;filters..&gt;")]</strong></pre>
			<pre class="source-code">fn users(grade: u8, filters: Filters) { /* ... */ }</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users])</pre>
			<pre class="source-code">}</pre>
			<p>The highlighted lines are the <code>route</code> attributes. You can only put the <code>route</code> attribute in a free function and <a id="_idIndexMarker152"/>not in a method inside <code>impl</code> of a <code>Struct</code>. Now, let's discuss the route parts in detail.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>HTTP methods</h2>
			<p>The first parameter you <a id="_idIndexMarker153"/>see inside the route definition is the HTTP method. The HTTP method is defined in the <code>rocket::http::Method</code> enum. The enum has the <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>HEAD</code>, <code>TRACE</code>, <code>CONNECT</code>, and <code>PATCH</code> members, which all correspond to valid HTTP methods defined in RFCs (Request For Comments).</p>
			<p>We can use other attributes to denote a route besides using the <code>#[route...]</code> macro. We can directly use method-specific route attributes such as <code>#[get...]</code>. There are seven method-specific route attributes: <code>get</code>, <code>put</code>, <code>post</code>, <code>delete</code>, <code>head</code>, <code>options</code>, and <code>patch</code>. We can rewrite the previous route attributes into the following lines:</p>
			<pre class="source-code">#[<strong class="bold">get</strong>("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">#[<strong class="bold">get</strong>("/users/&lt;grade&gt;?&lt;filters..&gt;")]</pre>
			<p>It looks simple, right? Unfortunately, we still have to use the <code>#[route...]</code> attribute if we want to handle <code>HTTP CONNECT</code> or <code>TRACE</code> as there are no method-specific route attributes for these two methods.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>URI</h2>
			<p>Inside the<a id="_idIndexMarker154"/> route attribute, we can see the <code>?</code>) is the path and the part after the question mark is the query.</p>
			<p>Both the path and the query can be divided<a id="_idIndexMarker157"/> into <code>/</code>), as in <code>/segment1/segment2</code>. The query is segmented by an ampersand (<code>&amp;</code>), as in <code>?segment1&amp;segment2</code>.</p>
			<p>A segment can be <code>/static</code> or <code>?static</code>. The dynamic segment is<a id="_idIndexMarker159"/> defined inside angle brackets (<code>&lt;&gt;</code>), as in <code>/&lt;dynamic&gt;</code> or <code>?&lt;dynamic&gt;</code>.</p>
			<p>If you declare a dynamic<a id="_idIndexMarker160"/> segment, you must use the segment as a function parameter in the function following the route attribute. The following is an example of how we can use the dynamic segment by writing a new application and adding this route and function handler:</p>
			<pre class="source-code">#[get("/&lt;<strong class="bold">id</strong>&gt;")]</pre>
			<pre class="source-code">fn process(<strong class="bold">id</strong>: u8) {/* ... */}</pre>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Path</h2>
			<p>The argument type in the handler<a id="_idIndexMarker161"/> function for the path must implement the <code>rocket::request::FromParam</code> trait. You might be wondering why we used <code>u8</code> as a function argument in the previous example. The answer is because Rocket has already implemented the <code>FromParam</code> trait for important types, such as <code>u8</code>. The following is a list of all types that have already implemented the <code>FromParam</code> trait:</p>
			<ul>
				<li>Primitive types such as <code>f32</code>, <code>f64</code>, <code>isize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>usize</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>bool</code>.</li>
				<li>Rust standard library numerical types in the <code>std::num</code> module, such as <code>NonZeroI8</code>, <code>NonZeroI16</code>, <code>NonZeroI32</code>, <code>NonZeroI64</code>, <code>NonZeroI128</code>, <code>NonZeroIsize</code>, <code>NonZeroU8</code>, <code>NonZeroU16</code>, <code>NonZeroU32</code>, <code>NonZeroU64</code>, <code>NonZeroU128</code>, and <code>NonZeroUsize</code>.</li>
				<li>Rust standard library <code>net</code> types in the <code>std::net</code> module, such as <code>IpAddr</code>, <code>Ipv4Addr</code>, <code>Ipv6Addr</code>, <code>SocketAddrV4</code>, <code>SocketAddrV6</code>, and <code>SocketAddr</code>.</li>
				<li><code>&amp;str</code> and <code>String</code>.</li>
				<li><code>Option&lt;T&gt;</code> and <code>Result&lt;T, T::Error&gt;</code> where <code>T:FromParam</code>. If you are new to Rust, this syntax is for a generic type. T:FromParam means that we can use any type <code>T</code>, as long as that type implements <code>FromParam</code>. For example, we can create a <code>User</code> struct, implement <code>FromParam</code> for <code>User</code>, and use <code>Option&lt;User&gt;</code> as an argument in the function handler.</li>
			</ul>
			<p>If you write a dynamic segment path, you must use the argument in the handler function, or else the code<a id="_idIndexMarker162"/> will fail to compile. The code will also fail if the argument type does not implement the <code>FromParam</code> trait.</p>
			<p>Let's see the error if we don't use the argument in the handler function by removing <code>id: u8</code> from the code:</p>
			<pre>&gt; cargo build
   ...
  Compiling route v0.1.0 (/Users/karuna/Chapter03/
  04UnusedParameter)
error: unused parameter
 --&gt; src/main.rs:6:7
  |
6 | #[get("/&lt;id&gt;")]
  |       ^^^^^^^
error: [note] expected argument named `id` here
 --&gt; src/main.rs:7:15
  |
7 | fn process_abc() { /* ... */ }
  |               ^^</pre>
			<p>Then, let's write the dynamic segment, which does not implement <code>FromParam</code>. Define an empty struct and use that as an argument in the handler function:</p>
			<pre class="source-code">struct S;</pre>
			<pre class="source-code">#[get("/&lt;id&gt;")]</pre>
			<pre class="source-code">fn process(id: S) { /* ... */ }</pre>
			<p>Again, the code will not compile:</p>
			<pre>&gt; cargo build
...
  Compiling route v0.1.0 (/home/karuna/workspace/
  rocketbook/Chapter03/05NotFromParam)
error[E0277]: the trait bound `S: FromParam&lt;'_&gt;` is not satisfied
--&gt; src/main.rs:9:16
  | 
9 | fn process(id: S) { /* ... */ }
  |                ^ the trait `FromParam&lt;'_&gt;` is not implemented for `S` 
  | 
  = note: required by `from_param`
error: aborting due to previous error</pre>
			<p>We can see from the<a id="_idIndexMarker163"/> compiler output that type <code>S</code> must implement the <code>FromParam</code> trait.</p>
			<p>There is another dynamic form<a id="_idIndexMarker164"/> in angle brackets but trailed with two full stops (<code>..</code>), as in <code>/&lt;dynamic..&gt;</code>. This dynamic form is called <strong class="bold">multiple segments</strong>.</p>
			<p>If a regular dynamic segment must implement the <code>FromParam</code> trait, multiple segments must implement the <code>rocket::request::FromSegments</code> trait. Rocket only provides <code>FromSegments</code> implementations for the Rust standard library <code>std::path::PathBuf</code> type. <code>PathBuf</code> is a type for representing a file path in the operating system. This implementation is very useful for serving a static file from the Rocket application.</p>
			<p>You might think serving from a specific path is dangerous because any person can try a path traversal such as <code>"../../../password.txt"</code>. Fortunately, the <code>FromSegments</code> implementation for <code>PathBuf</code> has already thought about the security problem. As a result, access to sensitive paths has been disabled, for example, <code>".."</code>, <code>"."</code>, or <code>"*"</code>. </p>
			<p>Another segment type is the <code>&lt;_&gt;</code> or <code>&lt;_..&gt;</code>. If you declare an ignored segment, it will <a id="_idIndexMarker165"/>not show in the function argument list. You must declare<a id="_idIndexMarker166"/> ignored multiple segments as the last argument in a path, just like regular multiple segments.</p>
			<p>An ignored segment is useful if you want to build an HTTP path that matches a lot of things, but you don't want to process it. For example, if you have the following lines of code, you can have a website that handles any path. It will handle <code>/</code>, <code>/some</code>, <code>/1/2/3</code>, or anything else:</p>
			<pre class="source-code">#[get("/<strong class="bold">&lt;_&gt;</strong>")]</pre>
			<pre class="source-code">fn index() {}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![index])</pre>
			<pre class="source-code">}</pre>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Query</h2>
			<p>Just like a path, a query segment <a id="_idIndexMarker167"/>can be a static segment or dynamic segment (such as <code>"?&lt;query1&gt;&amp;&lt;query2&gt;"</code>) or can be in a multiple <code>"?&lt;query..&gt;</code> form. The multiple query form is called <code>"?&lt;_&gt;"</code>, or ignored trailing parameters such as <code>"?&lt;_..&gt;"</code>.</p>
			<p>Neither dynamic queries nor trailing parameters are supposed to implement <code>FromParam</code>, but both must implement <code>rocket::form::FromForm</code> instead. We will discuss implementing <code>FromForm</code> more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Rank</h2>
			<p>The path and query segments <a id="_idIndexMarker169"/>in a URI can be grouped into three <strong class="bold">colors</strong>: <strong class="bold">static</strong>, <strong class="bold">partial</strong>, or <strong class="bold">wild</strong>. If all segments of the path are static, the path is called a static path. If all segments of the <a id="_idIndexMarker170"/>query are static, we say the query has a static color. If all segments of the path or query are dynamic, we call the path or query wild. The partial color is when a path or query has both static and dynamic segments.</p>
			<p>Why do we need these colors? They are required to determine the next parameter of the route, which<a id="_idIndexMarker171"/> is the <strong class="bold">rank</strong>. If we have multiple routes handling the same path, then Rocket will rank the functions and <em class="italic">start checking from the rank with the lowest number</em>. Let's see an example:</p>
			<pre class="source-code">#[get("/&lt;rank&gt;", <strong class="bold">rank = 1</strong>)]</pre>
			<pre class="source-code">fn first(rank: u8) -&gt; String {</pre>
			<pre class="source-code">    let result = rank + 10;</pre>
			<pre class="source-code">    format!("Your rank is, {}!", result)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[get("/&lt;name&gt;", <strong class="bold">rank = 2</strong>)]</pre>
			<pre class="source-code">fn second(name: &amp;str) -&gt; String {</pre>
			<pre class="source-code">    format!("Hello, {}!", name)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![first, second])</pre>
			<pre class="source-code">}</pre>
			<p>Here, we see we have two functions handling the same path, but with two different function signatures. Since Rust does not support function overloading, we created the functions with two different names. Let's try calling each of the routes:</p>
			<pre>&gt; curl http://127.0.0.1:8000/1
Your rank is, 11!
&gt; curl http://127.0.0.1:8000/jane
Hello, jane!</pre>
			<p>When we look at the application<a id="_idIndexMarker172"/> log in the other terminal, we can see how Rocket chose the route:</p>
			<pre>GET /1:
   &gt;&gt; Matched: (first) GET /&lt;rank&gt;
   &gt;&gt; Outcome: Success
   &gt;&gt; Response succeeded.
GET /jane:
   &gt;&gt; Matched: (first) GET /&lt;rank&gt;
   &gt;&gt; `rank: u8` param guard parsed forwarding with error 
      "jane"
   &gt;&gt; Outcome: Forward
   &gt;&gt; Matched: (second) GET /&lt;name&gt; [2]
   &gt;&gt; Outcome: Success
   &gt;&gt; Response succeeded.</pre>
			<p>Try reversing the rank in the source code and think about what would happen if you called it with <code>u8</code> as the parameter. After that, try requesting the endpoint to see whether your guess is correct.</p>
			<p>Let's recall Rocket's URI colors. Rocket ranks the colors of both path and query as follows:</p>
			<ul>
				<li>static path, static query = -12</li>
				<li>static path, partial query = -11</li>
				<li>static path, wild query = -10</li>
				<li>static path, none query = -9</li>
				<li>partial path, static query = -8</li>
				<li>partial path, partial query = -7</li>
				<li>partial path, wild query = -6</li>
				<li>partial path, none query = -5</li>
				<li>wild path, static query = -4</li>
				<li>wild path, partial query = -3</li>
				<li>wild path, wild query = -2</li>
				<li>wild path, none query = -1</li>
			</ul>
			<p>You can see the path has a lower rank, static is lower than partial, and finally, partial is lower than the wild <a id="_idIndexMarker173"/>color. Keep this in mind when you create multiple routes, as the output might not be what you expect because your route may have a lower or higher ranking.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Format</h2>
			<p>Another <a id="_idIndexMarker174"/>parameter we can use in a route is <code>format</code>. In requests with the HTTP method with a payload, such as <code>POST</code>, <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code>, the HTTP request <code>Content-Type</code> is checked against the value of this parameter. When handling HTTP requests without payloads, such as <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>, Rocket checks and matches the route's format with the HTTP requests' <code>Accept</code> header.</p>
			<p>Let's create an example for the <code>format</code> parameter. Create a new application and add the following lines:</p>
			<pre class="source-code">#[get("/get", <strong class="bold">format = "text/plain"</strong>)]</pre>
			<pre class="source-code">fn get() -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "GET Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[post("/post", <strong class="bold">format = "form"</strong>)]</pre>
			<pre class="source-code">fn post() -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "POST Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![get, post])</pre>
			<pre class="source-code">}</pre>
			<p>If you pay attention closely, the format for the <code>/get</code> endpoint uses the <code>"text/plain"</code> IANA (Internet Assigned Numbers Authority) media<a id="_idIndexMarker175"/> type, but the format for the <code>/post</code> endpoint is not the correct IANA media type. This is because Rocket accepts the following shorthand and converts them to the correct IANA media type:</p>
			<ul>
				<li><code>"any"</code> → <code>"*/*"</code></li>
				<li><code>"binary"</code> → <code>"application/octet-stream"</code></li>
				<li><code>"bytes"</code> → <code>"application/octet-stream"</code></li>
				<li><code>"html"</code> → <code>"text/html; charset=utf-8"</code></li>
				<li><code>"plain"</code> → <code>"text/html; charset=utf-8"</code></li>
				<li><code>"text"</code> → <code>"text/html; charset=utf-8"</code></li>
				<li><code>"json"</code> → <code>"application/json"</code></li>
				<li><code>"msgpack"</code> → <code>"application/msgpack"</code></li>
				<li><code>"form"</code> → <code>"application/x-www-form-urlencoded"</code></li>
				<li><code>"js"</code> → <code>"application/javascript"</code></li>
				<li><code>"css"</code> → <code>"text/css; charset=utf-8"</code></li>
				<li><code>"multipart"</code> → <code>"multipart/form-data"</code></li>
				<li><code>"xml"</code> → <code>"text/xml; charset=utf-8"</code></li>
				<li><code>"pdf"</code> → <code>"application/pdf"</code></li>
			</ul>
			<p>Now, run the application and call each of the two endpoints to see how they behave. First, call the <code>/get</code> endpoint with<a id="_idIndexMarker176"/> both the correct and incorrect <code>Accept</code> header:</p>
			<pre>&gt; curl -H "Accept: text/plain" http://127.0.0.1:8000/get
GET Request
&gt; curl -H "Accept: application/json" http://127.0.0.1:8000/get
{
  "error": {
    "code": 404,
    "reason": "Not Found",
    "description": "The requested resource could not be 
    found."
  }
}</pre>
			<p>The request with the correct <code>Accept</code> header returns the correct response, while the request with the incorrect <code>Accept</code> header returns <code>404</code> but with a <code>"Content-Type: application/json"</code> response header. Now, send the <code>POST</code> requests to the <code>/post</code> endpoint to see the responses:</p>
			<pre>&gt; curl -X POST -H "Content-Type: application/x-www-form-urlencoded" http://127.0.0.1:8000/post
POST Request
&gt; curl -X POST -H "Content-Type: text/plain" http://127.0.0.1:8000/post
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;404 Not Found&lt;/title&gt;
&lt;/head&gt;
...
&lt;/html&gt;</pre>
			<p>Our application <a id="_idIndexMarker177"/>outputs the expected response, but the <code>Content-Type</code> of the response is not what we expected. We will learn how to create a default error handler later in this chapter.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Data</h2>
			<p>The <code>data</code> parameter in<a id="_idIndexMarker178"/> the route is for processing the request body. The data must be in a dynamic form such as a dynamic <code>&lt;something&gt;</code> URI segment. After that, the declared attribute must be included as a parameter in the function following the route attribute. For example, look at the following lines:</p>
			<pre class="source-code">#[derive(FromForm)]</pre>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    age: u8,</pre>
			<pre class="source-code">    active: bool,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[post("/post", <code>data = "&lt;data&gt;"</code>)]</pre>
			<pre class="source-code">fn post(data: Form&lt;Filters&gt;) -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "POST Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![post])</pre>
			<pre class="source-code">}</pre>
			<p>If you do not include <code>data</code> as a parameter in the function following the route, Rust will complain about it at compile time. Try removing the <code>data</code> parameters in the function signature and<a id="_idIndexMarker179"/> try compiling it to see the compiler error output in action.</p>
			<p>We will learn more about data later when we implement forms and upload files to the server. Now that we have learned about Rocket routes, let's make an application to implement a route that handles a request.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Implementing route handlers</h1>
			<p>Here, we will make <a id="_idIndexMarker180"/>an application that handles a route. We are reusing the first code that we wrote in this chapter. The idea is that we have several user data, and we want to send requests that will select and return the selected user data according to the ID sent in the request. In this part, we will implement the request and selecting part of the route handlers. In the next section, we will learn how to create a custom response type. In the subsequent section, we will create a handler for when the request does not match any user data we have. And finally, in the last section, we will create a default error handler to handle invalid requests.</p>
			<p>Let's start by copying the first code into a new folder. After that, in <code>src/main.rs</code>, add a <code>User</code> struct after the <code>Filter</code> definition:</p>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">#[derive(Debug)]</strong></pre>
			<pre class="source-code"><strong class="bold">struct User {</strong></pre>
			<pre class="source-code"><strong class="bold">    uuid: String,</strong></pre>
			<pre class="source-code"><strong class="bold">    name: String,</strong></pre>
			<pre class="source-code"><strong class="bold">    age: u8,</strong></pre>
			<pre class="source-code"><strong class="bold">    grade: u8,</strong></pre>
			<pre class="source-code"><strong class="bold">    active: bool,</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<p>For the <code>User</code> struct, we <a id="_idIndexMarker181"/>are using <code>uuid</code> for object identification. The reason is that if we use <code>usize</code> or another numeric type as an ID without any authentication, we might<a id="_idIndexMarker182"/> fall into the <strong class="bold">Insecure Direct Object References</strong> (<strong class="bold">IDOR</strong>) security vulnerability where an unauthorized user can easily guess any number as an ID. The UUID as an identifier is harder to guess.</p>
			<p>Also, in real-world applications, we should probably create transparent encryption for the <em class="italic">name</em> and <em class="italic">age</em> as such information can be considered personally identifiable information, but let's skip it in this book for the sake of learning.</p>
			<p>We also add the <code>#[derive(Debug)]</code> attribute on top of the struct. The attribute automatically creates an implementation for the struct to be printed using <code>fmt::Debug</code>. We can then use it in code, such as <code>format!("{:?}", User)</code>. One of the requirements for the <code>Debug</code> attribute is that all type members must implement <code>Debug</code> as well; however, this is not a problem in our case, as all Rust standard library types already implement the <code>Debug</code> trait.</p>
			<p>As for the next step, we want to store several <code>User</code> data in a collection data structure. We can store them in a <code>[User; 5]</code> array or a growable <code>std::vec::Vec</code> array type. To find user <a id="_idIndexMarker183"/>data inside the array, we can iterate the array or Vec one by one until the end or until a match is found, but this is not ideal as it is time-consuming for a large array.</p>
			<p>In computer science, there are better data structures in which we can store data and easily find objects by their index, such as a hash map. Rust has many libraries that implement various data structures, and a hash map is one of them. In the standard library, we can find it in <code>std::collections::HashMap</code>.</p>
			<p>Besides using a standard library, we can use other alternatives, since the Rust community has already created a lot of data structure-related libraries. Try searching in <a href="https://crates.io">https://crates.io</a> or <a href="https://lib.rs">https://lib.rs</a>. For example, if we are not using the standard library, we can use an alternative crate such as <code>hashbrown</code>.</p>
			<p>Let's implement it in our <code>src/main.rs</code> file after the <code>User</code> struct declaration. Unfortunately, the <code>HashMap</code> creation requires heap allocation, so we cannot assign <code>HashMap</code> to a static variable. Adding the following code will not work:</p>
			<pre class="source-code">use std::collections::HashMap;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">static USERS: HashMap&lt;&amp;str, User&gt; = {</pre>
			<pre class="source-code">    let map = HashMap::new();</pre>
			<pre class="source-code">    map.insert(</pre>
			<pre class="source-code">        "3e3dd4ae-3c37-40c6-aa64-7061f284ce28",</pre>
			<pre class="source-code">        User {</pre>
			<pre class="source-code">            uuid: String::from("3e3dd4ae-3c37-40c6-aa64-</pre>
			<pre class="source-code">            7061f284ce28"),</pre>
			<pre class="source-code">            name: String::from("John Doe"),</pre>
			<pre class="source-code">            age: 18,</pre>
			<pre class="source-code">            grade: 1,</pre>
			<pre class="source-code">            active: true,</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    );</pre>
			<pre class="source-code">    map</pre>
			<pre class="source-code">};</pre>
			<p>There are several ways to assign <code>HashMap</code> to a static variable, but the best suggestion is to use the <code>lazy_static!</code> macro from the <code>lazy_static</code> crate, which runs the code at runtime and <a id="_idIndexMarker184"/>performs heap allocation. Let's add it to our code. First, add <code>lazy_static</code> in the <code>Cargo.toml</code> dependencies:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code"><strong class="bold">lazy_static = "1.4.0"</strong></pre>
			<pre class="source-code">rocket = "0.5.0-rc.1"</pre>
			<p>After that, use and implement it in the code as follows. Feel free to add extra users if you want to test it later:</p>
			<pre class="source-code">use lazy_static::lazy_static;</pre>
			<pre class="source-code">use std::collections::HashMap;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">lazy_static! {</pre>
			<pre class="source-code">    static ref USERS: HashMap&lt;&amp;'static str, User&gt; = {</pre>
			<pre class="source-code">        let mut map = HashMap::new();</pre>
			<pre class="source-code">        map.insert(</pre>
			<pre class="source-code">            "3e3dd4ae-3c37-40c6-aa64-7061f284ce28",</pre>
			<pre class="source-code">            User {</pre>
			<pre class="source-code">                ...</pre>
			<pre class="source-code">            },</pre>
			<pre class="source-code">        );</pre>
			<pre class="source-code">        map</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">}</pre>
			<p>Let's modify <code>fn user(...)</code> as follows:</p>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; String {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    match user {</pre>
			<pre class="source-code">        Some(u) =&gt; format!("Found user: {:?}", u),</pre>
			<pre class="source-code">        None =&gt; String::from("User not found"),</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We want the function to<a id="_idIndexMarker185"/> return something when we call it, therefore, we add <code>-&gt; String</code> in the function signature.</p>
			<p><code>HashMap</code> has many methods, such as <code>insert()</code> for inserting a new key and value, or <code>keys()</code>, which returns an iterator for the keys in <code>HashMap</code>. We are just using <code>get()</code>, which returns <code>std::option::Option</code>. Remember, <code>Option</code> is just an enum, which can be <code>None</code>, or <code>Some(T)</code> if it contains a value. Finally, the <code>match</code> control flow operator returns a string appropriately depending on whether the value is <code>None</code> or <code>Some(u)</code>.</p>
			<p>Now, if we try to send a <code>GET</code> request to <code>http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28</code>, we can see that it will return the correct response, and if we send a <code>GET</code> request to <code>http://127.0.0.1:8000/user/other</code>, it will return <code>"User not found"</code>.</p>
			<p>Now, let's implement the <code>users()</code> function. Let's recall the original signature:</p>
			<pre class="source-code">#[route(GET, uri = "/users/&lt;grade&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(grade: u8, filters: Filters) {}</pre>
			<p>Because <code>u8</code> already implements <code>FromParam</code>, we can just use it as it is. But, we want to see how we can implement <code>FromParam</code> for a custom type. Let's change our use case to have a path such as <code>"/users/&lt;name_grade&gt;?&lt;filters...&gt;"</code>.</p>
			<p>First, create a custom <code>NameGrade</code> struct. The <code>'r</code> annotation means that this struct should only live as long as the referenced string in its name field:</p>
			<pre class="source-code">struct NameGrade&lt;'r&gt; {</pre>
			<pre class="source-code">    name: &amp;'r str,</pre>
			<pre class="source-code">    grade: u8,</pre>
			<pre class="source-code">}</pre>
			<p>If we want to<a id="_idIndexMarker186"/> implement a trait, we have to look at the signature of that trait. The Rust compiler requires a type to implement all methods and a type placeholder in a trait. We can find the trait definition for <code>FromParam</code> from the Rocket API documentation:</p>
			<pre class="source-code">pub trait FromParam&lt;'a&gt;: Sized {</pre>
			<pre class="source-code">    type Error: Debug;</pre>
			<pre class="source-code">    fn from_param(param: &amp;'a str) -&gt; Result&lt;Self, Self::Error&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>The <code>type Error: Debug;</code> is called a type placeholder. Some<a id="_idIndexMarker187"/> traits require the implementation to have a certain type. Any type that implements this trait should use a concrete type, which also has a debug trait. Because we just want to show an error message, we can use <code>&amp;'static str</code> as the <code>Error</code> type for this implementation. Then, write the trait implementation signature for <code>NameGrade</code> as follows:</p>
			<pre class="source-code">use rocket::{request::FromParam, Build, Rocket};</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">impl&lt;'r&gt; FromParam&lt;'r&gt; for NameGrade&lt;'r&gt; {</pre>
			<pre class="source-code">    type Error = &amp;'static str;</pre>
			<pre class="source-code">    fn from_param(param: &amp;'r str) -&gt; Result&lt;Self, Self::</pre>
			<pre class="source-code">    Error&gt; {}</pre>
			<pre class="source-code">}</pre>
			<p>Inside the function, add the message that we want to show to the app user:</p>
			<pre class="source-code">const ERROR_MESSAGE: Result&lt;NameGrade, &amp;'static str&gt; = Err("Error parsing user parameter");</pre>
			<p>Then, let's split the input parameter at the <code>'_'</code> character:</p>
			<pre class="source-code">let name_grade_vec: Vec&lt;&amp;'r str&gt; = param.split('_').collect();</pre>
			<p>The <code>name_grade_vec</code> length will be either <code>2</code> or <code>other</code>, so we can use <code>match</code> on it. As <code>name_grade_vec[0]</code> is a <a id="_idIndexMarker188"/>string, we can use it as it is, but for the second member, we have to parse it. And, since the result can be anything, we have to use a special syntax that is formed as in <code>::&lt;Type&gt;</code>. This syntax is fondly called <strong class="bold">turbofish</strong> by the<a id="_idIndexMarker189"/> Rust community.</p>
			<p>Just like <code>Option</code>, <code>Result</code> is just an enum which can either be <code>Ok(T)</code> or <code>Err(E)</code>. If the program successfully parses <code>u8</code>, the method can return <code>Ok(NameGrade{...})</code>, or else the function can return <code>Err("...")</code>:</p>
			<pre class="source-code">match name_grade_vec.len() {</pre>
			<pre class="source-code">    2 =&gt; match name_grade_vec[1].parse::&lt;u8&gt;() {</pre>
			<pre class="source-code">        Ok(n) =&gt; Ok(Self {</pre>
			<pre class="source-code">            name: name_grade_vec[0],</pre>
			<pre class="source-code">            grade: n,</pre>
			<pre class="source-code">        }),</pre>
			<pre class="source-code">        Err(_) =&gt; ERROR_MESSAGE,</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    _ =&gt; ERROR_MESSAGE,</pre>
			<pre class="source-code">}</pre>
			<p>Now that we have implemented <code>FromParam</code> for <code>NameGrade</code>, we can use <code>NameGrade</code> as the parameter in the <code>users()</code> function. We also want <code>String</code> as the return type of the function:</p>
			<pre class="source-code">#[get("/users/&lt;<strong class="bold">name_grade</strong>&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(<strong class="bold">name_grade: NameGrade</strong>, filters: Filters) <strong class="bold">-&gt; String</strong> {}</pre>
			<p>Inside the function, write<a id="_idIndexMarker190"/> the routine that filters the <code>USERS</code> hash map with <code>name_grade</code> and <code>filters</code>:</p>
			<pre class="source-code">let users: Vec&lt;&amp;User&gt; = USERS</pre>
			<pre class="source-code">    .values()</pre>
			<pre class="source-code">    .filter(|user| user.name.contains(&amp;name_grade.name) &amp;&amp; </pre>
			<pre class="source-code">    user.grade == name_grade.grade)</pre>
			<pre class="source-code">    .filter(|user| user.age == filters.age &amp;&amp; user.active </pre>
			<pre class="source-code">    == filters.active)</pre>
			<pre class="source-code">    .collect();</pre>
			<p><code>HashMap</code> has the <code>values()</code> method, which returns <code>std::collections::hash_map::Values</code>. <code>Values</code> implements <code>std::iter::Iterator</code>, so we can filter it using the <code>filter()</code> method. The <code>filter()</code> method accepts a <em class="italic">closure</em>, which returns Rust bool type. The <code>filter()</code> method itself returns <code>std::iter::Filter</code>, which implements the <code>Iterator</code> trait. The <code>Iterator</code> trait has the <code>collect()</code> method, which can be used to collect items into the collection. Sometimes, you have to use the <code>::&lt;Type&gt;</code> turbofish in <code>collect::&lt;Type&gt;()</code> if the result type cannot be inferred by the compiler.</p>
			<p>After that, we can convert the collected users into <code>String</code>:</p>
			<pre class="source-code">if users.len() &gt; 0 {</pre>
			<pre class="source-code">    users</pre>
			<pre class="source-code">        .iter()</pre>
			<pre class="source-code">        .map(|u| u.name.to_string())</pre>
			<pre class="source-code">        .collect::&lt;Vec&lt;String&gt;&gt;()</pre>
			<pre class="source-code">        .join(",")</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    String::from("No user found")</pre>
			<pre class="source-code">}</pre>
			<p>After this is done, run the application and try calling the <code>users()</code> function:</p>
			<pre>curl -G -d age=18 -d active=true http://127.0.0.1:8000/users/John_1</pre>
			<p>It works, but the problem<a id="_idIndexMarker191"/> with this is that the query parameters are cumbersome; we want <code>Filters</code> to be optional. Let's modify the code a little bit. Change the signature of <code>fn users</code> to the following:</p>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: <strong class="bold">Option&lt;Filters&gt;</strong>) -&gt; String {</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">        .filter(|user| {</pre>
			<pre class="source-code">            <strong class="bold">if let Some(fts) = &amp;filters {</strong></pre>
			<pre class="source-code">                user.age == <strong class="bold">fts.</strong>age &amp;&amp; user.active == </pre>
			<pre class="source-code">                <strong class="bold">fts.</strong>active</pre>
			<pre class="source-code">            <strong class="bold">} else {</strong></pre>
			<pre class="source-code"><strong class="bold">                true</strong></pre>
			<pre class="source-code"><strong class="bold">            }</strong></pre>
			<pre class="source-code">        })</pre>
			<pre class="source-code">...</pre>
			<p>You might be confused by this piece of code: <code>if let Some(fts) = &amp;filters</code>. It's one of the destructuring syntaxes in Rust, just like this piece of code:</p>
			<pre class="source-code">match something {</pre>
			<pre class="source-code">    Ok(i) =&gt; /* use i here */ "",</pre>
			<pre class="source-code">    Err(err) =&gt; /* use err here */ "",</pre>
			<pre class="source-code">}</pre>
			<p>We have implemented the requests part for these two endpoints, <code>user()</code> and <code>users()</code>, but the return type for those two endpoints is the Rust standard library type, <code>String</code>. We want to use our<a id="_idIndexMarker192"/> own custom type. So, let's see how we can create a response from the <code>User</code> struct directly in the next section.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Creating responses</h1>
			<p>Let's implement a<a id="_idIndexMarker193"/> custom response for the <code>User</code> type. In Rocket, all types that implement <code>rocket::response::Responder</code> can be used as a return type in a function that handles routes.</p>
			<p>Let's take a look at the signature of the <code>Responder</code> trait. This trait requires two lifetimes, <code>'r</code> and <code>'o</code>. The result <code>'o</code> lifetime must at least be equal to the <code>'r</code> lifetime:</p>
			<pre class="source-code">pub trait Responder&lt;'r, 'o: 'r&gt; {</pre>
			<pre class="source-code">    fn respond_to(self, request: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    Result&lt;'o&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>First, we can include the required module to be used for implementing the <code>Responder</code> trait for the <code>User</code> struct:</p>
			<pre class="source-code">use rocket::http::ContentType;</pre>
			<pre class="source-code">use rocket::response::{self, Responder, Response};</pre>
			<pre class="source-code">use std::io::Cursor;</pre>
			<p>After that, add the implementation signature for the <code>User</code> struct:</p>
			<pre class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for &amp;'r User {</pre>
			<pre class="source-code">    fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    response::Result&lt;'r&gt; {    }</pre>
			<pre class="source-code">}</pre>
			<p>Why do we use <code>rocket::response::{self...}</code> instead of <code>rocket::response::{Result...}</code>? If we return <code>-&gt; Result</code>, we cannot use <code>std::result::Result</code>, which is a pretty ubiquitous type in Rust. Write the following lines in the <code>respond_to()</code> method body:</p>
			<pre class="source-code">let user = format!("Found user: {:?}", self);</pre>
			<pre class="source-code">Response::build()</pre>
			<pre class="source-code">    .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">    .raw_header("X-USER-ID", self.uuid.to_string())</pre>
			<pre class="source-code">    .header(ContentType::Plain)</pre>
			<pre class="source-code">    .ok()</pre>
			<p>The application generates a user <code>String</code> from the <code>User</code> object, then generates <code>rocket::response::Builder</code> by calling <code>Response::build()</code>. We can set various payloads for the <code>Builder</code> instance; for example, the <code>sized_body()</code> method adds the body <a id="_idIndexMarker194"/>of the response, <code>raw_header()</code> and <code>header()</code> add the HTTP header, and finally, we generate <code>response::Result()</code> using the <code>finalize()</code> method. </p>
			<p>The first parameter of the <code>sized_body()</code> method is <code>Option</code>, and the parameter can be <code>None</code>. As a result, the <code>sized_body()</code> method requires the second parameter to implement the <code>tokio::io::AsyncRead + tokio::io::AsyncSeek</code> trait to automatically determine the size. Fortunately, we can wrap the body in <code>std::io::Cursor</code> as Tokio already implements those traits for <code>Cursor</code>.</p>
			<p>There's a common pattern that we can observe when we implement the <code>std::iter::Iterator</code> trait and <code>rocket::response::Builder</code>, called the <code>Something</code> instance by chaining the command, such as <code>Something.new().func1().func2()</code>:</p>
			<pre class="source-code">struct Something {}</pre>
			<pre class="source-code">impl Something {</pre>
			<pre class="source-code">    fn new() -&gt; Something { ... }</pre>
			<pre class="source-code">    fn func1(&amp;mut self) -&gt; &amp;mut Something { ... }</pre>
			<pre class="source-code">    fn func2(&amp;mut self) -&gt; &amp;mut Something { ... }</pre>
			<pre class="source-code">}</pre>
			<p>Let's also modify the <code>users()</code> function to return a new <code>Responder</code>. We are defining a new type, which is commonly <a id="_idIndexMarker196"/>known as a <strong class="bold">newtype</strong> idiom. This idiom is useful if we want to <a id="_idIndexMarker197"/>wrap a collection or work around <strong class="bold">orphan rules</strong>.</p>
			<p>Orphan rules mean neither <code>type</code> nor <code>impl</code> are in our application or crate. For example, we cannot<a id="_idIndexMarker198"/> implement <code>impl Responder for Iterator</code> in our application. The reason is that <code>Iterator</code> is defined in the standard library, and <code>Responder</code> is defined in the Rocket crate.</p>
			<p>We can use the newtype idiom as in the following line:</p>
			<pre class="source-code">struct NewUser&lt;'a&gt;(Vec&lt;&amp;'a User&gt;);</pre>
			<p>Notice that the <a id="_idIndexMarker199"/>struct has a <code>struct NewType(type1, type2, ...)</code>.</p>
			<p>We can also call a struct with a nameless <a id="_idIndexMarker200"/>field a <code>(type1, type2, type3)</code>. We then can access the struct's field by its index, such as <code>self.0</code>, <code>self.1</code>, and so on.</p>
			<p>After the newtype definition, add the implementation as follows:</p>
			<pre class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for NewUser&lt;'r&gt; {</pre>
			<pre class="source-code">    fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">        let user = self</pre>
			<pre class="source-code">            .0</pre>
			<pre class="source-code">            .iter()</pre>
			<pre class="source-code">            .map(|u| format!("{:?}", u))</pre>
			<pre class="source-code">            .collect::&lt;Vec&lt;String&gt;&gt;()</pre>
			<pre class="source-code">            .join(",");</pre>
			<pre class="source-code">        Response::build()</pre>
			<pre class="source-code">            .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">            .header(ContentType::Plain)</pre>
			<pre class="source-code">            .ok()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Like the <code>Responder</code> implementation for the <code>User</code> type, in the <code>Responder</code> implementation for <code>NewUser</code>, we basically iterate a collection of users again, collect them as a String, and build the <code>response::Result</code> again.</p>
			<p>Finally, let's use <a id="_idIndexMarker202"/>both the <code>User</code> and <code>NewUser</code> structs as a response type in the <code>user()</code> and <code>users()</code> functions:</p>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">Option&lt;&amp;User&gt;</strong> {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    match user {</pre>
			<pre class="source-code"><strong class="bold">        Some(u) =&gt; Some(u),</strong></pre>
			<pre class="source-code"><strong class="bold">        None =&gt; None,</strong></pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[get("/users/&lt;name_grade&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; <strong class="bold">Option&lt;NewUser&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    if users.len() &gt; 0 {</pre>
			<pre class="source-code">        <strong class="bold">Some(NewUser(users))</strong></pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        <strong class="bold">None</strong></pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now that we've<a id="_idIndexMarker203"/> learned how to implement the <code>Responder</code> trait for a type, let's learn more about the wrappers that Rocket offers in the next section.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Wrapping Responder</h2>
			<p>Rocket has two <a id="_idIndexMarker204"/>modules that can be used to wrap the returned <code>Responder</code>.</p>
			<p>The first module is <code>rocket::response::status</code>, which has the following structs: <code>Accepted</code>, <code>BadRequest</code>, <code>Conflict</code>, <code>Created</code>, <code>Custom</code>, <code>Forbidden</code>, <code>NoContent</code>, <code>NotFound</code>, and <code>Unauthorized</code>. All the responders except <code>Custom</code> set the status just like their corresponding HTTP response code. For example, we can modify the previous <code>user()</code> function as follows:</p>
			<pre class="source-code">use rocket::response::status;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Accepted&lt;</strong>&amp;User<strong class="bold">&gt;</strong>  {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Accepted(</strong>user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The <code>Custom</code> type can be used to wrap a response with other HTTP code not available in the other structs. For example, take a look at the following lines:</p>
			<pre class="source-code"><strong class="bold">use rocket::http::Status;</strong></pre>
			<pre class="source-code">use rocket::response::status;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Custom&lt;</strong>&amp;User<strong class="bold">&gt;</strong>  {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Custom(Status::PreconditionFailed,</strong> user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The other module, <code>rocket::response::content</code>, has the following structs: <code>Css</code>, <code>Custom</code>, <code>Html</code>, <code>JavaScript</code>, <code>Json</code>, <code>MsgPack</code>, <code>Plain</code>, and <code>Xml</code>. Like the <code>status</code> module, the <code>content</code> module is used to set <code>Content-Type</code> of the response. For example, we can modify our <a id="_idIndexMarker205"/>code to the following lines:</p>
			<pre class="source-code"><strong class="bold">use rocket::response::content;</strong></pre>
			<pre class="source-code"><strong class="bold">use rocket::http::ContentType;</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">content::Plain&lt;</strong>&amp;User<strong class="bold">&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">content::Plain(</strong>user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; <strong class="bold">content::Custom&lt;</strong>NewUser<strong class="bold">&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Custom(ContentType::Plain,</strong> NewUser(users)<strong class="bold">)</strong>;</pre>
			<pre class="source-code">}</pre>
			<p>We can also combine both modules as in the following example:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Accepted&lt;content::Plain&lt;</strong>&amp;User<strong class="bold">&gt;&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Accepted(content::Plain(</strong>user<strong class="bold">))</strong></pre>
			<pre class="source-code">}</pre>
			<p>We can rewrite this using <code>rocket::http::Status</code> and <code>rocket::http::ContentType</code>:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">(Status, (ContentType, &amp;User))</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">(Status::Accepted, (ContentType::Plain, </strong>user<strong class="bold">))</strong></pre>
			<pre class="source-code">}</pre>
			<p>Now, you might be wondering how those structs can create HTTP <code>Status</code> and <code>Content-Type</code> and use another <code>Responder</code> implementor body. The answer is because the <code>Response</code> struct has two methods: <code>join()</code> and <code>merge()</code>.</p>
			<p>Let's assume there <a id="_idIndexMarker206"/>are two <code>Response</code> instances: <code>original</code> and <code>override</code>. The <code>original.join(override)</code> method merges the <code>override</code> body and status if it's not already present in <code>original</code>. The <code>join()</code> method also adjoins the same headers from <code>override</code>.</p>
			<p>Meanwhile, the <code>merge()</code> method replaces the <code>original</code> body and status with that of <code>override</code>, and replaces the <code>original</code> header if it exists in <code>override</code>.</p>
			<p>Let's rewrite our application to use a default response. This time we want to add a new HTTP header, <code>"X-CUSTOM-ID"</code>. To do so, implement the following function:</p>
			<pre class="source-code">fn default_response&lt;'r&gt;() -&gt; response::Response&lt;'r&gt; {</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .header(ContentType::Plain)</pre>
			<pre class="source-code">        .raw_header("X-CUSTOM-ID", "CUSTOM")</pre>
			<pre class="source-code">        .finalize()</pre>
			<pre class="source-code">}</pre>
			<p>Then, modify the <code>Responder</code> implementation for the <code>User</code> struct:</p>
			<pre class="source-code">fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let base_response = default_response();</strong></pre>
			<pre class="source-code">    let user = format!("Found user: {:?}", self);</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">        .raw_header("X-USER-ID", self.uuid.to_string())</pre>
			<pre class="source-code">        <strong class="bold">.merge(base_response)</strong></pre>
			<pre class="source-code">        .ok()</pre>
			<pre class="source-code">}</pre>
			<p>Finally, modify the <code>Responder</code> implementation for <code>NewUser</code>. But this time, we want to add extra<a id="_idIndexMarker207"/> values: the <code>"X-CUSTOM-ID"</code> header. We can do that using the <code>join()</code> method:</p>
			<pre class="source-code">fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let base_response = default_response();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">        .raw_header("X-CUSTOM-ID", "USERS")</pre>
			<pre class="source-code">        <strong class="bold">.join(base_response)</strong></pre>
			<pre class="source-code">        .ok()</pre>
			<pre class="source-code">}</pre>
			<p>Try opening the URL for <code>user</code> and <code>users</code> again; you should see the correct <code>Content-Type</code> and <code>X-CUSTOM-ID</code>:</p>
			<pre>&lt; x-custom-id: CUSTOM 
&lt; content-type: text/plain; charset=utf-8
&lt; x-custom-id: USERS 
&lt; x-custom-id: CUSTOM 
&lt; content-type: text/plain; charset=utf-8</pre>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Built-in implementations</h2>
			<p>Besides <code>content</code> and <code>status</code> wrappers, Rocket already implemented the <code>Responder</code> trait for several types <a id="_idIndexMarker208"/>to make it easier for developers. The following is a list of types already implementing the <code>Responder</code> trait:</p>
			<ul>
				<li><code>std::option::Option</code> – We can return <code>Option&lt;T&gt;</code> for any type of <code>T</code> that already implements <code>Responder</code>. If the returned variant is <code>Some(T)</code>, then <code>T</code> is returned to the client. We already see the example of this return type in the <code>user()</code> and <code>users()</code> functions.</li>
				<li><code>std::result::Result</code> – Both variants <code>T</code> and <code>E</code> in <code>Result&lt;T, E&gt;</code> should implement <code>Responder</code>. For example, we can change our <code>user()</code> implementation to return <code>status::NotFound</code> as in the following lines:<pre><strong class="bold">use rocket::response::status::NotFound;</strong>
...
fn user(uuid: &amp;str) -&gt; <strong class="bold">Result&lt;&amp;User, NotFound&lt;&amp;str&gt;&gt;</strong> {
    let user = USERS.get(uuid);
    <strong class="bold">user.ok_or(NotFound("User not found"))</strong>
}</pre></li>
				<li><code>&amp;str</code> and <code>String</code> – These types are returned with the text content as the response body and <code>Content-Type "text/plain"</code>.</li>
				<li><code>rocket::fs::NamedFile</code> – This <code>Responder</code> trait automatically returns a file specified with <code>Content-Type</code> based on the file content. For example, we have the <code>"static/favicon.png"</code> file and we want to serve it in our application. Take a look at the following example:<pre>use rocket::fs::{NamedFile, relative};
use std::path::Path;
#[get("/favicon.png")]
async fn favicon() -&gt; NamedFile {
    NamedFile::open(Path::new(relative!(
    "static")).join("favicon.png")).await.unwrap()
}</pre></li>
				<li><code>rocket::response::Redirect</code> – <code>Redirect</code> is used to return a <code>redirect</code> respo<a id="_idTextAnchor060"/>nse to the client. We will discuss <code>Redirect</code> more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</li>
				<li><code>rocket_dyn_templates::Template</code> – This responder returns a dynamic template. We will discuss<a id="_idIndexMarker209"/> templating more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</li>
				<li><code>rocket::serde::json::Json</code> – This type makes it easy to return the JSON type. To use this responder implementation, you must enable the <code>"json"</code> feature in <code>Cargo.toml</code> as follows: <code>rocket = {version = "0.5.0-rc.1", features = ["json"]}</code>. We will discuss more about JSON in <a href="B16825_11_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 11</em></a>, <em class="italic">Securing and Adding an API and JSON</em>.</li>
				<li><code>rocket::response::Flash</code> – <code>Flash</code> is a type of cookie that will be erased after a client accesses it. We will learn how to use this type in <a href="B16825_11_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 11</em></a>, <em class="italic">Securing and Adding an API and JSON</em>.</li>
				<li><code>rocket::serde::msgpack::MsgPack</code> – <code>"msgpack"</code> feature in <code>Cargo.toml</code>.</li>
				<li>Various <code>stream</code> responders in the <code>rocket::response::stream</code> module – We will learn more about these responders in <a href="B16825_09_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 9</em></a>, <em class="italic">Displaying Users' Post</em>, and <a href="B16825_10_ePub.xhtml#_idTextAnchor118"><em class="italic">Chapter 10</em></a>, <em class="italic">Uploading and Processing Posts</em>.</li>
			</ul>
			<p>We have already implemented a couple of routes, derived <code>FromParam</code>, and created types that implemented the <code>Responder</code> trait. In the next section, we will learn how to make a default error <a id="_idIndexMarker211"/>catcher for the same kind of HTTP status code.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Making default error catchers</h1>
			<p>An application <a id="_idIndexMarker212"/>should be able to handle an error that may occur anytime during processing. In a web application, the standardized way to return an error to a client is by using an HTTP status code. Rocket provides a way to handle returning errors to clients in the form of <code>rocket::Catcher</code>.</p>
			<p>The catcher handler works just like a route handler, with a few exceptions. Let's modify our last application to see how it works. Let's recall how we implemented the <code>user()</code> function:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; Result&lt;&amp;User, NotFound&lt;&amp;str&gt;&gt; {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    user.ok_or(NotFound("User not found"))</pre>
			<pre class="source-code">}</pre>
			<p>If we request <code>GET /user/wrongid</code>, the application will return an HTTP response with code <code>404</code>, a <code>"text/plain"</code> content type, and a <code>"User not found"</code> body. Let's change the function back to the return <code>Option</code>:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; Option&lt;&amp;User&gt; {</pre>
			<pre class="source-code">    USERS.get(uuid) </pre>
			<pre class="source-code">}</pre>
			<p>A function returning <code>Option</code> where the variant is <code>None</code> will use the default <code>404</code> error handler. After that, we can implement the default <code>404</code> handler as follows:</p>
			<pre class="source-code">#[catch(404)]</pre>
			<pre class="source-code">fn not_found(req: &amp;Request) -&gt; String {</pre>
			<pre class="source-code">    format!("We cannot find this page {}.", req.uri())</pre>
			<pre class="source-code">}</pre>
			<p>Notice the <code>#[catch(404)]</code> attribute above the function. It looks like a route directive. We can use any valid HTTP status code between <code>200</code> to <code>599</code> or <code>default</code>. If we put <code>default</code>, it will be used for any HTTP status code not declared in the code.</p>
			<p>Like <code>route</code>, the <code>catch</code> attribute must be put above a free function. We cannot put the <code>catch</code> attribute above a method inside the <code>impl</code> block. Also like the route handling function, the catcher function must return a type that implements <code>Responder</code>.</p>
			<p>The function handling <a id="_idIndexMarker213"/>an error can have zero, one, or two parameters. If the function has one parameter, the parameter type must be <code>&amp;rocket::Request</code>. If the function has two parameters, the first parameter type must be <code>rocket::http::Status</code> and the second parameter must be <code>&amp;Request</code>.</p>
			<p>The way the catcher function connects to Rocket is a little bit different. Where we use <code>mount()</code> and the <code>routes!</code> macro for the route handling functions, we use <code>register()</code> and the <code>catchers!</code> macro for catcher functions:</p>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users, </pre>
			<pre class="source-code">    favicon]).register("/", catchers![not_found])</pre>
			<pre class="source-code">}</pre>
			<p>How can we tell a route handling function to use a catcher? Let's say a catcher has been defined and registered as in the following lines:</p>
			<pre class="source-code">#[catch(403)]</pre>
			<pre class="source-code">fn forbidden(req: &amp;Request) -&gt; String {</pre>
			<pre class="source-code">    format!("Access forbidden {}.", req.uri())</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users, </pre>
			<pre class="source-code">    favicon]).register("/", catchers![not_found, </pre>
			<pre class="source-code">    forbidden])</pre>
			<pre class="source-code">}</pre>
			<p>We can then return <code>rocket::http::Status</code> directly on the route handling function. The status will<a id="_idIndexMarker214"/> then be forwarded to any registered catcher or Rocket built-in catcher:</p>
			<pre class="source-code">use rocket::http::{Status, ContentType};</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; Result&lt;NewUser, Status&gt; {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    if users.is_empty() {</pre>
			<pre class="source-code">        Err(Status::Forbidden)</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        Ok(NewUser(users))</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Try calling the <code>GET</code> request to this endpoint and see what happens:</p>
			<pre>curl -v http://127.0.0.1:8000/users/John_2
...
&lt; HTTP/1.1 403 Forbidden
&lt; content-type: text/plain; charset=utf-8
...
&lt; 
* Connection #0 to host 127.0.0.1 left intact
Access Forbidden /users/John_2.* Closing connection 0</pre>
			<p>The application<a id="_idIndexMarker215"/> returns the string from the <code>403</code> default handler and the correct HTTP status is also returned.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Summary</h1>
			<p>This chapter explored one of the most important parts of the Rocket framework. We learned about a route and its parts such as HTTP methods, URIs, path, query, rank, and data. We also implemented a couple of routes and various types related to routes in an application. After that, we explored ways to create responder types and learned about various wrappers and types already implemented in the <code>Responder</code> trait. Finally, we learned how to create a catcher and connect it to a Rocket application.</p>
			<p>In the next chapter, we will learn about other Rocket components such as states and fairings. We will learn the initialization process of a Rocket application, and how we can use those states and fairings to create more modern and complex applications.</p>
		</div>
	</body></html>