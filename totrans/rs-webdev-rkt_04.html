<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-47"><em class="italic"><a id="_idTextAnchor046"/>Chapter 3</em>: Rocket Requests and Responses</h1>
			<p>We will discuss Rocket <strong class="bold">requests</strong> and <strong class="bold">responses</strong> more in this chapter. The first section will discuss how Rocket handles incoming requests in the form of routes. We will learn about various parts of a route including HTTP methods, URIs, and paths. Then, we will create an application that uses various parts in routes. We will also talk about Rust <strong class="bold">traits</strong> and implement a Rust trait to create a request handler.</p>
			<p>We are also going to discuss responses in a Rocket route handler and implement returning responses. After that, we will talk more about various built-in responder implementations and learn how to create an error handler to create a custom error when a route handler fails. Finally, we will implement a generic error handler to handle common HTTP status codes such as <strong class="source-inline">404</strong> and <strong class="source-inline">500</strong>.</p>
			<p>By the end of the chapter, you will be able to create the most important part of the Rocket framework: functions to handle incoming requests and return responses.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding Rocket routes</li>
				<li>Implementing route handlers</li>
				<li>Creating responses</li>
				<li>Making default error handlers</li>
			</ul>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p>We still have the same technical requirements from <a href="B16825_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Our First Rocket Web Application</em> for this chapter. We require a Rust compiler to be installed, along with a text editor, and an HTTP client.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Understanding Rocket routes</h1>
			<p>We begin our chapter by<a id="_idIndexMarker146"/> discussing how Rocket handles incoming requests in the form of routes. We write functions that can be used to handle incoming requests, put route attribute above those functions, and attach the route handling functions to the Rocket. A route <a id="_idIndexMarker147"/>has an HTTP method and <a id="_idIndexMarker148"/>a <strong class="bold">URI</strong>, which corresponds to the URL path and URL query. The URI can be static, dynamic, or a combination of both. As well as a URI, there are other<a id="_idIndexMarker149"/> parameters in a route: <strong class="bold">rank</strong>, <strong class="bold">format</strong>, and <strong class="bold">data</strong>. We'll talk <a id="_idIndexMarker150"/>about them in detail later, but first, let's see how we can write<a id="_idIndexMarker151"/> a route in our code. Just like previously, let's create a new Rust application and add Rocket as a dependency. After that, let's add the following lines in the <strong class="source-inline">src/main.rs</strong> file:</p>
			<pre class="source-code">#[macro_use]</pre>
			<pre class="source-code">extern crate rocket;</pre>
			<pre class="source-code">use rocket::{Build, Rocket};</pre>
			<pre class="source-code">#[derive(FromForm)]</pre>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    age: u8,</pre>
			<pre class="source-code">    active: bool,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">#[route(GET, uri = "/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</strong></pre>
			<pre class="source-code">fn user(uuid: &amp;str) { /* ... */ }</pre>
			<pre class="source-code"><strong class="bold">#[route(GET, uri = "/users/&lt;grade&gt;?&lt;filters..&gt;")]</strong></pre>
			<pre class="source-code">fn users(grade: u8, filters: Filters) { /* ... */ }</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users])</pre>
			<pre class="source-code">}</pre>
			<p>The highlighted lines are the <strong class="source-inline">route</strong> attributes. You can only put the <strong class="source-inline">route</strong> attribute in a free function and <a id="_idIndexMarker152"/>not in a method inside <strong class="source-inline">impl</strong> of a <strong class="source-inline">Struct</strong>. Now, let's discuss the route parts in detail.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>HTTP methods</h2>
			<p>The first parameter you <a id="_idIndexMarker153"/>see inside the route definition is the HTTP method. The HTTP method is defined in the <strong class="source-inline">rocket::http::Method</strong> enum. The enum has the <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">OPTIONS</strong>, <strong class="source-inline">HEAD</strong>, <strong class="source-inline">TRACE</strong>, <strong class="source-inline">CONNECT</strong>, and <strong class="source-inline">PATCH</strong> members, which all correspond to valid HTTP methods defined in RFCs (Request For Comments).</p>
			<p>We can use other attributes to denote a route besides using the <strong class="source-inline">#[route...]</strong> macro. We can directly use method-specific route attributes such as <strong class="source-inline">#[get...]</strong>. There are seven method-specific route attributes: <strong class="source-inline">get</strong>, <strong class="source-inline">put</strong>, <strong class="source-inline">post</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">head</strong>, <strong class="source-inline">options</strong>, and <strong class="source-inline">patch</strong>. We can rewrite the previous route attributes into the following lines:</p>
			<pre class="source-code">#[<strong class="bold">get</strong>("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">#[<strong class="bold">get</strong>("/users/&lt;grade&gt;?&lt;filters..&gt;")]</pre>
			<p>It looks simple, right? Unfortunately, we still have to use the <strong class="source-inline">#[route...]</strong> attribute if we want to handle <strong class="source-inline">HTTP CONNECT</strong> or <strong class="source-inline">TRACE</strong> as there are no method-specific route attributes for these two methods.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>URI</h2>
			<p>Inside the<a id="_idIndexMarker154"/> route attribute, we can see the <strong class="bold">URI</strong>. The URI parameter is a string that has two <a id="_idIndexMarker155"/>parts, the <strong class="bold">path</strong> and the <strong class="bold">query</strong>. The<a id="_idIndexMarker156"/> part before the question mark (<strong class="source-inline">?</strong>) is the path and the part after the question mark is the query.</p>
			<p>Both the path and the query can be divided<a id="_idIndexMarker157"/> into <strong class="bold">segments</strong>. The path is segmented by the slash (<strong class="source-inline">/</strong>), as in <strong class="source-inline">/segment1/segment2</strong>. The query is segmented by an ampersand (<strong class="source-inline">&amp;</strong>), as in <strong class="source-inline">?segment1&amp;segment2</strong>.</p>
			<p>A segment can be <strong class="bold">static</strong> or <strong class="bold">dynamic</strong>. The static<a id="_idIndexMarker158"/> form is fixed, such as <strong class="source-inline">/static</strong> or <strong class="source-inline">?static</strong>. The dynamic segment is<a id="_idIndexMarker159"/> defined inside angle brackets (<strong class="source-inline">&lt;&gt;</strong>), as in <strong class="source-inline">/&lt;dynamic&gt;</strong> or <strong class="source-inline">?&lt;dynamic&gt;</strong>.</p>
			<p>If you declare a dynamic<a id="_idIndexMarker160"/> segment, you must use the segment as a function parameter in the function following the route attribute. The following is an example of how we can use the dynamic segment by writing a new application and adding this route and function handler:</p>
			<pre class="source-code">#[get("/&lt;<strong class="bold">id</strong>&gt;")]</pre>
			<pre class="source-code">fn process(<strong class="bold">id</strong>: u8) {/* ... */}</pre>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Path</h2>
			<p>The argument type in the handler<a id="_idIndexMarker161"/> function for the path must implement the <strong class="source-inline">rocket::request::FromParam</strong> trait. You might be wondering why we used <strong class="source-inline">u8</strong> as a function argument in the previous example. The answer is because Rocket has already implemented the <strong class="source-inline">FromParam</strong> trait for important types, such as <strong class="source-inline">u8</strong>. The following is a list of all types that have already implemented the <strong class="source-inline">FromParam</strong> trait:</p>
			<ul>
				<li>Primitive types such as <strong class="source-inline">f32</strong>, <strong class="source-inline">f64</strong>, <strong class="source-inline">isize</strong>, <strong class="source-inline">i8</strong>, <strong class="source-inline">i16</strong>, <strong class="source-inline">i32</strong>, <strong class="source-inline">i64</strong>, <strong class="source-inline">i128</strong>, <strong class="source-inline">usize</strong>, <strong class="source-inline">u8</strong>, <strong class="source-inline">u16</strong>, <strong class="source-inline">u32</strong>, <strong class="source-inline">u64</strong>, <strong class="source-inline">u128</strong>, and <strong class="source-inline">bool</strong>.</li>
				<li>Rust standard library numerical types in the <strong class="source-inline">std::num</strong> module, such as <strong class="source-inline">NonZeroI8</strong>, <strong class="source-inline">NonZeroI16</strong>, <strong class="source-inline">NonZeroI32</strong>, <strong class="source-inline">NonZeroI64</strong>, <strong class="source-inline">NonZeroI128</strong>, <strong class="source-inline">NonZeroIsize</strong>, <strong class="source-inline">NonZeroU8</strong>, <strong class="source-inline">NonZeroU16</strong>, <strong class="source-inline">NonZeroU32</strong>, <strong class="source-inline">NonZeroU64</strong>, <strong class="source-inline">NonZeroU128</strong>, and <strong class="source-inline">NonZeroUsize</strong>.</li>
				<li>Rust standard library <strong class="source-inline">net</strong> types in the <strong class="source-inline">std::net</strong> module, such as <strong class="source-inline">IpAddr</strong>, <strong class="source-inline">Ipv4Addr</strong>, <strong class="source-inline">Ipv6Addr</strong>, <strong class="source-inline">SocketAddrV4</strong>, <strong class="source-inline">SocketAddrV6</strong>, and <strong class="source-inline">SocketAddr</strong>.</li>
				<li><strong class="source-inline">&amp;str</strong> and <strong class="source-inline">String</strong>.</li>
				<li><strong class="source-inline">Option&lt;T&gt;</strong> and <strong class="source-inline">Result&lt;T, T::Error&gt;</strong> where <strong class="source-inline">T:FromParam</strong>. If you are new to Rust, this syntax is for a generic type. T:FromParam means that we can use any type <strong class="source-inline">T</strong>, as long as that type implements <strong class="source-inline">FromParam</strong>. For example, we can create a <strong class="source-inline">User</strong> struct, implement <strong class="source-inline">FromParam</strong> for <strong class="source-inline">User</strong>, and use <strong class="source-inline">Option&lt;User&gt;</strong> as an argument in the function handler.</li>
			</ul>
			<p>If you write a dynamic segment path, you must use the argument in the handler function, or else the code<a id="_idIndexMarker162"/> will fail to compile. The code will also fail if the argument type does not implement the <strong class="source-inline">FromParam</strong> trait.</p>
			<p>Let's see the error if we don't use the argument in the handler function by removing <strong class="source-inline">id: u8</strong> from the code:</p>
			<p class="source-code">&gt; cargo build</p>
			<p class="source-code">   ...</p>
			<p class="source-code">  Compiling route v0.1.0 (/Users/karuna/Chapter03/</p>
			<p class="source-code">  04UnusedParameter)</p>
			<p class="source-code">error: unused parameter</p>
			<p class="source-code"> --&gt; src/main.rs:6:7</p>
			<p class="source-code">  |</p>
			<p class="source-code">6 | #[get("/&lt;id&gt;")]</p>
			<p class="source-code">  |       ^^^^^^^</p>
			<p class="source-code">error: [note] expected argument named `id` here</p>
			<p class="source-code"> --&gt; src/main.rs:7:15</p>
			<p class="source-code">  |</p>
			<p class="source-code">7 | fn process_abc() { /* ... */ }</p>
			<p class="source-code">  |               ^^</p>
			<p>Then, let's write the dynamic segment, which does not implement <strong class="source-inline">FromParam</strong>. Define an empty struct and use that as an argument in the handler function:</p>
			<pre class="source-code">struct S;</pre>
			<pre class="source-code">#[get("/&lt;id&gt;")]</pre>
			<pre class="source-code">fn process(id: S) { /* ... */ }</pre>
			<p>Again, the code will not compile:</p>
			<p class="source-code">&gt; cargo build</p>
			<p class="source-code">...</p>
			<p class="source-code">  Compiling route v0.1.0 (/home/karuna/workspace/</p>
			<p class="source-code">  rocketbook/Chapter03/05NotFromParam)</p>
			<p class="source-code">error[E0277]: the trait bound `S: FromParam&lt;'_&gt;` is not satisfied</p>
			<p class="source-code">--&gt; src/main.rs:9:16</p>
			<p class="source-code">  | </p>
			<p class="source-code">9 | fn process(id: S) { /* ... */ }</p>
			<p class="source-code">  |                ^ the trait `FromParam&lt;'_&gt;` is not implemented for `S` </p>
			<p class="source-code">  | </p>
			<p class="source-code">  = note: required by `from_param`</p>
			<p class="source-code">error: aborting due to previous error</p>
			<p>We can see from the<a id="_idIndexMarker163"/> compiler output that type <strong class="source-inline">S</strong> must implement the <strong class="source-inline">FromParam</strong> trait.</p>
			<p>There is another dynamic form<a id="_idIndexMarker164"/> in angle brackets but trailed with two full stops (<strong class="source-inline">..</strong>), as in <strong class="source-inline">/&lt;dynamic..&gt;</strong>. This dynamic form is called <strong class="bold">multiple segments</strong>.</p>
			<p>If a regular dynamic segment must implement the <strong class="source-inline">FromParam</strong> trait, multiple segments must implement the <strong class="source-inline">rocket::request::FromSegments</strong> trait. Rocket only provides <strong class="source-inline">FromSegments</strong> implementations for the Rust standard library <strong class="source-inline">std::path::PathBuf</strong> type. <strong class="source-inline">PathBuf</strong> is a type for representing a file path in the operating system. This implementation is very useful for serving a static file from the Rocket application.</p>
			<p>You might think serving from a specific path is dangerous because any person can try a path traversal such as <strong class="source-inline">"../../../password.txt"</strong>. Fortunately, the <strong class="source-inline">FromSegments</strong> implementation for <strong class="source-inline">PathBuf</strong> has already thought about the security problem. As a result, access to sensitive paths has been disabled, for example, <strong class="source-inline">".."</strong>, <strong class="source-inline">"."</strong>, or <strong class="source-inline">"*"</strong>. </p>
			<p>Another segment type is the <strong class="bold">ignored segment</strong>. The ignored segment is defined as <strong class="source-inline">&lt;_&gt;</strong> or <strong class="source-inline">&lt;_..&gt;</strong>. If you declare an ignored segment, it will <a id="_idIndexMarker165"/>not show in the function argument list. You must declare<a id="_idIndexMarker166"/> ignored multiple segments as the last argument in a path, just like regular multiple segments.</p>
			<p>An ignored segment is useful if you want to build an HTTP path that matches a lot of things, but you don't want to process it. For example, if you have the following lines of code, you can have a website that handles any path. It will handle <strong class="source-inline">/</strong>, <strong class="source-inline">/some</strong>, <strong class="source-inline">/1/2/3</strong>, or anything else:</p>
			<pre class="source-code">#[get("/<strong class="bold">&lt;_&gt;</strong>")]</pre>
			<pre class="source-code">fn index() {}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![index])</pre>
			<pre class="source-code">}</pre>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Query</h2>
			<p>Just like a path, a query segment <a id="_idIndexMarker167"/>can be a static segment or dynamic segment (such as <strong class="source-inline">"?&lt;query1&gt;&amp;&lt;query2&gt;"</strong>) or can be in a multiple <strong class="source-inline">"?&lt;query..&gt;</strong> form. The multiple query form is called <strong class="bold">trailing parameters</strong>. Unlike the path, the query part does not have the<a id="_idIndexMarker168"/> ignored part, <strong class="source-inline">"?&lt;_&gt;"</strong>, or ignored trailing parameters such as <strong class="source-inline">"?&lt;_..&gt;"</strong>.</p>
			<p>Neither dynamic queries nor trailing parameters are supposed to implement <strong class="source-inline">FromParam</strong>, but both must implement <strong class="source-inline">rocket::form::FromForm</strong> instead. We will discuss implementing <strong class="source-inline">FromForm</strong> more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Rank</h2>
			<p>The path and query segments <a id="_idIndexMarker169"/>in a URI can be grouped into three <strong class="bold">colors</strong>: <strong class="bold">static</strong>, <strong class="bold">partial</strong>, or <strong class="bold">wild</strong>. If all segments of the path are static, the path is called a static path. If all segments of the <a id="_idIndexMarker170"/>query are static, we say the query has a static color. If all segments of the path or query are dynamic, we call the path or query wild. The partial color is when a path or query has both static and dynamic segments.</p>
			<p>Why do we need these colors? They are required to determine the next parameter of the route, which<a id="_idIndexMarker171"/> is the <strong class="bold">rank</strong>. If we have multiple routes handling the same path, then Rocket will rank the functions and <em class="italic">start checking from the rank with the lowest number</em>. Let's see an example:</p>
			<pre class="source-code">#[get("/&lt;rank&gt;", <strong class="bold">rank = 1</strong>)]</pre>
			<pre class="source-code">fn first(rank: u8) -&gt; String {</pre>
			<pre class="source-code">    let result = rank + 10;</pre>
			<pre class="source-code">    format!("Your rank is, {}!", result)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[get("/&lt;name&gt;", <strong class="bold">rank = 2</strong>)]</pre>
			<pre class="source-code">fn second(name: &amp;str) -&gt; String {</pre>
			<pre class="source-code">    format!("Hello, {}!", name)</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![first, second])</pre>
			<pre class="source-code">}</pre>
			<p>Here, we see we have two functions handling the same path, but with two different function signatures. Since Rust does not support function overloading, we created the functions with two different names. Let's try calling each of the routes:</p>
			<p class="source-code">&gt; curl http://127.0.0.1:8000/1</p>
			<p class="source-code">Your rank is, 11!</p>
			<p class="source-code">&gt; curl http://127.0.0.1:8000/jane</p>
			<p class="source-code">Hello, jane!</p>
			<p>When we look at the application<a id="_idIndexMarker172"/> log in the other terminal, we can see how Rocket chose the route:</p>
			<p class="source-code">GET /1:</p>
			<p class="source-code">   &gt;&gt; Matched: (first) GET /&lt;rank&gt;</p>
			<p class="source-code">   &gt;&gt; Outcome: Success</p>
			<p class="source-code">   &gt;&gt; Response succeeded.</p>
			<p class="source-code">GET /jane:</p>
			<p class="source-code">   &gt;&gt; Matched: (first) GET /&lt;rank&gt;</p>
			<p class="source-code">   &gt;&gt; `rank: u8` param guard parsed forwarding with error </p>
			<p class="source-code">      "jane"</p>
			<p class="source-code">   &gt;&gt; Outcome: Forward</p>
			<p class="source-code">   &gt;&gt; Matched: (second) GET /&lt;name&gt; [2]</p>
			<p class="source-code">   &gt;&gt; Outcome: Success</p>
			<p class="source-code">   &gt;&gt; Response succeeded.</p>
			<p>Try reversing the rank in the source code and think about what would happen if you called it with <strong class="source-inline">u8</strong> as the parameter. After that, try requesting the endpoint to see whether your guess is correct.</p>
			<p>Let's recall Rocket's URI colors. Rocket ranks the colors of both path and query as follows:</p>
			<ul>
				<li>static path, static query = -12</li>
				<li>static path, partial query = -11</li>
				<li>static path, wild query = -10</li>
				<li>static path, none query = -9</li>
				<li>partial path, static query = -8</li>
				<li>partial path, partial query = -7</li>
				<li>partial path, wild query = -6</li>
				<li>partial path, none query = -5</li>
				<li>wild path, static query = -4</li>
				<li>wild path, partial query = -3</li>
				<li>wild path, wild query = -2</li>
				<li>wild path, none query = -1</li>
			</ul>
			<p>You can see the path has a lower rank, static is lower than partial, and finally, partial is lower than the wild <a id="_idIndexMarker173"/>color. Keep this in mind when you create multiple routes, as the output might not be what you expect because your route may have a lower or higher ranking.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Format</h2>
			<p>Another <a id="_idIndexMarker174"/>parameter we can use in a route is <strong class="source-inline">format</strong>. In requests with the HTTP method with a payload, such as <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong> and <strong class="source-inline">DELETE</strong>, the HTTP request <strong class="source-inline">Content-Type</strong> is checked against the value of this parameter. When handling HTTP requests without payloads, such as <strong class="source-inline">GET</strong>, <strong class="source-inline">HEAD</strong>, and <strong class="source-inline">OPTIONS</strong>, Rocket checks and matches the route's format with the HTTP requests' <strong class="source-inline">Accept</strong> header.</p>
			<p>Let's create an example for the <strong class="source-inline">format</strong> parameter. Create a new application and add the following lines:</p>
			<pre class="source-code">#[get("/get", <strong class="bold">format = "text/plain"</strong>)]</pre>
			<pre class="source-code">fn get() -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "GET Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[post("/post", <strong class="bold">format = "form"</strong>)]</pre>
			<pre class="source-code">fn post() -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "POST Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![get, post])</pre>
			<pre class="source-code">}</pre>
			<p>If you pay attention closely, the format for the <strong class="source-inline">/get</strong> endpoint uses the <strong class="source-inline">"text/plain"</strong> IANA (Internet Assigned Numbers Authority) media<a id="_idIndexMarker175"/> type, but the format for the <strong class="source-inline">/post</strong> endpoint is not the correct IANA media type. This is because Rocket accepts the following shorthand and converts them to the correct IANA media type:</p>
			<ul>
				<li><strong class="source-inline">"any"</strong> → <strong class="source-inline">"*/*"</strong></li>
				<li><strong class="source-inline">"binary"</strong> → <strong class="source-inline">"application/octet-stream"</strong></li>
				<li><strong class="source-inline">"bytes"</strong> → <strong class="source-inline">"application/octet-stream"</strong></li>
				<li><strong class="source-inline">"html"</strong> → <strong class="source-inline">"text/html; charset=utf-8"</strong></li>
				<li><strong class="source-inline">"plain"</strong> → <strong class="source-inline">"text/html; charset=utf-8"</strong></li>
				<li><strong class="source-inline">"text"</strong> → <strong class="source-inline">"text/html; charset=utf-8"</strong></li>
				<li><strong class="source-inline">"json"</strong> → <strong class="source-inline">"application/json"</strong></li>
				<li><strong class="source-inline">"msgpack"</strong> → <strong class="source-inline">"application/msgpack"</strong></li>
				<li><strong class="source-inline">"form"</strong> → <strong class="source-inline">"application/x-www-form-urlencoded"</strong></li>
				<li><strong class="source-inline">"js"</strong> → <strong class="source-inline">"application/javascript"</strong></li>
				<li><strong class="source-inline">"css"</strong> → <strong class="source-inline">"text/css; charset=utf-8"</strong></li>
				<li><strong class="source-inline">"multipart"</strong> → <strong class="source-inline">"multipart/form-data"</strong></li>
				<li><strong class="source-inline">"xml"</strong> → <strong class="source-inline">"text/xml; charset=utf-8"</strong></li>
				<li><strong class="source-inline">"pdf"</strong> → <strong class="source-inline">"application/pdf"</strong></li>
			</ul>
			<p>Now, run the application and call each of the two endpoints to see how they behave. First, call the <strong class="source-inline">/get</strong> endpoint with<a id="_idIndexMarker176"/> both the correct and incorrect <strong class="source-inline">Accept</strong> header:</p>
			<p class="source-code">&gt; curl -H "Accept: text/plain" http://127.0.0.1:8000/get</p>
			<p class="source-code">GET Request</p>
			<p class="source-code">&gt; curl -H "Accept: application/json" http://127.0.0.1:8000/get</p>
			<p class="source-code">{</p>
			<p class="source-code">  "error": {</p>
			<p class="source-code">    "code": 404,</p>
			<p class="source-code">    "reason": "Not Found",</p>
			<p class="source-code">    "description": "The requested resource could not be </p>
			<p class="source-code">    found."</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The request with the correct <strong class="source-inline">Accept</strong> header returns the correct response, while the request with the incorrect <strong class="source-inline">Accept</strong> header returns <strong class="source-inline">404</strong> but with a <strong class="source-inline">"Content-Type: application/json"</strong> response header. Now, send the <strong class="source-inline">POST</strong> requests to the <strong class="source-inline">/post</strong> endpoint to see the responses:</p>
			<p class="source-code">&gt; curl -X POST -H "Content-Type: application/x-www-form-urlencoded" http://127.0.0.1:8000/post</p>
			<p class="source-code">POST Request</p>
			<p class="source-code">&gt; curl -X POST -H "Content-Type: text/plain" http://127.0.0.1:8000/post</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">    &lt;meta charset="utf-8"&gt;</p>
			<p class="source-code">    &lt;title&gt;404 Not Found&lt;/title&gt;</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Our application <a id="_idIndexMarker177"/>outputs the expected response, but the <strong class="source-inline">Content-Type</strong> of the response is not what we expected. We will learn how to create a default error handler later in this chapter.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Data</h2>
			<p>The <strong class="source-inline">data</strong> parameter in<a id="_idIndexMarker178"/> the route is for processing the request body. The data must be in a dynamic form such as a dynamic <strong class="source-inline">&lt;something&gt;</strong> URI segment. After that, the declared attribute must be included as a parameter in the function following the route attribute. For example, look at the following lines:</p>
			<pre class="source-code">#[derive(FromForm)]</pre>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    age: u8,</pre>
			<pre class="source-code">    active: bool,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[post("/post", <strong class="source-inline">data = "&lt;data&gt;"</strong>)]</pre>
			<pre class="source-code">fn post(data: Form&lt;Filters&gt;) -&gt; &amp;'static str {</pre>
			<pre class="source-code">    "POST Request"</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![post])</pre>
			<pre class="source-code">}</pre>
			<p>If you do not include <strong class="source-inline">data</strong> as a parameter in the function following the route, Rust will complain about it at compile time. Try removing the <strong class="source-inline">data</strong> parameters in the function signature and<a id="_idIndexMarker179"/> try compiling it to see the compiler error output in action.</p>
			<p>We will learn more about data later when we implement forms and upload files to the server. Now that we have learned about Rocket routes, let's make an application to implement a route that handles a request.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Implementing route handlers</h1>
			<p>Here, we will make <a id="_idIndexMarker180"/>an application that handles a route. We are reusing the first code that we wrote in this chapter. The idea is that we have several user data, and we want to send requests that will select and return the selected user data according to the ID sent in the request. In this part, we will implement the request and selecting part of the route handlers. In the next section, we will learn how to create a custom response type. In the subsequent section, we will create a handler for when the request does not match any user data we have. And finally, in the last section, we will create a default error handler to handle invalid requests.</p>
			<p>Let's start by copying the first code into a new folder. After that, in <strong class="source-inline">src/main.rs</strong>, add a <strong class="source-inline">User</strong> struct after the <strong class="source-inline">Filter</strong> definition:</p>
			<pre class="source-code">struct Filters {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">#[derive(Debug)]</strong></pre>
			<pre class="source-code"><strong class="bold">struct User {</strong></pre>
			<pre class="source-code"><strong class="bold">    uuid: String,</strong></pre>
			<pre class="source-code"><strong class="bold">    name: String,</strong></pre>
			<pre class="source-code"><strong class="bold">    age: u8,</strong></pre>
			<pre class="source-code"><strong class="bold">    grade: u8,</strong></pre>
			<pre class="source-code"><strong class="bold">    active: bool,</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<p>For the <strong class="source-inline">User</strong> struct, we <a id="_idIndexMarker181"/>are using <strong class="source-inline">uuid</strong> for object identification. The reason is that if we use <strong class="source-inline">usize</strong> or another numeric type as an ID without any authentication, we might<a id="_idIndexMarker182"/> fall into the <strong class="bold">Insecure Direct Object References</strong> (<strong class="bold">IDOR</strong>) security vulnerability where an unauthorized user can easily guess any number as an ID. The UUID as an identifier is harder to guess.</p>
			<p>Also, in real-world applications, we should probably create transparent encryption for the <em class="italic">name</em> and <em class="italic">age</em> as such information can be considered personally identifiable information, but let's skip it in this book for the sake of learning.</p>
			<p>We also add the <strong class="source-inline">#[derive(Debug)]</strong> attribute on top of the struct. The attribute automatically creates an implementation for the struct to be printed using <strong class="source-inline">fmt::Debug</strong>. We can then use it in code, such as <strong class="source-inline">format!("{:?}", User)</strong>. One of the requirements for the <strong class="source-inline">Debug</strong> attribute is that all type members must implement <strong class="source-inline">Debug</strong> as well; however, this is not a problem in our case, as all Rust standard library types already implement the <strong class="source-inline">Debug</strong> trait.</p>
			<p>As for the next step, we want to store several <strong class="source-inline">User</strong> data in a collection data structure. We can store them in a <strong class="source-inline">[User; 5]</strong> array or a growable <strong class="source-inline">std::vec::Vec</strong> array type. To find user <a id="_idIndexMarker183"/>data inside the array, we can iterate the array or Vec one by one until the end or until a match is found, but this is not ideal as it is time-consuming for a large array.</p>
			<p>In computer science, there are better data structures in which we can store data and easily find objects by their index, such as a hash map. Rust has many libraries that implement various data structures, and a hash map is one of them. In the standard library, we can find it in <strong class="source-inline">std::collections::HashMap</strong>.</p>
			<p>Besides using a standard library, we can use other alternatives, since the Rust community has already created a lot of data structure-related libraries. Try searching in <a href="https://crates.io">https://crates.io</a> or <a href="https://lib.rs">https://lib.rs</a>. For example, if we are not using the standard library, we can use an alternative crate such as <strong class="source-inline">hashbrown</strong>.</p>
			<p>Let's implement it in our <strong class="source-inline">src/main.rs</strong> file after the <strong class="source-inline">User</strong> struct declaration. Unfortunately, the <strong class="source-inline">HashMap</strong> creation requires heap allocation, so we cannot assign <strong class="source-inline">HashMap</strong> to a static variable. Adding the following code will not work:</p>
			<pre class="source-code">use std::collections::HashMap;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">static USERS: HashMap&lt;&amp;str, User&gt; = {</pre>
			<pre class="source-code">    let map = HashMap::new();</pre>
			<pre class="source-code">    map.insert(</pre>
			<pre class="source-code">        "3e3dd4ae-3c37-40c6-aa64-7061f284ce28",</pre>
			<pre class="source-code">        User {</pre>
			<pre class="source-code">            uuid: String::from("3e3dd4ae-3c37-40c6-aa64-</pre>
			<pre class="source-code">            7061f284ce28"),</pre>
			<pre class="source-code">            name: String::from("John Doe"),</pre>
			<pre class="source-code">            age: 18,</pre>
			<pre class="source-code">            grade: 1,</pre>
			<pre class="source-code">            active: true,</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    );</pre>
			<pre class="source-code">    map</pre>
			<pre class="source-code">};</pre>
			<p>There are several ways to assign <strong class="source-inline">HashMap</strong> to a static variable, but the best suggestion is to use the <strong class="source-inline">lazy_static!</strong> macro from the <strong class="source-inline">lazy_static</strong> crate, which runs the code at runtime and <a id="_idIndexMarker184"/>performs heap allocation. Let's add it to our code. First, add <strong class="source-inline">lazy_static</strong> in the <strong class="source-inline">Cargo.toml</strong> dependencies:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code"><strong class="bold">lazy_static = "1.4.0"</strong></pre>
			<pre class="source-code">rocket = "0.5.0-rc.1"</pre>
			<p>After that, use and implement it in the code as follows. Feel free to add extra users if you want to test it later:</p>
			<pre class="source-code">use lazy_static::lazy_static;</pre>
			<pre class="source-code">use std::collections::HashMap;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">lazy_static! {</pre>
			<pre class="source-code">    static ref USERS: HashMap&lt;&amp;'static str, User&gt; = {</pre>
			<pre class="source-code">        let mut map = HashMap::new();</pre>
			<pre class="source-code">        map.insert(</pre>
			<pre class="source-code">            "3e3dd4ae-3c37-40c6-aa64-7061f284ce28",</pre>
			<pre class="source-code">            User {</pre>
			<pre class="source-code">                ...</pre>
			<pre class="source-code">            },</pre>
			<pre class="source-code">        );</pre>
			<pre class="source-code">        map</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">}</pre>
			<p>Let's modify <strong class="source-inline">fn user(...)</strong> as follows:</p>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; String {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    match user {</pre>
			<pre class="source-code">        Some(u) =&gt; format!("Found user: {:?}", u),</pre>
			<pre class="source-code">        None =&gt; String::from("User not found"),</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We want the function to<a id="_idIndexMarker185"/> return something when we call it, therefore, we add <strong class="source-inline">-&gt; String</strong> in the function signature.</p>
			<p><strong class="source-inline">HashMap</strong> has many methods, such as <strong class="source-inline">insert()</strong> for inserting a new key and value, or <strong class="source-inline">keys()</strong>, which returns an iterator for the keys in <strong class="source-inline">HashMap</strong>. We are just using <strong class="source-inline">get()</strong>, which returns <strong class="source-inline">std::option::Option</strong>. Remember, <strong class="source-inline">Option</strong> is just an enum, which can be <strong class="source-inline">None</strong>, or <strong class="source-inline">Some(T)</strong> if it contains a value. Finally, the <strong class="source-inline">match</strong> control flow operator returns a string appropriately depending on whether the value is <strong class="source-inline">None</strong> or <strong class="source-inline">Some(u)</strong>.</p>
			<p>Now, if we try to send a <strong class="source-inline">GET</strong> request to <strong class="source-inline">http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28</strong>, we can see that it will return the correct response, and if we send a <strong class="source-inline">GET</strong> request to <strong class="source-inline">http://127.0.0.1:8000/user/other</strong>, it will return <strong class="source-inline">"User not found"</strong>.</p>
			<p>Now, let's implement the <strong class="source-inline">users()</strong> function. Let's recall the original signature:</p>
			<pre class="source-code">#[route(GET, uri = "/users/&lt;grade&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(grade: u8, filters: Filters) {}</pre>
			<p>Because <strong class="source-inline">u8</strong> already implements <strong class="source-inline">FromParam</strong>, we can just use it as it is. But, we want to see how we can implement <strong class="source-inline">FromParam</strong> for a custom type. Let's change our use case to have a path such as <strong class="source-inline">"/users/&lt;name_grade&gt;?&lt;filters...&gt;"</strong>.</p>
			<p>First, create a custom <strong class="source-inline">NameGrade</strong> struct. The <strong class="source-inline">'r</strong> annotation means that this struct should only live as long as the referenced string in its name field:</p>
			<pre class="source-code">struct NameGrade&lt;'r&gt; {</pre>
			<pre class="source-code">    name: &amp;'r str,</pre>
			<pre class="source-code">    grade: u8,</pre>
			<pre class="source-code">}</pre>
			<p>If we want to<a id="_idIndexMarker186"/> implement a trait, we have to look at the signature of that trait. The Rust compiler requires a type to implement all methods and a type placeholder in a trait. We can find the trait definition for <strong class="source-inline">FromParam</strong> from the Rocket API documentation:</p>
			<pre class="source-code">pub trait FromParam&lt;'a&gt;: Sized {</pre>
			<pre class="source-code">    type Error: Debug;</pre>
			<pre class="source-code">    fn from_param(param: &amp;'a str) -&gt; Result&lt;Self, Self::Error&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">type Error: Debug;</strong> is called a type placeholder. Some<a id="_idIndexMarker187"/> traits require the implementation to have a certain type. Any type that implements this trait should use a concrete type, which also has a debug trait. Because we just want to show an error message, we can use <strong class="source-inline">&amp;'static str</strong> as the <strong class="source-inline">Error</strong> type for this implementation. Then, write the trait implementation signature for <strong class="source-inline">NameGrade</strong> as follows:</p>
			<pre class="source-code">use rocket::{request::FromParam, Build, Rocket};</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">impl&lt;'r&gt; FromParam&lt;'r&gt; for NameGrade&lt;'r&gt; {</pre>
			<pre class="source-code">    type Error = &amp;'static str;</pre>
			<pre class="source-code">    fn from_param(param: &amp;'r str) -&gt; Result&lt;Self, Self::</pre>
			<pre class="source-code">    Error&gt; {}</pre>
			<pre class="source-code">}</pre>
			<p>Inside the function, add the message that we want to show to the app user:</p>
			<pre class="source-code">const ERROR_MESSAGE: Result&lt;NameGrade, &amp;'static str&gt; = Err("Error parsing user parameter");</pre>
			<p>Then, let's split the input parameter at the <strong class="source-inline">'_'</strong> character:</p>
			<pre class="source-code">let name_grade_vec: Vec&lt;&amp;'r str&gt; = param.split('_').collect();</pre>
			<p>The <strong class="source-inline">name_grade_vec</strong> length will be either <strong class="source-inline">2</strong> or <strong class="source-inline">other</strong>, so we can use <strong class="source-inline">match</strong> on it. As <strong class="source-inline">name_grade_vec[0]</strong> is a <a id="_idIndexMarker188"/>string, we can use it as it is, but for the second member, we have to parse it. And, since the result can be anything, we have to use a special syntax that is formed as in <strong class="source-inline">::&lt;Type&gt;</strong>. This syntax is fondly called <strong class="bold">turbofish</strong> by the<a id="_idIndexMarker189"/> Rust community.</p>
			<p>Just like <strong class="source-inline">Option</strong>, <strong class="source-inline">Result</strong> is just an enum which can either be <strong class="source-inline">Ok(T)</strong> or <strong class="source-inline">Err(E)</strong>. If the program successfully parses <strong class="source-inline">u8</strong>, the method can return <strong class="source-inline">Ok(NameGrade{...})</strong>, or else the function can return <strong class="source-inline">Err("...")</strong>:</p>
			<pre class="source-code">match name_grade_vec.len() {</pre>
			<pre class="source-code">    2 =&gt; match name_grade_vec[1].parse::&lt;u8&gt;() {</pre>
			<pre class="source-code">        Ok(n) =&gt; Ok(Self {</pre>
			<pre class="source-code">            name: name_grade_vec[0],</pre>
			<pre class="source-code">            grade: n,</pre>
			<pre class="source-code">        }),</pre>
			<pre class="source-code">        Err(_) =&gt; ERROR_MESSAGE,</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    _ =&gt; ERROR_MESSAGE,</pre>
			<pre class="source-code">}</pre>
			<p>Now that we have implemented <strong class="source-inline">FromParam</strong> for <strong class="source-inline">NameGrade</strong>, we can use <strong class="source-inline">NameGrade</strong> as the parameter in the <strong class="source-inline">users()</strong> function. We also want <strong class="source-inline">String</strong> as the return type of the function:</p>
			<pre class="source-code">#[get("/users/&lt;<strong class="bold">name_grade</strong>&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(<strong class="bold">name_grade: NameGrade</strong>, filters: Filters) <strong class="bold">-&gt; String</strong> {}</pre>
			<p>Inside the function, write<a id="_idIndexMarker190"/> the routine that filters the <strong class="source-inline">USERS</strong> hash map with <strong class="source-inline">name_grade</strong> and <strong class="source-inline">filters</strong>:</p>
			<pre class="source-code">let users: Vec&lt;&amp;User&gt; = USERS</pre>
			<pre class="source-code">    .values()</pre>
			<pre class="source-code">    .filter(|user| user.name.contains(&amp;name_grade.name) &amp;&amp; </pre>
			<pre class="source-code">    user.grade == name_grade.grade)</pre>
			<pre class="source-code">    .filter(|user| user.age == filters.age &amp;&amp; user.active </pre>
			<pre class="source-code">    == filters.active)</pre>
			<pre class="source-code">    .collect();</pre>
			<p><strong class="source-inline">HashMap</strong> has the <strong class="source-inline">values()</strong> method, which returns <strong class="source-inline">std::collections::hash_map::Values</strong>. <strong class="source-inline">Values</strong> implements <strong class="source-inline">std::iter::Iterator</strong>, so we can filter it using the <strong class="source-inline">filter()</strong> method. The <strong class="source-inline">filter()</strong> method accepts a <em class="italic">closure</em>, which returns Rust bool type. The <strong class="source-inline">filter()</strong> method itself returns <strong class="source-inline">std::iter::Filter</strong>, which implements the <strong class="source-inline">Iterator</strong> trait. The <strong class="source-inline">Iterator</strong> trait has the <strong class="source-inline">collect()</strong> method, which can be used to collect items into the collection. Sometimes, you have to use the <strong class="source-inline">::&lt;Type&gt;</strong> turbofish in <strong class="source-inline">collect::&lt;Type&gt;()</strong> if the result type cannot be inferred by the compiler.</p>
			<p>After that, we can convert the collected users into <strong class="source-inline">String</strong>:</p>
			<pre class="source-code">if users.len() &gt; 0 {</pre>
			<pre class="source-code">    users</pre>
			<pre class="source-code">        .iter()</pre>
			<pre class="source-code">        .map(|u| u.name.to_string())</pre>
			<pre class="source-code">        .collect::&lt;Vec&lt;String&gt;&gt;()</pre>
			<pre class="source-code">        .join(",")</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    String::from("No user found")</pre>
			<pre class="source-code">}</pre>
			<p>After this is done, run the application and try calling the <strong class="source-inline">users()</strong> function:</p>
			<p class="source-code">curl -G -d age=18 -d active=true http://127.0.0.1:8000/users/John_1</p>
			<p>It works, but the problem<a id="_idIndexMarker191"/> with this is that the query parameters are cumbersome; we want <strong class="source-inline">Filters</strong> to be optional. Let's modify the code a little bit. Change the signature of <strong class="source-inline">fn users</strong> to the following:</p>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: <strong class="bold">Option&lt;Filters&gt;</strong>) -&gt; String {</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">        .filter(|user| {</pre>
			<pre class="source-code">            <strong class="bold">if let Some(fts) = &amp;filters {</strong></pre>
			<pre class="source-code">                user.age == <strong class="bold">fts.</strong>age &amp;&amp; user.active == </pre>
			<pre class="source-code">                <strong class="bold">fts.</strong>active</pre>
			<pre class="source-code">            <strong class="bold">} else {</strong></pre>
			<pre class="source-code"><strong class="bold">                true</strong></pre>
			<pre class="source-code"><strong class="bold">            }</strong></pre>
			<pre class="source-code">        })</pre>
			<pre class="source-code">...</pre>
			<p>You might be confused by this piece of code: <strong class="source-inline">if let Some(fts) = &amp;filters</strong>. It's one of the destructuring syntaxes in Rust, just like this piece of code:</p>
			<pre class="source-code">match something {</pre>
			<pre class="source-code">    Ok(i) =&gt; /* use i here */ "",</pre>
			<pre class="source-code">    Err(err) =&gt; /* use err here */ "",</pre>
			<pre class="source-code">}</pre>
			<p>We have implemented the requests part for these two endpoints, <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong>, but the return type for those two endpoints is the Rust standard library type, <strong class="source-inline">String</strong>. We want to use our<a id="_idIndexMarker192"/> own custom type. So, let's see how we can create a response from the <strong class="source-inline">User</strong> struct directly in the next section.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Creating responses</h1>
			<p>Let's implement a<a id="_idIndexMarker193"/> custom response for the <strong class="source-inline">User</strong> type. In Rocket, all types that implement <strong class="source-inline">rocket::response::Responder</strong> can be used as a return type in a function that handles routes.</p>
			<p>Let's take a look at the signature of the <strong class="source-inline">Responder</strong> trait. This trait requires two lifetimes, <strong class="source-inline">'r</strong> and <strong class="source-inline">'o</strong>. The result <strong class="source-inline">'o</strong> lifetime must at least be equal to the <strong class="source-inline">'r</strong> lifetime:</p>
			<pre class="source-code">pub trait Responder&lt;'r, 'o: 'r&gt; {</pre>
			<pre class="source-code">    fn respond_to(self, request: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    Result&lt;'o&gt;;</pre>
			<pre class="source-code">}</pre>
			<p>First, we can include the required module to be used for implementing the <strong class="source-inline">Responder</strong> trait for the <strong class="source-inline">User</strong> struct:</p>
			<pre class="source-code">use rocket::http::ContentType;</pre>
			<pre class="source-code">use rocket::response::{self, Responder, Response};</pre>
			<pre class="source-code">use std::io::Cursor;</pre>
			<p>After that, add the implementation signature for the <strong class="source-inline">User</strong> struct:</p>
			<pre class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for &amp;'r User {</pre>
			<pre class="source-code">    fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    response::Result&lt;'r&gt; {    }</pre>
			<pre class="source-code">}</pre>
			<p>Why do we use <strong class="source-inline">rocket::response::{self...}</strong> instead of <strong class="source-inline">rocket::response::{Result...}</strong>? If we return <strong class="source-inline">-&gt; Result</strong>, we cannot use <strong class="source-inline">std::result::Result</strong>, which is a pretty ubiquitous type in Rust. Write the following lines in the <strong class="source-inline">respond_to()</strong> method body:</p>
			<pre class="source-code">let user = format!("Found user: {:?}", self);</pre>
			<pre class="source-code">Response::build()</pre>
			<pre class="source-code">    .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">    .raw_header("X-USER-ID", self.uuid.to_string())</pre>
			<pre class="source-code">    .header(ContentType::Plain)</pre>
			<pre class="source-code">    .ok()</pre>
			<p>The application generates a user <strong class="source-inline">String</strong> from the <strong class="source-inline">User</strong> object, then generates <strong class="source-inline">rocket::response::Builder</strong> by calling <strong class="source-inline">Response::build()</strong>. We can set various payloads for the <strong class="source-inline">Builder</strong> instance; for example, the <strong class="source-inline">sized_body()</strong> method adds the body <a id="_idIndexMarker194"/>of the response, <strong class="source-inline">raw_header()</strong> and <strong class="source-inline">header()</strong> add the HTTP header, and finally, we generate <strong class="source-inline">response::Result()</strong> using the <strong class="source-inline">finalize()</strong> method. </p>
			<p>The first parameter of the <strong class="source-inline">sized_body()</strong> method is <strong class="source-inline">Option</strong>, and the parameter can be <strong class="source-inline">None</strong>. As a result, the <strong class="source-inline">sized_body()</strong> method requires the second parameter to implement the <strong class="source-inline">tokio::io::AsyncRead + tokio::io::AsyncSeek</strong> trait to automatically determine the size. Fortunately, we can wrap the body in <strong class="source-inline">std::io::Cursor</strong> as Tokio already implements those traits for <strong class="source-inline">Cursor</strong>.</p>
			<p>There's a common pattern that we can observe when we implement the <strong class="source-inline">std::iter::Iterator</strong> trait and <strong class="source-inline">rocket::response::Builder</strong>, called the <strong class="bold">builder pattern</strong>. It's a pattern <a id="_idIndexMarker195"/>used to generate an instance by chaining methods. Take a look at the following example. We can then generate a <strong class="source-inline">Something</strong> instance by chaining the command, such as <strong class="source-inline">Something.new().func1().func2()</strong>:</p>
			<pre class="source-code">struct Something {}</pre>
			<pre class="source-code">impl Something {</pre>
			<pre class="source-code">    fn new() -&gt; Something { ... }</pre>
			<pre class="source-code">    fn func1(&amp;mut self) -&gt; &amp;mut Something { ... }</pre>
			<pre class="source-code">    fn func2(&amp;mut self) -&gt; &amp;mut Something { ... }</pre>
			<pre class="source-code">}</pre>
			<p>Let's also modify the <strong class="source-inline">users()</strong> function to return a new <strong class="source-inline">Responder</strong>. We are defining a new type, which is commonly <a id="_idIndexMarker196"/>known as a <strong class="bold">newtype</strong> idiom. This idiom is useful if we want to <a id="_idIndexMarker197"/>wrap a collection or work around <strong class="bold">orphan rules</strong>.</p>
			<p>Orphan rules mean neither <strong class="source-inline">type</strong> nor <strong class="source-inline">impl</strong> are in our application or crate. For example, we cannot<a id="_idIndexMarker198"/> implement <strong class="source-inline">impl Responder for Iterator</strong> in our application. The reason is that <strong class="source-inline">Iterator</strong> is defined in the standard library, and <strong class="source-inline">Responder</strong> is defined in the Rocket crate.</p>
			<p>We can use the newtype idiom as in the following line:</p>
			<pre class="source-code">struct NewUser&lt;'a&gt;(Vec&lt;&amp;'a User&gt;);</pre>
			<p>Notice that the <a id="_idIndexMarker199"/>struct has a <strong class="bold">nameless field</strong>. The form for a struct with a nameless field is as follows: <strong class="source-inline">struct NewType(type1, type2, ...)</strong>.</p>
			<p>We can also call a struct with a nameless <a id="_idIndexMarker200"/>field a <strong class="bold">tuple struct</strong> because the field <a id="_idIndexMarker201"/>is like a <strong class="bold">tuple</strong> <strong class="source-inline">(type1, type2, type3)</strong>. We then can access the struct's field by its index, such as <strong class="source-inline">self.0</strong>, <strong class="source-inline">self.1</strong>, and so on.</p>
			<p>After the newtype definition, add the implementation as follows:</p>
			<pre class="source-code">impl&lt;'r&gt; Responder&lt;'r, 'r&gt; for NewUser&lt;'r&gt; {</pre>
			<pre class="source-code">    fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; </pre>
			<pre class="source-code">    response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">        let user = self</pre>
			<pre class="source-code">            .0</pre>
			<pre class="source-code">            .iter()</pre>
			<pre class="source-code">            .map(|u| format!("{:?}", u))</pre>
			<pre class="source-code">            .collect::&lt;Vec&lt;String&gt;&gt;()</pre>
			<pre class="source-code">            .join(",");</pre>
			<pre class="source-code">        Response::build()</pre>
			<pre class="source-code">            .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">            .header(ContentType::Plain)</pre>
			<pre class="source-code">            .ok()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Like the <strong class="source-inline">Responder</strong> implementation for the <strong class="source-inline">User</strong> type, in the <strong class="source-inline">Responder</strong> implementation for <strong class="source-inline">NewUser</strong>, we basically iterate a collection of users again, collect them as a String, and build the <strong class="source-inline">response::Result</strong> again.</p>
			<p>Finally, let's use <a id="_idIndexMarker202"/>both the <strong class="source-inline">User</strong> and <strong class="source-inline">NewUser</strong> structs as a response type in the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> functions:</p>
			<pre class="source-code">#[get("/user/&lt;uuid&gt;", rank = 1, format = "text/plain")]</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">Option&lt;&amp;User&gt;</strong> {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    match user {</pre>
			<pre class="source-code"><strong class="bold">        Some(u) =&gt; Some(u),</strong></pre>
			<pre class="source-code"><strong class="bold">        None =&gt; None,</strong></pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[get("/users/&lt;name_grade&gt;?&lt;filters..&gt;")]</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; <strong class="bold">Option&lt;NewUser&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    if users.len() &gt; 0 {</pre>
			<pre class="source-code">        <strong class="bold">Some(NewUser(users))</strong></pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        <strong class="bold">None</strong></pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now that we've<a id="_idIndexMarker203"/> learned how to implement the <strong class="source-inline">Responder</strong> trait for a type, let's learn more about the wrappers that Rocket offers in the next section.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Wrapping Responder</h2>
			<p>Rocket has two <a id="_idIndexMarker204"/>modules that can be used to wrap the returned <strong class="source-inline">Responder</strong>.</p>
			<p>The first module is <strong class="source-inline">rocket::response::status</strong>, which has the following structs: <strong class="source-inline">Accepted</strong>, <strong class="source-inline">BadRequest</strong>, <strong class="source-inline">Conflict</strong>, <strong class="source-inline">Created</strong>, <strong class="source-inline">Custom</strong>, <strong class="source-inline">Forbidden</strong>, <strong class="source-inline">NoContent</strong>, <strong class="source-inline">NotFound</strong>, and <strong class="source-inline">Unauthorized</strong>. All the responders except <strong class="source-inline">Custom</strong> set the status just like their corresponding HTTP response code. For example, we can modify the previous <strong class="source-inline">user()</strong> function as follows:</p>
			<pre class="source-code">use rocket::response::status;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Accepted&lt;</strong>&amp;User<strong class="bold">&gt;</strong>  {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Accepted(</strong>user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">Custom</strong> type can be used to wrap a response with other HTTP code not available in the other structs. For example, take a look at the following lines:</p>
			<pre class="source-code"><strong class="bold">use rocket::http::Status;</strong></pre>
			<pre class="source-code">use rocket::response::status;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Custom&lt;</strong>&amp;User<strong class="bold">&gt;</strong>  {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Custom(Status::PreconditionFailed,</strong> user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<p>The other module, <strong class="source-inline">rocket::response::content</strong>, has the following structs: <strong class="source-inline">Css</strong>, <strong class="source-inline">Custom</strong>, <strong class="source-inline">Html</strong>, <strong class="source-inline">JavaScript</strong>, <strong class="source-inline">Json</strong>, <strong class="source-inline">MsgPack</strong>, <strong class="source-inline">Plain</strong>, and <strong class="source-inline">Xml</strong>. Like the <strong class="source-inline">status</strong> module, the <strong class="source-inline">content</strong> module is used to set <strong class="source-inline">Content-Type</strong> of the response. For example, we can modify our <a id="_idIndexMarker205"/>code to the following lines:</p>
			<pre class="source-code"><strong class="bold">use rocket::response::content;</strong></pre>
			<pre class="source-code"><strong class="bold">use rocket::http::ContentType;</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">content::Plain&lt;</strong>&amp;User<strong class="bold">&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">content::Plain(</strong>user<strong class="bold">)</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; <strong class="bold">content::Custom&lt;</strong>NewUser<strong class="bold">&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Custom(ContentType::Plain,</strong> NewUser(users)<strong class="bold">)</strong>;</pre>
			<pre class="source-code">}</pre>
			<p>We can also combine both modules as in the following example:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">status::Accepted&lt;content::Plain&lt;</strong>&amp;User<strong class="bold">&gt;&gt;</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">status::Accepted(content::Plain(</strong>user<strong class="bold">))</strong></pre>
			<pre class="source-code">}</pre>
			<p>We can rewrite this using <strong class="source-inline">rocket::http::Status</strong> and <strong class="source-inline">rocket::http::ContentType</strong>:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">(Status, (ContentType, &amp;User))</strong> {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">(Status::Accepted, (ContentType::Plain, </strong>user<strong class="bold">))</strong></pre>
			<pre class="source-code">}</pre>
			<p>Now, you might be wondering how those structs can create HTTP <strong class="source-inline">Status</strong> and <strong class="source-inline">Content-Type</strong> and use another <strong class="source-inline">Responder</strong> implementor body. The answer is because the <strong class="source-inline">Response</strong> struct has two methods: <strong class="source-inline">join()</strong> and <strong class="source-inline">merge()</strong>.</p>
			<p>Let's assume there <a id="_idIndexMarker206"/>are two <strong class="source-inline">Response</strong> instances: <strong class="source-inline">original</strong> and <strong class="source-inline">override</strong>. The <strong class="source-inline">original.join(override)</strong> method merges the <strong class="source-inline">override</strong> body and status if it's not already present in <strong class="source-inline">original</strong>. The <strong class="source-inline">join()</strong> method also adjoins the same headers from <strong class="source-inline">override</strong>.</p>
			<p>Meanwhile, the <strong class="source-inline">merge()</strong> method replaces the <strong class="source-inline">original</strong> body and status with that of <strong class="source-inline">override</strong>, and replaces the <strong class="source-inline">original</strong> header if it exists in <strong class="source-inline">override</strong>.</p>
			<p>Let's rewrite our application to use a default response. This time we want to add a new HTTP header, <strong class="source-inline">"X-CUSTOM-ID"</strong>. To do so, implement the following function:</p>
			<pre class="source-code">fn default_response&lt;'r&gt;() -&gt; response::Response&lt;'r&gt; {</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .header(ContentType::Plain)</pre>
			<pre class="source-code">        .raw_header("X-CUSTOM-ID", "CUSTOM")</pre>
			<pre class="source-code">        .finalize()</pre>
			<pre class="source-code">}</pre>
			<p>Then, modify the <strong class="source-inline">Responder</strong> implementation for the <strong class="source-inline">User</strong> struct:</p>
			<pre class="source-code">fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let base_response = default_response();</strong></pre>
			<pre class="source-code">    let user = format!("Found user: {:?}", self);</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">        .raw_header("X-USER-ID", self.uuid.to_string())</pre>
			<pre class="source-code">        <strong class="bold">.merge(base_response)</strong></pre>
			<pre class="source-code">        .ok()</pre>
			<pre class="source-code">}</pre>
			<p>Finally, modify the <strong class="source-inline">Responder</strong> implementation for <strong class="source-inline">NewUser</strong>. But this time, we want to add extra<a id="_idIndexMarker207"/> values: the <strong class="source-inline">"X-CUSTOM-ID"</strong> header. We can do that using the <strong class="source-inline">join()</strong> method:</p>
			<pre class="source-code">fn respond_to(self, _: &amp;'r Request&lt;'_&gt;) -&gt; response::Result&lt;'r&gt; {</pre>
			<pre class="source-code">    <strong class="bold">let base_response = default_response();</strong></pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    Response::build()</pre>
			<pre class="source-code">        .sized_body(user.len(), Cursor::new(user))</pre>
			<pre class="source-code">        .raw_header("X-CUSTOM-ID", "USERS")</pre>
			<pre class="source-code">        <strong class="bold">.join(base_response)</strong></pre>
			<pre class="source-code">        .ok()</pre>
			<pre class="source-code">}</pre>
			<p>Try opening the URL for <strong class="source-inline">user</strong> and <strong class="source-inline">users</strong> again; you should see the correct <strong class="source-inline">Content-Type</strong> and <strong class="source-inline">X-CUSTOM-ID</strong>:</p>
			<p class="source-code">&lt; x-custom-id: CUSTOM </p>
			<p class="source-code">&lt; content-type: text/plain; charset=utf-8</p>
			<p class="source-code">&lt; x-custom-id: USERS </p>
			<p class="source-code">&lt; x-custom-id: CUSTOM </p>
			<p class="source-code">&lt; content-type: text/plain; charset=utf-8</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Built-in implementations</h2>
			<p>Besides <strong class="source-inline">content</strong> and <strong class="source-inline">status</strong> wrappers, Rocket already implemented the <strong class="source-inline">Responder</strong> trait for several types <a id="_idIndexMarker208"/>to make it easier for developers. The following is a list of types already implementing the <strong class="source-inline">Responder</strong> trait:</p>
			<ul>
				<li><strong class="source-inline">std::option::Option</strong> – We can return <strong class="source-inline">Option&lt;T&gt;</strong> for any type of <strong class="source-inline">T</strong> that already implements <strong class="source-inline">Responder</strong>. If the returned variant is <strong class="source-inline">Some(T)</strong>, then <strong class="source-inline">T</strong> is returned to the client. We already see the example of this return type in the <strong class="source-inline">user()</strong> and <strong class="source-inline">users()</strong> functions.</li>
				<li><strong class="source-inline">std::result::Result</strong> – Both variants <strong class="source-inline">T</strong> and <strong class="source-inline">E</strong> in <strong class="source-inline">Result&lt;T, E&gt;</strong> should implement <strong class="source-inline">Responder</strong>. For example, we can change our <strong class="source-inline">user()</strong> implementation to return <strong class="source-inline">status::NotFound</strong> as in the following lines:<p class="source-code"><strong class="bold">use rocket::response::status::NotFound;</strong></p><p class="source-code">...</p><p class="source-code">fn user(uuid: &amp;str) -&gt; <strong class="bold">Result&lt;&amp;User, NotFound&lt;&amp;str&gt;&gt;</strong> {</p><p class="source-code">    let user = USERS.get(uuid);</p><p class="source-code">    <strong class="bold">user.ok_or(NotFound("User not found"))</strong></p><p class="source-code">}</p></li>
				<li><strong class="source-inline">&amp;str</strong> and <strong class="source-inline">String</strong> – These types are returned with the text content as the response body and <strong class="source-inline">Content-Type "text/plain"</strong>.</li>
				<li><strong class="source-inline">rocket::fs::NamedFile</strong> – This <strong class="source-inline">Responder</strong> trait automatically returns a file specified with <strong class="source-inline">Content-Type</strong> based on the file content. For example, we have the <strong class="source-inline">"static/favicon.png"</strong> file and we want to serve it in our application. Take a look at the following example:<p class="source-code">use rocket::fs::{NamedFile, relative};</p><p class="source-code">use std::path::Path;</p><p class="source-code">#[get("/favicon.png")]</p><p class="source-code">async fn favicon() -&gt; NamedFile {</p><p class="source-code">    NamedFile::open(Path::new(relative!(</p><p class="source-code">    "static")).join("favicon.png")).await.unwrap()</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">rocket::response::Redirect</strong> – <strong class="source-inline">Redirect</strong> is used to return a <strong class="source-inline">redirect</strong> respo<a id="_idTextAnchor060"/>nse to the client. We will discuss <strong class="source-inline">Redirect</strong> more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</li>
				<li><strong class="source-inline">rocket_dyn_templates::Template</strong> – This responder returns a dynamic template. We will discuss<a id="_idIndexMarker209"/> templating more in <a href="B16825_08_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Serving Static Assets and Templates</em>.</li>
				<li><strong class="source-inline">rocket::serde::json::Json</strong> – This type makes it easy to return the JSON type. To use this responder implementation, you must enable the <strong class="source-inline">"json"</strong> feature in <strong class="source-inline">Cargo.toml</strong> as follows: <strong class="source-inline">rocket = {version = "0.5.0-rc.1", features = ["json"]}</strong>. We will discuss more about JSON in <a href="B16825_11_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 11</em></a>, <em class="italic">Securing and Adding an API and JSON</em>.</li>
				<li><strong class="source-inline">rocket::response::Flash</strong> – <strong class="source-inline">Flash</strong> is a type of cookie that will be erased after a client accesses it. We will learn how to use this type in <a href="B16825_11_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 11</em></a>, <em class="italic">Securing and Adding an API and JSON</em>.</li>
				<li><strong class="source-inline">rocket::serde::msgpack::MsgPack</strong> – <strong class="bold">MessagePack</strong> is a binary serialization format just like JSON. To use<a id="_idIndexMarker210"/> this, you must enable the <strong class="source-inline">"msgpack"</strong> feature in <strong class="source-inline">Cargo.toml</strong>.</li>
				<li>Various <strong class="source-inline">stream</strong> responders in the <strong class="source-inline">rocket::response::stream</strong> module – We will learn more about these responders in <a href="B16825_09_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 9</em></a>, <em class="italic">Displaying Users' Post</em>, and <a href="B16825_10_ePub.xhtml#_idTextAnchor118"><em class="italic">Chapter 10</em></a>, <em class="italic">Uploading and Processing Posts</em>.</li>
			</ul>
			<p>We have already implemented a couple of routes, derived <strong class="source-inline">FromParam</strong>, and created types that implemented the <strong class="source-inline">Responder</strong> trait. In the next section, we will learn how to make a default error <a id="_idIndexMarker211"/>catcher for the same kind of HTTP status code.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Making default error catchers</h1>
			<p>An application <a id="_idIndexMarker212"/>should be able to handle an error that may occur anytime during processing. In a web application, the standardized way to return an error to a client is by using an HTTP status code. Rocket provides a way to handle returning errors to clients in the form of <strong class="source-inline">rocket::Catcher</strong>.</p>
			<p>The catcher handler works just like a route handler, with a few exceptions. Let's modify our last application to see how it works. Let's recall how we implemented the <strong class="source-inline">user()</strong> function:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; Result&lt;&amp;User, NotFound&lt;&amp;str&gt;&gt; {</pre>
			<pre class="source-code">    let user = USERS.get(uuid);</pre>
			<pre class="source-code">    user.ok_or(NotFound("User not found"))</pre>
			<pre class="source-code">}</pre>
			<p>If we request <strong class="source-inline">GET /user/wrongid</strong>, the application will return an HTTP response with code <strong class="source-inline">404</strong>, a <strong class="source-inline">"text/plain"</strong> content type, and a <strong class="source-inline">"User not found"</strong> body. Let's change the function back to the return <strong class="source-inline">Option</strong>:</p>
			<pre class="source-code">fn user(uuid: &amp;str) -&gt; Option&lt;&amp;User&gt; {</pre>
			<pre class="source-code">    USERS.get(uuid) </pre>
			<pre class="source-code">}</pre>
			<p>A function returning <strong class="source-inline">Option</strong> where the variant is <strong class="source-inline">None</strong> will use the default <strong class="source-inline">404</strong> error handler. After that, we can implement the default <strong class="source-inline">404</strong> handler as follows:</p>
			<pre class="source-code">#[catch(404)]</pre>
			<pre class="source-code">fn not_found(req: &amp;Request) -&gt; String {</pre>
			<pre class="source-code">    format!("We cannot find this page {}.", req.uri())</pre>
			<pre class="source-code">}</pre>
			<p>Notice the <strong class="source-inline">#[catch(404)]</strong> attribute above the function. It looks like a route directive. We can use any valid HTTP status code between <strong class="source-inline">200</strong> to <strong class="source-inline">599</strong> or <strong class="source-inline">default</strong>. If we put <strong class="source-inline">default</strong>, it will be used for any HTTP status code not declared in the code.</p>
			<p>Like <strong class="source-inline">route</strong>, the <strong class="source-inline">catch</strong> attribute must be put above a free function. We cannot put the <strong class="source-inline">catch</strong> attribute above a method inside the <strong class="source-inline">impl</strong> block. Also like the route handling function, the catcher function must return a type that implements <strong class="source-inline">Responder</strong>.</p>
			<p>The function handling <a id="_idIndexMarker213"/>an error can have zero, one, or two parameters. If the function has one parameter, the parameter type must be <strong class="source-inline">&amp;rocket::Request</strong>. If the function has two parameters, the first parameter type must be <strong class="source-inline">rocket::http::Status</strong> and the second parameter must be <strong class="source-inline">&amp;Request</strong>.</p>
			<p>The way the catcher function connects to Rocket is a little bit different. Where we use <strong class="source-inline">mount()</strong> and the <strong class="source-inline">routes!</strong> macro for the route handling functions, we use <strong class="source-inline">register()</strong> and the <strong class="source-inline">catchers!</strong> macro for catcher functions:</p>
			<pre class="source-code">#[launch]</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users, </pre>
			<pre class="source-code">    favicon]).register("/", catchers![not_found])</pre>
			<pre class="source-code">}</pre>
			<p>How can we tell a route handling function to use a catcher? Let's say a catcher has been defined and registered as in the following lines:</p>
			<pre class="source-code">#[catch(403)]</pre>
			<pre class="source-code">fn forbidden(req: &amp;Request) -&gt; String {</pre>
			<pre class="source-code">    format!("Access forbidden {}.", req.uri())</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn rocket() -&gt; Rocket&lt;Build&gt; {</pre>
			<pre class="source-code">    rocket::build().mount("/", routes![user, users, </pre>
			<pre class="source-code">    favicon]).register("/", catchers![not_found, </pre>
			<pre class="source-code">    forbidden])</pre>
			<pre class="source-code">}</pre>
			<p>We can then return <strong class="source-inline">rocket::http::Status</strong> directly on the route handling function. The status will<a id="_idIndexMarker214"/> then be forwarded to any registered catcher or Rocket built-in catcher:</p>
			<pre class="source-code">use rocket::http::{Status, ContentType};</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">fn users(name_grade: NameGrade, filters: Option&lt;Filters&gt;) -&gt; Result&lt;NewUser, Status&gt; {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    if users.is_empty() {</pre>
			<pre class="source-code">        Err(Status::Forbidden)</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        Ok(NewUser(users))</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Try calling the <strong class="source-inline">GET</strong> request to this endpoint and see what happens:</p>
			<p class="source-code">curl -v http://127.0.0.1:8000/users/John_2</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt; HTTP/1.1 403 Forbidden</p>
			<p class="source-code">&lt; content-type: text/plain; charset=utf-8</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt; </p>
			<p class="source-code">* Connection #0 to host 127.0.0.1 left intact</p>
			<p class="source-code">Access Forbidden /users/John_2.* Closing connection 0</p>
			<p>The application<a id="_idIndexMarker215"/> returns the string from the <strong class="source-inline">403</strong> default handler and the correct HTTP status is also returned.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Summary</h1>
			<p>This chapter explored one of the most important parts of the Rocket framework. We learned about a route and its parts such as HTTP methods, URIs, path, query, rank, and data. We also implemented a couple of routes and various types related to routes in an application. After that, we explored ways to create responder types and learned about various wrappers and types already implemented in the <strong class="source-inline">Responder</strong> trait. Finally, we learned how to create a catcher and connect it to a Rocket application.</p>
			<p>In the next chapter, we will learn about other Rocket components such as states and fairings. We will learn the initialization process of a Rocket application, and how we can use those states and fairings to create more modern and complex applications.</p>
		</div>
	</body></html>