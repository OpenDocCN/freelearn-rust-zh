- en: Scalable Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展微服务架构
- en: This chapter describes the scalability of microservices. In this chapter, we
    will learn how to create microservices that use messages for passing interaction
    with other microservices. You will get acquainted with RabbitMQ message broker
    and how to use it in Rust with `lapin` crate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了微服务的可扩展性。在本章中，我们将学习如何创建使用消息与其他微服务进行交互的微服务。你将熟悉RabbitMQ消息代理以及如何在Rust中使用`lapin`包来使用它。
- en: 'We will cover the following concepts related to microservices scalability in
    this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖与微服务可扩展性相关的以下概念：
- en: Scalable microservices design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展微服务设计
- en: How to avoid bottlenecks in your app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免应用程序中的瓶颈
- en: What are message brokers?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理是什么？
- en: How to use RabbitMQ with Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Rust与RabbitMQ
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To build scalable microservices you, need an infrastructure or resources to
    run multiple microservices in parallel. But for demonstration purposes, we will
    use Docker, which provides the ability to run multiple instances of our applications.
    We also need Docker to start a RabbitMQ instance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建可扩展的微服务，你需要一个基础设施或资源来并行运行多个微服务。但为了演示目的，我们将使用Docker，它提供了运行我们应用程序多个实例的能力。我们还需要Docker来启动一个RabbitMQ实例。
- en: To build all the examples, you will need version 1.31 of the Rust compiler.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建所有示例，你需要Rust编译器的1.31版本。
- en: 'You can get all the code for the examples in this chapter from the project
    on GitHub: [https:/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter12)[/github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter12).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub上的项目获取本章示例的所有代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter12)。
- en: Scalable architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展架构
- en: We avoid monoliths, and microservices can handle more requests per second if
    you develop them in the right way, but using microservices doesn't mean you have
    a scalable application effortlessly. It makes any part of an application flexible
    for scaling, and you have to write loosely coupled microservices that can run
    in many instances.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免使用单体架构，如果你以正确的方式开发微服务，它们可以处理每秒更多的请求，但使用微服务并不意味着你可以毫不费力地拥有一个可扩展的应用程序。它使应用程序的任何部分都变得灵活，可以扩展，你必须编写松散耦合的微服务，这些服务可以在多个实例中运行。
- en: Basic ideas
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本思想
- en: To make an application scalable, you can choose one of two approaches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序可扩展，你可以选择两种方法之一。
- en: In the first case, you can start more copies of the whole application. You may
    think it's impossible, but imagine a service that earns money from ads and provides
    a service to convert images into PDFs. This service can be scaled this way, and
    you can handle as many requests as the customers need, if you have enough hardware,
    of course.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你可以启动整个应用程序的更多副本。你可能认为这是不可能的，但想象一下一个通过广告赚钱并提供将图像转换为PDF的服务。这种服务可以通过这种方式进行扩展，如果你有足够的硬件，你可以处理客户需要的任何数量的请求。
- en: The second approach is to split the application into separate services that
    handle the same types of task, and you can run as many instances of the services
    as you want. For example, your application is an online store and you have issues
    with load on servers with images or static assets. This problem is simple to solve,
    because you can use a **content delivery network** (**CDN**) or buy an extra server
    where you can put the necessary static files, run NGINX, and add this server to
    the DNS records of your domain. But for microservices, you can't always use this
    approach. This requires ingenuity. But the recipe is clear. You have to achieve
    loose coupling for your microservices when you add extra microservices to handle
    specific tasks or to speed up some processes by caching, or using other tricks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是将应用程序拆分为处理相同类型任务的独立服务，你可以运行任意数量的服务实例。例如，如果你的应用程序是一个在线商店，你在服务器上处理图像或静态资源时遇到负载问题。这个问题很容易解决，因为你可以使用**内容分发网络**（**CDN**）或购买额外的服务器来放置必要的静态文件，运行NGINX，并将此服务器添加到你的域名DNS记录中。但对于微服务，你并不总是可以使用这种方法。这需要独创性。但食谱是清晰的。当你添加额外的微服务来处理特定任务或通过缓存或其他技巧加快某些流程时，你必须为你的微服务实现松散耦合。
- en: To have a more abstract services interaction layer, you can use message brokers
    that know nothing about your application, but provide the ability to send messages
    from one microservice to another and return the result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个更抽象的服务交互层，你可以使用对您的应用程序一无所知的消息代理，但提供从微服务到另一个微服务发送消息的能力，并返回结果。
- en: Message brokers and queues
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息代理和队列
- en: Message brokers translate messages from one application to another. Clients
    of message brokers use APIs to send messages that are serialized to a specific
    format and subscribe to queues to be notified about all the new messages. There
    is the **AMQP** (short for **Advanced Message Queuing Protocol**) protocol, which
    provides a common API that's compatible with different products.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理将消息从一种应用程序转换为另一种应用程序。消息代理的客户端使用 API 发送序列化为特定格式的消息，并订阅队列以接收所有新消息的通知。存在 **AMQP**（即
    **高级消息队列协议**）协议，它提供了一个与不同产品兼容的通用 API。
- en: The main concept of message brokers is the queue. It is an abstraction that
    represents an entity used to collect messages until they will be consumed by clients.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理的主要概念是队列。它是一种抽象，表示用于收集消息直到它们被客户端消费的实体。
- en: Why is the concept of message brokers cool? Because it's the simplest way to
    achieve loose coupling for services and maintain the possibility of smooth updates.
    You can use a common message format and write microservices to read specific types
    of messages. It helps you to reroute all paths of messages. For examples, you
    can add a specific handler for the specific message type, or set a balancing rule
    to load more powerful services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么消息代理的概念很酷？因为它是最简单的方式来实现服务的松耦合并保持平滑更新的可能性。您可以使用通用的消息格式并编写微服务来读取特定类型的消息。这有助于重新路由所有消息路径。例如，您可以添加特定消息类型的特定处理程序，或者设置平衡规则以加载更强大的服务。
- en: There are a lot of message brokers that can be used, depending on your needs.
    Some popular products are described in the following sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，有很多消息代理可以使用。以下章节中描述了一些流行的产品。
- en: RabbitMQ
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: RabbitMQ is the most popular message broker. This message broker supports the
    AMQP protocol. It's fast and reliable. It also facilitates the creation of short-lifetime
    queues for implementing client-server interactions based on messages. We will
    use this message broker to create an example of a scalable application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是最受欢迎的消息代理。这个消息代理支持 AMQP 协议。它速度快且可靠。它还便于创建短生命周期的队列，以实现基于消息的客户端-服务器交互。我们将使用这个消息代理来创建一个可扩展应用的示例。
- en: Kafka
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kafka
- en: Apache Kafka was originally created by LinkedIn and was donated to the Apache
    Software Foundation. It's implemented with Scala and works like a log that commits
    all information and provides access to it. It differs from traditional AMQP brokers,
    because it maintains a commit log that helps to achieve durable message storage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka 最初由 LinkedIn 创建，并捐赠给了 Apache 软件基金会。它使用 Scala 实现，就像一个日志，提交所有信息并提供对其的访问。它与传统的
    AMQP 代理不同，因为它维护一个提交日志，有助于实现持久消息存储。
- en: Application bottlenecks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序瓶颈
- en: Any part of an application can be a bottleneck. At first, you may have issues
    with the infrastructure used by microservices, such as databases or message brokers.
    Scaling these parts is a complex concept, but here we will only touch upon the
    bottlenecks of microservices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的任何部分都可能成为瓶颈。最初，您可能遇到微服务使用的底层基础设施问题，如数据库或消息代理。扩展这些部分是一个复杂的概念，但在这里我们只会触及微服务的瓶颈。
- en: When you create a microservice, you may encounter problems with the quantity
    of requests it can handle. It depends on multiple factors. You can use a concept
    such as the actors model to spread a load across threads and event loops.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建微服务时，您可能会遇到它可以处理的请求数量问题。这取决于多个因素。您可以使用如演员模型这样的概念来在线程和事件循环之间分配负载。
- en: If you have issues with CPU performance, you can create a separate worker that
    handles CPU-intensive tasks and schedules tasks with message brokers to achieve
    loose coupling, because you can add more workers at any time to handle more requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到 CPU 性能问题，您可以创建一个单独的工人来处理 CPU 密集型任务，并通过消息代理安排任务以实现松耦合，因为您可以在任何时间添加更多工人来处理更多请求。
- en: It you have I/O-intensive tasks, you can use load balancers to direct load to
    a specific service, but your microservice should be replaceable and shouldn't
    keep a persistent state, but can load it from a database. It allows you to use
    products such as Kubernetes to scale your applications automatically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些I/O密集型任务，你可以使用负载均衡器将负载定向到特定的服务，但你的微服务应该是可替换的，并且不应该保持持久状态，但可以从数据库中加载。这允许你使用Kubernetes等产品自动扩展你的应用程序。
- en: You should also split large tasks into small and separate microservices by logical
    domain. For example, create a separate microservice for handling accounts and
    another to render and show shopping carts in the online store. You can also add
    another microservice that processes payments, and they interact with each other
    with messages transferred by a message broker.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该通过逻辑领域将大型任务拆分成小而独立的微服务。例如，为处理账户创建一个单独的微服务，并为在线商店渲染和显示购物车创建另一个微服务。你还可以添加另一个处理支付并与其他微服务通过消息代理传递消息的微服务。
- en: Let's create an application that can be scaled by running extra instances of
    some of its components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以通过运行其某些组件的额外实例来扩展的应用程序。
- en: Scalable application with Rust and RabbitMQ
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rust和RabbitMQ构建可扩展的应用程序
- en: In this section, we will write an application that decodes QR codes from images
    to textual strings. We will create two services—one to handle incoming requests
    and for decoding tasks, and the second is a worker that will receive tasks and
    decode images to strings and return the result to a server. To implement interaction
    between services, we will use RabbitMQ. For the server and worker implementations,
    we will use the Actix framework. Before we start coding, let's start a RabbitMQ
    instance with Docker.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个应用程序，该程序可以从图像中解码QR码到文本字符串。我们将创建两个服务——一个用于处理传入请求和解码任务，另一个是工作器，它将接收任务并将图像解码为字符串，然后将结果返回到服务器。为了实现服务之间的交互，我们将使用RabbitMQ。对于服务器和工作器的实现，我们将使用Actix框架。在我们开始编码之前，让我们使用Docker启动一个RabbitMQ实例。
- en: Bootstrap message broker for testing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试启动消息代理引导信息
- en: 'To start RabbitMQ, we will use the official image for Docker from DockerHub,
    located here: [https://hub.docker.com/_/rabbitmq/](https://hub.docker.com/_/rabbitmq/).
    We have already used Docker to start instances of databases. Starting RabbitMQ
    is similar:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动RabbitMQ，我们将使用DockerHub上的官方Docker镜像，位于此处：[https://hub.docker.com/_/rabbitmq/](https://hub.docker.com/_/rabbitmq/)。我们已经使用Docker启动了数据库实例。启动RabbitMQ的过程类似：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We started a container called `test-rabbit` and forward port `5672` to the same
    port of the container. RabbitMQ images also exposes ports `4369`, `5671`, and
    `25672`. If you want to use the advanced features of the message broker, you need
    to open these ports too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动了一个名为`test-rabbit`的容器，并将端口`5672`转发到容器的相同端口。RabbitMQ镜像还公开了端口`4369`、`5671`和`25672`。如果你想使用消息代理的高级功能，你也需要打开这些端口。
- en: If you want to start an instance of RabbitMQ and have access to it from other
    containers, you can set the `--hostname` arguments for the `run` command and use
    the provided name from other containers to connect to the RabbitMQ instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要启动一个RabbitMQ实例并从其他容器访问它，你可以为`run`命令设置`--hostname`参数，并使用其他容器提供的名称来连接到RabbitMQ实例。
- en: 'When a message broker instance starts, you may need to get some statistics
    from it. The `rabbitmqctl` command can be executed inside the container using
    the `exec` command from Docker:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息代理实例启动时，你可能需要从它那里获取一些统计信息。可以使用Docker的`exec`命令在容器内执行`rabbitmqctl`命令：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It prints the available commands. Add any of them to the command, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出可用的命令。可以将其中任何一个添加到命令中，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command activates tracing all the messages pushed to queues,
    which you can see with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令激活了跟踪所有推送到队列的消息，你可以使用以下命令查看：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It prints the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印以下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we can create a microservice that uses the message broker for interaction
    with the worker.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个使用消息代理与工作器交互的微服务。
- en: Dependencies
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Create a new library crate (in which we will add two binaries later) called `rabbit-actix`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的库crate（稍后我们将添加两个二进制文件）名为`rabbit-actix`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we are using the 2018 edition of Rust. We need a pretty big
    pile of crates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用2018版的Rust。我们需要一大堆crate：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's important to note that we use the `actix` framework with the `actix-web`
    crate. If you are not familiar with this crate, you can read more about it in
    [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving Concurrency
    with Actors and Actix Crate*. We also use the `image` crate to work with image
    formats, because this crate is used by `queens-rock` and implements a decoder
    for QR codes. We also use the `askama` crate to render HTML pages with posted
    tasks, and we use the `indexmap` crate to get an ordered hash map that keeps elements
    insertion order. To create unique names for the tasks, we will use the UUID4 format,
    which is implemented in the `uuid` crate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们使用`actix`框架和`actix-web`crate。如果您不熟悉这个crate，您可以在第11章中了解更多信息，*使用Actix
    Crate和Actor处理并发*。我们还使用`image`crate来处理图像格式，因为这个crate被`queens-rock`使用，并实现了QR码的解码器。我们还使用`askama`crate来渲染带有已发布任务的HTML页面，并使用`indexmap`crate来获取一个保持元素插入顺序的有序哈希表。为了为任务创建唯一的名称，我们将使用UUID4格式，该格式在`uuid`crate中实现。
- en: 'To interact with RabbitMQ, we will use the `lapin-futures` crate, but we renamed
    it `lapin` because there are two implementations of this crate. The one that we
    use is based on the `futures` crate, and there is also the`lapin-async` crate
    version based on the `mio` crate. We will use the `lapin-futures` crate first,
    and name it `lapin`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要与RabbitMQ交互，我们将使用`lapin-futures`crate，但我们将其重命名为`lapin`，因为有两个此crate的实现。我们使用的是基于`futures`crate的实现，还有一个基于`mio`crate的`lapin-async`crate版本。我们将首先使用`lapin-futures`crate，并将其命名为`lapin`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the first binary with a server implementation pointing to the `src/server.rs`
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第一个二进制文件，其中包含指向`src/server.rs`文件的server实现：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the second binary for a worker that will be implemented in the `src/worker.rs`
    file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第二个二进制文件，用于实现将在`src/worker.rs`文件中的worker：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We already use the `askama` crate as a dependency for the main code, but we
    also need it as a dependency for the `build.rs` script. Add this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`askama`crate作为主代码的依赖项使用，但我们还需要它作为`build.rs`脚本的依赖项。添加以下内容：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding dependency needs to rebuild templates to embed them into code.
    Add the following code to a new `build.rs` script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的依赖项需要重新构建模板以将其嵌入到代码中。将以下代码添加到新的`build.rs`脚本中：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the dependencies are prepared, and we can create an abstract type to interact
    with queues in a message broker.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都已准备就绪，我们可以创建一个用于与消息代理中的队列交互的抽象类型。
- en: Abstract queue interaction actor
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象队列交互actor
- en: Add the `src/queue_actor.rs` actor, and let's create an actor that uses an abstract
    handler to process incoming messages and can send new messages to a queue. It
    also has to create all the necessary queues in RabbitMQ and subscribe to new events
    in the corresponding queue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`src/queue_actor.rs`中的actor，然后创建一个使用抽象处理器来处理传入消息并可以向队列发送新消息的actor。它还必须创建所有必要的RabbitMQ队列并订阅相应队列中的新事件。
- en: Dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'To create an actor, we need the following dependencies:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个actor，我们需要以下依赖项：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we use the `ensure_queue` function from the super module, which creates
    a new queue, but we will implement it later in this chapter. `spawn_client` lets
    us create a new `Client` connected to a message broker. We will use the `wrap_future`
    function, which converts any `Future` object into an `ActorFuture`, which can
    be spawned in the `Context` environment of the Actix framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用来自super模块的`ensure_queue`函数，该函数创建一个新的队列，但我们将在此章的后面实现它。`spawn_client`允许我们创建一个连接到消息代理的新`Client`。我们将使用`wrap_future`函数，该函数将任何`Future`对象转换为`ActorFuture`，这可以在Actix框架的`Context`环境中启动。
- en: Let's explore the types from the `lapin` crate. The `Channel` struct represents
    a connection channel with the RabbitMQ instance. `BasicConsumeOptions` represents
    options used for the `basic_consume` method of the `Channel` call to subscribe
    to new events in a queue. `BasicProperties` types are used as parameters for the `basic_publish`
    method call of the `Channel` type for add properties such as correlation IDs to
    distinct recipients of the message, or set the required quality level for delivery.
    `BasicPublishOptions` is used for the `basic_publish` call to set extra options
    for a message publishing activity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`lapin`crate中的类型。`Channel`结构体表示与RabbitMQ实例的连接通道。`BasicConsumeOptions`表示用于`Channel`调用中`basic_consume`方法的选项，用于订阅队列中的新事件。`BasicProperties`类型用于`Channel`类型的`basic_publish`方法调用的参数，用于添加如关联ID等属性到消息的不同接收者，或设置交付所需的质量级别。`BasicPublishOptions`用于`basic_publish`调用，以设置消息发布活动的额外选项。
- en: We also need the `Error` type from the `lapin` crate, but we renamed it `LapinError` because
    we also use the generic  `Error` from the `failure` crate. The `Delivery` struct
    represents an incoming message delivered from a queue. The `FieldTable` type is
    used as a parameter for the `basic_consume` method call of the `Channel` type.
    The `ShortString` type is a simple alias to a `String` that is used as a name
    of a queue in the `lapin` crate. The `Uuid` type is imported from the `uuid` crate
    to generate unique correlation IDs for messages to identify the origin of a message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`lapin`包中获取`Error`类型，但我们将它重命名为`LapinError`，因为我们还使用了来自`failure`包的泛型`Error`。`Delivery`结构体代表从队列中传递过来的入站消息。`FieldTable`类型被用作`Channel`类型的`basic_consume`方法调用的参数。`ShortString`类型是一个简单的别名，用于在`lapin`包中将`String`用作队列的名称。`Uuid`类型是从`uuid`包导入的，用于为消息生成唯一的关联ID以识别消息的来源。
- en: Now, we can declare the abstract handler for our messages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明我们消息的抽象处理器。
- en: Abstract messages handler
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象消息处理器
- en: 'Create the `QueueHandler` struct in the `queue_actor.rs` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`queue_actor.rs`文件中创建`QueueHandler`结构体：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`QueueHandler` is a trait that has two associated types and three methods.
    It requires a `static` lifetime for types that will implement the `QueueHandler`
    trait, because instances of this trait will be used as fields of actors that have
    a static lifetime as well.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueHandler`是一个具有两个关联类型和三个方法的特质。它要求实现`QueueHandler`特质的类型具有`static`生命周期，因为此特质的实例将被用作具有静态生命周期的演员的字段。'
- en: This trait has the `Incoming` associated type, which represents the incoming
    message type and requires the type to implement the `Deserialize` trait to be
    deserializable, because RabbitMQ transfers byte arrays only and you have to decide
    which format to use for serialization. The `Outgoing` associated type has to implement
    the `Serialize` trait to be serializable as a bytes array to be sent as an outgoing
    message.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此特质有一个`Incoming`关联类型，它代表入站消息类型，并要求类型实现`Deserialize`特质以便可反序列化，因为RabbitMQ只传输字节数组，你必须决定使用哪种格式进行序列化。`Outgoing`关联类型必须实现`Serialize`特质以便可序列化为字节数组，以便作为出站消息发送。
- en: '`The QueueHandler`  trait also has `incoming` and `outgoing` methods. The first
    returns the name of a queue to consume incoming messages. The second method returns
    the name of a queue in which an actor will write sending messages. There is also
    a `handle` method, which takes a reference to `TaskId` and incoming messages of the `Self::Incoming`
    associated type. The method returns a `Result` with an optional `Self::Outgoing`
    instance. If the implementation returns `None` then no messages will be sent to
    the outgoing channel. However, you can use a special `SendMessage` type to send
    a message later. We will declare this type later, after we add the actor''s struct.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueHandler`特质也有`incoming`和`outgoing`方法。第一个方法返回要消费入站消息的队列名称。第二个方法返回一个演员将要写入发送消息的队列名称。还有一个`handle`方法，它接受一个`TaskId`的引用和`Self::Incoming`关联类型的入站消息。该方法返回一个包含可选`Self::Outgoing`实例的`Result`。如果实现返回`None`，则不会将消息发送到出站通道。然而，你可以使用特殊的`SendMessage`类型稍后发送消息。我们将在添加演员的结构体之后声明此类型。'
- en: Actor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'Add a new struct called `QueueActor` and add a type parameter that implements the `QueueHandler`
    trait:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的结构体`QueueActor`，并添加一个实现`QueueHandler`特质的类型参数：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The struct has a reference to a connection `Channel` to RabbitMQ. We build it
    over `TcpStream`. The struct also has a `handler` field that contains an instance
    of a handler that implements `QueueHandler`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体有一个指向RabbitMQ连接`Channel`的引用。我们通过`TcpStream`构建它。结构体还有一个`handler`字段，其中包含一个实现`QueueHandler`的处理器的实例。
- en: 'This struct also has to implement the `Actor` trait to become an actor. We
    also added a `started` method. It remains empty, but it''s a good place to create
    all the queues. For example, you can create a message type that will attach a
    `Stream` of messages to this actor. With this approach, you can start consuming
    any queue at any time:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构体还必须实现`Actor`特质才能成为演员。我们还添加了一个`started`方法。它目前为空，但这是一个创建所有队列的好地方。例如，你可以创建一个消息类型，将消息的`Stream`附加到这个演员上。使用这种方法，你可以随时开始消费任何队列：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will initialize all the queues in the `new` method to interrupt actor creation
    if something goes wrong:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`new`方法中初始化所有队列，如果出现问题将中断演员的创建：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We call the `spawn_client` function, which we will implement later, to create
    a `Client` that's connected to a message broker. The function returns a `Channel`
    instance, which is created by the connected `Client`. We use `Channel` to ensure
    the queue we need exists, or create it with `ensure_queue`. This method is implemented
    later in this chapter. We use the result of the `QueueHandler::outgoing` method
    to get the name of the queue to create.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用稍后将要实现的`spawn_client`函数，以创建一个连接到消息代理的`Client`。该函数返回一个`Channel`实例，该实例由连接的`Client`创建。我们使用`Channel`来确保所需的队列存在，或者使用`ensure_queue`创建它。此方法将在本章稍后实现。我们使用`QueueHandler::outgoing`方法的结果来获取要创建的队列的名称。
- en: This method expects `SystemRunner` to execute `Future` objects immediately by
    calling the `block_on` method. It lets us get a `Result` and interrupts other
    activities if the method call fails.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法期望`SystemRunner`通过调用`block_on`方法立即执行`Future`对象。它允许我们获取`Result`，如果方法调用失败，则中断其他活动。
- en: After that, we create a queue using the name we get with the `QueueHandler::incoming`
    method call. We will consume messages from this queue and use the `basic_consume`
    method of a `Channel` that starts listening for new messages. To call `basic_consume`,
    we also created default values of the `BasicConsumeOptions` and `FieldTable` types.
    `basic_consume` returns a `Future` that will be resolved to a `Stream` value.
    We use the `block_on` method call of the `SystemRunner` instance to execute this
    `Future` to get a `Stream` instance to attach it to `QueueActor`. We create the
    `QueueActor` instance using the `create` method call, which expects a closure,
    which in turn takes a reference to a `Context`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`QueueHandler::incoming`方法调用的名称创建一个队列。我们将从这个队列中消费消息，并使用`Channel`的`basic_consume`方法开始监听新消息。要调用`basic_consume`，我们还创建了`BasicConsumeOptions`和`FieldTable`类型的默认值。`basic_consume`返回一个将解析为`Stream`值的`Future`。我们使用`SystemRunner`实例的`block_on`方法调用执行此`Future`以获取一个`Stream`实例并将其附加到`QueueActor`。我们使用`create`方法调用创建`QueueActor`实例，该方法期望一个闭包，该闭包反过来又接受一个`Context`的引用。
- en: Handling an incoming stream
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理传入的流
- en: 'We used the `basic_consume` method of a `Channel` to create a `Stream` that
    returns `Delivery` objects from a queue. Since we want to attach that `Stream`
    to the actor, we have to implement `StreamHandler` for the `QueueActor` type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Channel`的`basic_consume`方法创建了一个返回`Delivery`对象的`Stream`，这些对象来自一个队列。由于我们想将这个`Stream`附加到actor上，我们必须为`QueueActor`类型实现`StreamHandler`：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our `StreamHandler` implementation expects a `Delivery` instance. RabbitMQ expects
    that a client will send an acknowledgement when it consumes the delivered message.
    We do it with the `basic_ack` method call of a `Channel` instance stored as a
    field of `QueueActor`. This method call returns a `Future` instance that we will
    `spawn` in a `Context` to send an acknowledgement that the message was received.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`StreamHandler`实现期望一个`Delivery`实例。RabbitMQ期望客户端在消费投递的消息时发送确认。我们通过将`QueueActor`的字段存储为`Channel`实例的`basic_ack`方法调用来完成此操作。此方法调用返回一个`Future`实例，我们将将其`spawn`在一个`Context`中以发送消息已被接收的确认。
- en: RabbitMQ requires a consumer to notify with every message that is processed.
    If a consumer doesn't do this, then the message is left hanging in the queue.
    But you can set the `no_ack` field of the `BasicConsumeOptions` struct to `true`
    and the message will be marked as delivered as soon as the consumer reads it.
    But if your application fails before the message is processed, you will lose the
    message. It's only suitable for non-critical messages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ要求消费者在处理每条消息时进行通知。如果消费者不这样做，则消息将悬挂在队列中。但你可以将`BasicConsumeOptions`结构体的`no_ack`字段设置为`true`，这样消息一旦被消费者读取就会被标记为已投递。但如果你的应用程序在处理消息之前失败，你将丢失该消息。这仅适用于非关键消息。
- en: We use the `process_message` method that we will implement later to process
    a message using the `QueueHandler` instance. If this method returns a not `None`
    value, we will use it as a response message and send it to an outgoing queue using
    the `send_message` method, which we will also implement later in this chapter.
    But now we will add a message to initiate an outgoing message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用稍后将要实现的`process_message`方法，使用`QueueHandler`实例处理消息。如果此方法返回一个非`None`值，我们将将其用作响应消息，并使用`send_message`方法将其发送到输出队列，该方法我们将在本章稍后实现。但现在我们将添加一条消息以启动输出消息。
- en: Sending a new message
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送新消息
- en: '`QueueActor` has to send a new message, because we will use this actor to send
    tasks to a worker. Add the corresponding struct:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueActor`必须发送一条新消息，因为我们将使用此actor将任务发送到worker。添加相应的结构体：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `Message` trait for this type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为此类型实现 `Message` 特性：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need to set the `Result` type to `TaskId`, because we will generate a new
    task ID for a new message to process the response with a handler later. If you
    are not familiar with the Actix framework and message, return to [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml),
    *In**volving Concurrency with Actors and Actix Crate*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `Result` 类型设置为 `TaskId`，因为我们将为处理响应的处理器生成一个新的任务 ID。如果你不熟悉 Actix 框架和消息，请回到
    [第 11 章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)，*使用 Actor 和 Actix Crate 涉及并发*。
- en: 'The `Handler` of this message type will generate a new UUID and convert it
    into a `String`. Then, the method will use the `send_message` method to send a
    message to an outgoing queue:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息类型的 `Handler` 将生成一个新的 UUID 并将其转换为 `String`。然后，该方法将使用 `send_message` 方法向输出队列发送消息：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we have to implement the `process_message` and `send_message` methods of
    `QueueActor`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实现 `QueueActor` 的 `process_message` 和 `send_message` 方法。
- en: Utility methods
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具方法
- en: 'Let''s add the `process_message` method, which processes incoming `Delivery`
    items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 `process_message` 方法，它处理传入的 `Delivery` 项目：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we have to get a unique ID associated with a message. If you remember,
    we used the UUID in this case. We stored it in the correlation ID field of the
    message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取与消息相关联的唯一 ID。如果你还记得，我们在这个例子中使用了 UUID。我们将其存储在消息的关联 ID 字段中。
- en: A correlation ID represents a value that is associated with a message as a tag
    for the response. This information is used to implement **Remote Procedure Calls**
    (**RPC**s) over RabbitMQ. If you skipped [Chapter 6](fd4bf12a-bb05-469b-a230-163cee412261.xhtml),
    *Reactive Microservices - Increasing Capacity and Performance*, you can return
    to it to read more about RPCs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关联 ID 代表一个与消息相关联的值，作为响应的标签。此信息用于在 RabbitMQ 上实现 **远程过程调用**（RPC）。如果你跳过了 [第 6 章](fd4bf12a-bb05-469b-a230-163cee412261.xhtml)，*反应式微服务
    - 提高容量和性能*，你可以回到那里阅读更多关于 RPC 的内容。
- en: We use JSON format for our messages, and we parse using `serde_json` to create
    incoming data that is stored in the `data` field of the `Delivery` instance. If
    a deserialization was successful, we take the value of the `Self::Incoming` type.
    Now, we have all the information we need to call the `handle` method of the `QueueHandler`
    instance—the correlation ID and a deserialized incoming message. The handler returns
    a `Self::Outgoing` message instance, but we won't serialize it immediately for
    sending, because it will use the `send_message` method that we used to process
    incoming messages. Let's implement it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 JSON 格式来处理消息，并使用 `serde_json` 解析以创建存储在 `Delivery` 实例的 `data` 字段中的传入数据。如果反序列化成功，我们取
    `Self::Incoming` 类型的值。现在，我们拥有了调用 `QueueHandler` 实例的 `handle` 方法所需的所有信息——关联 ID
    和反序列化的传入消息。处理程序返回一个 `Self::Outgoing` 消息实例，但我们不会立即对其进行序列化以发送，因为它将使用我们用于处理传入消息的
    `send_message` 方法。让我们来实现它。
- en: 'The `send_message` method takes a correlation ID and an outgoing value to prepare
    and send a message:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_message` 方法接收一个关联 ID 和一个输出值来准备并发送一条消息：'
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, the method serializes a value to binary data. If the value is serialized
    to JSON successfully, we prepare options and properties to call the `basic_publish`
    method of a `Channel` to send a message to an outgoing queue. It's worth noting
    that we associated the provided correlation ID to the `BasicProperties` struct
    that's used with the `basic_publish` call. Publishing a message returns a `Future`
    instance, which we have to spawn in the context of an `Actor`. If we can't serialize
    a value, we will log an error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该方法将值序列化为二进制数据。如果值成功序列化为 JSON，我们将准备选项和属性以调用 `Channel` 的 `basic_publish` 方法向输出队列发送消息。值得注意的是，我们将提供的关联
    ID 与用于 `basic_publish` 调用的 `BasicProperties` 结构相关联。发布消息返回一个 `Future` 实例，我们必须在
    `Actor` 的上下文中启动它。如果我们无法序列化值，我们将记录一个错误。
- en: Now, we can finish implementing the library part of the crate by adding the `spawn_client`
    and `ensure_queue` functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加 `spawn_client` 和 `ensure_queue` 函数来完成 crate 的库部分实现。
- en: Crate
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crate
- en: 'Add the following imports to the `src/lib.rs` source file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到 `src/lib.rs` 源文件中：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You are familiar with some types. Let's discuss some of the new ones. `Client`
    represents a client that connects to RabbitMQ. The `Channel` type will be created
    as a result of a connection and is returned by a `Client`. `QueueDeclareOptions` is
    used as a parameter for the `queue_declare` method call of a `Channel`. `ConnectionOptions`
    is necessary to establish a connection, but we will use default values. `Queue`
    represents a queue in RabbitMQ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉一些类型。让我们讨论一些新的类型。`Client` 代表连接到 RabbitMQ 的客户端。`Channel` 类型将在连接的结果中创建，并由 `Client`
    返回。`QueueDeclareOptions` 用作 `Channel` 的 `queue_declare` 方法调用的参数。`ConnectionOptions`
    是建立连接所必需的，但我们将使用默认值。`Queue` 代表 RabbitMQ 中的队列。
- en: 'We need two queues: one for requests and one for responses. We will specify
    the destination of messages with the correlation ID. Add the following constants
    to be used as the names of queues:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个队列：一个用于请求，一个用于响应。我们将使用关联 ID 指定消息的目的地。添加以下常量作为队列的名称：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To spawn a `Client` and create a `Channel`, we will add the `spawn_client`
    function, which creates a `Client` and produces a `Channel` from it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个 `Client` 并创建一个 `Channel`，我们将添加 `spawn_client` 函数，该函数创建一个 `Client` 并从它生成一个
    `Channel`：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The implementation of the preceding function is simple enough. We create a `TcpStream`
    from a constant address with the `connect` method call. You can make the address
    parameter configurable if necessary. The `connect` method returns a `Future` that
    we use to create a combinator that maps to a new `Client` connected to RabbitMQ.
    We use `block_on` of `SystemRunner` to execute that `Future` immediately. It returns
    a `Client` and a `Heartbeat` instance. The `Client` instance is used to create
    an instance of `Channel`. The `Heartbeat` instance is a task that pings RabbitMQ
    with a connection that has to be spawned as a concurrent activity in the event
    loop. We use `actix::spawn` to run it, because we don't have the `Context` of
    an `Actor`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的实现足够简单。我们使用 `connect` 方法调用从一个常量地址创建一个 `TcpStream`。如果需要，你可以使地址参数可配置。`connect`
    方法返回一个 `Future`，我们使用它来创建一个映射到连接到 RabbitMQ 的新 `Client` 的组合器。我们使用 `SystemRunner`
    的 `block_on` 来立即执行该 `Future`。它返回一个 `Client` 和一个 `Heartbeat` 实例。`Client` 实例用于创建
    `Channel` 的实例。`Heartbeat` 实例是一个任务，它使用必须作为事件循环中的并发活动产生的连接来ping RabbitMQ。我们使用 `actix::spawn`
    来运行它，因为我们没有 `Actor` 的 `Context`。
- en: Finally, we call the `create_channel` method of a `Client` to create a `Channel`.
    But the method returns a `Future`, which we also execute with the `block_on` method.
    Now, we can return the created `Channel` and implement the `ensure_queue` method,
    which expects that `Channel` instance as a parameter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `Client` 的 `create_channel` 方法来创建一个 `Channel`。但是该方法返回一个 `Future`，我们也使用
    `block_on` 方法来执行它。现在，我们可以返回创建的 `Channel` 并实现 `ensure_queue` 方法，该方法期望该 `Channel`
    实例作为参数。
- en: 'The `ensure_queue` method creates the option to call the `queue_declare` method,
    which creates a queue inside RabbitMQ:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensure_queue` 方法创建了一个调用 `queue_declare` 方法的选项，该方法在 RabbitMQ 内部创建一个队列：'
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We fill `QueueDeclareOptions` with default parameters, but set the `auto_delete`
    field to `true`, because we want the created queues to be deleted when an application
    ends. It's suitable for testing purposes. In this method, we won't execute a `Future`
    that is returned by the `queue_declare` method immediately. We return it as is
    to enable the calling environment to make a combinator with the returned `Queue`
    value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用默认参数填充 `QueueDeclareOptions`，但将 `auto_delete` 字段设置为 `true`，因为我们希望创建的队列在应用程序结束时被删除。这对于测试目的来说很合适。在这个方法中，我们不会立即执行由
    `queue_declare` 方法返回的 `Future`。我们按原样返回它，以便调用环境可以使用返回的 `Queue` 值创建组合器。
- en: We have implemented all the necessary parts to create a server and a worker.
    Now, we need to declare request and response types to use them in a worker and
    in a server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了创建服务器和工人的所有必要部分。现在，我们需要声明请求和响应类型，以便在工人和服务器中使用它们。
- en: Request and response
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应
- en: 'The request type called `QrRequest` contains data about the QR image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `QrRequest` 的请求类型包含有关 QR 图像的数据：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It implements the `Message` trait from `actix`, which is to be set as an associated
    type of `QueueHandler`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了来自 `actix` 的 `Message` 特性，该特性将被设置为 `QueueHandler` 的关联类型：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The response type is represented by the `QrResponse` enumeration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 响应类型由 `QrResponse` 枚举表示：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It contains two variants: `Succeed` for successful results and `Failed` for
    errors. It is similar to the `Result` type of the standard library, but we decided
    to add our own type to have a chance to override the serialization behavior when
    we need it. But we can construct this response from a `Result` instance by implementing
    the `From` trait. It''s useful because we can use a function to construct a value
    that returns the `Result` type. Look at the implementation here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含两个变体：`Succeed`用于成功结果，`Failed`用于错误。它与标准库中的`Result`类型类似，但我们决定添加我们自己的类型，以便在我们需要时有机会覆盖序列化行为。但我们可以通过实现`From`特质从`Result`实例构建此响应。这很有用，因为我们可以使用一个函数来构建返回`Result`类型的值。请看这里的实现：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`QrResponse` also has to implement the `Message` trait:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`QrResponse`还必须实现`Message`特质：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The library crate is ready to be used to create a worker and a server. Let's
    start by implementing a worker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 库crate已准备好用于创建一个工作器和服务器。让我们先实现一个工作器。
- en: Worker
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作器
- en: The worker will consume all the messages from the requests queue and try to
    decode them as QR images to strings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 工作器将消费请求队列中的所有消息，并尝试将它们解码为QR图像字符串。
- en: Dependencies
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'We need the following types for the implementation of a worker:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下类型来实现工作器的实现：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We imported all the necessary types earlier in this chapter. We also imported
    two types for decoding QR images. `GenericImageView` provides the `to_luma` method
    to convert an image into grayscale. The `Scanner` method is a decoder of QR codes
    provided as grayscale images.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经导入了所有必要的类型。我们还导入了用于解码QR图像的两个类型。`GenericImageView`提供了将图像转换为灰度的`to_luma`方法。`Scanner`方法是一个将灰度图像作为QR码提供的解码器。
- en: Handler
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序
- en: 'We need to create an empty struct, because our worker doesn''t have a state
    and will only transform incoming messages:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个空的结构体，因为我们的工作器没有状态，并且只会转换传入的消息：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We use the `WorkerHandler` struct as the handler for the queue and use it with
    `QueueActor` later. Implement the `QueueHandler` trait, which is required by `QueueActor`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`WorkerHandler`结构体作为队列的处理程序，并在稍后与`QueueActor`一起使用。实现`QueueHandler`特质，这是`QueueActor`所需的：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since this handler takes requests and prepares responses, we set `QrRequest`
    as the `Incoming` type and `QrResponse` as the `Outgoing` type. The `incoming`
    method returns the value of the `REQUESTS` constant that we will use as a name
    for incoming queues. The `outgoing` method returns the `RESPONSES` constant, which
    is used as the name for the queue of outgoing messages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此处理程序接收请求并准备响应，我们将`QrRequest`设置为`Incoming`类型，将`QrResponse`设置为`Outgoing`类型。`incoming`方法返回`REQUESTS`常量的值，我们将用作传入队列的名称。`outgoing`方法返回`RESPONSES`常量，用作传出消息队列的名称。
- en: 'The `handle` method of `QueueHandler` takes a request and calls the `scan`
    method with data. Then, it converts the `Result` into a `QrResponse` and returns
    it. Let''s implement the `scan` method, which decodes images:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueHandler`的`handle`方法接收一个请求并使用数据调用`scan`方法。然后，它将`Result`转换为`QrResponse`并返回它。让我们实现解码图像的`scan`方法：'
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The implementation of the function is not important from a microservices point
    of view, and I will describe it shortly—it loads an `Image` from the provided
    bytes, converts the `Image` to grayscale with the `to_luma` method, and provides
    the returned value as an argument for a `Scanner`. Then, it uses the `scan` method
    to decode the QR code and extracts the first `Code` converted to a `String`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从微服务角度来看，函数的实现并不重要，我将简要描述它——它从提供的字节中加载一个`Image`，使用`to_luma`方法将`Image`转换为灰度，并将返回值作为`Scanner`的参数提供。然后，它使用`scan`方法解码QR码并提取转换为`String`的第一个`Code`。
- en: main function
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'Now, we can add a `main` function to spawn an actor with the decoding worker:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个`main`函数来创建一个带有解码工作器的actor：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method starts a `System` and creates an instance of `QueueActor` with an
    instance of `WorkerHandler`. That's all. It's really simple—with `QueueActor`,
    it's enough to implement `QueueHandler` to make a processor to a queue. Let's
    create a server in a similar way.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法启动一个`System`并创建一个`QueueActor`的实例，该实例包含一个`WorkerHandler`的实例。就是这样。这真的很简单——使用`QueueActor`，只需实现`QueueHandler`即可将处理器转换为队列。让我们以类似的方式创建一个服务器。
- en: Server
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: To implement a server, we don't just implement `QueueHandler`. We also have
    to implement handlers for HTTP requests. We will also use the `actix` and `actix-web`
    crates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现服务器，我们不仅要实现`QueueHandler`，还要实现HTTP请求的处理程序。我们还将使用`actix`和`actix-web`crate。
- en: Dependencies
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Add the following types to the `server.rs` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下类型添加到`server.rs`文件中：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You should be familiar with all the types, because we used most of them in the
    previous chapters, excluding `MultipartItem` and `MultipartError`. Both of these
    types are used to extract uploaded files from POST requests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉所有这些类型，因为我们已经在之前的章节中使用了它们中的大多数，除了 `MultipartItem` 和 `MultipartError`。这两种类型都用于从POST请求中提取上传的文件。
- en: Shared state
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享状态
- en: 'We will also add the `SharedTasks` type alias, which represents an `IndexMap`
    wrapped with `Mutex` and `Arc`. We will use this type to store all the tasks and
    statuses for them:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加 `SharedTasks` 类型别名，它表示由 `Mutex` 和 `Arc` 包装的 `IndexMap`。我们将使用此类型来存储所有任务及其状态：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Record` is a struct that contains the unique identifier of the task, and is
    used as the correlation ID for the message. It also has a `timestamp` that denotes
    when the task was posted, and a `Status` that represents the status of the task:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record` 是一个包含任务唯一标识符的结构体，用作消息的相关ID。它还有一个 `timestamp`，表示任务被发布的时间，以及一个 `Status`，表示任务的状态：'
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Status` is an enumeration that has two variants: `InProgress`, when a task
    is sent to a worker; and `Done`, when a worker returns a response as a `QrResponse`
    value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Status` 是一个枚举，有两个变体：`InProgress`，当任务被发送到工作者时；和 `Done`，当工作者以 `QrResponse` 值返回响应时：'
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need to implement the `Display` trait for `Status`, because we will use
    it to render the HTML template. Implement the trait:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 `Status` 实现 `Display` 特性，因为我们将会用它来渲染HTML模板。实现此特性：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will show three statuses: in progress, succeed, and failed.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示三种状态：进行中、成功和失败。
- en: 'Our server needs a shared state. We will use the `State` struct with a map
    of tasks and an address of `QueueActor` and `ServerHandler`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器需要一个共享状态。我们将使用带有任务映射和 `QueueActor` 及 `ServerHandler` 地址的 `State` 结构体：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we can implement `ServerHandler` and spawn an actor with it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现 `ServerHandler` 并使用它创建一个actor。
- en: Server handler
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器处理器
- en: 'To consume responses from a worker, our server has to start `QueueActor` with
    a handler that will update the shared state of a server. Create a `ServerHandler`
    struct that keeps a copy of the `SharedTasks` reference:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从工作者那里消费响应，我们的服务器必须启动 `QueueActor` 并带有将更新服务器共享状态的处理器。创建一个包含 `SharedTasks`
    引用副本的 `ServerHandler` 结构体：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the `QueueHandler` for this struct:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为此结构体实现 `QueueHandler`：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The handler of the server has to use the `RESPONSES` queue to consume responses,
    and `REQUESTS` as the outgoing queue to send requests. Correspondingly, set `QrResponse`
    to the `Incoming` type and `QrRequest` to the `Outgoing` type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器处理器必须使用 `RESPONSES` 队列来消费响应，并将 `REQUESTS` 作为发送请求的输出队列。相应地，将 `QrResponse`
    设置为 `Incoming` 类型，将 `QrRequest` 设置为 `Outgoing` 类型。
- en: The `handle` method locks a `Mutex` stored in the `tasks` field to get access
    to `IndexMap` and update the `status` field of `Record` if the record exists for
    a corresponding task ID. The ID of the task will be automatically extracted by
    `QueueActor` and is provided to this method by an immutable reference. It's time
    to implement all the necessary HTTP handlers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle` 方法锁定存储在 `tasks` 字段的 `Mutex`，以获取对 `IndexMap` 的访问权限，并在存在对应任务ID的记录时更新
    `Record` 的 `status` 字段。任务ID将由 `QueueActor` 自动提取，并通过不可变引用提供给此方法。现在是实现所有必要的HTTP处理器的时候了。'
- en: Requests handlers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求处理器
- en: 'We need three handlers for requests: an index page to show the name of the
    microservice, a handler for rendering all tasks and their statuses, and an uploading
    handler for posing new tasks with QR codes.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为请求实现三个处理器：一个显示微服务名称的索引页面、渲染所有任务及其状态的处理器，以及用于上传带有二维码的新任务的处理器。
- en: Index handler
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引处理器
- en: '`index_handler` returns some text with the name of this microservice:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`index_handler` 返回包含此微服务名称的文本：'
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tasks handler
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务处理器
- en: '`tasks_handler` locks a `Mutex` with `IndexMap` to iterate over all `Record`
    values to render them as a part of the `Tasks` struct:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasks_handler` 使用 `Mutex` 和 `IndexMap` 锁定，以便迭代所有 `Record` 值并将它们作为 `Tasks`
    结构体的一部分进行渲染：'
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you remember, we added the `askama` crate to render templates. Create a `templates`
    folder in the root of project and add a `tasks.html` file with some HTML code
    that contains at least the following rendering table:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们添加了 `askama` crate 来渲染模板。在项目的根目录中创建一个 `templates` 文件夹，并添加一个 `tasks.html`
    文件，其中包含一些HTML代码，至少包含以下渲染表格：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a part of the full template that you can find in the examples folder
    for this book, but the preceding code contains code for rendering a table with
    all the tasks extracted from the `Tasks` struct, which is  implemented as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以在本书示例文件夹中找到的完整模板的一部分，但前面的代码包含用于渲染从 `Tasks` 结构体中提取的所有任务的表格的代码，其实现如下：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Derive the `Template` type for this struct and attach the template with the `template`
    attribute. `askama` will embed the template into your code. That's very convenient.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为此结构派生`Template`类型，并使用`template`属性附加模板。`askama`会将模板嵌入到你的代码中。这非常方便。
- en: Upload handler
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传处理器
- en: '`upload_handler` is a bit complex, because it takes POST requests with a form
    that contains the uploaded image:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_handler`稍微复杂一些，因为它接受包含上传图像的表单的POST请求：'
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The implementation gets a `Stream` of `MultipartItem`, the value of which could
    be either `Filed` or `Nested`. We use the following function to collect all items
    in a single uniform `Stream` of `Vec<u8>` objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实现获取一个`MultipartItem`的`Stream`，其值可以是`Filed`或`Nested`。我们使用以下函数来收集所有项目到一个单一的统一`Stream`的`Vec<u8>`对象中：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, we extract the first item with the `into_future` method. If the value
    exists, we map it to `QrRequest` and use the address of `QueueActor` to `send`
    a request to a worker.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`into_future`方法提取第一个项目。如果值存在，我们将其映射到`QrRequest`并使用`QueueActor`的地址向一个worker发送请求。
- en: You may ask whether it is possible if a worker returns a result if the ID of
    task wasn't set. Potentially, it's possible. If you want to have a reliable changing
    of `State`, you should implement an actor that works with the `State` instance
    exclusively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果任务的ID没有设置，worker返回结果是否可能。潜在地，这是可能的。如果你想有一个可靠的`State`变化，你应该实现一个仅与`State`实例一起工作的actor。
- en: Finally, the handler constructs a `HttpResponse` value that redirects the client
    to the `/tasks` path.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理器构建一个`HttpResponse`值，将客户端重定向到`/tasks`路径。
- en: Now, we can connect each part in a single function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将所有部分连接到一个单独的函数中。
- en: main function
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'We have already created functions that create app instances of `actix` in [Chapter
    11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *In**volving Concurrency with
    Actors and Actix Crate*. Return to that chapter if you don''t remember how to
    attach handlers and a state to an application, and look at the `main` function,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第11章](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml)，*涉及并发与Actors和Actix Crate*中创建了创建`actix`应用程序实例的函数。如果你不记得如何将处理器和状态附加到应用程序，请回到该章节，查看以下`main`函数：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function creates a `System` instance with a new method that returns a `SystemRunner`
    instance, which we will use to start `QueueActor` with `ServerHandler` inside.
    Then, it creates a `State` instance with the address of the spawned actor and
    fills the `App` object with all the necessary handlers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个带有新方法的`System`实例，该方法返回一个`SystemRunner`实例，我们将使用它来启动包含`ServerHandler`的`QueueActor`。然后，它创建一个带有已孵化actor地址的`State`实例，并将所有必要的处理器填充到`App`对象中。
- en: When we start a `SystemRunner`, it creates an actor and connects to RabbitMQ
    to create all the necessary queues and starts consuming the responses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个`SystemRunner`时，它会创建一个actor并连接到RabbitMQ来创建所有必要的队列并开始消费响应。
- en: A good practice is to create the same queues from all the applications that
    use it, because you can't know which part will be started first—the server or
    the worker. That's why we implemented the creation of all the queues in the `new`
    method of `QueueAction`. All queues will be available before any piece of code
    uses them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是创建所有使用它的应用程序的相同队列，因为你无法知道哪个部分会先启动——服务器还是worker。这就是为什么我们在`QueueAction`的`new`方法中实现了所有队列的创建。所有队列在任何代码使用它们之前都将可用。
- en: We are ready to test this example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好测试这个示例。
- en: Testing
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Let's build and run the server and worker of the application. You should start
    a container with a RabbitMQ instance, as we did in this chapter in the *Bootstrap
    message broker for testing* section. Then, use `cargo build` to build all the parts.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序的服务器和worker。你应该启动一个包含RabbitMQ实例的容器，就像我们在本章的*Bootstrap消息代理测试*部分所做的那样。然后，使用`cargo
    build`来构建所有部分。
- en: 'When compilation has finished, start a server instance:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译完成后，启动一个服务器实例：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Also, start a worker instance with the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用以下命令启动一个worker实例：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When both parts have started, you can explore RabbitMQ with the `rabbitmqctl`
    command and explore your queues:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个部分都启动后，你可以使用`rabbitmqctl`命令探索RabbitMQ并查看你的队列：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It prints both the queues that were created by the actors:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出actors创建的所有队列：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you want to see all connected consumers, you can do that with the following
    command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看所有已连接的消费者，你可以使用以下命令：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It prints `responses-consumer`, which represents a server instance, and `requests-consumer`,
    which represents a worker instance:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出`responses-consumer`，代表一个服务器实例，以及`requests-consumer`，代表一个工作实例：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that everything is connected to RabbitMQ, we can open `http://localhost:8080/tasks`
    in a browser. You will see an empty table and a form to upload a QR code. Choose
    a file and upload it using the form. It will refresh the page and you will see
    your task in progress:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经连接到RabbitMQ，我们可以在浏览器中打开`http://localhost:8080/tasks`。你会看到一个空表和一个上传QR码的表单。选择一个文件，并使用表单上传。页面会刷新，你会看到你的任务正在进行中：
- en: '![](img/d48e3f3d-fc8c-45ec-b298-d526a231ab5c.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d48e3f3d-fc8c-45ec-b298-d526a231ab5c.png)'
- en: 'If the worker works properly and if you refresh the page after short period
    of time, you will see the decoded QR code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工作者工作正常，并且你在短时间内刷新页面，你会看到解码后的QR码：
- en: '![](img/239f03f8-e6da-434f-81a2-598cf7ba722b.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/239f03f8-e6da-434f-81a2-598cf7ba722b.png)'
- en: As you can see, the server and worker interact with a message that was delivered
    by RabbitMQ.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，服务器和工作者通过RabbitMQ传递的消息进行交互。
- en: Let's discuss the benefits and drawbacks of this solution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这个解决方案的优缺点。
- en: How to scale this application
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何扩展这个应用程序
- en: The example we created in this chapter uses two parts that work separately and
    use RabbitMQ to exchange tasks and results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的示例使用两个独立工作并使用RabbitMQ交换任务和结果的组件。
- en: Scaling this application is very easy—you just need to start as many workers
    as you want, and they don't have to work on the same server. You can run workers
    on a distributed cluster of servers. If your workers can't handle a load, you
    can start extra workers that will consume waiting tasks immediately and start
    the decoding process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展这个应用程序非常简单——你只需要启动任意数量的工作者，他们不需要在同一个服务器上工作。你可以在分布式的服务器集群上运行工作者。如果你的工作者无法处理负载，你可以启动额外的工人，他们可以立即消费等待的任务并开始解码过程。
- en: But this system has a potential bottleneck – the message broker. For this example,
    you can simply handle it if you start extra independent message brokers; for example,
    RabbitMQ support multiple instances with its clustering feature. Your server can
    have multiple connections with multiple message brokers, but you can't spawn as
    many servers as you want because they will have different sets of tasks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个系统有一个潜在的瓶颈——消息代理。对于这个示例，如果你启动额外的独立消息代理，你可以简单地处理它；例如，RabbitMQ通过其集群功能支持多个实例。你的服务器可以与多个消息代理建立多个连接，但你不能启动任意数量的服务器，因为它们将具有不同的任务集。
- en: Is it possible to share a list of tasks? Yes, you can use a traditional database
    or storage, such as Redis, but it becomes another bottleneck, because it's hard
    to use the same database instance for millions of clients.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以共享任务列表？是的，你可以使用传统的数据库或存储，如Redis，但它成为另一个瓶颈，因为很难为百万级客户使用相同的数据库实例。
- en: How can we handle the bottleneck with a database? You can split the tasks list
    by client and keep the list for a specific client on one instance of storage.
    If you want to provide a feature where your clients share tasks with each other,
    you can create shared lists and store them in a database, which won't have a heavy
    load in this case.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理数据库的瓶颈问题？你可以通过客户来分割任务列表，并将特定客户的列表保存在存储的一个实例上。如果你想提供一个功能，让客户之间可以共享任务，你可以创建共享列表并将它们存储在数据库中，在这种情况下，数据库的负载不会很重。
- en: As you can see, scaling is an undefined process, and you have to do some experimenting
    to achieve the desired result. But in any case, you should strive for separate
    tasks across microservices and use messages or RPCs to get loose coupling for
    your application, as well as good performance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，扩展是一个未定义的过程，你必须进行一些实验以达到预期的结果。但无论如何，你应该努力在微服务之间实现独立的任务，并使用消息或RPC来为你的应用程序提供松散耦合，以及良好的性能。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the important topic of scalable microservices.
    We started with the basics and continued with implementing two services that use
    RabbitMQ as a message broker to interact with each other. The example we created
    decodes QR codes to be processed by a separate worker. The benefit of the implemented
    application is that you can start as many workers as you want.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可扩展微服务的重要主题。我们从基础知识开始，继续实现两个使用RabbitMQ作为消息代理相互交互的服务。我们创建的示例将QR码解码以便由单独的工作者处理。实现的应用程序的好处是你可以启动任意数量的工作者。
- en: In the next chapter, we will learn how to test and debug microservices using
    unit tests, integration tests, and debuggers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用单元测试、集成测试和调试器来测试和调试微服务。
