["```rs\n[dependency] \nlibc = \"0.2.0\" \n```", "```rs\nextern crate libc; \n```", "```rs\n[link(name=\"mathlib\")] \nextern \n { \n     fn add_two_int_numbers(a: i32, b: i32) -> i32; \n} \n```", "```rs\nfn main() \n { \n    let ans = unsafe { add_two_int_numbers(10,20) }; \n    println!(\"10 + 20 = {}\", ans); \n} \n```", "```rs\n//Source1.rs\n[link(name=\"mylib\")] \nextern  \n{ \n    fn some_method(a: f32) → f32; \n    fn some_other_method(a: i32, b: f32, c: f64) → f64; \n} \n```", "```rs\n[link(name=\"mylib\")] \nextern \n { \n    fn some_other_method(a: i32, b: f32, c: f64) → f64; \n    fn some_text_method() → String; \n} \n```", "```rs\nsizeof(char) == 1 \nsizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long) \n```", "```rs\n[link(name=\"mathlib\")] \nextern \n { \n     fn add_two_int_numbers(a: i32, b: i32) -> i32; \n} \n```", "```rs\n[link(name=\"mathlib\")] \nextern \n { \n     fn check_mean_mode_median(a: Vec<i32>) -> bool; \n} \n```", "```rs\npub fn calc_mean_mode_median_check(a:Vec<int32>) -> bool \n { \n    unsafe \n { \n        check_mean_mode_median(a) == 0; \n    } \n} \n```", "```rs\npub fn mean_mode_median(a: Vec<int32>) -> Vec<f32> \n{ \n    // we can have this result outside of the unsafe as it is a guaranteed parameter \n    // it must be mutable as it is used to store the result if the result is returned \n    let mut result = vec![-999f32, -999f32, -999f32]; \n    unsafe \n { \n        if check_mean_mode_median(a) != 0 \n { \n             return result; \n        } \n else \n { \n             let res = calc_mean_median_mode(a); \n\nresult = res.to_vec(); \n             return result; \n\n        } \n    } \n} \n```", "```rs\nextern crate libc; \n#[link(name = \"mathlib\")] \nextern { \n    static code_version: libc::c_int; \n} \nfn main() { \n    println!(\"You have mathlib version {} installed.\", code_version as i32); \n} \n```", "```rs\npub trait Drop  \n{ \n    fn drop(&mut self); \n} \n```", "```rs\nstruct FreeMemory; \nimpl Drop for FreeMemory \n{ \n     fn drop(&mut self); \n} \n```", "```rs\ngraphics_block  = FreeMemory; \n```", "```rs\nextern fn my_callback(percent: i32) \n { \n     println!(\"Process is now {}% complete\", percent); \n} \n```", "```rs\n[link(name=\"external_lib\")] \nextern \n { \n     fn register_callback(call: extern fn(i32)) -> i32; \n     fn do_callback_trigger(); \n} \n```", "```rs\nfn main() \n { \n    unsafe \n { \n         register_callback(my_callback); \n         do_callback_trigger(); \n    } \n} \n```", "```rs\n#[repr(C)] // this is a name used within the extern in (2) \nstruct MyObject \n { \n    a: i32, \n    // and anything else you want to get back from the library \n    // just make sure you add them into the call back \n} \n```", "```rs\nextern \"C\" fn callback(result: *mut MyObject, a: i32)  \n{ \n     unsafe \n     { \n          (*result).a = a; \n     } \n} \n```", "```rs\n#[link(name=\"external_lib\")] \nextern \n { \n    fn register_callback(result: mut MyObject, cback: extern fn(mut MyObject, i32)); \n    fn start_callback(); \n} \n```", "```rs\nfn main() \n { \n    // we need to create an object for the callback \n    let mystruct = Box::new (MyObject{a: 5i32}); \n    unsafe { \n        register_callback(&mut *mystruct, callback); \n        start_callback(); \n    } \n} \n```", "```rs\n#[no_mangle] \npub extern fn hello_world() -> *const u8 { \n    \"Hello, world!\\0\".as_ptr() \n} \n```", "```rs\nvoid output_data(void *data); \nvoid transformed_data(void *data); \n```", "```rs\nextern crate libc; \nextern \"C\" \n { \n    pub fn output_data(arg: *mut libc::c_void); \n    pub fn transformed_data(arg: *mut libc::c_void); \n} \n```", "```rs\nstruct MyStruct; \nstruct MyOtherStruct; \nvoid pass_struct(struct MyStruct *arg); \nvoid pass_struct2(struct MyOtherStruct *arg2); \n```", "```rs\nenum MyStruct {}; \nenum MyOtherStruct {}; \nextern \"C\" \n{ \n    pub fn pass_struct(arg: *mut MyStruct); \n    pub fn pass_struct2(arg: *mut MyOtherStruct); \n} \n```"]