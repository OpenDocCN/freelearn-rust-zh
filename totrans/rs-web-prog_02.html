<html><head></head><body>
		<div><h1 id="_idParaDest-40" class="chapter-number"><a id="_idTextAnchor039"/>2</h1>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Designing Your Web Application in Rust </h1>
			<p>We previously explored the syntax of Rust, enabling us to tackle memory management quirks and build data structures. However, as any experienced engineer will tell you, structuring code across multiple files and directories is an important aspect of building software.</p>
			<p>In this chapter, we will build a basic command-line to-do program. We manage the dependencies needed to build our command-line program with Rust’s <strong class="bold">Cargo</strong>. Our program will be structured in a scalable way where we build and manage our own modules, which will be imported into other areas of the program and utilized. We will learn these concepts by building a to-do application spanning multiple files that create, edit, and delete to-do applications. This application will save our multiple to-do application files locally, and we will be able to interact with our application using a command-line interface. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Managing a software project with Cargo</li>
				<li>Structuring code</li>
				<li>Interacting with the environment</li>
			</ul>
			<p>By the end of this chapter, you will be able to build applications in Rust that can be packaged and used. You will also be able to use third-party packages in your code. As a result, you will be able to build any command-line application that does not require a server or a graphical user interface if you understand the problem you are trying to solve and can break it down into logical chunks.  </p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Technical requirements</h1>
			<p>As we move toward building web apps in Rust, we are going to have to start relying on third-party packages to do some of the heavy lifting for us. Rust manages dependencies through a package manager called Cargo. To use Cargo, we are going to have to install Rust on our computer from the following URL: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>.</p>
			<p>This installation provides the programming language Rust and the dependency manager Cargo. You can find all the code files on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02</a></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Managing a software project with Cargo</h1>
			<p>Before we start structuring our program with Cargo, we should build a basic single-file application. To do this, we initially must create <a id="_idIndexMarker138"/><a id="_idIndexMarker139"/>a file called <code>hello_world.rs</code> in a local directory. The <code>.rs</code> extension denotes that the file is a Rust file. To be honest, it does not matter what the extension is. If there is viable Rust code written in that file, the<a id="_idIndexMarker140"/><a id="_idIndexMarker141"/> compiler will compile and run it without any issues. However, having different extensions might confuse other developers and code editors and cause problems when importing code from other Rust files. So, it is best to use <code>.rs</code> when naming your Rust files. Inside our <code>hello_world.rs</code> file, we can have the following code:</p>
			<pre class="source-code">
fn main() {
    println!("hello world");
}</pre>
			<p>This is no different from our first code block in the previous chapter. Now that we have defined our entry point in our <code>hello_world.rs</code> file, we can compile the file with the following command:</p>
			<pre class="console">
rustc hello_world.rs</pre>
			<p>Once the compilation has finished, there will be a binary file in the same directory that can be run. If we compile it on Windows, we can run the binary with the following command:</p>
			<pre class="console">
.\hello_world.exe</pre>
			<p>If we compile it on Linux or macOS, we can run it with the following command:</p>
			<pre class="console">
./hello_world</pre>
			<p>Because we only built a simple <code>hello world</code> example, <code>hello world</code> will just be printed out. While this can be useful when building a simple application in one file, it is not recommended for managing programs spanning multiple files. It is not even recommended when relying on third-party modules. This is where Cargo comes in. Cargo manages everything, including the running, testing, documentation, building/compiling, and third-party module dependencies, out of the box with a few simple commands. We will cover these commands throughout this chapter. From what we have seen when running our <code>hello world</code> example, we must compile the code before we can run it, so let’s now move on to the next section where we build a basic application using Cargo. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Building with Cargo</h2>
			<p>Building with Cargo is straightforward. All we<a id="_idIndexMarker142"/><a id="_idIndexMarker143"/> must do is navigate to the directory where we want to build our project and run the following command:</p>
			<pre class="console">
cargo new web_app</pre>
			<p>The preceding command builds a basic Cargo Rust project. If we explore this application, we’ll see the following structure:</p>
			<pre class="source-code">
└── web_app
    ├── Cargo.toml
    └── src
         └── main.rs</pre>
			<p>We can see that there is only one Rust file, and this is the <code>main.rs</code> file that is housed in the <code>src</code> directory. If you open the <code>main.rs</code> file, you will see that this is the same as the file that we made in the previous section. It is an entry point with the default code printing out <code>hello world</code> to the console. The dependencies and metadata for our project are defined in the <code>Cargo.toml</code> file. If we want to run our program, we do not need to navigate to the <code>main.rs</code> file and run <code>rustc</code>. Instead, we can use Cargo and run it with the following command:</p>
			<pre class="console">
 cargo run</pre>
			<p>When you do this, you will see the project compile and run with the following printout:</p>
			<pre class="console">
  Compiling web_app v0.1.0 (/Users/maxwellflitton/Documents/
   github/books/Rust-Web_Programming-two/chapter02/web_app)
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
     Running `target/debug/web_app`
hello world</pre>
			<p>Your printout will be slightly different because the base directory will be different. At the bottom, you will see <code>hello world</code>, which is what we expect. We can also see that the printout states that the compilation is unoptimized and that it is running in <code>target/debug/web_app</code>. We can navigate directly to the <code>target/debug/web_app</code> binary and run it just like we did in the previous section as this is where the binary is stored. The <code>target</code> directory is where the files for compiling, running, and documenting our program reside. If we attach our code to a GitHub repository, we must make sure that the <code>target</code> directory is ignored by GitHub by putting it in the <code>.gitignore</code> file. Right now, we are running the unoptimized<a id="_idIndexMarker144"/><a id="_idIndexMarker145"/> version. This means that it is slower but quicker to compile. This makes sense as when we are developing, we will be compiling multiple times. However, if we want to run the optimized version, we can use the following command:</p>
			<pre class="console">
cargo run --release</pre>
			<p>The preceding command gives us the following printout:</p>
			<pre class="console">
    Finished release [optimized] target(s) in 2.63s
     Running `target/release/web_app`
hello world</pre>
			<p>In the preceding output, we can see that our optimized binary is in the <code>target/release/web_app</code> path. Now that we have got our basic builds done, we can start to use Cargo to utilize third-party crates.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Shipping crates with Cargo</h2>
			<p>Third-party libraries are referred to as crates. Adding<a id="_idIndexMarker146"/><a id="_idIndexMarker147"/> them and managing them with Cargo is straightforward. In this section, we will explore this process by <a id="_idIndexMarker148"/><a id="_idIndexMarker149"/>utilizing the <code>rand</code> crate, available at <a href="https://rust-random.github.io/rand/rand/index.html">https://rust-random.github.io/rand/rand/index.html</a>. It must be noted that the documentation for this crate is clear and well structured with links to structs, traits, and modules. This is not a reflection of the rand crate itself. This is standard documentation for Rust that we will cover in the next section. To use this crate in our project, we open the <code>Cargo.toml</code> file and add the <code>rand</code> crate under the <code>[dependencies]</code> section, as follows:</p>
			<pre class="source-code">
[dependencies]
rand = "0.7.3"</pre>
			<p>Now that we’ve defined our dependency, we can use the <code>rand</code> crate to build a random number generator:</p>
			<pre class="source-code">
use rand::prelude::*;
fn generate_float(generator: &amp;mut ThreadRng) -&gt; f64 {
    let placeholder: f64 = generator.gen();
    return placeholder * 10.0
}
fn main() {
    let mut rng: ThreadRng = rand::thread_rng();
    let random_number = generate_float(&amp;mut rng);
    println!("{}", random_number);
}</pre>
			<p>In the preceding code, we have defined a function called <code>generate_float</code>, which uses the crate to generate and return a float between <code>0</code> and <code>10</code>. Once we’ve done this, we print the number. The implementation of the <code>rand</code> crate is handled by the rand documentation. Our <code>use</code> statement imports the <code>rand</code> crate. When using the <code>rand</code> create for <a id="_idIndexMarker150"/><a id="_idIndexMarker151"/>generating a float, the documentation tells us to import (<code>*</code>) from the <code>rand::prelude</code> module, which simplifies the importing of common items, as shown in the crate documentation at <a href="https://rust-random.github.io/rand/rand/prelude/index.html">https://rust-random.github.io/rand/rand/prelude/index.html</a>. </p>
			<p>The <code>ThreadRng</code> struct is a random number <a id="_idIndexMarker152"/><a id="_idIndexMarker153"/>generator that generates an <code>f64</code> value between <code>0</code> and <code>1</code>, which is elaborated on in the rand crate documentation at <a href="https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html">https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html</a>.</p>
			<p>Now, we get to see the power of the documentation. With a few clicks on the introduction page of the rand documentation, we can dig into the declarations of the structs and functions used in the demonstration. Now that our code is built, we can run our program with the <code>cargo run</code> command. While Cargo is compiling, it pulls code from the <code>rand</code> crate and compiles that into the binary. We can also note that there is now a <code>cargo.lock</code> file. As we know that <code>cargo.toml</code> is for us to describe our own dependencies, <code>cargo.lock</code> is generated by Cargo and we should not edit it ourselves as it contains exact information about our dependencies. This seamless functionality combined with the easy-to-use documentation shows how Rust improves the development process through marginal gains via the development ecosystem as well as the quality of the language. However, all these gains from the documentation are not purely dependent on the third-party libraries; we can also autogenerate our own documentation.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Documenting with Cargo</h2>
			<p>Speed and safety are not the<a id="_idIndexMarker154"/><a id="_idIndexMarker155"/> only benefits of picking a new language such as Rust to develop in. Over the years, the software engineering community keeps learning and growing. Simple things such as good documentation can make or break a project. To demonstrate this, we can define Markdown language within the Rust file with the following code:</p>
			<pre class="source-code">
/// This function generates a float number using a number
/// generator passed into the function.
///
/// # Arguments
/// * generator (&amp;mut ThreadRng): the random number
/// generator to generate the random number
///
/// # Returns
/// (f64): random number between 0 -&gt; 10
fn generate_float(generator: &amp;mut ThreadRng) -&gt; f64 {
    let placeholder: f64 = generator.gen();
    return placeholder * 10.0
}</pre>
			<p>In the preceding code, we’ve denoted the <a id="_idIndexMarker156"/><a id="_idIndexMarker157"/>Markdown with the <code>///</code> markers. This does two things: it tells other developers who look at the code what the function does and renders Markdown in our autogeneration. Before we run the document command, we can define and document a basic user struct and a basic user trait to also show how these are documented:</p>
			<pre class="source-code">
/// This trait defines the struct to be a user.
trait IsUser {
    /// This function proclaims that the struct is a user.
    ///
    /// # Arguments
    /// None
    ///
    /// # Returns
    /// (bool) true if user, false if not
    fn is_user() -&gt; bool {
        return true
    }
}
/// This struct defines a user
///
/// # Attributes
/// * name (String): the name of the user
/// * age (i8): the age of the user
struct User {
    name: String,
    age: i8
}</pre>
			<p>Now that we have documented a range of different structures, we can run the auto-documentation process with the following command:</p>
			<pre class="console">
cargo doc --open</pre>
			<p>We can see that the documentation is<a id="_idIndexMarker158"/><a id="_idIndexMarker159"/> rendered in the same way as the rand crate:</p>
			<div><div><img src="img/Figure_2.1_B18722.jpg" alt="Figure 2.1 – Documentation view of the web app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Documentation view of the web app</p>
			<p>In the preceding screenshot, we can see that <strong class="bold">web_app</strong> is a crate. We can also see that the documentation of the rand crate is involved (if we look at the bottom left of the screenshot, we can see the <strong class="bold">rand</strong> crate documentation just above our <strong class="bold">web_app</strong> crate documentation). If we click on the <strong class="bold">User</strong> struct, we can see the declaration of the struct, the Markdown that we wrote for the attributes, and the trait implications, as shown in the following figure:</p>
			<div><div><img src="img/Figure_2.2_B18722.jpg" alt="Figure 2.2 – Documentation on struct"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Documentation on struct</p>
			<p>It must be noted that in future sections <a id="_idIndexMarker160"/><a id="_idIndexMarker161"/>of the book, we will not include Markdown in the code snippets to maintain readability. However, Markdown-documented code is provided in the book’s GitHub repo. Now that we have a well-documented, running Cargo project, we need to be able to pass parameters into it to enable different configurations to run depending on the context.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Interacting with Cargo</h2>
			<p>Now that we have our program running and <a id="_idIndexMarker162"/><a id="_idIndexMarker163"/>using third-party modules, we can start to interact with our Rust programs through command-line inputs. To enable our program to have some flexibility depending on the context, we need to be able to pass parameters into our program and keep track of the parameters in which the program is running. We can do this using the <code>std</code> (standard library) identifier:</p>
			<pre class="source-code">
use std::env;
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!("{:?}", args);
}</pre>
			<p>In the preceding code, we can see that we collect the arguments passed into the program into a vector and then print out the arguments in debug mode. Let us run the following command:</p>
			<pre class="console">
cargo run one two three</pre>
			<p>Running the preceding command gives the following printout:</p>
			<pre class="console">
["target/debug/interacting_with_cargo", "one", "two", "three"]</pre>
			<p>Here, we can see that our <code>args</code> vector has the arguments that we passed in. This is not surprising as many other languages also accept <a id="_idIndexMarker164"/><a id="_idIndexMarker165"/>arguments passed into the program via the command line. We must note as well that the path to the binary is also included. Here, I also must highlight that I am using a different project named <code>interacting_with_cargo</code>, hence the <code>target/debug/interacting_with_cargo</code> path. We can also see from the command-line arguments that we are running in debug mode. Let us try to run a release version of our program with the following command:</p>
			<pre class="console">
cargo run --release one two three</pre>
			<p>We would receive the following printout:</p>
			<pre class="console">
["target/release/interacting_with_cargo", "one", "two", "three"]</pre>
			<p>From the preceding output, we can see that <code>--release</code> is not in our vector. However, this does give us some extra functionality to play with. For instance, we might want to run different processes depending on the type of compilation. This can easily be done with the following code:</p>
			<pre class="source-code">
let args: Vec&lt;String&gt; = env::args().collect();
let path: &amp;str = &amp;args[0];
if path.contains("/debug/") {
    println!("Debug is running");
}
else if path.contains("/release/") {
    println!("release is running");
}
else {
    panic!("The setting is neither debug or release");
}</pre>
			<p>However, the preceding simple solution is patchy. The <code>path</code> that we extract is only consistent if we are running Cargo commands. While Cargo commands are great for building, compiling, and documenting, it does not make sense to carry all those files around in production. In fact, there are advantages to extracting the static binary, wrapping it in a Docker container completely by itself, and running the binary directly as this can reduce the size of the Docker image from 1.5 GB to 200 MB. So, while this might seem like a quick win, it can lead to<a id="_idIndexMarker166"/><a id="_idIndexMarker167"/> breaking code when deploying our applications. Therefore, it is essential to put in the <code>panic</code> macro at the end to prevent this from reaching production and you not knowing about it. </p>
			<p>So far, we have passed in some basic commands; however, this is not helpful or scalable. There would also be a lot of boilerplate code written for us to implement help guides for users. To scale our command-line interface, we can lean on the <code>clap</code> crate to handle arguments passed into the program, with the following dependency:  </p>
			<pre class="source-code">
[dependencies]
clap = "3.0.14"</pre>
			<p>To flesh out our understanding of command-line interfaces, we can develop a toy application that merely takes in a few commands and prints them out. To do this, we must import what we need from the <code>clap</code> crate in the <code>main.rs</code> file with the following code:</p>
			<pre class="source-code">
use clap::{Arg, App};</pre>
			<p>Now, we can move on to defining our application:</p>
			<ol>
				<li>Our application houses metadata about the application in the <code>main</code> function with the following code:<pre class="source-code">
fn main() {</pre><pre class="source-code">
    let app = App::new("booking")</pre><pre class="source-code">
        .version("1.0")</pre><pre class="source-code">
        .about("Books in a user")</pre><pre class="source-code">
        .author("Maxwell Flitton");</pre><pre class="source-code">
. . .</pre></li>
			</ol>
			<p>If we look at the documentation of <code>clap</code>, we can bind arguments directly to the <code>App</code> struct; however, this can get ugly and tightly bound. Instead, we will define them separately in the next step. </p>
			<ol>
				<li value="2">In our toy app, we are taking in a first name, last name, and age, which can be defined as follows:<pre class="source-code">
    let first_name = Arg::new("first name")</pre><pre class="source-code">
        .long("f")</pre><pre class="source-code">
        .takes_value(true)</pre><pre class="source-code">
        .help("first name of user")</pre><pre class="source-code">
        .required(true);</pre><pre class="source-code">
    let last_name = Arg::new("last name")</pre><pre class="source-code">
        .long("l")</pre><pre class="source-code">
        .takes_value(true)</pre><pre class="source-code">
        .help("first name of user")</pre><pre class="source-code">
        .required(true);</pre><pre class="source-code">
    let age = Arg::new("age")</pre><pre class="source-code">
        .long("a")</pre><pre class="source-code">
        .takes_value(true)</pre><pre class="source-code">
        .help("age of the user")</pre><pre class="source-code">
        .required(true);</pre></li>
			</ol>
			<p>We can see that we can keep stacking the <a id="_idIndexMarker168"/><a id="_idIndexMarker169"/>arguments. Right now, they are not bound to anything. Now, we can move on to binding them to our application and passing in the arguments in the next step.</p>
			<ol>
				<li value="3">Binding, getting, and parsing inputs can be achieved with the following code:<pre class="source-code">
    let app = app.arg(first_name).arg(last_name).arg(age);</pre><pre class="source-code">
    let matches = app.get_matches();</pre><pre class="source-code">
    let name = matches.value_of("first name")</pre><pre class="source-code">
        .expect("First name is required");</pre><pre class="source-code">
    let surname = matches.value_of("last name")</pre><pre class="source-code">
        .expect("Surname is required");</pre><pre class="source-code">
    let age: i8 = matches.value_of("age")</pre><pre class="source-code">
        .expect("Age is required").parse().unwrap();</pre><pre class="source-code">
    </pre><pre class="source-code">
    println!("{:?}", name);</pre><pre class="source-code">
    println!("{:?}", surname);</pre><pre class="source-code">
    println!("{:?}", age);</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Now that we have a working example of how to pass command-line arguments, we can interact with our application to see how it displays by running the following command:</p>
			<pre class="console">
cargo run -- --help  </pre>
			<p>The middle <code>--</code> before <code>--help</code> tells Cargo to <a id="_idIndexMarker170"/><a id="_idIndexMarker171"/>pass all the arguments after <code>--</code> into <code>clap</code> as opposed to <code>cargo</code>. The preceding command will give us the following printout:</p>
			<pre class="console">
booking 1.0
Maxwell Flitton
Books in a user
USAGE:
    interacting_with_cargo --f &lt;first name&gt; --l &lt;last name&gt; 
                           --a &lt;age&gt;
OPTIONS:
        --a &lt;age&gt;           age of the user
        --f &lt;first name&gt;    first name of user
    -h, --help              Print help information
        --l &lt;last name&gt;     first name of user
    -V, --version           Print version information</pre>
			<p>In the preceding output, we can see how to directly interact with our compiled binary file. We also have a nice help menu. To interact with Cargo, we need to run the following command:</p>
			<pre class="console">
cargo run -- --f first --l second --a 32</pre>
			<p>The preceding command will give the following printout:</p>
			<pre class="console">
"first"
"second"
32</pre>
			<p>We can see that the parsing works as we have two strings and an integer. The reason why crates such as <code>clap</code> are useful is that they are essentially self-documenting. Developers can look at the code and know what arguments are being accepted and view the metadata around them. Users can get help on the inputs by merely passing in the <code>help</code> parameter. This approach reduces the risk of the documentation becoming outdated as it is embedded in the code that executes it. If you accept command-line arguments, it is advised that you use a crate such as <code>clap</code> for this purpose. Now that we have explored structuring our command-line interface so it can scale, we can investigate structuring our code over multiple files to scale it in the next section.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Structuring code</h1>
			<p>We can now begin our journey of building a web <a id="_idIndexMarker172"/><a id="_idIndexMarker173"/>application. In the rest of this chapter, we will not touch a web framework or build an HTTP listener. This will happen in the next chapter. However, we will construct a to-do module that will interact with a JSON file. It is going to be structured in such a way that it can be inserted into any web application that we build with minimal effort. This to-do module will enable us to create, update, and delete to-do items. We will then interact with this via the command line. The process here is to explore how to build well-structured code that will scale and be flexible. To gain an understanding of this, we will break down the building of this module into the following chunks:</p>
			<ol>
				<li value="1">Build structs for pending and done to-do items. </li>
				<li>Build a factory that enables the structs to be built in the module with minimal clean input. </li>
				<li>Build traits that enable a struct to delete, create, edit, and get to-do items. </li>
				<li>Build a read-and-write-to-file module to store to-do items (we will replace this with a proper database in later chapters).</li>
				<li>Build a <code>config</code> module that can alter the behavior of the application based on the variables in a <code>config</code> file. </li>
			</ol>
			<p>Before we start tackling these steps, we need to get the application running. We can do this by navigating to the desired directory of where we want to house this application and start a new Cargo project called <code>todo_app</code>. Once this is done, we are going to put the logic that handles the management of to-do items in our <code>to_do</code> module. This can be achieved by creating a <code>to_do</code> directory and putting a <code>mod.rs</code> file at the base of this directory, as seen in the following layout:</p>
			<pre class="source-code">
├── main.rs
└── to_do
    ├── mod.rs</pre>
			<p>With this structure, we can start building out our <code>to_do</code> module starting with structs. Do not worry about the <code>to_do</code> file for now as this is covered in the first step, building structs for our done and pending to-do items. </p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Building to-do structs</h2>
			<p>Right now, we only have two structs for to-do items: ones that are waiting to<a id="_idIndexMarker174"/><a id="_idIndexMarker175"/> be done and others that are already done. However, we might want to introduce other categories. For instance, we could add a backlog category, or an <em class="italic">on-hold</em> task for tasks that have been started but for one reason or another are blocked. To avoid mistakes and repetitive code, we can build a <code>Base</code> struct and have that be utilized by other structs. The <code>Base</code> struct houses common fields and functions. An alteration of the <code>Base</code> struct will propagate to all other to-do structs. We will also need to define the type of to-do item. We could hardcode in strings for pending and done; however, this is not scalable and is also error prone. To avoid this, we will use an enum to classify and define the presentation of the type of to-do item. To achieve this, we need to create the following file structure for our module:</p>
			<pre class="source-code">
├── main.rs
└── to_do
    ├── enums.rs
    ├── mod.rs
    └── structs
        ├── base.rs
        ├── done.rs
        ├── mod.rs
        └── pending.rs</pre>
			<p>In the preceding code, we can notice that <a id="_idIndexMarker176"/><a id="_idIndexMarker177"/>we have two <code>mod.rs</code> files. These files are essentially where we declare our files, and what we define in them to make them accessible to other files in the same directory. We can also allow the files to be accessed outside of the directory if we publicly declare them in the <code>mod.rs</code> file. Before we write any code, we can see in <em class="italic">Figure 2</em><em class="italic">.3</em> how the data flows in our module:  </p>
			<div><div><img src="img/Figure_2.3_B18722.jpg" alt="Figure 2.3 – The flow of data in our to-do module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – The flow of data in our to-do module</p>
			<p>We see that our <code>Base</code> struct is used by our other to-do structs. The other to-do structs would not be able to access the <code>Base</code> struct if we did not declare it. However, no file outside the <code>to_do/structs</code> directory is referencing the <code>Base</code> struct, therefore it does not have to be a public declaration. </p>
			<p>Now that we understand the data flow for our <a id="_idIndexMarker178"/><a id="_idIndexMarker179"/>module, we need to look back at <em class="italic">Figure 2</em><em class="italic">.3</em> and work out what we need to work on first. We can see that our enums have no dependencies. In fact, our enum supplies all the structs. Therefore, we will start with our enum in the <code>/to_do/enums.rs</code> file. Our enum is defining the status of the task with the following code:</p>
			<pre class="source-code">
pub enum TaskStatus {
    DONE,
    PENDING
}</pre>
			<p>This will work in the code when it comes to defining the status of the task. However, if we want to write to a file or database, we are going to have to build a method to enable our enum to be represented in a string format. To do this, we can implement a <code>stringify</code> function for our <code>TaskStatus</code> enum with the following code:  </p>
			<pre class="source-code">
impl TaskStatus {
    pub fn stringify(&amp;self) -&gt; String {
        match &amp;self {
            &amp;Self::DONE =&gt; {"DONE".to_string()},
            &amp;Self::PENDING =&gt; {"PENDING".to_string()}
        }
    }
}</pre>
			<p>Calling this will enable us to print out the status of the to-do task in the console and write it in our JSON file. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">While the <code>stringify</code> function works, there is another way to convert the value of the enum to a string. To achieve the string conversion, we can implement the <code>Display</code> trait for <code>TaskStatus</code>. First, we must import the format module with the following code:</p>
			<pre class="source-code">
use std::fmt;</pre>
			<p>We can then implement the <code>Display</code> trait for the <code>TaskStatus</code> struct with the following code:</p>
			<pre class="source-code">
impl fmt::Display for TaskStatus {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match &amp;self {
            &amp;Self::DONE =&gt; {write!(f, "DONE")},
            &amp;Self::PENDING =&gt; {write!(f, "PENDING")}
        }
    }
}</pre>
			<p>This trait implementation has the same<a id="_idIndexMarker180"/><a id="_idIndexMarker181"/> logic as our <code>stringify</code> function. However, our trait is utilized when needed. So, we have the following code:</p>
			<pre class="source-code">
println!("{}", TaskStatus::DONE);
println!("{}", TaskStatus::PENDING);
let outcome = TaskStatus::DONE.to_string();
println!("{}", outcome);</pre>
			<p>This will result in the following printout:</p>
			<pre class="console">
DONE
PENDING
DONE</pre>
			<p>Here, we can see that when we pass <code>TaskStatus</code> into <code>println!</code>, the <code>Display</code> trait is automatically utilized. </p>
			<p>We can now make our enum publicly available in the <code>/to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
pub mod enums;</pre>
			<p>We can now refer to <em class="italic">Figure 2</em><em class="italic">.3</em> to see what we can build next, which is the <code>Base</code> struct. We can define the <code>Base</code> struct in the <code>/to_do/structs/base.rs</code> file with the following code:</p>
			<pre class="source-code">
use super::super::enums::TaskStatus;
pub struct Base {
    pub title: String,
    pub status: TaskStatus
}</pre>
			<p>From the import at the top of the file, we can access the <code>TaskStatus</code> enum using <code>super::super</code>. We know that the <code>TaskStatus</code> enum is in a higher directory. From this, we can deduce that <code>super</code> gives us access to what is declared in the <code>mod.rs</code> file of the current directory. So, using <code>super::super</code> in a file in the <code>/to_do/structs/</code> directory gives us access to what is defined in the <code>/to_do/mod.rs</code> file. </p>
			<p>We can now declare our <code>Base</code> struct in our <code>/to_do/structs/mod.rs</code> file with the following code: </p>
			<pre class="source-code">
mod base;</pre>
			<p>We do not have to declare it as public because <a id="_idIndexMarker182"/><a id="_idIndexMarker183"/>our <code>Base</code> struct is not accessed outside of the <code>/to_do/structs/</code> directory. Now, looking back at <em class="italic">Figure 2</em><em class="italic">.3</em>, we can build our <code>Pending</code> and <code>Done</code> structs. This is when we use composition to utilize our <code>Base</code> struct in our <code>/to_do/structs/pending.rs</code> file with the following code:</p>
			<pre class="source-code">
use super::base::Base;
use super::super::enums::TaskStatus;
pub struct Pending {
    pub super_struct: Base
}
impl Pending {
    pub fn new(input_title: &amp;str) -&gt; Self {
        let base = Base{
            title: input_title.to_string(),
            status: TaskStatus::PENDING
        };
        return Pending{super_struct: base}
    }
}</pre>
			<p>Through the preceding code, we can see that our <code>super_struct</code> field houses our <code>Base</code> struct. We utilize our enum and define the status to be pending. This means that we only must pass the title into the constructor, and we have a struct with a title and a status of pending. Considering this, coding our <code>Done</code> struct should be straightforward in our <code>/to_do/structs/done.rs</code> file with the following code: </p>
			<pre class="source-code">
use super::base::Base;
use super::super::enums::TaskStatus;
pub struct Done {
    pub super_struct: Base
}
impl Done {
    pub fn new(input_title: &amp;str) -&gt; Self {
        let base = Base {
            title: input_title.to_string(),
            status: TaskStatus::DONE
        };
        return Done{super_struct: base}
    }
}</pre>
			<p>We can see that there is not much difference <a id="_idIndexMarker184"/><a id="_idIndexMarker185"/>from the <code>Pending</code> struct definition apart from the <code>TaskStatus</code> enum having a <code>DONE</code> status. We can now make our structs available outside of the directory in the <code>/to_do/structs/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
mod base;
pub mod done;
pub mod pending;</pre>
			<p>We can then make our structs accessible in the <code>main.rs</code> file by declaring these structs in the <code>/to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
pub mod structs;
pub mod enums;</pre>
			<p>We have now made a basic module and exposed it to the <code>main.rs</code> file. For now, we can write some basic code that will use our module to create a task that is pending and another that is completed. This can be done with the following code:</p>
			<pre class="source-code">
mod to_do;
use to_do::structs::done::Done;
use to_do::structs::pending::Pending;
fn main() {
    let done = Done::new("shopping");
    println!("{}", done.super_struct.title);
    println!("{}", done.super_struct.status.stringify());
    let pending = Pending::new("laundry");
    println!("{}", pending.super_struct.title);
    println!("{}", pending.super_struct.status.stringify()
    );
}</pre>
			<p>In the preceding code, we can see that we have declared our <code>to_do</code> module. We then imported our structs and created a <code>pending</code> and <code>done</code> struct. Running our code will give us the following printout:</p>
			<pre class="console">
shopping
DONE
laundry
PENDING</pre>
			<p>This stops the <code>main.rs</code> file from<a id="_idIndexMarker186"/><a id="_idIndexMarker187"/> being overloaded with excessive code. If we were to stack more types of items that can be created, such as the on-hold or backlog items, the code in <code>main.rs</code> would balloon. This is where factories come in, which we will explore in the next step. </p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Managing structs with factories </h2>
			<p>A factory pattern is where we <a id="_idIndexMarker188"/><a id="_idIndexMarker189"/>abstract the construction of<a id="_idIndexMarker190"/><a id="_idIndexMarker191"/> structs in an entry point of the module. We can see how this would work with our module as follows:</p>
			<div><div><img src="img/Figure_2.4_B18722.jpg" alt="Figure 2.4 – Flow of to-do factory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Flow of to-do factory</p>
			<p>What factories do is abstract the module by providing an interface. While we have enjoyed building our module, if another developer wanted to use it, a simple factory interface with good documentation would save them a lot of time. All they must do is pass in a few parameters and get the constructed structs out of the factory wrapped in an enum. If we change the internals of the module or it becomes more complicated, this will not matter. If other modules use the interface, the changes would not break the rest of the code if we keep the<a id="_idIndexMarker192"/><a id="_idIndexMarker193"/> interfaces consistent. We can build our factory by defining our factory function in the <code>/to_do/mod.rs</code> file with<a id="_idIndexMarker194"/><a id="_idIndexMarker195"/> the following code:</p>
			<pre class="source-code">
pub mod structs;
pub mod enums;
use enums::TaskStatus;
use structs::done::Done;
use structs::pending::Pending;
pub enum ItemTypes {
    Pending(Pending),
    Done(Done)
}
pub fn to_do_factory(title: &amp;str, 
                     status: TaskStatus) -&gt; ItemTypes {
    match status {
        TaskStatus::DONE =&gt; {
            ItemTypes::Done(Done::new(title))
        },
        TaskStatus::PENDING =&gt; {
            ItemTypes::Pending(Pending::new(title))
        }
    }
}</pre>
			<p>In the preceding code, we can see that we define an enum called <code>ItemTypes</code>, which packages the constructed task structs. Our <code>factory</code> function essentially accepts our inputted title and status. The factory then matches the inputted status. Once we have established what type of status was passed in, we build a task that matches the status and wraps it in the <code>ItemTypes</code> enum. This can grow and get more complicated, and our main file will be none the wiser. We can then implement this factory in our <code>main.rs</code> file with the following code:</p>
			<pre class="source-code">
mod to_do;
use to_do::to_do_factory;
use to_do::enums::TaskStatus;
use to_do::ItemTypes;
fn main() {
    let to_do_item = to_do_factory("washing", 
                                   TaskStatus::DONE);
    match to_do_item {
        ItemTypes::Done(item) =&gt; {
            println!("{}", item.super_struct.status
                     .stringify());
            println!("{}", item.super_struct.title);
        },
        ItemTypes::Pending(item) =&gt; {
            println!("{}", item.super_struct.status
                     .stringify());
            println!("{}", item.super_struct.title);
        }
    }
}</pre>
			<p>In the preceding code, we can see that we pass into the factory the parameters we want to create for a to-do item, and then match the outcome to<a id="_idIndexMarker196"/><a id="_idIndexMarker197"/> print the item’s attributes. There is more code now introduced into the <code>main.rs</code> file. However, there is more <a id="_idIndexMarker198"/><a id="_idIndexMarker199"/>code because we are unwrapping the returned enum to print out the attributes for demonstrative purposes. We will usually pass this wrapped enum into other modules to handle. To create the struct, we only need one line of code, which is the following:</p>
			<pre class="source-code">
let to_do_item = to_do_factory("washing", TaskStatus::DONE);</pre>
			<p>This means we can create a to-do item and pass it around with little hassle as it is wrapped in an enum. Other functions and modules must just accept the enum. We can see that this offers flexibility. However, as our code stands, we can do away with the <code>Base</code>, <code>Done</code>, and <code>Pending</code> structs and just have one struct that accepts the status and title. It would mean less code. However, it would also be less flexible. We are going to see how this is the case in our next step, where we add traits to our structs to lock down functionality and ensure safety. </p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Defining functionality with traits </h2>
			<p>Right now, our structs do not really do anything<a id="_idIndexMarker200"/><a id="_idIndexMarker201"/> apart from holding the status and title of the task. However, our structs could have different functionality. Therefore, we have taken the extra trouble of defining individual structs. For instance, we are building a to-do application here. It is ultimately down to you how you structure your application, but it is not unreasonable to ensure that you cannot create a done task; otherwise, why are you adding it to your to-do list? This example might seem trivial. This book has used a to-do list to keep the problem that we are solving simple. Because of this, we can focus on the technical aspects of developing web applications in Rust without spending time understanding the problem we are solving. However, we must acknowledge that in more demanding applications, such as a system that processes bank transactions, we would need to be strict on how to implement our logic and lock down the possibility of any undesired processes happening. We can do this in our to-do application by building individual traits for each process and assigning them to task structs that we want. To do <a id="_idIndexMarker202"/><a id="_idIndexMarker203"/>this, we will need to create a <code>traits</code> directory in our <code>to_do</code> module and a file for each trait, which will take the following structure:</p>
			<pre class="source-code">
├── mod.rs
└── traits
    ├── create.rs
    ├── delete.rs
    ├── edit.rs
    ├── get.rs
    └── mod.rs</pre>
			<p>We can then publicly define all the traits in the <code>to_do/traits/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
pub mod create;
pub mod delete;
pub mod edit;
pub mod get;</pre>
			<p>We must also publicly define our traits in our <code>to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
pub mod traits;</pre>
			<p>Now that we have all our trait files plumbed up in our module, we can start building our traits. We can start by defining our <code>Get</code> trait in the <code>to_do/traits/get.rs</code> file with the following code: </p>
			<pre class="source-code">
pub trait Get {
    fn get(&amp;self, title: &amp;str) {
        println!("{} is being fetched", title);
    }
}</pre>
			<p>This is simply a demonstration of how we apply traits; therefore, we will just print out what is happening for now. We must remember that we cannot reference fields from the <code>&amp;self</code> parameter passed in because we can apply our trait to multiple structs; however, we can overwrite the <code>get</code> function for the trait that implements this. When it comes to the <code>Edit</code> trait, we can have two functions that change the status in the <code>to_do/traits/edit.rs</code> file with the following code:</p>
			<pre class="source-code">
pub trait Edit {
    fn set_to_done(&amp;self, title: &amp;str) {
        println!("{} is being set to done", title);
    }
    fn set_to_pending(&amp;self, title: &amp;str) {
        println!("{} is being set to pending", title);
    }
}</pre>
			<p>We can see a pattern here. So, for<a id="_idIndexMarker204"/><a id="_idIndexMarker205"/> completeness, our <code>Create</code> trait takes the following form in the <code>to_do/traits/create.rs</code> file:</p>
			<pre class="source-code">
pub trait Create {
    fn create(&amp;self, title: &amp;str) {
        println!("{} is being created", title);
    }
}</pre>
			<p>Our <code>Delete</code> trait is defined in the <code>to_do/traits/delete.rs</code> file with the following code:</p>
			<pre class="source-code">
pub trait Delete {
    fn delete(&amp;self, title: &amp;str) {
        println!("{} is being deleted", title);
    }
}</pre>
			<p>We have now defined all the traits that we need. Thus, we can utilize them to define and lock down behavior in our to-do item structs. For our <code>Done</code> struct, we can import our traits into the <code>to_do/structs/done.rs</code> file with the following code: </p>
			<pre class="source-code">
use super::super::traits::get::Get;
use super::super::traits::delete::Delete;
use super::super::traits::edit::Edit;</pre>
			<p>We can then implement our <code>Done</code> struct in the same file after the definition of the <code>Done</code> struct with the following code:</p>
			<pre class="source-code">
impl Get for Done {}
impl Delete for Done {}
impl Edit for Done {}</pre>
			<p>Now, our <code>Done</code> struct can get, edit, and delete to-do items. Here, we can really see the power of traits as highlighted in <a href="B18722_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">A Quick Introduction to Rust</em>. We can stack on or remove traits easily. For instance, allowing done to-do items to be created would be achieved with a simple <code>impl Create for Done;</code>. Now that we have <a id="_idIndexMarker206"/><a id="_idIndexMarker207"/>defined the traits that we want for our <code>Done</code> struct, we can move on to our <code>Pending</code> struct, importing what we need in the <code>to_do/structs/pending.rs</code> file with the following code: </p>
			<pre class="source-code">
use super::super::traits::get::Get;
use super::super::traits::edit::Edit;
use super::super::traits::create::Create;</pre>
			<p>Then, we can implement these traits after the definition of our <code>Pending</code> struct with the following code:</p>
			<pre class="source-code">
impl Get for Pending {}
impl Edit for Pending {}
impl Create for Pending {}</pre>
			<p>In the preceding code, we can see that our <code>Pending</code> struct can get, edit, and create but cannot delete. Implementing these traits also ties our <code>Pending</code> and <code>Done</code> structs together without compiling them. For instance, if we accepted a struct that implemented the <code>Edit</code> trait, it would accept both the <code>Pending</code> and <code>Done</code> structs. However, if we were to create a function that accepted structs that implemented the <code>Delete</code> trait, it would accept the <code>Done</code> struct but reject the <code>Pending</code> struct. This gives us a beautiful symphony of aggressive type-checking yet flexibility, which is truly a testament to Rust’s design. Now that our structs have all the traits that we want, we can completely rewrite our <code>main.rs</code> file utilizing them. First, we import what we need with the following code: </p>
			<pre class="source-code">
mod to_do;
use to_do::to_do_factory;
use to_do::enums::TaskStatus;
use to_do::ItemTypes;
use crate::to_do::traits::get::Get;
use crate::to_do::traits::delete::Delete;
use crate::to_do::traits::edit::Edit;</pre>
			<p>The imports are important to note this time around. Although we have implemented our traits on the structs that we want, we will have to import the traits into the file that is using them. This can be a bit confusing. For example, calling the <code>get</code> function from the <code>Get</code> trait after a struct has been initialized would take the form of <code>item.get(&amp;item.super_struct.title);</code>. The <code>get</code> function is tethered to the initialized struct. Intuitively, it makes sense not to need to import the trait. However, your compiler or IDE will give you the unhelpful error that the function named <code>get</code> is not found in the struct if you do not import the trait. This is important as we will use traits from database crates and web frameworks in the future and we will need to import these traits for the package structs to be used. With our imports, we can then utilize our traits and factory in the <code>main</code> function with the following code:</p>
			<pre class="source-code">
fn main() {
    let to_do_items = to_do_factory("washing", 
                                    TaskStatus::DONE);
    match to_do_items {
        ItemTypes::Done(item) =&gt; {
            item.get(&amp;item.super_struct.title);
            item.delete(&amp;item.super_struct.title);
        },
        ItemTypes::Pending(item) =&gt; {
            item.get(&amp;item.super_struct.title);
            item.set_to_done(&amp;item.super_struct.title);
        }
    }
}</pre>
			<p>Running the preceding code gives us the following printout:</p>
			<pre class="console">
washing is being fetched
washing is being deleted</pre>
			<p>What we have done here is build our own <a id="_idIndexMarker208"/><a id="_idIndexMarker209"/>module, which contains an entry point. We’ve then imported it into the <code>main</code> function and run it. Now, the basic structure is built and working, but we need to get the module to interact with the environment by passing variables in and writing to a file to become useful. </p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Interacting with the environment</h1>
			<p>To interact with the environment, we must <a id="_idIndexMarker210"/><a id="_idIndexMarker211"/>manage two things. First, we need to load, save, and edit the state of to-do items. Second, we also must accept user input to edit and display data. Our program can achieve this by running the following steps for each process:</p>
			<ol>
				<li value="1">Collect arguments from the user.</li>
				<li>Define a command (<code>get</code>, <code>edit</code>, <code>delete</code>, and <code>create</code>) and define a to-do title from commands being passed into the application.</li>
				<li>Load a JSON file that stores the to-do items from previous runs of the program.</li>
				<li>Run a <code>get</code>, <code>edit</code>, <code>delete</code>, or <code>create</code> function based on the command passed into the program, saving the result of the state in a JSON file at the end. </li>
			</ol>
			<p>We can start making this four-step process <a id="_idIndexMarker212"/><a id="_idIndexMarker213"/>possible by initially loading our state with the <code>serde</code> crate. </p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Reading and writing JSON files </h2>
			<p>We are now at the stage where we are<a id="_idIndexMarker214"/><a id="_idIndexMarker215"/> going to persist data in the form of a JSON file. We will upgrade this to a proper database in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>. But for now, we are going to introduce our first dependency in our web <a id="_idIndexMarker216"/><a id="_idIndexMarker217"/>application, which is <code>serde_json</code>. This <code>serde_json</code> crate handles the conversion of Rust data to JSON data and vice versa. We will use <code>serde_json</code> to process HTTP requests in the next chapter. We can install our crate in the <code>Cargo.toml</code> file with the following code:</p>
			<pre class="source-code">
[dependencies]
serde_json="1.0.59"</pre>
			<p>Seeing as we are going to be upgrading our storage option in the future, it makes sense to keep the operations around reading and writing to our JSON file separate from the rest of the application. We do not want a lot of debugging and refactoring when we pull it out for our database upgrade. We will also keep it simple as there are no schema or migrations that must be managed when reading and writing to a JSON file. Considering this, all we will need are <code>read</code> and <code>write</code> functions. As our module is small and simple, we can house our module in just one file next to the <code>main.rs</code> file. First, we need to import what we need in our <code>src/state.rs</code> file with the following code: </p>
			<pre class="source-code">
use std::fs::File;
use std::fs;
use std::io::Read;
use serde_json::Map;
use serde_json::value::Value;
use serde_json::json;</pre>
			<p>As we can see, we need the standard library and a series of structs to read the data as mapped out in <em class="italic">Figure 2</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/Figure_2.5_B18722.jpg" alt="Figure 2.5 – Steps to read a JSON file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Steps to read a JSON file</p>
			<p>We can carry out the<a id="_idIndexMarker218"/><a id="_idIndexMarker219"/> steps in <em class="italic">Figure 2</em><em class="italic">.5</em> with the following code:</p>
			<pre class="source-code">
pub fn read_file(file_name: &amp;str) -&gt; Map&lt;String, Value&gt; {
    let mut file = File::open(file_name.to_string()).unwrap();
    let mut data = String::new();
    file.read_to_string(&amp;mut data).unwrap();
    let json: Value = serde_json::from_str(&amp;data).unwrap();
    let state: Map&lt;String, Value&gt; = json.as_object()
                                    .unwrap().clone();
    return state
}</pre>
			<p>In the preceding code, we can see that we <a id="_idIndexMarker220"/><a id="_idIndexMarker221"/>directly unwrap the opening of the file. This is because there is no point in continuing the program if we cannot read the file, and as a result, we directly unwrap the file read. We must also note that the string must be mutable as we are going to fill this string with JSON data. Additionally, we use the <code>serde_json</code> crate to process the JSON data and configure it into a map. We can now access <a id="_idIndexMarker222"/><a id="_idIndexMarker223"/>our to-do items via this <code>Map</code> variable throughout the rest of the program. Now, we need to write our data, which can be <a id="_idIndexMarker224"/><a id="_idIndexMarker225"/>done in the same file with the following code: </p>
			<pre class="source-code">
pub fn write_to_file(file_name: &amp;str, 
                     state: &amp;mut Map&lt;String, Value&gt;) {
    let new_data = json!(state);
    fs::write(
          file_name.to_string(),
          new_data.to_string()
    ).expect("Unable to write file");
}</pre>
			<p>In the preceding code, we accept our <code>Map</code> variable and the path to the file. We then convert our <code>Map</code> variable into JSON using the <code>json!</code> macro from our <code>serde_json</code> crate. We then convert the JSON data to a string and then write it to our JSON file. Because of this, we now have functions to read and write to-do items to JSON files. We can now upgrade our <code>main.rs</code> file and build a simple command-line to-do application that reads and writes to-do items to a JSON file. We can interact with this using some basic arguments passed into the program with the following code:</p>
			<pre class="source-code">
mod state;
use std::env;
use state::{write_to_file, read_file};
use serde_json::value::Value;
use serde_json::{Map, json};
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let status: &amp;String = &amp;args[1];
    let title: &amp;String = &amp;args[2];
    let mut state: Map&lt;String, Value&gt; =
    read_file("./state.json");
    println!("Before operation: {:?}", state);
    state.insert(title.to_string(), json!(status));
    println!("After operation: {:?}", state);
    write_to_file("./state.json", &amp;mut state);
}</pre>
			<p>In the preceding code, we have done the following:</p>
			<ol>
				<li value="1">Collected the status and title from arguments passed into our program</li>
				<li>Read the to-do items from the JSON file </li>
				<li>Printed out the to-do items from the JSON file</li>
				<li>Inserted our new to-do item </li>
				<li>Printed out the new set of to-do items from memory </li>
				<li>Written our new to-do items list to our JSON file </li>
			</ol>
			<p>Our root path is going to be where the <code>Cargo.toml</code> file is, so we define an empty JSON file called <code>state.json</code> next to the <code>Cargo.toml</code> file. To interact with it, we can pass in the following command:</p>
			<pre class="console">
cargo run pending washing</pre>
			<p>The preceding command would result in the following printout:</p>
			<pre class="console">
Before operation: {}
After operation: {"washing": String("pending")}</pre>
			<p>In the preceding output, we can see<a id="_idIndexMarker226"/><a id="_idIndexMarker227"/> that <code>washing</code> has been inserted. An inspection of our JSON file would also show that <code>washing</code> has been written to the file. You may have noticed that we have removed any mention of our <code>to_do</code> module, including all the <a id="_idIndexMarker228"/><a id="_idIndexMarker229"/>structs and traits that we have built. We have not forgotten them. Instead, we are merely testing to see whether our interaction with the JSON file works before we try and fuse <code>to_do</code> with the <code>state</code> module. We will fuse the <code>to_do</code> and <code>state</code> modules by revising the traits implemented in our to-do structs in the next section. </p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Revisiting traits</h2>
			<p>Now that we have defined the module around managing the<a id="_idIndexMarker230"/><a id="_idIndexMarker231"/> state of our to-do items in a JSON file, we have an idea of how our trait functions will process the data and interact with our JSON file. To start off, we can update our simplest trait, which is the <code>Get</code> trait in our <code>src/to_do/traits/get.rs</code> file. Here, we are merely getting the to-do item from our JSON map and printing it out. We can do this by simply passing the JSON map into our <code>get</code> function, getting the to-do item status from the map using the to-do item title from the state, and printing it out to the console with the following code:</p>
			<pre class="source-code">
use serde_json::Map;
use serde_json::value::Value;
pub trait Get {
    fn get(&amp;self, title: &amp;String, state: &amp;Map&lt;String, Value&gt;) {
        let item: Option&lt;&amp;Value&gt; = state.get(title);
        match item {
            Some(result) =&gt; {
                println!("\n\nItem: {}", title);
                println!("Status: {}\n\n", result);
            },
            None =&gt; println!("item: {} was not found", 
                              title)
        }
    }
}</pre>
			<p>In the preceding code, we can see that we perform a <code>get</code> function on our JSON <code>Map</code>, matching the outcome and printing out what we extract. This means that any to-do item that implements the <code>Get</code> trait can now extract a to-do item from our state and print it out.  </p>
			<p>We can now move on to the next step<a id="_idIndexMarker232"/><a id="_idIndexMarker233"/> in complexity, which is the <code>Create</code> trait in our <code>src/to_do/traits/create.rs</code> file. This is slightly more complex than our <code>Get</code> trait because we edit the state by inserting the new to-do item and then writing this updated state into our JSON. We can carry out these steps with the following code:</p>
			<pre class="source-code">
use serde_json::Map;
use serde_json::value::Value;
use serde_json::json;
use crate::state::write_to_file;
pub trait Create {
    fn create(&amp;self, title: &amp;String, status: &amp;String,
              state: &amp;mut Map&lt;String, Value&gt;) {
            state.insert(title.to_string(), json!(status));
            write_to_file("./state.json", state);
            println!("\n\n{} is being created\n\n", title);
    }
}</pre>
			<p>In the preceding code, we can see that we have used the <code>write_to_file</code> function from the <code>state</code> module to save our state to the JSON file. We can use the <code>create</code> function as a template for what we need to do when deleting a to-do item. Deleting is essentially the inverse of what we have done in our <code>create</code> function. You can try to write the <code>delete</code> function for the <code>Delete</code> trait in the <code>src/to_do/traits/delete.rs</code> file now before moving on if you want. Your function may look different; however, it should run along the same lines as the following code:</p>
			<pre class="source-code">
use serde_json::Map;
use serde_json::value::Value;
use crate::state::write_to_file;
pub trait Delete {
    fn delete(&amp;self, title: &amp;String,
        state: &amp;mut Map&lt;String, Value&gt;) {
        state.remove(title);
        write_to_file("./state.json", state);
        println!("\n\n{} is being deleted\n\n", title);
    }
}</pre>
			<p>In the preceding code, we are merely<a id="_idIndexMarker234"/><a id="_idIndexMarker235"/> using the <code>remove</code> function on our JSON <code>Map</code>, writing the updated state to our JSON file. We are near the end of the section. All we need to do now is build our <code>edit</code> function for our <code>Edit</code> trait in the <code>src/to_do/traits/edit.rs</code> file. We have two functions. One will set the to-do item status to <code>DONE</code>. The other function will set the to-do item status to <code>PENDING</code>. These will be achieved by updating the state and then writing the updated state to the JSON file. You can try and write this yourself before reading on. Hopefully, your code will look like the following code:</p>
			<pre class="source-code">
use serde_json::Map;
use serde_json::value::Value;
use serde_json::json;
use crate::state::write_to_file;
use super::super::enums::TaskStatus;
pub trait Edit {
    fn set_to_done(&amp;self, title: &amp;String,
        state: &amp;mut Map&lt;String, Value&gt;) {
        state.insert(title.to_string(),
        json!(TaskStatus::DONE.stringify()));
        write_to_file("./state.json", state);
        println!("\n\n{} is being set to done\n\n", title);
    }
    fn set_to_pending(&amp;self, title: &amp;String,
        state: &amp;mut Map&lt;String, Value&gt;) {
        state.insert(title.to_string(),
        json!(TaskStatus::PENDING.stringify()));
        write_to_file("./state.json", state);
        println!("\n\n{} is being set to pending\n\n", title);
    }
}</pre>
			<p>Our traits can now interact without the<a id="_idIndexMarker236"/><a id="_idIndexMarker237"/> JSON file, carrying out the processes that we initially wanted them to do. There is nothing stopping us from utilizing these traits directly in the <code>main.rs</code> file as we did when we first defined these traits. However, this is not scalable. This is because we will essentially be building a web application with multiple views and API endpoints. Therefore, we will be interacting with these traits and storage processes in multiple different files. Therefore, we are going to have to come up with a way to interact with these traits in a standardized way without having to repeat code, which we will do in the next section. </p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Processing traits and structs</h2>
			<p>To enable our code to interact with a <a id="_idIndexMarker238"/><a id="_idIndexMarker239"/>simple interface, enabling us<a id="_idIndexMarker240"/><a id="_idIndexMarker241"/> to update with minimal pain and reduce repeated code and thus errors, we need a processes layer, as seen in <em class="italic">Figure 2</em><em class="italic">.6</em>: </p>
			<div><div><img src="img/Figure_2.6_B18722.jpg" alt="Figure 2.6 – Trait flow through a processes module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Trait flow through a processes module</p>
			<p>In <em class="italic">Figure 2</em><em class="italic">.6</em>, we can see that our structs are bound to the traits in a loose fashion and that the data flow to and from the JSON goes through the traits. We can also see that we have one entry point in the <code>processes</code> module, which will then direct commands to the correct traits, which in turn will access the JSON file as and when <a id="_idIndexMarker242"/><a id="_idIndexMarker243"/>needed. Seeing as <a id="_idIndexMarker244"/><a id="_idIndexMarker245"/>we have defined our traits, all we need to do is build our <code>processes</code> module, connect it to the traits, and then connect it to our <code>main.rs</code> file. We will be building our entire <code>processes</code> module in a single <code>src/processes.rs</code> file. We are keeping it to a single file because we will be removing it when we cover databases. There is no need to take on too much technical debt if we know we are going to be removing it in the future. For now, we can start building our <code>processes</code> module by initially importing all the structs and traits that we need with the following code:</p>
			<pre class="source-code">
use serde_json::Map;
use serde_json::value::Value;
use super::to_do::ItemTypes;
use super::to_do::structs::done::Done;
use super::to_do::structs::pending::Pending;
use super::to_do::traits::get::Get;
use super::to_do::traits::create::Create;
use super::to_do::traits::delete::Delete;
use super::to_do::traits::edit::Edit;</pre>
			<p>We can now start to build non-public functions. We can start by processing our <code>Pending</code> structs. We know that we can either get, create, or edit pending to-do items, as seen in the following code:</p>
			<pre class="source-code">
fn process_pending(item: Pending, command: String, 
                   state: &amp;Map&lt;String, Value&gt;) {
    let mut state = state.clone();
    match command.as_str() {
    "get" =&gt; item.get(&amp;item.super_struct.title, &amp;state),
    "create" =&gt; item.create(&amp;item.super_struct.title, 
    &amp;item.super_struct.status.stringify(), &amp;mut state),
    "edit" =&gt; item.set_to_done(&amp;item.super_struct.title, 
                               &amp;mut state),
    _ =&gt; println!("command: {} not supported", command)
    }
}</pre>
			<p>In the preceding code, we can see that we have ingested the <code>Pending</code> struct, command, and current state of our to-do items. We then match the command and execute the trait associated with that command. If there the command that is passed in is neither <code>get</code>, <code>create</code>, or <code>edit</code>, we do not support it, throwing an error<a id="_idIndexMarker246"/><a id="_idIndexMarker247"/> that tells the user what command is not supported. This is scalable. For instance, if we allow a <code>Pending</code> struct to <a id="_idIndexMarker248"/><a id="_idIndexMarker249"/>delete a to-do item from the JSON file, we merely must implement the <code>Delete</code> trait for the <code>Pending</code> struct and then add the <code>delete</code> command to our <code>process_pending</code> function. This would only take two lines of code in total, and this change would take effect throughout the application. This would also happen if we removed a command. We now have a flexible implementation of our <code>Pending</code> struct. With this in mind, you can choose to code our <code>process_done</code> function before reading on. If you have chosen to do so, hopefully, it will look like the following code:</p>
			<pre class="source-code">
fn process_done(item: Done, command: String, 
                state: &amp;Map&lt;String, Value&gt;) {
    let mut state = state.clone();
    match command.as_str() {
        "get" =&gt; item.get(&amp;item.super_struct.title, 
                          &amp;state),
        "delete" =&gt; item.delete(&amp;item.super_struct.title, 
                                &amp;mut state),
        "edit" =&gt; 
             item.set_to_pending(&amp;item.super_struct.title, 
                                 &amp;mut state),
        _ =&gt; println!("command: {} not supported", command)
    }
}</pre>
			<p>We can now process both our structs. This <a id="_idIndexMarker250"/><a id="_idIndexMarker251"/>is where the scalability of structs comes in when designing our module. Like the commands, we will want to stack <a id="_idIndexMarker252"/><a id="_idIndexMarker253"/>our structs just like we did with our traits. This is where our entry point comes in, as seen in <em class="italic">Figure 2</em><em class="italic">.7</em>:</p>
			<div><div><img src="img/Figure_2.7_B18722.jpg" alt="Figure 2.7 – Scalability of processes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Scalability of processes</p>
			<p>We can see from <em class="italic">Figure 2</em><em class="italic">.7</em> that we can scale the access to structs by increasing the routes by the entry point. To appreciate this more, we should define our entry point, which this time is a public function, with the following code:</p>
			<pre class="source-code">
pub fn process_input(item: ItemTypes, command: String, 
                     state: &amp;Map&lt;String, Value&gt;) {
    match item {
        ItemTypes::Pending(item) =&gt; process_pending(item, 
                                    command, state),
        ItemTypes::Done(item) =&gt; process_done(item, 
                                    command, state)
    }
}</pre>
			<p>In the preceding code, we can see that we <a id="_idIndexMarker254"/><a id="_idIndexMarker255"/>route to the correct struct with the <code>ItemTypes</code> enum. Our module can process more structs by adding the new struct to the <code>ItemTypes</code> enum, writing a new function that processes that struct in the <code>processes</code> module, and then applying the desired traits to the struct. Our <code>processes</code> module is now fully <a id="_idIndexMarker256"/><a id="_idIndexMarker257"/>completed, and we can rewrite our <code>main.rs</code> file to utilize it. First of all, we import what we need with the following code:</p>
			<pre class="source-code">
mod state;
mod to_do;
mod processes;
use std::env;
use serde_json::value::Value;
use serde_json::Map;
use state::read_file;
use to_do::to_do_factory;
use to_do::enums::TaskStatus;
use processes::process_input;</pre>
			<p>With these imports, we can see that we are going to be reading the data from the JSON file, using <code>to_do_factory</code> to create the structs from the input collected from the environment, and passing this into our <code>processes</code> module to update the JSON file. This is a good point in time to stop reading and try to code out this process by yourself. Remember, you must get the data from the JSON file and check to see whether the title of the to-do item is already stored in the JSON file. If we cannot find the title in the data from the JSON file, we then know that it is going to be a pending status as we cannot create a done task. If you chose to do this, your code hopefully looks like the following:</p>
			<pre class="source-code">
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let command: &amp;String = &amp;args[1];
    let title: &amp;String = &amp;args[2];
    let state: Map&lt;String, Value&gt; = read_file("./state.json");
    let status: String;
    match &amp;state.get(*&amp;title) {
        Some(result) =&gt; {
            status = result.to_string().replace('\"', "");
        }
        None=&gt; {
            status = "pending".to_owned();
        }
    }
    let item = to_do_factory(title, 
                             TaskStatus::from_string(
                             status.to_uppercase()));
    process_input(item, command.to_string(), &amp;state);
}</pre>
			<p>Before we run anything, you might have <a id="_idIndexMarker258"/><a id="_idIndexMarker259"/>realized that we created an instance of the <code>TaskStatus</code> using the <code>from_string</code> function. We have not<a id="_idIndexMarker260"/><a id="_idIndexMarker261"/> built the <code>from_string</code> function yet. At this point you should be able to build it yourself in the <code>impl TaskStatus</code> block. If you have attempted to build the <code>from_string</code> function, it should look like the following code in the <code>src/to_do/enums.rs</code> file:</p>
			<pre class="source-code">
impl TaskStatus {
    . . .
    pub fn from_string(input_string: String) -&gt; Self {
        match input_string.as_str() {
            "DONE" =&gt; TaskStatus::DONE,
            "PENDING" =&gt; TaskStatus::PENDING,
            _ =&gt; panic!("input {} not supported", 
                        input_string)
        }
    }
}</pre>
			<p>If you have managed to utilize the interfaces that we have created to get our program running, then well done. We can see now that we orchestrate a range of processes in our <code>main</code> function with ease. We can interact with our program with the following command:</p>
			<pre class="console">
cargo run create washing</pre>
			<p>The preceding command creates a to-do item<a id="_idIndexMarker262"/><a id="_idIndexMarker263"/> called <code>washing</code> in our JSON file with the status of pending. All our other traits are supported, and we can carry them <a id="_idIndexMarker264"/><a id="_idIndexMarker265"/>out in the command line as well. We have now built a basic command application that stores to-do items in a JSON file. However, it is not just a basic command-line application. We have structured our modules so they are scalable and flexible.   </p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Summary</h1>
			<p>What we have essentially done in this chapter is build a program that accepts some command-line inputs, interacts with a file, and edits it depending on the command and data from that file. The data is simple: a title and a status. We could have done this all in the <code>main</code> function with multiple <code>match</code> statements and <code>if</code>, <code>else if</code>, and <code>else</code> blocks. However, this is not scalable. Instead, we built structs that inherited other structs, which then implemented traits. We then packaged the construction of these structs into a factory, enabling other files to use all that functionality in a single line of code.</p>
			<p>We then built a processing interface so the command input, state, and struct could be processed, enabling us to stack on extra functionality and change the flow of the process with a few lines of code. Our main function must only focus on collecting the command-line arguments and coordinating when to call the module interfaces. We have now explored and utilized how Rust manages modules, giving us the building blocks to build real-world programs that can solve problems and add features without being hurt by tech debt and a ballooning <code>main</code> function. Now that we can do this, we are ready to start building scalable web apps that can grow. In the next chapter, we will learn about the <strong class="bold">Actix Web framework</strong> to get a basic web server up and running.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Questions</h1>
			<ol>
				<li value="1">What does the <code>--release</code> argument in Cargo do when added to a build and run? </li>
				<li>How do we enable a file to be accessible within and outside the module?</li>
				<li>What are the advantages of having traits with a single scope? </li>
				<li>What steps would we have to take to add an <code>OnHold</code> to-do item that will only allow <code>Get</code> and <code>Edit</code> functionality? </li>
				<li>What are the benefits of a factory function? </li>
				<li>How do we effectively map a range of processes based on some processes? </li>
			</ol>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Answers</h1>
			<ol>
				<li value="1">In a build, the <code>--release</code> argument compiles the program in an optimized way as opposed to a debug compilation. In a run, the <code>--release</code> argument points to an optimized binary as opposed to the debug binary. An optimized binary takes longer to compile but will run at a faster pace. </li>
				<li>To enable a file to be accessible to other files in a module, we must define the file as a module in the <code>mod.rs</code> file at the root of the module. We add <code>mod</code> before the definition to make it accessible outside the module.  </li>
				<li>Single-scope traits enable maximum flexibility when defining structs. A good example would be adding an <code>OnHold</code> to-do item. With this item, we might only allow it to have an edit trait, which we can do by implementing the single-scoped <code>Edit</code> trait. If we had one trait that did all the functions, this would not be possible. </li>
				<li>Define a struct in its own file in structs that inherit from the base struct, which also implements the <code>Get</code> and <code>Edit</code> traits. Add a <code>hold</code> type to the enum in the factory file. Add another line in the <code>match</code> statement for the entry point in the processes that point to a new function processing the <code>OnHold</code> item. </li>
				<li>The factory function standardizes the construction of structs. It also reduces the possibility of building one of a range of structs outside of the module with just one line of code. This stops other files from ballooning and does not require the developer to look around in the module to utilize it. </li>
				<li>We use <code>match</code> statements that lead to other <code>match</code> statements. This enables us to code a tree-like effect and there is nothing stopping us from connecting branches later down the chain. This is demonstrated in <em class="italic">Figure 2</em><em class="italic">.7</em>.</li>
			</ol>
		</div>
	

		<div><h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Part 2:Processing Data and Managing Displays </h1>
			<p>Now that we can build applications in Rust, we need to be able to handle HTTP requests. By the end of this part, you will know how to handle HTTP requests and route them. You will also be able to extract data from the request body and header. You will also structure the application so routing can scale and implement middleware to process and route HTTP requests before the view is loaded. Finally, you will understand how to display content in the browser by directly serving HTML, CSS, and JavaScript from the server. We will also explore a basic React application and wrap it in Electron to have a desktop application to talk to our Rust server. At this point, you will have learned everything to run a basic application without a proper database or authentication.  </p>
			<p>This part includes the following chapters:</p>
			<ul>
				<li><a href="B18722_03.xhtml#_idTextAnchor059"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling HTTP Requests</em></li>
				<li><a href="B18722_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Processing HTTP Requests</em></li>
				<li><a href="B18722_05.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a>, <em class="italic">Displaying Content in the Browser</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>