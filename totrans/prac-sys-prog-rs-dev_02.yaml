- en: '*Chapter 1*: Tools of the Trade – Rust Toolchains and Project Structures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust, as a modern systems programming language, has many inherent characteristics
    that make it easier to write safe, reliable, and performant code. Rust also has
    a compiler that enables a relatively fearless code refactoring experience as a
    project grows in size and complexity. But any programming language in itself is
    incomplete without the toolchains that support the software development life cycle.
    After all, where would software engineers be without their tools?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter specifically discusses the Rust toolchain and its ecosystem, and
    techniques to structure code within Rust projects to write safe, testable, performant,
    documented, and maintainable code that is also optimized to run in the intended
    target environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key learning outcomes for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right configuration of Rust for your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cargo introduction and project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cargo build management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cargo dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test scripts and doing automated unit and integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the generation of technical documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to select the right project
    type and toolchain; organize project code efficiently; add external and internal
    libraries as dependencies; build the project for development, test, and production
    environments; automate testing; and generate documentation for your Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rustup must be installed in the local development environment. Use this link
    for installation: [https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following link for official installation instructions: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, check `rustc`, and `cargo` have been installed correctly
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You must have access to any code editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the code and commands in this chapter, especially those related to shared
    libraries and setting paths, require a Linux system environment. It is recommended
    to install a local virtual machine such as VirtualBox or equivalent with a Linux
    installation for working with the code in this chapter. Instructions to install
    VirtualBox can be found at [https://www.virtualbox.org](https://www.virtualbox.org).
  prefs: []
  type: TYPE_NORMAL
- en: The Git repo for the examples in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right Rust configuration for your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start with Rust programming, you have to first select a Rust release
    channel and a Rust project type.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses details of the Rust *release channels* and gives guidance
    on how to choose among them for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Rust also allows you to build different types of binaries – standalone executables,
    static libraries, and dynamic libraries. If you know upfront what you will be
    building, you can create the right project type with the scaffolding code generated
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover these in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Rust release channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Rust programming language is developed continually and there are three releases
    being developed simultaneously at any point in time, each called a **release channel**.
    Each channel has a purpose and has varying features and stability characteristics.
    The three release channels are *stable*, *beta*, and *nightly*. Unstable language
    features and libraries are developed in the **nightly** and **beta** channels,
    while stability guarantees are provided on the **stable** channel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rustup** is the tool that installs the Rust compiler, the Rust Standard Library,
    the Cargo package manager, and other core tools for activities such as code formatting,
    testing, benchmarking, and documentation. All these tools are available in multiple
    flavors called *toolchains*. A *toolchain* is a combination of a *release channel*
    and a *host*, and optionally also has an associated archive date.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rustup* can install a toolchain from a *release channel*, or from other sources
    such as official archives and local builds. *Rustup* also determines the toolchain
    depending on the host platform. Rust is officially available on Linux, Windows,
    and macOS. Rustup thus is called a *tool multiplexer* as it installs and manages
    multiple toolchains, and in this sense is similar to *rbenv*, *pyenv*, or *nvm*
    in *Ruby*, *Python*, and *Node.js* respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Rustup manages the complexity associated with toolchains but makes the installation
    process fairly straightforward as it provides sensible defaults. These can later
    be modified by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Rust's stable version is released every 6 weeks; for example, Rust 1.42.0 was
    released on March 12, 2020, and 6 weeks later to the day, Rust 1.43 was released
    on April 23, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: A new nightly version of Rust is released every day. Once every 6 weeks, the
    latest master branch of nightly becomes the beta version.
  prefs: []
  type: TYPE_NORMAL
- en: Most Rust developers primarily use the *stable* channel. Beta channel releases
    are not used actively, but only to test for any regressions in the Rust language
    releases.
  prefs: []
  type: TYPE_NORMAL
- en: The *nightly* channel is for active language development and is published every
    night. The *nightly* channel lets Rust develop new and experimental features and
    allows early adopters to test them before they are stabilized. The price to be
    paid for early access is that there may be breaking changes to these features
    before they get into stable releases. Rust uses feature flags to determine what
    features are enabled in a given nightly release. A user who wants to use a cutting-edge
    feature in nightly version has to annotate the code with the appropriate *feature
    flag*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a feature flag is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that beta and stable releases cannot use feature flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rustup is configured to use the stable channel by default. To work with other
    channels, here are a few commands. For a complete list, refer to the official
    link: [https://github.com/rust-lang/rustup](https://github.com/rust-lang/rustup).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install nightly Rust, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To activate nightly Rust globally, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To activate nightly at a directory level, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the version of the compiler in nightly Rust, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To reset `rustup` to use the stable channel, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the installed toolchains and which is currently active, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the installed toolchains to the latest versions, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that once `rustup default <channel-name>` is set, other related tools,
    such as Cargo and Rustc, use the default channel set.
  prefs: []
  type: TYPE_NORMAL
- en: Which Rust channel should you use for your project? For any **production-bound**
    projects, it is advisable to use only the **stable** release channel. For any
    **experimental** projects, the **nightly** or **beta** channels may be used, with
    caution as there may be breaking changes needed for the code in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a Rust project type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two basic types of projects in Rust: **libraries** and **binaries**
    (or executables).'
  prefs: []
  type: TYPE_NORMAL
- en: A *library* is a self-contained piece of code that is intended for use by other
    programs. The purpose of a library is to enable code reuse and speed up the development
    cycle by leveraging the hard work of other open source developers. Libraries,
    also called a `crates.io`) that can be discovered and downloaded by other developers
    for use in their own programs. Program execution for a library crate begins in
    the `src/lib.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: A *binary* is a standalone executable that may download and link other libraries
    into a single binary. A binary project type is also called a `main()` function
    that is present in the `src/main.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to determine whether you want to build a binary or a library
    program in Rust while initializing the project. We will see examples of these
    two types of projects later in this chapter. It's time to introduce the star tool
    and Swiss-Army knife in the Rust ecosystem, *Cargo*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Cargo and project structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is the official build and dependency management tool for Rust. It has
    many of the features of the other popular tools in this segment, such as Ant,
    Maven, Gradle, npm, CocoaPods, pip, and yarn, but provides a far more seamless
    and integrated developer experience for compiling code, downloading and compiling
    dependent libraries (called **crates** in Rust), linking libraries, and building
    development and release binaries. It also performs the incremental build of the
    code to reduce the compilation time as the programs evolve. In addition, it creates
    an idiomatic project structure while creating new Rust projects.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Cargo as an integrated toolchain gives a seamless experience in the
    day-to-day tasks of creating a new project, building it, managing external dependencies,
    debugging, testing, generating documentation, and release management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo is the tool that can be used to set up the basic project scaffolding
    structure for a new Rust project. Before we create a new Rust project with Cargo,
    let''s first understand the options for organizing code within Rust projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Cargo project structure and hierarchy](img/Figure_1.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Cargo project structure and hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.1* shows how code can be organized within a Cargo-generated Rust
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: The smallest standalone unit of organization of code in a Rust project is a
    `main.rs` is a source file.
  prefs: []
  type: TYPE_NORMAL
- en: The next highest level of code organization is a **module**. Code within modules
    has its own unique namespace. A module can contain user-defined data types (such
    as structs, traits, and enums), constants, type aliases, other module imports,
    and function declarations. Modules can be nested within one another. Multiple
    module definitions can be defined within a single source file for smaller projects,
    or a module can contain code spread across multiple source files for larger projects.
    This type of organization is also referred to as a module system.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple modules can be organized into `main.rs` and for library crates it is
    `lib.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: One or more crates can be combined into a `Cargo.toml` file, which contains
    information on how to build the package, including downloading and linking the
    dependent crates. When Cargo is used to create a new Rust project, it creates
    a *package*. A *package* must contain at least one crate – either a library or
    a binary crate. A package may contain any number of binary crates, but it can
    contain either zero or only one library crate.
  prefs: []
  type: TYPE_NORMAL
- en: As Rust projects grow in size, there may be a need to split up a package into
    multiple units and manage them independently. A set of related packages can be
    organized as a `Cargo.lock` file (containing details of specific versions of dependencies
    that are shared across all packages in the workspace) and output directory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a few examples to understand various types of project structures in
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Automating build management with Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Rust code is compiled and built, the generated binary can either be a standalone
    executable binary or a library that can be used by other projects. In this section,
    we will look at how Cargo can be used to create Rust binaries and libraries, and
    how to configure metadata in `Cargo.toml` to provide build instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic binary crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will build a basic binary crate. A binary crate when built,
    produces an executable binary file. This is the default crate type for the cargo
    tool. Let's now look at the command to create a binary crate.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to generate a Rust source package using the `cargo new` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command in a terminal session inside your working directory
    to create a new package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the command executes, you will see the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the `src` directory contains one file called `main.rs`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To generate a binary crate (or executable) from this package, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following printed to your console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A cargo package can contain the source for multiple binaries. Let''s learn
    how to add another binary to our project. In `Cargo.toml`, add a new `[[bin]]`
    target below the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new file, `src/second.rs`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see the statement `target/debug` directory with the name `new-second-program`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You have learned how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create your first Rust source package and compile it into an executable binary
    crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give a new name to the binary, different from the package name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a second binary to the same cargo package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a `cargo` package can contain one or more binary crates.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cargo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cargo package has an associated `Cargo.toml` file, which is also called the
    **manifest**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest, at a minimum, contains the `[package]` section but can contain
    many other sections. A subset of the sections are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specifying output targets for the package**: Cargo packages can have five
    types of targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[bin]]`: A binary target is an executable program that can be run after it
    is built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[lib]`: A library target produces a library that can be used by other libraries
    and executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[example]]`: This target is useful for libraries to demonstrate the use of
    external APIs to users through example code. The example source code located in
    the `example` directory can be built into executable binaries using this target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[test]]`: Files located in the `tests` directory represent integration tests
    and each of these can be compiled into a separate executable binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[bench]]`: Benchmark functions defined in libraries and binaries are compiled
    into separate executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these targets, the configuration can be specified, including parameters
    such as the name of the target, the source file of the target, and whether you
    want cargo to automatically run test scripts and generate documentation for the
    target. You may recall that in the previous section, we changed the name and set
    the source file for the generated binary executable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Specifying dependencies for the package**: The source files in a package
    may depend on other internal or external libraries, which are also called *dependencies*.
    Each of these in turn may depend on other libraries and so on. Cargo downloads
    the list of dependencies specified under this section and links them to the final
    output targets. The various types of dependencies include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[dependencies]`: Package library or binary dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[dev-dependencies]`: Dependencies for examples, tests, and benchmarks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[build-dependencies]`: Dependencies for build scripts (if any are specified)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[target]`: This is for the cross-compilation of code for various target architectures.
    Note that this is not to be confused with the output targets of the package, which
    can be lib, bin, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specifying build profiles**: There are four types of profiles that can be
    specified while building a cargo package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`: The `cargo build` command uses the `dev` profile by default. Packages
    built with this option are optimized for compile-time speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release`: The `cargo build –-release` command enables the release profile,
    which is suitable for production release, and is optimized for runtime speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: The `cargo test` command uses this profile. This is used to build test
    executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bench`: The `cargo bench` command creates the benchmark executable, which
    automatically runs all functions annotated with the `#[bench]` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[workspace]` section can be used to define the list of packages that are part
    of the workspace.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a static library crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to create binary crates. Let''s now learn how to create a
    library crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The default directory structure of a new cargo project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code in `src/lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will see the library built under `target/debug` and it will have the name
    `libmy_first_lib.rlib`.
  prefs: []
  type: TYPE_NORMAL
- en: To invoke the function in this library, let's build a small binary crate. Create
    a `bin` directory under `src`, and a new file, `src/bin/mymain.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `use my_first_lib::hello_from_lib` statement tells the compiler to bring
    the library function into the scope of this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will see the `print` statement in your console. Also, the binary `mymain`
    will be placed in the `target/debug` folder along with the library we wrote earlier.
    The binary crate looks for the library in the same folder, which it finds in this
    case. Hence it is able to invoke the function within the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to place the `mymain.rs` file in another location (instead of within
    `src/bin`), then add a target in `Cargo.toml` and mention the name and path of
    the binary as shown in the following example, and move the `mymain.rs` file to
    the specified location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run `cargo run --bin mymain` and you will see the `println` output in your console.
  prefs: []
  type: TYPE_NORMAL
- en: Automating dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned in the previous section how Cargo can be used to set up the base
    project directory structure and scaffolding for a new project, and how to build
    various types of binary and library crates. We will look at the dependency management
    features of Cargo in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Rust comes with a built-in standard library consisting of language primitives
    and commonly used functions, but it is small by design (compared to other languages).
    Most real-world programs in Rust depend on additional external libraries to improve
    functionality and developer productivity. Any such external code that is used
    is a *dependency* for the program. Cargo makes it easy to specify and manage dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the Rust ecosystem, *crates.io* is the central public package registry for
    discovering and downloading libraries (called `crates.io` as the default package
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are specified in the `[dependencies]` section of `Cargo.toml`.
    Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new project with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Cargo.toml`, make the following entry to include an external library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Chrono` is a datetime library. This is called a dependency because our `deps-example`
    crate depends on this external library for its functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run `cargo build`, cargo looks for a crate on `crates.io` with this
    name and version. If found, it downloads this crate along with all of its dependencies,
    compiles them all, and updates a file called `Cargo.lock` with the exact versions
    of packages downloaded. The `Cargo.lock` file is a generated file and not meant
    for editing.
  prefs: []
  type: TYPE_NORMAL
- en: Each dependency in `Cargo.toml` is specified in a new line and takes the format
    `<crate-name> = "<semantic-version-number>"`. **Semantic versioning or Semver**
    has the form X.Y.Z, where X is the major version number, Y is the minor version,
    and Z is the patch version.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the location of a dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to specify the location and version of dependencies in
    `Cargo.toml`, some of which are summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crates.io registry**: This is the default option and all that is needed is
    to specify the package name and version string as we did earlier in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crates.io` is the default registry, Cargo provides the option to use an alternate
    registry. The registry name has to be configured in the `.cargo/config` file,
    and in `Cargo.toml`, an entry is to be made with the registry name, as shown in
    the example here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Cargo.toml` file in order to fetch its dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specify a local path**: Cargo supports path dependencies, which means the
    library can be a sub-crate within the main cargo package. While building the main
    cargo package, the sub-crates that have also been specified as dependencies will
    be built. But dependencies with only a path dependency cannot be uploaded to the
    *crates.io* public registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple locations**: Cargo supports the option to specify both a registry
    version *and* either a Git or path location. For local builds, the Git or path
    version is used, and the registry version will be used when the package is published
    to *crates.io*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dependent packages in source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the dependencies are specified in the `Cargo.toml` file in any of the
    preceding formats, we can use the external library in the package code as shown
    in the following example. Add the following code to `src/main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `use` statement tells the compiler to bring the `chrono` package `Utc`
    module into the scope of this program. We can then access the function `now()`
    from the `Utc` module to print out the current date and time. The `use` statement
    is not mandatory. An alternative way to print datetime would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This would give the same result. But if you have to use functions from the `chrono`
    package multiple times in code, it is more convenient to bring `chrono` and required
    modules into scope once using the `use` statement, and it becomes easier to type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to rename the imported package with the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For more details on managing dependencies, refer to the Cargo docs: [https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how to add dependencies to a package. Any number
    of dependencies can be added to `Cargo.toml` and used within the program. Cargo
    makes the dependency management process quite a pleasant experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at another useful feature of Cargo – running automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust programming language has built-in support for writing automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Rust tests are basically Rust functions that verify whether the other non-test
    functions written in the package work as intended. They basically invoke the other
    functions with the specified data and assert that the return values are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has two types of tests – unit tests and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new Rust package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a new function that returns the process ID of the currently running process.
    We will look at the details of process handling in a later chapter, so you may
    just type in the following code, as the focus here is on writing unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have written a simple (silly) function to use the standard library process
    module and retrieve the process ID of the currently running process.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code using `cargo check` to confirm there are no syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a unit test. Note that we cannot know upfront what the process
    ID is going to be, so all we can test is whether a number is being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Run `cargo test`. You will see that the test has passed successfully, as the
    function returns a non-zero positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have written the unit tests in the same source file as the rest
    of the code. In order to tell the compiler that this is a test function, we use
    the `#[test]` annotation. The `assert!` macro (available in standard Rust library)
    is used to check whether a condition evaluates to true. There are two other macros
    available, `assert_eq!` and `assert_ne!`, which are used to test whether the two
    arguments passed to these macros are equal or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom error message can also be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To compile but not run the tests, use the `--no-run` option with the `cargo
    test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example has only one simple `test` function, but as the number
    of tests increases, the following problems arise:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we write any helper functions needed for test code and differentiate
    it from the rest of the package code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we prevent the compiler from compiling tests as part of each build (to
    save time) and not include test code as part of the normal build (saving disk/memory
    space)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to provide more modularity and to address the preceding questions,
    it is idiomatic in Rust to group test functions in a `test` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the changes made to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have moved the `test` function under the `tests` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added the `cfg` attribute, which tells the compiler to compile test
    code only if we are trying to run tests (that is, only for `cargo test`, not for
    `cargo build`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a `use` statement, which brings the `get_process_id` function into
    the scope of the `tests` module. Note that `tests` is an inner module and so we
    use `super:: prefix` to bring the function that is being tested into the scope
    of the `tests` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cargo test` will now give the same results. But what we have achieved is greater
    modularity, and we''ve also allowed for the conditional compilation of test code.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Writing unit tests in Rust* section, we saw how to define a `tests`
    module to hold the unit tests. This is used to test fine-grained pieces of code
    such as an individual function call. Unit tests are small and have a narrow focus.
  prefs: []
  type: TYPE_NORMAL
- en: For testing broader test scenarios involving a larger scope of code such as
    a workflow, integration tests are needed. It is important to write both types
    of tests to fully ensure that the library works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: To write integration tests, the convention in Rust is to create a `tests` directory
    in the package root and create one or more files under this folder, each containing
    one integration test. Each file under the `tests` directory is treated as an individual
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is a catch. Integration tests in Rust are not available for binary
    crates, only library crates. So, let''s create a new library crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In `src/lib.rs`, replace the existing code with the following. This is the
    same code we wrote earlier, but this time it is in `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `tests` folder and create a file, `tests/integration_test1.rs`.
    Add the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following changes to the test code compared to unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests are external to the library, so we have to bring the library
    into the scope of the integration test. This is simulating how an external user
    of our library would call a function from the public interface of our library.
    This is in place of `super:: prefix` used in unit tests to bring the tested function
    into scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did not have to specify the `#[cfg(test)]` annotation with integration tests,
    because these are stored in a separate folder and cargo compiles files in this
    directory only when we run `cargo test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We still have to specify the `#[test]` attribute for each `test` function to
    tell the compiler these are the test functions (and not helper/utility code) to
    be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `cargo test`. You will see that this integration test has been run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling test execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cargo test` command compiles the source code in test mode and runs the
    resultant binary. `cargo test` can be run in various modes by specifying command-line
    options. The following is a summary of the key options.
  prefs: []
  type: TYPE_NORMAL
- en: Running a subset of tests by name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there are a large number of tests in a package, `cargo test` runs all tests
    by default each time. To run any particular test cases by name, the following
    option can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify this, let''s replace the code in the `integration_test1.rs` file
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This last dummy `test` function is for purposes of the demonstration of running
    selective cases.
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo test` and you can see both tests executed.
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo test files_test1` and you can see `files_test1` executed.
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo test files_test2` and you can see `files_test2` executed.
  prefs: []
  type: TYPE_NORMAL
- en: Run `cargo test files` and you will see both `files_test1` and `files_test2`
    tests executed, but `process_test1` is not executed. This is because cargo looks
    for all test cases containing the term `'files'` and executes them.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring some tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, you want to execute most of the tests every time but exclude
    a few. This can be achieved by annotating the `test` function with the `#[ignore]`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, let''s say we want to exclude `process_test1` from
    regular execution because it is computationally intensive and takes a lot of time
    to execute. The following snippet shows how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Run `cargo test`, and you will see that `process_test1` is marked as ignored,
    and hence not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run only the ignored tests in a separate iteration, use the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first `--` is a separator between the command-line options for the `cargo`
    command and those for the `test` binary. In this case, we are passing the `--ignored`
    flag for the test binary, hence the need for this seemingly confusing syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests sequentially or in parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, `cargo test` runs the various tests in parallel in separate threads.
    To support this mode of execution, the `test` functions must be written in a way
    that there is no common data sharing across test cases. However if there is indeed
    such a need (for example, one test case writes some data to a location and another
    test case reads it), then we can run the tests in sequence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This command tells cargo to use only one thread for executing tests, which indirectly
    means that tests have to be executed in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Rust's strong built-in type system and strict ownership rules enforced
    by the compiler, coupled with the ability to script and execute unit and integration
    test cases as an integral part of the language and tooling, makes it very appealing
    to write robust, reliable systems.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust ships with a tool called `Rustdoc`, which can generate documentation for
    Rust projects. Cargo has integration with `Rustdoc`, so you can use either tool
    to generate documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To get an idea of what it means to have documentation generated for Rust projects,
    go to [http://docs.rs](http://docs.rs).
  prefs: []
  type: TYPE_NORMAL
- en: This is a documentation repository for all the crates in *crates.io*. To see
    a sample of the generated documentation, select a crate and view the docs. For
    example, you can go to `docs.rs/serde` to see docs for the popular serialization/deserialization
    library in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: To generate similar documentation for your Rust projects, it is important to
    think through what to document, and how to document it.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what can you document? The following are some of the aspects of a crate
    that it would be useful to document:'
  prefs: []
  type: TYPE_NORMAL
- en: An overall short description of what your Rust library does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of modules and public functions in the library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of other items, such as `traits`, `macros`, `structs`, `enums`, and `typedefs`,
    that a public user of the library needs to be familiar with to use various features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For binary crates, installation instructions and command-line parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples that demonstrate to users how to use the crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, design details for the crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know **what** to document, we have to learn **how** to document
    it. There are two ways to document your crate:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline documentation comments within the crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate markdown files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use either approach, and the `rustdoc` tool will convert them into `HTML`,
    `CSS`, and `JavaScript` code that can be viewed from a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing inline documentation comments within crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust has two types of comments: **code comments** (aimed at developers) and
    **documentation comments** (aimed at users of the library/crate).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code comments are written using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//` for single-line comments and writing inline documentation comments within
    crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/* */` for multi-line comments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation comments are written using two styles:'
  prefs: []
  type: TYPE_NORMAL
- en: The first style is to use three slashes `///` for commenting on individual items
    that follow the comments. Markdown notation can be used to style the comments
    (for example, bold or italic). *This is typically used for item-level documentation.*
  prefs: []
  type: TYPE_NORMAL
- en: The second style is to use `//!`. This is used to add documentation for the
    item that contains these comments (as opposed to the first style, which is used
    to comment items that follow the comments). *This is typically used for crate-level
    documentation.*
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, `rustdoc` extracts documentation from the crate's documentation
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following comments to the `integ-test-example` project, in `src/lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Run `cargo doc –open` to see the generated HTML documentation corresponding
    to the documentation comments.
  prefs: []
  type: TYPE_NORMAL
- en: Writing documentation in markdown files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new folder, `doc`, under the crate root, and add a new file, `itest.md`,
    with the following markdown content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the process ID of the currently running executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]rust'
  prefs: []
  type: TYPE_NORMAL
- en: use integ_test_example;
  prefs: []
  type: TYPE_NORMAL
- en: fn get_id() -> i32 {
  prefs: []
  type: TYPE_NORMAL
- en: let my_pid = get_process_id();
  prefs: []
  type: TYPE_NORMAL
- en: 'println!("Process id for current process is: {}", my_pid);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code example is only representational.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, cargo does not directly support generating HTML from standalone
    markdown files (at the time of this writing), so we have to use `rustdoc` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You will find the generated HTML document `itest.html` in the same folder. View
    it in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Running documentation tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are any code examples written as part of the documentation, `rustdoc`
    can execute the code examples as tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a code example for our library. Open `src/lib.rs` and add the
    following code example to existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: /// fn get_id() {
  prefs: []
  type: TYPE_NORMAL
- en: /// let x = integ_test_example::get_process_id();
  prefs: []
  type: TYPE_NORMAL
- en: /// println!("{}",x);
  prefs: []
  type: TYPE_NORMAL
- en: /// }
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE51]
  prefs: []
  type: TYPE_NORMAL
- en: If you run `cargo test --doc`, it will run this example code and provide the
    status of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, running `cargo test` will run all the test cases from the `tests`
    directory (except those that are marked as ignored), and then run the documentation
    tests (that is, code samples provided as part of the documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Cargo ecosystem of toolchains is very important to be effective
    as a Rust programmer, and this chapter has provided the foundational knowledge
    that will be used in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that there are three release channels in Rust – stable, beta, and
    nightly. Stable is recommended for production use, nightly is for experimental
    features, and beta is an interim stage to verify that there isn't any regression
    in Rust language releases before they are marked `stable`. We also learned how
    to use rustup to configure the toolchain to use for the project.
  prefs: []
  type: TYPE_NORMAL
- en: We saw different ways to organize code in Rust projects. We also learned how
    to build executable binaries and shared libraries. We also looked at how to use
    Cargo to specify and manage dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to write unit tests and integration tests for a Rust package
    using Rust's built-in test framework, how to invoke automated tests using cargo,
    and how to control test execution. We learned how to document packages both through
    inline documentation comments and using standalone markdown files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a quick tour of the Rust programming language,
    through a hands-on project.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cargo Book ([https://doc.rust-lang.org/cargo](https://doc.rust-lang.org/cargo))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rust Book ([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust Forge ([https://forge.rust-lang.org/](https://forge.rust-lang.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rustup book ([https://rust-lang.github.io/rustup/index.html](https://rust-lang.github.io/rustup/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust style guide – the Rust style guide contains conventions, guidelines,
    and best practices to write idiomatic Rust code, and can be found at the following
    link: [https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
