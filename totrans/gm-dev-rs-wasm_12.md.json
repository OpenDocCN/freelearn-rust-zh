["```rs\nuse futures::prelude::*;\nuse wasm_bindgen::JsValue; \nuse wasm_bindgen_futures::JsFuture;\nuse wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};\nwasm_bindgen_test_configure!(run_in_browser);\n// This runs a unit test in native Rust, so it can only use Rust APIs.\n#[test]\nfn rust_test() {\n    assert_eq!(1, 1);\n}\n// This runs a unit test in the browser, so it can use browser APIs.\n#[wasm_bindgen_test]\nfn web_test() {\n    assert_eq!(1, 1);\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn two_rects_that_intersect_on_the_left() {\n        let rect1 = Rect {\n            position: Point { x: 10, y: 10 },\n            height: 100,\n            width: 100,\n        };\n        let rect2 = Rect {\n            position: Point { x: 0, y: 10 },\n            height: 100,\n            width: 100,\n        };\n        assert_eq!(rect2.intersects(&rect1), true);\n    }\n}\n```", "```rs\n    Finished test [unoptimized + debuginfo] target(s) in 1.48s\n     Running target/debug/deps/rust_webpack_template-5805000a6d5d52b4\nrunning 1 test\ntest engine::tests::two_rects_that_intersect_on_the_left ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n     Running target/debug/deps/app-ec65f178e238b04b\nrunning 1 test\ntest rust_test ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nimpl WalkTheDogState<GameOver> {\n    ...\n    fn new_game(self) -> WalkTheDogState<Ready> {\n        browser::hide_ui();\n        WalkTheDogState {\n            _state: Ready,\n            walk: Walk::reset(self.walk),\n        }\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod test_browser;\n#[cfg(test)]\nuse test_browser as browser;\n#[cfg(not(test))]\nuse crate::browser;\n```", "```rs\nuse anyhow::{anyhow, Result};\nuse wasm_bindgen::JsValue;\nuse web_sys::HtmlElement;\npub fn draw_ui(html: &str) -> Result<()> {\n    Ok(())\n}\npub fn hide_ui() -> Result<()> {\n    Ok(())\n}\npub fn find_html_element_by_id(id: &str) -> Result<HtmlElement> {\n    Err(anyhow!(\"Not implemented yet!\"))\n}\npub async fn fetch_json(json_path: &str) -> Result<JsValue> {\n    Err(anyhow!(\"Not implemented yet!\"))\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use futures::channel::mpsc::unbounded;\n    use std::collections::HashMap;\n    use web_sys::{AudioBuffer, AudioBufferOptions};\n    fn test_transition_from_game_over_to_new_game() {\n        let (_, receiver) = unbounded();\n        let image = HtmlImageElement::new().unwrap();\n        let audio = Audio::new().unwrap();\n        let options = AudioBufferOptions::new(1, 3000.0);\n        let sound = Sound {\n            buffer: AudioBuffer::new(&options).unwrap(),\n        };\n        let rhb = RedHatBoy::new(\n            Sheet {\n                frames: HashMap::new(),\n            },\n            image.clone(),\n            audio,\n            sound,\n        );\n        let sprite_sheet = SpriteSheet::new(\n            Sheet {\n                frames: HashMap::new(),\n            },\n            image.clone(),\n        );\n        let walk = Walk {\n            boy: rhb,\n            backgrounds: [\n                Image::new(image.clone(), Point { x: 0, y: \n                  0 }),\n                Image::new(image.clone(), Point { x: 0, y: \n                  0 }),\n            ],\n            obstacles: vec![],\n            obstacle_sheet: Rc::new(sprite_sheet),\n            stone: image.clone(),\n            timeline: 0,\n        };\n        let state = WalkTheDogState {\n            _state: GameOver {\n                new_game_event: receiver,\n            },\n            walk: walk,\n        };\n    }\n}\n```", "```rs\nthread 'game::tests::test_transition_from_game_over_to_new_game' panicked at 'cannot call wasm-bindgen imported functions on non-wasm targets', /Users/eric/.cargo/registry/src/github.com-1ecc6299db9ec823/web-sys-0.3.52/src/features/gen_HtmlImageElement.rs:4:1\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use futures::channel::mpsc::unbounded;\n    use std::collections::HashMap;\n    use web_sys::{AudioBuffer, AudioBufferOptions};\n    use wasm_bindgen_test::wasm_bindgen_test;\n    wasm_bindgen_test::wasm_bindgen_test_configure!\n        (run_in_browser);\n    #[wasm_bindgen_test]\n    fn test_transition_from_game_over_to_new_game() {\n        ...\n```", "```rs\nrunning 1 test\ntest rust_webpack_template::game::tests::test_transition_from_game_over_to_new_game … ok\n```", "```rs\n#[wasm_bindgen_test]\nfn test_transition_from_game_over_to_new_game() {\n    ...\n    let document = browser::document().unwrap();\n    document\n        .body()\n        .unwrap()\n       .insert_adjacent_html(\"afterbegin\", \"<div \n            id='ui'></div>\")\n        .unwrap();\n    browser::draw_ui(\"<p>This is the UI</p>\").unwrap();\n    let state = WalkTheDogState {\n        _state: GameOver {\n            new_game_event: receiver,\n        },\n        walk: walk,\n    };\n    state.new_game();\n    let ui =  \n        browser::find_html_element_by_id(\"ui\").unwrap();\n    assert_eq!(ui.child_element_count(), 0);\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use wasm_bindgen_test::wasm_bindgen_test;\n    wasm_bindgen_test::wasm_bindgen_test_configure!\n        (run_in_browser);\n    #[wasm_bindgen_test]\n    async fn test_error_loading_json() {\n        let json = fetch_json(\"not_there.json\").await;\n        assert_eq!(json.is_err(), true);\n    }\n}\n```", "```rs\nimpl WalkTheDogStateMachine {\n    fn update(self, keystate: &KeyState) -> Self {\n        log!(\"Keystate is {:#?}\", keystate);\n        match self {\n            WalkTheDogStateMachine::Ready(state) => \n                state.update(keystate),\n            WalkTheDogStateMachine::Walking(state) => \n                state.update(keystate),\n            WalkTheDogStateMachine::GameOver(state) => \n               state.update(),\n        }\n    }\n```", "```rs\n#[derive(Debug)]\npub struct KeyState {\n    pressed_keys: HashMap<String, web_sys::KeyboardEvent>,\n}\n```", "```rs\nmacro_rules! error {\n    ( $( $t:tt )* ) => {\n        web_sys::console::error_1(&format!( $( $t )* \n            ).into());\n    }\n}\n```", "```rs\nwarning: unused `std::result::Result` that must be used\n   --> src/game.rs:241:9\n    |\n241 |         browser::hide_ui();\n    |         ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_must_use)]` on by default\n    = note: this `Result` may be an `Err` variant, which should be handled\n```", "```rs\nimpl WalkTheDogState<GameOver> {\n    ...\n    fn new_game(self) -> WalkTheDogState<Ready> {\n        if let Err(err) = browser::hide_ui() {\n            error!(\"Error hiding the browser {:#?}\", err);\n        }\n        WalkTheDogState {\n            _state: Ready,\n            walk: Walk::reset(self.walk),\n        }\n    }\n}\n```", "```rs\nwarning: associated function is never used: `draw_rect`\n   --> src/engine.rs:106:12\n    |\n106 |     pub fn draw_rect(&self, bounding_box: &Rect) {\n    |            ^^^^^^^^^\n    |\n    = note: `#[warn(dead_code)]` on by default\n```", "```rs\nimpl Renderer {\n    ...\n    #[allow(dead_code)]\n    pub fn draw_rect(&self, bounding_box: &Rect) {\n```", "```rs\nrustup component add clippy\n```", "```rs\nwarning: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n   --> src/game.rs:945:29\n    |\n945 | fn rightmost(obstacle_list: &Vec<Box<dyn Obstacle>>) -> i16 {\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `&[Box<dyn Obstacle>]`\n    |\n    = note: `#[warn(clippy::ptr_arg)]` on by default\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n```", "```rs\nfn rightmost(obstacle_list: &[Box<dyn Obstacle>]) -> i16 {\n```", "```rs\nwarning: match expression looks like `matches!` macro\n   --> src/game.rs:533:9\n    |\n533 | /         match self {\n534 | |             RedHatBoyStateMachine::KnockedOut(_) => true,\n535 | |             _ => false,\n536 | |         }\n    | |_________^ help: try this: `matches!(self, RedHatBoyStateMachine::KnockedOut(_))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n```", "```rs\nimpl RedHatBoyStateMachine {\n    ...\n    fn knocked_out(&self) -> bool {\n        matches!(self, RedHatBoyStateMachine::KnockedOut(_))\n    }\n```", "```rs\nimpl Renderer {\n    ...\n    #[allow(dead_code)]\n    pub fn draw_text(&self, text: &str, location: &Point) -> Result<()> {\n        self.context.set_font(\"16pt serif\");\n        self.context\n            .fill_text(text, location.x.into(), \n                location.y.into())\n            .map_err(|err| anyhow!(\"Error filling text \n                {:#?}\", err))?;\n        Ok(())\n    }\n}\n```", "```rs\nunsafe fn draw_frame_rate(renderer: &Renderer, frame_time: f64) {\n    static mut FRAMES_COUNTED: i32 = 0;\n    static mut TOTAL_FRAME_TIME: f64 = 0.0;\n    static mut FRAME_RATE: i32 = 0;\n    FRAMES_COUNTED += 1;\n    TOTAL_FRAME_TIME += frame_time;\n    if TOTAL_FRAME_TIME > 1000.0 {\n        FRAME_RATE = FRAMES_COUNTED;\n        TOTAL_FRAME_TIME = 0.0;\n        FRAMES_COUNTED = 0;\n    }\n    if let Err(err) = renderer.draw_text(\n        &format!(\"Frame Rate {}\", FRAME_RATE),\n        &Point { x: 400, y: 100 },\n    ) {\n        error!(\"Could not draw text {:#?}\", err);\n    }\n}\n```", "```rs\nimpl GameLoop {\n    pub async fn start(game: impl Game + 'static) -> Result<()> {\n        ...\n        *g.borrow_mut() = Some(browser::create_raf_closure\n             (move |perf: f64| {\n            process_input(&mut keystate, &mut \n                keyevent_receiver);\n            let frame_time = perf - game_loop.last_frame;\n            game_loop.accumulated_delta += frame_time as \n                f32;\n            while game_loop.accumulated_delta > FRAME_SIZE {\n                game.update(&keystate);\n                game_loop.accumulated_delta -= FRAME_SIZE;\n            }\n            game_loop.last_frame = perf;\n            game.draw(&renderer);\n            if cfg!(debug_assertions) {\n                unsafe {\n                    draw_frame_rate(&renderer, frame_time);\n                }\n            }\n            ...\n```", "```rs\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>My Rust + Webpack project!</title>\n  <link rel=\"stylesheet\" href=\"styles.css\" type=\"text/css\" \n      media=\n  \"screen\">\n  <link rel=\"preload\" as=\"image\" href=\"Button.svg\">\n  <link rel=\"preload\" as=\"font\" href=\n  \"kenney_future_narrow-webfont.woff2\">\n</head>\n```"]