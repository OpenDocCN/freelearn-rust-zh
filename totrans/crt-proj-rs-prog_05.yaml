- en: Creating a Client-Side WebAssembly App Using Yew
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will see how Rust can be used to build the frontend of
    a web application, as an alternative to using HTML, CSS, and JavaScript (typically
    using a JavaScript frontend framework, such as React) or another language generating
    JavaScript code (such as Elm or TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: To build a Rust app for a web browser, the Rust code must be translated to WebAssembly
    code, which can be supported by all modern web browsers. The capability to translate
    Rust code into WebAssembly code is now included in the stable Rust compiler.
  prefs: []
  type: TYPE_NORMAL
- en: To develop large projects, a web frontend framework is needed. In this chapter,
    the Yew framework will be presented. It is a framework that supports the development
    of frontend web applications, using the **Model-View-Controller** (**MVC**)architectural
    pattern, and generating WebAssembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MVC architectural pattern and its usage in web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building WebAssembly apps using the Yew framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Yew crate to create web pages designed with the MVC pattern (`incr`
    and `adder`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web app having several pages with a common header and footer (`login` and `yauth`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web app having both a frontend and a backend, in two distinct projects
    (`yclient` and `persons_db`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend is developed using Yew, and the backend, which is an HTTP RESTful
    service, is developed using Actix web.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes you have already read the previous chapters, also, prior
    knowledge of HTML is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the projects in this chapter, it is enough to install the generator
    of WebAssembly code (Wasm, for short). Probably the simplest way to do this is
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After 13 minutes, your Cargo tool will be enriched by several commands. A few
    of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo web build` (or `cargo-web build`): It builds Rust projects designed
    to run in a web browser. It is similar to the `cargo build` command, but for Wasm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cargo web start` (or `cargo-web start`): It performs a `cargo web build` command,
    and then starts a web server where every time it is visited by a client, it sends
    a complete Wasm frontend app to the client. It is similar to the `cargo run` command,
    but for serving Wasm apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete source code for this chapter is in the `Chapter05` folder of the
    repository at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/Rust-2018-Projects)[Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Wasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wasm is a powerful new technology to deliver interactive applications. Before
    the advent of the web, there were already many developers building client/server
    applications, where the client apps ran on a PC (typically with Microsoft Windows)
    and the server apps ran on a company-owned system (typically with NetWare, OS/2,
    Windows NT, or Unix). In such systems, developers could choose their favorite
    language for the client app. Some people used Visual Basic, others used FoxPro
    or Delphi, and many other languages were in wide use.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for such systems, the deployment of updates was a kind of hell, because
    of several possible issues, such as ensuring that every client PC had the proper
    runtime system and that all clients got the updates at the same time. These problems
    were solved by JavaScript running in web browsers, as it is a ubiquitous platform
    on which frontend software could be downloaded and executed. This had some drawbacks
    though: developers were forced to use HTML + CSS + JavaScript to develop frontend software,
    and sometimes such software had poor performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Here comes Wasm, which is a machine-language-like programming language, like
    Java bytecode or Microsoft .NET CIL code, but it is a standard accepted by all
    major web browsers. Version 1.0 of its specification appeared in October 2017,
    and in 2019 it appears that already more than 80% of web browsers running in the
    world support it. This means that it can be more efficient and that it can be
    rather easily generated from several programming languages, including Rust.
  prefs: []
  type: TYPE_NORMAL
- en: So, if Wasm is set as the target architecture of the Rust compiler, a program
    written in Rust can be run on any major modern web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MVC architectural pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about creating web apps. So, to make things more concrete, let's
    look straight away at two toy web applications named `incr` and `adder`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing two toy web apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the first toy application, let''s take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go into the `incr` folder and type `cargo web start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a few minutes, a message will appear on the console, ending with the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the address box of a web browser, type: `127.0.0.1:8000` or `localhost:8000`,
    and immediately you will see the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c46a2847-2d66-493e-8ca1-7ad985362d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the two buttons, or select the following textbox and then press the
    *+* or the *0* keys on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click once on the Increment button, the contents of the box to the right
    change from 0 to 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click another time, it changes to 2, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click on the Reset button, the value changes to 0 (zero).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select the textbox by clicking on it and then press the *+* key, you
    increment the number like the Increment button does. Instead, if you press the
    *0* key, the number is set to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop the server, go to the console and press *Ctrl *+ *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the `adder` app, go into the `adder` folder and type `cargo web start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, for the other app, when the server app has started, you can refresh
    your web browser page and you will see the following page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/453816c4-97e3-48da-9d8d-2aa92aab4a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can insert a number in the first box, to the right of the Addend
    1 label, another number in the second box, and then press the Add button. After
    that, you will see the sum of those numbers in the textbox at the bottom, which
    has turned from yellow to light green, as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c8ac8a3-0f08-45ce-9ef6-b399beeedd28.png)'
  prefs: []
  type: TYPE_IMG
- en: After the addition, the Add button has become disabled. If one of the first
    two boxes is empty, the sum fails and nothing happens. Also, if you change the
    value of any of the two first boxes, the Add button becomes enabled, and the last
    textbox becomes empty and yellow.
  prefs: []
  type: TYPE_NORMAL
- en: What is the MVC pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen some very simple web applications, we can explain what
    the MVC architectural pattern is using these apps as an example. The MVC pattern
    is an architecture regarding event-driven interactive programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what event-driven interactiveprograms are. The word **interactive**
    is the opposite of **batch**. A batch program is a program in which the user prepares
    all the input at the beginning, and then the program runs without asking for further
    input. Instead, an interactive program has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for some actions from the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user acts on an input device, the program processes the related input,
    and then goes to the preceding step, to wait for further input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, console command interpreters are interactive programs, and all
    web apps are interactive too.
  prefs: []
  type: TYPE_NORMAL
- en: The phrase *event-driven* means that the application, after initialization,
    does nothing until the user performs something on the user interface. When the
    user acts on an input device, the app processes such inputs and updates the screen
    only as a reaction to the user input. Most web applications are event-driven.
    The main exceptions are games and virtual reality or augmented reality environments,
    where animations go on even if the user does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Our examples in this chapter are all event-driven interactive programs, as after
    initialization, they do something only when the user clicks with the mouse (or
    touches the touchscreen) or presses any key on the keyboard. Some such clicks
    and key presses cause a change on the screen. Therefore, the MVC architecture
    can be applied to these example projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are several dialects of this pattern. The one used by Yew derives from
    the one implemented by the Elm language, and so it is named the **Elm Architecture**.
  prefs: []
  type: TYPE_NORMAL
- en: The model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any MVC program, there is a data structure, named `model`, that contains
    all the dynamic data required to represent the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `incr` app, the value of the number contained in the box
    to the right is required to represent the box, and it can change at runtime. Hence,
    that numeric value must be in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the width and height of the browser window are usually not required to
    generate the HTML code and so they shouldn''t be a part of the model. Also, the
    sizes and texts of the buttons shouldn''t be a part of the model, but for another
    reason: they cannot change at runtime in this app. Though, if it were an internationalized
    app, all the texts should be in the model too.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `adder` app, the model should contain only the three values contained
    in the three textboxes. It doesn't matter that two of them are directly inputted
    by the user and the third one is calculated. The labels and the background color
    of the textboxes shouldn't be a part of the model.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next portion of the MVC architecture is the **view**. It is a specification
    of how to represent (or render) the graphical contents of the screen, depending
    on the value of the model. It can be a declarative specification, such as pure
    HTML code, or a procedural specification, such as some JavaScript or Rust code,
    or a mix of them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `incr` app, the view shows two push-buttons and one read-only
    textbox, whereas, in the `adder` app, the view shows three labels, three textboxes,
    and one push-button.
  prefs: []
  type: TYPE_NORMAL
- en: All the shown push-buttons have a constant appearance, but the views must change
    the display of the numbers when the models change.
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last portion of the MVC architecture is the *controller*. It is always a
    routine or a set of routines that are invoked by the view when the user, using
    an input device, interacts with the app. When a user performs an action with an
    input device, all the view has to do is to notify the controller that the user
    has performed that action, specifying which action (for example, which mouse key
    has been pressed), and where (for example, in which position of the screen).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `incr` app, the three possible input actions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A click on the Increment button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A click on the Reset button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A press of a key on the keyboard when the textbox is selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, it is also possible to press a push-button using the keyboard, but
    such an action can be considered equivalent to a mouse click, and so a single
    input action type is notified for each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `adder` app, the three possible input actions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A change of the value in the Addend 1 textbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change of the value in the Addend 2 textbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A click on the Add button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to change the value of a textbox in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By typing when no text is selected, inserting additional characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By typing when some text is selected, and so replacing the selected text with
    a character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By pasting some text from the clipboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By dragging and dropping some text from another element of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the mouse on the up-down spinner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not interested in these, because they are handled by the browser or by
    the framework. All that matters for application code is that when the user performs
    an input action, a textbox changes its value.
  prefs: []
  type: TYPE_NORMAL
- en: The job of the controller is just to use such input information to update the
    model. When the model is completely updated, the framework notifies the view about
    the need to refresh the look of the screen, taking into account the new values
    of the model.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `incr`app, the controller, when it is notified of the pressing
    of the Increment button, increments the number contained in the model; when it
    is notified of the pressing of the Reset button, it sets to zero that number in
    the model; when it is notified of the pressing of a key on the textbox, it checks
    whether the pressed key is *+*, or *0*, or something else, and the appropriate
    change is applied to the model. After such changes, the view is notified to update
    the display of such a number.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `adder` app, the controller, when it is notified of the change
    of the Addend 1 textbox, updates the model with the new value contained in the
    edit box. Similar behavior happens for the Addend 2 textbox; and when the controller
    is notified of the pressing of the Add button, it adds the two addends contained
    in the model and stores the result in the third field of the model. After such
    changes, the view is notified to update the display of such a result.
  prefs: []
  type: TYPE_NORMAL
- en: View implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regarding web pages, the representation of pages is usually made up of HTML
    code, and so, using the Yew framework, the view function must generate HTML code.
    Such generations contain in themselves the constant portions of HTML code, but
    they also access the model to get the information that can change at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the `incr` app, the view composes the HTML code that defines two buttons
    and one read-only numeric *input* element and puts in such an *input* element
    the value taken from the model. The view includes the handling of the HTML *click* events
    on the two buttons by forwarding them to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: In the `adder` app, the view composes the HTML code that defines three labels,
    three numeric input elements, and one button, and puts in the last *input* element
    the value taken from the model. It includes the handling of the HTML *input* events
    in the first two textboxes and the *click* event on the button, by forwarding
    them to the controller. Regarding the first two textbox events, the values contained
    in the boxes are forwarded to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Controller implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Yew, the controller is implemented by an *update* routine, which processes
    the messages regarding user actions coming from the view and uses such input to
    change the model. After the controller has completed all the required changes
    to the model, the view must be notified to apply the changes of the model to the
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some frameworks, such as in Yew, such an invocation of the view is automatic;
    that mechanism has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For any user action handled by the view, the framework calls the `update` function,
    that is, the controller. In this call, the framework passes to the controller
    the details regarding the user action; for example, which value has been typed
    in a textbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller, typically, changes the state of the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the controller has successfully applied some changes to the model, the framework
    calls the view function, which is the *view* of the MVC architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the MVC architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general flow of control of the MVC architecture is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1ea5bec-c3d3-43d2-963f-a0a3f4c54ed9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The iteration of every user action is this sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The user sees a static representation of graphical elements on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user acts on the graphical elements using an input device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view receives a user action and notifies the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller updates the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view reads the new state of the model to update the contents of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user sees the new state of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main concepts of the MVC architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All the mutable data that is needed to correctly build the display must be in
    a single data structure, named **model**. The model may be associated with some
    code, but such code does not get direct user input, nor does it give output to
    the user. It may access files, databases, or other processes, though. Because
    the model does not interact directly with the user interface, the code implementing
    the model shouldn't change if the application user interface is ported from text
    mode to GUI/web/mobile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logic that draws on the display and captures user input is named the *view*.
    The view, of course, must know about screen rendering, input devices and events,
    and also about the model. Though, the view just *reads* the model, it never changes
    it directly. When an interesting event happens, the view notifies the controller
    of that event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the controller is notified of an interesting event by the view, it changes
    the model accordingly, and when it has finished, the framework notifies the view
    to refresh itself using the new state of the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will present four projects that will get more and more complex.
    You have already seen the first two projects in action: `incr` and `adder`. The
    third project, named `login`, shows how to create a login page for authentication
    on a website.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth project, named `yauth,` extends the `login` project adding the CRUD
    handling of a list of persons. Its behavior is almost identical to that of the
    `auth` project in [Chapter 4](27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml), *Creating
    a Full Server-Side Web App*. Each project will require from 1 to 3 minutes to
    download and compile from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start all the machinery, a very simple statement is enough – the body of
    the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It creates a web app based on the specified `Model`, starts it, and waits on
    the default TCP port. Of course, the TCP port can be changed. It is a server that
    will serve the app to any browser navigating to it.
  prefs: []
  type: TYPE_NORMAL
- en: The incr app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we''ll see the implementation of the `incr` project, which we already
    saw how to build and use. The only dependency is on the Yew framework, and so,
    the TOML file contains the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the source code is in the `main.rs` file. The model is implemented by the
    following simple declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It just has to be a struct that will be instantiated by the framework, read
    by the view, and read and written by the controller. Its name and the name of
    its fields are arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the possible notifications from the view to the controller must be declared
    as an `enum` type. Here is that of `incr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here, the names are arbitrary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Msg` is short for *message*, as such notifications are in a sense messages
    from the view to the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Increment` message notifies a click on the Increment button.The `Reset`
    message notifies a click on the Reset button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `KeyDown` message notifies a press of any key on the keyboard; its argument
    communicates which key has been pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the controller, the `yew::Component` trait must be implemented
    for our model. The code for our project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The required implementations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message`: It is the `enum` defined before, describing all possible notifications
    from the view to the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Properties`: It is not used in this project. When not used, it must be an
    empty tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`: It is invoked by the framework to let the controller initialize the
    model. It can use two arguments, but here we are not interested in them, and it
    must return an instance of the model with its initial value. As we want to show
    the number zero at the beginning, we set `value` to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: It is invoked by the framework any time the user acts on the page
    in some way handled by the view. The two arguments are the mutable model itself
    (`self`) and the notification from the view (`msg`). This method should return
    a value of type `ShouldRender`, but a `bool` value will be good. Returning `true` means
    that the model has been changed, and so a refresh of the view is required. Returning
    `false` means that the model has not been changed, and so a refresh of the view
    would be a waste of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `update` method contains a `match` on the message type. The first two message
    types are quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the `Increment` message is notified, the value is incremented. If the `Reset` message
    is notified, the value is zeroed. In both cases, the view must be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handling of the keypress is a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `KeyDown` match arm assigns the key pressed to the `s` variable. As we are
    interested only in two possible keys, there is a nested `match` statement on the `s`
    variable. For the two-handled keys (`+` and `0`), the model is updated, and `true`
    is returned to refresh the view. For any other key pressed, nothing is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the view part of MVC, the `yew::Renderable` trait must be implemented
    for our model. The only required method is `view`, which gets an immutable reference
    to the model, and returns an object that represents some HTML code, but that is
    capable of reading the model and notifying the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of such a method is constructed with the powerful `yew::html` macro.
    Here is the body of such a macro invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks very similar to the actual HTML code. It is equivalent to the following
    HTML pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that at any HTML event, in the HTML pseudo-code, a JavaScript function
    is invoked (here, named `notify`). Instead, in Rust, there is a closure that returns
    a message for the controller. Such a message must have the arguments of the appropriate
    type. While the `onclick` event has no arguments, the `onkeydown` event has one
    argument, captured in the `e` variable, and by calling the `key` method on that
    argument, the pressed key is passed to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice in the HTML pseudo-code the `[value]` symbol, which at runtime will
    be replaced by an actual value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, notice that the body of the macro has three features that differentiate
    it from HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: All the arguments of HTML elements must end with a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any Rust expression can be evaluated inside HTML code, as long as it is enclosed
    in braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal strings are not allowed in this HTML code, so they must be inserted
    as Rust literals (by including them in braces).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The adder app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we'll see the implementation of the `adder` project, which we already
    saw how to build and use. Only that which differentiates it from the `incr` project
    will be examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there is a problem with the `html` macro expansion recursion
    level. It is so deep that it must be increased using the following directives
    at the beginning of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Without them, a compilation error is generated. With more complex views, an
    even larger limit is required. The model contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'They represent the following, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: The text inserted in the first box (`addend1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text inserted in the second box (`addend2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number calculated and to be displayed in the third box, if the calculation
    was performed and was successful, or nothing otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The handled events (that is, the messages) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'They represent the following, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Any change to the contents of the first box, with the new value contained in
    the box (`ChangedAddend1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change to the contents of the second box, with its value (`ChangedAddend2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A click on the Add button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `create` function initializes the three fields of the model: the two addends
    are set to empty strings, and the `sum` field is set to `None`. With these initial
    values, no number is displayed in the Sum textbox.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` function processes the three possible messages. For the `ComputeSum`
    message, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `addend1` and `addend2` fields of the model are parsed to convert them into
    numbers. If both conversions are successful, the first arm matches, and so the
    `a1` and `a2` values are added, and their sum is assigned to the `sum` field.
    If some conversion fails, `None` is assigned to the sum field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arm regarding the first addend is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The current value of the textbox is assigned to the `addend1` field of the model,
    and the `sum` field is set to `None`. Similar behavior is performed for a change
    to the other addend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the most interesting parts of the `view` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It assigns to a Rust variable a snippet of CSS code. Then, the textbox for
    the first `addend` is created by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that to the `style` attribute, the value of the `numeric` variable is
    assigned. The values of these attributes are just Rust expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sum` textbox is created by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `style` attribute is composed by concatenating the `numeric` string seen
    before with the background color. Such a color is light green if `sum` has a numeric
    value, or yellow if it is `None`. Also, the `value` attribute is assigned using
    an expression, to assign an empty string if `sum` is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The login app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that an app contains just one model struct, one `enum`
    of messages, one `create` function, one `update` method, and one `view` method.
    This is good for very simple apps, but with more complex apps, this simple architecture
    becomes unwieldy. There is a need to separate different portions of the app in
    different components, where each component is designed with the MVC pattern and
    so it has its own model, controller, and view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, but not necessarily, there is a general component that contains
    the portions of the app that remain the same for all of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: A header with a logo, a menu, and the name of the current user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A footer containing copyright information and contact information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And then in the middle of the page, there is the inner part (also named the *body*,
    although it is not the `body` HTML element). This inner part contains the real
    information of the app and is one of many possible components or forms (or pages):'
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the `login` app by typing `cargo web start` in its folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When navigating to `localhost:8000`, the following page appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd6d7092-fd8e-49fe-a4db-bb6c4c68ab50.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two horizontal lines. The part above the first line is meant to be
    a header, which must remain for the whole app. The part underneath the second
    line is meant to be a footer, which must remain for the whole app, too. The median
    part is the `Login` component, which appears only when the user must be authenticated.
    This portion will be replaced by other components when the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see some authentication failures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on Log in straightaway, a message box appears saying: User not
    found. The same happens if you type some random characters in the User name textbox.
    The only allowed user names are `susan` and `joe`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you insert one of the two allowed user names, and then you click on Log in,
    you get the message Invalid password for the specified user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same happens if you type some random characters in the Password textbox.
    The only allowed passwords are `xsusan` for the user `susan`, and `xjoe` for the
    user `joe`. If you type `susan` and then `xsusan`, just before clicking on Log
    in, you will see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/18689f3c-6ab5-4d13-bcdb-802598f81924.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And just after, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd96a096-7cb2-475f-80a2-f4b36a4cf74f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Three things have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: At the right of the label—Current user—the blue text --- has been replaced by
    susan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the right of that blue text, the Change User button has appeared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between the two horizontal lines, all the HTML elements have been replaced by
    the large text reading Page to be implemented. Of course, this situation would
    represent a case in which the user has been successfully authenticated and is
    using the rest of the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you were to click the Change User button, you will get the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29b734ef-1c56-496b-89ba-712832a89eab.png)'
  prefs: []
  type: TYPE_IMG
- en: It is similar to the first page, but the name susan appears both as Current
    user, and as User name.
  prefs: []
  type: TYPE_NORMAL
- en: Organization of the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code of this project has been split into three files (which you
    will find in the book''s GitHub repository at `Chapter05/login/src/db_access.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db_access.rs`: Contains a stub of a user directory to handle authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.rs`: Contains the one-line `main` function, and an MVC component that
    handles the header and the footer of the page, and delegates the inner section
    to the authentication component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login.rs`: Contains the MVC component to handle the authentication, to be
    used as an inner section of the main component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The db_access.rs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `db_access` module is a subset of that of the previous chapter. It declares
    a `DbConnection` struct that simulates a connection to a database. Actually, for
    simplicity, it contains just `Vec<User>`, where `User` is an account of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `User` type is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Any user of the app has a name, a password, and some privileges. In this simple
    system, there are only two possible privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanRead`, which means that the user can read all of the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanWrite`, which means that the user can change all of the database (that
    is, inserting, updating, and deleting records)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two users are wired in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`joe` with the password `xjoe`, capable only of reading from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`susan` with the password `xsusan`, capable of reading and writing the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new`, to create a `DbConnection`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`get_user_by_username`, to get a reference to the user having the specified
    name, or `None` if there is no user with that name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Of course, first, we will create a `DbConnection` object, using the `new` function,
    and then we will get a `User` from that object, using the `get_user_by_username` method.
  prefs: []
  type: TYPE_NORMAL
- en: The main.rs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main.rs` file begins with the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration imports the `login` module, which will be referenced by
    the `main` module. Any inner section module must be imported here.
  prefs: []
  type: TYPE_NORMAL
- en: The second statement declares all the components that will be used as inner
    sections. Here, we have only the authentication component (`Login`) and a component
    that is not yet implemented (`PersonsList`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the model of the MVC component of the main page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convention, the name of any model ends with `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first field of the model is the most important one. It represents which
    inner section (or `page`) is currently active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other fields contain global information, that is, information useful for
    displaying the header, the footer, or that must be shared with the inner components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `current_user` field contains the name of the logged-in user, or `None` if
    no user is logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` flag is a simplistic description of user privileges; here, both
    users can read, but only one can also write, and so this flag is `true` when they
    are logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field is a reference to the database stub. It must be shared
    with an inner component, and so it is implemented as a reference-counted smart
    pointer to `RefCell`, containing the actual `DbConnection`. Using this wrapping,
    any object can be shared with other components, as long as one thread at a time
    accesses them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible notifications from the view to the controller are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the footer has no elements that can get input, and for the header,
    there is only the Change User button that can get input, when it is visible. By
    pressing such a button, the `ChangeUserPressed` message is sent.
  prefs: []
  type: TYPE_NORMAL
- en: So, it appears there is no way to send the `LoggedIn` message! Actually, the
    `Login` component can send it to the main component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function of the controller has the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the `Login` component notifies the main component of successful authentication,
    thus specifying the authenticated user, the main controller sets `PersonsList` as
    the page to go to, saves the name of the newly authenticated user, and extracts
    the privileges from that user.
  prefs: []
  type: TYPE_NORMAL
- en: When the Change User button is clicked, the *page to go to* becomes the `Login`
    page. The `view` method contains just an invocation of the `html` macro. Such
    a macro must contain one HTML element, and in this case, it is a `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'That `div` element contains three HTML elements: a `style` element, a `header`
    element, and a `footer` element. But between the header and the footer, there
    is some Rust code to create the inner section of the main page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert Rust code inside an `html` macro, there are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes of HTML elements are just Rust code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any point, a pair of braces encloses Rust code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, the evaluation of such Rust code must return a value convertible
    to a string through the `Display` trait.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, the evaluation of the Rust code in braces must return an
    HTML element. And how can you return an HTML element from Rust code? Using an
    `html` macro!
  prefs: []
  type: TYPE_NORMAL
- en: So, the Rust code that implements the `view` method contains an `html` macro
    invocation that contains a block of Rust code, which contains an `html` macro
    invocation, and so on. This recursion is performed at compile time and has a limit
    that can be overridden using the `recursion_limit` Rust attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the header and the inner section contain a `match self.page`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: In the header, it is used to show the Change User button only if the current
    page is not the login page, for which it would be pointless.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the inner section, the body of such a statement is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current page is `Login`, an invocation to the `html` macro contains
    the `LoginModel:` HTML element. Actually, the HTML language doesn''t have such
    an element type. This is the way to embed another Yew component in the current
    component. The `LoginModel` component is declared in the `login.rs` source file.
    Its construction requires some arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current_username` is the name of the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when_logged_in` is a callback that the component should invoke when it has
    performed a successful authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db_connection` is a (reference-counted) copy of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the callback, notice that it receives a user (`u`) as an argument
    and returns the message `LoggedIn` decorated by that user. Sending this message
    to the controller of the main component is the way the `Login` component communicates
    to the main component who the user is that has just logged in.
  prefs: []
  type: TYPE_NORMAL
- en: The login.rs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `login` module begins by defining the model of the `Login` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This model must be used by the main component, and so it must be public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialog` is a reference to a Yew service, which is a way to ask the framework
    to do something more than implementing the MVC architecture. A dialog service
    is the ability to show message boxes to the user, through the JavaScript engine
    of the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username` and `password` are the values of the text that the user has typed
    in the two textboxes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when_logged_in` is a possible callback function, to call when a successful
    authentication is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db_connection` is a reference to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible notification messages are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first two messages mean that the respective fields have changed values,
    and the third message says that the push-button has been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen that this component has a model and some messages, like
    the components we saw before; but now we''ll see that it also has something that
    we''ve never seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure represents the arguments that every parent of this component
    must pass to create the component. In this project, there is only one parent of
    the `Login` component, that is, the main component, and that component created
    a `LoginModel`: element having the fields of `LoginProps` as attributes. Notice
    that all the fields are specializations of `Option`: it is required by the Yew
    framework, even if you don''t pass an `Option` as an attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `LoginProps` type must be used in four points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it must implement the `Default` trait, to ensure its fields are properly
    initialized when the framework needs an object of this type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we already saw that the implementation of the `Component` trait for
    the model has to define a `Properties` type. In this case, it must be like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That is, this type is passed into the implementation of the `Component` trait
    for the `LoginModel` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, the `create` function must use its first argument, containing the values
    passed in by the parent component. Here is that function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: All the fields of the model are initialized, but while the `dialog` and `password`
    fields receive default values, the other fields receive a value from the `props`
    object received from the parent component, that is, `MainModel`. As we are sure
    that the `db_connection` field of `props` will be `None`, we call `unwrap` for
    it. Instead, the `current_username` field may be `None`, and so, in that case,
    an empty string is used.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the `update` function, which is the controller of the `Login`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user presses the Log in button, the following code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The connection to the database is extracted from `RefCell` using the `borrow`
    method, and then the user with the current name is looked for. If the user is
    found, and if their stored password is the same as that typed by the user, the
    callback kept in the `when_logged_in` field is extracted, and then its `emit` method
    is invoked, passing a copy of the user name as argument. So, the routine passed
    by the parent, that is, the `|u| MainMsg::LoggedIn(u)` closure, is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of a missing user or mismatching password, a message box is displayed
    using the `alert` method of the dialog service. The controllers that we saw before
    had just two functions: `create` and `update`. This one has another function,
    though; it is the `change` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This method allows the parent to re-send to this component updated arguments
    using the `Properties` structure. The `create` method is invoked just one time,
    while the `change` method is invoked any time the parent will need to update the
    arguments to pass to the child component.
  prefs: []
  type: TYPE_NORMAL
- en: The view is easy to understand by reading its code and does not require explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The yauth app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `login` app, presented in the previous section, showed how to create a parent
    component containing one of several possible child components. However, it implemented
    just one child component, the `Login` component. So, in this section, a more complete
    example will be presented, having three different possible child components, corresponding
    to three different pages of a classical web application.
  prefs: []
  type: TYPE_NORMAL
- en: It is named `yauth`, short for **Yew Auth**, as its behavior is almost identical
    to the `auth` project shown in the previous chapter, although, it is completely
    based on the Yew framework, instead of being based on Actix web and Tera.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the behavior of the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This app is built and launched like the ones in the previous sections, and
    its first page is identical to the first page of the `login` app. Though, if you
    type `susan` as the username and `xsusan` as the password, and then click on the
    Log in button, you''ll see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcccef8b-c1b6-4512-bfe5-60f3d53696f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This page and the other page that you will see in this app, and their behavior,
    are almost identical to those of the `auth` app described in the previous chapter.
    The only differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Any error message is not shown as red text embedded in the page but as a pop-up
    message box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header and the footer are implemented by the main component, and they look
    and behave as already described in the previous section of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we just need to examine the implementation of this app.
  prefs: []
  type: TYPE_NORMAL
- en: Organization of the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code of this project has been split into five files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db_access.rs`: It contains a stub of a connection to a database, providing
    access to a user directory to handle authentication and to a list of persons;
    it actually contains such data as vectors. It is virtually identical to the file
    with the same name in the `auth` project of the previous chapter. The only relevant
    difference is that the `Serialize` trait is not implemented, because it''s not
    required by the Yew framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.rs`: It contains the one-line `main` function, and an MVC component that
    handles the header and the footer of the page, and delegates the inner section
    to one of the other three components of the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login.rs`: It contains the MVC component to handle the authentication. It
    is to be used as an inner section of the main component. It is identical to the
    module having the same name in the `login` project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persons_list.rs`: It contains the MVC component to handle the list of persons.
    It is to be used as an inner section of the main component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`one_person.rs`: It contains the MVC component to view, edit, or insert a single
    person; it is to be used as an inner section of the main component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only discuss the files unique to the `yauth` app, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The persons_list.rs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This file contains the definition of the component to let the user manage the
    list of persons, and so it defines the following struct as a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what each line in the previous code says:'
  prefs: []
  type: TYPE_NORMAL
- en: The `dialog` field contains a service to open message boxes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id_to_find` field contains the value typed by the user in the Id textbox
    if the box contains a number, or `None` otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `name_portion` field contains the value contained in the Name portion:
    textbox. In particular, if that box is empty, this field of the model contains
    an empty string. The `filtered_persons` field contains a list of the persons extracted
    from the database using the specified filter. Initially, the filter specifies
    to extract all the persons whose names contain an empty string. Of course, all
    the persons satisfy that filter, and so all the persons in the database are added
    to this vector, though the database is empty, and so this vector is too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `selected_ids` field contains the IDs of all the listed people whose checkbox
    is set, and so they are selected for further operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` field specifies whether the current user has the privilege to
    modify the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `go_to_one_person_page` field contains the callback to call to pass to the
    page to view/edit/insert a single person. Such a callback function receives one
    argument, which is the person to view/edit, or `None` to open the page to insert
    a new person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field contains a shared reference to the database connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible notifications from the view to the controllers are defined by
    this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we did in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IdChanged` message must be sent when the text in the Id: textbox is changed.
    Its argument is the new text value of the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FindPressed` message must be sent when the Find push-button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PartialNameChanged` message must be sent when the text in the Name portion: textbox
    is changed. Its argument is the new text value of the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FilterPressed` message must be sent when the Filter push-button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DeletePressed` message must be sent when the Delete Selected Persons push-button
    is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AddPressed` message must be sent when the Add New Person push-button is
    clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SelectionToggled` message must be sent when a checkbox in the list of persons
    is toggled (that is, checked or unchecked). Its argument is the ID of the person
    specified by that line of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EditPressed` message must be sent when any Edit push-button in the list
    of persons is clicked. Its argument is the ID of the person specified by that
    line of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the structure of the initialization arguments for the component is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `can_write` field, the main component specifies a simple definition
    of the privileges of the current user. A more complex application could have a
    more complex definition of privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `go_to_one_person_page` field, the main component passes a reference
    to a function, which must be called to go to the page for showing, editing, or
    inserting a single person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `db_connection` field, the main component passes a shared reference
    to the database connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The initialization of the `PersonsListProps` struct by implementing the `Default`
    trait and of the `PersonsListModel` struct by implementing the `Component` trait
    is trivial, except for the `filtered_persons` field. Instead of leaving it as
    an empty vector, it is first set as an empty vector, and then modified by the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why an empty collection wouldn't be good for filtered_persons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time the `PersonsList` page is opened, both from the login page and from
    the `OnePerson` page, the model is initialized by the `create` function, and all
    the user interface elements of the page are initialized using that model.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you type something in the `PersonsList` page, and then you go to another
    page, and then you go back to the `PersonsList` page, everything you typed is
    cleared unless you set it in the `create` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably, the fact that the Id textbox, the Name portion textbox, or the selected
    persons are cleared is not very annoying, but the fact that the list of persons
    is cleared means that you will get the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: You filter the persons to see some persons listed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You click on the Edit button in the row of one person, to change the name of
    that person, and so you go to the `OnePerson` page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You change the name and press the Update button, and so you go back to the `PersonsList`
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You see the text No persons. instead of the list of persons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't see the person that you have just modified in the `OnePerson` page
    anymore. This is inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: To see that person listed, you need to set `filtered_persons` to a value containing
    that person. The solution chosen has been to show all the persons existing in
    the database, and this is performed by calling the `get_persons_by_partial_name("")` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how the `update` method handles the messages from the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `IdChanged` message is received, the following statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It tries to store in the model the value of the textbox, or `None` if the value
    is not convertible to a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `FindPressed` message is received, the following statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Id textbox contained a valid number, another message would be sent recursively:
    it is the `EditPressed` message. Pressing the Find button must have the same behavior
    as pressing the Edit button in the row with the same ID contained in the Id textbox,
    and so the message is forwarded to the same function. If there is no ID in the
    text field, a message box is displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `PartialNameChanged` message is received, the new partial name is
    just saved in the `name_portion` field of the model. When the `FilterPressed`
    message is received, the following statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The connection to the database is encapsulated in a `RefCell` object, which
    is further encapsulated in an `Rc` object. The access inside `Rc` is implicit,
    but to access inside `RefCell`, it is required to call the `borrow` method. Then
    the database is queried to get the list of all the persons whose names contain
    the current name portion. This list is finally assigned to the `filtered_persons`
    field of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `DeletePressed` message is received, the following statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following pop-up box is shown for confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb323eb-f775-451c-b4e4-0c99fd004f03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user clicks on the OK button (or presses *Enter*), then the deletion
    is performed in the following way: a mutable reference is borrowed from the shared
    connection to the database, and for any ID selected through the checkboxes, the
    respective person is deleted from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The closing of the scope releases the borrowing. Then, a recursive call to
    `update` triggers the `FilterPressed` message, whose purpose is to refresh the
    list of persons shown. Finally, the following message box communicates the completion
    of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15d80085-c33a-454d-90a2-d56087596ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `AddPressed` message is received, the following code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, a reference to the `go_to_one_person_page` callback is taken, and then
    it is invoked using the `emit` method. The effect of such an invocation is to
    go to the `OnePerson` page. The argument of `emit` specifies which person will
    be edited on the page. If it is `None`, as in this case, the page is opened in
    insertion mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `SelectionToggled` message is received, it specifies an ID of a person,
    but it does not specify whether that person is to be selected or deselected. So,
    the following code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We want to invert the status of the person on which the user has clicked, that
    is, to select it if it was not selected, and to unselect it if it was selected.
    The `selected_ids` field of the model contains the set of all the selected persons.
    So, if the clicked ID is contained in the set of selected IDs, it is removed from
    this set by calling the `remove` method; otherwise, it is added to the list, by
    calling the `insert` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, when the `EditPressed` message is received (specifying the `id` of
    the person to view/change), the following code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The database is searched for a person with the specified ID. If such a person
    is found, the `go_to_one_person_page` callback is invoked, passing a clone of
    the person found. Otherwise, a message box explains the error. The `change` method
    keeps the fields of the model updated when any property coming from the parent
    component would change.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the view. The messages sent by the view were described when the
    messages were presented. The other interesting aspects of the view are the following
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The Delete Selected Persons button and the Add New Person button have the attribute `disabled=!self.can_write`.
    This enables such commands only if the user has the privilege to change the data.
  prefs: []
  type: TYPE_NORMAL
- en: The `if !self.filtered_persons.is_empty()` clause causes the table of persons
    to be displayed only if there is at least one person filtered. Otherwise, the
    text No persons. is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the table begins and ends with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is the required syntax for generating sequences of HTML elements based
    on an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` keyword is immediately followed by an iterator (in this case, the
    expression `self.filtered_persons.iter()`), followed by the expression `.map(|p|`,
    where `p` is the loop variable. In this way, it is possible to insert into the
    map closure a call to the `html` macro that generates the elements of the sequence.
    In this case, such elements are the lines of the HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: The last noteworthy point is the way to show which persons are selected. Every
    checkbox has the attribute `checked=self.selected_ids.contains(&id),`. The checked
    attribute expects a `bool` value. That expression sets as checked the checkbox
    relative to the persons whose `id` is contained in the list of the selected IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The one_person.rs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file contains the definition of the component to let the user view or edit
    the details of one person or to fill in the details and insert a new person. Of
    course, to view the details of an existing record, such details must be passed
    as arguments to the component; instead, to insert a new person, no data must be
    passed to the component.
  prefs: []
  type: TYPE_NORMAL
- en: This component does not return its changes directly to the parent that created
    it. Such changes are saved to the database, if the user requested that, and the
    parent can retrieve them from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore the model is defined by the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, we understood the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field contains the value contained in the Id textbox if the box contains
    a number, or `None` otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field contains the value contained in the Name textbox. In particular,
    if the box is empty, this field of the model contains an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` field specifies whether the current privileges allow the user
    to change the data or only to see it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is_inserting` field specifies whether this component has received no data,
    to insert a new person into the database, or whether it has received the data
    of a person, to view or edit them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `go_to_persons_list_page` field is a callback with no arguments that must
    be invoked by this component when the user closes this page to go to the page
    to manage the list of persons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field is a shared connection to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, it is pointless to open a page for insertion without allowing the
    user to change the values. So, the possible combinations are the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion mode**: The `id` field is `None`, the `can_write` field is `true`,
    and the `is_inserting` field is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editing mode**: The `id` field is `Some`, the `can_write` field is `true`,
    and the `is_inserting` field is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only mode**: The `id` field is `Some`, the `can_write` field is `false`,
    and the `is_inserting` field is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible notifications from the view to the controller are defined by the
    following `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happened in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user changes the contents of the Name textbox, the `NameChanged` message
    is sent, which also specifies the current contents of that textbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the Insert button or on the Update button, the `SavePressed`
    message is sent. To distinguish between the two buttons, the `is_inserting` field
    can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user presses the Cancel button, the `CancelPressed` message is sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value of the Id textbox can never be changed during the life of this component,
    and so no message is required for it. The data received from the parent is defined
    by the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the following things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field is `None` in case the parent wants to open the page to let the
    user insert a new person, and contains the ID of an existing person in case the
    page is for viewing or editing the data of that person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field is the only changeable data of any person. It is an empty string
    if the page is created for inserting a new person. Otherwise, the parent passes
    the current name of the person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` field specifies whether the user is allowed to change the displayed
    data. This field should be `true` if the `id` field is `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go_to_persons_list_page` is the callback that will activate the `PersonsList`
    component in the parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field is the shared database connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of the module, there is nothing new. The only thing to stress is
    that the use of conditional expressions based on the `can_write` and `is_inserting` flags
    of the model allows having just one component with a mutant view.
  prefs: []
  type: TYPE_NORMAL
- en: A web app accessing a RESTful service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section described a rather complex software architecture, but still
    running only in the user's web browser, after having being served by the site
    where it is installed. This is quite unusual, as most web apps actually communicate
    with some other process. Typically, the same site that provides the frontend app
    also provides a backend service, that is, a web service to let the app access
    shared data residing on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll see a pair of projects that can be downloaded from
    the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yclient`: This is an app quite similar to the `yauth` app. Actually, it is
    developed using Yew and Wasm, and it has the same look and behavior as `yauth`;
    though its data, which is the authorized users and the persons stored in the mock
    database, no longer resides in the app itself, but in another app, which is accessed
    through an HTTP connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persons_db`: This is the RESTful service that provides access to the data
    for the `yclient` app. It is developed using the Actix web framework, as explained
    in the previous chapter. Even this app does not manage a real database, only a
    mock, in-memory database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the system, two commands are required: one to run the frontend provider, `yclient`,
    and one to run the web service, `persons_db`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the frontend provider, go into the `yclient` folder, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After downloading and compiling all the required crates, it will print the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the backend, in another console window, go into the `db_persons` folder
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Both these commands will end by printing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use your web browser and navigate to `localhost:8000`. The app that
    will be opened will be quite similar to both the `yauth` app, shown in the previous
    section, and to the `auth` app, shown in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first see how `persons_db` is organized.
  prefs: []
  type: TYPE_NORMAL
- en: The persons_db app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app uses the Actix web framework, described in the previous two chapters.
    In particular, this project has some features taken from the `json_db` project,
    described in [Chapter 3](febceb22-18dd-437f-bd27-9895aef47384.xhtml), *Creating
    a REST Web Service*, and some from the `auth` project, described in [Chapter 4](27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml),
    *Creating a Full Server-Side Web App*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll see only the new features that haven''t been described so far.
    The `Cargo.toml` file contains the following new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This crate allows the handling of the **Cross-Origin Resource Sharing** (**CORS**)
    checks, usually performed by browsers. When some code running inside a browser
    tries to access an external resource using a network connection, the browser, for
    security reasons, checks whether the addressed host is just the one that provided
    the code that is performing the request. That means that the frontend and the
    backend are actually the same website.
  prefs: []
  type: TYPE_NORMAL
- en: If the check fails, that is, the frontend app is trying to communicate with
    a different site, the browser sends an HTTP request using the `OPTION` method
    to check whether the site agrees to cooperate with that web app on this resource
    sharing. Only if the response to the `OPTION` request allows the required kind
    of access can the original request be forwarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, both the frontend app and the web service run on localhost; though,
    they use different TCP ports: `8000` for the frontend and `8080` for the backend.
    So, they are considered as different origins, and CORS handling is needed. The
    `actix-cors` crate provides features to allow such cross-origin access for backends
    developed using Actix web.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these features is used in the `main` function, as in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This code is a so-called **middleware**, meaning that it will be run for every
    request received by the service, and so it is a piece of software that stays in
    the middle between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `wrap` method is the one to use to add a piece of middleware. This word
    means that the following code must be *around* every handler, possibly filtering
    both requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Such code creates an object of type `Cors` and specifies for it which HTTP methods
    will be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this web service should be clear to those who have learned what
    has already been described about the Actix web framework. It is a RESTful web
    service that accepts requests as URI paths and queries and returns responses as
    JSON bodies, and for which authentication is provided in any request by the basic
    authentication header.
  prefs: []
  type: TYPE_NORMAL
- en: The API has a new route for the `GET` method and the `/authenticate` path, which
    calls the `authenticate` handler, which is used to get a whole user object with
    the list of their privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how `yclient` is organized.
  prefs: []
  type: TYPE_NORMAL
- en: The yclient app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app starts from where the `yauth` app left off. The `yauth` apps contain its
    own in-memory database, while the app described here communicates with the `person_db` web
    service to access its database.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we'll see only the new features, with respect to the `yauth` project.
  prefs: []
  type: TYPE_NORMAL
- en: The imported crates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Cargo.toml` file contains new lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding code, let''s have a look at the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `failure` crate is used to encapsulate communication errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `serde` and `serde_derive` crates are needed to transfer whole objects
    from server to client, using deserialization. In particular, the whole object
    of the types `Person`, `User`, and `DbPrivilege` are transferred in server responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `url` crate is used for encoding information in a URL. In a URL path or
    a URL query, you can easily put only identifiers or integer numbers, such as,
    say, `/person/id/478` or `/persons?ids=1,3,39`, but more complex data, such as
    the name of a person, is not allowed *as is*. You cannot have a URL as `/persons?partial_name=John
    Doe`, because it contains whitespace. In general, you have to encode it in coding
    allowed in a URL, and that is provided by the call to `url::form_urlencoded::byte_serialize`,
    which gets a slice of bytes and returns an iterator generating chars. If you call
    `collect::<String>()` on this iterator, you get a string that can be safely put
    into a web URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `base64` crate is used to perform a similar encoding of binary data into
    textual data, but for the header or the body of an HTTP request. In particular,
    it is required to encode usernames and passwords in the basic authentication header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source file names are the same as the `yauth` project, except that the `db_access.rs` file
    has been renamed as `common.rs`. Actually, in this project, there is no code required
    to access the database, as access is now performed only by the service. The `common` module
    contains definitions of a constant, two structs, an enum, and a function needed
    by several components.
  prefs: []
  type: TYPE_NORMAL
- en: The changes to the models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The models of the components have the following changes.
  prefs: []
  type: TYPE_NORMAL
- en: All the `db_connection` fields have been removed, as the app now does not directly
    access the database. That has become the responsibility of the server.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean `fetching` field has been added. It is set to true when a request
    is sent to the server and reset to false when the response is received, or the
    request has failed. It is not really necessary in this app, but it may be useful
    when using a slower communication (with a remote server) or some more lengthy
    requests. It may be used to show to the user that a request is pending, and also
    to disable other requests in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch_service` field has been added to provide the communication feature. The
    `ft` field has been added to contain a reference to the current `FetchTask` object
    during a request, or `Nothing` when no request has already been sent. This field
    is not actually used; this is just a trick to keep the current request alive,
    because otherwise after the request is sent and the `update` function returns,
    the local variables would be dropped.
  prefs: []
  type: TYPE_NORMAL
- en: The `link` field has been added for forwarding to the current model the callback
    that will be called when the response is received.
  prefs: []
  type: TYPE_NORMAL
- en: The `console` field has been added to provide a way to print to the console
    of the browser, for debugging purposes. In Yew, the `print!` and `println!` macros
    are ineffective, as there is no system console on which to print. But the web
    browser has a console, which is accessed using the `console.log()` JavaScript
    function call. This Yew service provides access to such a feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `username` and `password` fields have been added to send authentication
    data with any requests.
  prefs: []
  type: TYPE_NORMAL
- en: But let's see the changes required to the code because of the need to communicate
    with the server.
  prefs: []
  type: TYPE_NORMAL
- en: A typical client/server request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For any user command that, in the `yauth` project, required access to the database,
    such access has been removed, and the following changes have been applied, instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a user command now sends a request to a web service, and then a response
    from that service must be handled. In our examples, the time between the user
    command and the reception of the response from the service is quite short – just
    a few milliseconds, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Both client and server run in the same computer, and so the TCP/IP packets actually
    don't exit the computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer has nothing else to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database is actually a very short memory vector, and so its operations are
    very fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though, in a real system, much more time is spent processing a user command
    that causes communication. If everything is good, a command takes only half a
    second, but sometimes it may take several seconds. So, synchronous communication
    is not acceptable. Your app cannot just wait for a response from the server, because
    it would appear to be stuck.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `FetchService` object of the Yew framework provides an asynchronous
    communication model.
  prefs: []
  type: TYPE_NORMAL
- en: The controller routine triggered by the user command prepares the request to
    be sent to the server, and also prepares a callback routine, to handle the response
    from the server, and then sends the request, and so the app is free to handle
    other messages.
  prefs: []
  type: TYPE_NORMAL
- en: When the response comes from the server, the response triggers a message that
    is handled by the controller. The handling of the message invokes the callback
    prepared in advance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in addition to the messages signaling a user command, other messages have
    been added. Some of them report the reception of a response, that is, the successful
    completion of a request; and others report a failure of the request coming from
    the server, that is, the unsuccessful completion of a request. For example, in
    the `PersonsListModel` component, implemented in the `persons_list.rs` file, the
    following user actions required communication:'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the Find button (triggering the `FindPressed` message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the Filter button (triggering the `FilterPressed` message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the Delete Selected Persons button (triggering the `DeletePressed` message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing one of the Edit buttons (triggering the `EditPressed` message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For them, the following messages have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadyFilteredPersons(Result<Vec<Person>, Error>)`: This is triggered by the
    `FetchService` instance when a list of filtered persons is received from the service.
    Such a list is contained in a `Vec` of `Person`. This may happen after processing
    the `FilterPressed` message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadyDeletedPersons(Result<u32, Error>)`: This is triggered by the `FetchService`
    instance when the report that a command to delete some persons has been completed
    by the service. The number of deleted persons is contained in `u32`. This may
    happen after processing the `DeletePressed` message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadyPersonToEdit(Result<Person, Error>)`: This is sent by `FetchService`
    when the requested `Person` object is received from the service, and so it can
    be edited (or simply displayed). This may happen after processing the `FindPressed` message
    or the `EditPressed` message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failure(String)`: This is sent by `FetchService` when any of the preceding
    requests have failed as the service returns a failure response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s see the code that handles the `EditPressed` message. Its
    first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the working of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `fetching` state is set to `true`, to take note that communication
    is underway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then a debug message is printed to the console of the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, a callback is prepared to handle the response. To prepare such a callback,
    a *move* closure, that is, a closure that gets ownership of all the variables
    it uses, is passed to the `send_back` function of the `link` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that we come here when the user has pressed a button to edit a person
    specified by their ID; and so we need the whole of the person data to display
    it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the callback is the code that we want to be executed after receiving
    a response from the server. Such a response, if successful, must contain all the
    data regarding the person we want to edit. So, this closure gets a `Response`
    object from the service. This type is actually parameterized by the possible contents
    of the response. In this project, we always expect a `yew::format::Json` payload
    and such a payload is a `Result`, which always has `failure::Error` as its error
    type. Though, the success type varies depending on the request type. In this particular
    request, we expect a `Person` object as a successful result.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the closure calls the `into_parts` method on the response to destructure
    the response into the metadata and the data. The metadata is HTTP-specific information,
    while the data is the JSON payload.
  prefs: []
  type: TYPE_NORMAL
- en: Using the metadata, it is possible to check whether the response was successful
    (`meta.status.is_success()`). In such a case, the Yew message `ReadyPersonToEdit(data)`
    is triggered; such a message will handle the response payload. In the event of
    an error, a Yew message of `Failure` is triggered; such a message will display
    the specified error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could ask: "Why does the callback forward the payload to the Yew framework,
    specifying another message, instead of doing anything that should be done upon
    receipt of the response?"'
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that the callback, to be executed out of context by the framework,
    must be the owner of any variable it accesses after its creation, that is, when
    the request is sent, up to the time of its destruction (when the response is received).
    So, it cannot use the model or any other external variable. You cannot even print
    on the console or open an alert box inside such a callback. So you need to asynchronously
    forward the response to a message handler, which will be able to access the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the handler of the `EditPressed` message is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: First, a web request is prepared, using the `get` method, which uses the `GET`
    HTTP method, and optionally specifying a `body`, which in this case is empty (`Nothing`).
  prefs: []
  type: TYPE_NORMAL
- en: Such a request is enriched with authentication information by a call of the
    `add_auth` common function, and finally, the `fetch` method of the `FetchService`
    object is invoked. This method uses the request and the callback to begin the
    communication with the server. It immediately returns a handle, stored in the
    `ft` field of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Then the control returns to Yew, which can process other messages, until a response
    comes from the server. Such a response will be forwarded to the callback defined
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the handler of the `ReadyPersonToEdit(person)` message, forwarded
    when a person structure is received from the server as a response to the request
    of editing a person by their `id`. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: First, the `fetching` state is set to `false`, to take note that the current
    communication is ended.
  prefs: []
  type: TYPE_NORMAL
- en: Then, if the received person was `None`,  such a value is replaced by a person
    having zero as `id` and an empty string as a name. Of course, it is an invalid
    person.
  prefs: []
  type: TYPE_NORMAL
- en: Then, a reference to the `go_to_one_person_page` field of the model is taken.
    This field can be `None` (in fact, only at the initialization stage), so, if it
    is not defined, nothing is done. This field is a Yew callback to jump to another
    page.
  prefs: []
  type: TYPE_NORMAL
- en: At last, a debug message is printed, and the callback is invoked using the `emit`
    method. This call receives a copy of the person to display on that page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the handler of the `Failure(msg)` message, forwarded when an
    error is received from the server. This handler is shared by other requests, as
    it has the same behavior. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Again, the fetching state is set to `false` since the communication is ended.
  prefs: []
  type: TYPE_NORMAL
- en: A debug message is printed, and a message box is opened to show the user the
    error message. As long as such a message box is opened, the component is frozen,
    as no other message can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: At last, the controller returns `false` to signal that no view needs to be refreshed.
    Notice that the default return value is `true` as, usually, the controller changes
    the model, and so the view must be refreshed as a consequence of that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how a complete frontend web app can be built using Rust, by using
    the `cargo-web` command, the Wasm code generator, and the Yew framework. Such
    apps are modular and well structured, as they use the Elm Architecture, which
    is a variant of the MVC architectural pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We created six apps, and we saw how they worked—`incr`, `adder`, `login`, `yauth`,
    `persons_db`, and `yclient`.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, you learned how to build and run a Wasm project. We looked at the
    MVC architectural pattern for building interactive apps. We covered how the Yew
    framework supports the creation of apps implementing an MVC pattern, specifically
    according to the Elm Architecture. We also saw how to structure an app in several
    components and how to keep a common header and footer, while the body of the app
    changes from page to page. And at the end, we learned how to use Yew to communicate
    with a backend app, possibly running on a different computer, packaging data in
    JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to build a web game using Wasm and the
    Quicksilver framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is WebAssembly, and what are its advantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the MVC pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are messages in the Elm Architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are components in the Yew framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are properties in the Yew framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you build a web app with a fixed header and footer and change the inner
    section using the Yew framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are callbacks in the Yew framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you pass a shared object, such as a database connection, between Yew
    components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why you must keep in the model a field having type FetchTask, when you communicate
    with a server, even if you don't need to use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you open JavaScript-style alert boxes and confirm boxes using the Yew
    framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yew project can be downloaded from here: [https://github.com/DenisKolodin/yew](https://github.com/DenisKolodin/yew). The
    repository contains a very short tutorial and many examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find other info about generating Wasm code from a Rust project at:
    [https://github.com/koute/cargo-web](https://github.com/koute/cargo-web).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of web development libraries and frameworks: [https://www.arewewebyet.org/](https://www.arewewebyet.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of game development libraries and frameworks: [https://arewegameyet.com/](https://arewegameyet.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of programmers' editors and IDEs: [https://areweideyet.com/](https://areweideyet.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of asynchronous programming libraries: [https://areweasyncyet.rs/](https://areweasyncyet.rs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of GUI development libraries and frameworks: [https://areweguiyet.com/](https://areweguiyet.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
