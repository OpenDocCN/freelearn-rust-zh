- en: Creating a Client-Side WebAssembly App Using Yew
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Yew 创建客户端 WebAssembly 应用程序
- en: In this chapter, you will see how Rust can be used to build the frontend of
    a web application, as an alternative to using HTML, CSS, and JavaScript (typically
    using a JavaScript frontend framework, such as React) or another language generating
    JavaScript code (such as Elm or TypeScript).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将看到如何使用 Rust 构建网页应用的前端，作为使用 HTML、CSS 和 JavaScript（通常使用 JavaScript 前端框架，如
    React）或生成 JavaScript 代码的另一种语言（如 Elm 或 TypeScript）的替代方案。
- en: To build a Rust app for a web browser, the Rust code must be translated to WebAssembly
    code, which can be supported by all modern web browsers. The capability to translate
    Rust code into WebAssembly code is now included in the stable Rust compiler.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要为网页浏览器构建 Rust 应用程序，必须将 Rust 代码转换为 WebAssembly 代码，这种代码可以被所有现代网页浏览器支持。现在，将 Rust
    代码转换为 WebAssembly 代码的功能已包含在稳定的 Rust 编译器中。
- en: To develop large projects, a web frontend framework is needed. In this chapter,
    the Yew framework will be presented. It is a framework that supports the development
    of frontend web applications, using the **Model-View-Controller** (**MVC**)architectural
    pattern, and generating WebAssembly code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开发大型项目需要网页前端框架。在本章中，将介绍 Yew 框架。这是一个支持使用 **模型-视图-控制器**（**MVC**）架构模式开发前端网页应用，并生成
    WebAssembly 代码的框架。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the MVC architectural pattern and its usage in web pages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 MVC 架构模式及其在网页中的应用
- en: Building WebAssembly apps using the Yew framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Yew 框架构建 WebAssembly 应用程序
- en: How to use the Yew crate to create web pages designed with the MVC pattern (`incr`
    and `adder`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Yew 包创建采用 MVC 模式（`incr` 和 `adder`）设计的网页
- en: Creating a web app having several pages with a common header and footer (`login` and `yauth`)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有公共页眉和页脚（`login` 和 `yauth`）的网页应用
- en: Creating a web app having both a frontend and a backend, in two distinct projects
    (`yclient` and `persons_db`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有前端和后端（在两个不同的项目中，`yclient` 和 `persons_db`）的网页应用
- en: The frontend is developed using Yew, and the backend, which is an HTTP RESTful
    service, is developed using Actix web.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前端使用 Yew 开发，后端是一个 HTTP RESTful 服务，使用 Actix web 开发。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes you have already read the previous chapters, also, prior
    knowledge of HTML is required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经阅读了前面的章节，此外，还需要具备 HTML 的相关知识。
- en: 'To run the projects in this chapter, it is enough to install the generator
    of WebAssembly code (Wasm, for short). Probably the simplest way to do this is
    by typing the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的项目，只需安装 WebAssembly 代码生成器（简称 Wasm）即可。最简单的方法可能是输入以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After 13 minutes, your Cargo tool will be enriched by several commands. A few
    of which are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 13 分钟后，你的 Cargo 工具将增加几个命令。其中一些如下：
- en: '`cargo web build` (or `cargo-web build`): It builds Rust projects designed
    to run in a web browser. It is similar to the `cargo build` command, but for Wasm.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo web build`（或 `cargo-web build`）：它构建旨在在网页浏览器中运行的 Rust 项目。它与 `cargo build`
    命令类似，但用于 Wasm。'
- en: '`cargo web start` (or `cargo-web start`): It performs a `cargo web build` command,
    and then starts a web server where every time it is visited by a client, it sends
    a complete Wasm frontend app to the client. It is similar to the `cargo run` command,
    but for serving Wasm apps.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cargo web start`（或 `cargo-web start`）：它执行 `cargo web build` 命令，然后启动一个网页服务器，每次被客户端访问时，都会向客户端发送一个完整的
    Wasm 前端应用。它与 `cargo run` 命令类似，但用于服务 Wasm 应用程序。'
- en: The complete source code for this chapter is in the `Chapter05` folder of the
    repository at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/Rust-2018-Projects)[Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于存储库的 `Chapter05` 文件夹中：[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/Rust-2018-Projects)[Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)。
- en: Introducing Wasm
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Wasm
- en: Wasm is a powerful new technology to deliver interactive applications. Before
    the advent of the web, there were already many developers building client/server
    applications, where the client apps ran on a PC (typically with Microsoft Windows)
    and the server apps ran on a company-owned system (typically with NetWare, OS/2,
    Windows NT, or Unix). In such systems, developers could choose their favorite
    language for the client app. Some people used Visual Basic, others used FoxPro
    or Delphi, and many other languages were in wide use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm是一种强大的新技术，可以提供交互式应用程序。在网页出现之前，已经有许多开发者正在构建客户端/服务器应用程序，其中客户端应用程序在PC上运行（通常是Microsoft
    Windows），而服务器应用程序在公司拥有的系统上运行（通常是NetWare、OS/2、Windows NT或Unix）。在这样的系统中，开发者可以选择他们喜欢的客户端应用程序的语言。有些人使用Visual
    Basic，其他人使用FoxPro或Delphi，还有许多其他语言被广泛使用。
- en: 'However, for such systems, the deployment of updates was a kind of hell, because
    of several possible issues, such as ensuring that every client PC had the proper
    runtime system and that all clients got the updates at the same time. These problems
    were solved by JavaScript running in web browsers, as it is a ubiquitous platform
    on which frontend software could be downloaded and executed. This had some drawbacks
    though: developers were forced to use HTML + CSS + JavaScript to develop frontend software,
    and sometimes such software had poor performance.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这样的系统，部署更新是一种地狱般的体验，因为存在多个可能的问题，例如确保每个客户端PC都有适当的运行时系统，并且所有客户端都能同时获得更新。这些问题通过在网页浏览器中运行的JavaScript得到了解决，因为它是前端软件可以下载和执行的一个无处不在的平台。但这也有一些缺点：开发者被迫使用HTML
    + CSS + JavaScript来开发前端软件，而且有时这样的软件性能较差。
- en: Here comes Wasm, which is a machine-language-like programming language, like
    Java bytecode or Microsoft .NET CIL code, but it is a standard accepted by all
    major web browsers. Version 1.0 of its specification appeared in October 2017,
    and in 2019 it appears that already more than 80% of web browsers running in the
    world support it. This means that it can be more efficient and that it can be
    rather easily generated from several programming languages, including Rust.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Wasm，这是一种类似机器语言的编程语言，就像Java字节码或Microsoft .NET CIL代码，但它是由所有主流网页浏览器接受的标准化语言。其规范的第1.0版于2017年10月发布，到2019年，世界上已有超过80%的网页浏览器支持它。这意味着它更高效，并且可以从多种编程语言中轻松生成，包括Rust。
- en: So, if Wasm is set as the target architecture of the Rust compiler, a program
    written in Rust can be run on any major modern web browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将Wasm设置为Rust编译器的目标架构，用Rust编写的程序就可以在任何主流的现代网页浏览器上运行。
- en: Understanding the MVC architectural pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MVC架构模式
- en: This chapter is about creating web apps. So, to make things more concrete, let's
    look straight away at two toy web applications named `incr` and `adder`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于创建网页应用程序的。所以，为了使事情更具体，让我们直接看看两个名为`incr`和`adder`的玩具网页应用程序。
- en: Implementing two toy web apps
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现两个玩具网页应用程序
- en: 'To run the first toy application, let''s take the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行第一个玩具应用程序，请按照以下步骤操作：
- en: Go into the `incr` folder and type `cargo web start`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`incr`文件夹并输入`cargo web start`。
- en: 'After a few minutes, a message will appear on the console, ending with the
    following line:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，控制台上将出现一条消息，最后以以下行结束：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, in the address box of a web browser, type: `127.0.0.1:8000` or `localhost:8000`,
    and immediately you will see the following contents:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在网页浏览器的地址栏中输入：`127.0.0.1:8000`或`localhost:8000`，你将立即看到以下内容：
- en: '![](img/c46a2847-2d66-493e-8ca1-7ad985362d8c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c46a2847-2d66-493e-8ca1-7ad985362d8c.png)'
- en: Click on the two buttons, or select the following textbox and then press the
    *+* or the *0* keys on the keyboard.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击两个按钮，或者选择以下文本框，然后按键盘上的*+*或*0*键。
- en: If you click once on the Increment button, the contents of the box to the right
    change from 0 to 1.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你点击一次增加按钮，右侧框的内容将从0变为1。
- en: If you click another time, it changes to 2, and so on.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你再点击一次，它就会变成2，以此类推。
- en: If you click on the Reset button, the value changes to 0 (zero).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你点击重置按钮，值会变为0（零）。
- en: If you select the textbox by clicking on it and then press the *+* key, you
    increment the number like the Increment button does. Instead, if you press the
    *0* key, the number is set to zero.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你通过点击选择文本框，然后按*+*键，数值会增加，就像增加按钮一样。相反，如果你按*0*键，数值将被设置为零。
- en: To stop the server, go to the console and press *Ctrl *+ *C*.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止服务器，请进入控制台并按*Ctrl* + *C*。
- en: To run the `adder` app, go into the `adder` folder and type `cargo web start`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行`adder`应用程序，请进入`adder`文件夹，并输入`cargo web start`。
- en: 'Similarly, for the other app, when the server app has started, you can refresh
    your web browser page and you will see the following page:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，对于其他应用程序，当服务器应用程序启动后，你可以刷新你的网页浏览器页面，你将看到以下页面：
- en: '![](img/453816c4-97e3-48da-9d8d-2aa92aab4a0b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/453816c4-97e3-48da-9d8d-2aa92aab4a0b.png)'
- en: 'Here, you can insert a number in the first box, to the right of the Addend
    1 label, another number in the second box, and then press the Add button. After
    that, you will see the sum of those numbers in the textbox at the bottom, which
    has turned from yellow to light green, as in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以在第一个框中输入一个数字，在“加数1”标签的右侧，在第二个框中输入另一个数字，然后按下“加”按钮。之后，你将在底部的文本框中看到这些数字的总和，该文本框已从黄色变为浅绿色，如下面的截图所示：
- en: '![](img/3c8ac8a3-0f08-45ce-9ef6-b399beeedd28.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c8ac8a3-0f08-45ce-9ef6-b399beeedd28.png)'
- en: After the addition, the Add button has become disabled. If one of the first
    two boxes is empty, the sum fails and nothing happens. Also, if you change the
    value of any of the two first boxes, the Add button becomes enabled, and the last
    textbox becomes empty and yellow.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在加法操作后，“加”按钮已变为禁用状态。如果第一个两个框中的任何一个为空，则求和失败，不会发生任何操作。此外，如果你更改前两个框中任意一个的值，“加”按钮将变为启用状态，最后一个文本框变为空并变为黄色。
- en: What is the MVC pattern?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是MVC模式？
- en: Now that we have seen some very simple web applications, we can explain what
    the MVC architectural pattern is using these apps as an example. The MVC pattern
    is an architecture regarding event-driven interactive programs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些非常简单的Web应用程序，我们可以使用这些应用程序作为例子来解释MVC架构模式是什么。MVC模式是一种关于事件驱动的交互式程序的架构。
- en: 'Let''s see what event-driven interactiveprograms are. The word **interactive**
    is the opposite of **batch**. A batch program is a program in which the user prepares
    all the input at the beginning, and then the program runs without asking for further
    input. Instead, an interactive program has the following steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看什么是事件驱动的交互式程序。单词**交互式**是**批处理**的反义词。批处理程序是一种用户在开始时准备所有输入的程序，然后程序运行而不需要进一步输入。相反，交互式程序有以下步骤：
- en: Initialization.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化。
- en: Waiting for some actions from the user.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待用户采取某些行动。
- en: When the user acts on an input device, the program processes the related input,
    and then goes to the preceding step, to wait for further input.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在输入设备上采取行动时，程序处理相关的输入，然后回到前面的步骤，等待进一步的输入。
- en: For example, console command interpreters are interactive programs, and all
    web apps are interactive too.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，控制台命令解释器是交互式程序，所有的Web应用程序也都是交互式的。
- en: The phrase *event-driven* means that the application, after initialization,
    does nothing until the user performs something on the user interface. When the
    user acts on an input device, the app processes such inputs and updates the screen
    only as a reaction to the user input. Most web applications are event-driven.
    The main exceptions are games and virtual reality or augmented reality environments,
    where animations go on even if the user does nothing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*事件驱动*意味着在初始化后，应用程序不执行任何操作，直到用户在用户界面上执行某些操作。当用户在输入设备上采取行动时，应用程序处理这些输入，并且仅作为对用户输入的反应来更新屏幕。大多数Web应用程序都是事件驱动的。主要的例外是游戏和虚拟现实或增强现实环境，即使用户没有采取任何行动，动画也会继续。
- en: Our examples in this chapter are all event-driven interactive programs, as after
    initialization, they do something only when the user clicks with the mouse (or
    touches the touchscreen) or presses any key on the keyboard. Some such clicks
    and key presses cause a change on the screen. Therefore, the MVC architecture
    can be applied to these example projects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都是事件驱动的交互式程序，因为初始化后，它们只有在用户用鼠标点击（或触摸触摸屏）或按下键盘上的任何键时才会执行某些操作。一些这样的点击和按键会在屏幕上引起变化。因此，MVC架构可以应用于这些示例项目。
- en: There are several dialects of this pattern. The one used by Yew derives from
    the one implemented by the Elm language, and so it is named the **Elm Architecture**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式有几种方言。Yew使用的方言源自Elm语言实现的方言，因此它被称为**Elm架构**。
- en: The model
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: In any MVC program, there is a data structure, named `model`, that contains
    all the dynamic data required to represent the user interface.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何MVC程序中，都有一个名为`model`的数据结构，它包含表示用户界面所需的所有动态数据。
- en: For example, in the `incr` app, the value of the number contained in the box
    to the right is required to represent the box, and it can change at runtime. Hence,
    that numeric value must be in the model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`incr`应用中，需要表示右侧框中包含的数字的值来表示该框，并且它可以随时改变。因此，这个数值必须在模型中。
- en: 'Here, the width and height of the browser window are usually not required to
    generate the HTML code and so they shouldn''t be a part of the model. Also, the
    sizes and texts of the buttons shouldn''t be a part of the model, but for another
    reason: they cannot change at runtime in this app. Though, if it were an internationalized
    app, all the texts should be in the model too.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，浏览器窗口的宽度和高度通常不需要生成HTML代码，因此它们不应该成为模型的一部分。同样，按钮的大小和文本也不应该成为模型的一部分，但出于另一个原因：在这个应用中它们不能在运行时改变。尽管如此，如果这是一个国际化应用，所有文本也应该包含在模型中。
- en: In the `adder` app, the model should contain only the three values contained
    in the three textboxes. It doesn't matter that two of them are directly inputted
    by the user and the third one is calculated. The labels and the background color
    of the textboxes shouldn't be a part of the model.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`adder`应用中，模型应只包含三个文本框中的三个值。其中两个直接由用户输入，第三个是计算得出的，这并不重要。标签和文本框的背景颜色不应该成为模型的一部分。
- en: The view
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The next portion of the MVC architecture is the **view**. It is a specification
    of how to represent (or render) the graphical contents of the screen, depending
    on the value of the model. It can be a declarative specification, such as pure
    HTML code, or a procedural specification, such as some JavaScript or Rust code,
    or a mix of them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MVC架构的下一部分是**视图**。它是指根据模型值如何表示（或渲染）屏幕图形内容的规定。它可以是声明性规范，如纯HTML代码，也可以是程序性规范，如一些JavaScript或Rust代码，或者它们的混合。
- en: For example, in the `incr` app, the view shows two push-buttons and one read-only
    textbox, whereas, in the `adder` app, the view shows three labels, three textboxes,
    and one push-button.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`incr`应用中，视图显示两个按钮和一个只读文本框，而在`adder`应用中，视图显示三个标签、三个文本框和一个按钮。
- en: All the shown push-buttons have a constant appearance, but the views must change
    the display of the numbers when the models change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的按钮都有恒定的外观，但视图必须根据模型的变化更改数字的显示。
- en: The controller
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: The last portion of the MVC architecture is the *controller*. It is always a
    routine or a set of routines that are invoked by the view when the user, using
    an input device, interacts with the app. When a user performs an action with an
    input device, all the view has to do is to notify the controller that the user
    has performed that action, specifying which action (for example, which mouse key
    has been pressed), and where (for example, in which position of the screen).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: MVC架构的最后一部分是*控制器*。它始终是一组由视图在用户使用输入设备与应用交互时调用的例程。当用户使用输入设备执行操作时，视图必须做的只是通知控制器用户已执行该操作，并指定操作（例如，哪个鼠标键被按下），以及位置（例如，屏幕的哪个位置）。
- en: 'In the `incr` app, the three possible input actions are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`incr`应用中，三种可能的输入操作如下：
- en: A click on the Increment button
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“增加”按钮
- en: A click on the Reset button
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“重置”按钮
- en: A press of a key on the keyboard when the textbox is selected
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本框被选中时按下键盘上的键
- en: Usually, it is also possible to press a push-button using the keyboard, but
    such an action can be considered equivalent to a mouse click, and so a single
    input action type is notified for each button.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，也可以使用键盘按下按钮，但这种动作可以被认为是相当于鼠标点击，因此每个按钮只通知一个输入动作类型。
- en: 'In the `adder` app, the three possible input actions are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`adder`应用中，三种可能的输入操作如下：
- en: A change of the value in the Addend 1 textbox
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变“加数1”文本框中的值
- en: A change of the value in the Addend 2 textbox
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变“加数2”文本框中的值
- en: A click on the Add button
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“添加”按钮
- en: 'It is possible to change the value of a textbox in several ways:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以更改文本框的值：
- en: By typing when no text is selected, inserting additional characters
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有选择文本的情况下输入，插入额外的字符
- en: By typing when some text is selected, and so replacing the selected text with
    a character
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择一些文本时输入，从而用字符替换所选文本
- en: By pasting some text from the clipboard
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从剪贴板粘贴一些文本
- en: By dragging and dropping some text from another element of the screen
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从屏幕上的另一个元素拖放一些文本
- en: By using the mouse on the up-down spinner
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用鼠标上下旋转器
- en: We are not interested in these, because they are handled by the browser or by
    the framework. All that matters for application code is that when the user performs
    an input action, a textbox changes its value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对此不感兴趣，因为它们由浏览器或框架处理。对于应用程序代码来说，重要的是当用户执行输入操作时，文本框会更改其值。
- en: The job of the controller is just to use such input information to update the
    model. When the model is completely updated, the framework notifies the view about
    the need to refresh the look of the screen, taking into account the new values
    of the model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的任务只是使用此类输入信息来更新模型。当模型完全更新后，框架通知视图需要刷新屏幕的外观，考虑到模型的新值。
- en: In the case of the `incr`app, the controller, when it is notified of the pressing
    of the Increment button, increments the number contained in the model; when it
    is notified of the pressing of the Reset button, it sets to zero that number in
    the model; when it is notified of the pressing of a key on the textbox, it checks
    whether the pressed key is *+*, or *0*, or something else, and the appropriate
    change is applied to the model. After such changes, the view is notified to update
    the display of such a number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `incr` 应用程序的情况下，当控制器被通知到按下 Increment 按钮，它会增加模型中的数字；当它被通知到按下 Reset 按钮，它会将模型中的该数字设置为零；当它被通知到在文本框上按下键时，它会检查按下的键是
    *+*、*0* 还是其他，并将适当的更改应用于模型。在这些更改之后，视图被通知更新显示这样的数字。
- en: In the case of the `adder` app, the controller, when it is notified of the change
    of the Addend 1 textbox, updates the model with the new value contained in the
    edit box. Similar behavior happens for the Addend 2 textbox; and when the controller
    is notified of the pressing of the Add button, it adds the two addends contained
    in the model and stores the result in the third field of the model. After such
    changes, the view is notified to update the display of such a result.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `adder` 应用程序的情况下，当控制器被通知到 Addend 1 文本框的更改时，它会将编辑框中包含的新值更新到模型中。对于 Addend 2
    文本框也有类似的行为；当控制器被通知到按下 Add 按钮，它会将模型中包含的两个加数相加并将结果存储在模型的第三个字段中。在这些更改之后，视图被通知更新显示这样的结果。
- en: View implementation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看实现
- en: Regarding web pages, the representation of pages is usually made up of HTML
    code, and so, using the Yew framework, the view function must generate HTML code.
    Such generations contain in themselves the constant portions of HTML code, but
    they also access the model to get the information that can change at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网页，页面的表示通常由 HTML 代码组成，因此，使用 Yew 框架，视图函数必须生成 HTML 代码。这样的生成包含 HTML 代码的固定部分，但它们也访问模型以获取在运行时可能更改的信息。
- en: In the `incr` app, the view composes the HTML code that defines two buttons
    and one read-only numeric *input* element and puts in such an *input* element
    the value taken from the model. The view includes the handling of the HTML *click* events
    on the two buttons by forwarding them to the controller.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `incr` 应用程序中，视图组合了定义两个按钮和一个只读数字 *输入* 元素的 HTML 代码，并将从模型中获取的值放入这样的 *输入* 元素中。视图包括通过将它们转发到控制器来处理两个按钮上的
    HTML *点击* 事件。
- en: In the `adder` app, the view composes the HTML code that defines three labels,
    three numeric input elements, and one button, and puts in the last *input* element
    the value taken from the model. It includes the handling of the HTML *input* events
    in the first two textboxes and the *click* event on the button, by forwarding
    them to the controller. Regarding the first two textbox events, the values contained
    in the boxes are forwarded to the controller.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `adder` 应用程序中，视图组合了定义三个标签、三个数字输入元素和一个按钮的 HTML 代码，并将从模型中获取的值放入最后一个 *输入* 元素中。视图包括处理前两个文本框的
    HTML *输入* 事件和按钮上的 *点击* 事件，通过将它们转发到控制器。关于前两个文本框事件，框中的值被转发到控制器。
- en: Controller implementation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器实现
- en: Using Yew, the controller is implemented by an *update* routine, which processes
    the messages regarding user actions coming from the view and uses such input to
    change the model. After the controller has completed all the required changes
    to the model, the view must be notified to apply the changes of the model to the
    user interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Yew 时，控制器通过一个 *更新* 程序实现，该程序处理来自视图的用户操作消息，并使用此类输入来更改模型。在控制器完成对模型的所有必要更改后，必须通知视图以将模型的更改应用于用户界面。
- en: 'In some frameworks, such as in Yew, such an invocation of the view is automatic;
    that mechanism has the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些框架中，例如在Yew中，这样的视图调用是自动的；该机制有以下步骤：
- en: For any user action handled by the view, the framework calls the `update` function,
    that is, the controller. In this call, the framework passes to the controller
    the details regarding the user action; for example, which value has been typed
    in a textbox.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于视图处理的任何用户操作，框架调用`update`函数，即控制器。在这个调用中，框架将用户操作的详细信息传递给控制器；例如，在文本框中输入了哪个值。
- en: The controller, typically, changes the state of the model.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，控制器会改变模型的状态。
- en: If the controller has successfully applied some changes to the model, the framework
    calls the view function, which is the *view* of the MVC architecture.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果控制器成功将一些更改应用到模型上，框架将调用视图函数，这是MVC架构的*视图*。
- en: Understanding the MVC architecture
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解MVC架构
- en: 'The general flow of control of the MVC architecture is shown in the following
    diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MVC架构的控制流程在以下图中展示：
- en: '![](img/e1ea5bec-c3d3-43d2-963f-a0a3f4c54ed9.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1ea5bec-c3d3-43d2-963f-a0a3f4c54ed9.png)'
- en: 'The iteration of every user action is this sequence of operations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户操作的迭代是这个操作序列：
- en: The user sees a static representation of graphical elements on the screen.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户看到屏幕上图形元素的静态表示。
- en: The user acts on the graphical elements using an input device.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用输入设备对图形元素进行操作。
- en: The view receives a user action and notifies the controller.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图接收到用户操作并通知控制器。
- en: The controller updates the model.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器更新模型。
- en: The view reads the new state of the model to update the contents of the screen.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图读取模型的新状态以更新屏幕的内容。
- en: The user sees the new state of the screen.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户看到屏幕的新状态。
- en: 'The main concepts of the MVC architecture are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MVC架构的主要概念如下：
- en: All the mutable data that is needed to correctly build the display must be in
    a single data structure, named **model**. The model may be associated with some
    code, but such code does not get direct user input, nor does it give output to
    the user. It may access files, databases, or other processes, though. Because
    the model does not interact directly with the user interface, the code implementing
    the model shouldn't change if the application user interface is ported from text
    mode to GUI/web/mobile.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有需要正确构建显示的必要可变数据必须在一个名为**模型**的单个数据结构中。模型可能关联一些代码，但这些代码不直接接收用户输入，也不向用户输出。它可能访问文件、数据库或其他进程。由于模型不直接与用户界面交互，实现模型的代码在应用程序用户界面从文本模式移植到GUI/web/mobile时不应更改。
- en: The logic that draws on the display and captures user input is named the *view*.
    The view, of course, must know about screen rendering, input devices and events,
    and also about the model. Though, the view just *reads* the model, it never changes
    it directly. When an interesting event happens, the view notifies the controller
    of that event.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上绘制并捕获用户输入的逻辑被称为*视图*。当然，视图必须了解屏幕渲染、输入设备和事件，以及模型。尽管视图只是*读取*模型，但它永远不会直接更改它。当发生有趣的事件时，视图会通知控制器该事件。
- en: When the controller is notified of an interesting event by the view, it changes
    the model accordingly, and when it has finished, the framework notifies the view
    to refresh itself using the new state of the model.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当控制器被视图通知有有趣的事件时，它会相应地更改模型，并在完成更改后，框架通知视图使用模型的新状态刷新自己。
- en: Project overview
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: This chapter will present four projects that will get more and more complex.
    You have already seen the first two projects in action: `incr` and `adder`. The
    third project, named `login`, shows how to create a login page for authentication
    on a website.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍四个项目，这些项目的复杂度将逐渐增加。您已经看到了前两个项目的实际操作：`incr`和`adder`。第三个项目，命名为`login`，展示了如何在网站上创建登录页面进行身份验证。
- en: The fourth project, named `yauth,` extends the `login` project adding the CRUD
    handling of a list of persons. Its behavior is almost identical to that of the
    `auth` project in [Chapter 4](27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml), *Creating
    a Full Server-Side Web App*. Each project will require from 1 to 3 minutes to
    download and compile from scratch.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个项目，命名为`yauth`，扩展了`login`项目，增加了对人员列表的CRUD处理。其行为几乎与[第4章](27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml)中“创建一个完整的后端Web应用”的`auth`项目相同。每个项目从零开始下载和编译大约需要1到3分钟。
- en: Getting started
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'To start all the machinery, a very simple statement is enough – the body of
    the `main` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动所有设备，只需要一个非常简单的语句——`main` 函数的主体：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It creates a web app based on the specified `Model`, starts it, and waits on
    the default TCP port. Of course, the TCP port can be changed. It is a server that
    will serve the app to any browser navigating to it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于指定的 `Model` 创建一个网络应用程序，启动它，并等待默认的 TCP 端口。当然，TCP 端口可以更改。这是一个将应用程序提供给任何导航到它的浏览器的服务器。
- en: The incr app
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`incr` 应用程序'
- en: 'Here, we''ll see the implementation of the `incr` project, which we already
    saw how to build and use. The only dependency is on the Yew framework, and so,
    the TOML file contains the following line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到 `incr` 项目的实现，我们之前已经看到了如何构建和使用它。唯一的依赖项是 Yew 框架，因此，TOML 文件包含以下行：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the source code is in the `main.rs` file. The model is implemented by the
    following simple declaration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有源代码都在 `main.rs` 文件中。模型通过以下简单声明实现：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It just has to be a struct that will be instantiated by the framework, read
    by the view, and read and written by the controller. Its name and the name of
    its fields are arbitrary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它只需要是一个将被框架实例化的结构体，被视图读取，并被控制器读取和写入。它的名称及其字段名称是任意的。
- en: 'Then the possible notifications from the view to the controller must be declared
    as an `enum` type. Here is that of `incr`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后必须将视图到控制器的可能通知声明为 `enum` 类型。以下是 `incr` 的示例：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, here, the names are arbitrary:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里的名称也是任意的：
- en: '`Msg` is short for *message*, as such notifications are in a sense messages
    from the view to the controller.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Msg` 是 *message* 的缩写，因为此类通知在某种程度上是视图到控制器的消息。'
- en: The `Increment` message notifies a click on the Increment button.The `Reset`
    message notifies a click on the Reset button.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Increment` 消息通知点击了增量按钮。《Reset` 消息通知点击了重置按钮。'
- en: The `KeyDown` message notifies a press of any key on the keyboard; its argument
    communicates which key has been pressed.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyDown` 消息通知键盘上任何键的按下；其参数传达了哪个键被按下。'
- en: 'To implement the controller, the `yew::Component` trait must be implemented
    for our model. The code for our project is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现控制器，必须为我们的模型实现 `yew::Component` 特性。我们项目的代码如下：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The required implementations are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的实现如下：
- en: '`Message`: It is the `enum` defined before, describing all possible notifications
    from the view to the controller.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`：是之前定义的 `enum`，描述了从视图到控制器的所有可能的通知。'
- en: '`Properties`: It is not used in this project. When not used, it must be an
    empty tuple.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Properties`：在这个项目中没有使用。当未使用时，它必须是一个空元组。'
- en: '`create`: It is invoked by the framework to let the controller initialize the
    model. It can use two arguments, but here we are not interested in them, and it
    must return an instance of the model with its initial value. As we want to show
    the number zero at the beginning, we set `value` to `0`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：框架调用它以让控制器初始化模型。它可以使用两个参数，但在这里我们对此不感兴趣，并且它必须返回一个具有初始值的模型实例。因为我们想在开始时显示数字零，我们将
    `value` 设置为 `0`。'
- en: '`update`: It is invoked by the framework any time the user acts on the page
    in some way handled by the view. The two arguments are the mutable model itself
    (`self`) and the notification from the view (`msg`). This method should return
    a value of type `ShouldRender`, but a `bool` value will be good. Returning `true` means
    that the model has been changed, and so a refresh of the view is required. Returning
    `false` means that the model has not been changed, and so a refresh of the view
    would be a waste of time.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：框架在用户以某种方式在页面上进行操作时调用它，该操作由视图处理。两个参数是可变的模型本身（`self`）和来自视图的通知（`msg`）。此方法应返回
    `ShouldRender` 类型的值，但 `bool` 值将很好。返回 `true` 表示模型已更改，因此需要刷新视图。返回 `false` 表示模型未更改，因此刷新视图将是浪费时间。'
- en: 'The `update` method contains a `match` on the message type. The first two message
    types are quite simple:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法包含对消息类型的 `match`。前两种消息类型相当简单：'
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the `Increment` message is notified, the value is incremented. If the `Reset` message
    is notified, the value is zeroed. In both cases, the view must be refreshed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到 `Increment` 消息，则值会增加。如果收到 `Reset` 消息，则值归零。在这两种情况下，视图都必须刷新。
- en: 'The handling of the keypress is a bit more complex:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理按键有点复杂：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `KeyDown` match arm assigns the key pressed to the `s` variable. As we are
    interested only in two possible keys, there is a nested `match` statement on the `s`
    variable. For the two-handled keys (`+` and `0`), the model is updated, and `true`
    is returned to refresh the view. For any other key pressed, nothing is done.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyDown`匹配分支将按下的键分配给`s`变量。由于我们只对两个可能的键感兴趣，因此`s`变量上有嵌套的`match`语句。对于双键（`+`和`0`），更新模型并返回`true`以刷新视图。对于按下的任何其他键，不执行任何操作。'
- en: 'To implement the view part of MVC, the `yew::Renderable` trait must be implemented
    for our model. The only required method is `view`, which gets an immutable reference
    to the model, and returns an object that represents some HTML code, but that is
    capable of reading the model and notifying the controller:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现MVC的视图部分，必须为我们的模型实现`yew::Renderable`特质。唯一需要的方法是`view`，它获取对模型的不可变引用，并返回一个表示某些HTML代码的对象，但该对象能够读取模型并通知控制器：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The body of such a method is constructed with the powerful `yew::html` macro.
    Here is the body of such a macro invocation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主体使用强大的`yew::html`宏构建。以下是此类宏调用的主体：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It looks very similar to the actual HTML code. It is equivalent to the following
    HTML pseudo-code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来非常类似于实际的HTML代码。它等同于以下HTML伪代码：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that at any HTML event, in the HTML pseudo-code, a JavaScript function
    is invoked (here, named `notify`). Instead, in Rust, there is a closure that returns
    a message for the controller. Such a message must have the arguments of the appropriate
    type. While the `onclick` event has no arguments, the `onkeydown` event has one
    argument, captured in the `e` variable, and by calling the `key` method on that
    argument, the pressed key is passed to the controller.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在任何HTML事件中，在HTML伪代码中，都会调用一个JavaScript函数（此处命名为`notify`）。相反，在Rust中，有一个返回给控制器消息的闭包。此类消息必须具有适当类型的参数。虽然`onclick`事件没有参数，但`onkeydown`事件有一个参数，在`e`变量中捕获，并通过调用该参数上的`key`方法，将按下的键传递给控制器。
- en: Also notice in the HTML pseudo-code the `[value]` symbol, which at runtime will
    be replaced by an actual value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意在HTML伪代码中的`[value]`符号，在运行时将被实际值替换。
- en: 'Finally, notice that the body of the macro has three features that differentiate
    it from HTML code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，宏的主体有三个与HTML代码不同的特性：
- en: All the arguments of HTML elements must end with a comma.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML元素的所有参数都必须以逗号结尾。
- en: Any Rust expression can be evaluated inside HTML code, as long as it is enclosed
    in braces.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Rust表达式都可以在HTML代码内部评估，只要它被括号包围。
- en: Literal strings are not allowed in this HTML code, so they must be inserted
    as Rust literals (by including them in braces).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此HTML代码中不允许使用字面字符串，因此必须将其作为Rust字面量（通过在括号中包含它们）插入。
- en: The adder app
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法器应用
- en: Here, we'll see the implementation of the `adder` project, which we already
    saw how to build and use. Only that which differentiates it from the `incr` project
    will be examined.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到`adder`项目的实现，我们已经看到了如何构建和使用它。我们将检查与`incr`项目不同的部分。
- en: 'First of all, there is a problem with the `html` macro expansion recursion
    level. It is so deep that it must be increased using the following directives
    at the beginning of the program:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，存在一个与`html`宏展开递归级别的问题。它非常深，必须在程序开始时使用以下指令增加：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Without them, a compilation error is generated. With more complex views, an
    even larger limit is required. The model contains the following fields:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没有它们，将生成编译错误。对于更复杂的视图，需要更大的限制。模型包含以下字段：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They represent the following, respectively:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它们分别代表以下内容：
- en: The text inserted in the first box (`addend1`).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入到第一个框中的文本（`addend1`）。
- en: The text inserted in the second box (`addend2`).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入到第二个框中的文本（`addend2`）。
- en: The number calculated and to be displayed in the third box, if the calculation
    was performed and was successful, or nothing otherwise.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计算成功并在第三个框中显示计算出的数字，否则不显示。
- en: 'The handled events (that is, the messages) are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的事件（即消息）如下：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'They represent the following, respectively:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它们分别代表以下内容：
- en: Any change to the contents of the first box, with the new value contained in
    the box (`ChangedAddend1`).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对第一个框内容的任何更改，包含在框中的新值（`ChangedAddend1`）。
- en: Any change to the contents of the second box, with its value (`ChangedAddend2`).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对第二个框内容的任何更改，及其值（`ChangedAddend2`）。
- en: A click on the Add button.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“添加”按钮。
- en: 'The `create` function initializes the three fields of the model: the two addends
    are set to empty strings, and the `sum` field is set to `None`. With these initial
    values, no number is displayed in the Sum textbox.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 函数初始化模型的三个字段：两个加数设置为空字符串，`sum` 字段设置为 `None`。使用这些初始值，在总和文本框中不显示任何数字。'
- en: 'The `update` function processes the three possible messages. For the `ComputeSum`
    message, it does the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数处理三种可能的消息。对于 `ComputeSum` 消息，它执行以下操作：'
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `addend1` and `addend2` fields of the model are parsed to convert them into
    numbers. If both conversions are successful, the first arm matches, and so the
    `a1` and `a2` values are added, and their sum is assigned to the `sum` field.
    If some conversion fails, `None` is assigned to the sum field.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的 `addend1` 和 `addend2` 字段被解析以将它们转换为数字。如果两个转换都成功，第一个臂匹配，因此将 `a1` 和 `a2` 的值相加，并将它们的和分配给
    `sum` 字段。如果某些转换失败，将 `None` 分配给 `sum` 字段。
- en: 'The arm regarding the first addend is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一个加数的臂如下所示：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The current value of the textbox is assigned to the `addend1` field of the model,
    and the `sum` field is set to `None`. Similar behavior is performed for a change
    to the other addend.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文本框的值被分配给模型的 `addend1` 字段，并将 `sum` 字段设置为 `None`。对于其他加数的更改，执行类似的行为。
- en: 'Let''s see the most interesting parts of the `view` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `view` 方法中最有趣的部分：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It assigns to a Rust variable a snippet of CSS code. Then, the textbox for
    the first `addend` is created by the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它将一段 CSS 代码片段分配给 Rust 变量。然后，使用以下代码创建第一个 `addend` 的文本框：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that to the `style` attribute, the value of the `numeric` variable is
    assigned. The values of these attributes are just Rust expressions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将 `numeric` 变量的值分配给 `style` 属性。这些属性的值只是 Rust 表达式。
- en: 'The `sum` textbox is created by the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了 `sum` 文本框：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `style` attribute is composed by concatenating the `numeric` string seen
    before with the background color. Such a color is light green if `sum` has a numeric
    value, or yellow if it is `None`. Also, the `value` attribute is assigned using
    an expression, to assign an empty string if `sum` is `None`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 属性是通过连接之前看到的 `numeric` 字符串和背景颜色组成的。如果 `sum` 有数值，则颜色为浅绿色，如果它是 `None`，则颜色为黄色。此外，使用表达式分配
    `value` 属性，如果 `sum` 是 `None`，则分配一个空字符串。'
- en: The login app
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录应用
- en: So far, we have seen that an app contains just one model struct, one `enum`
    of messages, one `create` function, one `update` method, and one `view` method.
    This is good for very simple apps, but with more complex apps, this simple architecture
    becomes unwieldy. There is a need to separate different portions of the app in
    different components, where each component is designed with the MVC pattern and
    so it has its own model, controller, and view.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，一个应用仅包含一个模型结构体、一个消息 `enum`、一个 `create` 函数、一个 `update` 方法和一个 `view`
    方法。这对于非常简单的应用来说很好，但随着应用变得更加复杂，这种简单的架构变得难以管理。需要将应用的不同部分分离到不同的组件中，其中每个组件都按照 MVC
    模式设计，因此它有自己的模型、控制器和视图。
- en: 'Typically, but not necessarily, there is a general component that contains
    the portions of the app that remain the same for all of the app:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，但不一定，有一个通用组件包含应用中所有部分都相同的部分：
- en: A header with a logo, a menu, and the name of the current user
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含标志、菜单和当前用户名的页眉
- en: A footer containing copyright information and contact information
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含版权信息和联系信息的页脚
- en: 'And then in the middle of the page, there is the inner part (also named the *body*,
    although it is not the `body` HTML element). This inner part contains the real
    information of the app and is one of many possible components or forms (or pages):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在页面中间，是内嵌部分（也称为 *body*，尽管它不是 `body` HTML 元素）。这个内嵌部分包含应用的真实信息，是许多可能的组件或表单（或页面）之一：
- en: Let's run the `login` app by typing `cargo web start` in its folder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在其文件夹中键入 `cargo web start` 来运行 `login` 应用。
- en: 'When navigating to `localhost:8000`, the following page appears:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当导航到 `localhost:8000` 时，显示以下页面：
- en: '![](img/bd6d7092-fd8e-49fe-a4db-bb6c4c68ab50.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd6d7092-fd8e-49fe-a4db-bb6c4c68ab50.png)'
- en: There are two horizontal lines. The part above the first line is meant to be
    a header, which must remain for the whole app. The part underneath the second
    line is meant to be a footer, which must remain for the whole app, too. The median
    part is the `Login` component, which appears only when the user must be authenticated.
    This portion will be replaced by other components when the user is authenticated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有两条水平线。第一行之上的部分是作为整个应用程序的头部，必须保持不变。第二行之下的部分是作为整个应用程序的尾部，也必须保持不变。中间部分是“登录”组件，仅在用户需要认证时出现。这部分将在用户认证后由其他组件替换。
- en: 'First of all, let''s see some authentication failures:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一些认证失败的情况：
- en: 'If you click on Log in straightaway, a message box appears saying: User not
    found. The same happens if you type some random characters in the User name textbox.
    The only allowed user names are `susan` and `joe`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您直接点击“登录”，会出现一个消息框，显示：“用户未找到”。如果您在用户名框中输入一些随机字符，也会发生相同的情况。仅允许的用户名是`susan`和`joe`。
- en: If you insert one of the two allowed user names, and then you click on Log in,
    you get the message Invalid password for the specified user.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您插入两个允许的用户名之一，然后点击登录，您将收到“指定用户无效密码”的消息。
- en: 'The same happens if you type some random characters in the Password textbox.
    The only allowed passwords are `xsusan` for the user `susan`, and `xjoe` for the
    user `joe`. If you type `susan` and then `xsusan`, just before clicking on Log
    in, you will see the following:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在密码框中输入一些随机字符，也会发生相同的情况。仅允许的用户密码是用户`susan`的`xsusan`，以及用户`joe`的`xjoe`。如果您输入`susan`然后`xsusan`，在点击登录之前，您将看到以下内容：
- en: '![](img/18689f3c-6ab5-4d13-bcdb-802598f81924.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18689f3c-6ab5-4d13-bcdb-802598f81924.png)'
- en: 'And just after, you will see the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到以下内容：
- en: '![](img/fd96a096-7cb2-475f-80a2-f4b36a4cf74f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd96a096-7cb2-475f-80a2-f4b36a4cf74f.png)'
- en: 'Three things have changed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三件事情发生了变化：
- en: At the right of the label—Current user—the blue text --- has been replaced by
    susan.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签“当前用户”的右侧，蓝色文本---已被替换为`susan`。
- en: At the right of that blue text, the Change User button has appeared.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那个蓝色文本的右侧，出现了“更改用户”按钮。
- en: Between the two horizontal lines, all the HTML elements have been replaced by
    the large text reading Page to be implemented. Of course, this situation would
    represent a case in which the user has been successfully authenticated and is
    using the rest of the app.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两条水平线之间，所有的HTML元素都被大号文本“待实现页面”所替换。当然，这种情况将代表用户已成功认证并正在使用应用程序的其余部分。
- en: 'If you were to click the Change User button, you will get the following page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击“更改用户”按钮，您将看到以下页面：
- en: '![](img/29b734ef-1c56-496b-89ba-712832a89eab.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29b734ef-1c56-496b-89ba-712832a89eab.png)'
- en: It is similar to the first page, but the name susan appears both as Current
    user, and as User name.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它与第一个页面相似，但`susan`的名字既出现在“当前用户”处，也出现在“用户名”处。
- en: Organization of the project
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目组织结构
- en: 'The source code of this project has been split into three files (which you
    will find in the book''s GitHub repository at `Chapter05/login/src/db_access.rs`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的源代码已被拆分为三个文件（您可以在本书的GitHub仓库`Chapter05/login/src/db_access.rs`中找到）：
- en: '`db_access.rs`: Contains a stub of a user directory to handle authentication'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_access.rs`：包含一个用于处理认证的用户目录的存根'
- en: '`main.rs`: Contains the one-line `main` function, and an MVC component that
    handles the header and the footer of the page, and delegates the inner section
    to the authentication component'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.rs`：包含一行`main`函数，以及一个处理页面头部和尾部的MVC组件，并将内部部分委托给认证组件'
- en: '`login.rs`: Contains the MVC component to handle the authentication, to be
    used as an inner section of the main component'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login.rs`：包含用于处理认证的MVC组件，用作主组件的内部部分'
- en: The db_access.rs file
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`db_access.rs`文件'
- en: 'The `db_access` module is a subset of that of the previous chapter. It declares
    a `DbConnection` struct that simulates a connection to a database. Actually, for
    simplicity, it contains just `Vec<User>`, where `User` is an account of the app:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_access`模块是前一章模块的一个子集。它声明了一个`DbConnection`结构体，用于模拟与数据库的连接。实际上，为了简单起见，它只包含`Vec<User>`，其中`User`是应用程序的账户：'
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The definition of the `User` type is this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类型的定义如下：'
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any user of the app has a name, a password, and some privileges. In this simple
    system, there are only two possible privileges:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的任何用户都有一个名字、一个密码和一些权限。在这个简单的系统中，只有两种可能的权限：
- en: '`CanRead`, which means that the user can read all of the database'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanRead`，表示用户可以读取数据库中的所有内容'
- en: '`CanWrite`, which means that the user can change all of the database (that
    is, inserting, updating, and deleting records)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanWrite`，意味着用户可以更改数据库的所有内容（即插入、更新和删除记录）'
- en: 'Two users are wired in:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 连接了两个用户：
- en: '`joe` with the password `xjoe`, capable only of reading from the database'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joe` 用户，密码为 `xjoe`，只能从数据库中读取'
- en: '`susan` with the password `xsusan`, capable of reading and writing the data'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`susan` 用户，密码为 `xsusan`，可以读取和写入数据'
- en: 'The only functions are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个函数：
- en: '`new`, to create a `DbConnection`:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`，用于创建 `DbConnection`：'
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`get_user_by_username`, to get a reference to the user having the specified
    name, or `None` if there is no user with that name:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_user_by_username`，用于获取具有指定名称的用户引用，如果没有用户具有该名称，则为 `None`：'
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course, first, we will create a `DbConnection` object, using the `new` function,
    and then we will get a `User` from that object, using the `get_user_by_username` method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，首先，我们将使用 `new` 函数创建一个 `DbConnection` 对象，然后我们将使用 `get_user_by_username` 方法从该对象中获取一个
    `User`。
- en: The main.rs file
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main.rs` 文件'
- en: 'The `main.rs` file begins with the following declarations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.rs` 文件以以下声明开始：'
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first declaration imports the `login` module, which will be referenced by
    the `main` module. Any inner section module must be imported here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个声明导入了 `login` 模块，该模块将被 `main` 模块引用。任何内部部分模块都必须在这里导入。
- en: The second statement declares all the components that will be used as inner
    sections. Here, we have only the authentication component (`Login`) and a component
    that is not yet implemented (`PersonsList`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个声明声明了所有将用作内部部分的组件。在这里，我们只有认证组件（`Login`）和一个尚未实现的组件（`PersonsList`）。
- en: 'Then, there is the model of the MVC component of the main page:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是主页 MVC 组件的模型：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As a convention, the name of any model ends with `Model`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，任何模型的名称都以 `Model` 结尾：
- en: The first field of the model is the most important one. It represents which
    inner section (or `page`) is currently active.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型的第一个字段是最重要的一个。它表示当前活动的是哪个内部部分（或页面）。
- en: The other fields contain global information, that is, information useful for
    displaying the header, the footer, or that must be shared with the inner components.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他字段包含全局信息，即用于显示页眉、页脚或必须与内部组件共享的信息。
- en: The `current_user` field contains the name of the logged-in user, or `None` if
    no user is logged in.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_user` 字段包含已登录用户的名称，如果没有用户登录，则为 `None`。'
- en: The `can_write` flag is a simplistic description of user privileges; here, both
    users can read, but only one can also write, and so this flag is `true` when they
    are logged in.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`can_write` 标志是对用户权限的简单描述；在这里，两个用户都可以读取，但只有一个也可以写入，因此当它们登录时，此标志为 `true`。'
- en: The `db_connection` field is a reference to the database stub. It must be shared
    with an inner component, and so it is implemented as a reference-counted smart
    pointer to `RefCell`, containing the actual `DbConnection`. Using this wrapping,
    any object can be shared with other components, as long as one thread at a time
    accesses them.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_connection` 字段是对数据库占位符的引用。它必须与内部组件共享，因此它被实现为一个引用计数的智能指针到 `RefCell`，其中包含实际的
    `DbConnection`。使用这种包装，任何对象都可以与其他组件共享，只要一次只有一个线程访问它们。'
- en: 'The possible notifications from the view to the controller are these:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 视图向控制器发送的可能通知如下：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that the footer has no elements that can get input, and for the header,
    there is only the Change User button that can get input, when it is visible. By
    pressing such a button, the `ChangeUserPressed` message is sent.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，页脚没有可以获取输入的元素，而对于页眉，只有当它可见时，Change User 按钮可以获取输入。按下此类按钮时，将发送 `ChangeUserPressed`
    消息。
- en: So, it appears there is no way to send the `LoggedIn` message! Actually, the
    `Login` component can send it to the main component.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来没有发送 `LoggedIn` 消息的方法！实际上，`Login` 组件可以向主组件发送它。
- en: 'The update function of the controller has the following body:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的更新函数具有以下主体：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the `Login` component notifies the main component of successful authentication,
    thus specifying the authenticated user, the main controller sets `PersonsList` as
    the page to go to, saves the name of the newly authenticated user, and extracts
    the privileges from that user.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Login` 组件通知主组件成功认证，从而指定了认证用户时，主控制器将 `PersonsList` 设置为要访问的页面，保存新认证用户的名称，并从该用户中提取权限。
- en: When the Change User button is clicked, the *page to go to* becomes the `Login`
    page. The `view` method contains just an invocation of the `html` macro. Such
    a macro must contain one HTML element, and in this case, it is a `div` element.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'That `div` element contains three HTML elements: a `style` element, a `header`
    element, and a `footer` element. But between the header and the footer, there
    is some Rust code to create the inner section of the main page.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert Rust code inside an `html` macro, there are two possibilities:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Attributes of HTML elements are just Rust code.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any point, a pair of braces encloses Rust code.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, the evaluation of such Rust code must return a value convertible
    to a string through the `Display` trait.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, the evaluation of the Rust code in braces must return an
    HTML element. And how can you return an HTML element from Rust code? Using an
    `html` macro!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: So, the Rust code that implements the `view` method contains an `html` macro
    invocation that contains a block of Rust code, which contains an `html` macro
    invocation, and so on. This recursion is performed at compile time and has a limit
    that can be overridden using the `recursion_limit` Rust attribute.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the header and the inner section contain a `match self.page`
    expression.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the header, it is used to show the Change User button only if the current
    page is not the login page, for which it would be pointless.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'In the inner section, the body of such a statement is the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the current page is `Login`, an invocation to the `html` macro contains
    the `LoginModel:` HTML element. Actually, the HTML language doesn''t have such
    an element type. This is the way to embed another Yew component in the current
    component. The `LoginModel` component is declared in the `login.rs` source file.
    Its construction requires some arguments:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '`current_username` is the name of the current user.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when_logged_in` is a callback that the component should invoke when it has
    performed a successful authentication.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db_connection` is a (reference-counted) copy of the database.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the callback, notice that it receives a user (`u`) as an argument
    and returns the message `LoggedIn` decorated by that user. Sending this message
    to the controller of the main component is the way the `Login` component communicates
    to the main component who the user is that has just logged in.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The login.rs file
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `login` module begins by defining the model of the `Login` component:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This model must be used by the main component, and so it must be public.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Its fields are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`dialog` is a reference to a Yew service, which is a way to ask the framework
    to do something more than implementing the MVC architecture. A dialog service
    is the ability to show message boxes to the user, through the JavaScript engine
    of the browser.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username` and `password` are the values of the text that the user has typed
    in the two textboxes.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when_logged_in` is a possible callback function, to call when a successful
    authentication is completed.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when_logged_in`是一个可能的回调函数，用于在成功认证完成后调用。'
- en: '`db_connection` is a reference to the database.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_connection`是数据库的引用。'
- en: 'The possible notification messages are these:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的通知消息如下：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first two messages mean that the respective fields have changed values,
    and the third message says that the push-button has been pressed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个消息表示相应的字段已更改值，第三个消息表示按钮已被按下。
- en: 'So far, we have seen that this component has a model and some messages, like
    the components we saw before; but now we''ll see that it also has something that
    we''ve never seen:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到这个组件有一个模型和一些消息，就像我们之前看到的组件一样；但现在我们将看到它还有一些我们从未见过的东西：
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This structure represents the arguments that every parent of this component
    must pass to create the component. In this project, there is only one parent of
    the `Login` component, that is, the main component, and that component created
    a `LoginModel`: element having the fields of `LoginProps` as attributes. Notice
    that all the fields are specializations of `Option`: it is required by the Yew
    framework, even if you don''t pass an `Option` as an attribute.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构表示每个父组件创建此组件必须传递的参数。在这个项目中，`Login`组件只有一个父组件，即主组件，该组件创建了一个具有`LoginProps`字段作为属性的`LoginModel`元素。请注意，所有字段都是`Option`的特殊化：即使你不将`Option`作为属性传递，Yew框架也要求这样做。
- en: 'This `LoginProps` type must be used in four points:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`LoginProps`类型必须在四个地方使用：
- en: 'First, it must implement the `Default` trait, to ensure its fields are properly
    initialized when the framework needs an object of this type:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它必须实现`Default`特质，以确保当框架需要此类型的对象时，其字段被正确初始化：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Second, we already saw that the implementation of the `Component` trait for
    the model has to define a `Properties` type. In this case, it must be like so:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们已经看到，为模型实现`Component`特质的实现必须定义一个`Properties`类型。在这种情况下，它必须是这样的：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That is, this type is passed into the implementation of the `Component` trait
    for the `LoginModel` type.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即，这个类型被传递到`LoginModel`类型的`Component`特质的实现中。
- en: 'Third, the `create` function must use its first argument, containing the values
    passed in by the parent component. Here is that function:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，`create`函数必须使用其第一个参数，该参数包含由父组件传递的值。以下是该函数：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All the fields of the model are initialized, but while the `dialog` and `password`
    fields receive default values, the other fields receive a value from the `props`
    object received from the parent component, that is, `MainModel`. As we are sure
    that the `db_connection` field of `props` will be `None`, we call `unwrap` for
    it. Instead, the `current_username` field may be `None`, and so, in that case,
    an empty string is used.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的所有字段都已初始化，但`dialog`和`password`字段接收默认值，而其他字段接收来自父组件接收的`props`对象中的值，即`MainModel`。因为我们确信`props`中的`db_connection`字段将是`None`，所以我们对其调用`unwrap`。相反，`current_username`字段可能是`None`，因此在这种情况下，使用空字符串。
- en: Then there is the `update` function, which is the controller of the `Login`
    component.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`update`函数，它是`Login`组件的控制器。
- en: 'When the user presses the Log in button, the following code is executed:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下登录按钮时，执行以下代码：
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The connection to the database is extracted from `RefCell` using the `borrow`
    method, and then the user with the current name is looked for. If the user is
    found, and if their stored password is the same as that typed by the user, the
    callback kept in the `when_logged_in` field is extracted, and then its `emit` method
    is invoked, passing a copy of the user name as argument. So, the routine passed
    by the parent, that is, the `|u| MainMsg::LoggedIn(u)` closure, is executed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`borrow`方法从`RefCell`中提取数据库连接，然后寻找当前名称的用户。如果找到用户，并且如果他们存储的密码与用户输入的密码相同，则从`when_logged_in`字段中提取回调，然后调用其`emit`方法，传递用户名的副本作为参数。因此，由父组件传递的例程，即`|u|
    MainMsg::LoggedIn(u)`闭包，被执行。
- en: 'In the event of a missing user or mismatching password, a message box is displayed
    using the `alert` method of the dialog service. The controllers that we saw before
    had just two functions: `create` and `update`. This one has another function,
    though; it is the `change` method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户缺失或密码不匹配的情况下，使用对话框服务的`alert`方法显示一个消息框。我们之前看到的控制器只有两个功能：`create`和`update`。但这个还有一个功能；它是`change`方法：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This method allows the parent to re-send to this component updated arguments
    using the `Properties` structure. The `create` method is invoked just one time,
    while the `change` method is invoked any time the parent will need to update the
    arguments to pass to the child component.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许父组件使用 `Properties` 结构重新发送更新后的参数到该组件。`create` 方法只调用一次，而 `change` 方法在父组件需要更新传递给子组件的参数时会被调用。
- en: The view is easy to understand by reading its code and does not require explanation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读其代码，视图很容易理解，并且不需要解释。
- en: The yauth app
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: yauth 应用
- en: The `login` app, presented in the previous section, showed how to create a parent
    component containing one of several possible child components. However, it implemented
    just one child component, the `Login` component. So, in this section, a more complete
    example will be presented, having three different possible child components, corresponding
    to three different pages of a classical web application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中展示的 `login` 应用程序展示了如何创建一个包含多个可能的子组件之一的父组件。然而，它只实现了一个子组件，即 `Login` 组件。因此，在本节中，将展示一个更完整的示例，包含三个不同的可能的子组件，对应于经典
    Web 应用程序的三个不同的页面。
- en: It is named `yauth`, short for **Yew Auth**, as its behavior is almost identical
    to the `auth` project shown in the previous chapter, although, it is completely
    based on the Yew framework, instead of being based on Actix web and Tera.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它被命名为 `yauth`，是 **Yew Auth** 的缩写，因为它的行为几乎与上一章中展示的 `auth` 项目相同，尽管如此，它完全基于 Yew
    框架，而不是基于 Actix web 和 Tera。
- en: Understanding the behavior of the app
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解应用的行为
- en: 'This app is built and launched like the ones in the previous sections, and
    its first page is identical to the first page of the `login` app. Though, if you
    type `susan` as the username and `xsusan` as the password, and then click on the
    Log in button, you''ll see the following page:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用与上一节中的应用构建和启动方式相同，其第一页与 `login` 应用的第一页相同。尽管如此，如果你输入 `susan` 作为用户名，`xsusan`
    作为密码，然后点击登录按钮，你会看到以下页面：
- en: '![](img/dcccef8b-c1b6-4512-bfe5-60f3d53696f4.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcccef8b-c1b6-4512-bfe5-60f3d53696f4.png)'
- en: 'This page and the other page that you will see in this app, and their behavior,
    are almost identical to those of the `auth` app described in the previous chapter.
    The only differences are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本页以及你将在本应用中看到的另一页，以及它们的行为，几乎与上一章中描述的 `auth` 应用程序的行为相同。唯一的区别如下：
- en: Any error message is not shown as red text embedded in the page but as a pop-up
    message box.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何错误信息都不会以红色文本的形式嵌入在页面中，而是以弹出消息框的形式显示。
- en: The header and the footer are implemented by the main component, and they look
    and behave as already described in the previous section of this chapter.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部和底部由主组件实现，它们的外观和行为如本章前述部分所述。
- en: So, we just need to examine the implementation of this app.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要检查此应用的实现。
- en: Organization of the project
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目组织
- en: 'The source code of this project has been split into five files:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的源代码已被拆分为五个文件：
- en: '`db_access.rs`: It contains a stub of a connection to a database, providing
    access to a user directory to handle authentication and to a list of persons;
    it actually contains such data as vectors. It is virtually identical to the file
    with the same name in the `auth` project of the previous chapter. The only relevant
    difference is that the `Serialize` trait is not implemented, because it''s not
    required by the Yew framework.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_access.rs`：它包含了一个连接到数据库的占位符，提供对用户目录的访问以处理身份验证以及人员列表；它实际上包含如向量这样的数据。它与上一章
    `auth` 项目的同名文件几乎相同。唯一的区别是 `Serialize` 特性没有被实现，因为 Yew 框架不需要它。'
- en: '`main.rs`: It contains the one-line `main` function, and an MVC component that
    handles the header and the footer of the page, and delegates the inner section
    to one of the other three components of the app.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.rs`：它包含了一行的 `main` 函数，以及处理页面头部和尾部的 MVC 组件，并将内嵌部分委托给应用的其他三个组件之一。'
- en: '`login.rs`: It contains the MVC component to handle the authentication. It
    is to be used as an inner section of the main component. It is identical to the
    module having the same name in the `login` project.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login.rs`：它包含处理身份验证的 MVC 组件。它应作为主组件的内嵌部分使用。它与 `login` 项目的同名模块相同。'
- en: '`persons_list.rs`: It contains the MVC component to handle the list of persons.
    It is to be used as an inner section of the main component.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persons_list.rs`：它包含处理人员列表的 MVC 组件。它应作为主组件的内嵌部分使用。'
- en: '`one_person.rs`: It contains the MVC component to view, edit, or insert a single
    person; it is to be used as an inner section of the main component.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`one_person.rs`：它包含用于查看、编辑或插入单个人员的MVC组件；它将用作主组件的内嵌部分。'
- en: We will only discuss the files unique to the `yauth` app, as follows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只讨论`yauth`应用独有的文件，如下所述。
- en: The persons_list.rs file
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`persons_list.rs`文件'
- en: 'This file contains the definition of the component to let the user manage the
    list of persons, and so it defines the following struct as a model:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含组件的定义，以便用户管理人员列表，因此它定义以下结构作为模型：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s see what each line in the previous code says:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上一段代码中的每一行都说了什么：
- en: The `dialog` field contains a service to open message boxes.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialog`字段包含打开消息框的服务。'
- en: The `id_to_find` field contains the value typed by the user in the Id textbox
    if the box contains a number, or `None` otherwise.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_to_find`字段包含用户在Id文本框中输入的值，如果框中包含数字，否则为`None`。'
- en: 'The `name_portion` field contains the value contained in the Name portion:
    textbox. In particular, if that box is empty, this field of the model contains
    an empty string. The `filtered_persons` field contains a list of the persons extracted
    from the database using the specified filter. Initially, the filter specifies
    to extract all the persons whose names contain an empty string. Of course, all
    the persons satisfy that filter, and so all the persons in the database are added
    to this vector, though the database is empty, and so this vector is too.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_portion`字段包含Name部分: 文本框中的值。特别是，如果该框为空，则模型中的该字段包含一个空字符串。`filtered_persons`字段包含使用指定过滤器从数据库中提取的人员列表。最初，过滤器指定提取所有名称包含空字符串的人员。当然，所有人员都满足该过滤器，因此数据库中的所有人员都被添加到该向量中，尽管数据库为空，因此该向量也为空。'
- en: The `selected_ids` field contains the IDs of all the listed people whose checkbox
    is set, and so they are selected for further operation.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected_ids`字段包含所有列出的、复选框被设置的人员的ID，因此它们被选中以进行进一步操作。'
- en: The `can_write` field specifies whether the current user has the privilege to
    modify the data.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`can_write`字段指定当前用户是否有修改数据的权限。'
- en: The `go_to_one_person_page` field contains the callback to call to pass to the
    page to view/edit/insert a single person. Such a callback function receives one
    argument, which is the person to view/edit, or `None` to open the page to insert
    a new person.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go_to_one_person_page`字段包含要传递给查看/编辑/插入单个人员的页面的回调。此类回调函数接收一个参数，即要查看/编辑的人员，或`None`以打开插入新人员的页面。'
- en: The `db_connection` field contains a shared reference to the database connection.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db_connection`字段包含对数据库连接的共享引用。'
- en: 'The possible notifications from the view to the controllers are defined by
    this structure:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从视图到控制器的可能通知由该结构定义：
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what we did in the previous code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在上一段代码中做了什么：
- en: The `IdChanged` message must be sent when the text in the Id: textbox is changed.
    Its argument is the new text value of the field.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当Id: 文本框中的文本发生变化时，必须发送`IdChanged`消息。其参数是字段的新文本值。'
- en: The `FindPressed` message must be sent when the Find push-button is clicked.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击查找按钮时，必须发送`FindPressed`消息。
- en: The `PartialNameChanged` message must be sent when the text in the Name portion: textbox
    is changed. Its argument is the new text value of the field.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当Name部分: 文本框中的文本发生变化时，必须发送`PartialNameChanged`消息。其参数是字段的新文本值。'
- en: The `FilterPressed` message must be sent when the Filter push-button is clicked.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击过滤器按钮时，必须发送`FilterPressed`消息。
- en: The `DeletePressed` message must be sent when the Delete Selected Persons push-button
    is clicked.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击删除选中人员按钮时，必须发送`DeletePressed`消息。
- en: The `AddPressed` message must be sent when the Add New Person push-button is
    clicked.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击添加新人员按钮时，必须发送`AddPressed`消息。
- en: The `SelectionToggled` message must be sent when a checkbox in the list of persons
    is toggled (that is, checked or unchecked). Its argument is the ID of the person
    specified by that line of the list.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当列表中的人员复选框被切换（即选中或取消选中）时，必须发送`SelectionToggled`消息。其参数是列表中该行指定的人员的ID。
- en: The `EditPressed` message must be sent when any Edit push-button in the list
    of persons is clicked. Its argument is the ID of the person specified by that
    line of the list.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击列表中任何编辑按钮时，必须发送`EditPressed`消息。其参数是列表中该行指定的人员的ID。
- en: 'Then, the structure of the initialization arguments for the component is defined:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义组件初始化参数的结构：
- en: '[PRE39]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s look at how this works:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的：
- en: Using the `can_write` field, the main component specifies a simple definition
    of the privileges of the current user. A more complex application could have a
    more complex definition of privileges.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `can_write` 字段，主要组件指定了当前用户的权限的简单定义。更复杂的应用程序可能有更复杂的权限定义。
- en: Using the `go_to_one_person_page` field, the main component passes a reference
    to a function, which must be called to go to the page for showing, editing, or
    inserting a single person.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `go_to_one_person_page` 字段，主要组件传递一个函数的引用，必须调用该函数才能转到显示、编辑或插入单个人员的页面。
- en: Using the `db_connection` field, the main component passes a shared reference
    to the database connection.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `db_connection` 字段，主要组件传递对数据库连接的共享引用。
- en: 'The initialization of the `PersonsListProps` struct by implementing the `Default`
    trait and of the `PersonsListModel` struct by implementing the `Component` trait
    is trivial, except for the `filtered_persons` field. Instead of leaving it as
    an empty vector, it is first set as an empty vector, and then modified by the
    following statement:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `Default` 特性初始化 `PersonsListProps` 结构体，以及通过实现 `Component` 特性初始化 `PersonsListModel`
    结构体是微不足道的，除了 `filtered_persons` 字段。它不是将其保留为空向量，而是首先将其设置为空向量，然后通过以下语句进行修改：
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why an empty collection wouldn't be good for filtered_persons
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么空集合对 filtered_persons 来说不是很好
- en: Every time the `PersonsList` page is opened, both from the login page and from
    the `OnePerson` page, the model is initialized by the `create` function, and all
    the user interface elements of the page are initialized using that model.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从登录页面和 `OnePerson` 页面打开 `PersonsList` 页面时，模型都通过 `create` 函数初始化，并且使用该模型初始化页面的所有用户界面元素。
- en: So, if you type something in the `PersonsList` page, and then you go to another
    page, and then you go back to the `PersonsList` page, everything you typed is
    cleared unless you set it in the `create` function.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您在 `PersonsList` 页面上输入某些内容，然后转到另一个页面，然后再返回到 `PersonsList` 页面，除非您在 `create`
    函数中设置它，否则您输入的所有内容都会被清除。
- en: 'Probably, the fact that the Id textbox, the Name portion textbox, or the selected
    persons are cleared is not very annoying, but the fact that the list of persons
    is cleared means that you will get the following behavior:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，Id 文本框、名称部分文本框或所选人员被清除的事实并不非常令人烦恼，但人员列表被清除的事实意味着您将获得以下行为：
- en: You filter the persons to see some persons listed.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您过滤人员以查看一些列出的人员。
- en: You click on the Edit button in the row of one person, to change the name of
    that person, and so you go to the `OnePerson` page.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您点击一个人员的行中的编辑按钮，以更改该人员的名称，然后转到 `OnePerson` 页面。
- en: You change the name and press the Update button, and so you go back to the `PersonsList`
    page.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您更改名称并按下更新按钮，然后返回到 `PersonsList` 页面。
- en: You see the text No persons. instead of the list of persons.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您会看到“无人员”文本，而不是人员列表。
- en: You don't see the person that you have just modified in the `OnePerson` page
    anymore. This is inconvenient.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 `OnePerson` 页面上再也看不到您刚刚修改的人员了。这很不方便。
- en: To see that person listed, you need to set `filtered_persons` to a value containing
    that person. The solution chosen has been to show all the persons existing in
    the database, and this is performed by calling the `get_persons_by_partial_name("")` function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到该人员被列出，您需要将 `filtered_persons` 设置为包含该人员的值。所选择的解决方案是显示数据库中存在的所有人员，这是通过调用
    `get_persons_by_partial_name("")` 函数来执行的。
- en: Now, let's see how the `update` method handles the messages from the view.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `update` 方法如何处理视图的消息。
- en: 'When the `IdChanged` message is received, the following statement is executed:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `IdChanged` 消息时，执行以下语句：
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It tries to store in the model the value of the textbox, or `None` if the value
    is not convertible to a number.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图在模型中存储文本框的值，如果没有可转换的数字，则为 `None`。
- en: 'When the `FindPressed` message is received, the following statement is executed:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `FindPressed` 消息时，执行以下语句：
- en: '[PRE42]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the Id textbox contained a valid number, another message would be sent recursively:
    it is the `EditPressed` message. Pressing the Find button must have the same behavior
    as pressing the Edit button in the row with the same ID contained in the Id textbox,
    and so the message is forwarded to the same function. If there is no ID in the
    text field, a message box is displayed.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Id 文本框包含一个有效的数字，则会递归地发送另一个消息：它是 `EditPressed` 消息。按下查找按钮必须与按下 Id 文本框中包含相同
    ID 的行中的编辑按钮具有相同的行为，因此消息被转发到同一个函数。如果没有在文本字段中输入 ID，则显示一个消息框。
- en: 'When the `PartialNameChanged` message is received, the new partial name is
    just saved in the `name_portion` field of the model. When the `FilterPressed`
    message is received, the following statement is executed:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The connection to the database is encapsulated in a `RefCell` object, which
    is further encapsulated in an `Rc` object. The access inside `Rc` is implicit,
    but to access inside `RefCell`, it is required to call the `borrow` method. Then
    the database is queried to get the list of all the persons whose names contain
    the current name portion. This list is finally assigned to the `filtered_persons`
    field of the model.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `DeletePressed` message is received, the following statement is executed:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following pop-up box is shown for confirmation:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb323eb-f775-451c-b4e4-0c99fd004f03.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: 'If the user clicks on the OK button (or presses *Enter*), then the deletion
    is performed in the following way: a mutable reference is borrowed from the shared
    connection to the database, and for any ID selected through the checkboxes, the
    respective person is deleted from the database.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'The closing of the scope releases the borrowing. Then, a recursive call to
    `update` triggers the `FilterPressed` message, whose purpose is to refresh the
    list of persons shown. Finally, the following message box communicates the completion
    of the operation:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15d80085-c33a-454d-90a2-d56087596ad3.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'When the `AddPressed` message is received, the following code is executed:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, a reference to the `go_to_one_person_page` callback is taken, and then
    it is invoked using the `emit` method. The effect of such an invocation is to
    go to the `OnePerson` page. The argument of `emit` specifies which person will
    be edited on the page. If it is `None`, as in this case, the page is opened in
    insertion mode.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `SelectionToggled` message is received, it specifies an ID of a person,
    but it does not specify whether that person is to be selected or deselected. So,
    the following code is executed:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We want to invert the status of the person on which the user has clicked, that
    is, to select it if it was not selected, and to unselect it if it was selected.
    The `selected_ids` field of the model contains the set of all the selected persons.
    So, if the clicked ID is contained in the set of selected IDs, it is removed from
    this set by calling the `remove` method; otherwise, it is added to the list, by
    calling the `insert` method.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, when the `EditPressed` message is received (specifying the `id` of
    the person to view/change), the following code is executed:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The database is searched for a person with the specified ID. If such a person
    is found, the `go_to_one_person_page` callback is invoked, passing a clone of
    the person found. Otherwise, a message box explains the error. The `change` method
    keeps the fields of the model updated when any property coming from the parent
    component would change.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the view. The messages sent by the view were described when the
    messages were presented. The other interesting aspects of the view are the following
    ones.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The Delete Selected Persons button and the Add New Person button have the attribute `disabled=!self.can_write`.
    This enables such commands only if the user has the privilege to change the data.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The `if !self.filtered_persons.is_empty()` clause causes the table of persons
    to be displayed only if there is at least one person filtered. Otherwise, the
    text No persons. is displayed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the table begins and ends with the following lines:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the required syntax for generating sequences of HTML elements based
    on an iterator.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The `for` keyword is immediately followed by an iterator (in this case, the
    expression `self.filtered_persons.iter()`), followed by the expression `.map(|p|`,
    where `p` is the loop variable. In this way, it is possible to insert into the
    map closure a call to the `html` macro that generates the elements of the sequence.
    In this case, such elements are the lines of the HTML table.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The last noteworthy point is the way to show which persons are selected. Every
    checkbox has the attribute `checked=self.selected_ids.contains(&id),`. The checked
    attribute expects a `bool` value. That expression sets as checked the checkbox
    relative to the persons whose `id` is contained in the list of the selected IDs.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The one_person.rs file
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file contains the definition of the component to let the user view or edit
    the details of one person or to fill in the details and insert a new person. Of
    course, to view the details of an existing record, such details must be passed
    as arguments to the component; instead, to insert a new person, no data must be
    passed to the component.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: This component does not return its changes directly to the parent that created
    it. Such changes are saved to the database, if the user requested that, and the
    parent can retrieve them from the database.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore the model is defined by the following struct:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With the preceding code, we understood the following things:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field contains the value contained in the Id textbox if the box contains
    a number, or `None` otherwise.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field contains the value contained in the Name textbox. In particular,
    if the box is empty, this field of the model contains an empty string.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` field specifies whether the current privileges allow the user
    to change the data or only to see it.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is_inserting` field specifies whether this component has received no data,
    to insert a new person into the database, or whether it has received the data
    of a person, to view or edit them.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `go_to_persons_list_page` field is a callback with no arguments that must
    be invoked by this component when the user closes this page to go to the page
    to manage the list of persons.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field is a shared connection to the database.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, it is pointless to open a page for insertion without allowing the
    user to change the values. So, the possible combinations are the following ones:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion mode**: The `id` field is `None`, the `can_write` field is `true`,
    and the `is_inserting` field is `true`.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editing mode**: The `id` field is `Some`, the `can_write` field is `true`,
    and the `is_inserting` field is `false`.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only mode**: The `id` field is `Some`, the `can_write` field is `false`,
    and the `is_inserting` field is `false`.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible notifications from the view to the controller are defined by the
    following `enum`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s see what happened in the code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: When the user changes the contents of the Name textbox, the `NameChanged` message
    is sent, which also specifies the current contents of that textbox.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the Insert button or on the Update button, the `SavePressed`
    message is sent. To distinguish between the two buttons, the `is_inserting` field
    can be used.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user presses the Cancel button, the `CancelPressed` message is sent.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value of the Id textbox can never be changed during the life of this component,
    and so no message is required for it. The data received from the parent is defined
    by the following structure:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we have the following things to check:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field is `None` in case the parent wants to open the page to let the
    user insert a new person, and contains the ID of an existing person in case the
    page is for viewing or editing the data of that person.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field is the only changeable data of any person. It is an empty string
    if the page is created for inserting a new person. Otherwise, the parent passes
    the current name of the person.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `can_write` field specifies whether the user is allowed to change the displayed
    data. This field should be `true` if the `id` field is `None`.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go_to_persons_list_page` is the callback that will activate the `PersonsList`
    component in the parent.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db_connection` field is the shared database connection.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of the module, there is nothing new. The only thing to stress is
    that the use of conditional expressions based on the `can_write` and `is_inserting` flags
    of the model allows having just one component with a mutant view.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: A web app accessing a RESTful service
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section described a rather complex software architecture, but still
    running only in the user's web browser, after having being served by the site
    where it is installed. This is quite unusual, as most web apps actually communicate
    with some other process. Typically, the same site that provides the frontend app
    also provides a backend service, that is, a web service to let the app access
    shared data residing on the server.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll see a pair of projects that can be downloaded from
    the repository:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '`yclient`: This is an app quite similar to the `yauth` app. Actually, it is
    developed using Yew and Wasm, and it has the same look and behavior as `yauth`;
    though its data, which is the authorized users and the persons stored in the mock
    database, no longer resides in the app itself, but in another app, which is accessed
    through an HTTP connection.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persons_db`: This is the RESTful service that provides access to the data
    for the `yclient` app. It is developed using the Actix web framework, as explained
    in the previous chapter. Even this app does not manage a real database, only a
    mock, in-memory database.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the system, two commands are required: one to run the frontend provider, `yclient`,
    and one to run the web service, `persons_db`.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the frontend provider, go into the `yclient` folder, and type the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After downloading and compiling all the required crates, it will print the
    following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To run the backend, in another console window, go into the `db_persons` folder
    and type the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or, we can use the following command:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Both these commands will end by printing the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now you can use your web browser and navigate to `localhost:8000`. The app that
    will be opened will be quite similar to both the `yauth` app, shown in the previous
    section, and to the `auth` app, shown in the previous chapter.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Let's first see how `persons_db` is organized.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The persons_db app
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app uses the Actix web framework, described in the previous two chapters.
    In particular, this project has some features taken from the `json_db` project,
    described in [Chapter 3](febceb22-18dd-437f-bd27-9895aef47384.xhtml), *Creating
    a REST Web Service*, and some from the `auth` project, described in [Chapter 4](27918752-3cb8-4b2f-9508-a439ad1745ab.xhtml),
    *Creating a Full Server-Side Web App*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll see only the new features that haven''t been described so far.
    The `Cargo.toml` file contains the following new line:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This crate allows the handling of the **Cross-Origin Resource Sharing** (**CORS**)
    checks, usually performed by browsers. When some code running inside a browser
    tries to access an external resource using a network connection, the browser, for
    security reasons, checks whether the addressed host is just the one that provided
    the code that is performing the request. That means that the frontend and the
    backend are actually the same website.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: If the check fails, that is, the frontend app is trying to communicate with
    a different site, the browser sends an HTTP request using the `OPTION` method
    to check whether the site agrees to cooperate with that web app on this resource
    sharing. Only if the response to the `OPTION` request allows the required kind
    of access can the original request be forwarded.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, both the frontend app and the web service run on localhost; though,
    they use different TCP ports: `8000` for the frontend and `8080` for the backend.
    So, they are considered as different origins, and CORS handling is needed. The
    `actix-cors` crate provides features to allow such cross-origin access for backends
    developed using Actix web.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these features is used in the `main` function, as in the following code
    snippet:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This code is a so-called **middleware**, meaning that it will be run for every
    request received by the service, and so it is a piece of software that stays in
    the middle between the client and the server.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The `wrap` method is the one to use to add a piece of middleware. This word
    means that the following code must be *around* every handler, possibly filtering
    both requests and responses.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Such code creates an object of type `Cors` and specifies for it which HTTP methods
    will be accepted.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this web service should be clear to those who have learned what
    has already been described about the Actix web framework. It is a RESTful web
    service that accepts requests as URI paths and queries and returns responses as
    JSON bodies, and for which authentication is provided in any request by the basic
    authentication header.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The API has a new route for the `GET` method and the `/authenticate` path, which
    calls the `authenticate` handler, which is used to get a whole user object with
    the list of their privileges.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how `yclient` is organized.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The yclient app
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app starts from where the `yauth` app left off. The `yauth` apps contain its
    own in-memory database, while the app described here communicates with the `person_db` web
    service to access its database.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Here, we'll see only the new features, with respect to the `yauth` project.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: The imported crates
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Cargo.toml` file contains new lines:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the preceding code, let''s have a look at the following things:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: The `failure` crate is used to encapsulate communication errors.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `serde` and `serde_derive` crates are needed to transfer whole objects
    from server to client, using deserialization. In particular, the whole object
    of the types `Person`, `User`, and `DbPrivilege` are transferred in server responses.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `url` crate is used for encoding information in a URL. In a URL path or
    a URL query, you can easily put only identifiers or integer numbers, such as,
    say, `/person/id/478` or `/persons?ids=1,3,39`, but more complex data, such as
    the name of a person, is not allowed *as is*. You cannot have a URL as `/persons?partial_name=John
    Doe`, because it contains whitespace. In general, you have to encode it in coding
    allowed in a URL, and that is provided by the call to `url::form_urlencoded::byte_serialize`,
    which gets a slice of bytes and returns an iterator generating chars. If you call
    `collect::<String>()` on this iterator, you get a string that can be safely put
    into a web URI.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `base64` crate is used to perform a similar encoding of binary data into
    textual data, but for the header or the body of an HTTP request. In particular,
    it is required to encode usernames and passwords in the basic authentication header.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source files
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source file names are the same as the `yauth` project, except that the `db_access.rs` file
    has been renamed as `common.rs`. Actually, in this project, there is no code required
    to access the database, as access is now performed only by the service. The `common` module
    contains definitions of a constant, two structs, an enum, and a function needed
    by several components.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The changes to the models
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The models of the components have the following changes.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: All the `db_connection` fields have been removed, as the app now does not directly
    access the database. That has become the responsibility of the server.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean `fetching` field has been added. It is set to true when a request
    is sent to the server and reset to false when the response is received, or the
    request has failed. It is not really necessary in this app, but it may be useful
    when using a slower communication (with a remote server) or some more lengthy
    requests. It may be used to show to the user that a request is pending, and also
    to disable other requests in the meantime.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch_service` field has been added to provide the communication feature. The
    `ft` field has been added to contain a reference to the current `FetchTask` object
    during a request, or `Nothing` when no request has already been sent. This field
    is not actually used; this is just a trick to keep the current request alive,
    because otherwise after the request is sent and the `update` function returns,
    the local variables would be dropped.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The `link` field has been added for forwarding to the current model the callback
    that will be called when the response is received.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: The `console` field has been added to provide a way to print to the console
    of the browser, for debugging purposes. In Yew, the `print!` and `println!` macros
    are ineffective, as there is no system console on which to print. But the web
    browser has a console, which is accessed using the `console.log()` JavaScript
    function call. This Yew service provides access to such a feature.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: The `username` and `password` fields have been added to send authentication
    data with any requests.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: But let's see the changes required to the code because of the need to communicate
    with the server.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: A typical client/server request
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For any user command that, in the `yauth` project, required access to the database,
    such access has been removed, and the following changes have been applied, instead.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a user command now sends a request to a web service, and then a response
    from that service must be handled. In our examples, the time between the user
    command and the reception of the response from the service is quite short – just
    a few milliseconds, for the following reasons:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Both client and server run in the same computer, and so the TCP/IP packets actually
    don't exit the computer.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer has nothing else to do.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database is actually a very short memory vector, and so its operations are
    very fast.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though, in a real system, much more time is spent processing a user command
    that causes communication. If everything is good, a command takes only half a
    second, but sometimes it may take several seconds. So, synchronous communication
    is not acceptable. Your app cannot just wait for a response from the server, because
    it would appear to be stuck.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: So, the `FetchService` object of the Yew framework provides an asynchronous
    communication model.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: The controller routine triggered by the user command prepares the request to
    be sent to the server, and also prepares a callback routine, to handle the response
    from the server, and then sends the request, and so the app is free to handle
    other messages.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: When the response comes from the server, the response triggers a message that
    is handled by the controller. The handling of the message invokes the callback
    prepared in advance.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in addition to the messages signaling a user command, other messages have
    been added. Some of them report the reception of a response, that is, the successful
    completion of a request; and others report a failure of the request coming from
    the server, that is, the unsuccessful completion of a request. For example, in
    the `PersonsListModel` component, implemented in the `persons_list.rs` file, the
    following user actions required communication:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the Find button (triggering the `FindPressed` message)
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the Filter button (triggering the `FilterPressed` message)
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the Delete Selected Persons button (triggering the `DeletePressed` message)
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing one of the Edit buttons (triggering the `EditPressed` message)
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For them, the following messages have been added:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadyFilteredPersons(Result<Vec<Person>, Error>)`: This is triggered by the
    `FetchService` instance when a list of filtered persons is received from the service.
    Such a list is contained in a `Vec` of `Person`. This may happen after processing
    the `FilterPressed` message.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadyDeletedPersons(Result<u32, Error>)`: This is triggered by the `FetchService`
    instance when the report that a command to delete some persons has been completed
    by the service. The number of deleted persons is contained in `u32`. This may
    happen after processing the `DeletePressed` message.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadyPersonToEdit(Result<Person, Error>)`: This is sent by `FetchService`
    when the requested `Person` object is received from the service, and so it can
    be edited (or simply displayed). This may happen after processing the `FindPressed` message
    or the `EditPressed` message.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failure(String)`: This is sent by `FetchService` when any of the preceding
    requests have failed as the service returns a failure response.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let''s see the code that handles the `EditPressed` message. Its
    first part is as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s check the working of the code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: First, the `fetching` state is set to `true`, to take note that communication
    is underway.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then a debug message is printed to the console of the browser.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, a callback is prepared to handle the response. To prepare such a callback,
    a *move* closure, that is, a closure that gets ownership of all the variables
    it uses, is passed to the `send_back` function of the `link` object.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that we come here when the user has pressed a button to edit a person
    specified by their ID; and so we need the whole of the person data to display
    it to the user.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: The body of the callback is the code that we want to be executed after receiving
    a response from the server. Such a response, if successful, must contain all the
    data regarding the person we want to edit. So, this closure gets a `Response`
    object from the service. This type is actually parameterized by the possible contents
    of the response. In this project, we always expect a `yew::format::Json` payload
    and such a payload is a `Result`, which always has `failure::Error` as its error
    type. Though, the success type varies depending on the request type. In this particular
    request, we expect a `Person` object as a successful result.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: The body of the closure calls the `into_parts` method on the response to destructure
    the response into the metadata and the data. The metadata is HTTP-specific information,
    while the data is the JSON payload.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Using the metadata, it is possible to check whether the response was successful
    (`meta.status.is_success()`). In such a case, the Yew message `ReadyPersonToEdit(data)`
    is triggered; such a message will handle the response payload. In the event of
    an error, a Yew message of `Failure` is triggered; such a message will display
    the specified error message.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'You could ask: "Why does the callback forward the payload to the Yew framework,
    specifying another message, instead of doing anything that should be done upon
    receipt of the response?"'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that the callback, to be executed out of context by the framework,
    must be the owner of any variable it accesses after its creation, that is, when
    the request is sent, up to the time of its destruction (when the response is received).
    So, it cannot use the model or any other external variable. You cannot even print
    on the console or open an alert box inside such a callback. So you need to asynchronously
    forward the response to a message handler, which will be able to access the model.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the handler of the `EditPressed` message is this:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: First, a web request is prepared, using the `get` method, which uses the `GET`
    HTTP method, and optionally specifying a `body`, which in this case is empty (`Nothing`).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Such a request is enriched with authentication information by a call of the
    `add_auth` common function, and finally, the `fetch` method of the `FetchService`
    object is invoked. This method uses the request and the callback to begin the
    communication with the server. It immediately returns a handle, stored in the
    `ft` field of the model.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Then the control returns to Yew, which can process other messages, until a response
    comes from the server. Such a response will be forwarded to the callback defined
    before.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the handler of the `ReadyPersonToEdit(person)` message, forwarded
    when a person structure is received from the server as a response to the request
    of editing a person by their `id`. Its code is as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, the `fetching` state is set to `false`, to take note that the current
    communication is ended.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Then, if the received person was `None`,  such a value is replaced by a person
    having zero as `id` and an empty string as a name. Of course, it is an invalid
    person.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Then, a reference to the `go_to_one_person_page` field of the model is taken.
    This field can be `None` (in fact, only at the initialization stage), so, if it
    is not defined, nothing is done. This field is a Yew callback to jump to another
    page.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: At last, a debug message is printed, and the callback is invoked using the `emit`
    method. This call receives a copy of the person to display on that page.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the handler of the `Failure(msg)` message, forwarded when an
    error is received from the server. This handler is shared by other requests, as
    it has the same behavior. Its code is as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Again, the fetching state is set to `false` since the communication is ended.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: A debug message is printed, and a message box is opened to show the user the
    error message. As long as such a message box is opened, the component is frozen,
    as no other message can be processed.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: At last, the controller returns `false` to signal that no view needs to be refreshed.
    Notice that the default return value is `true` as, usually, the controller changes
    the model, and so the view must be refreshed as a consequence of that.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how a complete frontend web app can be built using Rust, by using
    the `cargo-web` command, the Wasm code generator, and the Yew framework. Such
    apps are modular and well structured, as they use the Elm Architecture, which
    is a variant of the MVC architectural pattern.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: We created six apps, and we saw how they worked—`incr`, `adder`, `login`, `yauth`,
    `persons_db`, and `yclient`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: In particular, you learned how to build and run a Wasm project. We looked at the
    MVC architectural pattern for building interactive apps. We covered how the Yew
    framework supports the creation of apps implementing an MVC pattern, specifically
    according to the Elm Architecture. We also saw how to structure an app in several
    components and how to keep a common header and footer, while the body of the app
    changes from page to page. And at the end, we learned how to use Yew to communicate
    with a backend app, possibly running on a different computer, packaging data in
    JSON format.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to build a web game using Wasm and the
    Quicksilver framework.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is WebAssembly, and what are its advantages?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the MVC pattern?
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are messages in the Elm Architecture?
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are components in the Yew framework?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are properties in the Yew framework?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you build a web app with a fixed header and footer and change the inner
    section using the Yew framework?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are callbacks in the Yew framework?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you pass a shared object, such as a database connection, between Yew
    components?
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why you must keep in the model a field having type FetchTask, when you communicate
    with a server, even if you don't need to use it?
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you open JavaScript-style alert boxes and confirm boxes using the Yew
    framework?
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yew project can be downloaded from here: [https://github.com/DenisKolodin/yew](https://github.com/DenisKolodin/yew). The
    repository contains a very short tutorial and many examples.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find other info about generating Wasm code from a Rust project at:
    [https://github.com/koute/cargo-web](https://github.com/koute/cargo-web).'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of web development libraries and frameworks: [https://www.arewewebyet.org/](https://www.arewewebyet.org/)
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of game development libraries and frameworks: [https://arewegameyet.com/](https://arewegameyet.com/)
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of programmers' editors and IDEs: [https://areweideyet.com/](https://areweideyet.com/)
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of asynchronous programming libraries: [https://areweasyncyet.rs/](https://areweasyncyet.rs/)
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of GUI development libraries and frameworks: [https://areweguiyet.com/](https://areweguiyet.com/)
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
