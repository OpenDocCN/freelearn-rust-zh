["```rs\n$ curl https://sh.rustup.rs -sSf | sh\ninfo: downloading installer\n\nWelcome to Rust!\n\n[...]\n\nCurrent installation options:\n\n   default host triple: x86_64-unknown-linux-gnu\n     default toolchain: stable\n  modify PATH variable: yes\n\n1) Proceed with installation (default)\n2) Customize installation\n3) Cancel installation\n```", "```rs\ninfo: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'\ninfo: latest update on 2017-07-20, rust version 1.19.0 (0ade33941 2017-07-17)\ninfo: downloading component 'rustc'\n\n[...]\n\n  stable installed - rustc 1.19.0 (0ade33941 2017-07-17)\n\nRust is installed now. Great!\n\nTo get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATH\nenvironment variable. Next time you log in this will be done automatically.\n\nTo configure your current shell run source $HOME/.cargo/env\n```", "```rs\n$ source $HOME/.cargo/env\n# Which is the same as executing the following:\n$ export PATH=\"$HOME/.cargo/bin:$PATH\"\n```", "```rs\n$ cargo -V\ncargo 0.23.0 (61fa02415 2017-11-22)\n$ rustc -V\nrustc 1.22.1 (05e2e1c41 2017-11-22)\n```", "```rs\n$ cargo new --bin hello_world\n     Created binary (application) `hello_world` project\n```", "```rs\n$ tree hello_world/\nhello_world/\n├── Cargo.toml\n└── src\n    └── main.rs\n\n1 directory, 2 files\n```", "```rs\n$ cd hello_world/\n$ cargo run\n   Compiling hello_world v0.1.0 (file:///home/packtpub/projects/hello_world)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.39 secs\n     Running `target/debug/hello_world`\nHello, world!\n```", "```rs\n$ cat src/main.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n```", "```rs\n$ cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n```", "```rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n```", "```rs\nfn main() {\n    let name = \"world\";\n    println!(\"Hello, {}!\", name);\n}\n```", "```rs\nlet name: &str = \"world\";\n```", "```rs\nlet age = 42;\nage += 1;\n```", "```rs\nerror[E0384]: cannot assign twice to immutable variable `age`\n  --> src/main.rs:16:5\n   |\n15 |     let age = 42;\n   |         --- first assignment to `age`\n16 |     age += 1;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n```", "```rs\nlet mut age = 42;\nage += 1;\n```", "```rs\nlet number1 = 24;\nlet number2 = 42;\nif number1 > number2 {\n    println!(\"{} > {}\", number1, number2);\n} else {\n    println!(\"{} <= {}\", number1, number2);\n}\n```", "```rs\nlet minimum =\n    if number1 < number2 {\n        number1\n    } else {\n        number2\n    }; // Don't forget the semi-colon here.\n```", "```rs\nlet mut a = 15;\nlet mut b = 40;\nwhile b != 0 {\n    let temp = b;\n    b = a % b;\n    a = temp;\n}\nprintln!(\"Greatest common divisor of 15 and 40 is: {}\", a);\n```", "```rs\nfn max(a: i32, b: i32) -> i32 {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n```", "```rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n```", "```rs\nlet point = Point {\n    x: 24,\n    y: 42,\n};\nprintln!(\"({}, {})\", point.x, point.y);\n```", "```rs\nprintln!(\"{}\", point);\n```", "```rs\nerror[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied\n --> src/main.rs:7:20\n  |\n7 |     println!(\"{}\", point);\n  |                    ^^^^^ `Point` cannot be formatted with the default formatter; try using `:?` instead if you are using a format string\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `Point`\n  = note: required by `std::fmt::Display::fmt`\n```", "```rs\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nprintln!(\"{:?}\", point);\n```", "```rs\nPoint { x: 24, y: 42 }\n```", "```rs\nprintln!(\"{:#?}\", point);\n```", "```rs\nPoint {\n    x: 24,\n    y: 42\n}\n```", "```rs\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = p1;\nprintln!(\"{}\", p1.x);\n```", "```rs\nerror[E0382]: use of moved value: `p1.x`\n --> src/main.rs:4:20\n  |\n3 |     let p2 = p1;\n  |         -- value moved here\n4 |     println!(\"{}\", p1.x);\n  |                    ^^^^ value used here after move\n  |\n  = note: move occurs because `p1` has type `Point`, which does not implement the `Copy` trait\n```", "```rs\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = &p1;\nprintln!(\"{}\", p1.x);\n```", "```rs\nfn print_point(point: &Point) {\n    println!(\"x: {}, y: {}\", point.x, point.y);\n}\n```", "```rs\nprint_point(&p1);\nprintln!(\"{}\", p1.x);\n```", "```rs\n#[derive(Clone, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n```", "```rs\nfn print_point(point: Point) {\n    println!(\"x: {}, y: {}\", point.x, point.y);\n}\n\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = p1.clone();\nprint_point(p1.clone());\nprintln!(\"{}\", p1.x);\n```", "```rs\nlet num1 = 42;\nlet num2 = num1;\nprintln!(\"{}\", num1);\n```", "```rs\n#[derive(Clone, Copy)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n```", "```rs\nfn print_point(point: Point) {\n    println!(\"x: {}, y: {}\", point.x, point.y);\n}\n\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = p1;\nprint_point(p1);\nprintln!(\"{}\", p1.x);\n```", "```rs\nfn inc_x(point: &mut Point) {\n    point.x += 1;\n}\n```", "```rs\nlet mut p1 = Point { x: 1, y: 2 };\ninc_x(&mut p1);\n```", "```rs\nimpl Point {\n    fn dist_from_origin(&self) -> f64 {\n        let sum_of_squares = self.x.pow(2) + self.y.pow(2);\n        (sum_of_squares as f64).sqrt()\n    }\n}\n```", "```rs\nimpl Point {\n    fn translate(&mut self, dx: i32, dy: i32) {\n        self.x += dx;\n        self.y += dy;\n    }\n}\n```", "```rs\nimpl Point {\n    fn new(x: i32, y: i32) -> Self {\n        Self { x: x, y: y }\n    }\n}\n```", "```rs\nfn new(x: i32, y: i32) -> Self {\n    Self { x, y }\n}\n```", "```rs\nimpl Point {\n    fn origin() -> Self {\n        Point { x: 0, y: 0 }\n    }\n}\n```", "```rs\nlet tuple = (24, 42);\nprintln!(\"({}, {})\", tuple.0, tuple.1);\n```", "```rs\nlet (hello, world) = \"helloworld\".split_at(5);\nprintln!(\"{}, {}!\", hello, world);\n```", "```rs\nenum Expr {\n    Null,\n    Add(i32, i32),\n    Sub(i32, i32),\n    Mul(i32, i32),\n    Div { dividend: i32, divisor: i32 },\n    Val(i32),\n}\n\nlet quotient = Expr::Div { dividend: 10, divisor: 2 };\nlet sum = Expr::Add(40, 2);\n```", "```rs\nfn print_expr(expr: Expr) {\n    match expr {\n        Expr::Null => println!(\"No value\"),\n        Expr::Add(x, y) => println!(\"{}\", x + y),\n        Expr::Sub(x, y) => println!(\"{}\", x - y),\n        Expr::Mul(x, y) => println!(\"{}\", x * y),\n        Expr::Div { dividend: x, divisor: 0 } => println!(\"Divisor \n         is zero\"),\n        Expr::Div { dividend: x, divisor: y } => println!(\"{}\",  \n        x/y),\n        Expr::Val(x) => println!(\"{}\", x),\n    }\n}\n```", "```rs\nfn uppercase(c: u8) -> u8 {\n    match c {\n        b'a'...b'z' => c - 32,\n        _ => c,\n    }\n}\n```", "```rs\nprintln!(\"{}\", uppercase(b'a') as char);\n```", "```rs\nfn is_alphanumeric(c: char) -> bool {\n    match c {\n        'a'...'z' | 'A'...'Z' | '0'...'9' => true,\n        _ => false,\n    }\n}\n```", "```rs\nfn uppercase(c: u8) -> u8 {\n    if let b'a'...b'z' = c {\n        c - 32\n    } else {\n        c\n    }\n}\n```", "```rs\nlet tuple = (24, 42);\nlet (a, b) = tuple;\nprintln!(\"{}, {}\", a, b);\n```", "```rs\ntrait BitSet {\n    fn clear(&mut self, index: usize);\n    fn is_set(&self, index: usize) -> bool;\n    fn set(&mut self, index: usize);\n}\n```", "```rs\nimpl BitSet for u64 {\n    fn clear(&mut self, index: usize) {\n        *self &= !(1 << index);\n    }\n\n    fn is_set(&self, index: usize) -> bool {\n        (*self >> index) & 1 == 1\n    }\n\n    fn set(&mut self, index: usize) {\n        *self |= 1 << index;\n    }\n}\n```", "```rs\nlet mut num = 0;\nnum.set(15);\nprintln!(\"{}\", num.is_set(15));\nnum.clear(15);\n```", "```rs\ntrait BitSet {\n    fn clear(&mut self, index: usize);\n    fn is_set(&self, index: usize) -> bool;\n    fn set(&mut self, index: usize);\n\n    fn toggle(&mut self, index: usize) {\n        if self.is_set(index) {\n            self.clear(index);\n        } else {\n            self.set(index);\n        }\n    }\n}\n```", "```rs\nimpl BitSet for u64 {\n    // The other methods are the same as before.\n\n    fn toggle(&mut self, index: usize) {\n        *self ^= 1 << index;\n    }\n}\n```", "```rs\nuse std::ops::Add;\n\nimpl Add<Point> for Point {\n    type Output = Point;\n\n    fn add(self, point: Point) -> Self::Output {\n        Point {\n            x: self.x + point.x,\n            y: self.y + point.y,\n        }\n    }\n}\n```", "```rs\nlet p1 = Point { x: 1, y: 2 };\nlet p2 = Point { x: 3, y: 4 };\nlet p3 = p1 + p2;\n```", "```rs\nfn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n```", "```rs\nprintln!(\"{}\", max('a', 'z'));\n```", "```rs\nenum Option<T> {\n    Some(T),\n    None,\n}\n```", "```rs\nlet array = [1, 2, 3, 4];\nlet array: [i16; 4] = [1, 2, 3, 4];\n```", "```rs\nlet array = [1u8, 2, 3, 4];\n```", "```rs\nprintln!(\"{}\", array[4]);\n```", "```rs\nthread 'main' panicked at 'index out of bounds: the len is 4 but the index is 4', src/main.rs:5:20\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\nlet array = [0u8; 100];\n```", "```rs\nfn first<T>(slice: &[T]) -> &T {\n    &slice[0]\n}\n```", "```rs\nprintln!(\"{}\", first(&array));\n```", "```rs\nprintln!(\"{}\", first(&array[2..]));\n```", "```rs\nlet array = [1, 2, 3, 4];\nlet mut sum = 0;\nfor element in &array {\n    sum += *element;\n}\nprintln!(\"Sum: {}\", sum);\n```", "```rs\nfn index<T: PartialEq>(slice: &[T], target: &T) -> Option<usize> {\n    for (index, element) in slice.iter().enumerate() {\n        if element == target {\n            return Some(index);\n        }\n    }\n    None\n}\n```", "```rs\nfn min_max(slice: &[i32]) -> Option<(i32, i32)> {\n    if slice.is_empty() {\n        return None;\n    }\n    let mut min = slice[0];\n    let mut max = slice[0];\n    for &element in slice {\n        if element < min {\n            min = element;\n        }\n        if element > max {\n            max = element;\n        }\n    }\n    Some((min, max))\n}\n```", "```rs\nmacro_rules! int_bitset {\n    ($ty:ty) => {\n        impl BitSet for $ty {\n            fn clear(&mut self, index: usize) {\n                *self &= !(1 << index);\n            }\n\n            fn is_set(&self, index: usize) -> bool {\n                (*self >> index) & 1 == 1\n            }\n\n            fn set(&mut self, index: usize) {\n                *self |= 1 << index;\n            }\n        }\n    };\n}\n```", "```rs\nint_bitset!(i32);\nint_bitset!(u8);\nint_bitset!(u64);\n```", "```rs\nmacro_rules! op {\n    (+ $_self:ident : $self_type:ty, $other:ident $expr:expr) => {\n        impl ::std::ops::Add for $self_type {\n            type Output = $self_type;\n\n            fn add($_self, $other: $self_type) -> $self_type {\n                $expr\n            }\n        }\n    };\n    // …\n```", "```rs\n    (- $_self:ident : $self_type:ty, $other:ident $expr:expr) => {\n        impl ::std::ops::Sub for $self_type {\n            type Output = $self_type;\n\n            fn sub($_self, $other: $self_type) -> $self_type {\n                $expr\n            }\n        }\n    };\n}\n```", "```rs\nop!(+ self:Point, other {\n    Point {\n        x: self.x + other.x,\n        y: self.y + other.y,\n    }\n});\n\nop!(- self:Point, other {\n    Point {\n        x: self.x - other.x,\n        y: self.y - other.y,\n    }\n});\n```", "```rs\nmacro_rules! hash {\n    ($( $key:expr => $value:expr ),*) => {{\n        let mut hashmap = ::std::collections::HashMap::new();\n        $(hashmap.insert($key, $value);)*\n        hashmap\n    }};\n}\n```", "```rs\nlet hashmap = hash! {\n    \"one\" => 1,\n    \"two\" => 2\n};\n```", "```rs\nmacro_rules! hash {\n    ($( $key:expr => $value:expr ),*) => {\n        let mut hashmap = ::std::collections::HashMap::new();\n        $(hashmap.insert($key, $value);)*\n        hashmap\n    };\n}\n```", "```rs\nlet hashmap = let mut hashmap = ::std::collections::HashMap::new();\n    hashmap.insert(\"one\", 1);\n    hashmap.insert(\"two\", 2);\n    hashmap;\n```", "```rs\nlet hashmap = {\n    let mut hashmap = ::std::collections::HashMap::new();\n    hashmap.insert(\"one\", 1);\n    hashmap.insert(\"two\", 2);\n    hashmap\n};\n```", "```rs\n$(hashmap.insert($key, $value);)*\n```", "```rs\nlet keys = [$($key),*];\n```", "```rs\nhash! {\n    \"one\" => 1,\n    \"two\" => 2\n}\n```", "```rs\nlet keys = [\"one\", \"two\"];\n```"]