<html><head></head><body>
        

                            
                    <h1 class="header-title">Reliable Integration with Databases</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">Persistent microservices have to store and load data. If you want to keep this data organized and reliable, you should use a database. Rust has third-party crates that support popular databases, and in this chapter, you'll learn about how to use different databases with Rust, including the following: </p>
<ul>
<li>PostgreSQL</li>
<li>MySQL</li>
<li>Redis</li>
<li>MongoDB</li>
<li>DynamoDB</li>
</ul>
<p class="CDPAlignLeft CDPAlign">We will create utilities that will allow you to insert or remove data to and from the database, and to query the data held in the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">In this chapter, you'll need database instances to run our examples. The most effective way to run and work with a database for testing purposes is to use Docker. You can install databases locally, but seeing as we'll also need Docker for the remaining chapters, it's best to install and use it from this chapter.</p>
<p class="CDPAlignLeft CDPAlign">We will use the following official images from Docker Hub:</p>
<ul>
<li><kbd>postgres:11</kbd></li>
<li><kbd>mysql:8</kbd></li>
<li><kbd>redis:5</kbd></li>
<li><kbd>mongo:4</kbd></li>
<li><kbd>amazon/dynamodb-local:latest</kbd></li>
</ul>
<p class="CDPAlignLeft CDPAlign">You can get to know more about these images on the Docker Hub repository pages: <a href="https://hub.docker.com/">https://hub.docker.com/</a>.</p>
<p>We will also use the <kbd>DynamoDB</kbd> database, which is provided as part of Amazon Web Services: <a href="https://aws.amazon.com/dynamodb/">https://aws.amazon.com/dynamodb/</a>.</p>
<p>If you want to interact with databases to check whether our examples work successfully, you'll also have to install the corresponding clients for each database.</p>
<p class="CDPAlignLeft CDPAlign">You can find all of the examples for this chapter in the <kbd>Chapter07</kbd> folder on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PostgreSQL</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">PostgreSQL is a reliable and mature database. In this section, we will explore how to start an instance of this database in a container, and how to connect to it from Rust using third-party crates. We will look at simple interactions with this database, and at the use of connection pools to get extra performance. We will start an instance of the database with Docker and create a tool to add records to a table and to query the list of added records before printing them to a console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a test database</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">To create our database, you can use Docker, which automatically pulls all the necessary layers of the images containing the preinstalled PostgreSQL database. It's important to note that PostgreSQL has official images on Docker Hub, and you should opt to use these instead of unofficial ones, because the latter have a greater risk of malicious updates.</p>
<p class="CDPAlignLeft CDPAlign">We need to start a container with a PostgreSQL database instance. You can do this using the following command:</p>
<pre><strong>docker run -it --rm --name test-pg -p 5432:5432 postgres</strong></pre>
<p class="CDPAlignLeft CDPAlign">What does this command do? It starts a container from the <kbd>postgres</kbd> image (the latest version) and uses port <kbd>5432</kbd> on the localhost to forward it to the inner port, <kbd>5432</kbd>, of the container (that is, the port exposed by the image). We also set a name with the <kbd>--name</kbd> argument. We give the container the name <kbd>test-pg</kbd>. You can use this name later to stop the container. The <kbd>--rm</kbd> flag will remove the anonymous volumes associated with the container when it's stopped. So that we can interact with the database from a Terminal, we've added <kbd>-it</kbd> flags.<br/></p>
<p class="CDPAlignLeft CDPAlign">The database instance will start and print something like the following to the Terminal:</p>
<pre>creating subdirectories ... ok<br/>selecting default max_connections ... 100<br/>selecting default shared_buffers ... 128MB<br/>selecting dynamic shared memory implementation ... posix<br/>creating configuration files ... ok<br/>running bootstrap script ... ok<br/>performing post-bootstrap initialization ... ok<br/>syncing data to disk ... ok<br/>........</pre>
<p class="CDPAlignLeft CDPAlign">The database is now ready for use. You can check it with the <kbd>psql</kbd> client, if you have it locally. The default parameters of the image are as follows:</p>
<pre><strong>psql --host localhost --port 5432 --username postgres</strong></pre>
<p class="CDPAlignLeft CDPAlign">If you don't need the database anymore, you can use the following command to shut it down:</p>
<pre><strong>docker stop test-pg</strong></pre>
<p class="CDPAlignLeft CDPAlign">But don't shut it down yet—let's connect to it with Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple interaction with a database</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The easiest way to interact with a database is to create a single connection directly to the database. Simple interaction is a straightforward database connection that doesn't use connection pools or other abstractions to maximize performance.</p>
<p class="CDPAlignLeft CDPAlign">To connect to a PostgreSQL database, we can use two crates: <kbd>postgres</kbd> or <kbd>r2d2_postgres</kbd>. The first is a generic connection driver. The second, <kbd>r2d2_postgres</kbd>, is a crate for the <kbd>r2d2</kbd> connection pools crate. We will start by using the <kbd>postgres</kbd> crate directly, without a pool from the <kbd>r2d2</kbd> crate, and work on a simple utility to create a table, before adding commands to manipulate the data in that table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding dependencies</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Let's create a new project with all the necessary dependencies. We will create a binary utility for managing users in a database. Create a new binary crate:</p>
<pre><strong>cargo new --bin users</strong></pre>
<p class="CDPAlignLeft CDPAlign">Next, add the dependencies:</p>
<pre><strong>cargo add clap postgres</strong></pre>
<p class="CDPAlignLeft CDPAlign">But wait! Cargo doesn't contain an <kbd>add</kbd> command. I've installed <kbd>cargo-edit</kbd> tool for managing dependencies. You can do this with the following command:</p>
<pre><strong>cargo install cargo-edit</strong></pre>
<p class="CDPAlignLeft CDPAlign">The preceding command installs the <kbd>cargo-edit</kbd> tool. If you don't install it, your local <kbd>cargo</kbd> won't have an <kbd>add</kbd> command. Install the <kbd>cargo-edit</kbd> tool and add the <kbd>postgres</kbd> dependency. You can also add dependencies manually by editing the <kbd>Cargo.toml</kbd> file, but as we are going to create more complex projects, the <kbd>cargo-edit</kbd> tool can be used to save us time.</p>
<p>The Cargo tool can be found here: <a href="https://github.com/killercup/cargo-edit">https://github.com/killercup/cargo-edit</a>. This tool contains three useful commands to manage dependencies: <kbd>add</kbd> to add a dependency, <kbd>rm</kbd> to remove an unnecessary dependency, and <kbd>upgrade</kbd> to upgrade versions of dependencies to their latest versions. Furthermore, with the awesome Edition 2018 of Rust, you don't need to use an <kbd>extern crate ...</kbd> declaration. You can simply add or remove any crates and all of them will be available immediately in every module. But what about if you add a crate that you don't need, and end up forgetting about it? Since the Rust compiler allows unused crates, you can add the following crate-wide attribute, <kbd>#![deny(unused_extern_crates)]</kbd>, to your crate. This is necessary in case you accidentally add a crate that you won't use.</p>
<p class="CDPAlignLeft CDPAlign">Also, add the <kbd>clap</kbd> crate. We need it for parsing arguments for our tool. Add the usages of all the necessary types, as follows:</p>
<pre>extern crate clap;<br/>extern crate postgres;<br/><br/>use clap::{<br/>    crate_authors, crate_description, crate_name, crate_version,<br/>    App, AppSettings, Arg, SubCommand,<br/>};<br/>use postgres::{Connection, Error, TlsMode};</pre>
<p class="CDPAlignLeft CDPAlign">All necessary dependencies have been installed, and our types have been imported, so we can create the first connection to a database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a connection</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Before you can execute any query on a database, you have to establish a connection with the database you started in a container. Create a new <kbd>Connection</kbd> instance with the following command:</p>
<pre>let conn = Connection::connect("postgres://postgres@localhost:5432", TlsMode::None).unwrap();</pre>
<p class="CDPAlignLeft CDPAlign">The created <kbd>Connection</kbd> instance has <kbd>execute</kbd> and <kbd>query</kbd> methods. The first method is used to execute SQL statements; the second is used to query data with SQL. Since we want to manage users, let's add three functions that we'll use with our <kbd>Connection</kbd> instance: <kbd>create_table</kbd>, <kbd>create_user</kbd>, and <kbd>list_users</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">The first function, <kbd>create_table</kbd>, creates a table for users:</p>
<pre>fn create_table(conn: &amp;Connection) -&gt; Result&lt;(), Error&gt; {<br/>    conn.execute("CREATE TABLE users (<br/>                    id SERIAL PRIMARY KEY,<br/>                    name VARCHAR NOT NULL,<br/>                    email VARCHAR NOT NULL<br/>                  )", &amp;[])<br/>        .map(drop)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function uses a <kbd>Connection</kbd> instance to execute a statement to create a <kbd>users</kbd> table. Since we don't need a result, we can simply <kbd>drop</kbd> it with the <kbd>map</kbd> command on <kbd>Result</kbd>. As you can see, we use an immutable reference to a connection, because <kbd>Connection</kbd> contains a reference to a shared struct, so we don't need to change this value to interact with a database.</p>
<p>There are a lot of discussions about which approach to use: immutable references with runtime locks and Mutexes, or mutable references even if we need runtime locks. Some crates use the first approach, while others use the second. In my opinion, it's good to fit your approach to the environment in which it will be called. In some cases, it's more convenient to avoid mutable references, but in most cases, it's safer to require mutability for an interface object, such as <kbd>Connection</kbd> from the <kbd>postgres</kbd> crate. The developers of the crate also have a plan to move to mutable references. You can read more about it here: <a href="https://github.com/sfackler/rust-postgres/issues/346">https://github.com/sfackler/rust-postgres/issues/346</a>.</p>
<p class="CDPAlignLeft CDPAlign">The next function is <kbd>create_user</kbd>:</p>
<pre>fn create_user(conn: &amp;Connection, name: &amp;str, email: &amp;str) -&gt; Result&lt;(), Error&gt; {<br/>    conn.execute("INSERT INTO users (name, email) VALUES ($1, $2)",<br/>                 &amp;[&amp;name, &amp;email])<br/>        .map(drop)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function also uses the <kbd>execute</kbd> method of <kbd>Connection</kbd> to insert a value, but it also adds parameters to a call to fill the provided statement with values (the <kbd>create_table</kbd> function leaves these parameters empty). The result of the execution is dropped and we keep <kbd>Error</kbd> only. You may need the returning value if the request returns an identifier of an inserted record.</p>
<p class="CDPAlignLeft CDPAlign">The last function, <kbd>list_users</kbd>, queries a database to get a list of users from the <kbd>users</kbd> table.</p>
<pre>fn list_users(conn: &amp;Connection) -&gt; Result&lt;Vec&lt;(String, String)&gt;, Error&gt; {<br/>    let res = conn.query("SELECT name, email FROM users", &amp;[])?.into_iter()<br/>        .map(|row| (row.get(0), row.get(1)))<br/>        .collect();<br/>    Ok(res)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function, <kbd>list_users</kbd>, uses the <kbd>query</kbd> method of <kbd>Connection</kbd>. We use a simple <kbd>SELECT</kbd> SQL statement here, convert it into an iterator of rows, and extract pairs of names and email addresses of the users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping with a tool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">We've prepared all queries, so now we can join them in a binary tool with a command-line interface. In the following code, we will parse some parameters with the <kbd>clap</kbd> crate, and run functions to manage users with an established <kbd>Connection</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">Our tool will support three commands. Declare their names as constants:</p>
<pre>const CMD_CREATE: &amp;str = "create";<br/>const CMD_ADD: &amp;str = "add";<br/>const CMD_LIST: &amp;str = "list";</pre>
<p class="CDPAlignLeft CDPAlign">Now, we can create the <kbd>main</kbd> function using the <kbd>clap</kbd> crate to parse our command-line arguments:</p>
<pre>fn main() -&gt; Result&lt;(), Error&gt; {<br/><br/>    let matches = App::new(crate_name!())<br/>        .version(crate_version!())<br/>        .author(crate_authors!())<br/>        .about(crate_description!())<br/>        .setting(AppSettings::SubcommandRequired)<br/>        .arg(<br/>            Arg::with_name("database")<br/>            .short("d")<br/>            .long("db")<br/>            .value_name("ADDR")<br/>            .help("Sets an address of db connection")<br/>            .takes_value(true),<br/>            )<br/>        .subcommand(SubCommand::with_name(CMD_CREATE).about("create users table"))<br/>        .subcommand(SubCommand::with_name(CMD_ADD).about("add user to the table")<br/>                    .arg(Arg::with_name("NAME")<br/>                         .help("Sets the name of a user")<br/>                         .required(true)<br/>                         .index(1))<br/>                    .arg(Arg::with_name("EMAIL")<br/>                         .help("Sets the email of a user")<br/>                         .required(true)<br/>                         .index(2)))<br/>        .subcommand(SubCommand::with_name(CMD_LIST).about("print list of users"))<br/>        .get_matches();<br/>    // Add connection here<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">The <kbd>main</kbd> function returns <kbd>postgres::Error</kbd> in case of failure, because all operations we will do relate to our Postgres database connection. We create a <kbd>clap::App</kbd>  instance here, and add a <kbd>--database</kbd> argument to let users change the address of the connection. We also added three subcommands, <kbd>create</kbd>, <kbd>add</kbd>, and <kbd>list</kbd>, along with extra arguments to the <kbd>add</kbd> command that requires the name and email address of a user so that we can insert this into a database.</p>
<p class="CDPAlignLeft CDPAlign">To create a <kbd>Connection</kbd> instance, we use a database argument to extract a connection URL provided by a user with the <kbd>--db</kbd> command-line argument, and if it isn't provided, we will use the default URL value, <kbd>postgres://postgres@localhost:5432</kbd>:</p>
<pre>let addr = matches.value_of("database")<br/>    .unwrap_or("postgres://postgres@localhost:5432");<br/>let conn = Connection::connect(addr, TlsMode::None)?;</pre>
<p class="CDPAlignLeft CDPAlign">We used a <kbd>Connection::connect</kbd> method with an address, and set the <kbd>TlsMode</kbd> parameter to <kbd>TlsMode::None</kbd>, because we don't use TLS in our demo. We created a <kbd>Connection</kbd> instance named <kbd>conn</kbd> to call our functions to interact with our database.</p>
<p class="CDPAlignLeft CDPAlign">Finally, we can add branches for subcommands:</p>
<pre>match matches.subcommand() {<br/>    (CMD_CREATE, _) =&gt; {<br/>        create_table(&amp;conn)?;<br/>    }<br/>    (CMD_ADD, Some(matches)) =&gt; {<br/>        let name = matches.value_of("NAME").unwrap();<br/>        let email = matches.value_of("EMAIL").unwrap();<br/>        create_user(&amp;conn, name, email)?;<br/>    }<br/>    (CMD_LIST, _) =&gt; {<br/>        let list = list_users(&amp;conn)?;<br/>        for (name, email) in list {<br/>            println!("Name: {:20}    Email: {:20}", name, email);<br/>        }<br/>    }<br/>    _ =&gt; {<br/>        matches.usage(); // but unreachable<br/>    }<br/>}<br/>Ok(())</pre>
<p class="CDPAlignLeft CDPAlign">The first branch matches the <kbd>crate</kbd> subcommand  and creates a table by calling the <kbd>create_table</kbd> function.</p>
<p class="CDPAlignLeft CDPAlign">The second branch is for the <kbd>add</kbd> subcommand. It extracts pairs of required arguments for the name and email of a user, and calls the <kbd>create_user</kbd> function to create a user record with the provided values. We use <kbd>unwrap</kbd> to extract it, because both arguments are required.</p>
<p class="CDPAlignLeft CDPAlign">The penultimate branch handles the <kbd>list</kbd> command and takes a list of users with the <kbd>list_users</kbd> function call. After the value has been taken, it is used in a <kbd>for</kbd> loop to print all the records of the users to the console.</p>
<p class="CDPAlignLeft CDPAlign">The last branch is unreachable because we set <kbd>AppSettings::SubcommandRequired</kbd> to <kbd>clap::App</kbd>, but we leave it in for consistency. It is especially useful if you want to provide a default behavior when a subcommand value hasn't been set.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling and running</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">At the beginning of this chapter, we started an instance of the PostgreSQL database that we will use to check our tool. Compile the example we created with Cargo and print the available subcommands with the following command:</p>
<pre><strong>cargo run -- --helpYou will see the next output:</strong><br/><strong>USAGE:</strong><br/><strong>    users [OPTIONS] &lt;SUBCOMMAND&gt;</strong><br/><strong>FLAGS:</strong><br/><strong>    -h, --help       Prints help information</strong><br/><strong>    -V, --version    Prints version information</strong><br/><strong>OPTIONS:</strong><br/><strong>    -d, --db &lt;ADDR&gt;    Sets an address of db connection</strong><br/><strong>SUBCOMMANDS:</strong><br/><strong>    add       add user to the table</strong><br/><strong>    create    create users table</strong><br/><strong>    help      Prints this message or the help of the given subcommand(s)</strong><br/><strong>    list      print list of users</strong></pre>
<p class="CDPAlignLeft CDPAlign">Cargo looks like a cute tool for managing the database of an application. Let's create a table with it, like so:</p>
<pre><strong>cargo run -- create</strong></pre>
<p class="CDPAlignLeft CDPAlign">This command creates a <kbd>users</kbd> table. If you try to run it again, you will get an error:</p>
<pre>Error: Error(Db(DbError { severity: "ERROR", parsed_severity: Some(Error), code: SqlState("42P07"), message: "relation \"users\" already exists", detail: None, hint: None, position: None, where_: None, schema: None, table: None, column: None, datatype: None, constraint: None, file: Some("heap.c"), line: Some(1084), routine: Some("heap_create_with_catalog") }))</pre>
<p class="CDPAlignLeft CDPAlign">If you check your tables with the <kbd>psql</kbd> client, you will see the table that resides in our database:</p>
<pre><strong>postgres=# \dt</strong><br/><strong>         List of relations</strong><br/><strong> Schema | Name  | Type  |  Owner   </strong><br/><strong>--------+-------+-------+----------</strong><br/><strong> public | users | table | postgres</strong><br/><strong>(1 row)</strong></pre>
<p class="CDPAlignLeft CDPAlign">To add a new user, call the <kbd>add</kbd> subcommand with the following parameters:</p>
<pre><strong>cargo run -- add user-1 user-1@example.com</strong><br/><strong>cargo run -- add user-2 user-2@example.com</strong><br/><strong>cargo run -- add user-3 user-3@example.com</strong></pre>
<p class="CDPAlignLeft CDPAlign">We added three users, which you can see in the list if you enter the <kbd>list</kbd> subcommand:</p>
<pre><strong>cargo run -- list</strong><br/><strong>Name: user-1   Email: user-1@example.com  </strong><br/><strong>Name: user-2   Email: user-2@example.com  </strong><br/><strong>Name: user-3   Email: user-3@example.com </strong> </pre>
<p class="CDPAlignLeft CDPAlign">In the following example, we will use a pool of database connections to add multiple users in parallel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connection pools</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The tool we created uses a single connection to a database. It works fine for a small amount of queries. If you want to run multiple queries in parallel, you'll have to use connection pools. In this section, we improve the tool with the <kbd>import</kbd> command, which imports bulk user data from a CSV file. We will use a <kbd>Pool</kbd> type from the <kbd>r2d2</kbd> crate, add a command that will read users from a file, and execute statements to add users to a table in parallel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">To create a connection pool, we will use the <kbd>r2d2</kbd> crate that can hold multiple connections and provide one for us from the pool. This crate is generic, so you'll need a specific implementation for every database to connect to it. The <kbd>r2d2</kbd> crate can connect to the following databases using adapter crates:</p>
<ul>
<li>PostgreSQL</li>
<li>Redis</li>
<li>MySQL</li>
<li>SQLite</li>
<li>Neo4j</li>
<li>Diesel ORM</li>
<li>CouchDB</li>
<li>MongoDB</li>
<li>ODBC</li>
</ul>
<p class="CDPAlignLeft CDPAlign">For our example, we need the <kbd>r2d2-postgres</kbd> adapter crate to connect to the PostgreSQL database. Add it to our dependencies with the <kbd>r2d2</kbd> crate:</p>
<pre>[dependencies]<br/>clap = "2.32"<br/>csv = "1.0"<br/>failure = "0.1"<br/>postgres = "0.15"<br/>r2d2 = "0.8"<br/>r2d2_postgres = "0.14"<br/>rayon = "1.0"<br/>serde = "1.0"<br/>serde_derive = "1.0"</pre>
<p class="CDPAlignLeft CDPAlign">We also keep the <kbd>postgres</kbd> dependency, and add <kbd>failure</kbd> for error-handling and <kbd>rayon</kbd> to execute SQL statements in parallel. We also added a set of <kbd>serde</kbd> crates to deserialize <kbd>User</kbd> records from the CSV file, along with the <kbd>csv</kbd> crate to read that file.</p>
<p class="CDPAlignLeft CDPAlign">You will be much more comfortable using Rust structs that represent data records in a database. Let's add a <kbd>User</kbd> type that represents a user record in a database with the following struct:</p>
<pre>#[derive(Deserialize, Debug)]<br/>struct User {<br/> name: String,<br/> email: String,<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">Since we have our special <kbd>User</kbd> type, we can improve the <kbd>create_user</kbd> and <kbd>list_users</kbd> functions to use this new type:</p>
<pre>fn create_user(conn: &amp;Connection, user: &amp;User) -&gt; Result&lt;(), Error&gt; {<br/>    conn.execute("INSERT INTO users (name, email) VALUES ($1, $2)",<br/>                 &amp;[&amp;user.name, &amp;user.email])<br/>        .map(drop)<br/>}<br/><br/>fn list_users(conn: &amp;Connection) -&gt; Result&lt;Vec&lt;User&gt;, Error&gt; {<br/>    let res = conn.query("SELECT name, email FROM users", &amp;[])?.into_iter()<br/>        .map(|row| {<br/>            User {<br/>                name: row.get(0),<br/>                email: row.get(1),<br/>            }<br/>        })<br/>        .collect();<br/>    Ok(res)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">It hasn't changed dramatically: we still use the same <kbd>Connection</kbd> type, but we use the fields from the <kbd>User</kbd> struct to fill our <kbd>create</kbd> statements and extract values from our <kbd>get list</kbd> query. The <kbd>create_table</kbd> function has not changed.</p>
<p class="CDPAlignLeft CDPAlign">Add a constant for the <kbd>import</kbd> command:</p>
<pre>const CMD_IMPORT: &amp;str = "import";</pre>
<p class="CDPAlignLeft CDPAlign">Then, add it as a <kbd>SubCommand</kbd> to <kbd>App</kbd>:</p>
<pre>.subcommand(SubCommand::with_name(CMD_IMPORT).about("import users from csv"))</pre>
<p class="CDPAlignLeft CDPAlign">Almost all branches have changed and we should explore those changes. The <kbd>add</kbd> command creates a <kbd>User</kbd> instance to call the <kbd>create_user</kbd> function:</p>
<pre>(CMD_ADD, Some(matches)) =&gt; {<br/>    let name = matches.value_of("NAME").unwrap().to_owned();<br/>    let email = matches.value_of("EMAIL").unwrap().to_owned();<br/>    let user = User { name, email };<br/>    create_user(&amp;conn, &amp;user)?;<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">The <kbd>list</kbd> subcommand returns a list of <kbd>User</kbd> struct instances. We have to take this change into account:</p>
<pre>(CMD_LIST, _) =&gt; {<br/>    let list = list_users(&amp;conn)?;<br/>    for user in list {<br/>        println!("Name: {:20}    Email: {:20}", user.name, user.email);<br/>    }<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">The <kbd>import</kbd> command is more complex, so let's discuss this in more detail in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parallel imports with the rayon crate</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Since we have a pool of connections, we can run multiple requests to a database in parallel. We will read users from a standard input stream in CSV format. Let's add a branch to the <kbd>match</kbd> expression we declared before, for the <kbd>import</kbd> subcommand, and open <kbd>stdin</kbd> with <kbd>csv::Reader</kbd>. After that, we will use the <kbd>deserialize</kbd> method of the reader, which returns an iterator of deserialized instances to our desired type. In our case, we deserialize the CSV data to a list of <kbd>User</kbd> structs and push them to a vector:</p>
<pre>(CMD_IMPORT, _) =&gt; {<br/>    let mut rdr = csv::Reader::from_reader(io::stdin());<br/>    let mut users = Vec::new();<br/>    for user in rdr.deserialize() {<br/>        users.push(user?);<br/>    }<br/>    // Put parallel statements execution here<br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Rayon</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">To run requests in parallel, we'll use the <kbd>rayon</kbd> crate, which provides a parallel iterator with the <kbd>par_iter</kbd> method. The parallel iterator divides a list into separate tasks that run across a pool of threads:</p>
<pre>users.par_iter()<br/>    .map(|user| -&gt; Result&lt;(), failure::Error&gt; {<br/>        let conn = pool.get()?;<br/>        create_user(&amp;conn, &amp;user)?;<br/>        Ok(())<br/>    })<br/>    .for_each(drop);</pre>
<p class="CDPAlignLeft CDPAlign">The parallel iterator returns items much like a traditional iterator. We can get a connection from the pool using the <kbd>Pool::get</kbd> method, and call the <kbd>create_user</kbd> function with a reference to a connection. We also ignore results here, and if any request fails, it will be skipped silently, as in the demonstration, we cannot take care of values that have not been inserted. Since we use multiple connections, we can't use transactions to roll back changes if any statement does fail.</p>
<p>The <kbd>rayon</kbd> crate looks really impressive and simple to use. You may ask: <em>could you use this crate in microservices?</em> The answer is: <em>yes!</em> But remember that to collect data, you have to call the <kbd>for_each</kbd> method, which blocks the current thread until all tasks are completed. If you call it in reactor's context (which we discussed in <a href="ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml"/><a href="ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml">Chapter 5</a>, <em>Understanding Asynchronous Operations with  Futures Crate</em>) in asynchronous <kbd>Future</kbd>, it will block the reactor for a while.</p>
<p class="CDPAlignLeft CDPAlign">In the next section, we will rewrite this example for a MySQL database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">MySQL</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">MySQL is one of the most popular databases, so Rust naturally has crates to interact with it. There are two good crates that I recommend that you use: the <kbd>mysql</kbd> crate and its asynchronous version, the <kbd>mysql_async</kbd> crate.</p>
<p class="CDPAlignLeft CDPAlign">In this section, we'll rewrite the previous example of managing users with support for a MySQL database. We'll also bootstrap a local instance of the database in a container, and create a command-line utility that connects to a database instance, sends queries to create table, and allows us to add and remove users. We will use the latest example for PostgreSQL, which uses the <kbd>r2d2</kbd> pool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database for tests</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">To bootstrap the database, we also will use a Docker image. You can install MySQL locally, but a container is a more flexible approach that doesn't clog the system, and you can easily start an empty database for testing purposes in seconds.</p>
<p class="CDPAlignLeft CDPAlign">There is an official image, <kbd>mysql</kbd>, of the MySQL database that you can find here: <a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a>. You can load and run the container using these images with the following command:</p>
<pre><strong>docker run -it --rm --name test-mysql -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=test -p 3306:3306 mysql</strong></pre>
<p class="CDPAlignLeft CDPAlign">There are two necessary parameters that you can set with environment variables. First, the <kbd>MYSQL_ROOT_PASSWORD</kbd> environment variable sets a password for the root user. Second, the <kbd>MYSQL_DATABASE</kbd> environment variable sets the name of a default database that will be created on the first start of a container. We named our container <kbd>test-mysql</kbd> and forwarded the local port <kbd>3306</kbd> to port <kbd>3306</kbd> inside our container.</p>
<p class="CDPAlignLeft CDPAlign">To make sure that our container has started, you can use the <kbd>mysql</kbd> client, if it's installed locally:</p>
<pre><strong>mysql -h 127.0.0.1 -P 3306 -u root -p test</strong></pre>
<p class="CDPAlignLeft CDPAlign">The preceding command connects to <kbd>127.0.0.1</kbd> (to avoid using sockets) on port <kbd>3306</kbd>, with user as <kbd>root</kbd>. The <kbd>-p</kbd> argument asks for a password for the connection. We set a password for our testing container because the database images require it.</p>
<p class="CDPAlignLeft CDPAlign">Our database is ready to use. You can also stop it with the following command:</p>
<pre><strong>docker stop test-mysql</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting with the r2d2 adapter</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">In the previous section, we used a connecting pool from the <kbd>r2d2</kbd> crate with a PostgreSQL database. There is also a connection manager for MySQL in the <kbd>r2d2-mysql</kbd> crate that allows you to use a MySQL connection with the <kbd>r2d2</kbd> crate. The <kbd>r2d2-mysql</kbd> crate is based on the <kbd>mysql</kbd> crate. Using the pool is also simple, just as we did for the PostgreSQL database, but here, we use the <kbd>MysqlConnectionManager</kbd> as a type parameter for <kbd>r2d2::Pool</kbd>. Let's modify all functions with queries to use a pool from our MySQL database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding dependencies</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">First, we have to add dependencies to establish a connection to MySQL. We use all the same dependencies as in the previous example, but have replaced <kbd>postgres</kbd> with the <kbd>mysql</kbd> crate, and <kbd>r2d2_postgres</kbd> with the <kbd>r2d2_mysql</kbd> crate:</p>
<pre>mysql = "14.1"<br/>r2d2_mysql = "9.0"</pre>
<p class="CDPAlignLeft CDPAlign">We still need the <kbd>csv</kbd>, <kbd>rayon</kbd>, <kbd>r2d2</kbd>, and <kbd>serde</kbd> family crates.</p>
<p class="CDPAlignLeft CDPAlign">You also have to declare other types to use them in the code, as follows:</p>
<pre>use mysql::{Conn, Error, Opts, OptsBuilder};<br/>use r2d2_mysql::MysqlConnectionManager;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Database interaction functions</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Now, we can replace our <kbd>Connection</kbd> instance from the <kbd>postgres</kbd> crate with <kbd>Conn</kbd> from the <kbd>mysql</kbd> crate to provide our interaction functions. The first function, <kbd>create_table</kbd>, uses a mutable reference to a <kbd>Conn</kbd> instance:</p>
<pre>fn create_table(conn: &amp;mut Conn) -&gt; Result&lt;(), Error&gt; {<br/>    conn.query("CREATE TABLE users (<br/>                    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,<br/>                    name VARCHAR(50) NOT NULL,<br/>                    email VARCHAR(50) NOT NULL<br/>                  )")<br/>        .map(drop)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">Also, we used the <kbd>query</kbd> method of the <kbd>Conn</kbd> connection object to send a query. This method doesn't expect parameters. We still ignore the successful result of a query and <kbd>drop</kbd> it with <kbd>map</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">The next function, <kbd>create_user</kbd>, has transformed into the following form:</p>
<pre>fn create_user(conn: &amp;mut Conn, user: &amp;User) -&gt; Result&lt;(), Error&gt; {<br/>     conn.prep_exec("INSERT INTO users (name, email) VALUES (?, ?)",<br/>                  (&amp;user.name, &amp;user.email))<br/>         .map(drop)<br/> }</pre>
<p class="CDPAlignLeft CDPAlign">We use the <kbd>prep_exec</kbd> method of <kbd>Conn</kbd>, which expects a tuple of parameters that we have extracted from <kbd>User</kbd> struct fields. As you can see, we used the <kbd>?</kbd> char to specify where to insert the value.</p>
<p class="CDPAlignLeft CDPAlign">The last function, <kbd>list_users</kbd>, collects users from a query. It's more complex than the version for PostgreSQL. We used the <kbd>query</kbd> method which returns a <kbd>QueryResult</kbd> type that implements the <kbd>Iterator</kbd> trait. We use this property to convert the result in to an iterator, and try to fold values to a vector in the <kbd>try_fold</kbd> method of the <kbd>Iterator</kbd> implementation:</p>
<pre>fn list_users(conn: &amp;mut Conn) -&gt; Result&lt;Vec&lt;User&gt;, Error&gt; {<br/>    conn.query("SELECT name, email FROM users")?<br/>        .into_iter()<br/>        .try_fold(Vec::new(), |mut vec, row| {<br/>            let row = row?;<br/>            let user = User {<br/>                name: row.get_opt(0).unwrap()?,<br/>                email: row.get_opt(1).unwrap()?,<br/>            };<br/>            vec.push(user);<br/>            Ok(vec)<br/>        })<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">For the <kbd>try_fold</kbd> method call, we provide a closure that expects two arguments: the first is a vector that we pass with the <kbd>try_fold</kbd> call, while the second is a <kbd>Row</kbd> instance. We use <kbd>try_fold</kbd> to return <kbd>Error</kbd> if any row conversion to user fails.</p>
<p class="CDPAlignLeft CDPAlign">We use the <kbd>get_opt</kbd> method of the <kbd>Row</kbd> object to get a value of a corresponding type, and use the <kbd>?</kbd> operator to extract it from a result, or return <kbd>Error</kbd> with <kbd>try_fold</kbd>. In every iteration, we return a vector with a new, appended value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a connection pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">We will reuse the arguments parser from the previous example, but will rewrite the code that establish a connection, because we're using MySQL instead of PostgreSQL now. First, we replaced the database link with the <kbd>mysql</kbd> scheme. We will use the same parameters for the connection as those that we used to bootstrap the MySQL server instance.</p>
<p class="CDPAlignLeft CDPAlign">We convert the address string to the <kbd>Opts</kbd> - options of a connections, the type of mysql crate that's used to set parameters for connections. But <kbd>MysqlConnectionManager</kbd> expects us to provide an <kbd>OptsBuilder</kbd> object. Look at the following code:</p>
<pre>let addr = matches.value_of("database")<br/>    .unwrap_or("mysql://root:password@localhost:3306/test");<br/>let opts = Opts::from_url(addr)?;<br/>let builder = OptsBuilder::from_opts(opts);<br/>let manager = MysqlConnectionManager::new(builder);<br/>let pool = r2d2::Pool::new(manager)?;<br/>let mut conn = pool.get()?;</pre>
<p class="CDPAlignLeft CDPAlign">Now, we can create <kbd>MysqlConnectionManager</kbd> using <kbd>builder</kbd>, and we can create <kbd>r2d2::Pool</kbd> with a <kbd>manager</kbd> instance. We also get a mutable <kbd>conn</kbd> reference to a connection to provide it for subcommands.</p>
<p class="CDPAlignLeft CDPAlign">The good news is that it's enough to start. We don't need to change anything in our branches, except the type of reference. Now, we have to pass a mutable reference to the connection:</p>
<pre>(CMD_CRATE, _) =&gt; {<br/>    create_table(&amp;mut conn)?;<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">Try to start and check how the tool works. We will provide it a CSV file with content in the following format:</p>
<pre>name,email<br/>user01,user01@example.com<br/>user02,user02@example.com<br/>user03,user03@example.com</pre>
<p class="CDPAlignLeft CDPAlign">If you want to check whether the database has really changed, try importing user data from our CSV file:</p>
<pre><strong>cargo run -- import &lt; users.csv</strong></pre>
<p class="CDPAlignLeft CDPAlign">You can use the <kbd>mysql</kbd> client to print the <kbd>users</kbd> table:</p>
<pre><strong>mysql&gt; SELECT * FROM users;</strong><br/><strong>+----+--------+--------------------+</strong><br/><strong>| id | name   | email              |</strong><br/><strong>+----+--------+--------------------+</strong><br/><strong>|  1 | user01 | user01@example.com |</strong><br/><strong>|  2 | user03 | user03@example.com |</strong><br/><strong>|  3 | user08 | user08@example.com |</strong><br/><strong>|  4 | user06 | user06@example.com |</strong><br/><strong>|  5 | user02 | user02@example.com |</strong><br/><strong>|  6 | user07 | user07@example.com |</strong><br/><strong>|  7 | user04 | user04@example.com |</strong><br/><strong>|  8 | user09 | user09@example.com |</strong><br/><strong>|  9 | user10 | user10@example.com |</strong><br/><strong>| 10 | user05 | user05@example.com |</strong><br/><strong>+----+--------+--------------------+</strong><br/><strong>10 rows in set (0.00 sec)</strong></pre>
<p class="CDPAlignLeft CDPAlign">It works! As you can see, users were added in an unpredictable order, because we used multiple connections and real concurrency. Now you have knowledge of how to use SQL databases. It's time to look at interacting with NoSQL databases through the <kbd>r2d2</kbd> crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Redis</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">When writing microservices, you may sometimes need a data store that can keep values by keys; for example, if you want to store session, you can store a protected identifier of the session and keep additional information about users in a persistent cache. It's not a problem if a session's data is lost; on the contrary, it is a best practice to clean sessions periodically in case a user's session identifier is stolen.</p>
<p class="CDPAlignLeft CDPAlign">Redis is a popular in-memory data structure store for this use case. It can be used as a database, as a message broker, or as a cache. In the following section, we will run a Redis instance with Docker and create a command-line tool that helps manage a users' sessions in Redis.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bootstrap database for tests</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Redis has an official image, <kbd>redis</kbd>, on Docker Hub. To create and run a container, use the following command:</p>
<pre><strong>docker run -it --rm --name test-redis -p 6379:6379 redis</strong></pre>
<p class="CDPAlignLeft CDPAlign">This command runs a container from the <kbd>redis</kbd> image with the name <kbd>test-redis</kbd>, and forwards local port <kbd>6379</kbd> to the internal port <kbd>6379</kbd> of the container.</p>
<p class="CDPAlignLeft CDPAlign">An interesting fact about Redis is that it uses a very plain and simple interaction protocol. You can even use <kbd>telnet</kbd> to interact with Redis:</p>
<pre>telnet 127.0.0.1 6379<br/>Trying 127.0.0.1...<br/>Connected to 127.0.0.1.<br/>Escape character is '^]'.<br/>SET session-1 "Rust"<br/>+OK<br/>GET session-1<br/>$4<br/>Rust<br/>^]</pre>
<p class="CDPAlignLeft CDPAlign">The native client is more comfortable to use, but it expects the same commands as the raw protocol.</p>
<p class="CDPAlignLeft CDPAlign">To shut down a container running Redis, use this command:</p>
<pre><strong>docker stop test-redis</strong></pre>
<p class="CDPAlignLeft CDPAlign">Let's create a tool to manage sessions in Redis.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a connection pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">We have started a Redis instance in a Docker container, so now, we can start creating a command-line tool to allow us to connect to that database instance and put some information into it. This utility will be different from the ones we created for PostgreSQL and MySQL, because Redis doesn't use the SQL language. We will use specific API methods that are available in Redis.</p>
<p class="CDPAlignLeft CDPAlign">In this section, we will create a new binary crate and add functions that set or get data from Redis using <kbd>r2d2::Pool</kbd>. After this, we will call them in response to subcommands that a user specified as command-line arguments for the command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependencies</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Create a new binary crate and add all of the necessary dependencies to the <kbd>Cargo.toml</kbd> file of that crate:</p>
<pre>[dependencies]<br/>clap = "2.32"<br/>failure = "0.1"<br/>r2d2 = "0.8"<br/>r2d2_redis = "0.8"<br/>redis = "0.9"</pre>
<p>We added the dependencies that we used in the previous examples of this chapter—<kbd>clap</kbd>, <kbd>failure</kbd>, and <kbd>r2d2</kbd>. Also, we need the <kbd>redis</kbd> and <kbd>r2d2_redis</kbd> crates, which contain a connection manager for Redis so that we can use it with <kbd>Pool</kbd> from the <kbd>r2d2</kbd> crate.</p>
<p class="CDPAlignLeft CDPAlign">Next, let's import the types we need to create a tool:</p>
<pre>use clap::{<br/>    crate_authors, crate_description, crate_name, crate_version,<br/>    App, AppSettings, Arg, SubCommand,<br/>};<br/>use redis::{Commands, Connection, RedisError};<br/>use r2d2_redis::RedisConnectionManager;<br/>use std::collections::HashMap;</pre>
<p>Note the usage of some types. We imported <kbd>Connection</kbd> as a main connection type, which we will use to connect to a Redis instance. We also imported <kbd>RedisConnectionManager</kbd> from the <kbd>r2d2_redis</kbd> crate. This type allows <kbd>Pool</kbd> to create new connections. The last thing you should note is the <kbd>Command</kbd> trait. This trait contains methods that reflect the Redis client API. The names of methods are the same (but in lowercase), as you can see in the Redis protocol. We tested it manually in a previous section. The <kbd>Command</kbd> trait, implemented by a <kbd>Connection</kbd> struct, allows you to call methods of the Redis API.</p>
<p>Redis supports a lot of commands. You can find a full list at <a href="https://redis.io/commands">https://redis.io/commands</a>. The <kbd>redis</kbd> crate provides most of them as methods of the <kbd>Command</kbd> trait.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding commands and interaction functions</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The tool that we are creating for Redis will support three commands:</p>
<ul>
<li><kbd>add</kbd> - adds a new session record</li>
<li><kbd>remove</kbd> - removes a session record by key (that is, by username)</li>
<li><kbd>list</kbd> - prints all session records</li>
</ul>
<p class="CDPAlignLeft CDPAlign">We need constants for the name of every subcommand to prevent mistakes in strings in the code:</p>
<pre>const SESSIONS: &amp;str = "sessions";<br/>const CMD_ADD: &amp;str = "add";<br/>const CMD_REMOVE: &amp;str = "remove";<br/>const CMD_LIST: &amp;str = "list";</pre>
<p class="CDPAlignLeft CDPAlign">This list also contains the <kbd>SESSION</kbd> constant as the name of the <kbd>HashMap</kbd> in Redis. Now, we can declare functions to manipulate session data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data manipulation functions</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Our example needs three functions. The first function, <kbd>add_session</kbd>, adds an association between the token and user ID:</p>
<pre>fn add_session(conn: &amp;Connection, token: &amp;str, uid: &amp;str) -&gt; Result&lt;(), RedisError&gt; {<br/>    conn.hset(SESSIONS, token, uid)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function only calls the <kbd>hset</kbd> method of a <kbd>Connection</kbd> and sets the <kbd>uid</kbd> value by the <kbd>token</kbd> key in the <kbd>SESSIONS</kbd> map. It returns <kbd>RedisError</kbd> if something is wrong with a set operation.</p>
<p class="CDPAlignLeft CDPAlign">The next function, <kbd>remove_session</kbd>, is also pretty simple and calls the <kbd>hdel</kbd> method of <kbd>Connection</kbd>:</p>
<pre>fn remove_session(conn: &amp;Connection, token: &amp;str) -&gt; Result&lt;(), RedisError&gt; {<br/>    conn.hdel(SESSIONS, token)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function deletes a record with the <kbd>token</kbd> key from the <kbd>SESSIONS</kbd> map.</p>
<p class="CDPAlignLeft CDPAlign">The last function, <kbd>list_sessions</kbd>, returns all token-uid pairs as a <kbd>HashMap</kbd> instance from the <kbd>SESSION</kbd> map. It uses the <kbd>hgetall</kbd> method of <kbd>Connection</kbd>, which calls the <kbd>HGETALL</kbd> method in Redis:</p>
<pre>fn list_sessions(conn: &amp;Connection) -&gt; Result&lt;HashMap&lt;String, String&gt;, RedisError&gt; {<br/>     conn.hgetall(SESSIONS)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">As you can see, all functions map to raw Redis commands, which looks pretty simple. But all functions do a good job in the background too, converting values to their corresponding Rust types.</p>
<p class="CDPAlignLeft CDPAlign">Now, we can create an arguments parser for the session tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing arguments</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Since our command supports three subcommands, we have to add them to a <kbd>clap::App</kbd> instance:</p>
<pre>let matches = App::new(crate_name!())<br/>    .version(crate_version!())<br/>    .author(crate_authors!())<br/>    .about(crate_description!())<br/>    .setting(AppSettings::SubcommandRequired)<br/>    .arg(<br/>        Arg::with_name("database")<br/>        .short("d")<br/>        .long("db")<br/>        .value_name("ADDR")<br/>        .help("Sets an address of db connection")<br/>        .takes_value(true),<br/>        )<br/>    .subcommand(SubCommand::with_name(CMD_ADD).about("add a session")<br/>                .arg(Arg::with_name("TOKEN")<br/>                     .help("Sets the token of a user")<br/>                     .required(true)<br/>                     .index(1))<br/>                .arg(Arg::with_name("UID")<br/>                     .help("Sets the uid of a user")<br/>                     .required(true)<br/>                     .index(2)))<br/>    .subcommand(SubCommand::with_name(CMD_REMOVE).about("remove a session")<br/>                .arg(Arg::with_name("TOKEN")<br/>                     .help("Sets the token of a user")<br/>                     .required(true)<br/>                     .index(1)))<br/>    .subcommand(SubCommand::with_name(CMD_LIST).about("print list of sessions"))<br/>    .get_matches();</pre>
<p class="CDPAlignLeft CDPAlign">As in previous examples, this can also use the <kbd>--database</kbd> argument with a link to a Redis connection. It supports two subcommands. The <kbd>add</kbd> subcommand expects a session <kbd>TOKEN</kbd> and the <kbd>UID</kbd> of the user. The <kbd>remove</kbd> command expects a session <kbd>TOKEN</kbd> only to remove it from a map. The <kbd>list</kbd> command doesn't expect any parameters and prints a list of sessions.</p>
<p class="CDPAlignLeft CDPAlign">Imagine the structure of data in this example as a cache for sessions that holds associations between <kbd>token</kbd> and <kbd>uid</kbd>. After authorization, we can send the token as a secure cookie and extract the user's <kbd>uid</kbd> for the provided token for every microservice to achieve loose coupling between microservices. We will explore this concept in detail later.</p>
<p class="CDPAlignLeft CDPAlign">Now, we are ready to connect to Redis with <kbd>r2d2::Pool</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting to Redis</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The <kbd>r2d2</kbd> connection to Redis looks similar to other databases:</p>
<pre>let addr = matches.value_of("database")<br/>    .unwrap_or("redis://127.0.0.1/");<br/>let manager = RedisConnectionManager::new(addr)?;<br/>let pool = r2d2::Pool::builder().build(manager)?;<br/>let conn = pool.get()?;</pre>
<p class="CDPAlignLeft CDPAlign">We get the address from the <kbd>--database</kbd> argument, but if it isn't set, we will use the default value, <kbd>redis://127.0.0.1/</kbd>. After that, we will create a new <kbd>RedisConnectionManager</kbd> instance and pass it to the <kbd>Pool::new</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing subcommands</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">We use the structure of branches to match subcommands from our previous examples:</p>
<pre>match matches.subcommand() {<br/>    (CMD_ADD, Some(matches)) =&gt; {<br/>        let token = matches.value_of("TOKEN").unwrap();<br/>        let uid = matches.value_of("UID").unwrap();<br/>        add_session(&amp;conn, token, uid)?;<br/>    }<br/>    (CMD_REMOVE, Some(matches)) =&gt; {<br/>        let token = matches.value_of("TOKEN").unwrap();<br/>        remove_session(&amp;conn, token)?;<br/>    }<br/>    (CMD_LIST, _) =&gt; {<br/>        println!("LIST");<br/>        let sessions = list_sessions(&amp;conn)?;<br/>        for (token, uid) in sessions {<br/>            println!("Token: {:20}   Uid: {:20}", token, uid);<br/>        }<br/>    }<br/>    _ =&gt; { matches.usage(); }<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">For the <kbd>add</kbd> subcommand, we extract the <kbd>TOKEN</kbd> and <kbd>UID</kbd> values from arguments and pass them to the <kbd>add_session</kbd> function with a reference to a <kbd>Connector</kbd>. For the <kbd>remove</kbd> subcommand, we extract only the <kbd>TOKEN</kbd> value and call the <kbd>remove_session</kbd> function with its corresponding parameters. For the <kbd>list</kbd> subcommand, we call the <kbd>list_session</kbd> function as is, because we don't need any extra parameters to get all values from a map. This returns a vector of pairs. The first item of the pair contains <kbd>token</kbd>, and the second contains <kbd>uid</kbd>. We print the values using a fixed width specifier of <kbd>{:20}</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing our Redis example</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Let's compile and test the tool. We will add three sessions of users:</p>
<pre><strong>cargo run -- add 7vQ2MhnRcyYeTptp a73bbfe3-df6a-4dea-93a8-cb4ea3998a53</strong><br/><strong>cargo run -- add pTySt8FI7TIqId4N 0f3688be-0efc-4744-829c-be5d177e0e1c</strong><br/><strong>cargo run -- add zJx3mBRpJ9WTkwGU f985a744-6648-4d0a-af5c-0b71aecdbcba</strong></pre>
<p class="CDPAlignLeft CDPAlign">To print the list, run the <kbd>list</kbd> command:</p>
<pre><strong>cargo run -- list</strong></pre>
<p class="CDPAlignLeft CDPAlign">With this, you will see all the sessions you have created:</p>
<pre>LIST<br/>Token: pTySt8FI7TIqId4N       Uid: 0f3688be-0efc-4744-829c-be5d177e0e1c<br/>Token: zJx3mBRpJ9WTkwGU       Uid: f985a744-6648-4d0a-af5c-0b71aecdbcba<br/>Token: 7vQ2MhnRcyYeTptp       Uid: a73bbfe3-df6a-4dea-93a8-cb4ea3998a53</pre>
<p class="CDPAlignLeft CDPAlign">We've learned how to use Redis. It's useful to store messages for caching something. Next in line is the last NoSQL database we'll look at: MongoDB.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">MongoDB</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">MongoDB is a popular NoSQL database that has great features and good performance. It's really good for data that changes structure quickly, such as the following:</p>
<ul>
<li>Operational intelligence (logs and reports)</li>
<li>Product data management (product catalog, hierarchies, and categories)</li>
<li>Content management systems (posts, comments, and other records)</li>
</ul>
<p class="CDPAlignLeft CDPAlign">We will create an example that stores the activities of a user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bootstrapping a database for testing</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">We will use the official Docker image to bootstrap a MongoDB instance. You can do it simply with the following command:</p>
<pre><strong>docker run -it --rm --name test-mongo -p 27017:27017 mongo</strong></pre>
<p class="CDPAlignLeft CDPAlign">This command runs a container with the name <kbd>test-mongo</kbd> from the <kbd>mongo</kbd> image, and forwards the local port <kbd>27017</kbd> to the same internal port of the container. The data that container produces will be removed after container shutdown.</p>
<p class="CDPAlignLeft CDPAlign">If you have a <kbd>mongo</kbd> client, you can use it to connect to an instance of database inside the container:</p>
<pre><strong>mongo 127.0.0.1:27017/admin</strong></pre>
<p class="CDPAlignLeft CDPAlign">When you need to shut down the container, use the <kbd>stop</kbd> subcommand of <kbd>docker</kbd> and specify the <kbd>name</kbd> of the container:</p>
<pre><strong>docker stop test-mongo</strong></pre>
<p class="CDPAlignLeft CDPAlign">It can also be terminated with <em>Ctrl </em>+ <em>C</em> if you attached the container to a Terminal with <kbd>-it</kbd> arguments, as I did previously.</p>
<p class="CDPAlignLeft CDPAlign">Now, we can look how to connect to a database using <kbd>mongo</kbd> and the <kbd>r2d2-mongo</kbd> crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting to a database using the r2d2 pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">By tradition, we will use a <kbd>Pool</kbd> from the <kbd>r2d2</kbd> crate, but in this example (as in the Redis example), we don't use multiple connections at once. Add all of the necessary dependencies to a new binary crate:</p>
<pre>[dependencies]<br/>bson = "0.13"<br/>chrono = { version = "0.4", features = ["serde"] }<br/>clap = "2.32"<br/>failure = "0.1"<br/>mongodb = "0.3"<br/>r2d2 = "0.8"<br/>r2d2-mongodb = "0.1"<br/>serde = "1.0"<br/>serde_derive = "1.0"<br/>url = "1.7"</pre>
<p class="CDPAlignLeft CDPAlign">The list is not small. Besides the crates you already familiar with, we've added the <kbd>bson</kbd>, <kbd>chrono</kbd>, and <kbd>url</kbd> crates. The first crate we need to work with data in the database; the second, to use the <kbd>Utc</kbd> type; and the last to split URL strings into pieces.</p>
<p class="CDPAlignLeft CDPAlign">Import all the necessary types, as follows:</p>
<pre>use chrono::offset::Utc;<br/>use clap::{<br/>    crate_authors, crate_description, crate_name, crate_version,<br/>    App, AppSettings, Arg, SubCommand,<br/>};<br/>use mongodb::Error;<br/>use mongodb::db::{Database, ThreadedDatabase};<br/>use r2d2::Pool;<br/>use r2d2_mongodb::{ConnectionOptionsBuilder, MongodbConnectionManager};<br/>use url::Url;</pre>
<p class="CDPAlignLeft CDPAlign">This user's logging tool will support two commands: <kbd>add</kbd> to add a record, and <kbd>list</kbd> to print a list of all records. Add the following necessary constants:</p>
<pre>const CMD_ADD: &amp;str = "add";<br/>const CMD_LIST: &amp;str = "list";</pre>
<p class="CDPAlignLeft CDPAlign">To set and get structured data, we need to declare an <kbd>Activity</kbd> struct that will be used to create a BSON document and to restore it from BSON data, because MongoDB uses this format for data interaction. The <kbd>Activity</kbd> struct has three fields, <kbd>user_id</kbd>, <kbd>activity</kbd>, and <kbd>datetime</kbd>:</p>
<pre>#[derive(Deserialize, Debug)]<br/>struct Activity {<br/>    user_id: String,<br/>    activity: String,<br/>    datetime: String,<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Interaction functions</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Since we have a declared structure, we can add functions to work with databases. The first function we will add is <kbd>add_activity</kbd> which adds an activity record to a database:</p>
<pre>fn add_activity(conn: &amp;Database, activity: Activity) -&gt; Result&lt;(), Error&gt; {<br/>    let doc = doc! {<br/>        "user_id": activity.user_id,<br/>        "activity": activity.activity,<br/>        "datetime": activity.datetime,<br/>    };<br/>    let coll = conn.collection("activities");<br/>    coll.insert_one(doc, None).map(drop)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">This function only converts the <kbd>Activity</kbd> struct into a BSON document, and does this by extracting fields from a struct and construct BSON document with the same fields. We can derive the <kbd>Serialize</kbd> trait for the structure and use automatic serialization, but I used the <kbd>doc!</kbd> macro for demonstration purposes to show you that you can add a free-form document that can be constructed on the fly.</p>
<p class="CDPAlignLeft CDPAlign">To add <kbd>Activity</kbd>, we get a collection called <kbd>activities</kbd> from a <kbd>Database</kbd> instance by reference to the <kbd>collection()</kbd> method, and call the <kbd>insert_one</kbd> method of <kbd>Collection</kbd> to add a record.</p>
<p class="CDPAlignLeft CDPAlign">The next method is <kbd>list_activities</kbd>. This method uses a <kbd>Database</kbd> instance to find all values in the <em>activities</em> collection. We use the <kbd>find()</kbd> method of <kbd>Collection</kbd> to get data, but make sure to set filter (the first argument) to <kbd>None</kbd>, and options (the second argument) to <kbd>None</kbd>, to get all of the values from a collection.</p>
<p class="CDPAlignLeft CDPAlign">You can tweak these parameters for filtering, or to limit the quantity of records you retrieve:</p>
<pre>fn list_activities(conn: &amp;Database) -&gt; Result&lt;Vec&lt;Activity&gt;, Error&gt; {<br/>    conn.collection("activities").find(None, None)?<br/>        .try_fold(Vec::new(), |mut vec, doc| {<br/>            let doc = doc?;<br/>            let activity: Activity = bson::from_bson(bson::Bson::Document(doc))?;<br/>            vec.push(activity);<br/>            Ok(vec)<br/>        })<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">To convert every record returned by the <kbd>find</kbd> query as a BSON document, we can use the <kbd>bson::from_bson</kbd> method, since we have derived the <kbd>Deserialize</kbd> trait for the <kbd>Activity</kbd> struct. The <kbd>try_fold</kbd> method lets us interrupt folding if conversion should fail. We push all successfully converted values to the vector that we provided as the first argument to the <kbd>try_fold</kbd> method call. Now, we can parse arguments so that we can prepare a pool to use for calling declared interaction functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing arguments</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Our tool expects two subcommands: <kbd>add</kbd> and <kbd>list</kbd>. Let's add them to a <kbd>clap::App</kbd> instance. Like all previous examples, we also added a <kbd>--database</kbd> argument to set the connection URL. Look at the following code:</p>
<pre>let matches = App::new(crate_name!())<br/>    .version(crate_version!())<br/>    .author(crate_authors!())<br/>    .about(crate_description!())<br/>    .setting(AppSettings::SubcommandRequired)<br/>    .arg(<br/>        Arg::with_name("database")<br/>        .short("d")<br/>        .long("db")<br/>        .value_name("ADDR")<br/>        .help("Sets an address of db connection")<br/>        .takes_value(true),<br/>        )<br/>    .subcommand(SubCommand::with_name(CMD_ADD).about("add user to the table")<br/>                .arg(Arg::with_name("USER_ID")<br/>                     .help("Sets the id of a user")<br/>                     .required(true)<br/>                     .index(1))<br/>                .arg(Arg::with_name("ACTIVITY")<br/>                     .help("Sets the activity of a user")<br/>                     .required(true)<br/>                     .index(2)))<br/>    .subcommand(SubCommand::with_name(CMD_LIST).about("print activities list of users"))<br/>    .get_matches();</pre>
<p class="CDPAlignLeft CDPAlign">The <kbd>add</kbd> subcommand expects two parameters: <kbd>USER_ID</kbd> and <kbd>ACTIVITY</kbd>. Both are represented as <kbd>String</kbd> type values in the <kbd>Activity</kbd> struct. We will require these arguments, but we'll get any provided values without any restrictions. The <kbd>list</kbd> subcommand has no extra arguments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a connections pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">To connect to a database, we extract the connection URL from the <kbd>--database</kbd> command-line argument. If it isn't set, we use the <kbd>mongodb://localhost:27017/admin</kbd> default value:</p>
<pre>let addr = matches.value_of("database")<br/>    .unwrap_or("mongodb://localhost:27017/admin");<br/>let url = Url::parse(addr)?;</pre>
<p class="CDPAlignLeft CDPAlign">But we also parse it to the <kbd>Url</kbd> struct. This is necessary because MongoDB connections expect options sets to be collected by separate values:</p>
<pre>let opts = ConnectionOptionsBuilder::new()<br/>    .with_host(url.host_str().unwrap_or("localhost"))<br/>    .with_port(url.port().unwrap_or(27017))<br/>    .with_db(&amp;url.path()[1..])<br/>    .build();<br/><br/>let manager = MongodbConnectionManager::new(opts);<br/><br/>let pool = Pool::builder()<br/>    .max_size(4)<br/>    .build(manager)?;<br/><br/>let conn = pool.get()?;</pre>
<p class="CDPAlignLeft CDPAlign">In the preceding code, we create a new <kbd>ConnectionOptionsBuilder</kbd> instance and populate it with values from a parsed <kbd>Url</kbd> instance. We set <kbd>host</kbd>, <kbd>port</kbd>, and the <kbd>db</kbd> name. As you can see, we skip the first character of the path so that we can use it as the name of the database. Call the <kbd>build</kbd> method to build the <kbd>ConnectionOptions</kbd> struct. Now, we can create a <kbd>MongodbConnectionManager</kbd> instance and use it to create a <kbd>Pool</kbd> instance. But, in this example, we called the <kbd>builder</kbd> method, instead of <kbd>new</kbd>, to show you how you can set the number of connections in a <kbd>Pool</kbd> instance. We set this to <kbd>4</kbd>. After that, we called the <kbd>build</kbd> method to create a <kbd>Pool</kbd> instance. As in previous examples, we call the <kbd>get</kbd> method of a <kbd>Pool</kbd> to get a <kbd>Database</kbd> connection object from a pool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing subcommands</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The implementation of subcommands is simple. For the <kbd>add</kbd> subcommand, we extract two arguments, <kbd>USER_ID</kbd> and <kbd>ACTIVITY</kbd>, and use them to create an <kbd>Activity</kbd> struct instance. We also get the current time with the <kbd>Utc::now</kbd> method and save it to a <kbd>datetime</kbd> field of <kbd>Activity</kbd>. Finally, we call the <kbd>add_activity</kbd> method to add the <kbd>Activity</kbd> instance to the MongoDB database:</p>
<pre>match matches.subcommand() {<br/>    (CMD_ADD, Some(matches)) =&gt; {<br/>        let user_id = matches.value_of("USER_ID").unwrap().to_owned();<br/>        let activity = matches.value_of("ACTIVITY").unwrap().to_owned();<br/>        let activity = Activity {<br/>            user_id,<br/>            activity,<br/>            datetime: Utc::now().to_string(),<br/>        };<br/>        add_activity(&amp;conn, activity)?;<br/>    }<br/>    (CMD_LIST, _) =&gt; {<br/>        let list = list_activities(&amp;conn)?;<br/>        for item in list {<br/>            println!("User: {:20}    Activity: {:20}    DateTime: {:20}",<br/>                     item.user_id, item.activity, item.datetime);<br/>        }<br/>    }<br/>    _ =&gt; { matches.usage(); }<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">The list subcommand calls the <kbd>list_activities</kbd> function, and then iterates over all records to print them to a Terminal. The logging tool is finished – we can test it now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Compile and run the tool with the following command:</p>
<pre><strong>cargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 "Logged In"</strong><br/><strong>cargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 "Added contact information"</strong><br/><strong>cargo run -- add 43fb507d-4cee-431a-a7eb-af31a1eeed02 "E-mail confirmed"</strong></pre>
<p class="CDPAlignLeft CDPAlign">Print a list of added records with the following command:</p>
<pre><strong>cargo run -- list</strong></pre>
<p class="CDPAlignLeft CDPAlign">This will print the following output:</p>
<pre>User: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:26.245957656 UTC    Activity: Logged In<br/>User: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:42.249548906 UTC   Activity: Added contact information<br/>User: 43fb507d-4cee-431a-a7eb-af31a1eeed02   DateTime: 2018-11-30 14:19:59.035373758 UTC   Activity: E-mail confirmed</pre>
<p class="CDPAlignLeft CDPAlign">You can also check the result with the <kbd>mongo</kbd> client:</p>
<pre><strong>mongo admin</strong><br/><strong>&gt; db.activities.find()</strong><br/><strong>{ "_id" : ObjectId("5c0146ee6531339934e7090c"), "user_id" : "43fb507d-4cee-431a-a7eb-af31a1eeed02", "activity" : "Logged In", "datetime" : "2018-11-30 14:19:26.245957656 UTC" }</strong><br/><strong>{ "_id" : ObjectId("5c0146fe653133b8345ed772"), "user_id" : "43fb507d-4cee-431a-a7eb-af31a1eeed02", "activity" : "Added contact information", "datetime" : "2018-11-30 14:19:42.249548906 UTC" }</strong><br/><strong>{ "_id" : ObjectId("5c01470f653133cf34391c1f"), "user_id" : "43fb507d-4cee-431a-a7eb-af31a1eeed02", "activity" : "E-mail confirmed", "datetime" : "2018-11-30 14:19:59.035373758 UTC" }</strong></pre>
<p class="CDPAlignLeft CDPAlign">You did it! It works well! Now, you know how to use all popular databases with Rust. In the next chapter, we will improve on this knowledge with <strong>o</strong><strong>bject-relational mapping</strong> (<strong>ORM</strong>), which helps to simplify database structure declaration, interaction, and migrations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DynamoDB</h1>
                
            
            
                
<p>We used local database instances in this chapter. The disadvantage of maintaining databases yourself is that you also have to take care of scalability yourself. There are a lot of services that provide popular databases that automatically scale to meet your needs. But not every database can grow without limits: traditional SQL databases often experience speed performance issues when tables become huge. For large datasets, you should choose to use key-value databases (such as NoSQL) that provide scalability by design. In this section, we will explore the usage of <kbd>DynamoDB</kbd>, which was created by Amazon, to provide an easily scalable database as a service.</p>
<p>To use AWS services, you need the AWS SDK, but there is no official SDK for Rust, so we will use the <kbd>rusoto</kbd> crate, which provides the AWS API in Rust. Let's start by porting the tool, which we created earlier in this chapter, to <kbd>DynamoDB</kbd>. First, we should create a table in the <kbd>DynamoDB</kbd> instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bootstrapping a database for testing</h1>
                
            
            
                
<p>Since AWS services are paid-for, it's better to bootstrap a local instance of the <kbd>DynamoDB</kbd> database for development or testing your application. There is an image of <kbd>DynamoDB</kbd> on Docker Hub. Run the instance with this command:</p>
<pre><strong>docker run -it --rm --name test-dynamodb -p 8000:8000 amazon/dynamodb-local</strong></pre>
<p>This command creates an instance of a database and forwards port <kbd>8000</kbd> of a container to a local port with the same number.</p>
<p>To work with this database instance, you need the AWS CLI tool. This can be installed using the instructions from <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html">https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html</a>. On Linux, I use the following command:</p>
<pre><strong>pip install awscli --upgrade --user</strong></pre>
<p>This command doesn't need administration privileges to be installed. After I installed the tool, I created a user with programmatic access, as detailed here: <a href="https://console.aws.amazon.com/iam/home#/users%24new?step=details">https://console.aws.amazon.com/iam/home#/users$new?step=details</a>. You can read more about creating a user account to access the AWS API here: <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html">https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html</a>.</p>
<p>When you have a user for programmatic access, you can configure the AWS CLI using the <kbd>configure</kbd> subcommand:</p>
<pre><strong>aws configure</strong><br/><strong>AWS Access Key ID [None]: &lt;your-access-key&gt;</strong><br/><strong>AWS Secret Access Key [None]: &lt;your-secret-key&gt;</strong><br/><strong>Default region name [None]: us-east-1</strong><br/><strong>Default output format [None]: json</strong></pre>
<p>The subcommand asks you for your user credentials, default region, and desired output format. Fill in those fields as appropriate.</p>
<p>Now, we can create a table using the AWS CLI tool. Enter the following command into the console:</p>
<pre><strong>aws dynamodb create-table --cli-input-json file://table.json --endpoint-url http://localhost:8000 --region custom</strong></pre>
<p>This command creates a table from a declaration in JSON format from the <kbd>table.json</kbd> file in the local database, with an endpoint of <kbd>localhost:8000</kbd>. This is the address of the container we have started. Look at the contents of this table declaration file:</p>
<pre>{<br/>    "TableName" : "Locations",<br/>    "KeySchema": [<br/>        {<br/>            "AttributeName": "Uid",<br/>            "KeyType": "HASH"<br/>        },<br/>        {<br/>            "AttributeName": "TimeStamp",<br/>            "KeyType": "RANGE"<br/>        }<br/>    ],<br/>    "AttributeDefinitions": [<br/>        {<br/>            "AttributeName": "Uid",<br/>            "AttributeType": "S"<br/>        },<br/>        {<br/>            "AttributeName": "TimeStamp",<br/>            "AttributeType": "S"<br/>        }<br/>    ],<br/>    "ProvisionedThroughput": {<br/>        "ReadCapacityUnits": 1,<br/>        "WriteCapacityUnits": 1<br/>    }<br/>}</pre>
<p>This file contains a declaration of a table with two required attributes:</p>
<ul>
<li><kbd>Uid</kbd> - This stores user identifiers. This attribute will be used as a partition key.</li>
<li><kbd>TimeStamp</kbd> - This stores a timestamp when location data is produced. This attribute will be used as a sorting key to order records.</li>
</ul>
<p>You can check whether the database instance contains this new table with the following command:</p>
<pre><strong>aws dynamodb list-tables --endpoint-url http://localhost:8000 </strong><strong>--region custom</strong></pre>
<p>It prints the list of tables that the database instance contains, but our list is rather short, as we only have one table:</p>
<pre>{<br/>    "TableNames": [<br/>        "Locations"<br/>    ]<br/>}</pre>
<p>The database is prepared. Now, we will create a tool to add records to this table using Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting to DynamoDB</h1>
                
            
            
                
<p>In this section, we will create a tool to add records to a table in our <kbd>DynamoDB</kbd> database, and also print all records from the table. First, we need to add all of the necessary crates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding dependencies</h1>
                
            
            
                
<p>To work with the AWS API, we will use the <kbd>rusoto</kbd> crate. Actually, it isn't a single crate, but a set of crates where every single crate covers some functionality of the AWS API. The basic crate is <kbd>rusoto_core</kbd>, which contains the <kbd>Region</kbd> struct that represents an address of the AWS API endpoint. <kbd>Region</kbd> is often necessary for other crates. Also, the <kbd>rusoto_core</kbd> crate re-exports the <kbd>rusoto_credential</kbd> crate, which contains types for loading and managing AWS credentials to access the API.</p>
<p>To interact with the <kbd>DynamoDB</kbd> database, we need to add the <kbd>rusoto_dynamodb</kbd> dependency. The full list looks like this:</p>
<pre>chrono = "0.4"<br/><br/>clap = "2.32"<br/><br/>failure = "0.1"<br/><br/>rusoto_core = "0.36.0"<br/><br/>rusoto_dynamodb = "0.36.0"</pre>
<p>We also added the <kbd>chrono</kbd> dependency to generate timestamps and convert them to ISO-8601 format strings. We use the <kbd>clap</kbd> crate to parse command-line arguments, and the <kbd>failure</kbd> crate to return a generic <kbd>Error</kbd> type from the <kbd>main</kbd> function.</p>
<p>We need the following types in our code:</p>
<pre>use chrono::Utc;<br/><br/>use clap::{App, AppSettings, Arg, SubCommand,<br/>    crate_authors, crate_description, crate_name, crate_version};<br/><br/>use failure::{Error, format_err};<br/><br/>use rusoto_core::Region;<br/><br/>use rusoto_dynamodb::{AttributeValue, DynamoDb, DynamoDbClient,<br/>    QueryInput, UpdateItemInput};<br/><br/>use std::collections::HashMap;</pre>
<p>It's worth paying attention to types that are imported from the <kbd>rusoto_core</kbd> and <kbd>rusoto_dynamodb</kbd> crates. We imported the <kbd>Region</kbd> struct, which is used to set the location of the AWS endpoint. The <kbd>DynamoDb</kbd> trait, <kbd>DynamoDbClient</kbd>, is used to get access to a database. <kbd>AttributeValue</kbd> is a type used to represent values stored in DynamoDB's tables. <kbd>QueryInput</kbd> is a struct to prepare <kbd>query</kbd> and <kbd>UpdateItemInput</kbd> is a struct to prepare an <kbd>update_item</kbd> request.</p>
<p>Let's add functions to interact with the <kbd>DynamoDB</kbd> database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interaction functions</h1>
                
            
            
                
<p>In this section, we will create a tool that stores location records to a database and query location points for a specific user. To represent a location in the code, we declare the following <kbd>Location</kbd> struct:</p>
<pre>#[derive(Debug)]<br/>struct Location {<br/>    user_id: String,<br/>    timestamp: String,<br/>    longitude: String,<br/>    latitude: String,<br/>}</pre>
<p>This struct keeps <kbd>user_id</kbd>, which represents the partition key, and <kbd>timestamp</kbd>, which represents the sort key.</p>
<div><kbd>DynamoDB</kbd> is a key-value storage, where every record has a unique key. When you declare tables, you have to decide which attributes will be the key of a record. You can choose up to two keys. The first is required and represents a partition key that's used to distribute data across database partitions. The second key is optional and represents an attribute that's used to sort items in a table.</div>
<p>The <kbd>rusoto_dynamodb</kbd> crate contains an <kbd>AttributeValue</kbd> struct, which is used in queries and results to insert or extract data from tables. Since every record (that is, every item) of a table is a set of attribute names to attribute values, we will add the <kbd>from_map</kbd> method to convert the <kbd>HashMap</kbd> of attributes to our <kbd>Location</kbd> type:</p>
<pre>impl Location {<br/>    fn from_map(map: HashMap&lt;String, AttributeValue&gt;) -&gt; Result&lt;Location, Error&gt; {<br/>        let user_id = map<br/>            .get("Uid")<br/>            .ok_or_else(|| format_err!("No Uid in record"))<br/>            .and_then(attr_to_string)?;<br/>        let timestamp = map<br/>            .get("TimeStamp")<br/>            .ok_or_else(|| format_err!("No TimeStamp in record"))<br/>            .and_then(attr_to_string)?;<br/>        let latitude = map<br/>            .get("Latitude")<br/>            .ok_or_else(|| format_err!("No Latitude in record"))<br/>            .and_then(attr_to_string)?;<br/>        let longitude = map<br/>            .get("Longitude")<br/>            .ok_or_else(|| format_err!("No Longitude in record"))<br/>            .and_then(attr_to_string)?;<br/>        let location = Location { user_id, timestamp, longitude, latitude };<br/>        Ok(location)<br/>    }<br/>}</pre>
<p>We need four attributes: <kbd>Uid</kbd>,  <kbd>TimeStamp</kbd>, <kbd>Longitude</kbd>, and <kbd>Latitude</kbd>. We extract every attribute from the map and convert it into a <kbd>Location</kbd> instance using the <kbd>attr_to_string</kbd> method:</p>
<pre>fn attr_to_string(attr: &amp;AttributeValue) -&gt; Result&lt;String, Error&gt; {<br/>    if let Some(value) = &amp;attr.s {<br/>        Ok(value.to_owned())<br/>    } else {<br/>        Err(format_err!("no string value"))<br/>    }<br/>}</pre>
<p>The <kbd>AttributeValue</kbd> struct contains multiple fields for different types of values:</p>
<ul>
<li><kbd>b</kbd> - A binary value represented by <kbd>Vec&lt;u8&gt;</kbd></li>
<li><kbd>bool</kbd> - A boolean value with the <kbd>bool</kbd> type</li>
<li><kbd>bs</kbd> - A binary set, but represented as <kbd>Vec&lt;Vec&lt;u8&gt;&gt;</kbd></li>
<li><kbd>l</kbd> - A list of attributes of a <kbd>Vec&lt;AttributeValue&gt;</kbd> type</li>
<li><kbd>m</kbd> - A map of attributes of a <kbd>HashMap&lt;String, AttributeValue&gt;</kbd> type</li>
<li><kbd>n</kbd> - A number stored as a <kbd>String</kbd> type to keep the exact value without any precision loss</li>
<li><kbd>ns</kbd> - A set of numbers as a <kbd>Vec&lt;String&gt;</kbd></li>
<li><kbd>null</kbd> - Used to represent a null value and stored as <kbd>bool</kbd>, which means the value is null</li>
<li><kbd>s</kbd> - A string, of the <kbd>String</kbd> type</li>
<li><kbd>ss</kbd> - A set of strings, of the <kbd>Vec&lt;String&gt;</kbd> type</li>
</ul>
<p>You might notice that there is no data type for timestamps. This is true, as <kbd>DynamoDB</kbd> uses strings for most types of data.</p>
<p>We use the <kbd>s</kbd> field to work with string values that we'll add with the <kbd>add_location</kbd> function:</p>
<pre>fn add_location(conn: &amp;DynamoDbClient, location: Location) -&gt; Result&lt;(), Error&gt; {<br/>    let mut key: HashMap&lt;String, AttributeValue&gt; = HashMap::new();<br/>    key.insert("Uid".into(), s_attr(location.user_id));<br/>    key.insert("TimeStamp".into(), s_attr(location.timestamp));<br/>    let expression = format!("SET Latitude = :y, Longitude = :x");<br/>    let mut values = HashMap::new();<br/>    values.insert(":y".into(), s_attr(location.latitude));<br/>    values.insert(":x".into(), s_attr(location.longitude));<br/>    let update = UpdateItemInput {<br/>        table_name: "Locations".into(),<br/>        key,<br/>        update_expression: Some(expression),<br/>        expression_attribute_values: Some(values),<br/>        ..Default::default()<br/>    };<br/>    conn.update_item(update)<br/>        .sync()<br/>        .map(drop)<br/>        .map_err(Error::from)<br/>}</pre>
<p>This function expects two parameters: a reference to a database client, and a <kbd>Location</kbd> instance to store. We have to prepare data manually to get it as an attributes map for storage, because <kbd>DynamoDbClient</kbd> takes values of the <kbd>AttributeValue</kbd> type only. The attributes included in the key are inserted into the <kbd>HashMap</kbd>, with values extracted from the <kbd>Location</kbd> instance and converted into <kbd>AttributeValue</kbd> using the <kbd>s_attr</kbd> function, which has the following declaration:</p>
<pre>fn s_attr(s: String) -&gt; AttributeValue {<br/>    AttributeValue {<br/>        s: Some(s),<br/>        ..Default::default()<br/>    }<br/>}</pre>
<p>After we've filled the <kbd>key</kbd> map, we can set other attributes with expressions. To set attributes to an item, we have to specify them in <kbd>DynamoDB</kbd> syntax, along the lines of <kbd>SET Longitude = :x, Latitude = :y</kbd>. This expression means that we add two attributes with the names <kbd>Longitude</kbd> and <kbd>Latitude</kbd>. In the preceding expression, we used the placeholders of <kbd>:x</kbd> and <kbd>:y</kbd>, which will be replaced with real values that we pass in from the <kbd>HashMap</kbd>.</p>
<p>More information about expressions can be found here: <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.html">https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.html</a>.</p>
<p>When all of the data prepared, we fill the <kbd>UpdateItemInput</kbd> struct and set <kbd>table_name</kbd> to <kbd>"Locations"</kbd>, because it requires this as an argument for the <kbd>update_item</kbd> method of <kbd>DynamoDbClient</kbd>.</p>
<p>The <kbd>update_item</kbd> method returns <kbd>RusotoFuture</kbd>, which implements the <kbd>Future</kbd> trait that we explored in <a href="ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml">Chapter 5</a>, <em>Understanding Asynchronous Operations with Futures Crate</em>. You can use the <kbd>rusoto</kbd> crate in asynchronous applications. Since we don't use a reactor or asynchronous operations in this example, we will call the <kbd>sync</kbd> method of <kbd>RusotoFuture</kbd>, which blocks the current thread and waits for <kbd>Result</kbd>.</p>
<p>We have implemented a method to create new data items to the table and now we need a function to retrieve data from this table. The following <kbd>list_locations</kbd> function gets a list of <kbd>Location</kbd> for a specific user from the <kbd>Locations</kbd> table:</p>
<pre>fn list_locations(conn: &amp;DynamoDbClient, user_id: String) -&gt; Result&lt;Vec&lt;Location&gt;, Error&gt; {<br/>    let expression = format!("Uid = :uid");<br/>    let mut values = HashMap::new();<br/>    values.insert(":uid".into(), s_attr(user_id));<br/>    let query = QueryInput {<br/>        table_name: "Locations".into(),<br/>        key_condition_expression: Some(expression),<br/>        expression_attribute_values: Some(values),<br/>        ..Default::default()<br/>    };<br/>    let items = conn.query(query).sync()?<br/>        .items<br/>        .ok_or_else(|| format_err!("No Items"))?;<br/>    let mut locations = Vec::new();<br/>    for item in items {<br/>        let location = Location::from_map(item)?;<br/>        locations.push(location);<br/>    }<br/>    Ok(locations)<br/>}</pre>
<p>The <kbd>list_locations</kbd> function expects a reference to the <kbd>DynamoDbClient</kbd> instance and a string with if of user. If there are items in the table for the requested user, they are returned as a <kbd>Vec</kbd> of items, converted into the <kbd>Location</kbd> type.</p>
<p>In this function, we use the <kbd>query</kbd> method of <kbd>DynamoDbClient</kbd>, which expects a <kbd>QueryInput</kbd> struct as an argument. We fill it with the name of the table, the condition of the key expression, and values to fill that expression. We use a simple <kbd>Uid = :uid</kbd> expression that queries items with the corresponding value of the <kbd>Uid</kbd> partition key. We use a <kbd>:uid</kbd> placeholder and create a <kbd>HashMap</kbd> instance with a <kbd>:uid</kbd> key and a <kbd>user_id</kbd> value, which is converted into <kbd>AttributeValue</kbd> with the <kbd>s_attr</kbd> function call.</p>
<p>Now, we have two functions to insert and query data. We will use them to implement a command-line tool to interact with <kbd>DynamoDB</kbd>. Let's start with parsing arguments for our tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing command-line arguments</h1>
                
            
            
                
<p>AWS is divided by regions, where each has its own endpoint to connect to services. Our tool will support two arguments to set a region and endpoint:</p>
<pre>.arg(<br/>   Arg::with_name("region")<br/>   .long("region")<br/>   .value_name("REGION")<br/>   .help("Sets a region")<br/>   .takes_value(true),<br/>   )<br/>.arg(<br/>   Arg::with_name("endpoint")<br/>   .long("endpoint-url")<br/>   .value_name("URL")<br/>   .help("Sets an endpoint url")<br/>   .takes_value(true),<br/>   )</pre>
<p>We add both to <kbd>App</kbd> instance. The tool will support two commands to add a new item and to print all items. The first subcommand is <kbd>add</kbd> and it expects three arguments: <kbd>USER_ID</kbd>, <kbd>LONGITUDE</kbd>, and <kbd>LATITUDE</kbd>:</p>
<pre>.subcommand(SubCommand::with_name(CMD_ADD).about("add geo record to the table")<br/>           .arg(Arg::with_name("USER_ID")<br/>                .help("Sets the id of a user")<br/>                .required(true)<br/>                .index(1))<br/>           .arg(Arg::with_name("LATITUDE")<br/>                .help("Sets a latitudelongitude of location")<br/>                .required(true)<br/>                .index(2))<br/>           .arg(Arg::with_name("LONGITUDE")<br/>                .help("Sets a longitude of location")<br/>                .required(true)<br/>                .index(3)))</pre>
<p>The <kbd>list</kbd> subcommand requires <kbd>USER_ID</kbd> in arguments only:</p>
<pre>.subcommand(SubCommand::with_name(CMD_LIST).about("print all records for the user")<br/>           .arg(Arg::with_name("USER_ID")<br/>                .help("User if to filter records")<br/>                .required(true)<br/>                .index(1)))</pre>
<p>Add all of the preceding code to the <kbd>main</kbd> function. We can use these arguments to create a <kbd>Region</kbd> instance that we can use for a connection with <kbd>DynamoDB</kbd>:</p>
<pre>let region = matches.value_of("endpoint").map(|endpoint| {<br/>     Region::Custom {<br/>         name: "custom".into(),<br/>         endpoint: endpoint.into(),<br/>     }<br/> }).ok_or_else(|| format_err!("Region not set"))<br/> .or_else(|_| {<br/>     matches.value_of("region")<br/>         .unwrap_or("us-east-1")<br/>         .parse()<br/> })?;</pre>
<p>The code works according to the following logic: if a user sets the <kbd>--endpoint-url</kbd> parameter, we create a <kbd>Region</kbd> with a custom name and provide an <kbd>endpoint</kbd> value. If <kbd>endpoint</kbd> is not set, we try to parse the <kbd>--region</kbd> parameter to the <kbd>Region</kbd> instance, or just use the <kbd>us-east-1</kbd> value by default.</p>
<p>AWS takes the region value seriously, and if you create a table in one region, you can't access that table from another region. We used a custom name for the region, but for production tools, it's better to use the <kbd>~/.aws/config</kbd> file or provide the flexibility to customize these settings.</p>
<p>Now, we can use the <kbd>Region</kbd> value to create a <kbd>DynamoDbClient</kbd> instance:</p>
<pre>let client = DynamoDbClient::new(region);</pre>
<p>The <kbd>DynamoDbClient</kbd> struct is used for sending queries to our <kbd>DynamoDB</kbd> instance. We will use this instance in the implementation of our commands. Do you remember the <kbd>match</kbd> expression that parses command-line arguments? Add this implementation for the <kbd>add</kbd> subcommand first, which puts a new item in a table, as follows:</p>
<pre>(CMD_ADD, Some(matches)) =&gt; {<br/>     let user_id = matches.value_of("USER_ID").unwrap().to_owned();<br/>     let timestamp = Utc::now().to_string();<br/>     let latitude = matches.value_of("LATITUDE").unwrap().to_owned();<br/>     let longitude = matches.value_of("LONGITUDE").unwrap().to_owned();<br/>     let location = Location { user_id, timestamp, latitude, longitude };<br/>     add_location(&amp;client, location)?;<br/> }</pre>
<p>The implementation is simple—we extract all provided arguments, generate a timestamp using the <kbd>Utc::now</kbd> call, and convert it into a <kbd>String</kbd> type in the ISO-8601 format. Lastly, we fill the <kbd>Location</kbd> instance and call the <kbd>add_location</kbd> function that we declared before.</p>
<p>Have you ever wondered why databases use the ISO-8601 format to represent dates, which look like <kbd>YEAR-MONTH-DATE HOUR:MINUTE:SECOND</kbd>? That's because dates stored in strings in this format are ordered chronologically if sorted alphabetically. It's very convenient: you can sort dates to get the earliest on top and the latest at the bottom.</p>
<p>We still need to implement the <kbd>list</kbd> subcommand:</p>
<pre>(CMD_LIST, Some(matches)) =&gt; {<br/>     let user_id = matches.value_of("USER_ID").unwrap().to_owned();<br/>     let locations = list_locations(&amp;client, user_id)?;<br/>     for location in locations {<br/>         println!("{:?}", location);<br/>     }<br/> }</pre>
<p>This command extracts <kbd>USER_ID</kbd> arguments and calls the <kbd>list_locations</kbd> function with the provided <kbd>user_id</kbd> value. Finally, we iterate over all locations and print them to the Terminal.</p>
<p>The implementation is finished and we can try it now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>To test the tool, start the <kbd>DynamoDB</kbd> instance with Docker and create a table, like we did before in this chapter. Let's add four locations of two users:</p>
<pre><strong>cargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73169 41.44326</strong><br/><strong>cargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73213 41.44443</strong><br/><strong>cargo run -- --endpoint-url http://localhost:8000 add 651B4984-1252-4ECE-90E7-0C8B58541E7C 52.73124 41.44435</strong><br/><strong>cargo run -- --endpoint-url http://localhost:8000 add 7E3E27D0-D002-43C4-A0DF-415B2F5FF94D 35.652832 139.839478</strong></pre>
<p>We also set the <kbd>--endpoint-url</kbd> argument to target our client to a local <kbd>DynamoDB</kbd> instance. When all records have been added, we can use the <kbd>list</kbd> subcommand to print all of the values of the specified user:</p>
<pre><strong>cargo run -- --endpoint-url http://localhost:8000 list 651B4984-1252-4ECE-90E7-0C8B58541E7C</strong></pre>
<p>This command prints something like the following:</p>
<pre>Location { user_id: "651B4984-1252-4ECE-90E7-0C8B58541E7C", timestamp: "2019-01-04 19:58:26.278518362 UTC", latitude: "52.73169", longitude: "41.44326" }<br/>Location { user_id: "651B4984-1252-4ECE-90E7-0C8B58541E7C", timestamp: "2019-01-04 19:58:42.559125438 UTC", latitude: "52.73213", longitude: "41.44443" }<br/>Location { user_id: "651B4984-1252-4ECE-90E7-0C8B58541E7C", timestamp: "2019-01-04 19:58:55.730794942 UTC", latitude: "52.73124", longitude: "41.44435" }</pre>
<p>As you can see, we retrieved all of the values in a sorted order, because we use the <kbd>TimeStamp</kbd> attribute as a sorting key of the table. Now, you know enough to create microservices that uses databases, but if you use the SQL database, you can add an extra abstraction layer and work with records of a database as native Rust structs, without writing glue code. In the next chapter, we will examine this approach with object-relational mappings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">In this chapter, we've covered a lot to do with databases. We started by creating a plain connection to PostgreSQL. After that, we added a pool of connections with the <kbd>r2d2</kbd> crate and used the <kbd>rayon</kbd> crate to execute SQL statements in parallel. We created a tool to manage our <kbd>users</kbd> database, and reimplemented it for our MySQL database.</p>
<p class="CDPAlignLeft CDPAlign">We have also mastered some ways of interacting with NoSQL databases, in particular, Redis and MongoDB.</p>
<p>The last database we explored was DynamoDB, which is part of Amazon Web Services and can be scaled very easily.</p>
<p class="CDPAlignLeft CDPAlign">For all examples, we run database instances in containers, because it's the simplest way to test interactions with databases. We haven't use database connections in microservices yet, because it requires a separate thread to avoid blocking. We will learn how to use background tasks with asynchronous code later, in <a href="ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml">Chapter 10</a>, <em>Background Tasks and Thread Pools in Microservices</em>.</p>
<p class="CDPAlignLeft CDPAlign">In the next chapter, we will explore a different approach to using databases—object-relational mapping with the <kbd>diesel</kbd> crate.</p>


            

            
        
    </body></html>