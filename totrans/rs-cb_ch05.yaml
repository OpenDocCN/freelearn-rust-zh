- en: Deep Dive into Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨并行性
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating a thread in Rust
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中创建一个线程
- en: Spawning multiple threads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: Holding threads in a vector
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向量中保持线程
- en: Sharing data between threads using channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道在线程之间共享数据
- en: Implementing safe mutable access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现安全的可变访问
- en: Creating child processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建子进程
- en: Waiting for a child process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待子进程
- en: Making sequential code parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顺序代码并行化
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Concurrency and parallelism are very important topics for creating a high-performance
    application that can completely utilize system resources, especially considering
    the fact that hardware is getting better with its offering of multiple cores.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行对于创建高性能应用程序非常重要，该应用程序可以完全利用系统资源，尤其是考虑到硬件正变得越来越强大，提供了多个核心。
- en: Rust is a great programming language for performing parallel operations in your
    application. It ensures memory safety and freedom from data races, which is one
    of the major reasons for the list of various concurrency bugs. Rust utilizes the
    standard system APIs to perform concurrency operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种非常适合在应用程序中执行并行操作的编程语言。它确保内存安全并避免数据竞争，这是各种并发错误的主要原因之一。Rust 利用标准系统 API
    来执行并发操作。
- en: Creating a thread in Rust
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rust 中创建一个线程
- en: Rust's standard library provides various functionality for spawning threads,
    which allow the developer to develop and run Rust code in parallel. In this recipe,
    we will learn how to use `std::thread` for spawning multiple threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的标准库提供了各种用于创建线程的功能，允许开发者并行开发和运行 Rust 代码。在本教程中，我们将学习如何使用 `std::thread` 创建多个线程。
- en: You will learn how to create a new thread from the parent, pass a value to the
    newly created child thread, and retrieve the value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何从父进程创建一个新的线程，向新创建的子线程传递一个值，并检索该值。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following steps will walk you through this implementation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您完成此实现：
- en: Create a file named `sample_move.rs` and open it in your text editor.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_move.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Call the standard `thread` library using the `use` keyword:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `use` 关键字调用标准 `thread` 库：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `main` function and declare two variables: `x` and `handle`. Assign
    `x` with the integer value `1` and assign `handle` to the new `thread`, using
    the `thread::spawn` command. Here''s the code for this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并声明两个变量：`x` 和 `handle`。将 `x` 赋值为整数值 `1`，并将 `handle` 赋值给新创建的 `thread`，使用
    `thread::spawn` 命令。以下是该代码的示例：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will get the following screenshot as an output upon successful execution
    of the code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将获得以下截图作为输出：
- en: '![](img/9bdc4ae8-7dca-45d9-a377-fa5ad3bc57fa.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bdc4ae8-7dca-45d9-a377-fa5ad3bc57fa.png)'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we use Rust's standard library, namely `std::thread`, for creating
    a `thread` that would allow your Rust code to run in parallel.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用 Rust 的标准库，即 `std::thread`，来创建一个允许 Rust 代码并行运行的 `thread`。
- en: We created a variable named `x` using the `let` keyword and assigned it the
    value `1`, which we passed to the `thread` created by the `thread::spawn()` method.
    This method accepts a closure and it will be executed as a different `thread`;
    the result that it returns is collected in the `handle` variable of the main or
    parent `thread`, which is the originator of the `child` thread. The parent or
    main `thread` waits until the `child` `thread` completes the task, and by assigning
    it to a variable, we collect the information from the `child` `thread` in the
    `handle` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `let` 关键字创建了一个名为 `x` 的变量，并将其赋值为 `1`，然后将其传递给由 `thread::spawn()` 方法创建的 `thread`。此方法接受一个闭包，它将在不同的
    `thread` 中执行；它返回的结果将被收集在主或父 `thread` 的 `handle` 变量中，该变量是子 `thread` 的发起者。父或主 `thread`
    等待子 `thread` 完成任务，通过将其赋值给变量，我们在 `handle` 变量中收集子 `thread` 的信息。
- en: As closures have the ability to capture variables from their environment, we
    brought the data from the `child` `thread` to the parent `thread`, but we have
    to do this carefully using the `move` closure. If you don't use `move`, you will
    get a compile-time error as, by default closures capture variables by reference,
    and we only have the reference to `x`. This is a problem of dangling pointers.
    The `move` closure prevents this by moving the variable from other environments
    to themselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包具有从其环境捕获变量的能力，我们将`child` `thread`中的数据带到了父`thread`，但我们必须使用`move`闭包小心地这样做。如果你不使用`move`，你将得到编译时错误，因为默认情况下闭包通过引用捕获变量，而我们只有`x`的引用。这是一个悬垂指针的问题。`move`闭包通过将变量从其他环境移动到自身来防止这种情况。
- en: At last, we called the `join()` and `unwrap()` methods to print the result from
    the `child` `thread`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了`join()`和`unwrap()`方法来从`child` `thread`打印结果。
- en: Spawning multiple threads
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: The aim of this recipe is to spawn multiple threads in Rust and perform simple
    actions that will help you understand how threads are generated in Rust. We will
    extensively use the standard `thread` module with the `move` closure, which we
    learned in the previous recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目的是在Rust中创建多个线程并执行一些简单的操作，这将帮助你理解如何在Rust中生成线程。我们将广泛使用标准`thread`模块和我们在上一个菜谱中学到的`move`闭包。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps will walk you through this implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成此实现：
- en: Create a file named `sample_multiple_threads.rs` and open it in your text editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_multiple_threads.rs`的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Call the standard `thread` library using the `use` keyword:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`use`关键字调用标准`thread`库：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the `main` function and declare two variables: `x` and `handle`. Assign
    `x` as an integer value of `1` and assign `handle` to the new `thread`, using
    the `thread::spawn` command. Here''s the code for this:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并声明两个变量：`x`和`handle`。将`x`赋值为整数`1`，并将`handle`赋值为新创建的`thread`，使用`thread::spawn`命令。以下是该代码示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following screenshot as output upon successful execution of
    the code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，我们将得到以下截图作为输出：
- en: '![](img/c43ddd38-d86f-4f3a-86f7-5845ea460381.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c43ddd38-d86f-4f3a-86f7-5845ea460381.png)'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created two threads using the `spawn` module of the `thread`
    crate. The first `thread` just prints a statement, but the second `thread`, apart
    from printing, also passes and returns a value to the main `thread`. The main
    `thread` is the user-created Rust process that creates the other two threads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`thread` crate的`spawn`模块创建了两个线程。第一个`thread`仅打印一条语句，但第二个`thread`除了打印外，还向主`thread`传递并返回一个值。主`thread`是用户创建的Rust进程，它创建了其他两个线程。
- en: The most important point to learn from this recipe is that the main `thread`
    will not wait for the spawned `thread` to complete, which means that the next
    `println` macro won't be executed before the program exits. To ensure that the
    program waits for the threads to finish, we called the `join()` module on the
    `join_handle` variable of the `thread`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个菜谱中学习到最重要的点是主`thread`不会等待创建的`thread`完成，这意味着在程序退出之前，下一个`println`宏不会执行。为了确保程序等待线程完成，我们在`thread`的`join_handle`变量上调用了`join()`模块。
- en: We even send a value `17` to a different `thread` through `join_handle`, as
    we sent to the second `thread` in this case. In the last few lines of the code,
    we had the `match` statement, where we check whether the value `x` has returned
    from the second `thread` using `join_handle .join()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至通过`join_handle`将值`17`发送到不同的`thread`，就像我们在这个例子中发送到第二个`thread`一样。在代码的最后几行中，我们有`match`语句，其中我们使用`join_handle
    .join()`检查值`x`是否已从第二个`thread`返回。
- en: The preceding three `println` statements can be observed in any order.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的三个`println`语句可以以任何顺序观察到。
- en: The reason why these statements could be observed in a different order in every
    execution is that they are scheduled by the OS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句在每次执行中可能以不同的顺序出现，原因在于它们是由操作系统进行调度的。
- en: Holding threads in a vector
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在向量中保持线程
- en: We are going to create a train of 10 threads in this recipe and declare a vector
    where we will hold all the `thread` handles. We will join the main `thread` later
    to ensure the handles are executed and return the value that we would send while
    spawning the `thread`. We will extensively use the concepts learned from the previous
    two recipes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个由10个线程组成的序列，并声明一个向量，我们将在这里存储所有的 `thread` 处理程序。稍后我们将连接主 `thread`
    以确保处理程序被执行，并返回我们在创建 `thread` 时发送的值。我们将广泛使用从前两个菜谱中学到的概念。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps will walk you through this implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成此实现：
- en: Create a file named `sample_thread_expt.rs` and open it in your text editor.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_thread_expt.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头信息：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Call the standard `thread` library using the `use` keyword and create a `static`
    variable called `NO_THREADS` using the 32-bit integer value `10`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `use` 关键字调用标准 `thread` 库，并使用32位整数值 `10` 创建一个名为 `NO_THREADS` 的 `static` 变量：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the `main` function and declare an empty `thread_holder` vector. Then
    create the corresponding loops for pushing the threads spawned to the vector with
    the iterator value `i` and return them later:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并声明一个空的 `thread_holder` 向量。然后创建相应的循环，将迭代值 `i` 创建的线程推送到向量中，并在稍后返回它们：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will get the following screenshot as output upon successful execution of
    the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，我们将得到以下截图作为输出：
- en: '![](img/17d2ddd5-dcd9-457a-aa45-21cd456b26ae.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17d2ddd5-dcd9-457a-aa45-21cd456b26ae.png)'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We declared a static variable named `NO_THREADS` to which we assigned the 32-bit
    integer value `10`; we also created an empty mutable vector named `thread_holder`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为 `NO_THREADS` 的静态变量，并将其赋值为32位整数值 `10`；我们还创建了一个名为 `thread_holder` 的空可变向量。
- en: Using a `for` loop, we iterated over the value, starting from `0` to the upper
    limit value of the static variable, that is, `NO_THREADS`. Inside the `for` loop,
    we pushed the spawned threads to the `thread_holder` vector using the `push` functionality.
    While creating the `thread`, we used the `move` closure and sent the iterator
    value `i` to the newly spawned `thread`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环，我们从 `0` 开始迭代，直到静态变量的上限值 `NO_THREADS`。在 `for` 循环内部，我们使用 `push` 功能将创建的线程推送到
    `thread_holder` 向量中。在创建 `thread` 时，我们使用了 `move` 闭包并将迭代值 `i` 发送到新创建的 `thread`。
- en: Once all the thread-spawning commands are completed by the compiler, we start
    to iterate over the `thread_holder` vector elements using a `for` loop. In this
    case, the iterator variable was `thread_elements`; we called the `join` and `unwrap`
    function to the `thread` through this variable. With this, we ensured that all
    the threads are completed and they return to the main `thread`, where we print
    the value that was sent earlier to the `thread` when it was spawned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译器完成了所有线程创建命令，我们就开始使用 `for` 循环遍历 `thread_holder` 向量中的元素。在这种情况下，迭代变量是 `thread_elements`；我们通过这个变量调用
    `join` 和 `unwrap` 函数到 `thread`。通过这种方式，我们确保所有线程都已完成，并返回到主 `thread`，在那里我们打印出之前在创建
    `thread` 时发送给 `thread` 的值。
- en: Since all the threads are scheduled by the OS, we can't predict the order in
    which threads will be spawned and the values returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有线程都是由操作系统调度的，我们无法预测线程创建的顺序以及返回的值。
- en: Sharing data between threads using channels
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道在线程间共享数据
- en: The idea is to send a piece of information or data of the type `T` between threads
    via a channel. Here, `T` implements the `Send` trait, which indicates that variables
    or resources of the type `T` have the ability to transfer their ownership safely
    between threads. This particular feature of Rust helps in safe sharing of data
    between threads. This helps achieve safer concurrency and data-race freedom. The
    catch here is that the type `T`, which we want to send across the threads via
    the channel, must support and implement the `Send` trait. The second important
    trait is `Sync`. When `T` implements `Sync`, it means that something of this type
    has no possibility of introducing memory unsafety when used from multiple threads
    concurrently through shared references. These two traits allow you to use the
    Rust type system for making concurrent code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在线程之间通过通道发送类型为`T`的信息或数据。在这里，`T`实现了`Send`特质，这表示类型`T`的变量或资源具有在线程之间安全转移所有权的功能。Rust的这个特定功能有助于在线程之间安全地共享数据。这有助于实现更安全的并发和数据竞争自由。这里的难点在于，我们想要通过通道在线程之间发送的类型`T`必须支持并实现`Send`特质。第二个重要的特质是`Sync`。当`T`实现`Sync`时，这意味着当通过共享引用从多个线程并发使用时，这种类型的某个东西没有引入内存不安全性的可能性。这两个特质允许您使用Rust类型系统来编写并发代码。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will walk you through this implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您完成此实现的操作：
- en: Create a file named `sample_channel.rs` and open it in your text editor.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_channel.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头并包含相关信息：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the standard `thread` library using the `use` keyword:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`use`关键字调用标准`thread`库：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `static` variable called `NO_THREADS` with a 32-bit integer value
    of 3:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NO_THREADS`的静态变量，其32位整数值为3：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `main` function and declare the `tx` and `rx` endpoints of the channel:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并声明通道的`tx`和`rx`端点：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `for` loop to create threads and send them across the channel:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环来创建线程并将它们发送到通道中：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, create another `for` loop to iterate and collect all the values
    passed to the channel:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建另一个`for`循环来迭代并收集传递给通道的所有值：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/421f8943-9555-4279-9287-a1cf1b54ab97.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/421f8943-9555-4279-9287-a1cf1b54ab97.png)'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we discussed how to use the channel feature of Rust to send
    data of the type `T`, which implements the traits required for safely sending
    data across threads.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们讨论了如何使用Rust的通道功能来发送类型为`T`的数据，`T`实现了安全地在线程之间发送数据所需的特质。
- en: First, to start off with developing channels, we used the `mpsc::channel()`
    method to create a new channel; post this, we sent simple data, such as the `thread_id`,
    from the endpoints. The endpoints in our case were `tx` and `rx`, which were the
    transmitter and receiver endpoints of the channel. The channel now had two endpoints,
    namely `Sender<T>` and `Receiver<T>`, where `T` was the type of the message that
    had to be transferred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了开始开发通道，我们使用了`mpsc::channel()`方法来创建一个新的通道；之后，我们从端点发送了简单的数据，例如`thread_id`。在我们的情况下，端点是`tx`和`rx`，它们是通道的发送端和接收端。现在通道有两个端点，即`Sender<T>`和`Receiver<T>`，其中`T`是要传输的消息的类型。
- en: In the first `for` loop, where our focus was on sending the data to the channel,
    we iterated with a variable named `thread_id` from `0` to the static `NO_THREADS`
    variable value. The sender endpoint is copied by the `clone` method and assigned
    to `thread_id`. Each `thread` sends its `thread_no` via the channel by spawning
    new threads in which the `thread_id` value is passed to the `send(data).unwrap()`
    methods. The `thread` takes ownership of the `thread_tx` value. Each `thread`
    queues a message in the channel, sending a non-blocking operation, and continues
    immediately after sending the message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`for`循环中，我们的重点是向通道发送数据，我们使用名为`thread_id`的变量从`0`迭代到静态变量`NO_THREADS`的值。发送端点通过`clone`方法被复制并分配给`thread_id`。每个`thread`通过在新的线程中传递`thread_id`值到`send(data).unwrap()`方法来通过通道发送其`thread_no`。`thread`接管了`thread_tx`值的所有权。每个`thread`在通道中排队一个消息，执行非阻塞操作，并在发送消息后立即继续。
- en: In the second `for` loop, all the messages are collected from the channel. We
    declare a vector named `thread_holder` with the capacity of the number of threads
    spawned, which is a prefixed static value called `NO_THREADS`. The `recv` method
    of `rx` collects the messages from the channel, and `recv` blocks the current
    `thread` if there are no messages available. All these messages are pushed to
    the `thread_holder` vector using the `push` method of the vector. In the last
    `println` statement, we showed the order in which the messages were sent by printing
    the `thread_holder` vector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `for` 循环中，所有消息都从通道中收集。我们声明一个名为 `thread_holder` 的向量，其容量为生成的线程数，这是一个前缀静态值，称为
    `NO_THREADS`。`rx` 的 `recv` 方法从通道中收集消息，并且如果没有消息可用，`recv` 会阻塞当前 `thread`。所有这些消息都使用向量的
    `push` 方法推送到 `thread_holder` 向量。在最后的 `println` 语句中，我们通过打印 `thread_holder` 向量显示了消息发送的顺序。
- en: Implementing safe mutable access
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现安全可变访问
- en: We want to ensure safe and mutable access of data, which will allow multiple
    threads to access the resource without having data races. The ownership model
    of Rust enables this functionality. You will learn about locks that will help
    you keep track of your data when you have multiple threads making modifications
    to it. We have the atomic reference count `Arc<T>` in Rust, which at runtime will
    keep track of the count and allow the developer to share the ownership of the
    data across threads.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保数据的安全和可变访问，这将允许多个线程访问资源而不会发生数据竞争。Rust 的所有权模型使得这种功能成为可能。当您有多个线程对数据进行修改时，您将学习到帮助您跟踪数据的锁。Rust
    中有原子引用计数 `Arc<T>`，它在运行时将跟踪计数并允许开发者跨线程共享数据的所有权。
- en: In this recipe, we will use `mutex<T>`. This allows us to safely mutate a shared
    data value across multiple threads. For example, we have data where `mutex` will
    ensure only one `thread` would be able to mutate the value inside it at a time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `mutex<T>`。这允许我们在多个线程之间安全地修改共享数据值。例如，我们有数据，其中 `mutex` 将确保一次只有一个
    `thread` 能够修改其内部的价值。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will walk you through this recipe:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导您完成此菜谱：
- en: Create a file named `sample_lock.rs` and open it in your text editor.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_lock.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the standard libraries:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the `main` function and declare the `data` variable with an `Arc` type
    data with `Mutex`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并声明一个具有 `Arc` 类型数据和 `Mutex` 的 `data` 变量：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Spawn multiple threads using the `for` loop, which will mutate the data using
    `lock`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环生成多个线程，使用 `lock` 来修改数据：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/8bda868f-76ee-47ae-bc69-8e0b109b4bcd.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bda868f-76ee-47ae-bc69-8e0b109b4bcd.png)'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We created a new variable `data` of the `Mutex` type, which we implemented
    from the standard sync library. Using the `for` loop, we planned to spawn three
    threads. Inside the scope of the `for` loop, we cloned `data` to the same variable
    name: `data`. Next, using the standard threads library, we spawned three threads
    where we locked the `Mutex`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的 `Mutex` 类型变量 `data`，这是我们使用标准同步库实现的。使用 `for` 循环，我们计划生成三个线程。在 `for`
    循环的作用域内，我们将 `data` 克隆到相同的变量名：`data`。接下来，使用标准线程库，我们生成了三个线程，其中我们锁定了 `Mutex`。
- en: The `Mutex` (short form of mutual exclusion) allows one `thread` to access a
    value at a time. If you wish to access the value, you have to use the `lock()`
    method on the type. This will lock the `Mutex`, and no other `thread` will be
    able to unlock it; therefore, no one will be able to modify the data. If a `thread`
    attempts to lock a `mutex` that is already locked, it will wait until the other
    `thread` releases the lock.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex`（互斥的简称）允许一次只有一个 `thread` 访问一个值。如果您想访问该值，您必须使用该类型的 `lock()` 方法。这将锁定 `Mutex`，其他
    `thread` 将无法解锁它；因此，没有人可以修改数据。如果一个 `thread` 尝试锁定已经锁定的 `mutex`，它将等待其他 `thread` 释放锁。'
- en: Note that the value of `i` is copied only to the closure and not shared among
    the threads.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`i` 的值仅复制到闭包中，而不是在线程之间共享。
- en: The releasing of the lock is automatic as when the variable goes out of scope,
    it is automatically released, which makes it available to other threads.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的释放是自动的，因为当变量超出作用域时，它会自动释放，这使得它对其他线程可用。
- en: Creating child processes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子进程
- en: In this recipe, we will call a `child` process from the Rust code to the outside
    world and record its output values. A `child` process is created via the `Command`
    struct, which configures the spawning process. The `child` process, in general,
    is any other tool or application that you would run or start using specific shell
    commands. In Rust, we spawn these `child` processes from the main process, which
    is the main Rust application, and control them according to the need of the Rust
    application using the built-in methods that let us read errors, pass arguments,
    wait for the process to complete, parse the output, and more.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将从Rust代码调用`child`进程到外部世界，并记录其输出值。`child`进程是通过`Command`结构体创建的，该结构体配置了启动进程。通常，`child`进程是您将使用特定shell命令运行或启动的任何其他工具或应用程序。在Rust中，我们从主进程（即主要的Rust应用程序）启动这些`child`进程，并根据Rust应用程序的需求使用内置方法控制它们，这些方法允许我们读取错误、传递参数、等待进程完成、解析输出等。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps will walk you through the implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您完成实现：
- en: Create a file named `sample_child_process.rs` and open it in your text editor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_child_process.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Call the standard library:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the `main` function and declare the `output` variable, which is the
    `Command` implementation to execute the `child` process and get `std:output`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并声明`output`变量，该变量是执行`child`进程并获取`std:output`的`Command`实现：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Print out the string value of `s` variable based on the `output` response using
    `if...else` statements:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`output`响应打印出`s`变量的字符串值，使用`if...else`语句：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/ef27c0c5-dbd0-4290-8d7f-87f810ccd75a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef27c0c5-dbd0-4290-8d7f-87f810ccd75a.png)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `child` process is created via the `Command` struct, which is responsible
    for the spawning process. Here, we declared a variable output where we called
    the `new` method. This is the place where we entered the main command to run.
    Next, we had `arg`, which contained the options of a particular system command.
    The `output` response was responsible for getting the output and the other commands
    used for error handling.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Command`结构体创建了一个`child`进程，该结构体负责启动进程。在这里，我们声明了一个名为`output`的变量，我们在这里调用了`new`方法。这是我们输入要运行的主要命令的地方。接下来，我们有`arg`，它包含特定系统命令的选项。`output`响应负责获取输出和其他用于错误处理的命令。
- en: 'The `struct` `child` basically has three fields: `pub stdin: Option<ChildStdin>`,
    `pub stdout: Option<ChildStdout>`, and `pub stderr: Option<ChildStderr>`. These
    fields handle represent functionalities such as standard input, output, and error,
    respectively.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` `child`基本上有三个字段：`pub stdin: Option<ChildStdin>`，`pub stdout: Option<ChildStdout>`，和`pub
    stderr: Option<ChildStderr>`。这些字段分别处理标准输入、输出和错误等表示功能。'
- en: In the `if...else` statement, we basically checked whether the `Command` had
    executed properly using the `status` module's `success` method, which returns
    `True` in case of success and `False` otherwise. In both the cases, we captured
    the error and output, which we printed by `&output.stdout` and `&output.stderr`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if...else`语句中，我们基本上检查了`Command`是否正确执行，使用`status`模块的`success`方法，在成功时返回`True`，否则返回`False`。在两种情况下，我们都捕获了错误和输出，并通过`&output.stdout`和`&output.stderr`打印出来。
- en: Waiting for a child process
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待子进程
- en: Often, we want the main thread to wait for the `child` process to complete before
    continuing with the main `thread` execution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在主线程等待`child`进程完成后再继续执行主`thread`。
- en: In this recipe, we will learn how to use the wait method to get the status of
    a `child` process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用`wait`方法获取`child`进程的状态。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps will walk you through the recipe:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您完成配方：
- en: Create a file named `sample_wait.rs` and open it in your text editor.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_wait.rs`的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the standard library:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the `main` function and create a `child` process using the `Command`
    struct:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并使用`Command`结构体创建一个`child`进程：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a variable named `_result` and call the `wait` method, the last print
    statement, marking the end of the program:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`_result`的变量并调用`wait`方法，最后的打印语句，标记程序的结束：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你将得到以下输出：
- en: '![](img/7890e2f2-e44d-4ebf-98d0-61fe12a62639.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7890e2f2-e44d-4ebf-98d0-61fe12a62639.png)'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a variable named `child` in which we called the `Command`
    struct to create the `child` process, which is the `sleep` statement with an argument
    with `5`. This makes the program sleep or waits for five seconds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在一个名为`child`的变量中调用了`Command`结构体来创建`child`进程，这是一个带有`5`参数的`sleep`语句。这使得程序休眠或等待五秒钟。
- en: Calling the `wait` function will make the parent or the main process wait until
    the `child` process has actually exited before continuing with the other statements
    of the main process. The mutable `child` wait function waits for the command to
    exit completely and returns the status that it exited with to the `_result` variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`wait`函数将使父进程或主进程等待`child`进程实际退出后再继续执行主进程的其他语句。可变的`child`等待函数等待命令完全退出，并将退出状态返回给`_result`变量。
- en: Last, we printed the status of the `child` process and marked the end of the
    main `thread`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印了`child`进程的状态，并标记了主`thread`的结束。
- en: Making sequential code parallel
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将顺序代码并行化
- en: Here, you'll learn about `rayon`, an external crate in Rust, whose main aim
    is to make your sequential code parallel. The best part about `rayon` is that
    it guarantees you that the APIs of `rayon` will not introduce any concurrency
    bugs, such as data race. In this recipe, you will learn about rayon's parallel
    iterators, which execute iterative statements in parallel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将了解`rayon`，这是Rust中的一个外部包，其主要目的是使你的顺序代码并行化。`rayon`的最好之处在于，它保证你`rayon`的API不会引入任何并发错误，例如数据竞争。在这个菜谱中，你将了解rayon的并行迭代器，它们并行执行迭代语句。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Follow these steps to download and set up a `rayon` crate in your project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在你的项目中下载和设置`rayon`包：
- en: We will require the Rust compiler and any text editor for developing the Rust
    code `snippet.cargo`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码`snippet.cargo`。
- en: 'Create a new Cargo project named `sample_rayon` using:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个名为`sample_rayon`的新Cargo项目：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get the following screenshot as output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下截图作为输出：
- en: '![](img/abd0d09f-975d-4c91-85a5-90c957caa665.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abd0d09f-975d-4c91-85a5-90c957caa665.png)'
- en: 'Enter the newly created `sample_rayon` project and check whether the structure
    is created properly:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新创建的`sample_rayon`项目并检查结构是否创建正确：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/e2f0cfe7-4b13-44e8-94c2-5893abc963ad.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2f0cfe7-4b13-44e8-94c2-5893abc963ad.png)'
- en: 'Open the `Cargo.toml` file to download the `rayon` crate using:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Cargo.toml`文件，使用以下命令下载`rayon`包：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Enter the following values in the dependencies tag:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在依赖项标签中输入以下值：
- en: '![](img/b101d263-b840-4f97-a691-acf61207cf6e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b101d263-b840-4f97-a691-acf61207cf6e.png)'
- en: 'Build the project again to download the `rayon` crate:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建项目以下载`rayon`包：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will get the following screenshot as output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下截图作为输出：
- en: '![](img/4349ae5a-f680-4c5b-9e59-d5082d809f7c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4349ae5a-f680-4c5b-9e59-d5082d809f7c.png)'
- en: 'Check the file structure to see the dependencies installed:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件结构以查看已安装的依赖项：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will get the following screenshot as output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下截图作为输出：
- en: '![](img/d66506ab-0c53-4263-b480-9ffbe686cdec.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d66506ab-0c53-4263-b480-9ffbe686cdec.png)'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps will walk you through the implementation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成实现：
- en: Create a file named `sample_rayon.rs` and open it in your text editor.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_rayon.rs`的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头编写代码：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Call the external library, named `rayon`, which we developed in the *Getting
    ready* section:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用在*准备就绪*部分开发的名为`rayon`的外部库：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `sum_of_squares` function and accept a variable `input` of the type
    `i32`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`sum_of_squares`的函数，并接受一个类型为`i32`的变量`input`：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `main` function where we will create `rand_val` and assign it the
    value `10`, which we will pass to the `sum_of_square` function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数，我们将在这里创建 `rand_val` 并将其值 `10` 赋予它，然后将其传递给 `sum_of_square` 函数：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will get the following screenshot as output upon successful execution of
    the code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你将得到以下截图：
- en: '![](img/0539ae70-daf0-4903-9c4a-04151e232490.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0539ae70-daf0-4903-9c4a-04151e232490.png)'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since `rayon` is an external crate, we first downloaded it using the Cargo tool
    from the [crates.io](http://crates.io) repo site. We used the latest version of
    `rayon`, which is `0.6.0`. `rayon` currently requires rustc 1.12.0 and is available
    in [crates.io](http://crates.io). And note, `rayon` is an experimental crate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `rayon` 是一个外部包，我们首先使用 Cargo 工具从 [crates.io](http://crates.io) 仓库站点下载它。我们使用了
    `rayon` 的最新版本，即 `0.6.0`。`rayon` 目前需要 rustc 1.12.0，并在 [crates.io](http://crates.io)
    中可用。注意，`rayon` 是一个实验性包。
- en: '`rayon` has an API called parallel iterators that lets us write iterator processes
    and execute them in parallel. We implemented the `sum_of_squares` function using
    parallel iterators. To use parallel iterators, we first imported the traits by
    calling `use rayon::prelude::*` to our Rust module. We then called `par_iter`
    to get a parallel iterator, which is similar to a regular iterator. Parallel iterators
    work by first constructing a computation and then executing it; `input` is the
    parameter of the `sum_of_squares` function that returns an integer output. We
    performed the mathematical operation using the `map` and `sum` methods.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`rayon` 拥有一个名为并行迭代器的 API，它允许我们编写迭代器过程并在并行中执行它们。我们使用并行迭代器实现了 `sum_of_squares`
    函数。要使用并行迭代器，我们首先通过调用 `use rayon::prelude::*` 到我们的 Rust 模块中来导入 traits。然后我们调用 `par_iter`
    来获取一个并行迭代器，它类似于一个常规迭代器。并行迭代器通过首先构建一个计算然后执行它来工作；`input` 是 `sum_of_squares` 函数的参数，它返回一个整数值输出。我们使用
    `map` 和 `sum` 方法执行了数学运算。'
- en: In the `main` function, we created a variable named `rand_var` and assigned
    it the value `10`, which we passed as an argument to the `sum_of_squares` function.
    The return value is stored in the `sum_sq` variable and printed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了一个名为 `rand_var` 的变量，并将其值 `10` 赋予它，我们将这个值作为参数传递给 `sum_of_squares`
    函数。返回值存储在 `sum_sq` 变量中并打印出来。
