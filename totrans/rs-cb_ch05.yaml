- en: Deep Dive into Parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Holding threads in a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between threads using channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing safe mutable access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating child processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for a child process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making sequential code parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency and parallelism are very important topics for creating a high-performance
    application that can completely utilize system resources, especially considering
    the fact that hardware is getting better with its offering of multiple cores.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a great programming language for performing parallel operations in your
    application. It ensures memory safety and freedom from data races, which is one
    of the major reasons for the list of various concurrency bugs. Rust utilizes the
    standard system APIs to perform concurrency operations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's standard library provides various functionality for spawning threads,
    which allow the developer to develop and run Rust code in parallel. In this recipe,
    we will learn how to use `std::thread` for spawning multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to create a new thread from the parent, pass a value to the
    newly created child thread, and retrieve the value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_move.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard `thread` library using the `use` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare two variables: `x` and `handle`. Assign
    `x` with the integer value `1` and assign `handle` to the new `thread`, using
    the `thread::spawn` command. Here''s the code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following screenshot as an output upon successful execution
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bdc4ae8-7dca-45d9-a377-fa5ad3bc57fa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use Rust's standard library, namely `std::thread`, for creating
    a `thread` that would allow your Rust code to run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: We created a variable named `x` using the `let` keyword and assigned it the
    value `1`, which we passed to the `thread` created by the `thread::spawn()` method.
    This method accepts a closure and it will be executed as a different `thread`;
    the result that it returns is collected in the `handle` variable of the main or
    parent `thread`, which is the originator of the `child` thread. The parent or
    main `thread` waits until the `child` `thread` completes the task, and by assigning
    it to a variable, we collect the information from the `child` `thread` in the
    `handle` variable.
  prefs: []
  type: TYPE_NORMAL
- en: As closures have the ability to capture variables from their environment, we
    brought the data from the `child` `thread` to the parent `thread`, but we have
    to do this carefully using the `move` closure. If you don't use `move`, you will
    get a compile-time error as, by default closures capture variables by reference,
    and we only have the reference to `x`. This is a problem of dangling pointers.
    The `move` closure prevents this by moving the variable from other environments
    to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we called the `join()` and `unwrap()` methods to print the result from
    the `child` `thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this recipe is to spawn multiple threads in Rust and perform simple
    actions that will help you understand how threads are generated in Rust. We will
    extensively use the standard `thread` module with the `move` closure, which we
    learned in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_multiple_threads.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard `thread` library using the `use` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare two variables: `x` and `handle`. Assign
    `x` as an integer value of `1` and assign `handle` to the new `thread`, using
    the `thread::spawn` command. Here''s the code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screenshot as output upon successful execution of
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c43ddd38-d86f-4f3a-86f7-5845ea460381.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created two threads using the `spawn` module of the `thread`
    crate. The first `thread` just prints a statement, but the second `thread`, apart
    from printing, also passes and returns a value to the main `thread`. The main
    `thread` is the user-created Rust process that creates the other two threads.
  prefs: []
  type: TYPE_NORMAL
- en: The most important point to learn from this recipe is that the main `thread`
    will not wait for the spawned `thread` to complete, which means that the next
    `println` macro won't be executed before the program exits. To ensure that the
    program waits for the threads to finish, we called the `join()` module on the
    `join_handle` variable of the `thread`.
  prefs: []
  type: TYPE_NORMAL
- en: We even send a value `17` to a different `thread` through `join_handle`, as
    we sent to the second `thread` in this case. In the last few lines of the code,
    we had the `match` statement, where we check whether the value `x` has returned
    from the second `thread` using `join_handle .join()`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding three `println` statements can be observed in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why these statements could be observed in a different order in every
    execution is that they are scheduled by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Holding threads in a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a train of 10 threads in this recipe and declare a vector
    where we will hold all the `thread` handles. We will join the main `thread` later
    to ensure the handles are executed and return the value that we would send while
    spawning the `thread`. We will extensively use the concepts learned from the previous
    two recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_thread_expt.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard `thread` library using the `use` keyword and create a `static`
    variable called `NO_THREADS` using the 32-bit integer value `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare an empty `thread_holder` vector. Then
    create the corresponding loops for pushing the threads spawned to the vector with
    the iterator value `i` and return them later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screenshot as output upon successful execution of
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17d2ddd5-dcd9-457a-aa45-21cd456b26ae.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We declared a static variable named `NO_THREADS` to which we assigned the 32-bit
    integer value `10`; we also created an empty mutable vector named `thread_holder`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `for` loop, we iterated over the value, starting from `0` to the upper
    limit value of the static variable, that is, `NO_THREADS`. Inside the `for` loop,
    we pushed the spawned threads to the `thread_holder` vector using the `push` functionality.
    While creating the `thread`, we used the `move` closure and sent the iterator
    value `i` to the newly spawned `thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the thread-spawning commands are completed by the compiler, we start
    to iterate over the `thread_holder` vector elements using a `for` loop. In this
    case, the iterator variable was `thread_elements`; we called the `join` and `unwrap`
    function to the `thread` through this variable. With this, we ensured that all
    the threads are completed and they return to the main `thread`, where we print
    the value that was sent earlier to the `thread` when it was spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the threads are scheduled by the OS, we can't predict the order in
    which threads will be spawned and the values returned.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between threads using channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea is to send a piece of information or data of the type `T` between threads
    via a channel. Here, `T` implements the `Send` trait, which indicates that variables
    or resources of the type `T` have the ability to transfer their ownership safely
    between threads. This particular feature of Rust helps in safe sharing of data
    between threads. This helps achieve safer concurrency and data-race freedom. The
    catch here is that the type `T`, which we want to send across the threads via
    the channel, must support and implement the `Send` trait. The second important
    trait is `Sync`. When `T` implements `Sync`, it means that something of this type
    has no possibility of introducing memory unsafety when used from multiple threads
    concurrently through shared references. These two traits allow you to use the
    Rust type system for making concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_channel.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard `thread` library using the `use` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `static` variable called `NO_THREADS` with a 32-bit integer value
    of 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare the `tx` and `rx` endpoints of the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `for` loop to create threads and send them across the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create another `for` loop to iterate and collect all the values
    passed to the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/421f8943-9555-4279-9287-a1cf1b54ab97.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discussed how to use the channel feature of Rust to send
    data of the type `T`, which implements the traits required for safely sending
    data across threads.
  prefs: []
  type: TYPE_NORMAL
- en: First, to start off with developing channels, we used the `mpsc::channel()`
    method to create a new channel; post this, we sent simple data, such as the `thread_id`,
    from the endpoints. The endpoints in our case were `tx` and `rx`, which were the
    transmitter and receiver endpoints of the channel. The channel now had two endpoints,
    namely `Sender<T>` and `Receiver<T>`, where `T` was the type of the message that
    had to be transferred.
  prefs: []
  type: TYPE_NORMAL
- en: In the first `for` loop, where our focus was on sending the data to the channel,
    we iterated with a variable named `thread_id` from `0` to the static `NO_THREADS`
    variable value. The sender endpoint is copied by the `clone` method and assigned
    to `thread_id`. Each `thread` sends its `thread_no` via the channel by spawning
    new threads in which the `thread_id` value is passed to the `send(data).unwrap()`
    methods. The `thread` takes ownership of the `thread_tx` value. Each `thread`
    queues a message in the channel, sending a non-blocking operation, and continues
    immediately after sending the message.
  prefs: []
  type: TYPE_NORMAL
- en: In the second `for` loop, all the messages are collected from the channel. We
    declare a vector named `thread_holder` with the capacity of the number of threads
    spawned, which is a prefixed static value called `NO_THREADS`. The `recv` method
    of `rx` collects the messages from the channel, and `recv` blocks the current
    `thread` if there are no messages available. All these messages are pushed to
    the `thread_holder` vector using the `push` method of the vector. In the last
    `println` statement, we showed the order in which the messages were sent by printing
    the `thread_holder` vector.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing safe mutable access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to ensure safe and mutable access of data, which will allow multiple
    threads to access the resource without having data races. The ownership model
    of Rust enables this functionality. You will learn about locks that will help
    you keep track of your data when you have multiple threads making modifications
    to it. We have the atomic reference count `Arc<T>` in Rust, which at runtime will
    keep track of the count and allow the developer to share the ownership of the
    data across threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use `mutex<T>`. This allows us to safely mutate a shared
    data value across multiple threads. For example, we have data where `mutex` will
    ensure only one `thread` would be able to mutate the value inside it at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_lock.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare the `data` variable with an `Arc` type
    data with `Mutex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Spawn multiple threads using the `for` loop, which will mutate the data using
    `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bda868f-76ee-47ae-bc69-8e0b109b4bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a new variable `data` of the `Mutex` type, which we implemented
    from the standard sync library. Using the `for` loop, we planned to spawn three
    threads. Inside the scope of the `for` loop, we cloned `data` to the same variable
    name: `data`. Next, using the standard threads library, we spawned three threads
    where we locked the `Mutex`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Mutex` (short form of mutual exclusion) allows one `thread` to access a
    value at a time. If you wish to access the value, you have to use the `lock()`
    method on the type. This will lock the `Mutex`, and no other `thread` will be
    able to unlock it; therefore, no one will be able to modify the data. If a `thread`
    attempts to lock a `mutex` that is already locked, it will wait until the other
    `thread` releases the lock.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the value of `i` is copied only to the closure and not shared among
    the threads.
  prefs: []
  type: TYPE_NORMAL
- en: The releasing of the lock is automatic as when the variable goes out of scope,
    it is automatically released, which makes it available to other threads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating child processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will call a `child` process from the Rust code to the outside
    world and record its output values. A `child` process is created via the `Command`
    struct, which configures the spawning process. The `child` process, in general,
    is any other tool or application that you would run or start using specific shell
    commands. In Rust, we spawn these `child` processes from the main process, which
    is the main Rust application, and control them according to the need of the Rust
    application using the built-in methods that let us read errors, pass arguments,
    wait for the process to complete, parse the output, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_child_process.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare the `output` variable, which is the
    `Command` implementation to execute the `child` process and get `std:output`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the string value of `s` variable based on the `output` response using
    `if...else` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef27c0c5-dbd0-4290-8d7f-87f810ccd75a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `child` process is created via the `Command` struct, which is responsible
    for the spawning process. Here, we declared a variable output where we called
    the `new` method. This is the place where we entered the main command to run.
    Next, we had `arg`, which contained the options of a particular system command.
    The `output` response was responsible for getting the output and the other commands
    used for error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `struct` `child` basically has three fields: `pub stdin: Option<ChildStdin>`,
    `pub stdout: Option<ChildStdout>`, and `pub stderr: Option<ChildStderr>`. These
    fields handle represent functionalities such as standard input, output, and error,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `if...else` statement, we basically checked whether the `Command` had
    executed properly using the `status` module's `success` method, which returns
    `True` in case of success and `False` otherwise. In both the cases, we captured
    the error and output, which we printed by `&output.stdout` and `&output.stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for a child process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we want the main thread to wait for the `child` process to complete before
    continuing with the main `thread` execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the wait method to get the status of
    a `child` process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_wait.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and create a `child` process using the `Command`
    struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable named `_result` and call the `wait` method, the last print
    statement, marking the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7890e2f2-e44d-4ebf-98d0-61fe12a62639.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a variable named `child` in which we called the `Command`
    struct to create the `child` process, which is the `sleep` statement with an argument
    with `5`. This makes the program sleep or waits for five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `wait` function will make the parent or the main process wait until
    the `child` process has actually exited before continuing with the other statements
    of the main process. The mutable `child` wait function waits for the command to
    exit completely and returns the status that it exited with to the `_result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we printed the status of the `child` process and marked the end of the
    main `thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Making sequential code parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you'll learn about `rayon`, an external crate in Rust, whose main aim
    is to make your sequential code parallel. The best part about `rayon` is that
    it guarantees you that the APIs of `rayon` will not introduce any concurrency
    bugs, such as data race. In this recipe, you will learn about rayon's parallel
    iterators, which execute iterative statements in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to download and set up a `rayon` crate in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code `snippet.cargo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Cargo project named `sample_rayon` using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following screenshot as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abd0d09f-975d-4c91-85a5-90c957caa665.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the newly created `sample_rayon` project and check whether the structure
    is created properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2f0cfe7-4b13-44e8-94c2-5893abc963ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `Cargo.toml` file to download the `rayon` crate using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following values in the dependencies tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b101d263-b840-4f97-a691-acf61207cf6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the project again to download the `rayon` crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following screenshot as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4349ae5a-f680-4c5b-9e59-d5082d809f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the file structure to see the dependencies installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following screenshot as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d66506ab-0c53-4263-b480-9ffbe686cdec.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will walk you through the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_rayon.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the external library, named `rayon`, which we developed in the *Getting
    ready* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `sum_of_squares` function and accept a variable `input` of the type
    `i32`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function where we will create `rand_val` and assign it the
    value `10`, which we will pass to the `sum_of_square` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following screenshot as output upon successful execution of
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0539ae70-daf0-4903-9c4a-04151e232490.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `rayon` is an external crate, we first downloaded it using the Cargo tool
    from the [crates.io](http://crates.io) repo site. We used the latest version of
    `rayon`, which is `0.6.0`. `rayon` currently requires rustc 1.12.0 and is available
    in [crates.io](http://crates.io). And note, `rayon` is an experimental crate.
  prefs: []
  type: TYPE_NORMAL
- en: '`rayon` has an API called parallel iterators that lets us write iterator processes
    and execute them in parallel. We implemented the `sum_of_squares` function using
    parallel iterators. To use parallel iterators, we first imported the traits by
    calling `use rayon::prelude::*` to our Rust module. We then called `par_iter`
    to get a parallel iterator, which is similar to a regular iterator. Parallel iterators
    work by first constructing a computation and then executing it; `input` is the
    parameter of the `sum_of_squares` function that returns an integer output. We
    performed the mathematical operation using the `map` and `sum` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we created a variable named `rand_var` and assigned
    it the value `10`, which we passed as an argument to the `sum_of_squares` function.
    The return value is stored in the `sum_sq` variable and printed.
  prefs: []
  type: TYPE_NORMAL
