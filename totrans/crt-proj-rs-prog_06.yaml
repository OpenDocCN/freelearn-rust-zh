- en: Creating a WebAssembly Game Using Quicksilver
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 创建 WebAssembly 游戏
- en: In this chapter, you will see how Rust can be used to build a simple 2D game
    that can be compiled to run as a desktop app or as a web app. To run it as a web
    app, we will use the tools seen in the previous chapter to generate a **WebAssembly**
    (**Wasm**) application. As seen in that chapter, Wasm is a powerful new technology
    to run applications inside a browser. The appropriate tools translate Rust source
    code into a pseudo-machine language, named Wasm, that is loaded and run at top
    speed by browsers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解如何使用 Rust 构建一个简单的 2D 游戏，该游戏可以编译为桌面应用程序或网络应用程序。要将其作为网络应用程序运行，我们将使用上一章中看到的工具生成一个
    **WebAssembly** (**Wasm**) 应用程序。正如该章节所示，Wasm 是一种运行在浏览器内部的新技术，它可以将 Rust 源代码转换为伪机器语言，名为
    Wasm，浏览器以最高速度加载和运行。
- en: 'The Quicksilver open source framework will be described and used in this chapter.
    It has the powerful feature of being able to generate the following applications
    from a single source code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将描述并使用 Quicksilver 开源框架。它具有从单个源代码生成以下应用程序的强大功能：
- en: A standalone **graphical user interface** (**GUI**) application, to be run in
    a desktop system such as Windows, macOS, or Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的 **图形用户界面** (**GUI**) 应用程序，可在 Windows、macOS 或 Linux 等桌面系统中运行
- en: A Wasm app that runs in a JavaScript-enabled web browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用 JavaScript 的网络浏览器中运行的 Wasm 应用程序
- en: 'Quicksilver is oriented toward game programming, and so, as an example, we
    will develop an interactive graphical game using it: a slalom ski race, in which
    the player must drive a ski along a slope, entering the gates found along the
    ski run.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Quicksilver 面向游戏编程，因此，作为一个例子，我们将使用它开发一个交互式图形游戏：一项滑雪回转比赛，玩家必须沿着滑雪道驾驶滑雪板，进入沿途的障碍门。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the animation loop architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解动画循环架构
- en: Building an animated application (`ski`) using the Quicksilver framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 框架构建一个动画应用程序（`ski`）
- en: Building a simple game using the Quicksilver framework (`silent_slalom`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quicksilver 框架（`silent_slalom`）构建一个简单的游戏
- en: Adding text and sound to a game (`assets_slalom`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏中添加文本和声音（`assets_slalom`）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You need to read the section on Wasm of the previous chapter, but no other knowledge
    is required. To run the projects in this chapter, it is enough to install a Wasm
    code generator.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读上一章中关于 Wasm 的部分，但不需要其他知识。要运行本章中的项目，只需安装一个 Wasm 代码生成器即可。
- en: The complete source code for this chapter is in the `Chapter06` folder of the
    repository, found at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码位于存储库的 `Chapter06` 文件夹中，可在[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers) 找到。
- en: For macOS users, you may struggle to install `coreaudio-sys`. Upgrading the
    patch version of `coreaudio-sys` to 0.2.3 resolves this issue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您可能难以安装 `coreaudio-sys`。将 `coreaudio-sys` 的补丁版本升级到 0.2.3 可以解决这个问题。
- en: Project overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will see how to develop games to be run in modern web browsers,
    or in GUI windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何开发在现代网络浏览器或 GUI 窗口中运行的游戏。
- en: For that purpose, we will first describe the typical architecture of any interactive
    game that is based on the animation loop concept.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们首先将描述基于动画循环概念的任何交互式游戏的典型架构。
- en: Then, the Quicksilver crate will be introduced. This is a framework that allows
    us to create a graphical application based on an animation loop. It allows us
    to generate a Wasm executable to be run in a web browser, or a native executable
    to be run in a desktop environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍 Quicksilver crate。这是一个框架，允许我们基于动画循环创建图形应用程序。它允许我们生成可在网络浏览器中运行的 Wasm
    可执行文件，或在桌面环境中运行的本地可执行文件。
- en: 'The first project (`ski`) will be very simple: just a page containing one ski
    that can be rotated by pressing arrow keys. This project will show the general
    architecture of a game, how to draw on a page, and how to handle input.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目（`ski`）将非常简单：仅包含一个可以按箭头键旋转的滑雪板页面。这个项目将展示游戏的一般架构，如何在页面上绘制，以及如何处理输入。
- en: The second project (`silent_slalom`) will add features to the first project,
    creating a complete—albeit very simple—game. However, it will not use loadable
    resources such as images, fonts, or sounds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目（`silent_slalom`）将为第一个项目添加功能，创建一个完整——尽管非常简单——的游戏。然而，它将不会使用可加载的资源，例如图像、字体或声音。
- en: The third project (`assets_slalom`) will add features to the second project,
    loading a font and some recorded sounds, and showing how to display some text
    on the page, and how to play the loaded sound files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个项目（`assets_slalom`）将为第二个项目添加功能，加载字体和一些录音声音，并展示如何在页面上显示一些文本，以及如何播放加载的声音文件。
- en: Understanding the animation loop architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动画循环架构
- en: As described in the previous chapter, the typical architecture of interactive
    software is** event-driven architecture**. In such an architecture, the software
    just waits for input commands, and it responds to such commands when they arrive.
    Until any command arrives, the software does nothing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，交互式软件的典型架构是**事件驱动架构**。在这种架构中，软件只是等待输入命令，当命令到达时，它会对这些命令做出响应。在收到任何命令之前，软件什么都不做。
- en: 'This architecture is efficient and responsive for many kinds of applications,
    but it is not optimal for some other kinds of applications, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构对许多类型的应用程序来说既高效又响应迅速，但它对某些其他类型的应用程序来说并不理想，例如以下情况：
- en: Games with animations
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有动画的游戏
- en: Continuous-simulation software
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续模拟软件
- en: Multimedia software
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多媒体软件
- en: Some kind of educational software
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些教育软件
- en: Machine monitoring software (known as **Human-Machine Interface** (**HMI**)
    software)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器监控软件（通常称为**人机界面**（**HMI**）软件）
- en: Systems monitoring software (known as **Supervisory Control and Data Acquisition**
    (**SCADA**) software)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统监控软件（通常称为**监督控制与数据采集**（**SCADA**）软件）
- en: 'In such systems, the software has always something to do, as in the following
    examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，软件总是有事情要做，如下面的例子所示：
- en: In games with animations, such as sports games or combat games or racing games,
    both those against other human players and those against machine-simulated players, even
    if the user does nothing, the opponents move, and time flows; so, the screen must
    be constantly updated to show what the opponents have done, and what the current
    time is.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带有动画的游戏中，例如体育游戏或战斗游戏或赛车游戏，无论是与其他玩家对战还是与机器模拟玩家对战，即使用户没有操作，对手也会移动，时间会流逝；因此，屏幕必须不断更新以显示对手所做的一切，以及当前的时间。
- en: In continuous-simulation software, such as the graphical simulation of a car
    crash, the objects continue to move, even if you don't press any key; so, the
    screen must show the new positions of the objects at any time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在持续模拟软件中，例如汽车碰撞的图形模拟，物体即使在您没有按任何键的情况下也会继续移动；因此，屏幕必须随时显示物体的新位置。
- en: In multimedia software, such as software that reproduces an audio or video clip,
    the data continues to flow, until you pause or stop the reproduction.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多媒体软件中，例如播放音频或视频剪辑的软件，数据会持续流动，直到您暂停或停止播放。
- en: There are many kinds of educational software, but some of them are just games
    with animations, continuous-simulation software, or multimedia software.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育软件有很多种，但其中一些只是带有动画的游戏、持续模拟软件或多媒体软件。
- en: Most mechanical machines, to let a user monitor them, display on a screen a
    constantly updated representation of their internal status, even when the user
    does not request an update.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数机械机器为了让用户监控它们，即使在用户没有请求更新时，也会在屏幕上显示其内部状态的持续更新表示。
- en: Many complex systems, such as industrial plants, office buildings, and—recently—also
    residential buildings, display on a screen a constantly updated representation
    of the status of the devices operating in the system.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多复杂的系统，如工业设施、办公楼，以及最近也开始应用于住宅建筑，会在屏幕上显示系统内运行的设备状态的持续更新表示。
- en: Actually, such kinds of software can even be developed using an event-driven
    architecture. It is enough to use a specific widget known as a *timer*. A timer
    is a software component that triggers an event at a fixed time interval.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这类软件甚至可以使用事件驱动架构来开发。只需要使用一个称为**计时器**的特定小部件。计时器是一个软件组件，会在固定的时间间隔触发一个事件。
- en: For example, in an electronic thermometer, there is a timer that executes a
    routine every minute. Such a routine reads the temperature from a sensor and displays
    the read value on the small screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在电子温度计中，有一个每分钟执行一次例程的计时器。这个例程从传感器读取温度，并在小屏幕上显示读取值。
- en: For some kinds of applications, the use of an event-driven environment, possibly
    including one or more timers, is appropriate. For example, event-driven programming
    is optimal for business applications such as an accounting application. In such
    applications, the user screen is split into several input widgets, such as labels,
    buttons, and textboxes. In such software, no application code is run until the
    user clicks the mouse or presses a key. Such input events trigger the action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的应用，使用事件驱动环境，可能包括一个或多个计时器，是合适的。例如，事件驱动编程对于会计应用等商业应用来说是最优的。在这些应用中，用户屏幕被分成几个输入小部件，如标签、按钮和文本框。在这样的软件中，直到用户点击鼠标或按下一个键，才运行应用程序代码。这些输入事件触发动作。
- en: However, event-driven programming is not quite appropriate for the kind of software
    that displays a scene that fills the window, with no widgets, and that always
    has some code running even if the user does not act on input devices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事件驱动编程并不完全适合显示填充窗口的场景，这种软件没有小部件，并且即使在用户没有对输入设备进行操作的情况下，也始终有一些代码在运行。
- en: 'For such software, the so-called **animation loop architecture** is more appropriate.
    Its simplest structure is the following one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类软件，所谓的 **动画循环架构** 更为合适。其最简单的结构如下：
- en: First, a draw routine is defined as the one responsible for checking the status
    of the input devices and for redrawing the screen according to the status.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，绘制例程被定义为负责检查输入设备的状态并根据状态重新绘制屏幕的程序。
- en: Then, a screen area is defined as a scene, and an update rate is defined for
    it.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个屏幕区域被定义为场景，并为它定义一个更新率。
- en: When the program starts, it first opens a window (or a subwindow) for the scene,
    and then invokes the draw routine at regular intervals, using an internal timer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序启动时，它首先为场景打开一个窗口（或子窗口），然后使用内部计时器以固定间隔调用绘制例程。
- en: Such periodic invocations of the draw routine are usually named *frames*, and
    the invocation rate is measured in **Frames Per Second** (**FPS**).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种周期性的绘制例程通常被称为 *帧*，其调用频率以每秒 **帧数**（**FPS**）来衡量。
- en: 'The animation loop is sometimes named *game-loop*, as it is very often used
    for games. This is quite a misnomer, however, for the following two reasons:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动画循环有时被称为 *游戏循环*，因为它经常用于游戏。然而，这个名称并不准确，原因如下：
- en: There are several other kinds of apps that should use an animation loop, such
    as continuous-simulation software, industrial machine monitoring software, or
    multimedia software. So, an animation loop is not only for games.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他几种应用应该使用动画循环，例如连续模拟软件、工业机器监控软件或多媒体软件。因此，动画循环不仅限于游戏。
- en: There are some games that do not need an animation loop. For example, a chess
    game, a card game, or an adventure game, provided they are not based on animations,
    can be implemented perfectly well using an event-driven architecture. So, games
    are not necessarily based on animation loop.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些游戏不需要动画循环。例如，棋盘游戏、纸牌游戏或冒险游戏，只要它们不是基于动画的，就可以使用事件驱动架构完美实现。因此，游戏不一定基于动画循环。
- en: Notice that, while in an event-driven architecture user input triggers the action,
    in an animation loop architecture some action happens anyway, but if there is
    some user input such actions change accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然在事件驱动架构中用户输入会触发动作，但在动画循环架构中，某些动作仍然会发生，但如果存在用户输入，这些动作会相应地改变。
- en: Consider a user who presses a keyboard key or a mouse button. In event-driven
    programming, that input operation sends exactly one command. Instead, in animation
    loop programming, the program, at any frame, checks whether any key is pressed.
    If the key is pressed for a very short time, it is possible that such an operation
    goes unnoticed as, when the keyboard is checked in one cycle, that key has not
    been pressed yet, and when the keyboard is checked in the next cycle, that key
    has been already released.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个按下键盘键或鼠标按钮的用户。在事件驱动编程中，这种输入操作发送一条精确的命令。相反，在动画循环编程中，程序在任何一帧都会检查是否有任何键被按下。如果按键时间非常短，那么这种操作可能会被忽略，因为在检查键盘的一个周期中，那个键还没有被按下，而在下一个周期中，那个键已经被释放了。
- en: This is quite unusual, though. Typical frame rates are from 20 to 60 FPS, and
    so the corresponding intervals are from 50 to 16.7 milliseconds. It is very difficult
    to press a key for a shorter time than that. Instead, it is quite typical that
    a key-press is much longer than a frame, and so the key is seen pressed in several
    successive frames.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不寻常。典型的帧率是从20到60 FPS，因此相应的间隔是从50到16.7毫秒。很难按下比这更短的时间。相反，按键时间通常比帧长得多，因此按键在几个连续帧中被看到按下。
- en: If you use such a key-press to insert text, you would want to allow the user
    to press a key to insert just one letter. If you use a mouse click to press a
    button on the screen, you want that screen button to be pressed just once. To
    avoid such multiple hits, you must disable input for a short time the first time
    you get it. This is quite a nuisance, and so, for typical widget-based GUI apps,
    event-driven programming is more appropriate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这样的按键来插入文本，你希望允许用户按下一个键来插入一个字母。如果你使用鼠标点击来在屏幕上按一个按钮，你希望那个屏幕按钮只按一次。为了避免这种多次点击，你必须在你第一次得到输入时暂时禁用输入。这相当麻烦，因此，对于典型的基于小部件的GUI应用程序，事件驱动编程更合适。
- en: Instead, animation loop programming is appropriate whenever a key-press must
    have an effect proportional to the duration of the press. For example, if the
    arrow keys are used to move a character on the screen, and if you keep the right
    arrow pressed for 1 second, that character moves by a short distance; while if
    you keep pressed that key for 2 seconds, that character moves double that distance. In
    general, a short press should change little, and a long press should change much.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当必须使按键的效果与按键持续时间成比例时，动画循环编程是合适的。例如，如果使用箭头键在屏幕上移动一个角色，并且如果你按住右箭头键1秒钟，那个角色会移动一段短距离；而如果你按住那个键2秒钟，那个角色会移动两倍的距离。一般来说，短按应该改变很少，而长按应该改变很多。
- en: Regarding the output, when using event-driven programming, the effect of the
    operation is usually shown by changing some property of a widget (such as changing
    the text contents in a textbox, or loading a bitmap in a picture box). After that
    change, the widget is capable of refreshing itself whenever it needs, using its
    internal state. The event that triggers refreshing is the invalidation of the
    screen portion containing the widget. For example, if another window overlaps
    our window, and then it moves away, the discovered portion of our window is invalidated,
    and so it must be refreshed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于输出，当使用事件驱动编程时，操作的效果通常是通过改变小部件的一些属性（例如，在文本框中更改文本内容，或在图片框中加载位图）来显示的。在更改之后，小部件能够在其需要时使用其内部状态自行刷新。触发刷新的事件是小部件包含的屏幕部分的无效化。例如，如果另一个窗口覆盖了我们的窗口，然后它移动开去，我们窗口被发现的区域就无效了，因此它必须刷新。
- en: This kind of graphic is named **retained-mode**, as there is an inner data structure
    that retains the information needed to refresh the screen when there is a need.
    Instead, when using animation loop programming, all the images must be regenerated
    at every frame, and so there is no need to wait for a specific event. This kind
    of graphic is named **immediate-mode**, as the drawing is performed immediately
    by application code when it must be seen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图形被称为**保留模式**，因为有一个内部数据结构保留在需要刷新屏幕时所需的信息。相反，当使用动画循环编程时，必须在每一帧重新生成所有图像，因此不需要等待特定事件。这种图形被称为**即时模式**，因为绘图是在需要看到时立即由应用程序代码执行的。
- en: In the previous chapter, we saw that for event-driven applications, the **Model-View-Controller**
    (**MVC**) architectural pattern allows you to give a better structure to your
    code. Also, for animation loop applications, there is a kind of MVC architectural
    pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了对于事件驱动应用程序，**模型-视图-控制器**（**MVC**）架构模式允许你给你的代码提供更好的结构。同样，对于动画循环应用程序，也存在一种MVC架构模式。
- en: The **Model** is the data structure that contains all the variables that must
    persist between frames.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是包含所有必须在帧之间持续存在的变量的数据结构。'
- en: The **Controller** is a function that has input but no output. It checks the
    status of input devices (which keyboard keys are pressed; which mouse keys are
    pressed; where the mouse is; which are the values of possible other input channels),
    reads the fields of the model, and updates them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是一个有输入但没有输出的函数。它检查输入设备的状态（哪些键盘键被按下；哪些鼠标键被按下；鼠标的位置；其他可能的输入通道的值），读取模型的字段，并更新它们。'
- en: The **View** is a function that has output but no input. It reads the fields
    of the model and draws on the screen according to the read values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是一个有输出但没有输入的功能。它读取模型的字段并根据读取的值在屏幕上绘制。'
- en: Here is how the Quicksilver framework implements this pattern.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Quicksilver框架实现此模式的方式。
- en: 'The model is any data type, typically a struct, that must implement the `State`
    trait. Such a trait contains the following three functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是任何数据类型，通常是结构体，必须实现`State`特质。这样的特质包含以下三个函数：
- en: '`fn new() -> Result<Screen>`: This is the only way to create the model. It
    will return a valid model (if it can) or an error.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn new() -> Result<Screen>`: 这是创建模型的唯一方法。它将返回一个有效的模型（如果可能的话）或一个错误。'
- en: '`fn update(&mut self, window: &mut Window) -> Result<()>`: This is the controller.
    It is invoked periodically by the framework. The `window` argument allows you
    to get some context information. In this framework, it is mutable, but in the
    proper implementation of the MVC pattern, it shouldn''t be changed. Instead, `self`—that
    is, the model—is rightly mutable.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn update(&mut self, window: &mut Window) -> Result<()>`: 这是个控制器。它由框架定期调用。`window`参数允许你获取一些上下文信息。在这个框架中，它是可变的，但在MVC模式的正确实现中，它不应该被改变。相反，`self`——即模型——应该是可变的。'
- en: '`fn draw(&mut self, window: &mut Window) -> Result<()>`: This is the view.
    It is invoked periodically by the framework. The `self` argument allows information
    to be obtained from the model. In this framework, it is mutable, but in the proper
    implementation of the MVC pattern, it shouldn''t be changed. Instead, the `window` argument—that
    is, the output device—is rightly mutable.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn draw(&mut self, window: &mut Window) -> Result<()>`: 这是个视图。它由框架定期调用。`self`参数允许从模型中获取信息。在这个框架中，它是可变的，但在MVC模式的正确实现中，它不应该被改变。相反，`window`参数——即输出设备——应该是可变的。'
- en: Now, let's examine the first project in the repository using the Quicksilver
    framework.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Quicksilver框架检查存储库中的第一个项目。
- en: Implementing the ski project
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施滑雪项目
- en: 'The first project we are going to see is quite simple. It just shows a geometric
    shape on the screen and it allows the user to rotate it using the arrow keys:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的第一个项目相当简单。它只是在屏幕上显示一个几何形状，并允许用户使用箭头键旋转它：
- en: 'To run it as a desktop app, go into the `ski` folder, and type the following
    command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将其作为桌面应用程序运行，请进入`ski`文件夹，并输入以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--release` argument is recommended to optimize the generated code. For
    this simple example, it is pointless, but in more complex examples, the code generated
    without specifying it is so inefficient that the resulting app is noticeably slowed
    down.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用`--release`参数来优化生成的代码。对于这个简单的例子，这是没有意义的，但在更复杂的例子中，没有指定它生成的代码效率如此低，以至于生成的应用程序运行速度明显减慢。
- en: 'After a few minutes of download and compilation, the following desktop window
    will appear:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过几分钟的下载和编译后，以下桌面窗口将出现：
- en: '![](img/e55047b9-f621-40c7-bd6f-1a2dca7d0a3a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e55047b9-f621-40c7-bd6f-1a2dca7d0a3a.png)'
- en: It is just an 800 x 600-pixels white rectangle, with a small purple rectangle
    and a small indigo triangle on top of it. They represent a monoski with its pointed
    end, in a snowy ski slope.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个800 x 600像素的白色矩形，上面有一个小紫色矩形和一个小靛蓝色三角形。它们代表一个尖端的单板滑雪板，位于雪坡上。
- en: If you press the left or right arrow keys (*←*/*→*) on your keyboard, you will
    see the ski rotate around its tip.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你按下键盘上的左箭头键（*←*）或右箭头键（*→*），你会看到滑雪板在其尖端旋转。
- en: Now, close this window using the appropriate command in your windowing environment.
    Typically, you click on a cross icon in the caption bar or press the *Alt* + *F4*
    key combination.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请使用你的窗口环境中的适当命令关闭此窗口。通常，你会在标题栏中点击一个叉号图标，或者按*Alt* + *F4*键组合。
- en: 'Now, let''s see another way to launch this application. Type the following
    command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种启动此应用程序的方法。输入以下命令：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We saw in the previous chapter that this command helps us to create a Wasm app
    and to launch a command-line program that serves it through the HTTP protocol.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了这个命令如何帮助我们创建Wasm应用程序，并通过HTTP协议启动一个命令行程序来提供服务。
- en: 'At the end of the compilation, a server program starts and suggests the address
    where you can access the app. On your preferred browser, you can type this address:
    `localhost:8000`. Only modern 64-bit browsers support WebGL2\. If this is not
    true in your case, then nothing happens; instead, if your browser supports this
    standard, you will see in the browser just the same graphics that before were
    shown in the desktop window.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译结束时，一个服务器程序启动并建议你可以访问应用的地址。在你的浏览器中，你可以输入此地址：`localhost:8000`。只有现代 64 位浏览器支持
    WebGL2。如果在你这里不是这样，那么什么都不会发生；相反，如果你的浏览器支持这个标准，你将在浏览器中看到之前在桌面窗口中显示的相同图形。
- en: This is possible as the Quicksilver framework, used by our app, has multi-target
    capability. When compiled for the Wasm target, it generates a web browser application;
    and when compiled for a **central processing unit** (**CPU**) target, it generates
    a desktop application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们的应用程序使用的 Quicksilver 框架具有多目标能力。当编译为 Wasm 目标时，它生成一个网页浏览器应用程序；当编译为 **中央处理器**（**CPU**）目标时，它生成一个桌面应用程序。
- en: This compile-time portability is very useful for debugging purposes. Actually,
    it is not easy to debug a Wasm application; but if you first debug the desktop
    application, a few bugs will remain in the Wasm version.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编译时便携性对于调试目的非常有用。实际上，调试 Wasm 应用程序并不容易；但如果你首先调试桌面应用程序，Wasm 版本中会剩下一些错误。
- en: Understanding the code behind this
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解此代码背后的含义
- en: Now, let's see the code used to create such a project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建此类项目所使用的代码。
- en: 'Before starting the project, a note about this is required. All the projects
    in this chapter show a monoski on a ski slope. There is a convention about the
    coordinates of the ski and other objects: the horizontal coordinate, usually named
    *X*, is actually named *across*; and the vertical coordinate, usually named *Y*,
    is actually named *along*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始项目之前，需要对此进行说明。本章中的所有项目都展示了一个滑雪板在滑雪道上的场景。关于滑雪板和其他对象的坐标有一个约定：水平坐标，通常称为 *X*，实际上称为
    *across*；而垂直坐标，通常称为 *Y*，实际上称为 *along*。
- en: So, the *across speed* is the speed of a movement from left to right (or vice
    versa, if negative), and the *along speed* is the speed of a movement from bottom
    to top (or vice versa, if negative).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*横向速度* 是从左到右（或反之，如果为负）移动的速度，而 *纵向速度* 是从底部到顶部（或反之，如果为负）移动的速度。
- en: 'First of all, the `Cargo.toml` file must contain the `quicksilver = "0.3"` dependency. Then,
    there is just a `main.rs` source file. It contains some constants, as shown in
    the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Cargo.toml` 文件必须包含 `quicksilver = "0.3"` 依赖项。然后，只有一个 `main.rs` 源文件。它包含一些常量，如下代码片段所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at what the terms suggest in this code, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码中的术语意味着什么，如下所示：
- en: '`SCREEN_WIDTH` and `SCREEN_HEIGHT` are the size in pixels of the client area
    in the desktop window or the size of the canvas in the web page.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCREEN_WIDTH` 和 `SCREEN_HEIGHT` 是桌面窗口中的客户端区域或网页中画布的大小（以像素为单位）。'
- en: '`SKI_WIDTH`, `SKI_LENGTH`, and `SKI_TIP_LEN` are the sizes of the ski.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKI_WIDTH`、`SKI_LENGTH` 和 `SKI_TIP_LEN` 是滑雪板的大小。'
- en: '`STEERING_SPEED` is the number of degrees by which the ski is rotated at every
    step. Steps have a frequency (that is, 25 per second), and so this constant represents
    an angular speed (3.5 degrees per step * 25 steps per second = 87.5 degrees per
    second).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STEERING_SPEED` 是滑雪板每次步骤旋转的度数。步骤有一个频率（即每秒 25 次），因此这个常量代表角速度（每步 3.5 度 * 每秒
    25 步 = 每秒 87.5 度）。'
- en: '`MAX_ANGLE` is a limit to rotational capability, both to the right and to the
    left, to ensure the ski is always downhill.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_ANGLE` 是旋转能力的限制，无论是向右还是向左，以确保滑雪板始终向下。'
- en: 'Then, there is the model of our MVC architecture, as shown in the following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是我们的 MVC 架构模型，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The meaning of these fields is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的意义如下：
- en: '`ski_across_offset` represents the across displacement of the tip of the ski
    with respect to the center of the screen. Actually, in this project, it is always
    zero, as the tip of the ski never moves. It is a variable just because in future
    projects, it will change.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ski_across_offset` 代表滑雪板尖端相对于屏幕中心的横向位移。实际上，在这个项目中，它始终为零，因为滑雪板的尖端从不移动。它是一个变量，因为在未来项目中，它将发生变化。'
- en: '`direction` is the angle in degrees of the ski with respect to the downhill
    direction. It is initially zero but can vary from -75 to +75\. It is the only
    portion of our model that can change.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction` 是滑雪板相对于下山方向的度数。它最初为零，但可以从 -75 到 +75 变化。它是我们模型中唯一可以改变的部分。'
- en: 'The constructor of the model is quite simple, as illustrated in the following
    code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的构造函数相当简单，如下代码片段所示：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It simply initializes to zero both fields of the model. The body of the controller
    (the `update` function) is created with this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型简单地初始化了模型的两个字段为零。控制器的主体（`update`函数）是用以下代码创建的：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The purpose of this routine is to steer the ski a bit to the right, if the right-arrow
    key is pressed, and a bit to the left if the left-arrow key is pressed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程的目的是在按下右箭头键时将滑雪板稍微向右引导，如果按下左箭头键则稍微向左引导。
- en: The `window.keyboard()` expression gets a reference to the keyboard associated
    with the current window, and then the `[Key::Right]` expression gets a reference
    to the right-arrow key of such a keyboard. The `is_down` function returns `true`
    if the specified key is in a pressed state in this instant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.keyboard()`表达式获取与当前窗口关联的键盘的引用，然后`[Key::Right]`表达式获取该键盘的右箭头键的引用。`is_down`函数在指定键在此瞬间处于按下状态时返回`true`。'
- en: 'The steering is performed by the `steer` method, whose body consists of the
    following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是通过`steer`方法执行的，其主体由以下代码组成：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, the value of the `direction` field of the model is incremented or decremented
    by the `STEERING_SPEED` constant. Then, it is ensured that the new value does
    not exceed the designed limits.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，模型`direction`字段的值通过`STEERING_SPEED`常量递增或递减。然后，确保新值不超过设计限制。
- en: 'The view is more complex. It must redraw all the scene even if it has not changed
    at all. The first drawing operation is always to draw the white background, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 视图更复杂。即使场景完全没有变化，也必须重新绘制整个场景。第一次绘制操作始终是绘制白色背景，如下所示：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the rectangle is drawn, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，绘制矩形，如下所示：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `draw_ex` method is used to draw shapes. Its first argument is a reference
    to the shape to draw; in this case, it is `Rectangle`. Its second argument, in
    the fifth line, is the background color of the shape; in this case, it is `PURPLE`.
    Its third argument is a plane affine transformation matrix; in this case, it is
    a translation, followed by a rotation, followed by a translation. And its fourth
    argument, in the last line, is a *Z* elevation; its purpose is to give an overlapping
    order to shapes. Let's examine these arguments in more detail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_ex`方法用于绘制形状。它的第一个参数是要绘制的形状的引用；在这种情况下，它是`Rectangle`。它的第二个参数，在第五行，是形状的背景颜色；在这种情况下，它是`紫色`。它的第三个参数是一个平面仿射变换矩阵；在这种情况下，它是一个平移，然后是旋转，然后是平移。它的第四个参数，在最后一行，是一个*Z*高度；其目的是为形状提供重叠顺序。让我们更详细地检查这些参数。'
- en: The `Rectangle::new` method receives two arguments. The first argument is a
    tuple made up of the *x* and *y* coordinates on the top-left vertex of the rectangle.
    The second argument is a tuple made up of the width and height of the rectangle.
    The origin of the coordinate system is the top left of the window, with the *x*
    coordinate that grows toward the right, and the *y* coordinate that grows downward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle::new`方法接收两个参数。第一个参数是由矩形左上角顶点的*x*和*y*坐标组成的元组。第二个参数是由矩形的宽度和高度组成的元组。坐标系的原点是窗口的左上角，*x*坐标向右增长，*y*坐标向下增长。'
- en: In those formulas, the only variable is `self.ski_across_offset`, which represents
    the displacement of the ski to the right of the center of the window when positive,
    and to the left when negative. In this project, it is always zero, and so the
    ski's *x* coordinate is always at the center of the window. The vertical position
    is such that the center of the rectangle is near the bottom of the window, at
    15/16 of the height of the window.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些公式中，唯一的变量是`self.ski_across_offset`，它表示当为正时，滑雪板相对于窗口中心的位移向右，当为负时向左。在这个项目中，它始终为零，因此滑雪板的*x*坐标始终位于窗口中心。垂直位置是使得矩形的中心接近窗口底部，大约是窗口高度的15/16。
- en: Rectangles are always created with their sides parallel to the sides of the
    window. To have a rotated angle, a geometric transformation must be applied. There
    are several elementary transformations that can be combined by multiplying them.
    To draw a shape in a translated position, a transformation is created using the `Transform::translate`
    method, which receives a `Vector` (not a `Vec`!) specifying the displacements
    along *x* and *y*. To draw a shape in a rotated position, a transformation is
    created using the `Transform::rotate` method, which receives an angle in degrees specifying
    the angle by which to rotate the shape.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形总是与其边平行于窗口的边创建。为了有一个旋转角度，必须应用几何变换。有几种基本的变换可以通过乘法组合。要绘制一个在平移位置上的形状，使用 `Transform::translate`
    方法创建一个变换，该方法接收一个 `Vector`（不是 `Vec`！）指定沿 *x* 和 *y* 方向的位移。要绘制一个在旋转位置上的形状，使用 `Transform::rotate`
    方法创建一个变换，该方法接收一个角度（以度为单位），指定旋转形状的角度。
- en: The rotation is performed around the centroid of the shape, but we want to rotate
    around the tip of the ski. So, we need first to translate the rectangle so that
    its centroid is where the tip of the ski was, then rotate it around its centroid,
    and then translate it back to the original centroid. By multiplying the three
    transformations, a rotation around the tip of the ski is obtained. In the case
    of a rectangle, the centroid is just the center of the rectangle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是围绕形状的质心进行的，但我们想围绕滑雪板的尖端旋转。因此，我们需要首先平移矩形，使其质心位于滑雪板的尖端处，然后围绕其质心旋转，最后将其平移回原始质心。通过乘以这三个变换，我们得到了围绕滑雪板尖端的旋转。在矩形的例子中，质心就是矩形的中心。
- en: The last argument of `draw_ex` is a *z* coordinate. This is a 2D framework,
    and so no *z* coordinate would be required, but this coordinate allows us to specify
    the order of the appearance of the shapes. Actually, if two shapes overlap, and
    they have the same *z* coordinate, WebGL (used by Quicksilver) does not necessarily
    draw them in the order in which you have drawn them. The actual order is undefined.
    To specify that a shape must appear above another, it must have a larger *z* coordinate.
    It doesn't matter how much larger.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_ex` 的最后一个参数是一个 *z* 坐标。这是一个二维框架，因此不需要 *z* 坐标，但这个坐标允许我们指定形状出现的顺序。实际上，如果有两个形状重叠，并且它们具有相同的
    *z* 坐标，Quicksilver（使用 WebGL）并不一定按照你绘制的顺序绘制它们。实际的顺序是未定义的。为了指定一个形状必须出现在另一个形状之上，它必须具有更大的
    *z* 坐标。它的大小并不重要。'
- en: To draw the triangular-pointed end on top of the rectangle, a similar statement
    is executed. The `Triangle::new` method creates a `Triangle` shape, using three
    `Vector` variables as its vertices. To rotate it around its tip, we need to know
    the centroid of the triangle. With a bit of geometry, you can calculate that the
    centroid of that triangle is the point above the center of the base of the triangle
    by a distance equal to one-third of the height of the triangle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要在矩形上方绘制三角形尖端，执行一个类似的语句。`Triangle::new` 方法创建一个 `Triangle` 形状，使用三个 `Vector` 变量作为其顶点。为了使其围绕尖端旋转，我们需要知道三角形的质心。通过一点几何知识，你可以计算出该三角形的质心位于三角形底边中心上方，距离等于三角形高度的1/3。
- en: 'By the end of the program, there is a `main` function that must initialize
    the app. The body of the function contains this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到程序结束时，有一个必须初始化应用的 `main` 函数。函数的主体包含以下内容：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This statement just runs the model, with some arguments. The first argument
    is the caption of the title bar, the second one is the size of the window, and
    the third one is a structure containing some optional settings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句只是运行模型，并带有一些参数。第一个参数是标题栏的标题，第二个参数是窗口的大小，第三个参数是一个包含一些可选设置的结构的实例。
- en: 'The following two settings are specified here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面两个设置在这里指定：
- en: '`draw_rate`: This is the interval in milliseconds between each successive invocation
    of the `draw` function'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw_rate`：这是 `draw` 函数连续调用之间的时间间隔（以毫秒为单位）'
- en: '`update_rate`: This is the interval in milliseconds between each successive
    invocation of the `update` function'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_rate`：这是 `update` 函数连续调用之间的时间间隔（以毫秒为单位）'
- en: This project was quite trivial, but it showed many concepts that will be used
    in the other projects of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目相当简单，但它展示了将在本章其他项目中使用的许多概念。
- en: Implementing the silent_slalom project
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 silent_slalom 项目
- en: The previous project just showed a ski on a ski slope. In this section, we will
    show a possibly amusing game using a ski—a slalom. For simplicity, no text is
    displayed and no sound effects are played in this project. Its source code is
    contained in the `silent_slalom` folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running its desktop version, a window similar to this will
    appear to you:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/542d2008-a2b5-436f-ab73-9dc8f2cb70ee.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: In addition to the ski, some blue dots are drawn. There are four dots in the
    middle of the window, and two half dots that come out at the top border. Each
    pair of blue dots is the poles of a slalom gate. The purpose of the game is to
    make the ski pass through each of the gates. Now, you can see just three gates,
    but the course contains seven intermediate gates, plus the finish gate. The remaining
    five gates will appear when the ski proceeds along the slope.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The actual position of the poles will be different in your case because their
    horizontal (across) position is generated at random. If you stop and relaunch
    the program, you will see other poles' positions. The size of the gates—that is,
    the distance between the two poles of any gate—is kept constant, though; and also,
    the distance, along the *y* coordinate, between any gate and the gate following
    it is constant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: To start the game, press the spacebar. The blue dots will begin to move slowly
    downward, giving the impression of the ski going forward. By rotating the ski,
    you change its direction, and you should try to ensure that its tip passes between
    the poles of every gate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The finish gate is distinguished by having green poles instead of blue. If
    you pass through it, the game finishes, showing a window similar to this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdb950e4-4056-4d02-8d02-9c6bfc547c00.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: You can restart the game by pressing the *R* key. If you fail to pass a gate
    correctly, the game stops and ends. You can restart it by pressing the *R* key.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this project has something in common with the previous project. Let's
    see the differences within it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is the insertion into the `Cargo.toml` file of the `rand
    = "0.6"` dependency. The gates are positioned at a random *x* position, and so
    the random number generator contained in this crate is required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the following constants are defined:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s have a look at these constants in detail, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`N_GATES_IN_SCREEN` is the number of gates that will appear in the window at
    once. The along separation between successive gates is the window height divided
    by this number. Therefore, this number must be positive.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GATE_POLE_RADIUS` is the radius in pixels of each circle drawn to represent
    a pole.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GATE_WIDTH` is the distance in pixels between the centers of the poles in
    each gate. This number must be positive.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKI_MARGIN` is the distance in pixels between the leftmost position that can
    be reached by the tip of the ski to the left border of the window, and between
    the rightmost position that can be reached by the tip of the ski to the right
    border of the window.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALONG_ACCELERATION` is the acceleration, in pixels per frame for each frame,
    for the movement of the ski, due to the slope, when the ski is in downhill position—that
    is, vertical. For example, for an acceleration value of 0.06 and an update rate
    of 40 milliseconds, or 25 frames per second, in a second the speed would go from
    zero to *0.06 * 25 = 1.5* pixels per frame—that is, a speed of *1.5 * 25 = 37.5*
    pixels per second. The actual acceleration will be lower if the ski has an inclination
    with respect to the slope.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DRAG_FACTOR` represents the deceleration caused by air friction. The actual
    deceleration is this factor multiplied by the module of the speed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOTAL_N_GATES` is the number of gates, including the finish gate.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While in the previous project you could do just one thing all the time—that
    is, rotate the ski—in this project, you can do different things according to the
    current situation. So, there is a need to distinguish among four possible states,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The initial mode is `Ready`, when you are eager to start the run, at the top
    of the slope. After the `start` command, you are in `Running` mode, until you
    complete the run correctly, ending in `Finished` mode, or get out of a gate, ending
    in `Failed` mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Some fields have been added to the model of the application, to track some
    other state information, as illustrated in the following code block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The meaning of these fields is described as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '`gates` is a list of the along positions of the poles. For them, the origin
    is the center of the window.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward_speed` is the module of the velocity in pixels per frame.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gates_along_offset` is the *Y* translation of all the shown gates toward the
    bottom, which represents the advancement of the ski. It is a number between zero
    and the along spacing between successive gates.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode` is the state described previously.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entered_gate` indicates whether the tip of the ski has already entered the
    lowest gate shown in the window. This flag is initialized as `false`; it becomes
    `true` when the ski passes a gate correctly and becomes `false` again when that
    gate exits the window from the bottom because now it refers to the next gate.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disappeared_gates` counts the gates exited from the window. Of course, it
    is initialized at zero and is incremented every time a gate exits the window.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function added to the `Screen` type generates a random gate, as illustrated
    in the following code block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function receives the `gate_is_at_right` flag, which indicates in which
    part of the slope the generated gate will be. If such an argument is `true`, the
    new gate will be at the right of the center of the window; otherwise, it will
    be at the left of the center of the window. This function creates a random number
    generator and uses it to generate a reasonable position for a pole. The other
    pole position is computed using the argument of the function and the fixed gate
    size (`GATE_WIDTH`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Another utility function is `deg_to_rad`, which converts angles from degrees
    to radians. It is needed because Quicksilver uses degrees, but trigonometric functions
    use radians. The `new` method creates all the gates, alternating them at right
    and at left, and initializes the model. The `update` function does a lot more
    than the function with that name seen in the previous project. Let''s look at
    the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'According to the current mode, different operations are performed. If the mode
    is `Ready`, it checks whether the spacebar key is pressed, and, in such a case,
    it sets the current mode to `Running`. This means that it starts the race. If
    the mode is `Running`, the following code is executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this mode, a lot of things are computed. First, the ski direction is converted
    from degrees to radians.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Then, the forward speed is incremented because of the slope, and it is decremented
    because of the friction of the air, which is proportional to the speed itself.
    The net effect is that the speed will tend to a maximum value. In addition, the
    more the ski direction is rotated with respect to the slope, the slower it is.
    This effect is implemented using the `cos` cosine trigonometric function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the forward speed is split into its components: the along speed, which
    causes the downward movement of the poles, and the across speed, which increments
    the across ski offset. They are computed by applying, respectively, the `cos`
    and `sin` trigonometric functions to the forward speed, as shown in the following
    code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, it checks that the ski position is not too far to the left or to the
    right, and, if it is so, it is kept within the defined margins, as illustrated
    in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new along speed is used to move down the gates, by incrementing the `gates_along_offset`
    field. If its new value is larger than the distance between successive gates,
    one gate is dropped out of the bottom of the window, and all the gates are moved
    backward by one step and the number of disappeared gates is incremented, as illustrated
    in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, the two coordinates of the tip of the ski are computed: `ski_tip_along`
    is the constant *y* coordinate, from the top of the window, and `ski_tip_across`
    is the variable *x* coordinate, from the center of the window.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the positions inside the next gate are computed: `left_pole_offset` is
    the *x* position of the right side of the left pole, and `right_pole_offset` is
    the *x* position of the left side of the right pole. These coordinates are computed
    from the left border of the window. And then, `next_gate_along` is the *y* position
    of such points, as illustrated in the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the *y* coordinate of the tip of the ski (`ski_tip_along`) is less than that
    of the gate (`next_gate_along`), then we can say that the tip of the ski has passed
    to the next gate. Though, if the `entered_gate` field, which records such passing,
    is still `false`, we can say that in the previous frame the ski hadn't yet passed
    the gate. Therefore, in such a case, we are in the situation in which the ski
    has just passed a gate. So, we must check whether the gate has been passed correctly
    or wrongly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If the *x* coordinate of the tip is *not* between the two coordinates of the
    poles, we are outside the gate, and so we go into the `Failed` mode. Otherwise,
    we must check whether this gate is the last gate of the course—that is, the finish
    gate. If it is the case, we go into the `Finish` mode; otherwise, we make a note
    that we have entered the gate, to avoid checking it again at the next frame, and
    the race goes on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: If the *y* coordinate is such that we haven't reached the next gate yet, we
    take note that `entered_gate` is still false. With this, we have completed the
    computations for the `Running` case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Two modes remain to be considered, as illustrated in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both in the `Failed` mode and in the `Finished` mode, the *R* key is checked.
    If it is pressed, the model is reinitialized, going to the same state as when
    the game was just launched.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the steering key is checked for any mode, just as in the previous project.
    Regarding the `draw` function, what has been added in this project, with respect
    to the previous project, is the drawing of the poles. The code can be seen in
    the following snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A loop scans the gates that appear in the window. The indices of the gates go
    from zero to `TOTAL_N_GATES`, but we must ski the ones that have already exited
    from the bottom, whose number is `self.disappeared_gates`. We must show at least
    the `N_GATES_IN_SCREEN` gates and must stop at the last gate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the player which is the finish gate, it has a different color, as can
    be seen in the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last gate is green. To compute the *y* coordinate of the poles of a gate,
    the following formula is used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It adds the position of the ski between two successive gates (`gates_along_offset`)
    to the initial position of the first three gates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, two small circles are drawn for each gate. The left circle is drawn
    by executing the following statement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The argument of the `Circle` constructor is a tuple composed of the *x* and
    *y* coordinates of the center and the radius. Here, the `draw` method of the window
    object is used, instead of the `draw_ex` method. It is simpler, as it does not
    require a transformation nor a *z* coordinate.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: And so, we have examined all the code of this project. In the next project,
    we'll show how we can add text and sound to our game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the assets_slalom project
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous project built was a valid slalom race, but that game had no sound
    or text to explain what was happening. This project, contained in the `assets_slalom`
    folder, just adds sound and text to the game of the previous project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot that was taken during a race:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcb74ea0-5d42-41a3-80f9-e507c120179b.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'In the top left of the window, there is the following information:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Elapsed time**: This tells us how many seconds or hundreds of seconds have
    elapsed since the start of the current race.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: This tells us how much is the current forward speed in pixels per
    second.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remaining gates**: This tells us how many gates remain to pass.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, a help message explains which commands are available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, four sounds have been added, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A tick at any start of a race
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A whoosh at any turn
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bump at any fail
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chime at any finish
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run the game to hear them. Notice that not all web browsers are
    equally capable of reproducing sounds.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how Quicksilver can show text and play sounds. Sounds and text
    are not so simple to use because of the fact that they need files; for text, one
    or more font files are needed; and for sounds, a sound file for any sound effect
    is needed. Such files must be stored in a folder named `static` in the root of
    the project. If you look in the said folder, you''ll find the following files:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`font.ttf`: This is a font in TrueType format.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click.ogg`: This is a short click sound, to be played at the start of a race.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whoosh.ogg`: This is a short friction sound, to be played when the ski is
    turning during a race.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bump.ogg`: This is a bump sound to express disapproval, to be played when
    the ski misses a gate.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two_notes.ogg`: This is a pair of notes to express satisfaction, to be played
    when the ski passes the finish gate.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such a `static` folder and its contained files must be deployed together with
    the executable program, as they are loaded at runtime by the program. They are
    usually also named *assets* as they are just data, not executable code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Quicksilver has chosen to load such assets in an asynchronous way, using the
    *future* *concept*. To load a sound from a file, the `Sound::load(«filename»)` expression is
    used. It receives a value implementing a reference to a path, such as a string,
    and it returns an object implementing the `Future` trait.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: An asset—that is, an object that encapsulates a future that is loading a file—is
    created by the `Asset::new(«future value»)` expression. It receives a value implementing
    a future, and it returns an `Asset` instance of the specific type. For instance,
    the `Asset::new(Sound::load("bump.ogg"))` expression returns a value of the `Asset<Sound>` type.
    Such a value is an asset that encapsulates a future—that is, reading a sound from
    the `bump.ogg` file. The sounds in this project are in the `.ogg` format, but
    Quicksilver is capable of reading several audio formats.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an asset encapsulating a future loading a file, you can access
    such a file in an expression such as `sound_future.execute(|sound_resource| sound_resource.play())`.
    Here, the `sound_future` variable is our asset. As it is a future, you have to
    wait for it to be ready. This is done using the `execute` method of the `Asset`
    type. It invokes the closure received as an argument, passing to it the encapsulated
    resource, which in this case is of the `Sound` type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sound` type has the `play` method, which starts to reproduce the sound.
    As usual in multimedia systems, such reproduction is asynchronous: you don''t
    have to wait for the end of the sound to proceed with the game. If you call `play`
    on a sound when the previous sound is still reproducing, the two sounds overlap,
    and if you play many of them, the resulting volume typically becomes very high.
    Therefore, you should keep your sounds very short, or play them seldom.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `Asset::new(Font::load("font.ttf"))` expression returns a value
    of the `Asset<Font>`. type. Such a value is an asset that encapsulates a future—that
    is, reading a font from the `font.ttf` file. You can use that font with the `font_future.execute(|font_resource|
    image = font_resource.render(&"Hello", &style))` expression. Here, the `font_future` variable
    is our asset. As it is a future, you have to wait for it using the `execute` method
    of the `Asset` type, which invokes the closure received as an argument, passing
    to it the encapsulated resource, which in this case is of the `Font` type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The `Font` type has the `render` method, which receives a string and a reference
    to a `FontStyle` value and creates an image containing that text, printed using
    that font and that font style.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the code
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And now, let''s see all the code of the project that differs from the previous
    project. There is a new constant, as can be seen in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is to solve the following problem. If the game has a frame rate of 50 FPS,
    the window is redrawn 50 times per second, and each time using the latest values
    of the variables. Regarding time, it is a number that would change so rapidly
    that it would be impossible to read. Therefore, this constant sets the maximum
    rate of change of the displayed time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The model has several new fields, as can be seen in the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The meaning of these fields is described as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`elapsed_sec` is the fractional number of seconds elapsed since the start of
    the current race, using the maximum resolution available.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elapsed_shown_sec` is the fractional number to show to the user as the number
    of elapsed seconds since the start of the current race.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font_style` contains the size and color of the text to print.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font` is the future value of the font to use to print the text of the screen.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whoosh_sound` is the future value of the sound to play during the turns of
    the running ski.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bump_sound` is the future value of the sound to play when a gate is missed.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click_sound` is the future value of the sound to play when a race is started.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two_notes_sound` is the future value of the sound to play when the finish
    gate is crossed.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A routine to play sounds has been defined, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It receives a future value of a sound and a volume. It calls `execute` to ensure
    the sound is loaded, and then sets the specified volume and plays that sound.
    Notice that the `execute` method returns a `Result`, to allow for possible errors.
    As in games sounds are not essential, we want to ignore possible errors regarding
    sounds, and so, we always return `Ok(())`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `steer` function, when a turn operation is performed and the ski is
    not already at an extreme angle, the following statement is performed:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It plays the whoosh sound and a volume that is proportional to the speed of
    the ski. In this way, if you rotate the ski when you are not running, you are
    silent.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The new fields of the model are initialized like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that, as `font_style`, a size of 16 points and a black color are set.
    We already described the other kind of expressions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` function, when the race is started by pressing the spacebar,
    the following statement is executed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It plays a click sound with a normal volume. When running, the elapsed time
    is computed like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `update_rate` function actually returns the time between frames, in milliseconds.
    So, if you divide it by 1,000, you get the seconds between each frame.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: If there is a high frame rate, such as 25 frames per second or more, showing
    the user different text at any frame can be confusing, as people cannot read a
    text that changes so rapidly. So, the second statement in the previous code snippet
    shows a technique to update the text at a lower rate. The `elapsed_shown_sec`
    field keeps the time of the last update, and the `elapsed_sec` field keeps the
    current time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The `MIN_TIME_DURATION` constant keeps the minimum duration by which a text
    must remain unchanged on screen before it can be updated. So, if the time elapsed
    from the time of the previous update to the current time is larger than such minimum
    duration, the text can be updated. In this particular case, the text to update
    is just the elapsed time in seconds, and so, if enough time has passed, the `elapsed_shown_sec` field
    is set to the current time. The `draw` routine will use that value to print the
    elapsed time on the screen.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Two other sounds are emitted. When the `mode` becomes `Failed`, the `play_sound`
    is called to play a bump sound. And when the `mode` becomes `Finished`, the `play_sound` is
    called to play a chime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it''s up to the draw routine to print all the text. First, the text is
    formatted in a new multi-line string, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The elapsed time and the speed are printed using two decimals; the remaining
    gates are computed by subtracting the disappeared gates to the total number of
    gates. In addition, if the current gate has been entered, the count of remaining
    gates is decremented by one. Then, some different words are printed according
    to the current mode.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'After having prepared the multiline string, the string is printed on a new
    image and stored in the `image` local variable, and the image is drawn on the
    window using the `draw` method, as a textured background. The method receives
    as a first argument the rectangular area to print, large as the whole bitmap,
    and, as a second argument, the `Img` variant of the `Background` type, constructed
    using the image, as illustrated in the following code snippet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, we have completed our examination of this simple but interesting framework.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how a complete game, running both on desktop and on the web, can
    be built using Rust and the Quicksilver framework, with the web version using
    the `cargo-web` command and the Wasm code generator. This game was structured
    according to the animation loop architecture and the MVC architectural pattern.
    We created three apps—`ski`, `silent_slalom`, and `assets_slalom`—and understood
    the implementation behind them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be seeing another 2D game framework, the `ggez`
    framework, oriented toward desktop applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the animation loop, and what are its advantages with respect to an event-driven
    architecture?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is an event-driven architecture better than an animation loop architecture?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which kinds of software can use the animation loop?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you draw triangles, rectangles, and circles using Quicksilver?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you receive input from the keyboard using Quicksilver?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are the controller and the view of MVC implemented using Quicksilver?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you vary the frame rate of animation using Quicksilver?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you load assets from files using Quicksilver, and where should you keep
    such assets?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you play sounds using Quicksilver?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you draw text on the screen using Quicksilver?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Quicksilver project can be downloaded from here: [https://github.com/ryanisaacg/quicksilver](https://github.com/ryanisaacg/quicksilver). This
    repository contains a link to a very short tutorial and some examples.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about generating Wasm code from a Rust project
    at [https://github.com/koute/cargo-web](https://github.com/koute/cargo-web).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
