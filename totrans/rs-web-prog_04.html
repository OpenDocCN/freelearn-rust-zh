<html><head></head><body>
		<div id="_idContainer045">
			<h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor073"/>4</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Processing HTTP Requests </h1>
			<p>Up to this point, we have utilized the Actix Web framework to serve basic views. However, this can only get us so far when it comes to extracting data from the request and passing data back to the user. In this chapter, we will fuse code from <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, Designing Your Web Application in Rust</em>, and <a href="B18722_03.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Handling HTTP Requests</em>, to build server views that process to-do items. We will then explore <strong class="bold">JSON serialization</strong> for extracting data and returning it to make our views more user friendly. We will also extract data from the header with middleware before it hits the view. We will explore the concepts around data serialization and extracting data from requests by building out the create, edit, and delete to-do item endpoints for our to-do application. </p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Getting to know the initial setup for <span class="No-Break">fusing code</span></li>
				<li>Passing parameters <span class="No-Break">into views</span></li>
				<li>Using macros for <span class="No-Break">JSON serialization</span></li>
				<li>Extracting data <span class="No-Break">from views</span></li>
			</ul>
			<p>Once you have finished this chapter, you will be able to build a basic Rust server that can send and receive data in the URL, in the body using JSON, and in the header of the HTTP request. This is essentially a fully functioning API Rust server without a proper database for data storage, the ability to authenticate users, or the ability to display content in the browser. However, these concepts will be covered in the next three chapters. You are on the home run for having a fully working Rust server that is up and running. Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>For this chapter, we need to download and install <strong class="bold">Postman</strong>. We will need Postman to make API requests to our server. You can download it <span class="No-Break">from </span><a href="https://www.postman.com/downloads/"><span class="No-Break">https://www.postman.com/downloads/</span></a><span class="No-Break">.</span></p>
			<p>We will also be building on the server code we created in the previous chapter, which can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app</a>. </p>
			<p>You can find the full source code that will be used in this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04</span></a><span class="No-Break">.</span></p>
			<p>Managing views code will be the basis of this chapter, and we will add features to this code base. We will be fusing this with the to-do module that we wrote in <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, which can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs"><span class="No-Break">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Getting to know the initial setup for fusing code</h1>
			<p>In<a id="_idIndexMarker354"/> this section, we will cover the initial setup of two fusing pieces of code we built in <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, and <a href="B18722_03.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Handling HTTP Requests</em>. This fusion will give us the <span class="No-Break">following structure:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_4.1_B18722.jpg" alt="Figure 4.1 – Structure of our app and its modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Structure of our app and its modules</p>
			<p>Here, we<a id="_idIndexMarker355"/> will register all the modules in the main file and then pull all these modules into the views to be used. We are essentially swapping the command-line interface from <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, with web views. Combining these modules gives us the following files in the <span class="No-Break">code base:</span></p>
			<pre class="source-code">
├── main.rs
├── processes.rs
├── state.rs</pre>
			<p>We are then bolting our <strong class="source-inline">to_do</strong> module into the same directory of our <strong class="source-inline">main.rs</strong> file. If you built the <strong class="source-inline">to_do</strong> module when reading <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, your <strong class="source-inline">to_do</strong> module should have the <span class="No-Break">following structure:</span></p>
			<pre class="source-code">
├── to_do
│   ├── enums.rs
│   ├── mod.rs
│   ├── structs
│   │   ├── base.rs
│   │   ├── done.rs
│   │   ├── mod.rs
│   │   └── pending.rs
│   └── traits
│       ├── create.rs
│       ├── delete.rs
│       ├── edit.rs
│       ├── get.rs
│       └── mod.rs</pre>
			<p>So now, our <a id="_idIndexMarker356"/>bolt on the <strong class="source-inline">views</strong> module from the previous chapter should contain <span class="No-Break">the following:</span></p>
			<pre class="source-code">
└── views
    ├── auth
    │   ├── login.rs
    │   ├── logout.rs
    │   └── mod.rs
    ├── mod.rs
    ├── path.rs</pre>
			<p>The full structure, with all the code, can be found in the following <span class="No-Break">GitHub repo:</span></p>
			<p><a href="https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup&#13;"><span class="No-Break">https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup</span></a></p>
			<p>Now that we have added modules from previous chapters to our project, we can bind them together in our program. To do this, we must create a new <strong class="source-inline">src/main.rs</strong> file. First, we must import the modules that we built and define a basic server using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use actix_web::{App, HttpServer};
mod views;
mod to_do;
mod state;
mod processes;
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        let app = App::new().configure(views::views_factory);
        return app
    })
        .bind("127.0.0.1:8000")?
        .run()
        .await
}</pre>
			<p>In the preceding code, we defined the modules and then our server. Because the server is utilizing <strong class="source-inline">views_factory</strong>, we will not have to alter this file for the rest of this chapter. Instead, we will chain our factory functions that will be called in the <strong class="source-inline">views_factory</strong> function. </p>
			<p>At this point, we can sit back and appreciate the dividends of all the hard work that we did in the previous chapters. The isolation of principles and well-defined modules have enabled us to slot our logic from our command-line program into our server interface with minimal effort. Now, all we have to do is connect it to our <strong class="source-inline">views</strong> module, and pass parameters into those views. Before we move on to the next section, however, there is some minor housekeeping we must do to ensure that our server can run. First, our dependencies in the <strong class="source-inline">Cargo.toml</strong> file have the <span class="No-Break">following requirements:</span></p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"</pre>
			<p>We can then<a id="_idIndexMarker357"/> do a <strong class="source-inline">cargo run</strong> command, showing that our login and logout views work in our browser. With this done, we can start working on passing parameters into views. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Passing parameters into views </h1>
			<p>In <a id="_idIndexMarker358"/>this section, we will cover the initial setup of fusing two <a id="_idIndexMarker359"/>modules to create a to-do item and store it through a view. To do this, we will have to pass in the title of the to-do item into our <strong class="source-inline">create</strong> view that creates a to-do item. We can pass data into a view using the <span class="No-Break">following routes:</span></p>
			<ul>
				<li><strong class="bold">URL</strong>: Data and parameters can be passed inside the URL of the request. This is generally used in simple cases as it is easy <span class="No-Break">to implement.</span></li>
				<li><strong class="bold">body</strong>: Data can be stored under different fields in the request body. This is used for more complex data structures and bigger payloads. </li>
				<li><strong class="bold">header</strong>: Data can be stored under different fields in the request header. This is used to store metadata about the request being sent. We also store the authentication data of the request in the header.  </li>
			</ul>
			<p>We will cover all<a id="_idIndexMarker360"/> these approaches throughout our project, but for<a id="_idIndexMarker361"/> now, we will pass our data using the URL method as this is the easiest introduction method. First, we will create the structure for our to-do views with the <span class="No-Break">following layout:</span></p>
			<pre class="source-code">
└── views
    ├── auth
    │   ├── login.rs
    │   ├── logout.rs
    │   └── mod.rs
    ├── mod.rs
    └── to_do
        ├── create.rs
        └── mod.rs</pre>
			<p>We can see that we have put our <strong class="source-inline">to-do</strong> views in their own <strong class="source-inline">views</strong> module next to the <strong class="source-inline">to_do</strong> module. We will keep stacking our views in this way so that we can slot them in and out of our server and slot them into other projects if needed. For now, creating a to-do item will take the <span class="No-Break">following form:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.2_B18722.jpg" alt="Figure 4.2 – Process of creating a to-do item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Process of creating a to-do item</p>
			<p>To carry out the process demonstrated in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>, we need to perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Load the current state of the to-do item list. </li>
				<li>Get the title of the new to-do item from the URL. </li>
				<li>Pass the title and the status <strong class="source-inline">pending</strong> through <strong class="source-inline">to_do_factory</strong>. </li>
				<li>Pass the result of the previous step along with the string <strong class="source-inline">create</strong> and the state into the process <span class="No-Break">module interface.</span></li>
				<li>Return a string to the user to signal that the process <span class="No-Break">has finished.</span></li>
			</ol>
			<p>We can carry out<a id="_idIndexMarker362"/> these steps defined previously in the <strong class="source-inline">views/to_do/create.rs</strong> file. First <a id="_idIndexMarker363"/>of all, we must import what we need with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde_json::value::Value;
use serde_json::Map;
use actix_web::HttpRequest;
use crate::to_do::{to_do_factory, enums::TaskStatus};
use crate::state::read_file;
use crate::processes::process_input;</pre>
			<p>We will use <strong class="source-inline">serde_json::value::Value</strong> and <strong class="source-inline">serde_json::Map</strong> to define what type of data we are reading from the <strong class="source-inline">state.json</strong> file and to extract the title from the URL using the <strong class="source-inline">HttpRequest</strong> struct. We will then import what we need from our other modules to enable us to create an item, read the state file, and process the input. Our view can be defined through the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn create(req: HttpRequest) -&gt; String {
    let state: Map&lt;String, Value&gt; = read_file(
        "./state.json"); // step 1
    let title: String = req.match_info().get("title"
    ).unwrap().to_string(); // step 2
    let item = to_do_factory(&amp;title.as_str(), 
                             TaskStatus::PENDING); // step 3
    process_input(item, "create".to_string(), &amp;state);
    // step 4
    return format!("{} created", title) // step 5
}</pre>
			<p>We need to <a id="_idIndexMarker364"/>remember that this is an <strong class="source-inline">async</strong> function because it is a <a id="_idIndexMarker365"/>view that our server is processing. We can also see that our <strong class="source-inline">title</strong> is extracted from <strong class="source-inline">HttpRequest</strong> by using the <strong class="source-inline">match_info</strong> function. We must directly unwrap it because if there is no title in the URL, then we do not want to continue with the process of making an item and then converting the extracted title to <strong class="source-inline">String</strong>. We then need to pass a reference of this to our <strong class="source-inline">to_do_factory</strong> to create an <strong class="source-inline">ItemTypes</strong> <strong class="source-inline">enum</strong>. We then pass our <strong class="source-inline">enum</strong> with a command and a reference to the current state of our application into our <strong class="source-inline">process_input</strong> function, which, as we remember, will go through a series of steps to work out how to handle the state based on the command and item type passed in. There is a lot going on here, but it must be noted none of the logic around how to process the item is in this view. This is called the separation of concerns of code orthogonality. Code orthogonality refers to the following <span class="No-Break">mathematical concept:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.3_B18722.jpg" alt="Figure 4.3 – Mathematical concept of orthogonality "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Mathematical concept of orthogonality </p>
			<p>We can<a id="_idIndexMarker366"/> see in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em> that if a vector is orthogonal to another<a id="_idIndexMarker367"/> vector then it is said to have no projection onto another vector. In physics, if the vectors are forces, these vectors do not have any effect on each other. Now, this cannot be completely true in programming: if we delete the code in our <strong class="source-inline">processes</strong> module, it will affect the <strong class="source-inline">create</strong> view as we must reference it. However, the logic of <strong class="source-inline">processes</strong> should not be defined in the <strong class="source-inline">create</strong> view. This is partly because we must use <strong class="source-inline">processes</strong> elsewhere, but this is not the entire story. When we look at the <strong class="source-inline">create</strong> view, we can see the logic around creating a pending item in relation to the rest of the application. This makes it easy for developers to know exactly what’s going on. They are not getting lost in details that are not relevant to the five steps we specified earlier in this section to create a to-do item. If the developer wants to explore the logic around the saving of the item, they can investigate the file that defines this. </p>
			<p>We must now make the views in our <strong class="source-inline">to_do</strong> module available to the outside. We can do this by creating a to-do views factory function in the <strong class="source-inline">views/to_do/mod.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, get, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", get().to(create::create))
    );
}</pre>
			<p>In the preceding<a id="_idIndexMarker368"/> code, we can see that we do not make the <strong class="source-inline">create</strong> view public <a id="_idIndexMarker369"/>but we do use it in our factory to define the view. We also define the title being passed into the URL with the <strong class="source-inline">/{title}</strong> tag. Now that our item views are functional, we need to plug <strong class="source-inline">to_do_views_factory</strong> into our application in the <strong class="source-inline">views/mod.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod auth;
mod to_do; // define the module
use auth::auth_views_factory;
use to_do::to_do_views_factory; // import the factory 
use actix_web::web::ServiceConfig;
pub fn views_factory(app: &amp;mut ServiceConfig) {
    auth_views_factory(app);
    to_do_views_factory(app); // pass the ServiceConfig 
}</pre>
			<p>In the preceding code, we <a id="_idIndexMarker370"/>can see that we have defined the module, imported the factory, and then passed the application configuration. With this done, our<a id="_idIndexMarker371"/> application is ready to run and create to-do items. When our application is running, we can create the item with the <span class="No-Break">following URL:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.4_B18722.jpg" alt="Figure 4.4 – View to create a to-do item "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – View to create a to-do item </p>
			<p>If we look at the console, we will see the <span class="No-Break">following printout:</span></p>
			<pre class="console">
learn to code rust is being created</pre>
			<p>If we look at the <strong class="source-inline">state.json</strong> file in the root, we will get the <span class="No-Break">following data:</span></p>
			<pre class="console">
{"learn to code rust":"PENDING"}</pre>
			<p>We can see that our process to create a to-do item worked! Our application takes in a title from the URL, creates a pending to-do item, and saves it in our JSON file. While this is a milestone, it must be noted that a JSON file is not the best solution for data storage. It will do for now, however, as we will configure a proper database in <a href="B18722_06.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Data Persistence with PostgreSQL</em>. We can also see <strong class="source-inline">%20</strong> in the URL, which denotes a space. We can see that this space translates to the console printout and the saving of the data to the JSON file, and this space is also in the view displayed in the browser. What we have done is take in a to-do item title via the URL, print it out to the terminal, display it in the browser, and save it in a JSON file. We have essentially performed the basis for a web application as we can display data to a user and store it in a file.  </p>
			<p>The <strong class="source-inline">GET</strong> method works for us, but it is not the most appropriate method for creating a to-do item. <strong class="source-inline">GET</strong> methods can be cached, bookmarked, kept in the browser’s history, and have restrictions in terms of their length. Bookmarking, storing them in browser history, or caching them doesn’t just present security issues; it also increases the risk of the user accidentally making the same call again. Because of this, it is not a good idea to alter data with a <strong class="source-inline">GET</strong> request. To protect against this, we can use a <strong class="source-inline">POST</strong> request, which does not cache, does not end up in browser history, and cannot <span class="No-Break">be bookmarked.</span></p>
			<p>Because of the reasons we laid out, we will now turn our <strong class="source-inline">create</strong> view into a <strong class="source-inline">POST</strong> request. Remember our comments on code orthogonality. What defines how the routes of our views are processed is kept in our factory in <a id="_idIndexMarker372"/>the <strong class="source-inline">views/to_do/mod.rs</strong> file with the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker373"/></span><span class="No-Break">code:</span></p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, post, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create", post().to(create::create))
    );
}</pre>
			<p>In the preceding code, we can see that we have merely changed the <strong class="source-inline">get</strong> to <strong class="source-inline">post</strong> in the import and the <strong class="source-inline">route</strong> definition. If we try and create a new to-do item using the previous approach, we get the <span class="No-Break">following outcome:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.5_B18722.jpg" alt="Figure 4.5 – Blocked method "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Blocked method </p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.5</em>, we can <a id="_idIndexMarker374"/>see that the page cannot be found. This might be confusing <a id="_idIndexMarker375"/>as the error is a 404-error stating that the page can’t be found. The URL is still defined, but the <strong class="source-inline">GET</strong> method is no longer allowed for this URL. With this in mind, we can make a <strong class="source-inline">POST</strong> call using the following <span class="No-Break">Postman configuration:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.6_B18722.jpg" alt="Figure 4.6 – Postman post method for creating an item "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Postman post method for creating an item </p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.6</em>, we can see <a id="_idIndexMarker376"/>that our URL is still working with just a different <a id="_idIndexMarker377"/>method—the <strong class="source-inline">POST</strong> method. We can inspect our state file, finding the <span class="No-Break">following data:</span></p>
			<pre class="console">
{"learn to code rust":"PENDING","washing":"PENDING"}</pre>
			<p>We can see that changing the allowed method for the <strong class="source-inline">create</strong> view did not affect the way in which we create or store to-do items. Looking back at <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.6</em>, we can also see that we get a status code of <strong class="source-inline">200</strong>, which is <strong class="source-inline">OK</strong>. This already tells us that the creation has happened. Because of this, we do not have to return anything as the status is <strong class="source-inline">OK</strong>. </p>
			<p>Looking back at what we get when we try and send a <strong class="source-inline">GET</strong> request to our <strong class="source-inline">create</strong> view, we get a <strong class="bold">not found</strong> error. Can you think what this means? Is there anything stopping us from reusing the same URL but with a different method? Well, if the view cannot be found, then there should not be anything stopping us from using the same URL with a different method. This can be done in the <strong class="source-inline">views/to_do/mod.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
app.service(
    scope("v1/item")
    .route("create/{title}", post().to(create::create))
    .route("create/{title}", get().to(create::create))
);</pre>
			<p>We can see that this works if we put our URL in our browser, which results in creating a pending to-do item. We also have the option to put a different function in our <strong class="source-inline">get</strong> route with the same URL if needed. This gives us flexibility on how to use and reuse our URLs. However, considering the differences that we covered between the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> methods, it is sensible to just have a <strong class="source-inline">POST</strong> method for our <strong class="source-inline">create</strong> function.  </p>
			<p>We have now done all that we need to when it comes to creating our to-do item. However, in other views, we will have to return structured data to present the current state of our to-do items. </p>
			<p>So far, we have<a id="_idIndexMarker378"/> passed data into our application using a URL, which is the <a id="_idIndexMarker379"/>most basic way in which we can pass data. However, we cannot pass structured data using a URL. For instance, if we wanted to send a hashmap or a list, a URL is just not able to house such structures. This is where we need to pass data to our application in the body of the request using JSON, which we will cover in the next section. </p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Using macros for JSON serialization  </h1>
			<p>When it comes to <a id="_idIndexMarker380"/>serializing data and returning it to the client, we can achieve this quickly with minimal code using the JSON from the <strong class="source-inline">Actix-web</strong> crate. We can demonstrate this by creating a <strong class="source-inline">GET</strong> view that returns all our to-do items in the <span class="No-Break"><strong class="source-inline">views/to_do/get.rs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
use actix_web::{web, Responder};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
pub async fn get() -&gt; impl Responder {
    let state: Map&lt;String, Value&gt; = read_file("./state.json");
    return web::Json(state);
}</pre>
			<p>Here, we can see that we are merely reading the JSON from the JSON file and then returning the values from this wrapped in the <strong class="source-inline">web::Json</strong> function. It might make sense to just return <strong class="source-inline">Map&lt;String, Value&gt;</strong> from the JSON file directly, as it is a <strong class="source-inline">String</strong> and <strong class="source-inline">Value</strong>. However, the type of <strong class="source-inline">Map&lt;String, Value&gt;</strong> does not implement the <strong class="source-inline">Responder</strong> trait. We could update the function to return the state directly with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn get() -&gt; Map&lt;String, Value&gt;  {
    let state: Map&lt;String, Value&gt; = read_file("./state.json");
    return state;
}</pre>
			<p>However, this will <a id="_idIndexMarker381"/>not work because the <strong class="source-inline">get().to()</strong> function in the <strong class="source-inline">views/to_do/mod.rs</strong> file needs to accept a struct that has implemented the <strong class="source-inline">Responder</strong> trait. We can now plug in our <strong class="source-inline">get</strong> view in the <strong class="source-inline">views/to_do/mod.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod create;
mod get; // import the get file 
use actix_web::web::{ServiceConfig, post, get, scope};
// import get
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", post().to(create::create))
        .route("get", get().to(get::get)) // define view and URL
    );
}</pre>
			<p>Running the URL <strong class="source-inline">http://127.0.0.1:8000/item/get</strong> gives us the following JSON data in the <span class="No-Break">response body:</span></p>
			<pre class="console">
{
    "learn to code rust": "PENDING",
    "washing": "PENDING"
}</pre>
			<p>We now have <a id="_idIndexMarker382"/>some structured data that we can present to the frontend. While this essentially gets the job done, it is not too helpful. For instance, we would like to have two different lists for <em class="italic">pending</em> and <em class="italic">done</em>. We could also add timestamps telling users when the to-do item was created or edited. Simply returning the titles and the statuses of the to-do items will not enable us to scale complexity when needed. </p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Building our own serialization struct</h2>
			<p>To have <a id="_idIndexMarker383"/>more control over the type of data that we are going to return to the user, we are going to have to build our own serialization structs. Our serialization struct is going to present two lists, one for completed items and another for pending items. The lists will be populated with objects consisting of a title and a status. If we recall from <a href="B18722_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Designing Your Web Application in Rust</em>, our <strong class="source-inline">pending</strong> and <strong class="source-inline">Done</strong> item structs are inherited via composition from a <strong class="source-inline">Base</strong> struct. Therefore, we must access the title and the status from the <strong class="source-inline">Base</strong> struct. However, our <strong class="source-inline">Base</strong> struct is not accessible to the public. We will have to make it accessible so that we can serialize the attributes for each <span class="No-Break">to-do item:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.7_B18722.jpg" alt="Figure 4.7 – Relationship that our to-do structs have with our interfaces "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Relationship that our to-do structs have with our interfaces </p>
			<p>Looking at <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.7</em>, we can<a id="_idIndexMarker384"/> see that the <strong class="source-inline">TaskStatus enum</strong> is the root of the dependency. We need to be able to serialize this <strong class="source-inline">enum</strong> before we can serialize our to-do items. We can use the <strong class="source-inline">serde</strong> crate for this. In order to do this, we must update our dependencies in the <span class="No-Break"><strong class="source-inline">Cargo.toml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"
serde = { version = "1.0.136", features = ["derive"] }</pre>
			<p>We can see<a id="_idIndexMarker385"/> that we have added the <strong class="source-inline">features = ["derive"]</strong>. This will enable us to decorate our structs with <strong class="source-inline">serde</strong> traits. We can now look at how we defined our <strong class="source-inline">enum</strong> in the <strong class="source-inline">src/to_do/enums.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub enum TaskStatus {
    DONE,
    PENDING
}
impl TaskStatus {
    pub fn stringify(&amp;self) -&gt; String {
        match &amp;self {
            &amp;Self::DONE =&gt; {return "DONE".to_string()},
            &amp;Self::PENDING =&gt; 
                {return "PENDING".to_string()}
        }
    }
    pub fn from_string(input_string: String) -&gt; Self {
        match input_string.as_str() {
            "DONE" =&gt; TaskStatus::DONE,
            "PENDING" =&gt; TaskStatus::PENDING,
            _ =&gt; panic!("input {} not supported", 
                        input_string)
        }
    }
}</pre>
			<p>In the preceding code, we can see that we have two fields named <strong class="source-inline">DONE</strong> and <strong class="source-inline">PENDING</strong>; however, they are essentially their own types. How can we serialize this as a JSON value? There is a clue in the <strong class="source-inline">stringify</strong> function. However, this is not the full picture. Remember, the return values of our server views need to implement traits. We can implement a <strong class="source-inline">serde</strong> trait for our <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong> by initially importing the traits that we need in <a id="_idIndexMarker386"/>the <strong class="source-inline">src/to_do/enums.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::ser::{Serialize, Serializer, SerializeStruct};</pre>
			<p>We now have everything we need to implement the <strong class="source-inline">Serialize</strong> trait so we can customize how the structs that we write can be serialized in the following section. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Implementing the Serialize trait</h2>
			<p><strong class="source-inline">Serialize</strong> is the<a id="_idIndexMarker387"/> trait that we will implement, and <strong class="source-inline">Serializer</strong> is a data formatter that can serialize any data format that is supported by <strong class="source-inline">serde</strong>. We can then implement a <strong class="source-inline">Serialize</strong> trait for our <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl Serialize for TaskStatus {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, 
                    S::Error&gt;
    where
        S: Serializer,
    {
        Ok(serializer.serialize_str(&amp;self.stringify()
                                   .as_str())?)
    }
}</pre>
			<p>This is a standard approach that is defined in the <strong class="source-inline">serde</strong> documents. In the preceding code, we can see a <strong class="source-inline">serialize</strong> function has been defined. The <strong class="source-inline">serialize</strong> function gets called when serializing our <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong>. We also notice that the type of notation for <strong class="source-inline">serializer</strong> is <strong class="source-inline">S</strong>. We then use a <strong class="source-inline">where</strong> statement defining <strong class="source-inline">S</strong> as <strong class="source-inline">Serializer</strong>. This may seem counterintuitive, so we can take a step back from our application to explore it. The following code blocks are not needed to complete our application. </p>
			<p>Let us define<a id="_idIndexMarker388"/> some basic structs <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
#[derive(Debug)]
struct TwoDposition {
    x: i32,
    y: i32
}
#[derive(Debug)]
struct ThreeDposition {
    x: i32,
    y: i32,
    z: i32
}</pre>
			<p>In the preceding code, we can see that we implement the <strong class="source-inline">Debug</strong> trait for both the <strong class="source-inline">TwoDposition</strong> and <strong class="source-inline">ThreeDposition</strong> structs. We can then define functions that print a debug statement for each <strong class="source-inline">struct</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn print_two(s: &amp;TwoDposition) {
    println!("{:?}", s);
}
fn print_three(s: &amp;ThreeDposition) {
    println!("{:?}", s);
}</pre>
			<p>However, we can see that this does not scale well. We would be writing a function for everything that implements it. Instead, we can use a <strong class="source-inline">where</strong> statement so we can pass both of our structs into it as they implement the <strong class="source-inline">Debug</strong> trait. First, we must import the trait with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use core::fmt::Debug;</pre>
			<p>We can then<a id="_idIndexMarker389"/> define our flexible function with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn print_debug&lt;S&gt;(s: &amp;S)
where
    S: Debug {
    println!("{:?}", s);    
}</pre>
			<p>What is happening here is that our function is generic in terms of the type of variable that we are passing into the function. We then take a reference to a value of the type <strong class="source-inline">S</strong>. This means that <strong class="source-inline">S</strong> can be any type if it implements the <strong class="source-inline">Debug</strong> trait. If we try and pass in a <strong class="source-inline">struct</strong> that does not implement the <strong class="source-inline">Debug</strong> trait, the compiler will refuse to compile. So, what is happening when we compile? Run the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn main() {
    let two = TwoDposition{x: 1, y: 2};
    let three = ThreeDposition{x: 1, y: 2, z: 3};    
    print_debug(&amp;two);
    print_debug(&amp;three);
}</pre>
			<p>We will get the <span class="No-Break">following printout:</span></p>
			<pre class="console">
TwoDposition { x: 1, y: 2 }
ThreeDposition { x: 1, y: 2, z: 3 }</pre>
			<p>The preceding output makes sense as this is the result of printing when invoking the debug trait. However, they are two different functions that are created when the compiler is compiling. Our compiler compiled the following <span class="No-Break">two functions:</span></p>
			<pre class="source-code">
print_debug::&lt;TwoDposition&gt;(&amp;two);
print_debug::&lt;ThreeDposition&gt;(&amp;three);</pre>
			<p>This is not <a id="_idIndexMarker390"/>breaking what we know in terms of how Rust works; however, it does make our code more scalable. There are more advantages to using a <strong class="source-inline">where</strong> statement; for instance, we could specify what traits we need in an iterator with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fn debug_iter&lt;I&gt;(iter: I)
where
    I: Iterator
    I::Item: Debug
{
    for item in iter {
        println!("{:?}", iter);
    }
}</pre>
			<p>In the preceding code, we can see that we are accepting an iterator and that the items in the iterator need to implement the <strong class="source-inline">Debug</strong> trait. However, if we keep exploring the implementation of traits, we can lose focus of our main goal in this book: web programming in Rust.  </p>
			<p>With the <a id="_idIndexMarker391"/>knowledge of using the <strong class="source-inline">where</strong> statement to implement traits, we can look back at our implementation of the <strong class="source-inline">Serialize</strong> trait in the <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong>: </p>
			<pre class="source-code">
impl Serialize for TaskStatus {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, 
                                                  S::Error&gt;
    where
        S: Serializer,
    {
        Ok(serializer.serialize_str(&amp;self.stringify()
                                    .as_str())?)
    }
}</pre>
			<p>We can see that we merely call the <strong class="source-inline">stringify</strong> function and wrap it in an <strong class="source-inline">Ok</strong> result. We only want the status as a <strong class="source-inline">String</strong> as we are slotting it into a bigger body of data. If it was a struct with fields, then we could write the <strong class="source-inline">serialize</strong> function as follows: </p>
			<pre class="source-code">
fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
where
    S: Serializer,
{
    let mut s = serializer.serialize_struct("TaskStatus", 
                                             1)?;
    s.serialize_field("status", &amp;self.stringify())?;
    s.end()
}</pre>
			<p>In the preceding code, our serializer is the struct called <strong class="source-inline">"TaskStatus"</strong> with the number of fields being one. We then attributed the result of the <strong class="source-inline">stringify</strong> function to the <strong class="source-inline">status</strong> field. Doing this essentially gives us the <span class="No-Break">following structure:</span></p>
			<pre class="source-code">
#[derive(Serialize)]
struct TaskStatus {
    status: String
}</pre>
			<p>However, we <a id="_idIndexMarker392"/>will not utilize the <strong class="source-inline">serialize_struct</strong> approach for our current exercise as we will need the status to be inserted into a bigger body to <span class="No-Break">be returned.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Integrating serialization structs into our application code</h2>
			<p>Now that we have <a id="_idIndexMarker393"/>enabled our <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong> to be serialized, we can look back at <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.7</em> and see that our <strong class="source-inline">Base</strong> struct is next to be serialized. We can also see that the <strong class="source-inline">Base</strong> struct is the key to JSON serialization, but it is currently not public, so we need to make it public. This can be done by changing the declaration of the base module in the <strong class="source-inline">to_do/structs/mod.rs</strong> file from <strong class="source-inline">mod base;</strong> to <strong class="source-inline">pub mod base;</strong>. Now that the <strong class="source-inline">Base</strong> struct is directly available outside of the module, we can build our own <strong class="source-inline">json_serialization</strong> module in the <strong class="source-inline">src</strong> directory with the following structure:   </p>
			<pre class="source-code">
├── main.rs
├── json_serialization
│   ├── mod.rs
│   └── to_do_items.rs</pre>
			<p>We will define what we will return to the viewer when the <strong class="source-inline">get</strong> view is called in the <strong class="source-inline">src/json_serialization/to_do_items.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::Serialize;
use crate::to_do::ItemTypes;
use crate::to_do::structs::base::Base;
#[derive(Serialize)]
pub struct ToDoItems {
    pub pending_items: Vec&lt;Base&gt;,
    pub done_items: Vec&lt;Base&gt;,
    pub pending_item_count: i8,
    pub done_item_count: i8
}</pre>
			<p>In the<a id="_idIndexMarker394"/> preceding code, all we have done is define a standard public struct’s parameters. We then used the <strong class="source-inline">derive</strong> macro to implement the <strong class="source-inline">Serialize</strong> trait. This enables the struct’s attributes to be serialized to JSON with the name of the attribute as the key. For instance, if the <strong class="source-inline">ToDoItems</strong> struct had a <strong class="source-inline">done_item_count</strong> of one, then the JSON body would denote it as <strong class="source-inline">"done_item_count": 1</strong>. We can see that this is easier than the manual serialization that we did for our <strong class="source-inline">TaskStatus</strong> <strong class="source-inline">enum</strong> earlier. This is because the format of our fields is straightforward. If we do not need any extra logic during the serialization, decorating our <strong class="source-inline">ToDoItems</strong> with the <strong class="source-inline">Serialize</strong> trait is the easiest approach, which will result in fewer errors.  </p>
			<p>Now that serialization is defined, we must consider the processing of the data. It would not be scalable if we must sort the data and count it before calling the <strong class="source-inline">struct</strong>. This would add unnecessary code into the view that processes data for serialization as opposed to the logic belonging to the view in question. It would also enable duplicate code. There is only going to be one way we sort, count, and serialize the data. If other views are needed to return the list of items, then we would have to duplicate the <span class="No-Break">code again.</span></p>
			<p>Considering this, it makes sense to build a constructor for the struct where we ingest a vector of to-do items, sort them into the right attributes, and then count them. We can define the constructor with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl ToDoItems {
    pub fn new(input_items: Vec&lt;ItemTypes&gt;) -&gt; ToDoItems {
        . . . // code to be filled in
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker395"/>code, we can see that our constructor takes in a vector of to-do items that we will have loaded from our JSON file. Inside our constructor, we must carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Sort the items into two vectors, one for pending items, and the other for <span class="No-Break">complete items.</span></li>
			</ol>
			<p>We will merely loop through the vector of items appending to different vectors depending on the item type with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let mut pending_array_buffer = Vec::new();
let mut done_array_buffer = Vec::new();
for item in input_items {
    match item {
        ItemTypes::Pending(packed) =&gt; pending_array_buffer.
            push(packed.super_struct),
        ItemTypes::Done(packed) =&gt; done_array_buffer.push(
            packed.super_struct)
    }
}</pre>
			<ol>
				<li value="2">Count the total number of pending and complete items. </li>
			</ol>
			<p>For the next step, we can then call the <strong class="source-inline">len</strong> function on each vector. The <strong class="source-inline">len</strong> function returns <strong class="source-inline">usize</strong>, which is a pointer-sized unsigned integer type. Because of this, we can cast it as <strong class="source-inline">i8</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let done_count: i8 = done_array_buffer.len() as i8;
let pending_count: i8 = pending_array_buffer.len() as i8;</pre>
			<ol>
				<li value="3">We now<a id="_idIndexMarker396"/> have all the data that we need for constructing and returning the struct, which can be defined using the <span class="No-Break">following code:</span><pre class="source-code">
return ToDoItems{</pre><pre class="source-code">
    pending_items: pending_array_buffer, </pre><pre class="source-code">
    done_item_count: done_count,</pre><pre class="source-code">
    pending_item_count: pending_count, </pre><pre class="source-code">
    done_items: done_array_buffer</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Now our constructor is done. </p>
			<p>We can now build our struct using this function. All we must do is plug it into our application so that we can pass it into our application. In the <strong class="source-inline">json_serialization/mod.rs</strong> file, we can make it public with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub mod to_do_items;</pre>
			<p>We can now declare our module in the <strong class="source-inline">src/main.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
mod json_serialization;</pre>
			<p>We also must ensure that our <strong class="source-inline">base</strong> module is public in the <strong class="source-inline">src/to_do/structs/mod.rs</strong> file. We are going to be serializing the | struct when returning data which can be achieved in the <strong class="source-inline">src/to_do/structs/base.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub mod to_do_items;
use super::super::enums::TaskStatus;
use serde::Serialize;
#[derive(Serialize)]
pub struct Base {
    pub title: String,
    pub status: TaskStatus
}</pre>
			<p>To utilize<a id="_idIndexMarker397"/> our struct, we must define it in our <strong class="source-inline">GET</strong> view in our <strong class="source-inline">views/to_do/get.rs</strong> file and return it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use actix_web::{web, Responder};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
use crate::to_do::{ItemTypes, to_do_factory, enums::TaskStatus};
use crate::json_serialization::to_do_items::ToDoItems;
pub async fn get() -&gt; impl Responder {
    let state: Map&lt;String, Value&gt; = read_file(
                                    "./state.json");
    let mut array_buffer = Vec::new();
    for (key, value) in state {
        let status = TaskStatus::from_string(
                          &amp;value.as_str().unwrap())
                                      .to_string();
        let item: ItemTypes = to_do_factory(
                                &amp;key, status);
        array_buffer.push(item);
    }
    let return_package: ToDoItems = ToDoItems::new(
                                     array_buffer);
    return web::Json(return_package);
}</pre>
			<p>The preceding <a id="_idIndexMarker398"/>code is another example of a moment where everything clicks together. We use our <strong class="source-inline">read_file</strong> interface to get the state from the JSON file. We can then loop through the map converting the item type into a string and feed it into our <strong class="source-inline">to_do_factory</strong> interface. Once we have the constructed item from the factory, we append it to a vector and feed that vector into our JSON serialization struct. After hitting the <strong class="source-inline">get</strong> view, we receive the following <span class="No-Break">JSON body:</span></p>
			<pre class="console">
{
    "pending_items": [
        {
            "title": "learn to code rust",
            "status": "PENDING"
        },
        {
            "title": "washing",
            "status": "PENDING"
        }
    ],
    "done_items": [],
    "pending_item_count": 2,
    "done_item_count": 0
}</pre>
			<p>We now have a well-structured response that we can expand on and edit. The development of applications never stops so if you were going to continue to maintain this application you will be adding features to this return JSON body. We will soon move onto other views. However, before we do this, we must acknowledge that we will be returning the <a id="_idIndexMarker399"/>full list of items with counts every time we make an API call. Therefore, we must package this response in a function for every function; otherwise, we will be writing the same code that we wrote in the <strong class="source-inline">get</strong> view for every other view. In the next section, we will cover how we can package our to-do items so that they can be returned in multiple views. </p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Packaging our custom serialized struct to be returned to users</h2>
			<p>Now, our <strong class="source-inline">GET</strong> view returns <a id="_idIndexMarker400"/>an implementation of the <strong class="source-inline">Responder</strong> trait. This means that if our <strong class="source-inline">ToDoItems</strong> struct also implements this, it can be directly returned in a view. We can do this in our <strong class="source-inline">json_serialization/to_do_items.rs</strong> file. First, we must import the following structs <span class="No-Break">and traits:</span></p>
			<pre class="source-code">
use serde::Serialize;
use std::vec::Vec;
use serde_json::value::Value;
use serde_json::Map;
use actix_web::{
    body::BoxBody, http::header::ContentType, 
    HttpRequest, HttpResponse, Responder,
};
use crate::to_do::ItemTypes;
use crate::to_do::structs::base::Base;
use crate::state::read_file;
use crate::to_do::{to_do_factory, enums::TaskStatus};</pre>
			<p>We can<a id="_idIndexMarker401"/> see from the <strong class="source-inline">actix_web</strong> crate that we have imported a range of structs and traits that will enable us to build an HTTP response. We can now implement the <strong class="source-inline">get</strong> view code in a <strong class="source-inline">get_state</strong> function for the <strong class="source-inline">ToDoItems</strong> struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl ToDoItems {
    pub fn new(input_items: Vec&lt;ItemTypes&gt;) -&gt; ToDoItems {
        . . .
    }
    pub fn get_state() -&gt; ToDoItems {
        let state: Map&lt;String, Value&gt; = read_file("./state.            json");
        let mut array_buffer = Vec::new();
        for (key, value) in state {
            let status = TaskStatus::from_string(&amp;value
                         .as_str().unwrap().to_string());
            let item = to_do_factory(&amp;key, status);
            array_buffer.push(item);
        }
        return ToDoItems::new(array_buffer)
    }
}</pre>
			<p>The<a id="_idIndexMarker402"/> preceding code enables us to get all the to-do items from our JSON file with just one line of code. We must enable our <strong class="source-inline">ToDoItems</strong> struct to be returned in a view by implementing the <strong class="source-inline">Responder</strong> trait with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl Responder for ToDoItems {
    type Body = BoxBody;
    fn respond_to(self, _req: &amp;HttpRequest) 
                            -&gt; HttpResponse&lt;Self::Body&gt; {
        let body = serde_json::to_string(&amp;self).unwrap();
        HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(body)
    }
}</pre>
			<p>In the preceding code, what we have essentially done is serialize our <strong class="source-inline">ToDoItems</strong> struct using the <strong class="source-inline">serde_json</strong> crate, and then returned an HTTP response with the <strong class="source-inline">ToDoItems</strong> struct at the body. The <strong class="source-inline">respond_to</strong> function will be called when our <strong class="source-inline">ToDoItems</strong> struct is being returned in a view. Now this is where it gets really cool. We can rewrite our <strong class="source-inline">views/to_do/get.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use actix_web::Responder;
use crate::json_serialization::to_do_items::ToDoItems;
pub async fn get() -&gt; impl Responder {
    return ToDoItems::get_state();
}</pre>
			<p>That is it! If <a id="_idIndexMarker403"/>we run our application now, we will get the same response as we had before. With this, we can see how traits can abstract code for our views. Now that we have created the <strong class="source-inline">get</strong> view, we must work on building other views that create, edit, and delete. To do this, we are going to move on to our next section, which is extracting data from our views. </p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Extracting data from views</h1>
			<p>In this section, we are <a id="_idIndexMarker404"/>going to explore extracting data from our HTTP requests<a id="_idIndexMarker405"/> from the header and body. We are then going to use these methods to edit, delete to-do items, and intercept requests before they are fully loaded with middleware. We will go one step at a time. For now, let us extract data from the body of the HTTP request to edit a to-do item. When it comes to accepting data in JSON format, we should do what we have been doing throughout the book, separating this code from the view. If we think about it, we just need to send in the item that we are editing. However, we can also use this same schema for deleting. We can define our schema in our <strong class="source-inline">json_serialization/to_do_item.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct ToDoItem {
    pub title: String,
    pub status: String
}</pre>
			<p>In the preceding code, we have merely stated which type of data we need for each field as we cannot pass enums through JSON; only strings can be passed. The deserialization from JSON is enabled by decorating the <strong class="source-inline">ToDoItem</strong> struct with the <strong class="source-inline">Deserialize</strong> trait macro. We must remember to make the <strong class="source-inline">ToDoItem</strong> struct available to the rest of the application, so our <strong class="source-inline">json_serialization/mod.rs</strong> file should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
pub mod to_do_items;
pub mod to_do_item;</pre>
			<p>Now that our item extraction is done, we can move on to our <strong class="source-inline">edit</strong> view. In our <strong class="source-inline">views/to_do/edit.rs</strong> file we can import what we need with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use actix_web::{web, HttpResponse};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
use crate::to_do::{to_do_factory, enums::TaskStatus};
use crate::json_serialization::{to_do_item::ToDoItem, 
                                to_do_items::ToDoItems};
use crate::processes::process_input;</pre>
			<p>In the<a id="_idIndexMarker406"/> preceding code, we can see that we need to import the<a id="_idIndexMarker407"/> standard serialization and web structs needed for a view. We also import the structs <strong class="source-inline">ToDoItem</strong> and <strong class="source-inline">ToDoItems</strong> for ingesting data and returning the entire state of the application. We can then import our <strong class="source-inline">process_input</strong> function that processes the input with a command. At this point, looking at the imports, can you think of the steps needed to perform our edit? Have a think before moving forward. The path is like what we did with a <strong class="source-inline">get</strong> view; however, we must update the state with the new updated item. We must also remember that our <strong class="source-inline">process_input</strong> function will edit the to-do item if the <strong class="source-inline">edit</strong> command is passed in. </p>
			<p>After <a id="_idIndexMarker408"/>thinking it through, remember, there are many ways to <a id="_idIndexMarker409"/>solve a problem. If your steps solve the problem, then do not feel bad if it is different from the steps laid out. You may also produce a better solution. Our <strong class="source-inline">edit</strong> view involves the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Get the state of the entire application for the <span class="No-Break">to-do items.</span></li>
				<li>Check to see if the item is there, returning a <strong class="source-inline">not found</strong> response if it <span class="No-Break">is not.</span></li>
				<li>Pass the data through the <strong class="source-inline">to_do_factory</strong> factory to construct the existing data from the state to an item that we <span class="No-Break">can manipulate.</span></li>
				<li>Check that the status being put in is not the same as the existing status. </li>
				<li>Pass the existing item into the <strong class="source-inline">process_input</strong> function with an <strong class="source-inline">edit</strong> command so it is saved to the JSON state file. </li>
				<li>Get the<a id="_idIndexMarker410"/> state <a id="_idIndexMarker411"/>of the application and return it. </li>
			</ol>
			<p>With these steps in mind, we can concrete our knowledge of extracting JSON from the body of the request and process it for editing in the next subsection. </p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Extracting JSON from the body of a request</h2>
			<p>Now that we <a id="_idIndexMarker412"/>have the imports done and the outline defined, we can define the outline of our view with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;) 
                                 -&gt; HttpResponse {
    . . .
}</pre>
			<p>In the preceding code, we can see that our <strong class="source-inline">ToDoItem</strong> struct is wrapped in the <strong class="source-inline">web::Json</strong> struct. This means that the parameter <strong class="source-inline">to_do_item</strong> will be extracted from the body of the request, serialized, and constructed as the <strong class="source-inline">ToDoItem</strong> struct. So, inside our view, our <strong class="source-inline">to_do_item</strong> is a <strong class="source-inline">ToDoItem</strong> struct. Thus, inside our view, we can load our state with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let state: Map&lt;String, Value&gt; = read_file("./state.json");</pre>
			<p>We can then extract the item data from our state with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let status: TaskStatus;
match &amp;state.get(&amp;to_do_item.title) {
    Some(result) =&gt; {
        status = TaskStatus::new(result.as_str().unwrap());
    }
    None=&gt; {
        return HttpResponse::NotFound().json(
            format!("{} not in state", &amp;to_do_item.title))
    }
}</pre>
			<p>In the preceding code, we can see that we can construct the status from the data or return a <strong class="source-inline">not found</strong> HTTP response if it is not found. We then need to construct the item struct with the existing data using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let existing_item = to_do_factory(to_do_item.title.as_str(), 
              status.clone());</pre>
			<p>In the <a id="_idIndexMarker413"/>preceding code, we can see why our factory is coming in handy. Now, we need to compare the new and existing status for the item. There is no point altering the status if the desired status is the same as the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if &amp;status.stringify() == &amp;TaskStatus::from_string(
                          &amp;to_do_item.status.as_str()
                          .to_string()).stringify() {
    return HttpResponse::Ok().json(ToDoItems::get_state())
}</pre>
			<p>Therefore, we need to check the current status and if it is the same as the desired status, we merely return an <strong class="source-inline">Ok</strong> HTTP response state. We do this because the frontend client might be out of sync. In the next chapter, we will be writing the frontend code and we will see that the items will be cached and rendered. If, let’s say, another tab is open with our application or we have updated our to-do application on another device such as a phone, then the client making this request might be out of sync. We do not want to execute a command based on an out-of-sync frontend. We then need to process the input by making an edit and then returning the state with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
process_input(existing_item, "edit".to_owned(), &amp;state);
return HttpResponse::Ok().json(ToDoItems::get_state())</pre>
			<p>The <a id="_idIndexMarker414"/>preceding code should work but right now, it will not. This is because we need to clone our <strong class="source-inline">TaskStatus</strong> enum and our <strong class="source-inline">TaskStatus</strong> does not implement the <strong class="source-inline">Clone</strong> trait. This can be updated in our <strong class="source-inline">src/to_do/enums.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[derive(Clone)]
pub enum TaskStatus {
    DONE,
    PENDING
}</pre>
			<p>We must then ensure that the <strong class="source-inline">edit</strong> view is available and defined in the <strong class="source-inline">to-do</strong> view factory. So, in the <strong class="source-inline">src/views/to_do/mod.rs</strong> file, our factory should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
mod create;
mod get;
mod edit;
use actix_web::web::{ServiceConfig, post, get, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", post().to(create::create))
        .route("get", get().to(get::get))
        .route("edit", post().to(edit::edit))
    );
}</pre>
			<p>We can see that our view factory is scaling nicely. We can also stand back and appreciate that all our views for to-do items are defined nicely in one isolated page meaning we can simply look at the preceding code and still know that we need a <strong class="source-inline">delete</strong> view. We can now run our application and make a request in Postman with the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker415"/></span><span class="No-Break">configuration:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.8_B18722.jpg" alt="Figure 4.8 – Edit request with Postman "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Edit request with Postman </p>
			<p>We can see in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.8</em> that we are switching our washing task to <strong class="source-inline">"DONE"</strong>. We have put this data in the body as raw with the format to be JSON. If we make this call to the <strong class="source-inline">edit</strong> endpoint, we will get the <span class="No-Break">following response:</span></p>
			<pre class="console">
{
    "pending_items": [
        {
            "title": "learn to code rust",
            "status": "PENDING"
        }
    ],
    "done_items": [
        {
            "title": "washing",
            "status": "DONE"
        }
    ],
    "pending_item_count": 1,
    "done_item_count": 1
}</pre>
			<p>In the preceding code, we can see that the done items list is now populated and that the counts have been altered. If we continue to make the same call, we will get the same response as we will be editing the <strong class="source-inline">washing</strong> item to <strong class="source-inline">done</strong> when it already has a done status. We will have to switch the status of <strong class="source-inline">washing</strong> back to <strong class="source-inline">pending</strong> or change the title in our call to get a different updated state. If we do not include <strong class="source-inline">title</strong> and <strong class="source-inline">status</strong> in the body of our call, then we will get a bad request response instantly, because the <strong class="source-inline">ToDoItem</strong> struct is expecting those two fields. </p>
			<p>Now that we<a id="_idIndexMarker416"/> have locked down the process of receiving and returning JSON data in the URL parameters and body, we are nearly done. However, we have one more important method to cover that’s used for data extraction – the header. Headers are used t<a id="_idTextAnchor085"/>o store meta information such as <span class="No-Break">security credentials.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Extracting data from the header in requests</h2>
			<p>If we needed to <a id="_idIndexMarker417"/>authorize a range of requests; it would not be scalable to put them in all our JSON structs. We also must acknowledge that the request body could be large, especially if the requester is being malicious. Therefore, it makes sense to access the security credentials before passing the request through to the view. This can be done by intercepting the request through what is commonly known as middleware. Once we’ve intercepted the request, we can access the security credentials, check them, and then process <span class="No-Break">the view.</span></p>
			<p>In the previous edition of this book, we manually developed our middleware for our authentication. However, this is not scalable in terms of code management and does not allow flexibility. However, it is important to cover manually configuring your own middleware to have a better understanding of how the server constructors work giving you the flexibility of processing requests. To intercept our requests, we need to add the <strong class="source-inline">actix-service</strong> crate. With this installation, our <strong class="source-inline">Cargo.toml</strong> file dependencies should look like the <span class="No-Break">following definitions:</span></p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"
serde = { version = "1.0.136", features = ["derive"] }
actix-service = "2.0.2"</pre>
			<p>Now, we can update our <strong class="source-inline">src/main.rs</strong> file. First, our imports should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
use actix_web::{App, HttpServer};
use actix_service::Service;
mod views;
mod to_do;
mod state;
mod processes;
mod json_serialization;</pre>
			<p>Now that all the <a id="_idIndexMarker418"/>imports are done, we can define our server construction with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        let app = App::new()
            .wrap_fn(|req, srv|{
                println!("{:?}", req);
                let future = srv.call(req);
                async {
                    let result = future.await?;
                    Ok(result)
                }
        }).configure(views::views_factory);
        return app
    })
    .bind("127.0.0.1:8000")?
    .run()
    .await
}</pre>
			<p>In the preceding code, we can see that the <strong class="source-inline">wrap_fn</strong> enables us to interact with the request (<strong class="source-inline">req</strong>). The service routing (<strong class="source-inline">srv</strong>) can be called when we need it to pass the request. We must note that calling the routing service is a future that we then wait to finish in an <strong class="source-inline">async</strong> code block returning the result. This is middleware. We can manipulate our request, inspect it, and reroute or return it before calling the routing service to process the HTTP request in one of our views. For us, we are just printing out the debug of the request, which looks like the <span class="No-Break">following printout:</span></p>
			<pre class="console">
ServiceRequest HTTP/1.1 GET:/v1/item/get
  headers:
    "accept-language": "en-GB,en-US;q=0.9,en;q=0.8"
    "accept": "text/html,application/xhtml+xml,application/xml;
    q=0.9,image/avif,image/webp,image/        apng,*/*;q=0.8,application
    signed-exchange;v=b3;q=0.9"
    "sec-ch-ua-platform": "\"macOS\""
    "sec-fetch-site": "none"
    . . . 
    "host": "127.0.0.1:8000"
    "connection": "keep-alive"
    "sec-fetch-user": "?1"</pre>
			<p>We can see that <a id="_idIndexMarker419"/>we have a lot of data to work with. But this is as far as we will go with our homemade middleware. We will now investigate extracting data from headers using traits. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Simplifying header extraction with traits</h2>
			<p>Before we <a id="_idIndexMarker420"/>do this, we will have to install the futures crate, adding the following to the dependencies section of the <strong class="source-inline">Cargo.toml</strong> file: </p>
			<pre class="source-code">
futures = "0.3.21"</pre>
			<p>We will now create an <strong class="source-inline">src/jwt.rs</strong> file to house <a id="_idIndexMarker421"/>our <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>). This is where we can store encrypted data about the user once the user has logged in. We can then send the JWT in the header with every HTTP request. In <span class="No-Break"><em class="italic">Chapter 7</em></span>, <em class="italic">Managing User Sessions</em>, we will explore the security nuances of checking and managing these tokens. For now, we will simply build the header extraction process. We will start by importing the needed structs and traits in the <strong class="source-inline">src/jwt.rs</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use actix_web::dev::Payload;
use actix_web::{Error, FromRequest, HttpRequest};
use futures::future::{Ready, ok};</pre>
			<p>The <strong class="source-inline">Payload</strong> struct houses the requests raw data stream. We then have the <strong class="source-inline">FromRequest</strong> trait which is what we are going to implement to extract the data before it hits the view. We then use the <strong class="source-inline">Ready</strong> and <strong class="source-inline">ok</strong> from futures to wrap the result of our data extraction to create a future that is immediately ready with a success value, which is the value from our header extraction. Now that we have imported what we need, we can define our JWT struct with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
pub struct JwToken {
    pub message: String
}</pre>
			<p>For now, we are only going to have a message but, in the future, we will be adding fields like the ID of the user. With <a id="_idIndexMarker422"/>this struct, we can implement the <strong class="source-inline">FromRequest</strong> trait with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
impl FromRequest for JwToken {
    type Error = Error;
    type Future = Ready&lt;Result&lt;JwToken, Error&gt;&gt;;
    fn from_request(req: &amp;HttpRequest, _: &amp;mut Payload) 
                                          -&gt; Self::Future {
    . . .
    }
}</pre>
			<p>We can deduce that the <strong class="source-inline">from_request</strong> function gets called before the view is loaded. We are extracting the header, which is why we have no interest in the payload. So, we mark the parameter with <strong class="source-inline">_</strong>. We need to define the <strong class="source-inline">Future</strong> type, which is a ready future housing a result that can either be our <strong class="source-inline">JwToken</strong> struct or an error. Inside the <strong class="source-inline">from_request</strong> function, we can extract the data from the header with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
match req.headers().get("token") {
    Some(data) =&gt; {
        let token = JwToken{
            message: data.to_str().unwrap().to_string()
        };
        ok(token)
    },
    None =&gt; {
        let token = JwToken{
            message: String::from("nothing found")
        };
        ok(token)
    }
}</pre>
			<p>In the preceding code, we <a id="_idIndexMarker423"/>can see that for this chapter we just look for the <strong class="source-inline">token</strong> key and if it is there, we return the <strong class="source-inline">JwToken</strong> struct with the message. If not, we will return the <strong class="source-inline">JwToken</strong> struct with nothing found. As this chapter focuses on data, this is where we stop, but in <a href="B18722_07.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Managing User Sessions</em>, we will revisit this function and explore concepts such as throwing errors and returning requests before they hit the view with unauthorized codes. For now, we must make our <strong class="source-inline">JwToken</strong> struct accessible by defining it in our <strong class="source-inline">src/main.rs</strong> file with the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
mod jwt;</pre>
			<p>Now that we have gone through the hassle of implementing a trait, using it is going to be compact and simple. Let us revisit our <strong class="source-inline">edit</strong> view in our <strong class="source-inline">views/to_do/edit.rs</strong> file, import our <strong class="source-inline">JwToken</strong> struct, add our <strong class="source-inline">JwToken</strong> struct to our parameters in the <strong class="source-inline">edit</strong> view, and print out the message as seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
use crate::jwt::JwToken;
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;, 
                  token: JwToken) -&gt; HttpResponse {
    println!("here is the message in the token: {}", 
              token.message);
    . . .</pre>
			<p>Clearly, we do not want to <a id="_idIndexMarker424"/>edit the rest of the view but as we can deduce from the preceding code, the <strong class="source-inline">token</strong> parameter is the constructed <strong class="source-inline">JwToken</strong> struct that has been extracted from the HTTP request and is ready for use just like the <strong class="source-inline">ToDoItem</strong> struct. If we make the same edit HTTP call now after running the server, we will see that the HTTP request is printed out, but we also get the <span class="No-Break">following response:</span></p>
			<pre class="console">
here is the message in the token: nothing found</pre>
			<p>It looks like it is working, as we haven’t added anything to the header yet. We can add a token into our header with the Postman setup defined in the following figure: </p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_4.9_B18722.jpg" alt="Figure 4.9 – Edit request in Postman with header "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Edit request in Postman with header </p>
			<p>If we send the <a id="_idIndexMarker425"/>request again, we get the <span class="No-Break">following printout:</span></p>
			<pre class="console">
here is the message in the token: "hello from header"</pre>
			<p>That’s it! We can pass data through headers. What’s more, adding and taking them away from views is as easy as defining them in the parameters and removing them. </p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we have put all of what we have learned in the previous chapters to good use. We fused the logic from the to-do item factory, which loads and saves to-do items from a JSON file, and looked at the to-do item process logic by using the basic views from <strong class="source-inline">Actix-web</strong>. With this, we have been able to see how the isolated modules click together. We will keep reaping the benefits of this approach in the next few chapters as we rip out the JSON file that loads and saves a database. </p>
			<p>We also managed to utilize the <strong class="source-inline">serde</strong> crate to serialize complex data structures. This allows our users to get the full state update returned to them when they make an edit. We also built on our knowledge of futures, <strong class="source-inline">async</strong> blocks, and closures to intercept requests before they reached the view. Now, we can see that the power of Rust is enabling us to do some highly customizable things to our server, without us having to dig deep into the framework. </p>
			<p>Thus, Rust has a strong future in web development. Despite its infancy, we can get things up and running with little to no code. With a few more lines of code and a closure, we are building our own middleware. Our JSON serialization structs were made possible with just one line of code, and the traits provided by <strong class="source-inline">Actix</strong> enabled us to merely define the parameter in the view function, thus enabling the view to automatically extract the data from the body and serialize it into the struct. This scalable, powerful, and standardized way of passing data is more concise than many high-level languages. We can now fully interact with and inspect every part of the HTTP request. </p>
			<p>Now that we are processing and returning well-structured data to the user, we can start displaying it in an interactive way for our user to point and click when editing, creating, and deleting to-do items. </p>
			<p>In the next chapter, we will be serving HTML, CSS, and JavaScript from the <strong class="source-inline">Actix-web</strong> server. This will enable us to see and interact with to-do items via a graphical user interface, with the JavaScript making API calls to the endpoints we defined in this chapter. </p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a <strong class="source-inline">GET</strong> and <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request?</span></li>
				<li>Why would we have middleware when we check credentials? </li>
				<li>How do you enable a custom <strong class="source-inline">struct</strong> to be directly returned in <span class="No-Break">a view?</span></li>
				<li>How do you enact middleware for <span class="No-Break">the server?</span></li>
				<li>How do you enable a custom <strong class="source-inline">struct</strong> to serialize data into <span class="No-Break">the view?</span></li>
			</ol>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Answers</h1>
			<ol>
				<li value="1">A <strong class="source-inline">GET</strong> request can be cached and there are limits to the types and amount of data that can be sent. A <strong class="source-inline">POST</strong> request has a body, which enables more data to be transferred. Also, it cannot be cached. </li>
				<li>We use middleware to open the header and check the credentials before sending the request to the desired view. This gives us an opportunity to prevent the body from being loaded by returning an <strong class="source-inline">auth</strong> error before loading the view preventing the potentially malicious body. </li>
				<li>For the struct to be directly returned, we will have to implement the <strong class="source-inline">Responder</strong> trait. During this implementation, we will have to define the <strong class="source-inline">responded_to</strong> function that accepts the HTTP request struct. The <strong class="source-inline">responded_to</strong> will be fired when the struct is returned. </li>
				<li>In order to enact middleware, we enact the <strong class="source-inline">wrap_fn</strong> function on the <strong class="source-inline">App</strong> struct. In the <strong class="source-inline">wrap_fn</strong> function, we pass a closure that accepts the service request and routing structs. </li>
				<li>We decorate the struct with the <strong class="source-inline">#[derive(Deserialize)]</strong> macro. Once we have done this, we define the parameter type to be wrapped in a JSON struct: <span class="No-Break"><strong class="source-inline">parameter: web::Json&lt;ToDoItem&gt;</strong></span><span class="No-Break">.</span></li>
			</ol>
		</div>
	</body></html>