<html><head></head><body>
		<div><h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor073"/>4</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Processing HTTP Requests </h1>
			<p>Up to this point, we have utilized the Actix Web framework to serve basic views. However, this can only get us so far when it comes to extracting data from the request and passing data back to the user. In this chapter, we will fuse code from <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a><em class="italic">, Designing Your Web Application in Rust</em>, and <a href="B18722_03.xhtml#_idTextAnchor059"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling HTTP Requests</em>, to build server views that process to-do items. We will then explore <strong class="bold">JSON serialization</strong> for extracting data and returning it to make our views more user friendly. We will also extract data from the header with middleware before it hits the view. We will explore the concepts around data serialization and extracting data from requests by building out the create, edit, and delete to-do item endpoints for our to-do application. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Getting to know the initial setup for fusing code</li>
				<li>Passing parameters into views</li>
				<li>Using macros for JSON serialization</li>
				<li>Extracting data from views</li>
			</ul>
			<p>Once you have finished this chapter, you will be able to build a basic Rust server that can send and receive data in the URL, in the body using JSON, and in the header of the HTTP request. This is essentially a fully functioning API Rust server without a proper database for data storage, the ability to authenticate users, or the ability to display content in the browser. However, these concepts will be covered in the next three chapters. You are on the home run for having a fully working Rust server that is up and running. Let’s get started!</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Technical requirements</h1>
			<p>For this chapter, we need to download and install <strong class="bold">Postman</strong>. We will need Postman to make API requests to our server. You can download it from <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>.</p>
			<p>We will also be building on the server code we created in the previous chapter, which can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app</a>. </p>
			<p>You can find the full source code that will be used in this chapter here: <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04</a>.</p>
			<p>Managing views code will be the basis of this chapter, and we will add features to this code base. We will be fusing this with the to-do module that we wrote in <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, which can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs</a>.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Getting to know the initial setup for fusing code</h1>
			<p>In<a id="_idIndexMarker354"/> this section, we will cover the initial setup of two fusing pieces of code we built in <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, and <a href="B18722_03.xhtml#_idTextAnchor059"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling HTTP Requests</em>. This fusion will give us the following structure:</p>
			<div><div><img src="img/Figure_4.1_B18722.jpg" alt="Figure 4.1 – Structure of our app and its modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Structure of our app and its modules</p>
			<p>Here, we<a id="_idIndexMarker355"/> will register all the modules in the main file and then pull all these modules into the views to be used. We are essentially swapping the command-line interface from <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, with web views. Combining these modules gives us the following files in the code base:</p>
			<pre class="source-code">
├── main.rs
├── processes.rs
├── state.rs</pre>
			<p>We are then bolting our <code>to_do</code> module into the same directory of our <code>main.rs</code> file. If you built the <code>to_do</code> module when reading <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, your <code>to_do</code> module should have the following structure:</p>
			<pre class="source-code">
├── to_do
│   ├── enums.rs
│   ├── mod.rs
│   ├── structs
│   │   ├── base.rs
│   │   ├── done.rs
│   │   ├── mod.rs
│   │   └── pending.rs
│   └── traits
│       ├── create.rs
│       ├── delete.rs
│       ├── edit.rs
│       ├── get.rs
│       └── mod.rs</pre>
			<p>So now, our <a id="_idIndexMarker356"/>bolt on the <code>views</code> module from the previous chapter should contain the following:</p>
			<pre class="source-code">
└── views
    ├── auth
    │   ├── login.rs
    │   ├── logout.rs
    │   └── mod.rs
    ├── mod.rs
    ├── path.rs</pre>
			<p>The full structure, with all the code, can be found in the following GitHub repo:</p>
			<p><a href="https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup&#13;">https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup</a></p>
			<p>Now that we have added modules from previous chapters to our project, we can bind them together in our program. To do this, we must create a new <code>src/main.rs</code> file. First, we must import the modules that we built and define a basic server using the following code:</p>
			<pre class="source-code">
use actix_web::{App, HttpServer};
mod views;
mod to_do;
mod state;
mod processes;
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        let app = App::new().configure(views::views_factory);
        return app
    })
        .bind("127.0.0.1:8000")?
        .run()
        .await
}</pre>
			<p>In the preceding code, we defined the modules and then our server. Because the server is utilizing <code>views_factory</code>, we will not have to alter this file for the rest of this chapter. Instead, we will chain our factory functions that will be called in the <code>views_factory</code> function. </p>
			<p>At this point, we can sit back and appreciate the dividends of all the hard work that we did in the previous chapters. The isolation of principles and well-defined modules have enabled us to slot our logic from our command-line program into our server interface with minimal effort. Now, all we have to do is connect it to our <code>views</code> module, and pass parameters into those views. Before we move on to the next section, however, there is some minor housekeeping we must do to ensure that our server can run. First, our dependencies in the <code>Cargo.toml</code> file have the following requirements:</p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"</pre>
			<p>We can then<a id="_idIndexMarker357"/> do a <code>cargo run</code> command, showing that our login and logout views work in our browser. With this done, we can start working on passing parameters into views. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Passing parameters into views </h1>
			<p>In <a id="_idIndexMarker358"/>this section, we will cover the initial setup of fusing two <a id="_idIndexMarker359"/>modules to create a to-do item and store it through a view. To do this, we will have to pass in the title of the to-do item into our <code>create</code> view that creates a to-do item. We can pass data into a view using the following routes:</p>
			<ul>
				<li><strong class="bold">URL</strong>: Data and parameters can be passed inside the URL of the request. This is generally used in simple cases as it is easy to implement.</li>
				<li><strong class="bold">body</strong>: Data can be stored under different fields in the request body. This is used for more complex data structures and bigger payloads. </li>
				<li><strong class="bold">header</strong>: Data can be stored under different fields in the request header. This is used to store metadata about the request being sent. We also store the authentication data of the request in the header.  </li>
			</ul>
			<p>We will cover all<a id="_idIndexMarker360"/> these approaches throughout our project, but for<a id="_idIndexMarker361"/> now, we will pass our data using the URL method as this is the easiest introduction method. First, we will create the structure for our to-do views with the following layout:</p>
			<pre class="source-code">
└── views
    ├── auth
    │   ├── login.rs
    │   ├── logout.rs
    │   └── mod.rs
    ├── mod.rs
    └── to_do
        ├── create.rs
        └── mod.rs</pre>
			<p>We can see that we have put our <code>to-do</code> views in their own <code>views</code> module next to the <code>to_do</code> module. We will keep stacking our views in this way so that we can slot them in and out of our server and slot them into other projects if needed. For now, creating a to-do item will take the following form:</p>
			<div><div><img src="img/Figure_4.2_B18722.jpg" alt="Figure 4.2 – Process of creating a to-do item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Process of creating a to-do item</p>
			<p>To carry out the process demonstrated in <em class="italic">Figure 4</em><em class="italic">.2</em>, we need to perform the following steps:</p>
			<ol>
				<li>Load the current state of the to-do item list. </li>
				<li>Get the title of the new to-do item from the URL. </li>
				<li>Pass the title and the status <code>pending</code> through <code>to_do_factory</code>. </li>
				<li>Pass the result of the previous step along with the string <code>create</code> and the state into the process module interface.</li>
				<li>Return a string to the user to signal that the process has finished.</li>
			</ol>
			<p>We can carry out<a id="_idIndexMarker362"/> these steps defined previously in the <code>views/to_do/create.rs</code> file. First <a id="_idIndexMarker363"/>of all, we must import what we need with the following code:</p>
			<pre class="source-code">
use serde_json::value::Value;
use serde_json::Map;
use actix_web::HttpRequest;
use crate::to_do::{to_do_factory, enums::TaskStatus};
use crate::state::read_file;
use crate::processes::process_input;</pre>
			<p>We will use <code>serde_json::value::Value</code> and <code>serde_json::Map</code> to define what type of data we are reading from the <code>state.json</code> file and to extract the title from the URL using the <code>HttpRequest</code> struct. We will then import what we need from our other modules to enable us to create an item, read the state file, and process the input. Our view can be defined through the following code:</p>
			<pre class="source-code">
pub async fn create(req: HttpRequest) -&gt; String {
    let state: Map&lt;String, Value&gt; = read_file(
        "./state.json"); // step 1
    let title: String = req.match_info().get("title"
    ).unwrap().to_string(); // step 2
    let item = to_do_factory(&amp;title.as_str(), 
                             TaskStatus::PENDING); // step 3
    process_input(item, "create".to_string(), &amp;state);
    // step 4
    return format!("{} created", title) // step 5
}</pre>
			<p>We need to <a id="_idIndexMarker364"/>remember that this is an <code>async</code> function because it is a <a id="_idIndexMarker365"/>view that our server is processing. We can also see that our <code>title</code> is extracted from <code>HttpRequest</code> by using the <code>match_info</code> function. We must directly unwrap it because if there is no title in the URL, then we do not want to continue with the process of making an item and then converting the extracted title to <code>String</code>. We then need to pass a reference of this to our <code>to_do_factory</code> to create an <code>ItemTypes</code> <code>enum</code>. We then pass our <code>enum</code> with a command and a reference to the current state of our application into our <code>process_input</code> function, which, as we remember, will go through a series of steps to work out how to handle the state based on the command and item type passed in. There is a lot going on here, but it must be noted none of the logic around how to process the item is in this view. This is called the separation of concerns of code orthogonality. Code orthogonality refers to the following mathematical concept:</p>
			<div><div><img src="img/Figure_4.3_B18722.jpg" alt="Figure 4.3 – Mathematical concept of orthogonality "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Mathematical concept of orthogonality </p>
			<p>We can<a id="_idIndexMarker366"/> see in <em class="italic">Figure 4</em><em class="italic">.3</em> that if a vector is orthogonal to another<a id="_idIndexMarker367"/> vector then it is said to have no projection onto another vector. In physics, if the vectors are forces, these vectors do not have any effect on each other. Now, this cannot be completely true in programming: if we delete the code in our <code>processes</code> module, it will affect the <code>create</code> view as we must reference it. However, the logic of <code>processes</code> should not be defined in the <code>create</code> view. This is partly because we must use <code>processes</code> elsewhere, but this is not the entire story. When we look at the <code>create</code> view, we can see the logic around creating a pending item in relation to the rest of the application. This makes it easy for developers to know exactly what’s going on. They are not getting lost in details that are not relevant to the five steps we specified earlier in this section to create a to-do item. If the developer wants to explore the logic around the saving of the item, they can investigate the file that defines this. </p>
			<p>We must now make the views in our <code>to_do</code> module available to the outside. We can do this by creating a to-do views factory function in the <code>views/to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, get, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", get().to(create::create))
    );
}</pre>
			<p>In the preceding<a id="_idIndexMarker368"/> code, we can see that we do not make the <code>create</code> view public <a id="_idIndexMarker369"/>but we do use it in our factory to define the view. We also define the title being passed into the URL with the <code>/{title}</code> tag. Now that our item views are functional, we need to plug <code>to_do_views_factory</code> into our application in the <code>views/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
mod auth;
mod to_do; // define the module
use auth::auth_views_factory;
use to_do::to_do_views_factory; // import the factory 
use actix_web::web::ServiceConfig;
pub fn views_factory(app: &amp;mut ServiceConfig) {
    auth_views_factory(app);
    to_do_views_factory(app); // pass the ServiceConfig 
}</pre>
			<p>In the preceding code, we <a id="_idIndexMarker370"/>can see that we have defined the module, imported the factory, and then passed the application configuration. With this done, our<a id="_idIndexMarker371"/> application is ready to run and create to-do items. When our application is running, we can create the item with the following URL:</p>
			<div><div><img src="img/Figure_4.4_B18722.jpg" alt="Figure 4.4 – View to create a to-do item "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – View to create a to-do item </p>
			<p>If we look at the console, we will see the following printout:</p>
			<pre class="console">
learn to code rust is being created</pre>
			<p>If we look at the <code>state.json</code> file in the root, we will get the following data:</p>
			<pre class="console">
{"learn to code rust":"PENDING"}</pre>
			<p>We can see that our process to create a to-do item worked! Our application takes in a title from the URL, creates a pending to-do item, and saves it in our JSON file. While this is a milestone, it must be noted that a JSON file is not the best solution for data storage. It will do for now, however, as we will configure a proper database in <a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em>. We can also see <code>%20</code> in the URL, which denotes a space. We can see that this space translates to the console printout and the saving of the data to the JSON file, and this space is also in the view displayed in the browser. What we have done is take in a to-do item title via the URL, print it out to the terminal, display it in the browser, and save it in a JSON file. We have essentially performed the basis for a web application as we can display data to a user and store it in a file.  </p>
			<p>The <code>GET</code> method works for us, but it is not the most appropriate method for creating a to-do item. <code>GET</code> methods can be cached, bookmarked, kept in the browser’s history, and have restrictions in terms of their length. Bookmarking, storing them in browser history, or caching them doesn’t just present security issues; it also increases the risk of the user accidentally making the same call again. Because of this, it is not a good idea to alter data with a <code>GET</code> request. To protect against this, we can use a <code>POST</code> request, which does not cache, does not end up in browser history, and cannot be bookmarked.</p>
			<p>Because of the reasons we laid out, we will now turn our <code>create</code> view into a <code>POST</code> request. Remember our comments on code orthogonality. What defines how the routes of our views are processed is kept in our factory in <a id="_idIndexMarker372"/>the <code>views/to_do/mod.rs</code> file with the following <a id="_idIndexMarker373"/>code:</p>
			<pre class="source-code">
mod create;
use actix_web::web::{ServiceConfig, post, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create", post().to(create::create))
    );
}</pre>
			<p>In the preceding code, we can see that we have merely changed the <code>get</code> to <code>post</code> in the import and the <code>route</code> definition. If we try and create a new to-do item using the previous approach, we get the following outcome:</p>
			<div><div><img src="img/Figure_4.5_B18722.jpg" alt="Figure 4.5 – Blocked method "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Blocked method </p>
			<p>In <em class="italic">Figure 4</em><em class="italic">.5</em>, we can <a id="_idIndexMarker374"/>see that the page cannot be found. This might be confusing <a id="_idIndexMarker375"/>as the error is a 404-error stating that the page can’t be found. The URL is still defined, but the <code>GET</code> method is no longer allowed for this URL. With this in mind, we can make a <code>POST</code> call using the following Postman configuration:</p>
			<div><div><img src="img/Figure_4.6_B18722.jpg" alt="Figure 4.6 – Postman post method for creating an item "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Postman post method for creating an item </p>
			<p>In <em class="italic">Figure 4</em><em class="italic">.6</em>, we can see <a id="_idIndexMarker376"/>that our URL is still working with just a different <a id="_idIndexMarker377"/>method—the <code>POST</code> method. We can inspect our state file, finding the following data:</p>
			<pre class="console">
{"learn to code rust":"PENDING","washing":"PENDING"}</pre>
			<p>We can see that changing the allowed method for the <code>create</code> view did not affect the way in which we create or store to-do items. Looking back at <em class="italic">Figure 4</em><em class="italic">.6</em>, we can also see that we get a status code of <code>200</code>, which is <code>OK</code>. This already tells us that the creation has happened. Because of this, we do not have to return anything as the status is <code>OK</code>. </p>
			<p>Looking back at what we get when we try and send a <code>GET</code> request to our <code>create</code> view, we get a <code>views/to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
app.service(
    scope("v1/item")
    .route("create/{title}", post().to(create::create))
    .route("create/{title}", get().to(create::create))
);</pre>
			<p>We can see that this works if we put our URL in our browser, which results in creating a pending to-do item. We also have the option to put a different function in our <code>get</code> route with the same URL if needed. This gives us flexibility on how to use and reuse our URLs. However, considering the differences that we covered between the <code>GET</code> and <code>POST</code> methods, it is sensible to just have a <code>POST</code> method for our <code>create</code> function.  </p>
			<p>We have now done all that we need to when it comes to creating our to-do item. However, in other views, we will have to return structured data to present the current state of our to-do items. </p>
			<p>So far, we have<a id="_idIndexMarker378"/> passed data into our application using a URL, which is the <a id="_idIndexMarker379"/>most basic way in which we can pass data. However, we cannot pass structured data using a URL. For instance, if we wanted to send a hashmap or a list, a URL is just not able to house such structures. This is where we need to pass data to our application in the body of the request using JSON, which we will cover in the next section. </p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Using macros for JSON serialization  </h1>
			<p>When it comes to <a id="_idIndexMarker380"/>serializing data and returning it to the client, we can achieve this quickly with minimal code using the JSON from the <code>Actix-web</code> crate. We can demonstrate this by creating a <code>GET</code> view that returns all our to-do items in the <code>views/to_do/get.rs</code> file:</p>
			<pre class="source-code">
use actix_web::{web, Responder};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
pub async fn get() -&gt; impl Responder {
    let state: Map&lt;String, Value&gt; = read_file("./state.json");
    return web::Json(state);
}</pre>
			<p>Here, we can see that we are merely reading the JSON from the JSON file and then returning the values from this wrapped in the <code>web::Json</code> function. It might make sense to just return <code>Map&lt;String, Value&gt;</code> from the JSON file directly, as it is a <code>String</code> and <code>Value</code>. However, the type of <code>Map&lt;String, Value&gt;</code> does not implement the <code>Responder</code> trait. We could update the function to return the state directly with the following code:</p>
			<pre class="source-code">
pub async fn get() -&gt; Map&lt;String, Value&gt;  {
    let state: Map&lt;String, Value&gt; = read_file("./state.json");
    return state;
}</pre>
			<p>However, this will <a id="_idIndexMarker381"/>not work because the <code>get().to()</code> function in the <code>views/to_do/mod.rs</code> file needs to accept a struct that has implemented the <code>Responder</code> trait. We can now plug in our <code>get</code> view in the <code>views/to_do/mod.rs</code> file with the following code:</p>
			<pre class="source-code">
mod create;
mod get; // import the get file 
use actix_web::web::{ServiceConfig, post, get, scope};
// import get
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", post().to(create::create))
        .route("get", get().to(get::get)) // define view and URL
    );
}</pre>
			<p>Running the URL <code>http://127.0.0.1:8000/item/get</code> gives us the following JSON data in the response body:</p>
			<pre class="console">
{
    "learn to code rust": "PENDING",
    "washing": "PENDING"
}</pre>
			<p>We now have <a id="_idIndexMarker382"/>some structured data that we can present to the frontend. While this essentially gets the job done, it is not too helpful. For instance, we would like to have two different lists for <em class="italic">pending</em> and <em class="italic">done</em>. We could also add timestamps telling users when the to-do item was created or edited. Simply returning the titles and the statuses of the to-do items will not enable us to scale complexity when needed. </p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Building our own serialization struct</h2>
			<p>To have <a id="_idIndexMarker383"/>more control over the type of data that we are going to return to the user, we are going to have to build our own serialization structs. Our serialization struct is going to present two lists, one for completed items and another for pending items. The lists will be populated with objects consisting of a title and a status. If we recall from <a href="B18722_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, <em class="italic">Designing Your Web Application in Rust</em>, our <code>pending</code> and <code>Done</code> item structs are inherited via composition from a <code>Base</code> struct. Therefore, we must access the title and the status from the <code>Base</code> struct. However, our <code>Base</code> struct is not accessible to the public. We will have to make it accessible so that we can serialize the attributes for each to-do item:</p>
			<div><div><img src="img/Figure_4.7_B18722.jpg" alt="Figure 4.7 – Relationship that our to-do structs have with our interfaces "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Relationship that our to-do structs have with our interfaces </p>
			<p>Looking at <em class="italic">Figure 4</em><em class="italic">.7</em>, we can<a id="_idIndexMarker384"/> see that the <code>TaskStatus enum</code> is the root of the dependency. We need to be able to serialize this <code>enum</code> before we can serialize our to-do items. We can use the <code>serde</code> crate for this. In order to do this, we must update our dependencies in the <code>Cargo.toml</code> file:</p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"
serde = { version = "1.0.136", features = ["derive"] }</pre>
			<p>We can see<a id="_idIndexMarker385"/> that we have added the <code>features = ["derive"]</code>. This will enable us to decorate our structs with <code>serde</code> traits. We can now look at how we defined our <code>enum</code> in the <code>src/to_do/enums.rs</code> file with the following code:</p>
			<pre class="source-code">
pub enum TaskStatus {
    DONE,
    PENDING
}
impl TaskStatus {
    pub fn stringify(&amp;self) -&gt; String {
        match &amp;self {
            &amp;Self::DONE =&gt; {return "DONE".to_string()},
            &amp;Self::PENDING =&gt; 
                {return "PENDING".to_string()}
        }
    }
    pub fn from_string(input_string: String) -&gt; Self {
        match input_string.as_str() {
            "DONE" =&gt; TaskStatus::DONE,
            "PENDING" =&gt; TaskStatus::PENDING,
            _ =&gt; panic!("input {} not supported", 
                        input_string)
        }
    }
}</pre>
			<p>In the preceding code, we can see that we have two fields named <code>DONE</code> and <code>PENDING</code>; however, they are essentially their own types. How can we serialize this as a JSON value? There is a clue in the <code>stringify</code> function. However, this is not the full picture. Remember, the return values of our server views need to implement traits. We can implement a <code>serde</code> trait for our <code>TaskStatus</code> <code>enum</code> by initially importing the traits that we need in <a id="_idIndexMarker386"/>the <code>src/to_do/enums.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::ser::{Serialize, Serializer, SerializeStruct};</pre>
			<p>We now have everything we need to implement the <code>Serialize</code> trait so we can customize how the structs that we write can be serialized in the following section. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Implementing the Serialize trait</h2>
			<p><code>Serialize</code> is the<a id="_idIndexMarker387"/> trait that we will implement, and <code>Serializer</code> is a data formatter that can serialize any data format that is supported by <code>serde</code>. We can then implement a <code>Serialize</code> trait for our <code>TaskStatus</code> <code>enum</code> with the following code:</p>
			<pre class="source-code">
impl Serialize for TaskStatus {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, 
                    S::Error&gt;
    where
        S: Serializer,
    {
        Ok(serializer.serialize_str(&amp;self.stringify()
                                   .as_str())?)
    }
}</pre>
			<p>This is a standard approach that is defined in the <code>serde</code> documents. In the preceding code, we can see a <code>serialize</code> function has been defined. The <code>serialize</code> function gets called when serializing our <code>TaskStatus</code> <code>enum</code>. We also notice that the type of notation for <code>serializer</code> is <code>S</code>. We then use a <code>where</code> statement defining <code>S</code> as <code>Serializer</code>. This may seem counterintuitive, so we can take a step back from our application to explore it. The following code blocks are not needed to complete our application. </p>
			<p>Let us define<a id="_idIndexMarker388"/> some basic structs as follows:</p>
			<pre class="source-code">
#[derive(Debug)]
struct TwoDposition {
    x: i32,
    y: i32
}
#[derive(Debug)]
struct ThreeDposition {
    x: i32,
    y: i32,
    z: i32
}</pre>
			<p>In the preceding code, we can see that we implement the <code>Debug</code> trait for both the <code>TwoDposition</code> and <code>ThreeDposition</code> structs. We can then define functions that print a debug statement for each <code>struct</code> with the following code:</p>
			<pre class="source-code">
fn print_two(s: &amp;TwoDposition) {
    println!("{:?}", s);
}
fn print_three(s: &amp;ThreeDposition) {
    println!("{:?}", s);
}</pre>
			<p>However, we can see that this does not scale well. We would be writing a function for everything that implements it. Instead, we can use a <code>where</code> statement so we can pass both of our structs into it as they implement the <code>Debug</code> trait. First, we must import the trait with the following code:</p>
			<pre class="source-code">
use core::fmt::Debug;</pre>
			<p>We can then<a id="_idIndexMarker389"/> define our flexible function with the following code:</p>
			<pre class="source-code">
fn print_debug&lt;S&gt;(s: &amp;S)
where
    S: Debug {
    println!("{:?}", s);    
}</pre>
			<p>What is happening here is that our function is generic in terms of the type of variable that we are passing into the function. We then take a reference to a value of the type <code>S</code>. This means that <code>S</code> can be any type if it implements the <code>Debug</code> trait. If we try and pass in a <code>struct</code> that does not implement the <code>Debug</code> trait, the compiler will refuse to compile. So, what is happening when we compile? Run the following code:</p>
			<pre class="source-code">
fn main() {
    let two = TwoDposition{x: 1, y: 2};
    let three = ThreeDposition{x: 1, y: 2, z: 3};    
    print_debug(&amp;two);
    print_debug(&amp;three);
}</pre>
			<p>We will get the following printout:</p>
			<pre class="console">
TwoDposition { x: 1, y: 2 }
ThreeDposition { x: 1, y: 2, z: 3 }</pre>
			<p>The preceding output makes sense as this is the result of printing when invoking the debug trait. However, they are two different functions that are created when the compiler is compiling. Our compiler compiled the following two functions:</p>
			<pre class="source-code">
print_debug::&lt;TwoDposition&gt;(&amp;two);
print_debug::&lt;ThreeDposition&gt;(&amp;three);</pre>
			<p>This is not <a id="_idIndexMarker390"/>breaking what we know in terms of how Rust works; however, it does make our code more scalable. There are more advantages to using a <code>where</code> statement; for instance, we could specify what traits we need in an iterator with the following code:</p>
			<pre class="source-code">
fn debug_iter&lt;I&gt;(iter: I)
where
    I: Iterator
    I::Item: Debug
{
    for item in iter {
        println!("{:?}", iter);
    }
}</pre>
			<p>In the preceding code, we can see that we are accepting an iterator and that the items in the iterator need to implement the <code>Debug</code> trait. However, if we keep exploring the implementation of traits, we can lose focus of our main goal in this book: web programming in Rust.  </p>
			<p>With the <a id="_idIndexMarker391"/>knowledge of using the <code>where</code> statement to implement traits, we can look back at our implementation of the <code>Serialize</code> trait in the <code>TaskStatus</code> <code>enum</code>: </p>
			<pre class="source-code">
impl Serialize for TaskStatus {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, 
                                                  S::Error&gt;
    where
        S: Serializer,
    {
        Ok(serializer.serialize_str(&amp;self.stringify()
                                    .as_str())?)
    }
}</pre>
			<p>We can see that we merely call the <code>stringify</code> function and wrap it in an <code>Ok</code> result. We only want the status as a <code>String</code> as we are slotting it into a bigger body of data. If it was a struct with fields, then we could write the <code>serialize</code> function as follows: </p>
			<pre class="source-code">
fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
where
    S: Serializer,
{
    let mut s = serializer.serialize_struct("TaskStatus", 
                                             1)?;
    s.serialize_field("status", &amp;self.stringify())?;
    s.end()
}</pre>
			<p>In the preceding code, our serializer is the struct called <code>"TaskStatus"</code> with the number of fields being one. We then attributed the result of the <code>stringify</code> function to the <code>status</code> field. Doing this essentially gives us the following structure:</p>
			<pre class="source-code">
#[derive(Serialize)]
struct TaskStatus {
    status: String
}</pre>
			<p>However, we <a id="_idIndexMarker392"/>will not utilize the <code>serialize_struct</code> approach for our current exercise as we will need the status to be inserted into a bigger body to be returned.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Integrating serialization structs into our application code</h2>
			<p>Now that we have <a id="_idIndexMarker393"/>enabled our <code>TaskStatus</code> <code>enum</code> to be serialized, we can look back at <em class="italic">Figure 4</em><em class="italic">.7</em> and see that our <code>Base</code> struct is next to be serialized. We can also see that the <code>Base</code> struct is the key to JSON serialization, but it is currently not public, so we need to make it public. This can be done by changing the declaration of the base module in the <code>to_do/structs/mod.rs</code> file from <code>mod base;</code> to <code>pub mod base;</code>. Now that the <code>Base</code> struct is directly available outside of the module, we can build our own <code>json_serialization</code> module in the <code>src</code> directory with the following structure:   </p>
			<pre class="source-code">
├── main.rs
├── json_serialization
│   ├── mod.rs
│   └── to_do_items.rs</pre>
			<p>We will define what we will return to the viewer when the <code>get</code> view is called in the <code>src/json_serialization/to_do_items.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::Serialize;
use crate::to_do::ItemTypes;
use crate::to_do::structs::base::Base;
#[derive(Serialize)]
pub struct ToDoItems {
    pub pending_items: Vec&lt;Base&gt;,
    pub done_items: Vec&lt;Base&gt;,
    pub pending_item_count: i8,
    pub done_item_count: i8
}</pre>
			<p>In the<a id="_idIndexMarker394"/> preceding code, all we have done is define a standard public struct’s parameters. We then used the <code>derive</code> macro to implement the <code>Serialize</code> trait. This enables the struct’s attributes to be serialized to JSON with the name of the attribute as the key. For instance, if the <code>ToDoItems</code> struct had a <code>done_item_count</code> of one, then the JSON body would denote it as <code>"done_item_count": 1</code>. We can see that this is easier than the manual serialization that we did for our <code>TaskStatus</code> <code>enum</code> earlier. This is because the format of our fields is straightforward. If we do not need any extra logic during the serialization, decorating our <code>ToDoItems</code> with the <code>Serialize</code> trait is the easiest approach, which will result in fewer errors.  </p>
			<p>Now that serialization is defined, we must consider the processing of the data. It would not be scalable if we must sort the data and count it before calling the <code>struct</code>. This would add unnecessary code into the view that processes data for serialization as opposed to the logic belonging to the view in question. It would also enable duplicate code. There is only going to be one way we sort, count, and serialize the data. If other views are needed to return the list of items, then we would have to duplicate the code again.</p>
			<p>Considering this, it makes sense to build a constructor for the struct where we ingest a vector of to-do items, sort them into the right attributes, and then count them. We can define the constructor with the following code:</p>
			<pre class="source-code">
impl ToDoItems {
    pub fn new(input_items: Vec&lt;ItemTypes&gt;) -&gt; ToDoItems {
        . . . // code to be filled in
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker395"/>code, we can see that our constructor takes in a vector of to-do items that we will have loaded from our JSON file. Inside our constructor, we must carry out the following steps:</p>
			<ol>
				<li value="1">Sort the items into two vectors, one for pending items, and the other for complete items.</li>
			</ol>
			<p>We will merely loop through the vector of items appending to different vectors depending on the item type with the following code:</p>
			<pre class="source-code">
let mut pending_array_buffer = Vec::new();
let mut done_array_buffer = Vec::new();
for item in input_items {
    match item {
        ItemTypes::Pending(packed) =&gt; pending_array_buffer.
            push(packed.super_struct),
        ItemTypes::Done(packed) =&gt; done_array_buffer.push(
            packed.super_struct)
    }
}</pre>
			<ol>
				<li value="2">Count the total number of pending and complete items. </li>
			</ol>
			<p>For the next step, we can then call the <code>len</code> function on each vector. The <code>len</code> function returns <code>usize</code>, which is a pointer-sized unsigned integer type. Because of this, we can cast it as <code>i8</code> with the following code:</p>
			<pre class="source-code">
let done_count: i8 = done_array_buffer.len() as i8;
let pending_count: i8 = pending_array_buffer.len() as i8;</pre>
			<ol>
				<li value="3">We now<a id="_idIndexMarker396"/> have all the data that we need for constructing and returning the struct, which can be defined using the following code:<pre class="source-code">
return ToDoItems{</pre><pre class="source-code">
    pending_items: pending_array_buffer, </pre><pre class="source-code">
    done_item_count: done_count,</pre><pre class="source-code">
    pending_item_count: pending_count, </pre><pre class="source-code">
    done_items: done_array_buffer</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Now our constructor is done. </p>
			<p>We can now build our struct using this function. All we must do is plug it into our application so that we can pass it into our application. In the <code>json_serialization/mod.rs</code> file, we can make it public with the following code:</p>
			<pre class="source-code">
pub mod to_do_items;</pre>
			<p>We can now declare our module in the <code>src/main.rs</code> file with the following code:</p>
			<pre class="source-code">
mod json_serialization;</pre>
			<p>We also must ensure that our <code>base</code> module is public in the <code>src/to_do/structs/mod.rs</code> file. We are going to be serializing the | struct when returning data which can be achieved in the <code>src/to_do/structs/base.rs</code> file with the following code:</p>
			<pre class="source-code">
pub mod to_do_items;
use super::super::enums::TaskStatus;
use serde::Serialize;
#[derive(Serialize)]
pub struct Base {
    pub title: String,
    pub status: TaskStatus
}</pre>
			<p>To utilize<a id="_idIndexMarker397"/> our struct, we must define it in our <code>GET</code> view in our <code>views/to_do/get.rs</code> file and return it with the following code:</p>
			<pre class="source-code">
use actix_web::{web, Responder};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
use crate::to_do::{ItemTypes, to_do_factory, enums::TaskStatus};
use crate::json_serialization::to_do_items::ToDoItems;
pub async fn get() -&gt; impl Responder {
    let state: Map&lt;String, Value&gt; = read_file(
                                    "./state.json");
    let mut array_buffer = Vec::new();
    for (key, value) in state {
        let status = TaskStatus::from_string(
                          &amp;value.as_str().unwrap())
                                      .to_string();
        let item: ItemTypes = to_do_factory(
                                &amp;key, status);
        array_buffer.push(item);
    }
    let return_package: ToDoItems = ToDoItems::new(
                                     array_buffer);
    return web::Json(return_package);
}</pre>
			<p>The preceding <a id="_idIndexMarker398"/>code is another example of a moment where everything clicks together. We use our <code>read_file</code> interface to get the state from the JSON file. We can then loop through the map converting the item type into a string and feed it into our <code>to_do_factory</code> interface. Once we have the constructed item from the factory, we append it to a vector and feed that vector into our JSON serialization struct. After hitting the <code>get</code> view, we receive the following JSON body:</p>
			<pre class="console">
{
    "pending_items": [
        {
            "title": "learn to code rust",
            "status": "PENDING"
        },
        {
            "title": "washing",
            "status": "PENDING"
        }
    ],
    "done_items": [],
    "pending_item_count": 2,
    "done_item_count": 0
}</pre>
			<p>We now have a well-structured response that we can expand on and edit. The development of applications never stops so if you were going to continue to maintain this application you will be adding features to this return JSON body. We will soon move onto other views. However, before we do this, we must acknowledge that we will be returning the <a id="_idIndexMarker399"/>full list of items with counts every time we make an API call. Therefore, we must package this response in a function for every function; otherwise, we will be writing the same code that we wrote in the <code>get</code> view for every other view. In the next section, we will cover how we can package our to-do items so that they can be returned in multiple views. </p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Packaging our custom serialized struct to be returned to users</h2>
			<p>Now, our <code>GET</code> view returns <a id="_idIndexMarker400"/>an implementation of the <code>Responder</code> trait. This means that if our <code>ToDoItems</code> struct also implements this, it can be directly returned in a view. We can do this in our <code>json_serialization/to_do_items.rs</code> file. First, we must import the following structs and traits:</p>
			<pre class="source-code">
use serde::Serialize;
use std::vec::Vec;
use serde_json::value::Value;
use serde_json::Map;
use actix_web::{
    body::BoxBody, http::header::ContentType, 
    HttpRequest, HttpResponse, Responder,
};
use crate::to_do::ItemTypes;
use crate::to_do::structs::base::Base;
use crate::state::read_file;
use crate::to_do::{to_do_factory, enums::TaskStatus};</pre>
			<p>We can<a id="_idIndexMarker401"/> see from the <code>actix_web</code> crate that we have imported a range of structs and traits that will enable us to build an HTTP response. We can now implement the <code>get</code> view code in a <code>get_state</code> function for the <code>ToDoItems</code> struct with the following code:</p>
			<pre class="source-code">
impl ToDoItems {
    pub fn new(input_items: Vec&lt;ItemTypes&gt;) -&gt; ToDoItems {
        . . .
    }
    pub fn get_state() -&gt; ToDoItems {
        let state: Map&lt;String, Value&gt; = read_file("./state.            json");
        let mut array_buffer = Vec::new();
        for (key, value) in state {
            let status = TaskStatus::from_string(&amp;value
                         .as_str().unwrap().to_string());
            let item = to_do_factory(&amp;key, status);
            array_buffer.push(item);
        }
        return ToDoItems::new(array_buffer)
    }
}</pre>
			<p>The<a id="_idIndexMarker402"/> preceding code enables us to get all the to-do items from our JSON file with just one line of code. We must enable our <code>ToDoItems</code> struct to be returned in a view by implementing the <code>Responder</code> trait with the following code:</p>
			<pre class="source-code">
impl Responder for ToDoItems {
    type Body = BoxBody;
    fn respond_to(self, _req: &amp;HttpRequest) 
                            -&gt; HttpResponse&lt;Self::Body&gt; {
        let body = serde_json::to_string(&amp;self).unwrap();
        HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(body)
    }
}</pre>
			<p>In the preceding code, what we have essentially done is serialize our <code>ToDoItems</code> struct using the <code>serde_json</code> crate, and then returned an HTTP response with the <code>ToDoItems</code> struct at the body. The <code>respond_to</code> function will be called when our <code>ToDoItems</code> struct is being returned in a view. Now this is where it gets really cool. We can rewrite our <code>views/to_do/get.rs</code> file with the following code:</p>
			<pre class="source-code">
use actix_web::Responder;
use crate::json_serialization::to_do_items::ToDoItems;
pub async fn get() -&gt; impl Responder {
    return ToDoItems::get_state();
}</pre>
			<p>That is it! If <a id="_idIndexMarker403"/>we run our application now, we will get the same response as we had before. With this, we can see how traits can abstract code for our views. Now that we have created the <code>get</code> view, we must work on building other views that create, edit, and delete. To do this, we are going to move on to our next section, which is extracting data from our views. </p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Extracting data from views</h1>
			<p>In this section, we are <a id="_idIndexMarker404"/>going to explore extracting data from our HTTP requests<a id="_idIndexMarker405"/> from the header and body. We are then going to use these methods to edit, delete to-do items, and intercept requests before they are fully loaded with middleware. We will go one step at a time. For now, let us extract data from the body of the HTTP request to edit a to-do item. When it comes to accepting data in JSON format, we should do what we have been doing throughout the book, separating this code from the view. If we think about it, we just need to send in the item that we are editing. However, we can also use this same schema for deleting. We can define our schema in our <code>json_serialization/to_do_item.rs</code> file with the following code:</p>
			<pre class="source-code">
use serde::Deserialize;
#[derive(Deserialize)]
pub struct ToDoItem {
    pub title: String,
    pub status: String
}</pre>
			<p>In the preceding code, we have merely stated which type of data we need for each field as we cannot pass enums through JSON; only strings can be passed. The deserialization from JSON is enabled by decorating the <code>ToDoItem</code> struct with the <code>Deserialize</code> trait macro. We must remember to make the <code>ToDoItem</code> struct available to the rest of the application, so our <code>json_serialization/mod.rs</code> file should look like the following:</p>
			<pre class="source-code">
pub mod to_do_items;
pub mod to_do_item;</pre>
			<p>Now that our item extraction is done, we can move on to our <code>edit</code> view. In our <code>views/to_do/edit.rs</code> file we can import what we need with the following code:</p>
			<pre class="source-code">
use actix_web::{web, HttpResponse};
use serde_json::value::Value;
use serde_json::Map;
use crate::state::read_file;
use crate::to_do::{to_do_factory, enums::TaskStatus};
use crate::json_serialization::{to_do_item::ToDoItem, 
                                to_do_items::ToDoItems};
use crate::processes::process_input;</pre>
			<p>In the<a id="_idIndexMarker406"/> preceding code, we can see that we need to import the<a id="_idIndexMarker407"/> standard serialization and web structs needed for a view. We also import the structs <code>ToDoItem</code> and <code>ToDoItems</code> for ingesting data and returning the entire state of the application. We can then import our <code>process_input</code> function that processes the input with a command. At this point, looking at the imports, can you think of the steps needed to perform our edit? Have a think before moving forward. The path is like what we did with a <code>get</code> view; however, we must update the state with the new updated item. We must also remember that our <code>process_input</code> function will edit the to-do item if the <code>edit</code> command is passed in. </p>
			<p>After <a id="_idIndexMarker408"/>thinking it through, remember, there are many ways to <a id="_idIndexMarker409"/>solve a problem. If your steps solve the problem, then do not feel bad if it is different from the steps laid out. You may also produce a better solution. Our <code>edit</code> view involves the following steps:</p>
			<ol>
				<li value="1">Get the state of the entire application for the to-do items.</li>
				<li>Check to see if the item is there, returning a <code>not found</code> response if it is not.</li>
				<li>Pass the data through the <code>to_do_factory</code> factory to construct the existing data from the state to an item that we can manipulate.</li>
				<li>Check that the status being put in is not the same as the existing status. </li>
				<li>Pass the existing item into the <code>process_input</code> function with an <code>edit</code> command so it is saved to the JSON state file. </li>
				<li>Get the<a id="_idIndexMarker410"/> state <a id="_idIndexMarker411"/>of the application and return it. </li>
			</ol>
			<p>With these steps in mind, we can concrete our knowledge of extracting JSON from the body of the request and process it for editing in the next subsection. </p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Extracting JSON from the body of a request</h2>
			<p>Now that we <a id="_idIndexMarker412"/>have the imports done and the outline defined, we can define the outline of our view with the following code:</p>
			<pre class="source-code">
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;) 
                                 -&gt; HttpResponse {
    . . .
}</pre>
			<p>In the preceding code, we can see that our <code>ToDoItem</code> struct is wrapped in the <code>web::Json</code> struct. This means that the parameter <code>to_do_item</code> will be extracted from the body of the request, serialized, and constructed as the <code>ToDoItem</code> struct. So, inside our view, our <code>to_do_item</code> is a <code>ToDoItem</code> struct. Thus, inside our view, we can load our state with the following code:</p>
			<pre class="source-code">
let state: Map&lt;String, Value&gt; = read_file("./state.json");</pre>
			<p>We can then extract the item data from our state with the following code:</p>
			<pre class="source-code">
let status: TaskStatus;
match &amp;state.get(&amp;to_do_item.title) {
    Some(result) =&gt; {
        status = TaskStatus::new(result.as_str().unwrap());
    }
    None=&gt; {
        return HttpResponse::NotFound().json(
            format!("{} not in state", &amp;to_do_item.title))
    }
}</pre>
			<p>In the preceding code, we can see that we can construct the status from the data or return a <code>not found</code> HTTP response if it is not found. We then need to construct the item struct with the existing data using the following code:</p>
			<pre class="source-code">
let existing_item = to_do_factory(to_do_item.title.as_str(), 
              status.clone());</pre>
			<p>In the <a id="_idIndexMarker413"/>preceding code, we can see why our factory is coming in handy. Now, we need to compare the new and existing status for the item. There is no point altering the status if the desired status is the same as the following code:</p>
			<pre class="source-code">
if &amp;status.stringify() == &amp;TaskStatus::from_string(
                          &amp;to_do_item.status.as_str()
                          .to_string()).stringify() {
    return HttpResponse::Ok().json(ToDoItems::get_state())
}</pre>
			<p>Therefore, we need to check the current status and if it is the same as the desired status, we merely return an <code>Ok</code> HTTP response state. We do this because the frontend client might be out of sync. In the next chapter, we will be writing the frontend code and we will see that the items will be cached and rendered. If, let’s say, another tab is open with our application or we have updated our to-do application on another device such as a phone, then the client making this request might be out of sync. We do not want to execute a command based on an out-of-sync frontend. We then need to process the input by making an edit and then returning the state with the following code:</p>
			<pre class="source-code">
process_input(existing_item, "edit".to_owned(), &amp;state);
return HttpResponse::Ok().json(ToDoItems::get_state())</pre>
			<p>The <a id="_idIndexMarker414"/>preceding code should work but right now, it will not. This is because we need to clone our <code>TaskStatus</code> enum and our <code>TaskStatus</code> does not implement the <code>Clone</code> trait. This can be updated in our <code>src/to_do/enums.rs</code> file with the following code:</p>
			<pre class="source-code">
#[derive(Clone)]
pub enum TaskStatus {
    DONE,
    PENDING
}</pre>
			<p>We must then ensure that the <code>edit</code> view is available and defined in the <code>to-do</code> view factory. So, in the <code>src/views/to_do/mod.rs</code> file, our factory should look like the following:</p>
			<pre class="source-code">
mod create;
mod get;
mod edit;
use actix_web::web::{ServiceConfig, post, get, scope};
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {
    app.service(
        scope("v1/item")
        .route("create/{title}", post().to(create::create))
        .route("get", get().to(get::get))
        .route("edit", post().to(edit::edit))
    );
}</pre>
			<p>We can see that our view factory is scaling nicely. We can also stand back and appreciate that all our views for to-do items are defined nicely in one isolated page meaning we can simply look at the preceding code and still know that we need a <code>delete</code> view. We can now run our application and make a request in Postman with the following <a id="_idIndexMarker415"/>configuration:</p>
			<div><div><img src="img/Figure_4.8_B18722.jpg" alt="Figure 4.8 – Edit request with Postman "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Edit request with Postman </p>
			<p>We can see in <em class="italic">Figure 4</em><em class="italic">.8</em> that we are switching our washing task to <code>"DONE"</code>. We have put this data in the body as raw with the format to be JSON. If we make this call to the <code>edit</code> endpoint, we will get the following response:</p>
			<pre class="console">
{
    "pending_items": [
        {
            "title": "learn to code rust",
            "status": "PENDING"
        }
    ],
    "done_items": [
        {
            "title": "washing",
            "status": "DONE"
        }
    ],
    "pending_item_count": 1,
    "done_item_count": 1
}</pre>
			<p>In the preceding code, we can see that the done items list is now populated and that the counts have been altered. If we continue to make the same call, we will get the same response as we will be editing the <code>washing</code> item to <code>done</code> when it already has a done status. We will have to switch the status of <code>washing</code> back to <code>pending</code> or change the title in our call to get a different updated state. If we do not include <code>title</code> and <code>status</code> in the body of our call, then we will get a bad request response instantly, because the <code>ToDoItem</code> struct is expecting those two fields. </p>
			<p>Now that we<a id="_idIndexMarker416"/> have locked down the process of receiving and returning JSON data in the URL parameters and body, we are nearly done. However, we have one more important method to cover that’s used for data extraction – the header. Headers are used t<a id="_idTextAnchor085"/>o store meta information such as security credentials.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Extracting data from the header in requests</h2>
			<p>If we needed to <a id="_idIndexMarker417"/>authorize a range of requests; it would not be scalable to put them in all our JSON structs. We also must acknowledge that the request body could be large, especially if the requester is being malicious. Therefore, it makes sense to access the security credentials before passing the request through to the view. This can be done by intercepting the request through what is commonly known as middleware. Once we’ve intercepted the request, we can access the security credentials, check them, and then process the view.</p>
			<p>In the previous edition of this book, we manually developed our middleware for our authentication. However, this is not scalable in terms of code management and does not allow flexibility. However, it is important to cover manually configuring your own middleware to have a better understanding of how the server constructors work giving you the flexibility of processing requests. To intercept our requests, we need to add the <code>actix-service</code> crate. With this installation, our <code>Cargo.toml</code> file dependencies should look like the following definitions:</p>
			<pre class="source-code">
[dependencies]
actix-web = "4.0.1"
serde_json = "1.0.59"
serde = { version = "1.0.136", features = ["derive"] }
actix-service = "2.0.2"</pre>
			<p>Now, we can update our <code>src/main.rs</code> file. First, our imports should look like the following:</p>
			<pre class="source-code">
use actix_web::{App, HttpServer};
use actix_service::Service;
mod views;
mod to_do;
mod state;
mod processes;
mod json_serialization;</pre>
			<p>Now that all the <a id="_idIndexMarker418"/>imports are done, we can define our server construction with the following code:</p>
			<pre class="source-code">
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        let app = App::new()
            .wrap_fn(|req, srv|{
                println!("{:?}", req);
                let future = srv.call(req);
                async {
                    let result = future.await?;
                    Ok(result)
                }
        }).configure(views::views_factory);
        return app
    })
    .bind("127.0.0.1:8000")?
    .run()
    .await
}</pre>
			<p>In the preceding code, we can see that the <code>wrap_fn</code> enables us to interact with the request (<code>req</code>). The service routing (<code>srv</code>) can be called when we need it to pass the request. We must note that calling the routing service is a future that we then wait to finish in an <code>async</code> code block returning the result. This is middleware. We can manipulate our request, inspect it, and reroute or return it before calling the routing service to process the HTTP request in one of our views. For us, we are just printing out the debug of the request, which looks like the following printout:</p>
			<pre class="console">
ServiceRequest HTTP/1.1 GET:/v1/item/get
  headers:
    "accept-language": "en-GB,en-US;q=0.9,en;q=0.8"
    "accept": "text/html,application/xhtml+xml,application/xml;
    q=0.9,image/avif,image/webp,image/        apng,*/*;q=0.8,application
    signed-exchange;v=b3;q=0.9"
    "sec-ch-ua-platform": "\"macOS\""
    "sec-fetch-site": "none"
    . . . 
    "host": "127.0.0.1:8000"
    "connection": "keep-alive"
    "sec-fetch-user": "?1"</pre>
			<p>We can see that <a id="_idIndexMarker419"/>we have a lot of data to work with. But this is as far as we will go with our homemade middleware. We will now investigate extracting data from headers using traits. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Simplifying header extraction with traits</h2>
			<p>Before we <a id="_idIndexMarker420"/>do this, we will have to install the futures crate, adding the following to the dependencies section of the <code>Cargo.toml</code> file: </p>
			<pre class="source-code">
futures = "0.3.21"</pre>
			<p>We will now create an <code>src/jwt.rs</code> file to house <a id="_idIndexMarker421"/>our <code>src/jwt.rs</code> file with the following code:</p>
			<pre class="source-code">
use actix_web::dev::Payload;
use actix_web::{Error, FromRequest, HttpRequest};
use futures::future::{Ready, ok};</pre>
			<p>The <code>Payload</code> struct houses the requests raw data stream. We then have the <code>FromRequest</code> trait which is what we are going to implement to extract the data before it hits the view. We then use the <code>Ready</code> and <code>ok</code> from futures to wrap the result of our data extraction to create a future that is immediately ready with a success value, which is the value from our header extraction. Now that we have imported what we need, we can define our JWT struct with the following code:</p>
			<pre class="source-code">
pub struct JwToken {
    pub message: String
}</pre>
			<p>For now, we are only going to have a message but, in the future, we will be adding fields like the ID of the user. With <a id="_idIndexMarker422"/>this struct, we can implement the <code>FromRequest</code> trait with the following code:</p>
			<pre class="source-code">
impl FromRequest for JwToken {
    type Error = Error;
    type Future = Ready&lt;Result&lt;JwToken, Error&gt;&gt;;
    fn from_request(req: &amp;HttpRequest, _: &amp;mut Payload) 
                                          -&gt; Self::Future {
    . . .
    }
}</pre>
			<p>We can deduce that the <code>from_request</code> function gets called before the view is loaded. We are extracting the header, which is why we have no interest in the payload. So, we mark the parameter with <code>_</code>. We need to define the <code>Future</code> type, which is a ready future housing a result that can either be our <code>JwToken</code> struct or an error. Inside the <code>from_request</code> function, we can extract the data from the header with the following code:</p>
			<pre class="source-code">
match req.headers().get("token") {
    Some(data) =&gt; {
        let token = JwToken{
            message: data.to_str().unwrap().to_string()
        };
        ok(token)
    },
    None =&gt; {
        let token = JwToken{
            message: String::from("nothing found")
        };
        ok(token)
    }
}</pre>
			<p>In the preceding code, we <a id="_idIndexMarker423"/>can see that for this chapter we just look for the <code>token</code> key and if it is there, we return the <code>JwToken</code> struct with the message. If not, we will return the <code>JwToken</code> struct with nothing found. As this chapter focuses on data, this is where we stop, but in <a href="B18722_07.xhtml#_idTextAnchor149"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing User Sessions</em>, we will revisit this function and explore concepts such as throwing errors and returning requests before they hit the view with unauthorized codes. For now, we must make our <code>JwToken</code> struct accessible by defining it in our <code>src/main.rs</code> file with the following line of code:</p>
			<pre class="source-code">
mod jwt;</pre>
			<p>Now that we have gone through the hassle of implementing a trait, using it is going to be compact and simple. Let us revisit our <code>edit</code> view in our <code>views/to_do/edit.rs</code> file, import our <code>JwToken</code> struct, add our <code>JwToken</code> struct to our parameters in the <code>edit</code> view, and print out the message as seen in the following code:</p>
			<pre class="source-code">
use crate::jwt::JwToken;
pub async fn edit(to_do_item: web::Json&lt;ToDoItem&gt;, 
                  token: JwToken) -&gt; HttpResponse {
    println!("here is the message in the token: {}", 
              token.message);
    . . .</pre>
			<p>Clearly, we do not want to <a id="_idIndexMarker424"/>edit the rest of the view but as we can deduce from the preceding code, the <code>token</code> parameter is the constructed <code>JwToken</code> struct that has been extracted from the HTTP request and is ready for use just like the <code>ToDoItem</code> struct. If we make the same edit HTTP call now after running the server, we will see that the HTTP request is printed out, but we also get the following response:</p>
			<pre class="console">
here is the message in the token: nothing found</pre>
			<p>It looks like it is working, as we haven’t added anything to the header yet. We can add a token into our header with the Postman setup defined in the following figure: </p>
			<div><div><img src="img/Figure_4.9_B18722.jpg" alt="Figure 4.9 – Edit request in Postman with header "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Edit request in Postman with header </p>
			<p>If we send the <a id="_idIndexMarker425"/>request again, we get the following printout:</p>
			<pre class="console">
here is the message in the token: "hello from header"</pre>
			<p>That’s it! We can pass data through headers. What’s more, adding and taking them away from views is as easy as defining them in the parameters and removing them. </p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we have put all of what we have learned in the previous chapters to good use. We fused the logic from the to-do item factory, which loads and saves to-do items from a JSON file, and looked at the to-do item process logic by using the basic views from <code>Actix-web</code>. With this, we have been able to see how the isolated modules click together. We will keep reaping the benefits of this approach in the next few chapters as we rip out the JSON file that loads and saves a database. </p>
			<p>We also managed to utilize the <code>serde</code> crate to serialize complex data structures. This allows our users to get the full state update returned to them when they make an edit. We also built on our knowledge of futures, <code>async</code> blocks, and closures to intercept requests before they reached the view. Now, we can see that the power of Rust is enabling us to do some highly customizable things to our server, without us having to dig deep into the framework. </p>
			<p>Thus, Rust has a strong future in web development. Despite its infancy, we can get things up and running with little to no code. With a few more lines of code and a closure, we are building our own middleware. Our JSON serialization structs were made possible with just one line of code, and the traits provided by <code>Actix</code> enabled us to merely define the parameter in the view function, thus enabling the view to automatically extract the data from the body and serialize it into the struct. This scalable, powerful, and standardized way of passing data is more concise than many high-level languages. We can now fully interact with and inspect every part of the HTTP request. </p>
			<p>Now that we are processing and returning well-structured data to the user, we can start displaying it in an interactive way for our user to point and click when editing, creating, and deleting to-do items. </p>
			<p>In the next chapter, we will be serving HTML, CSS, and JavaScript from the <code>Actix-web</code> server. This will enable us to see and interact with to-do items via a graphical user interface, with the JavaScript making API calls to the endpoints we defined in this chapter. </p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Questions</h1>
			<ol>
				<li value="1">What is the difference between a <code>GET</code> and <code>POST</code> request?</li>
				<li>Why would we have middleware when we check credentials? </li>
				<li>How do you enable a custom <code>struct</code> to be directly returned in a view?</li>
				<li>How do you enact middleware for the server?</li>
				<li>How do you enable a custom <code>struct</code> to serialize data into the view?</li>
			</ol>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Answers</h1>
			<ol>
				<li value="1">A <code>GET</code> request can be cached and there are limits to the types and amount of data that can be sent. A <code>POST</code> request has a body, which enables more data to be transferred. Also, it cannot be cached. </li>
				<li>We use middleware to open the header and check the credentials before sending the request to the desired view. This gives us an opportunity to prevent the body from being loaded by returning an <code>auth</code> error before loading the view preventing the potentially malicious body. </li>
				<li>For the struct to be directly returned, we will have to implement the <code>Responder</code> trait. During this implementation, we will have to define the <code>responded_to</code> function that accepts the HTTP request struct. The <code>responded_to</code> will be fired when the struct is returned. </li>
				<li>In order to enact middleware, we enact the <code>wrap_fn</code> function on the <code>App</code> struct. In the <code>wrap_fn</code> function, we pass a closure that accepts the service request and routing structs. </li>
				<li>We decorate the struct with the <code>#[derive(Deserialize)]</code> macro. Once we have done this, we define the parameter type to be wrapped in a JSON struct: <code>parameter: web::Json&lt;ToDoItem&gt;</code>.</li>
			</ol>
		</div>
	</body></html>