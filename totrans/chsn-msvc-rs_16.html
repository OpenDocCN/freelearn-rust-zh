<html><head></head><body>
        

                            
                    <h1 class="header-title">DevOps of Rust Microservices - Continuous Integration and Delivery</h1>
                
            
            
                
<p class="mce-root">This chapter covers the widely used practices of <strong>continuous integration</strong> (<strong>CI</strong>) and <strong>continuous delivery</strong> (<strong>CD</strong>). When a microservice is being developed, you have to be sure that every feature is tested and works and think about how to deliver an application to your servers or deploy it to the cloud.</p>
<p class="mce-root">In this chapter, we'll study how to do the following:</p>
<ul>
<li>How to use tools to check the code</li>
<li>How to build the code automatically using CI tools</li>
<li>How to deploy the compiled code to servers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the Rust compiler, and you have to install at least version 1.31. Also, you need the <kbd>rustup</kbd> tool to add extra components, such as <kbd>rustfmt</kbd> and <kbd>clippy</kbd>. If you don't have it, you can find it here: <a href="https://rustup.rs/">https://rustup.rs/</a></p>
<p>Also in this chapter, we will try to bootstrap a CI system that will build and test a microservice. Since manual installation of these kinds of tools is long and complex, we will use Docker with Docker Compose to start and prepare the building environment faster. But in any case, you need a browser to be able to connect to the management console UI of the TeamCity tool to configure it.</p>
<p>The examples for this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter16.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous integration and continuous delivery</h1>
                
            
            
                
<p>In the modern world, speed is a decisive factor of success for applications and products. The competition has become fierce and every company has to release new features as fast as possible.</p>
<p>For microservice developers, this means we need a continuous process for building and delivering new versions of our products to be timely and competitive. In terms of software, this means you need to automate this process—maybe a special product or a set of scripts. Fortunately, this class of products already exists; called CI tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous integration </h1>
                
            
            
                
<p>CI is the process of merging all incoming features and patches into a single, well-tested application. It is important to note that this should happen several times a day—you will get a freshly <em>baked</em> version, like from a conveyor belt.</p>
<p>Nowadays, many products are offered to provide you a tool to test, build, and deploy your product unclear. In most cases, CI products work as a server that uses remote build agents to build code pulled from a repository. This process is approximately depicted in the following diagram:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/39e23daf-c25f-42a5-8262-d124dc94f259.png"/></p>
<p>The CI server is responsible for getting updates from a source code management server (such as Git) to pull a fresh version of the code and start building on using agents that are already connected and registered on the server. Some software can use Docker as a runtime for the necessary build agents. In this case, you don't even need to run agents manually. But this is not suitable for every part of an application, because some parts need to be built in an environment that can't be started as a Docker container.</p>
<p>Microservices that have been compiled and tested successfully can be moved to a deployment process that also can be automated using CD.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous delivery </h1>
                
            
            
                
<p>When an application is built and is ready for deployment, the process of deployment automation is called CD. Often, this functionality is provided by CI products by using special plugins called configuration management and deployment tools, such as Ansible, Chef, Puppet, and Salt.</p>
<p>In the past, microservices were delivered as an archive with files such as <strong>Web ARchives</strong> (<strong>WAR</strong>), in Java, as packages installed directly on a server's operating system, and as binaries. Nowadays, companies prefer to deliver containers, instead of these other formats. The advantages of containers are undeniable: they're compact and safe, they use shared registries, and you don't need to prepare environments again and again. A Docker image already contains what you need, and if your microservices can work without collisions with other instances of the same microservice, you can consider delivering your product not only as a container deployed to a remote server, but also using an orchestration tool that automatically scales your application depending on your customers' needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Container orchestration</h1>
                
            
            
                
<p>With automated building and delivery processes, you can still deploy a microservice into an unscalable environment. This means you lose the important benefit of fast-scaling your application. Developers of one huge internet hiring service told me a funny story about the peak load they experience—the greatest activity on their servers falls on Monday morning. That's the time when every worker visits the office after the weekend and decides, <em>that's finished</em>. The reality of application maintenance is that you can't predict peaks of activity for your services, so you should be able to run more instances of your microservices quickly.</p>
<p>There are some products that can orchestrate containers, and one of the most popular is Kubernetes. The only thing you have to do is to upload containers to a registry. Kubernetes can route requests and run extra instances of microservices that can't process all incoming requests. However, you still need to provide hardware resources to it and write loosely coupled microservices so that you can run as many as you want.</p>
<p>In any case, to automate the delivery process of your application, you have to start with a CI system and improve it. Let's look at the tools that we can use to write CI scripts for Rust projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rust tools</h1>
                
            
            
                
<p>The first line of quality control of microservices is checking that the code does not contain explicit blunders. The compiler checks the cases with mutability, references, ownership, and lifetimes, and also prints warnings if you have unused code, but there are more complex cases that require a special tool to detect.</p>
<p>In this section, we cover the following tools commonly used in CI agents to prepare a code for merging. Let's explore all of them, starting with code formatting styles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rustfmt</h1>
                
            
            
                
<p>Rustfmt is a tool that helps you to fit your code to style guidelines. It doesn't mean you have to use one common style: the tool provides multiple configuration parameters that you can use to set a preferred style.</p>
<p>This tool is mature, but it wasn't included in the Rust distribution until version 1.31. Since edition 2018 was released, the rustfmt tool has been available and is recommended for use in your projects; however, Rust doesn't force your code to have a standard format. Let's install it and try to use it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation</h1>
                
            
            
                
<p>If you use the <kbd>rustup</kbd> tool, then to install <kbd>rustfmt</kbd>, you need to add the corresponding component using the following command:</p>
<pre><strong>rustup component add rustfmt</strong></pre>
<p>If you want to install the latest version, you can do it directly from the repository:</p>
<pre><strong>cargo install --git https://github.com/rust-lang/rustfmt</strong></pre>
<p>The installation from source code requires compilation time and can be unstable, but you will have the latest features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Usage</h1>
                
            
            
                
<p>Since <kbd>rustfmt</kbd> was added as a command, using it is as simple as calling a special command:</p>
<pre><strong>cargo fmt</strong></pre>
<p>This command fixes all sources to default style guidelines. But it works quietly and we have to look at the differences between files to see the changes.</p>
<p>The tool patches files from your project, and you have to commit all the changes before you attempt to fix the code styles.</p>
<p>But we will use this tool to check the code styles with CI, and stop building if the code was formatted incorrectly. To check the code and also to see potential changes, you have to pass the <kbd>--check</kbd> argument to <kbd>rustfmt</kbd>:</p>
<pre><strong>cargo fmt -- --check</strong></pre>
<p>As you can see, we used an extra <kbd>--</kbd> parameter, because without it, we pass arguments to a tool that calls <kbd>rustfmt</kbd>, but to send arguments directly to <kbd>rustfmt</kbd> we have to add this extra pair of dashes. The checking has a <kbd>0</kbd> code if sources don't contain issues, and a non-zero code if errors are present, printing a potential diff:</p>
<pre>Diff in ./microservice/src/main.rs at line 1:<br/>-use actix_web::{App, middleware, server, App};<br/>+use actix_web::{middleware, server, App, App};<br/> <br/> fn index(_req: &amp;HttpRequest) -&gt; &amp;'static str {<br/>     "Microservice"<br/>Diff in ./microservice/src/main.rs at line 8:<br/>     env_logger::init();<br/>     let sys = actix::System::new("microservice");<br/>     server::new(|| {<br/>-        App::new().middleware(middleware::Logger::default()).resource("/", |r| r.f(index))<br/>+        App::new()<br/>+            .middleware(middleware::Logger::default())<br/>+            .resource("/", |r| r.f(index))<br/>     })<br/>     .bind("127.0.0.1:8080")<br/>     .unwrap()</pre>
<p>This is exactly what we need to use in CI to interrupt the building, and to see the reason for the interruption in order to fix it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration</h1>
                
            
            
                
<p>You can change the behavior of <kbd>rustfmt</kbd> with a configuration to set your preferred styles. Add the <kbd>rustfmt.toml</kbd> configuration file to your project. The defaults of the current version can be described with the following configuration file contents:</p>
<pre>max_width = 100<br/>hard_tabs = false<br/>tab_spaces = 4<br/>newline_style = "Auto"<br/>use_small_heuristics = "Default"<br/>reorder_imports = true<br/>reorder_modules = true<br/>remove_nested_parens = true<br/>edition = "2015"<br/>merge_derives = true<br/>use_try_shorthand = false<br/>use_field_init_shorthand = false<br/>force_explicit_abi = true</pre>
<p>Most parameters have descriptive names, but if you want to read a description of the parameters, you can pass the <kbd>--help=config</kbd> argument to <kbd>rustfmt</kbd> to see the details. You can create a <kbd>rustfmt.toml</kbd> file and set parameters that are different from the default values.</p>
<p>Often, code style checking is the first step of a CI script, because it's the fastest check and is best done before a long compilation process. There is also another code check that we should do before compilation—lint checking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Clippy</h1>
                
            
            
                
<p>In addition to the problems with the format of your code, you may also face more serious problems that can be fixed with another kind of tool—linters. A linter is a program that finds bad practices of writing code that can affect the future performance if the problem can be solved more simply. Rust has a good linter called <kbd>clippy</kbd>, included as a component since version 1.31, when it became a part of edition 2018. It's a good tool to use when building scripts to prevent a flood of bad coding practices. Let's install it and try to use it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation</h1>
                
            
            
                
<p>You can install <kbd>clippy</kbd> in two ways, as we did with the <kbd>rustfmt</kbd> tool: by adding the component using the <kbd>rustup</kbd> command or by installing the latest version from the GitHub repository of the project. To add it as a prebuilt component, use the following command:</p>
<pre><strong>rustup component add clippy</strong></pre>
<p>You also can install the latest version directly from the repository of the project using this command:</p>
<pre><strong>cargo install --git https://github.com/rust-lang/rust-clippy</strong></pre>
<p>But remember, this version is potentially unstable, and the lints it contains might be changed in the future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Usage</h1>
                
            
            
                
<p>To use <kbd>clippy</kbd>, it's enough to start it as the subcommand of <kbd>cargo</kbd>:</p>
<pre><strong>cargo clippy</strong></pre>
<p>This sub-command starts checking the code and will inform you about possible improvements. For example, imagine that you have a struct like this in your code:</p>
<pre>struct State {<br/>    vec: Box&lt;Vec&lt;u8&gt;&gt;,<br/>}</pre>
<p>Then, <kbd>clippy</kbd> will inform you that <kbd>Box</kbd> is unnecessary, since <kbd>Vec</kbd> is already placed in a memory heap:</p>
<pre>warning: you seem to be trying to use `Box&lt;Vec&lt;T&gt;&gt;`. Consider using just `Vec&lt;T&gt;`<br/> --&gt; src/main.rs:4:10<br/>  |<br/>4 |     vec: Box&lt;Vec&lt;u8&gt;&gt;,<br/>  |          ^^^^^^^^^^^^<br/>  |<br/>  = note: #[warn(clippy::box_vec)] on by default<br/>  = help: `Vec&lt;T&gt;` is already on the heap, `Box&lt;Vec&lt;T&gt;&gt;` makes an extra allocation.<br/>  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#box_vec</pre>
<p>But if you really want to box a vector, you can disable this warning for this line of code by adding the <kbd>#[allow(clippy::box_vec)]</kbd> attribute to the field or the struct, and the warning for this field will be suppressed.</p>
<p>The preceding example is a warning that means the code will be compiled successfully and the building won't be interrupted by <kbd>clippy</kbd>. In CI scripts, <kbd>clippy</kbd> has to interrupt execution if it gets a warning from the code, because we should merge code that doesn't contain any warnings, as well as ambiguous code. To let <kbd>clippy</kbd> fail when there's warning, we can set the extra argument:</p>
<pre><strong>cargo clippy -- -D warnings</strong></pre>
<p>Now, <kbd>clippy</kbd> denies all warnings. But there is still a loophole if your crate contains non-default features: <kbd>clippy</kbd> won't check all of them. To do a full check, you can use the following arguments:</p>
<pre><strong>cargo clippy --all-targets --all-features -- -D warnings</strong></pre>
<p>Of course, it will take more time, but all potential problems known to <kbd>clippy</kbd> will be checked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration</h1>
                
            
            
                
<p>The <kbd>clippy</kbd> tool can be very annoying. To tighten or loosen checks, you can configure the tool using the <kbd>clippy.toml</kbd> configuration file.</p>
<p>For example, if we activate all lints with the <kbd>-W clippy::pedantic</kbd> argument, we can get a warning like this:</p>
<pre>warning: you should put `MyCompany` between ticks in the documentation<br/> --&gt; src/main.rs:8:29<br/>  |<br/>8 | /// This method connects to MyCompany API.<br/>  |                             ^^^^^^^^^<br/>  |<br/>  = note: `-W clippy::doc-markdown` implied by `-W clippy::pedantic`<br/>  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown</pre>
<p>This happened because <kbd>clippy</kbd> thinks there is the name of a variable that we forget to include in ticks. To avoid this behavior, we can add an extra word to the <kbd>clippy.toml</kbd> configuration to ignore markdown comments:</p>
<pre>doc-valid-idents = ["MyCompany"]</pre>
<p>Now the tool won't interpret <kbd>MyCompany</kbd> as the name of a variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recommended code attributes</h1>
                
            
            
                
<p>As you saw, it's possible to allow or deny some warnings for lints, but there are some attributes that can be used to make your code cleaner:</p>
<pre>#![deny(<br/>    bare_trait_objects,<br/>    dead_code,<br/>)]<br/>#![warn(<br/>    missing_debug_implementations,<br/>    missing_docs,<br/>    while_true,<br/>    unreachable_pub,<br/>)]<br/>#![cfg_attr(<br/>    feature = "cargo-clippy",<br/>    deny(<br/>        clippy::doc_markdown,<br/>    ),<br/>)]</pre>
<p>This is an example of stricter requirements for a code. The compiler deny unused code of missing docs, will require <kbd>loop</kbd> instead of <kbd>while true</kbd> and check all published types have to be reachable. Also, we completely deny using variable names in markdown docs without ticks. You can add whatever requirements you need to your project.</p>
<p>Also, the preceding requirements force us to use <kbd>dyn Trait</kbd> for trait objects, instead of a bare <kbd>Trait</kbd> name. This may come in handy if you use the 2015 edition but want to prepare the project for Edition 2018, but it's better to use the latest edition where possible, and there is a tool that can help you to move to the freshest edition of Rust—<kbd>rustfix</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rustfix</h1>
                
            
            
                
<p>You may have thought, if Rust can find a problem in a code and suggest a solution, why hasn't it applied the changes immediately? This is a reasonable idea, and it may be possible in the future, but now this feature in active development with the <kbd>rustfix</kbd> tool.</p>
<p>This project aims to provide a tool that can fix all compiler warnings, and today you can try to use it to move your project from Edition 2015 to Edition 2018. We don't need this tool in CI processes directly, but it can help to satisfy CI checks more quickly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation</h1>
                
            
            
                
<p>To install <kbd>rustfix</kbd>, use the following command:</p>
<pre><strong>cargo install cargo-fix</strong></pre>
<p>After installation, you can use the <kbd>cargo fix</kbd> subcommand with the necessary parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Usage</h1>
                
            
            
                
<p>Let's consider moving the project from Edition 2015 to Edition 2018. Which arguments do you have to set to do this transformation of your code? First, you can prepare your code for transformation with this command:</p>
<pre><strong>cargo fix --edition</strong></pre>
<p>This command will make your code compatible with both editions, but if you want to use idioms of an edition, you have to set the edition version to be used in the <kbd>edition</kbd> field of the <kbd>[package]</kbd> section of the <kbd>Cargo.toml</kbd> file, and run the following command:</p>
<pre><strong>cargo fix --edition-idioms</strong></pre>
<p>After running this, your code will potentially be compatible with the selected edition. You can also do more with <kbd>rustfix</kbd>, but some issues can be fixed if you use an IDE, but this topic is out of the scope of this book; and let's explore other cargo commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cargo test</h1>
                
            
            
                
<p>To be perfectly honest, the most important tool for checking in CI is the testing tool. We already learned about writing tests in <a href="1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml">Chapter 13</a>, <em>Testing and Debugging Rust Microservices</em>, but in this section we explore some useful arguments for the <kbd>cargo test</kbd> command.</p>
<p>There are some useful arguments for CI:</p>
<ul>
<li><kbd>--no-run</kbd>: Compiles, but doesn't run tests, which is useful for checking the compilation of tests for different targets, without wasting time for extra running</li>
<li><kbd>--all-targets</kbd>: Runs tests for all targets</li>
<li><kbd>--all-features</kbd>: Runs tests with all features</li>
<li><kbd>--examples</kbd>: Tests all examples</li>
<li><kbd>--jobs &lt;N&gt;</kbd>: Runs tests in multiple jobs, which is useful if the test uses one database instance only and you want to run tests sequentially to avoid a situation where one test affects the results of another<br/></li>
</ul>
<p>Now we are ready to bootstrap a CI tool and configure it for building a microservice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CI and CD tools</h1>
                
            
            
                
<p>In this section, we will discuss systems for CI, and bootstrap a CI server instance with a build agent using Docker Compose. But first, let's look at some popular CI products and their delivery capabilities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">TravisCI</h1>
                
            
            
                
<p>TravisCI is the most popular CI service for open source projects, because it provides a free plan for such projects and is integrated well with GitHub. To use it, all you have to do is add the <kbd>.travis.yml</kbd> file to the root of repository of your project. It supports Rust out of the box.</p>
<p>With TravisCI, you can build your projects in either Linux or macOS environments. Let's write a simple example of a <kbd>.travis.yml</kbd> file. The first part of this file is a building matrix declaration:</p>
<pre>language: rust<br/>cache: cargo<br/>matrix:<br/>  include:<br/>    - os: linux<br/>      rust: stable<br/>      env: TARGET=x86_64-unknown-linux-gnu<br/>    - os: linux<br/>      rust: nightly<br/>      env: TARGET=x86_64-unknown-linux-gnu<br/>    - os: osx<br/>      rust: stable<br/>      env: TARGET=x86_64-apple-darwin<br/>    - os: osx<br/>      rust: nightly<br/>      env: TARGET=x86_64-apple-darwin</pre>
<p>We chose the Rust language with caching for cargo to speed up building updates. Also, we declared a matrix of environments. TravisCI automatically prepared the Rust environment for us with four variants: <kbd>linux</kbd> with a <kbd>stable</kbd> compiler, <kbd>linux</kbd> with a <kbd>nightly</kbd> compiler, and a pair of <kbd>stable</kbd> and <kbd>nightly</kbd> compiler versions for <kbd>osx</kbd>. For microservices, you often need <kbd>linux</kbd> builds only. Also, we specified targets, but you can use <kbd>musl</kbd> instead of <kbd>gnu</kbd>, for example.</p>
<p>The following code installs extra packages:</p>
<pre>addons:<br/>  apt:<br/>    packages:<br/>      - build-essential<br/>      - libcurl4-openssl-dev<br/>      - libssl-dev</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Also, you can add environment variables that you can use in building and test running:</p>
<pre>env:<br/>  global:<br/>    - APPNAME="myapp"</pre>
<p>Finally, you have to add a script that will be used as the CI script. You can put the <kbd>script</kbd> section with a command directly into <kbd>.travis.yml</kbd> as items to that section, or add a <kbd>jobs</kbd> section that can contain concurrent jobs to run:</p>
<pre>jobs:<br/>  include:<br/>    - name: rustfmt<br/>      install:<br/>        - rustup component add rustfmt<br/>      script:<br/>        - cargo fmt -- --check<br/>    - name: clippy<br/>      install:<br/>        - rustup component add clippy<br/>      script:<br/>        - cargo clippy<br/>    - name: test<br/>      script:<br/>        - cargo build --target $TARGET --verbose<br/>        - cargo test --target $TARGET --verbose</pre>
<p>The <kbd>jobs</kbd> section can also contain an install subsection to provide a list of commands to install extra dependencies for a job.</p>
<p>Now you can put this .<kbd>travis.yml</kbd> file into the root of the repository of your project to allow Travis CI to check the pull requests of your project. But remember that you have to pay for private repositories with the TravisCI service, while GitHub allows you to have private repositories for free. You can test your Rust application for Linux and macOS, but there is another service that provides another set of operating systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AppVeyor</h1>
                
            
            
                
<p>AppVeyor is a CI service for Linux and Windows. It's also free for open source projects and provides good integration with GitHub. To start using this service, you have to add an <kbd>appveyor.yml</kbd> file to your project. Let's look at the example configuration:</p>
<pre>os: Visual Studio 2015<br/>environment:<br/>  matrix:<br/>    - channel: stable<br/>      target: x86_64-pc-windows-msvc<br/>    - channel: nightly<br/>      target: i686-pc-windows-msvc<br/>    - channel: stable<br/>      target: x86_64-pc-windows-gnu<br/>    - channel: nightly<br/>      target: i686-pc-windows-gnu</pre>
<p>The configuration looks similar to the configuration for TravisCI. We also created a matrix of builds and will use MSVC and GNU toolchains for stable and nightly compiler versions. After this, we use these values to install the required tools using <kbd>rustup</kbd>:</p>
<pre>install:<br/>  - appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe<br/>  - rustup-init -yv --default-toolchain %channel% --default-host %target%<br/>  - set PATH=%PATH%;%USERPROFILE%\.cargo\bin<br/>  - rustup component add rustfmt<br/>  - rustup component add clippy<br/>  - rustc -vV<br/>  - cargo -vV</pre>
<p>We also installed the <kbd>rustfmt</kbd> and <kbd>clippy</kbd> tools after the <kbd>PATH</kbd> environment variable was updated. Finally, we can build the projects as follows:</p>
<pre>build: false<br/>test_script:<br/>  - cargo fmt -- --check<br/>  - cargo clippy<br/>  - cargo build<br/>  - cargo test</pre>
<p>We set the <kbd>build</kbd> field to <kbd>false</kbd> to prevent the building agent from starting the MSBuild tool, which is not necessary for Rust crates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jenkins</h1>
                
            
            
                
<p>This is a popular CI system created originally for and with Java. Jenkins is an open source product and has no limits on usage. These are both reasons why some growing companies choose this product, and you might too, if you want to customize the build process and want to control costs for CI.</p>
<p>Jenkins offers you two approaches for building applications.The first is running a plain script and the second is using pipeline, the feature that allows you to include a CI script in the root of the repository, like we did with TravisCI and AppVeyor.</p>
<p>Here is an example of the <kbd>pipeline</kbd> configuration that has to be stored in a <kbd>Jenkinsfile</kbd> configuration file in the root of your project if you want to pull this script with a repository automatically and update it using SCM:</p>
<pre>pipeline {<br/>    agent { dockerfile true }<br/>    stages {<br/>        stage('Rustfmt') {<br/>            steps {<br/>                sh "cargo fmt -- --check"<br/>            }<br/>        }<br/>        stage('Clippy') {<br/>            steps {<br/>                sh "cargo clippy"<br/>            }<br/>        }<br/>        stage('Build') {<br/>            steps {<br/>                sh "cargo build"<br/>            }<br/>        }<br/>        stage('Test') {<br/>            steps {<br/>                sh "cargo test"<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The preceding <kbd>pipeline</kbd> configuration means that Jenkins requires Docker to build the attached <kbd>Dockerfile</kbd> and to run all commands for all stages. This feature utilizes Docker containers instead of agents, but you can also connect traditional building agents to a CI server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Demonstration of continuous integration</h1>
                
            
            
                
<p>To create a demonstration, we will use TeamCity CI, developed by JetBrains. This product is similar to Jenkins in some features, but it's simpler to bootstrap and deploy for our demonstration. We will bootstrap our own CI environment and configure our own building tasks for it. TeamCity has a free plan that's enough for building small and medium projects. We will also use a Gogs Git server to have a private SCM server for our building needs. Let's start.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Docker Compose</h1>
                
            
            
                
<p>Create an empty <kbd>docker-compose.yml</kbd> file and add a <kbd>services</kbd> section to it:</p>
<pre>version: '3.1'<br/>services:</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The SCM server</h1>
                
            
            
                
<p>To the <kbd>services</kbd> section, add the SCM server Gogs first:</p>
<pre>git-server:<br/>    image: gogs/gogs<br/>    ports:<br/>        - '10022:22'<br/>        - '10080:3000'<br/>    volumes:<br/>        - ./gogs:/data</pre>
<p>We'll use an official Docker image. We set a persistent volume to keep all created repositories between starts. Also, we forwarded two ports—SSH (from local port <kbd>10022</kbd> to port <kbd>22</kbd> in the container) and HTTP (from local port <kbd>10080</kbd> to port <kbd>3000</kbd> in the container). To upload data with the Git client, we will use the local port, but to use the server from TeamCity, we have to use the port of the container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The CI server</h1>
                
            
            
                
<p>The next service we need is a CI server. We will use the official image of TeamCity:</p>
<pre>teamcity:<br/>    image: jetbrains/teamcity-server<br/>    ports:<br/>        - '8111:8111'<br/>    volumes:<br/>        - ./teamcity/datadir:/data/teamcity_server/datadir<br/>        - ./teamcity/logs:/opt/teamcity/logs</pre>
<p>The container requires two persistent volumes for data and logs. We also forward port <kbd>8111</kbd> of the container to the same local port to connect to the UI with a browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The CI agent</h1>
                
            
            
                
<p>To use the TeamCity server for builds, we need at least one agent. It works as a sibling container in Docker, and we also declare it as a service, but provide the <kbd>SERVER_URL</kbd> environment variable targeted to the CI server we created before:</p>
<pre>agent:<br/>    build: ./images/rust-slave<br/>    environment:<br/>        - SERVER_URL=http://teamcity:8111<br/>    volumes:<br/>        - ./teamcity/agent:/data/teamcity_agent/conf</pre>
<p>There is the official image for an agent, but we don't use it directly here, because we need to add the Rust compiler and extra tools, which is why we build our own image for this service. Also, we need to provide a persistent volume to it to keep the configuration of the running agent that will be connected to the server.</p>
<p>Agents don't need to open ports, because they are non-interactive and don't have any UI. Often, agents are also called slaves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The image</h1>
                
            
            
                
<p>The image for the agent service created from the official image of minimal agent for TeamCity is as follows:</p>
<pre>FROM jetbrains/teamcity-minimal-agent:latest<br/><br/>RUN apt-get update<br/>RUN apt-get install -y build-essential<br/><br/>ENV RUST_VERSION=1.32.0<br/><br/>RUN curl https://sh.rustup.rs -sSf \<br/> | sh -s -- -y --no-modify-path --default-toolchain $RUST_VERSION<br/><br/>ENV PATH=/root/.cargo/bin:$PATH<br/><br/>RUN rustup --version; \<br/> cargo --version; \<br/> rustc --version;<br/><br/>RUN rustup component add rustfmt<br/>RUN rustup component add clippy</pre>
<p class="mce-root"/>
<p>As you can see, we installed the Rust compiler and added <kbd>rustfmt</kbd> and <kbd>clippy</kbd> as components with <kbd>rustup</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Gogs</h1>
                
            
            
                
<p>Let's configure the SCM server and push a tiny microservice to it:</p>
<ol>
<li> Start up Docker Compose from our CI services bundle with this command:</li>
</ol>
<pre><strong>docker-compose up</strong></pre>
<ol start="2">
<li>When all services are started, open <kbd>http://localhost:10080</kbd> in a browser to configure the Gogs server. You will see the following configuration form:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ccf28dc3-b980-4084-9849-843466357026.png" style="width:42.92em;height:28.67em;"/></p>
<ol start="3">
<li>Set SQLite3 in the Database Type field (because we won't spend time configuring an external database), leave the default values in the other fields, and hit the Install Gogs button. It will redirect you to port <kbd>3000</kbd>, but recall that, it's available inside Docker only and you have to open the previous URL again.</li>
</ol>
<ol start="4">
<li>Click the Register link and register a new account:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0429244c-da63-424f-9552-4dc6886b47da.png"/></p>
<p>I set <kbd>developer</kbd> as the username and <kbd>secret</kbd> as the password. We need these credentials to both upload our code to a created repository and to pull it with CI.</p>
<ol start="5">
<li>Create a new private repository with the <strong>+</strong> sing button and call it <kbd>microservice</kbd>. Now you can upload the code to this repository using <kbd>http://localhost:3000/developer/microservice.git</kbd>. If you use the code of this chapter from the repository of the book, you can use the microservice crate in that folder, but you have to initialize it and add the remote server with these commands:</li>
</ol>
<p> </p>
<pre style="padding-left: 60px"><strong>git init</strong><br/><strong>git add -A</strong><br/><strong>git commit</strong><br/><strong>git remote add origin http://localhost:10080/developer/microservice.git</strong><br/><strong>git push origin master</strong></pre>
<p style="padding-left: 60px">It's a trivial command, but one to remember if you forget something.</p>
<ol start="6">
<li>Enter the username and password we set before, and you have got an empty repository in SCM:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8161f652-1a7b-41c5-bfb4-4a0028f8e5fd.png"/></p>
<p>Now we can configure CI to get this code for building.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring TeamCity</h1>
                
            
            
                
<ol>
<li>First, open the <kbd>http://localhost:8111</kbd> URL, where we bind the CI server in a browser and pass the first steps of configuring the TeamCity instance. Set a DataDirectory the same as we attached as a persistent volume (default value):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d85f4f1a-f522-4a23-a128-3c704e1813e4.png"/></p>
<ol start="2">
<li>Click the Proceed button, and in the next step, create a database of the HSQLDB type. There are options for other external databases, and it's better to use them for production, but for testing it's enough to keep all data in the <kbd>data</kbd> directory of TeamCity:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/598cdc1d-cbdc-48a7-9add-518bf6a1cf90.png"/></p>
<p class="mce-root"/>
<ol start="3">
<li>Create an administrator account that you will use to access the TeamCity UI:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/067319fe-d838-4473-9927-81e333c478a0.png" style="width:33.58em;height:32.58em;"/></p>
<p>I used the <kbd>admin</kbd> value for username and the <kbd>secret</kbd> value for the password fields. Now it takes time to initialize and start, but after the initialization process is finished, we can add external agents.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authorizing agents</h1>
                
            
            
                
<p>Since we have an agent in a sibling container, it already tried to connect to a server, but we have to authorize it because if an agent is authorized it can steal the source code of the microservices. Click the Authorize button in the Unauthorized tab of the Agents page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7301472-221c-4f91-b135-a6b543466afe.png"/></p>
<p>When the agent is authorized, you can see it in the Connected tab and can control it. You can also add more sibling workers to the Docker Compose configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project</h1>
                
            
            
                
<p>Now we have connected agents and can create a project that will build our microservice. Click the Create Project button on the Projects page and fill in the form with the parameters of the repository that we want to build:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f7a643b6-3c32-43c2-a712-6b226c9ff5d1.png"/></p>
<p>We set the repository URL to <kbd>http://git-server:3000/developer/microservice.git</kbd>, because the CI server instance works inside a virtual network and can connect to other services by the names and original ports exposed by Docker images.</p>
<p>When you click the Proceed button, you can specify the name of the project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/11d445ab-73ce-4ec0-9540-13117c933b42.png"/></p>
<p>Click Proceed again, and you have an empty project that we can configure with steps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building steps for Rust</h1>
                
            
            
                
<p>On the project's page, click the link to configure build steps manually and add a new build step to our project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9a64eb3f-638d-416c-871d-9d88c1ec88c5.png"/></p>
<p>The first step, called <kbd>Format Check</kbd>, is a Command Line that runs Custom script with a single command: <kbd>cargo fmt -- --check</kbd>. This command will check the style of the code with the <kbd>rustfmt</kbd> tool. Add the next build step, called Build (you can use your own name), with the <kbd>cargo build</kbd> command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e9f27cdc-db76-4420-a843-960daf262e9a.png"/></p>
<p>Now, if you click the Build Steps menu item, you will see the steps we created:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ecd0add2-e44f-4bd5-bc87-53ae654a18ac.png"/></p>
<p>Now you can start this building process by clicking the Run button, as shown in the preceding screenshot. It will immediately start building with the agent container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building with CI</h1>
                
            
            
                
<p>If you enter into the first building task that appears, you will see the building is in progress:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/97ce1689-c841-4d8a-a5fe-bf1b16fc96a9.png"/></p>
<p>As you can see, the first step is finished successfully and the <kbd>cargo build</kbd> command is in progress. When it is complete, the status of this building task will be changed to success. It works!</p>
<p>Also, projects by default create a trigger to run the build process when you push new changes to the repository:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/be6c5d33-f9cd-47b1-a376-f6b8b7040ca7.png"/></p>
<p>I pushed one extra commit to a repository and the building process started. As you can see in the preceding screenshot, an estimated time for building has appeared. According to the previous build, it's estimated at 15 minutes, but actually it takes only 40 seconds, because agents keep a building cache.</p>
<p>As an experiment, you can add more steps that test and check the code with <kbd>clippy</kbd>, and also add steps to upload the binary to servers.</p>
<p>You can also configure Jenkins to work in a similar way, but it takes a little more time to configure.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we got acquainted with CI of Rust microservices. If you haven't used Rust to create local programs before, this may seem like a new topic to you. First, we discussed the purposes of CI and CD. Also, we looked at the benefits of container orchestration tools.</p>
<p>After this, we learned about some tools for checking the quality of the code—<kbd>rustfmt</kbd>, <kbd>clippy</kbd>, and <kbd>rustfix</kbd>. Then we figured out how to configure them.</p>
<p>Next, we studied examples of using some popular CI services and servers—TravisCI, AppVeyor, and Jenkins. Then, we bootstrapped an example with TeamCity CI and its agent, and used a private Git server to push our Rust project to be built with CI. Lastly, we configured the building process of a microservice and checked it with UI.</p>
<p>In the next chapter, we have a look at serverless applications: what is it, and how to write them using Rust. Amazon Web Services offers AWS Lambda product for hosting serverless applications and had started to support Rust officially.</p>


            

            
        
    </body></html>