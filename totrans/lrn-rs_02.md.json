["```rs\nlet x = 1; \n```", "```rs\nlet mut x = 1; \n```", "```rs\nlet x = 1i32; \n```", "```rs\nlet pi = 3.14f32; \n```", "```rs\nlet pi = 3.14f64; \n```", "```rs\nlet pi: f32 = 3.14; \n```", "```rs\nlet sint = 10i32; \n```", "```rs\nlet usint = 10u32; \n```", "```rs\nlet sint: i32 = 10; \n```", "```rs\nconst PI: f32 = 3.1415927; \n```", "```rs\nstatic MY_VARIABLE: i32 = 255; \n```", "```rs\nlet myName = \"my name\"; \n```", "```rs\nlet mut myStringOne = \"This is my first string \".to_owned(); \nlet myStringTwo = \"This is my second string. \"; \nlet myStringThree = \"This is my final string\"; \nmyStringOne = myStringOne + myStringTwo + myStringTwo + myStringThree + myStringTwo; \n```", "```rs\nlet mut myString = String::new(); \n```", "```rs\nlet mut ynwa = String::with_capacity(23); \nynwa.push_str(\"You'll never walk alone\"); \n```", "```rs\nlet mut ynwa = \"You'll never walk alone\".to_owned(); \n```", "```rs\nlet homeTeam = \"Liverpool\"; \n```", "```rs\nlet homeTeam = \"Liverpool\"; \nlet result = \" beat \"; \nlet awayTeam = \"Manchester United\"; \nlet theString = homeTeam + result + awayTeam; \n```", "```rs\nfn main() { \n    let homeTeam = \"Liverpool\"; \n    let result = \" beat \"; \n    let awayTeam = \"Manchester United\"; \n\n    let fullLine = homeTeam.to_owned() + result + awayTeam; \n\n    println!(\"{}\", fullLine); \n} \n```", "```rs\nfn main() { \n    let home_team = \"Liverpool\"; \n    let result = \" beat \"; \n    let away_team = \"Manchester United\"; \n\n    let full_line = format!(\"{}{}{}\", home_team, result, away_team); \n\n    println!(\"{}\", full_line); \n} \n```", "```rs\nfn main() { \n    let home_team = \"Liverpool\"; \n    let result = \" beat \"; \n    let away_team = \"Manchester United\"; \n    let home_score = '3'; // single character \n    let away_score = \"-0\"; \n\n    let mut full_line = format!(\"{}{}{} \", home_team, result, away_team); \n\n    // add the character to the end of the String     \n    full_line.push(home_score); \n\n    // add the away score to the end of the String \n    full_line.push_str(away_score); \n\n    println!(\"{}\", full_line); \n} \n```", "```rs\nlet my_score = 10i32; \nlet mut final_score : u32 = 100; \nlet final_score = my_score as u32; \n```", "```rs\nlet pi = 3.14; \nlet new_pi = pi as i32; // new_pi = 3 \n```", "```rs\nlet n = 240.51; \nlet n_as_int = n as i8; // n_as_int = 0   \n```", "```rs\nlet my_home = \"Newton-le-Willows\"; \nlet my_number = my_home as u32; // cannot convert &str to u32 \n```", "```rs\nlet s   = String::from(\"Richmond\");   \n```", "```rs\n\nlet s   = String::from_utf8(vec!(33, 34)).expect(\"UTF8 decoding failed);   \n```", "```rs\nlet s   = String::with_capacity(10);   \n```", "```rs\nlet s = \"A String\".to_owned();\nlet slice = s.as_bytes();\n```", "```rs\nlet mut s = \"A String\".to_owned();\ns.insert(2, 'S');\n// s = \"A SString\"\n```", "```rs\nlet s = \"A String äö\";\n// s.len() => 13\n```", "```rs\nlet s1 = \"\".to_owned();\nlet s2 = \"A String\".to_owned();\n// s1.is_empty() => true\n// s2.is_empty() => false\n```", "```rs\nlet s1 = \"Hellö World\";\n// s1.is_char_boundary(5) => false\n// s1.is_char_boundary(6) => true\n```", "```rs\nT a = new T(); \n```", "```rs\nfn generic_function<T>(a: T, b: T) \n```", "```rs\nlet my_array = [\"Merseybus\", \"Amberline\", \"Crosville\", \"Liverbus\", \"Liverline\", \"Fareway\"]; \n```", "```rs\nlet mut my_array_two: [i32; 4] = [1, 11, 111, 1111]; \nlet mut empty_array: [&str; 0] = []; \n```", "```rs\nlet number = [111; 5]; \n```", "```rs\nlet mut my_vector: Vec<f32> = Vec::new(); // explicit definition \n```", "```rs\nlet mut my_alt_vector = vec![4f32, 3.14, 6.28, 13.54, 27.08]; \n```", "```rs\nlet mut my_ids: Vec<i64> = Vec::with_capacity(30); \n```", "```rs\nlet my_vec: Vec<u64> = (0..10).collect(); \n```", "```rs\nfn main() { \n    let mut my_vec : Vec<i32> = (0..10).collect(); \n    println!(\"{:?}\", my_vec);  \n    my_vec.push(13); \n    my_vec.push(21); \n    println!(\"{:?}\", my_vec);  \n    let mut twenty_one = my_vec.pop(); // removes the last value \n    println!(\"twenty_one= {:?}\", twenty_one);  \n    println!(\"{:?}\", my_vec);  \n} \n```", "```rs\nlet my_slice = &my_vec[1..5];  \n```", "```rs\nfn main() \n{ \n    let add = add_values(3, 5);  \n    println!(\"{:?}\", add); \n} \n\nfn add_values(a: i32, b: i32) -> i32 \n{ \n    a + b \n} \n```", "```rs\nfn add_values(a: i32, b: i32) -> i32 \n```", "```rs\nfn my_function(a: &i32, b: &i32) -> i32 \n```", "```rs\nlet ref_num = &2; \nlet deref_num = *ref_num; \n// deref_num = 2 \n```", "```rs\nlet mut var = 4; \nlet ref_to_var = &var; \nlet ref second_ref = var; \nlet ref mut third_ref = var; \n```", "```rs\nfn main()  \n{ \n    // first create a couple of arrays - these will be used \n    // for the vectors \n    let line1: [i32; 4] = [4, 2, 3, 3]; \n    let line2: [i32; 4] = [3, 4, 5, 7]; \n    let line3: [i32; 4] = [2, 9, 6, 2]; \n    let line4: [i32; 4] = [5, 7, 2, 4]; \n\n    // create two holding arrays and assign \n    // we are creating an array of references \n    let array_one = [&line1, &line3, &line4, &line2]; \n    let array_two = [&line2, &line1, &line3, &line4]; \n\n    // let's do the multiply \n    // we are passing in a ref array containing ref arrays \n    let result = matrix_multiply(&array_one, &array_two); \n    println!(\"{:?}\", result); \n} \n\nfn matrix_multiply(vec1: &[&[i32;4];4], vec2: &[&[i32;4];4]) -> [[i32; 4];4] \n{ \n    // we need to create the arrays to put the results into \n    let mut result = [[0i32; 4]; 4]; \n\n    // loop through the two vectors \n    for vone in 0..4 \n    { \n       for vtwo in 0..4 \n       { \n          let mut sum = 0; \n          for k in 0..4 \n          { \n               sum += vec1[vone][k] * vec2[k][vtwo]; \n          } \n          result[vone][vtwo] = sum; \n       } \n    } \n    result \n} \n```", "```rs\nfn matrix_multiply(vec1: &[&[i32;4];4], vec2: &[&[i32;4];4]) -> [[i32; 4];4] \n```"]