- en: '*Chapter 4*: Understanding WebAssembly Binary Toolkit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler chain converts Rust code into WebAssembly binary. But the
    generated binaries are both size- and performance-optimized. It is difficult to
    understand, debug, and validate binary code (it is a bunch of hexadecimal numbers).
    Converting WebAssembly binary back into the original source code is very difficult.
    **WebAssembly Binary Toolkit** (**WABT**) helps to convert WebAssembly binary
    into a human-readable format, such as the **WebAssembly text** (**WAST**) format
    or C-native code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Native code here does not refer to the original source of truth; instead, it
    refers to C-native code that the machine interprets.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly Binary Toolkit is abbreviated as WABT and pronounced as "*wabbit*."
    WABT provides a set of tools for converting, analyzing, and testing WebAssembly
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore WABT and how it helps to convert WebAssembly
    binary into various formats and why it is useful. We will cover the following
    main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with WABT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting WAST into WASM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting WASM into WAST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting WASM into C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting WAST into JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a few other tools provided by WABT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with WABT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first install WABT and then explore the various options provided by the
    WABT tool.
  prefs: []
  type: TYPE_NORMAL
- en: Installing WABT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install WABT, first clone the repository from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We use the `--recursive` flag here as it ensures that after the clone is created,
    all submodules within the repository (such as `test-suite`) are initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the cloned repository, create a folder named `build`, and then go inside
    the `build` folder. This is where we will generate the binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to install CMake. Refer to [https://cmake.org/download/](https://cmake.org/download/)
    for more instructions.
  prefs: []
  type: TYPE_NORMAL
- en: To build the binary with CMake, we first need to generate the build system.
    We specify the source to the `cmake` command. CMake will then build trees and
    generate a build system for the specified source, using the `CMakeLists.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Linux or macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to generate the project build system, we run the `cmake` command with
    the path to the `wabt` folder. The `cmake` command accepts both a relative and
    absolute path. We are using the relative path here (`..`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build the project using cmake build. `cmake build` makes use of
    the generated project binary tree to generate the binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake build` command requires the `<dir>` option to generate the binaries.
    The cmake build command accepts the flags listed in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Install CMake and Visual Studio (>= 2015). Then, run `cmake` inside the `build`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `[config]` parameter can be either `DEBUG` or `RELEASE`.
  prefs: []
  type: TYPE_NORMAL
- en: The `[install directory]` parameter should be the folder where you want to install
    the binaries.
  prefs: []
  type: TYPE_NORMAL
- en: The `[generator]` parameter should be the type of project you want to generate,
    for example, Visual Studio 14 2015\. You can see the list of available generators
    by running `cmake –help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will build and install all the required executables inside the folder
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you have successfully installed all the WABT tools, you can either add
    them to your path or call them from their path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `build` folder contains the following binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That sure is a huge list of binaries. Let''s see what each one is capable of,
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wat2wasm` – This tool helps to convert the WAST format into a **WebAssembly
    module** (**WASM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wat-desugar` – This tool reads a file in a WASM S-expression and formats it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wast2json` – This tool validates and converts WAST format into JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm2wat` – This tool converts WASM into WAST format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm2c` – This tool converts WASM into C-native code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-validate` – This tool validates whether the given WebAssembly is constructed
    as per the specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-strip` – As we saw in the previous chapter, WASM consists of various
    sections. The custom section in the module is used only for extra meta-information
    about the module and the tools used in its generation. `wasm-strip` removes the
    custom section from the WASM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-opcodecnt` – This tool reads the WASM and counts the use of opcode instructions
    in the WebAssembly Module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-objdump` – This tool helps to print information about a WASM binary.
    It is similar to objdump ([https://en.wikipedia.org/wiki/Objdump](https://en.wikipedia.org/wiki/Objdump))
    but for WebAssembly Modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-interp` – This tool decodes and runs a WebAssembly binary file using
    a stack-based interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-decompile` – This tool helps to decompile a WASM binary into readable
    C-like syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the testing binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hexfloat_test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spectest-interp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wabt-unittests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explore various supported proposals by WABT at [https://github.com/WebAssembly/wabt#supported-proposals](https://github.com/WebAssembly/wabt#supported-proposals).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have built WABT and generated the tools. Now, let's explore the most important
    and useful tools.
  prefs: []
  type: TYPE_NORMAL
- en: Converting WAST into WASM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wat2wasm` helps to convert the WAST format into WASM. Let''s take it for a
    spin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `wabt-playground` and go into the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `.wat` file called `add.wat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following contents to `add.wat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the WAST format into WASM using the `wat2wasm` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This generates a valid WebAssembly binary in `add.wasm` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the size of the generated binary is 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'WABT reads the WAST format file (`.wat`) and converts it into a WebAssembly
    module (`.wasm`). `wat2wasm` first validates the given file (`.wat`) and then
    converts it into a `.wasm` file. To check the various options supported by `wat2wasm`,
    we can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we need to generate the WASM file in a different name, we can use the `-o`
    option with the filename. For example, `wat2wasm add.wat -o add.wasm` will generate
    `add.wasm`.
  prefs: []
  type: TYPE_NORMAL
- en: '`wat2wasm` also provides verbose output that clearly explains how the WASM
    is structured. In order to see the structure of the WASM, we run it with the `-v`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding output is a detailed description of the binary generated. The
    leftmost seven numbers are the index, followed by a colon. The next two characters
    are the actual binary code, and then comments. The comment describes what the
    binary (op)code does.
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines specify `wasm_magic_header` and its version. The next segment
    is the `Type` section. The `Type` section defines the section ID, followed by
    the size of the section, and then the number of type blocks. In our case, we have
    only one type. The `type 0` section defines the `type` signature of the `add`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `Function` section. In the `Function` section, we have the
    section ID, followed by the section size, and then the number of functions. The
    function section does not have the function body. The function body is defined
    in the `Code` section.
  prefs: []
  type: TYPE_NORMAL
- en: While generating the binary, we can enable the compiler to include the new and
    shiny features and disable various existing features using the appropriate `enable-*`
    and `disable-*` options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also check the online version at [https://webassembly.github.io/wabt/demo/wat2wasm/](https://webassembly.github.io/wabt/demo/wat2wasm/)
    to explore the WABT tools.
  prefs: []
  type: TYPE_NORMAL
- en: We have converted WAST into WASM. Now, let's explore how to convert WASM into
    WAST with `wasm2wat`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting WASM into WAST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, for debugging or understanding, we need to know what the WASM is
    doing. WABT has a `wasm2wat` converter. It helps to convert WASM into WAST format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Running the previous command will convert `add.wasm` back into WAST format and
    print the output in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to save it as a file, you can do so by using the `-o` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a `new_add.wat` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the various options supported by `wasm2wat`, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both `wasm2wat` and `wat2wasm` have almost identical options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous command with the `-v` option prints the AST syntax of
    the WAST format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The entire code block is wrapped inside `BeginModule` and `EndModule`. `BeginModule`
    includes the version of the WebAssembly binary.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the BeginModule, the `BeginTypeSection` starts with the section index
    of type (that is, `7`), followed by `OnTypeCount`, the number of types defined.
    Then, we have the actual definition of the type with `OnType`. We end the type
    section with `EndTypeSection`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the `Function` section marked by `BeginFunctionSection` and `EndFunctionSection`.
    This contains the function count (`OnFunctionCount`) and the function definition
    (`OnFunction`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the code section, which holds the actual body of the function.
    The code section begins and ends with `BeginCodeSection` and `EndCodeSection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, WASM may contain debug names. We can ignore them using the `--no-debug-names`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note `BeginCustomSection` and `EndCustomSection`. Compare it with the previous
    output; it is missing `NamesSection`. Now, let's check out the various options
    provided by the `wasm2wat` tool.
  prefs: []
  type: TYPE_NORMAL
- en: -f or --fold-exprs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a big fan of functional programming, this is one of the coolest options available.
    It folds over the expression; that is, it converts expression 1 >> expression
    2 >> operation into operation >> expression 1 >> expression2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see that in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a WAST file called `fold.wat` and fill it with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s first convert it into WASM using `wat2wasm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates `fold.wasm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, convert the WASM into the WAST format using `wasm2wat` and pass in the
    `-f` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a file called `converted_fold.wat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `i32.const 1` (expression 1) and `i32.const 2` (expression
    2) and then doing `i32.add` (operation), this generates an output, `i32.add` (operation),
    followed by `i32.const 1` (expression 1) and `i32.const 2` (expression 2).
  prefs: []
  type: TYPE_NORMAL
- en: While generating `wat`, we can enable the compiler to include the new and shiny
    features and disable various existing features using the appropriate `enable-*`
    and `disable-*` options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We have converted WASM into WAST. Now, let's explore how to convert WASM into
    native code (C) using `wasm2c`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting WASM into C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WABT has a `wasm2c` converter that converts WASM into C source code and a header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `simple.wat` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following contents to `simple.wat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`wat` here defines a `uanswer` function that adds `22` and `20` to give `42`
    as the answer. Let''s create a WebAssembly binary using `wat2wasm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the `simple.wasm` binary. Now, convert the binary into C code
    using `wasm2c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This generates `simple.c` and `simple.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both `simple.c` and `simple.h` might look huge. Remember this is an autogenerated
    file and it includes all the necessary headers and configuration needed for the
    program to run.
  prefs: []
  type: TYPE_NORMAL
- en: simple.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`simple.h` (the header file) includes standard boilerplate for the header.
    It also includes the `_cplusplus` condition to prevent name mangling in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we have used `i32.const` and `i32.add`, the header file also imports `stdint.h`.
    It includes `wasm-rt.h`. The `wasm-rt.h` header imports the necessary WASM runtime
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can specify a module prefix. The module prefix is useful when using
    multiple modules. Since we only have one module, we use an empty prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have some typedefs for the various number formats that WASM supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: simple.c
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`simple.c` provides the actual C code generated from the WASM binary. The generated
    code has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll require the following list of libraries to use in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the trap that is called when an error occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define `PROLOGUE`, `EPILOGUE`, and `UNREACHABLE_TRAP`, which are called
    before the start of execution, after execution, and when the execution meets an
    unreachable exception, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WASM_RT_MAX_CALL_STACK_DEPTH` is the maximum depth of the stack. By default,
    the value is `500` but we can change it. Note that if it reaches the limit, then
    an exception is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the memory manipulations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MEMCHECK` checks for memory. The `DEFINE_LOAD` and `DEFINE_STORE` blocks define
    how to load and store a value in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a bunch of load and store operations for various data types
    that we have in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we define various functions that each of the data types supports, such
    as `TRUNC`, `DIV`, and `REM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we initialize the function types using `func_types`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers the (result i32) type in the WASM provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we initialize `globals`, `memory`, `table`, and `exports`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we implement the actual function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function is static. It calls `FUNC_PROLOGUE` before the execution. Then,
    it creates two variables (both are unsigned u32). Then, we define the value of
    both the variables, `22` and `20`, respectively. After that, we add them both.
    Once the execution is complete, we call `FUNC_EPILOGUE`. Finally, we return the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since we have not exported anything in `wat`, `init_exports` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: We have converted WASM into C. The generated code is slightly different from
    the original code. Let's explore how to convert WAST into JSON with `wast2json`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting WAST into JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wast2json` tool reads the WAST format and parses it, checks for errors,
    and then converts WAST into the JSON file. It generates a JSON and WASM file associated
    with the WAST file. Then, it links the WASM inside the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the various options supported by `wast2json`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These are the frequently used WABT tools. There are a few other tools provided
    by WABT that help with debugging and understanding WASM better.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a few other tools provided by WABT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the converters, WABT also provides a few tools that help us
    to understand WASM better. In this section, let''s explore the following tools
    provided by WABT:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-objdump`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-strip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-validate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-interp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wasm-objdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object code is nothing more than a sequence of instructions or statements in
    the computer language. Object code is what the compiler produces. The object code
    is then collected together and then stored inside the object file. The object
    file is the metadata holder for linking and debugging information. The machine
    code in the object file is not directly executable, but it provides valuable information
    when debugging and also helps with linking.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`objdump` is the tool that is available in POSIX systems that provides a way
    to disassemble the binary format and print the assembly format of the code that
    is running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wasm-objdump` tool provides the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At least one of the following options should be provided to the `wasm-objdump`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-h` option prints all the available headers in WASM. For example, in our
    add example (`add.wasm`), we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have three sections available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-d` option prints the actual body of the function available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It dissembles the assembly function and prints only the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-x` option prints the section details of the WebAssembly binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-s` option prints the contents of all the sections that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: wasm-strip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The custom section in a WASM holds information about the names of the function
    and all locals defined in the WASM. It may contain information about the build
    and how the WASM was created. This is additional information. It bloats the binary
    and does not add any functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can strip the custom section to trim the binary size using the `wasm-strip`
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `wat` file with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, convert that into a WASM with `wat2wasm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `--debug-names` option provided generates the custom section and adds it
    to the binary generated.
  prefs: []
  type: TYPE_NORMAL
- en: The previous command generates a `simple.wasm` file and it is 51 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s remove the custom section from the binary using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, it removed 21 bytes of unnecessary information. Some WASM generators
    add the custom section for a better debugging experience but when deploying in
    production, we do not need the custom section. Use `wasm-strip` to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: wasm-validate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can validate the WASM using `wasm-validate`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `error.wasm` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run `wasm-validate` to check whether the WASM is valid or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `wasm-validate` tool provides the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read a file in the WebAssembly binary format and validate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: wasm-interp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wasm-interp` reads a file in the WebAssembly binary format and runs it in
    a stack-based interpreter. The `wasm-interp` tool parses the binary file and then
    type checks it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The last five lines are how the stack interpreter executes the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wasm-interp` tool provides the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: WABT provides a list of tools that make WASM easier to understand, debug, and
    convert into various human-readable formats. It is one of the most important toolkits
    that allows developers to explore the WASM better.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what WABT is and how to install and use various tools
    provided by it. The WABT tool is very important in the WebAssembly ecosystem as
    it provides an easy option to convert non-readable, compact binaries into readable,
    expanded source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore various sections inside the WASM.
  prefs: []
  type: TYPE_NORMAL
