- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Functional programming has developed design patterns just like object-oriented
    or other communities. These patterns, unsurprisingly, make use of functions as
    a central concept. They also emphasize something called the **single responsibility
    principle**. The single responsibility principle states that program's logical
    components should do one thing and do that one thing well. In this chapter, we
    will focus on a few very common patterns. Some of these concepts are so simple that
    they counter-intuitively become harder to explain. In these cases, we will make
    use of various examples to demonstrate how a simple concept can exhibit complex
    behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程已经发展出了类似于面向对象或其他社区的设计模式。这些模式，不出所料，利用函数作为核心概念。它们还强调了一个称为**单一职责原则**的概念。单一职责原则指出，程序的逻辑组件应该只做一件事，并且要做好这件事。在本章中，我们将关注几个非常常见的模式。其中一些概念非常简单，以至于它们反直觉地变得难以解释。在这些情况下，我们将使用各种示例来展示一个简单的概念如何表现出复杂的行为。
- en: 'In this chapter, you will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将执行以下操作：
- en: Learn to recognize and use functors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习识别和使用函子
- en: Learn to recognize and use monads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习识别和使用单子
- en: Learn to recognize and use combinators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习识别和使用组合子
- en: Learn to recognize and use lazy evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习识别和使用惰性求值
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要一个较新的 Rust 版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节的 `README.md` 文件中也包含了具体的安装和构建说明。
- en: Using the functor pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函子模式
- en: 'A functor is approximately the inverse of a function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函子大致是函数的逆：
- en: A function defines a transformation, accepts data, and returns the result of
    the transformation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数定义了一个转换，接受数据，并返回转换的结果
- en: A functor defines data, accepts a function, and returns the result of the transformation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子定义数据，接受一个函数，并返回转换的结果
- en: 'A simple example of a functor is the Rust vector and its accompanying `map`
    function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的函子例子是 Rust 向量和其伴随的 `map` 函数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Functors are often thought of as only the `map` function, due to the rules
    of what constitutes a functor or not. The preceding common case is what''s called
    a **structure-preserving map**. Functors do not need to be structure-preserving.
    For example, take the very similar case of a map implemented for a set, as shown
    in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构成函子或非函子的规则，函子通常被认为只是 `map` 函数。前面提到的常见情况被称为**结构保持映射**。函子不需要是结构保持的。例如，考虑以下代码中为集合实现的类似映射情况：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We see here that the resulting set is smaller than the original set due to
    collisions. This mapping still satisfies the properties of a functor. The defining
    properties of a functor are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，由于冲突，结果集比原始集小。这个映射仍然满足函子的性质。函子的定义性质如下：
- en: A collection of objects, `C`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组对象，`C`
- en: A mapping function that will transform objects in `C` into objects in `D`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将 `C` 中的对象映射到 `D` 中的对象的映射函数
- en: 'The preceding `Set` map satisfies both the first and second property, and is
    therefore a proper functor. It also demonstrates how data can be transformed into
    a differently shaped structure through a functor. Using a little imagination,
    we may also consider the case where each mapped value may produce multiple outputs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Set` 映射满足第一和第二个性质，因此是一个合适的函子。它还展示了如何通过函子将数据转换成不同形状的结构。发挥一点想象力，我们还可以考虑每个映射值可能产生多个输出的情况：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Technically speaking, this last case is not a normal functor, but rather a contravariant
    functor. All functors are covariant. The distinction between covariance and contravariance
    is not important for our purposes, so we will leave that topic to only the most
    curious readers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度讲，这个最后的例子不是一个正常的函子，而是一个逆变函子。所有函子都是协变的。协变与逆变之间的区别对我们来说并不重要，所以我们把这个问题留给最好奇的读者。
- en: 'As a final definition by example, we should note that the input and output
    of a functor map need not be of the same type. For example, we can map from a
    vector to a `HashSet`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通过例子给出的最终定义，我们应该注意函子的输入和输出不需要是同一类型。例如，我们可以从向量映射到`HashSet`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To give a non-trivial example of how the functor pattern could be used, let''s
    look at webcams and AI. Modern AI facial recognition software is capable of identifying
    human faces in pictures and even visible emotional states. Let''s imagine an app
    that connects to a webcam and processes the input with a filter. Here are some
    type definitions for the program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出一个非平凡的例子来说明函子模式如何使用，让我们看看网络摄像头和AI。现代AI面部识别软件能够在图片中识别人类面孔，甚至可见的情绪状态。让我们想象一个连接到网络摄像头并使用过滤器处理输入的应用程序。以下是程序的一些类型定义：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the `WebCamera` type, we will implement two functors. One functor, `map_emotion`,
    will map emotions to other emotions. Maybe this could be used to add emojis to
    the text chat. The second contravariant functor, `flatmap_emotion`, maps emotions
    to zero, or more filters. These are animations or effects that can be applied
    back onto the web camera field of view:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WebCamera`类型上，我们将实现两个函子。一个函子，`map_emotion`，将情绪映射到其他情绪。这可能被用来向文本聊天添加表情符号。第二个协变函子，`flatmap_emotion`，将情绪映射到零个或多个过滤器。这些是可以应用到网络摄像头视野中的动画或效果：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use the functors, the programmer supplies which emotions map to which filters.
    The complex AI and effects can be easily modified due to the encapsulation provided
    by the functor pattern:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函子，程序员需要提供哪些情绪映射到哪些过滤器。由于函子模式提供的封装，复杂的AI和效果可以很容易地修改：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the monad pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子模式
- en: 'A monad defines `return` and `bind` operations for a type. The `return` operation
    is like a constructor to make the monad. The `bind` operation incorporates new
    information and returns a new monad. There are also several laws that monads should
    obey. Rather than quote the laws, we''ll just say that monads should behave well
    when daisy chained like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单子为一种类型定义了`return`和`bind`操作。`return`操作就像一个构造函数来创建单子。`bind`操作结合新的信息并返回一个新的单子。单子还应遵守一些定律。我们不会引用这些定律，只是说单子应该像以下这样在链式操作中表现良好：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In Rust, there are several semi-monads that appear in standard libraries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，标准库中有几个半单子：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the normal `Option` constructors, `Some` or `None`, take the
    place of the monadic naming convention, `return`. There are two semi-monads implemented
    here, one associated with `and_then`, and the other with `or_else`. Both of these
    correspond to the monadic `bind` naming convention for the operator responsible
    for incorporating new information into a new monad return value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，正常的`Option`构造函数，`Some`或`None`，取代了单子的命名约定，即`return`。这里实现了两个半单子，一个与`and_then`相关联，另一个与`or_else`相关联。这两个都对应于单子的`bind`命名约定，用于将新信息结合到新的单子返回值中。
- en: 'Monadic `bind` operations are also polymorphic, meaning they should permit
    returning monads of different types from the current monad. According to this
    rule, `or_else` is not technically a monad; hence it is a semi-monad:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单子的`bind`操作也是多态的，这意味着它们应该允许从当前单子返回不同类型的单子。根据这个规则，`or_else`在技术上不是一个单子；因此它是一个半单子：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Monads were originally developed to express side-effects in purely functional
    languages. Isn't that a contradiction—pure with side-effects?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单子最初是为了在纯函数式语言中表达副作用而开发的。这不是一个矛盾——纯函数式语言中的副作用？
- en: The answer is *no* if the effects are passed as input and output through pure
    functions. However, for this to work, every function would need to declare every
    state variable and pass it along, which could become a huge list of parameters.
    This is where monads come in. A monad can hide state inside itself, which becomes
    essentially a larger, more complex function than what the programmer interacts
    with.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果效果作为输入和输出通过纯函数传递，答案是*否*。然而，为了使这可行，每个函数都需要声明每个状态变量并将其传递，这可能会变成一个非常长的参数列表。这就是单子的作用。单子可以隐藏自身内部的状态，这本质上比程序员交互的函数更大、更复杂。
- en: 'One concrete example of side-effect hiding is the concept of a universal logger.
    The monadic `return` and `bind` can be used to wrap state and computation inside
    of a monad that will log all intermediate results. Here is the logger monad:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具体的副作用隐藏的例子是通用日志器的概念。单子的`return`和`bind`可以用来封装状态和计算，在单子中记录所有中间结果。以下是日志单子的示例：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As long as each result implements the `Debug` trait, it can be automatically
    logged with this pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只要每个结果实现了`Debug`特质，就可以使用这种模式自动记录。
- en: 'The monad pattern is also very useful for chaining together code that can''t
    be written in a normal code block. For example, code blocks are always evaluated
    eagerly. If you want to define code that will be evaluated later or in pieces,
    the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe
    code or data that is not evaluated until it is referenced. This is contrary to
    the typical eager evaluation of Rust code that will execute immediately regardless
    of context. Here is the lazy monad pattern:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单子模式对于将无法用正常代码块编写的代码连接起来也非常有用。例如，代码块总是被急切地评估。如果你想定义稍后或在片段中评估的代码，懒单子模式非常方便。懒评估是一个术语，用来描述只有在被引用时才进行评估的代码或数据。这与Rust代码的典型急切评估相反，Rust代码将立即执行，无论上下文如何。以下是一个懒单子模式的例子：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This block defines statements that will be evaluated one at a time after a value
    is supplied, but not before. This may seem a bit trivial since we can do the same
    with a simple closure and code block; however, to make this pattern stick, let's
    consider a more complex case—an asynchronous web server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块定义了在提供值之后、但在之前不会逐个评估的语句。这可能看起来有点微不足道，因为我们可以用简单的闭包和代码块做到同样的事情；然而，为了使这个模式更加牢固，让我们考虑一个更复杂的案例——异步Web服务器。
- en: 'A web server will typically receive a full HTTP request before processing it.
    Choosing what to do with a request is sometimes called **routing**. Then requests
    are sent to a request handler. In the following code, we define a server that
    helps us wrap routes and handlers into a single web server object. Here are the
    type and method definitions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器通常在处理之前会接收到一个完整的HTTP请求。决定如何处理请求有时被称为**路由**。然后请求被发送到请求处理器。在以下代码中，我们定义了一个服务器，它帮助我们将路由和处理器包装成一个单一的Web服务器对象。以下是类型和方法定义：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This type defines `return` and `bind` like operations. However, the `bind` function
    is not polymorphic and the operation is not a pure function. Without these compromises,
    we would need to fight against the Rust type and ownership system; the preceding
    example is not written monadically due to complications when trying to box and
    copy closures. This is an expected trade-off and the semi-monad pattern should
    not be discouraged when appropriate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型定义了`return`和`bind`等操作。然而，`bind`函数不是多态的，操作也不是一个纯函数。如果没有这些妥协，我们就需要与Rust的类型和所有权系统作斗争；前面的例子不是以单子方式编写的，因为在尝试装箱和复制闭包时出现了复杂性。这是一个预期的权衡，当适当的时候，半单子模式不应该被劝阻。
- en: 'To define our web server responses, we can attach handlers like in the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的Web服务器响应，我们可以像以下代码那样附加处理器：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run this program and send messages to localhost `8888`, then you may
    get a response if the message length is divisible by `2`, `3`, `5`, or `7`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序并向本地主机`8888`发送消息，那么如果消息长度能被`2`、`3`、`5`或`7`整除，你可能会收到响应。
- en: Using the combinator pattern
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合子模式
- en: A combinator is a function that takes other functions as arguments and returns
    a new function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子是一个函数，它接受其他函数作为参数并返回一个新的函数。
- en: 'A simple example of a combinator would be the composition operator, which chains
    two functions together:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子的一个简单例子是组合操作符，它将两个函数连接在一起：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Parser combinators
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器组合子
- en: Another major application of combinators is parser combinators. A parser combinator
    makes use of both the monad and combinator patterns. The monadic `bind` functions
    are used to bind data from parsers that are later returned as a parse result.
    The combinators join parsers into a sequence, failover, or other patterns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子的另一个主要应用是解析器组合子。解析器组合子利用了单子和组合子模式。单子的`bind`函数用于从稍后返回的解析结果中绑定数据。组合子将解析器连接成序列、故障转移或其他模式。
- en: 'The `chomp` parser combinator library is a good implementation of this concept.
    Also, the library provides a nice `parse!` macro that makes the combinator logic
    much easier to read. Here is an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`chomp`解析器组合子库是这个概念的很好实现。此外，该库提供了一个很好的`parse!`宏，使得组合子逻辑更容易阅读。以下是一个例子：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the example defines a grammar for a first name, last name parser. In the
    name function, the parser is defined with a macro. The inside of the macro looks
    almost like a normal code, like the `let` statements, function calls, and closure
    definitions. However, the generated code is actually a mix of monads and combinators.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，示例定义了一个用于姓氏和名字的语法。在名字函数中，解析器使用宏定义。宏的内部看起来几乎像正常代码，如`let`语句、函数调用和闭包定义。然而，生成的代码实际上是单子和组合器的混合。
- en: Each `let` binding corresponds to a combinator. Each semicolon corresponds to
    a combinator. The functions `take_while1` and `token` are both combinators that
    introduce parser monads. Then, when the macro ends, we are left with an expression
    that processes the input to parse a result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`let`绑定对应一个组合器。每个分号对应一个组合器。函数`take_while1`和`token`都是引入解析器单子的组合器。然后，当宏结束时，我们留下一个处理输入以解析结果的表达式。
- en: 'This `chomp` parser combinator library is fully featured and may be hard to
    understand if you just casually examined the source code. To see what is happening
    here, let''s create our own parser combinators. First, let''s define the parser
    state:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`chomp`解析器组合库功能齐全，如果你只是随意查看源代码，可能会难以理解。为了了解这里发生了什么，让我们创建自己的解析器组合器。首先，让我们定义解析器状态：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we define `ParseState`, `ParseRCon`, and `ParseResult`. The parse state
    keeps track of what character index the parser is at. The parse state often also
    records information, such as the line and column number.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`ParseState`、`ParseRCon`和`ParseResult`。解析器状态跟踪解析器所在的字符索引。解析器状态通常还记录信息，如行号和列号。
- en: The `ParseRCon` structure encapsulates state along with an optional value wrapped
    in a result. If an unrecoverable error happens while parsing, the result will
    become `Err`. If a recoverable error happens while parsing, the option will be
    `None`. Otherwise, the parsers should work mostly as if they expect to always
    have the optional value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseRCon`结构封装了状态以及一个可选值，该值被封装在结果中。如果在解析过程中发生不可恢复的错误，结果将变为`Err`。如果在解析过程中发生可恢复的错误，选项将为`None`。否则，解析器应该基本上像它们期望始终有可选值一样工作。'
- en: The `ParseResult` type is returned at the very end of a parse execution to provide
    a successful result or error message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseResult`类型在解析执行的最后返回，以提供成功的结果或错误信息。'
- en: 'The parser monads and combinators are defined ad hoc with different functions.
    To create a parser, the simplest options would be `parse_mzero` and `parse_return`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器单子和组合器使用不同的函数定义。要创建一个解析器，最简单的选项可能是`parse_mzero`和`parse_return`：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `parse_mzero` monad always fails and returns a simple message. The `parse_return`
    always succeeds and returns a given value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_mzero`单子总是失败并返回一个简单的消息。`parse_return`总是成功并返回一个给定的值。'
- en: 'To make things more interesting, let''s actually look at a parser that consumes
    input. We create the following two functions—`parse_token` and `parse_satisfy`.
    `parse_token` will always consume one token and return its value unless there
    is no more input. `parse_satisfy` will consume a token if the token satisfies
    some condition. Here are the definitions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，让我们实际看看一个消耗输入的解析器。我们创建了以下两个函数——`parse_token`和`parse_satisfy`。`parse_token`将始终消耗一个标记并返回其值，除非没有更多输入。`parse_satisfy`将消耗一个标记，如果标记满足某些条件。以下是定义：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `parse_token` and `parse_satisfy` look at one token. If the token satisfies
    the provided condition, it then returns the input token. Here, we create several
    conditions to correspond to single character matching, digits, spaces, or arithmetic
    operators.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_token`和`parse_satisfy`查看一个标记。如果标记满足提供的条件，它将返回输入标记。在这里，我们创建几个条件来对应单个字符匹配、数字、空格或算术运算符。'
- en: 'These functions can be composed using high-level combinators to create complex
    grammar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以使用高级组合器组合起来创建复杂的语法：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we see how the monadic `parse_bind` or its derivative, `parse_sequence`,
    can be used to sequence two parsers together. We don't have an example here but
    the failover combinator is also defined in `parse_or`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到如何使用单子的`parse_bind`或其衍生物`parse_sequence`来串联两个解析器。这里没有示例，但失败组合器也在`parse_or`中定义。
- en: Using these primitives, we can create nice tools to help us generate complex
    parsers that expect, store, and manipulate data from token streams. Parse combinators
    are one of the more practical yet challenging applications of monads and combinators.
    The fact that these concepts are at all possible in Rust demonstrates how far
    the language has developed towards supporting functional concepts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些原始工具，我们可以创建一些很好的工具来帮助我们生成复杂的解析器，这些解析器期望、存储和操作来自标记流的 数据。解析组合器是单子和组合器更实用但更具挑战性的应用之一。这些概念在
    Rust 中成为可能的事实展示了该语言在支持函数式概念方面的发展程度。
- en: Using the lazy evaluation pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用惰性评估模式
- en: Lazy evaluation is procrastination, doing work later rather than now. Why is
    this important? Well, it turns out if you procrastinate long enough, sometimes
    it turns out that the work never needed to be done after all!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估是推迟，将工作推迟到以后而不是现在。为什么这很重要？好吧，结果证明，如果你推迟足够长的时间，有时最终发现这项工作根本不需要完成！
- en: 'Take, for example, a simple expression evaluation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的表达式评估为例：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a strict interpretation, the first expression will perform an arithmetic
    calculation. The second expression will define an arithmetic calculation but will
    wait before evaluating it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格的解释下，第一个表达式将执行一个算术计算。第二个表达式将定义一个算术计算，但会等待然后再进行评估。
- en: This case is so simple that the compiler gives a warning and might choose to
    discard the unused constant expression. In more complicated cases, the lazy evaluated
    case will always perform better when not evaluated. This should be expected because
    unused lazy expressions do nothing, intentionally.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况如此简单，以至于编译器会发出警告，并可能选择丢弃未使用的常量表达式。在更复杂的情况下，未评估的惰性评估情况将始终表现得更好。这应该是预期的，因为未使用的惰性表达式什么也不做，这是故意的。
- en: 'Iterators are lazy. They don''t do anything until you collect or otherwise
    iterate over them:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是惰性的。它们在你收集或以其他方式迭代它们之前不会做任何事情：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Another data structure that intentionally uses lazy evaluation is the lazy list.
    A lazy list is very similar to an iterator with the exception that lazy lists
    can be shared and consumed at different paces independently.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个故意使用惰性评估的数据结构是惰性列表。惰性列表与迭代器非常相似，除了惰性列表可以独立地共享和以不同的速度消费。
- en: 'In the parser combinator example, we hid a lazy list inside of the parser state
    structure. Let''s isolate that and see what a pure definition looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析组合器示例中，我们在解析器状态结构中隐藏了一个惰性列表。让我们将其隔离出来，看看一个纯定义看起来像什么：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we can see that a lazy list is much like an iterator. In fact, a lazy
    list could implement the `Iterator` trait; then it really would be an iterator.
    However, iterators are not lazy lists. Lazy lists inherently have an unlimited
    capacity to look ahead to any number of items. Iterators, on the other hand, optionally,
    may implement the `Peekable` trait permitting one look ahead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到惰性列表与迭代器非常相似。事实上，惰性列表可以实现 `Iterator` 特性；那么它就真的是一个迭代器了。然而，迭代器不是惰性列表。惰性列表本质上具有无限的前瞻能力，可以查看任意数量的项目。另一方面，迭代器可选地可以实现
    `Peekable` 特性，允许向前查看。
- en: There is a fundamental problem at the core of lazy programming, though. Too
    much procrastination will never complete any task. If you write a program to launch
    missiles, at some point in the program, it needs to actually launch missiles.
    This is an irreversible side-effect of running the program. We don't like side-effects,
    and lazy programming takes an extreme stance against side- effects. At the same
    time, we need to accomplish the given task though, and that involves making a
    choice at some point to push the launch button.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管惰性编程的核心存在一个基本问题。过多的推迟将永远不会完成任何任务。如果你编写一个发射导弹的程序，在程序的某个时刻，它需要实际发射导弹。这是程序运行的一个不可逆的副作用。我们不喜欢副作用，而惰性编程对副作用持极端的反对态度。同时，我们还需要完成给定的任务，这涉及到在某个时刻做出选择，按下发射按钮。
- en: Clearly, we can never fully contain the behavior of programs with side-effects.
    However, we can make them easier to work with. By wrapping side-effects into lazy
    evaluated expressions, then turning them into monads, what we create are side-effect
    units. These units can then be manipulated and composed in a more functional style.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们永远无法完全包含具有副作用程序的行为。然而，我们可以使它们更容易处理。通过将副作用包装到惰性评估表达式中，然后将它们转换为单子，我们创建的是副作用单元。然后我们可以以更函数式的方式对这些单元进行操作和组合。
- en: The last lazy pattern that we will introduce is **functional reactive programming**,
    **FRP** for short. There are entire programming languages, such as Elm, based
    on this concept. Popular web UI frameworks, such as React or Angular, are also
    influenced by FRP concepts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要引入的最后一种懒惰模式是**函数式响应式编程**，简称**FRP**。有一些基于这个概念的整个编程语言，例如Elm。流行的网络UI框架，如React或Angular，也受到了FRP概念的影响。
- en: 'The FRP concept is an extension of the side-effect/state monad example. Event
    handling, state transitions, and side-effects can be turned into units of reactive
    programming. Let''s define a monad to capture this reactive unit concept:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: FRP概念是副作用/状态单例示例的扩展。事件处理、状态转换和副作用可以转换为响应式编程的单位。让我们定义一个单例来捕获这个响应式单元概念：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we find that a `ReactiveUnit` holds state, can respond to an input, cause
    side-effects, and return a value. Reactive units can be extended with `bind` or
    concatenated with `plus`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现`ReactiveUnit`可以持有状态，可以响应输入，产生副作用，并返回一个值。可以通过`bind`扩展`ReactiveUnit`或通过`plus`连接它们。
- en: 'Now, let''s make a reactive unit. We will focus on web frameworks since those
    seem to be popular. First, we render a simple HTML page, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个响应式单元。我们将关注网络框架，因为它们似乎很受欢迎。首先，我们渲染一个简单的HTML页面，如下所示：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, the unit renders a simple page corresponding to `section 1` on a website.
    The unit will always render a whole page and does not consider any state or input.
    Let''s give the unit more responsibilities by telling it to render different content
    based on which section is active:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单元渲染了一个简单的页面，对应于网站上的`第1节`。这个单元将始终渲染整个页面，不考虑任何状态或输入。让我们通过告诉单元根据哪个部分是活动的来给它更多的责任：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the unit makes use of the parameter to decide what section should be rendered.
    This is starting to feel more like a UI framework, but we aren't using the state,
    yet. Let's try using that to address a common web problem—page tearing. When a
    large portion of HTML is changed on a web page, the browser must recalculate how
    the page should be displayed. Most modern browsers do this in stages and the result
    is an ugly mishmash of components being visibly thrown around the page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单元使用参数来决定应该渲染哪个部分。这开始感觉更像是一个UI框架，但我们还没有使用状态。让我们尝试使用它来解决一个常见的网络问题——页面撕裂。当网页上的大量HTML发生变化时，浏览器必须重新计算页面应该如何显示。大多数现代浏览器都是分阶段进行这一操作的，结果是组件在页面上被明显地扔来扔去，显得很丑陋。
- en: 'To reduce or prevent page tearing, we should only update portions of the page
    that have changed. Let''s use the state variable along with the input parameter
    to only send updates when a component has changed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少或防止页面撕裂，我们应只更新已更改的页面部分。让我们使用状态变量和输入参数，仅在组件发生变化时发送更新：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we issue commands to conditionally render changes to the header. If the
    header is already in the correct state, then we do nothing. This code only takes
    responsibility for the header component. We also need to render changes to page
    content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发出命令以有条件地渲染标题的变化。如果标题已经处于正确的状态，则不执行任何操作。此代码仅负责标题组件。我们还需要渲染页面内容的变化：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we have a component for the header and another component for the content.
    We should combine these two into a single unit. FRP libraries would probably have
    a cool neat way of doing this, but we don''t; so instead, we just write a little
    unit to combine them manually:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个用于标题的组件和另一个用于内容的组件。我们应该将这两个组件合并成一个单元。FRP库可能有一个很酷的整洁方法来做这件事，但我们没有；所以，我们只是编写了一个小单元来手动合并它们：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s test this out:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each `apply` issues appropriate new update commands. The redundant `apply` to
    render `section 2` again returns no commands, as intended. This is really lazy
    code; the good kind of lazy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`apply`都会发出适当的新的更新命令。再次渲染`第2节`的冗余`apply`不会返回任何命令，正如预期的那样。这实际上是一种懒惰的代码；是好的懒惰。
- en: 'What would reactive programming be without event handling? Let''s handle a
    couple of signals and events. On top of the page state, let''s introduce some
    database interaction:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有事件处理，响应式编程会是什么样子？让我们处理一些信号和事件。在页面状态之上，让我们引入一些数据库交互：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We define four event types to react to. Responding to page state changes still
    works as previously defined. Events that should interact with the database issue
    commands to update the database locally and remotely. A view of the output JavaScript
    looks like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了四种事件类型以进行响应。响应页面状态变化仍然像之前定义的那样工作。应该与数据库交互的事件会发出命令以在本地和远程更新数据库。输出JavaScript的视图如下所示：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This correspondence demonstrates how simple side-effect units can be composed
    to create complex programmatic behavior. This is all built from an FRP library
    that is less than 50 lines long. Imagine the potential utility of a few more helper
    functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对应关系展示了如何将简单的副作用单元组合起来以创建复杂的程序行为。这一切都是从一个少于50行代码的FRP库中构建的。想象一下增加几个辅助函数的潜在效用。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced many common functional design patterns. We used
    a lot of scary words, such as functor, monad, and combinator. You should try to
    remember these words and their meanings. Other scary words, such as contravariant,
    you can probably forget unless you want to pursue math.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多常见的函数式设计模式。我们使用了大量令人畏惧的词汇，如函子、单子和组合子。你应该努力记住这些词汇及其含义。其他令人畏惧的词汇，如逆变，除非你想追求数学，否则你可能可以忘记。
- en: In an applied context, we learned that functors can hide information to expose
    simple transformations on data. The monad pattern allows us to turn sequential
    actions into units of computation. Monads can be used to create iterators that
    also behave more like lists. Laziness can be used to defer computation. Also,
    these patterns can often be combined in useful ways, such as FRP, which is gaining
    popularity as a tool to develop user interfaces and other complex interactive
    programs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用场景中，我们了解到函子可以隐藏信息以暴露对数据的简单转换。单子模式允许我们将顺序操作转换为计算单元。单子可以用来创建也表现得像列表的迭代器。惰性求值可以用来延迟计算。此外，这些模式通常可以以有用的方式组合，例如FRP，它作为开发用户界面和其他复杂交互程序的工具而越来越受欢迎。
- en: In the next chapter, we will explore concurrency. We will introduce the Rust
    concepts of thread/data ownership, shared synchronized data, and message passing.
    Thread-level concurrency is something that Rust was specifically designed for.
    If you have worked with threads in other languages, then hopefully the next chapter
    will be encouraging.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨并发。我们将介绍Rust的线程/数据所有权、共享同步数据和消息传递的概念。线程级别的并发是Rust特别设计用于的功能。如果你在其他语言中处理过线程，那么下一章可能会给你带来鼓舞。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a functor?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函子？
- en: What is a contravariant functor?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆变函子是什么？
- en: What is a monad?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单子？
- en: What are the monad laws?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单子法则是什么？
- en: What is a combinator?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是组合子？
- en: Why is the `impl` keyword necessary for closure return values?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么闭包返回值需要使用`impl`关键字？
- en: What is lazy evaluation?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 惰性求值是什么？
