- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has developed design patterns just like object-oriented
    or other communities. These patterns, unsurprisingly, make use of functions as
    a central concept. They also emphasize something called the **single responsibility
    principle**. The single responsibility principle states that program's logical
    components should do one thing and do that one thing well. In this chapter, we
    will focus on a few very common patterns. Some of these concepts are so simple that
    they counter-intuitively become harder to explain. In these cases, we will make
    use of various examples to demonstrate how a simple concept can exhibit complex
    behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learn to recognize and use functors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use monads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use combinators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use lazy evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Using the functor pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A functor is approximately the inverse of a function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A function defines a transformation, accepts data, and returns the result of
    the transformation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functor defines data, accepts a function, and returns the result of the transformation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple example of a functor is the Rust vector and its accompanying `map`
    function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Functors are often thought of as only the `map` function, due to the rules
    of what constitutes a functor or not. The preceding common case is what''s called
    a **structure-preserving map**. Functors do not need to be structure-preserving.
    For example, take the very similar case of a map implemented for a set, as shown
    in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We see here that the resulting set is smaller than the original set due to
    collisions. This mapping still satisfies the properties of a functor. The defining
    properties of a functor are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: A collection of objects, `C`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping function that will transform objects in `C` into objects in `D`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding `Set` map satisfies both the first and second property, and is
    therefore a proper functor. It also demonstrates how data can be transformed into
    a differently shaped structure through a functor. Using a little imagination,
    we may also consider the case where each mapped value may produce multiple outputs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Technically speaking, this last case is not a normal functor, but rather a contravariant
    functor. All functors are covariant. The distinction between covariance and contravariance
    is not important for our purposes, so we will leave that topic to only the most
    curious readers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final definition by example, we should note that the input and output
    of a functor map need not be of the same type. For example, we can map from a
    vector to a `HashSet`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To give a non-trivial example of how the functor pattern could be used, let''s
    look at webcams and AI. Modern AI facial recognition software is capable of identifying
    human faces in pictures and even visible emotional states. Let''s imagine an app
    that connects to a webcam and processes the input with a filter. Here are some
    type definitions for the program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the `WebCamera` type, we will implement two functors. One functor, `map_emotion`,
    will map emotions to other emotions. Maybe this could be used to add emojis to
    the text chat. The second contravariant functor, `flatmap_emotion`, maps emotions
    to zero, or more filters. These are animations or effects that can be applied
    back onto the web camera field of view:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use the functors, the programmer supplies which emotions map to which filters.
    The complex AI and effects can be easily modified due to the encapsulation provided
    by the functor pattern:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the monad pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A monad defines `return` and `bind` operations for a type. The `return` operation
    is like a constructor to make the monad. The `bind` operation incorporates new
    information and returns a new monad. There are also several laws that monads should
    obey. Rather than quote the laws, we''ll just say that monads should behave well
    when daisy chained like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In Rust, there are several semi-monads that appear in standard libraries:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the normal `Option` constructors, `Some` or `None`, take the
    place of the monadic naming convention, `return`. There are two semi-monads implemented
    here, one associated with `and_then`, and the other with `or_else`. Both of these
    correspond to the monadic `bind` naming convention for the operator responsible
    for incorporating new information into a new monad return value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Monadic `bind` operations are also polymorphic, meaning they should permit
    returning monads of different types from the current monad. According to this
    rule, `or_else` is not technically a monad; hence it is a semi-monad:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Monads were originally developed to express side-effects in purely functional
    languages. Isn't that a contradiction—pure with side-effects?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The answer is *no* if the effects are passed as input and output through pure
    functions. However, for this to work, every function would need to declare every
    state variable and pass it along, which could become a huge list of parameters.
    This is where monads come in. A monad can hide state inside itself, which becomes
    essentially a larger, more complex function than what the programmer interacts
    with.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'One concrete example of side-effect hiding is the concept of a universal logger.
    The monadic `return` and `bind` can be used to wrap state and computation inside
    of a monad that will log all intermediate results. Here is the logger monad:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As long as each result implements the `Debug` trait, it can be automatically
    logged with this pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The monad pattern is also very useful for chaining together code that can''t
    be written in a normal code block. For example, code blocks are always evaluated
    eagerly. If you want to define code that will be evaluated later or in pieces,
    the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe
    code or data that is not evaluated until it is referenced. This is contrary to
    the typical eager evaluation of Rust code that will execute immediately regardless
    of context. Here is the lazy monad pattern:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This block defines statements that will be evaluated one at a time after a value
    is supplied, but not before. This may seem a bit trivial since we can do the same
    with a simple closure and code block; however, to make this pattern stick, let's
    consider a more complex case—an asynchronous web server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'A web server will typically receive a full HTTP request before processing it.
    Choosing what to do with a request is sometimes called **routing**. Then requests
    are sent to a request handler. In the following code, we define a server that
    helps us wrap routes and handlers into a single web server object. Here are the
    type and method definitions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This type defines `return` and `bind` like operations. However, the `bind` function
    is not polymorphic and the operation is not a pure function. Without these compromises,
    we would need to fight against the Rust type and ownership system; the preceding
    example is not written monadically due to complications when trying to box and
    copy closures. This is an expected trade-off and the semi-monad pattern should
    not be discouraged when appropriate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our web server responses, we can attach handlers like in the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run this program and send messages to localhost `8888`, then you may
    get a response if the message length is divisible by `2`, `3`, `5`, or `7`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Using the combinator pattern
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A combinator is a function that takes other functions as arguments and returns
    a new function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a combinator would be the composition operator, which chains
    two functions together:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Parser combinators
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major application of combinators is parser combinators. A parser combinator
    makes use of both the monad and combinator patterns. The monadic `bind` functions
    are used to bind data from parsers that are later returned as a parse result.
    The combinators join parsers into a sequence, failover, or other patterns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chomp` parser combinator library is a good implementation of this concept.
    Also, the library provides a nice `parse!` macro that makes the combinator logic
    much easier to read. Here is an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the example defines a grammar for a first name, last name parser. In the
    name function, the parser is defined with a macro. The inside of the macro looks
    almost like a normal code, like the `let` statements, function calls, and closure
    definitions. However, the generated code is actually a mix of monads and combinators.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Each `let` binding corresponds to a combinator. Each semicolon corresponds to
    a combinator. The functions `take_while1` and `token` are both combinators that
    introduce parser monads. Then, when the macro ends, we are left with an expression
    that processes the input to parse a result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'This `chomp` parser combinator library is fully featured and may be hard to
    understand if you just casually examined the source code. To see what is happening
    here, let''s create our own parser combinators. First, let''s define the parser
    state:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we define `ParseState`, `ParseRCon`, and `ParseResult`. The parse state
    keeps track of what character index the parser is at. The parse state often also
    records information, such as the line and column number.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseRCon` structure encapsulates state along with an optional value wrapped
    in a result. If an unrecoverable error happens while parsing, the result will
    become `Err`. If a recoverable error happens while parsing, the option will be
    `None`. Otherwise, the parsers should work mostly as if they expect to always
    have the optional value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseResult` type is returned at the very end of a parse execution to provide
    a successful result or error message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser monads and combinators are defined ad hoc with different functions.
    To create a parser, the simplest options would be `parse_mzero` and `parse_return`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `parse_mzero` monad always fails and returns a simple message. The `parse_return`
    always succeeds and returns a given value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, let''s actually look at a parser that consumes
    input. We create the following two functions—`parse_token` and `parse_satisfy`.
    `parse_token` will always consume one token and return its value unless there
    is no more input. `parse_satisfy` will consume a token if the token satisfies
    some condition. Here are the definitions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `parse_token` and `parse_satisfy` look at one token. If the token satisfies
    the provided condition, it then returns the input token. Here, we create several
    conditions to correspond to single character matching, digits, spaces, or arithmetic
    operators.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions can be composed using high-level combinators to create complex
    grammar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we see how the monadic `parse_bind` or its derivative, `parse_sequence`,
    can be used to sequence two parsers together. We don't have an example here but
    the failover combinator is also defined in `parse_or`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using these primitives, we can create nice tools to help us generate complex
    parsers that expect, store, and manipulate data from token streams. Parse combinators
    are one of the more practical yet challenging applications of monads and combinators.
    The fact that these concepts are at all possible in Rust demonstrates how far
    the language has developed towards supporting functional concepts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Using the lazy evaluation pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation is procrastination, doing work later rather than now. Why is
    this important? Well, it turns out if you procrastinate long enough, sometimes
    it turns out that the work never needed to be done after all!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, a simple expression evaluation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a strict interpretation, the first expression will perform an arithmetic
    calculation. The second expression will define an arithmetic calculation but will
    wait before evaluating it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: This case is so simple that the compiler gives a warning and might choose to
    discard the unused constant expression. In more complicated cases, the lazy evaluated
    case will always perform better when not evaluated. This should be expected because
    unused lazy expressions do nothing, intentionally.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators are lazy. They don''t do anything until you collect or otherwise
    iterate over them:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Another data structure that intentionally uses lazy evaluation is the lazy list.
    A lazy list is very similar to an iterator with the exception that lazy lists
    can be shared and consumed at different paces independently.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parser combinator example, we hid a lazy list inside of the parser state
    structure. Let''s isolate that and see what a pure definition looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we can see that a lazy list is much like an iterator. In fact, a lazy
    list could implement the `Iterator` trait; then it really would be an iterator.
    However, iterators are not lazy lists. Lazy lists inherently have an unlimited
    capacity to look ahead to any number of items. Iterators, on the other hand, optionally,
    may implement the `Peekable` trait permitting one look ahead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: There is a fundamental problem at the core of lazy programming, though. Too
    much procrastination will never complete any task. If you write a program to launch
    missiles, at some point in the program, it needs to actually launch missiles.
    This is an irreversible side-effect of running the program. We don't like side-effects,
    and lazy programming takes an extreme stance against side- effects. At the same
    time, we need to accomplish the given task though, and that involves making a
    choice at some point to push the launch button.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we can never fully contain the behavior of programs with side-effects.
    However, we can make them easier to work with. By wrapping side-effects into lazy
    evaluated expressions, then turning them into monads, what we create are side-effect
    units. These units can then be manipulated and composed in a more functional style.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The last lazy pattern that we will introduce is **functional reactive programming**,
    **FRP** for short. There are entire programming languages, such as Elm, based
    on this concept. Popular web UI frameworks, such as React or Angular, are also
    influenced by FRP concepts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The FRP concept is an extension of the side-effect/state monad example. Event
    handling, state transitions, and side-effects can be turned into units of reactive
    programming. Let''s define a monad to capture this reactive unit concept:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we find that a `ReactiveUnit` holds state, can respond to an input, cause
    side-effects, and return a value. Reactive units can be extended with `bind` or
    concatenated with `plus`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a reactive unit. We will focus on web frameworks since those
    seem to be popular. First, we render a simple HTML page, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, the unit renders a simple page corresponding to `section 1` on a website.
    The unit will always render a whole page and does not consider any state or input.
    Let''s give the unit more responsibilities by telling it to render different content
    based on which section is active:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the unit makes use of the parameter to decide what section should be rendered.
    This is starting to feel more like a UI framework, but we aren't using the state,
    yet. Let's try using that to address a common web problem—page tearing. When a
    large portion of HTML is changed on a web page, the browser must recalculate how
    the page should be displayed. Most modern browsers do this in stages and the result
    is an ugly mishmash of components being visibly thrown around the page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce or prevent page tearing, we should only update portions of the page
    that have changed. Let''s use the state variable along with the input parameter
    to only send updates when a component has changed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we issue commands to conditionally render changes to the header. If the
    header is already in the correct state, then we do nothing. This code only takes
    responsibility for the header component. We also need to render changes to page
    content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we have a component for the header and another component for the content.
    We should combine these two into a single unit. FRP libraries would probably have
    a cool neat way of doing this, but we don''t; so instead, we just write a little
    unit to combine them manually:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s test this out:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each `apply` issues appropriate new update commands. The redundant `apply` to
    render `section 2` again returns no commands, as intended. This is really lazy
    code; the good kind of lazy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'What would reactive programming be without event handling? Let''s handle a
    couple of signals and events. On top of the page state, let''s introduce some
    database interaction:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We define four event types to react to. Responding to page state changes still
    works as previously defined. Events that should interact with the database issue
    commands to update the database locally and remotely. A view of the output JavaScript
    looks like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This correspondence demonstrates how simple side-effect units can be composed
    to create complex programmatic behavior. This is all built from an FRP library
    that is less than 50 lines long. Imagine the potential utility of a few more helper
    functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对应关系展示了如何将简单的副作用单元组合起来以创建复杂的程序行为。这一切都是从一个少于50行代码的FRP库中构建的。想象一下增加几个辅助函数的潜在效用。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced many common functional design patterns. We used
    a lot of scary words, such as functor, monad, and combinator. You should try to
    remember these words and their meanings. Other scary words, such as contravariant,
    you can probably forget unless you want to pursue math.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多常见的函数式设计模式。我们使用了大量令人畏惧的词汇，如函子、单子和组合子。你应该努力记住这些词汇及其含义。其他令人畏惧的词汇，如逆变，除非你想追求数学，否则你可能可以忘记。
- en: In an applied context, we learned that functors can hide information to expose
    simple transformations on data. The monad pattern allows us to turn sequential
    actions into units of computation. Monads can be used to create iterators that
    also behave more like lists. Laziness can be used to defer computation. Also,
    these patterns can often be combined in useful ways, such as FRP, which is gaining
    popularity as a tool to develop user interfaces and other complex interactive
    programs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用场景中，我们了解到函子可以隐藏信息以暴露对数据的简单转换。单子模式允许我们将顺序操作转换为计算单元。单子可以用来创建也表现得像列表的迭代器。惰性求值可以用来延迟计算。此外，这些模式通常可以以有用的方式组合，例如FRP，它作为开发用户界面和其他复杂交互程序的工具而越来越受欢迎。
- en: In the next chapter, we will explore concurrency. We will introduce the Rust
    concepts of thread/data ownership, shared synchronized data, and message passing.
    Thread-level concurrency is something that Rust was specifically designed for.
    If you have worked with threads in other languages, then hopefully the next chapter
    will be encouraging.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨并发。我们将介绍Rust的线程/数据所有权、共享同步数据和消息传递的概念。线程级别的并发是Rust特别设计用于的功能。如果你在其他语言中处理过线程，那么下一章可能会给你带来鼓舞。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a functor?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函子？
- en: What is a contravariant functor?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆变函子是什么？
- en: What is a monad?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单子？
- en: What are the monad laws?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单子法则是什么？
- en: What is a combinator?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是组合子？
- en: Why is the `impl` keyword necessary for closure return values?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么闭包返回值需要使用`impl`关键字？
- en: What is lazy evaluation?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 惰性求值是什么？
