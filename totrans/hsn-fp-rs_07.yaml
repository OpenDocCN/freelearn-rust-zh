- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has developed design patterns just like object-oriented
    or other communities. These patterns, unsurprisingly, make use of functions as
    a central concept. They also emphasize something called the **single responsibility
    principle**. The single responsibility principle states that program's logical
    components should do one thing and do that one thing well. In this chapter, we
    will focus on a few very common patterns. Some of these concepts are so simple that
    they counter-intuitively become harder to explain. In these cases, we will make
    use of various examples to demonstrate how a simple concept can exhibit complex
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to recognize and use functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to recognize and use lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the functor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A functor is approximately the inverse of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: A function defines a transformation, accepts data, and returns the result of
    the transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functor defines data, accepts a function, and returns the result of the transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple example of a functor is the Rust vector and its accompanying `map`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Functors are often thought of as only the `map` function, due to the rules
    of what constitutes a functor or not. The preceding common case is what''s called
    a **structure-preserving map**. Functors do not need to be structure-preserving.
    For example, take the very similar case of a map implemented for a set, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We see here that the resulting set is smaller than the original set due to
    collisions. This mapping still satisfies the properties of a functor. The defining
    properties of a functor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of objects, `C`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping function that will transform objects in `C` into objects in `D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding `Set` map satisfies both the first and second property, and is
    therefore a proper functor. It also demonstrates how data can be transformed into
    a differently shaped structure through a functor. Using a little imagination,
    we may also consider the case where each mapped value may produce multiple outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Technically speaking, this last case is not a normal functor, but rather a contravariant
    functor. All functors are covariant. The distinction between covariance and contravariance
    is not important for our purposes, so we will leave that topic to only the most
    curious readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final definition by example, we should note that the input and output
    of a functor map need not be of the same type. For example, we can map from a
    vector to a `HashSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To give a non-trivial example of how the functor pattern could be used, let''s
    look at webcams and AI. Modern AI facial recognition software is capable of identifying
    human faces in pictures and even visible emotional states. Let''s imagine an app
    that connects to a webcam and processes the input with a filter. Here are some
    type definitions for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `WebCamera` type, we will implement two functors. One functor, `map_emotion`,
    will map emotions to other emotions. Maybe this could be used to add emojis to
    the text chat. The second contravariant functor, `flatmap_emotion`, maps emotions
    to zero, or more filters. These are animations or effects that can be applied
    back onto the web camera field of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the functors, the programmer supplies which emotions map to which filters.
    The complex AI and effects can be easily modified due to the encapsulation provided
    by the functor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the monad pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A monad defines `return` and `bind` operations for a type. The `return` operation
    is like a constructor to make the monad. The `bind` operation incorporates new
    information and returns a new monad. There are also several laws that monads should
    obey. Rather than quote the laws, we''ll just say that monads should behave well
    when daisy chained like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust, there are several semi-monads that appear in standard libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the normal `Option` constructors, `Some` or `None`, take the
    place of the monadic naming convention, `return`. There are two semi-monads implemented
    here, one associated with `and_then`, and the other with `or_else`. Both of these
    correspond to the monadic `bind` naming convention for the operator responsible
    for incorporating new information into a new monad return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monadic `bind` operations are also polymorphic, meaning they should permit
    returning monads of different types from the current monad. According to this
    rule, `or_else` is not technically a monad; hence it is a semi-monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Monads were originally developed to express side-effects in purely functional
    languages. Isn't that a contradiction—pure with side-effects?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is *no* if the effects are passed as input and output through pure
    functions. However, for this to work, every function would need to declare every
    state variable and pass it along, which could become a huge list of parameters.
    This is where monads come in. A monad can hide state inside itself, which becomes
    essentially a larger, more complex function than what the programmer interacts
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'One concrete example of side-effect hiding is the concept of a universal logger.
    The monadic `return` and `bind` can be used to wrap state and computation inside
    of a monad that will log all intermediate results. Here is the logger monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As long as each result implements the `Debug` trait, it can be automatically
    logged with this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The monad pattern is also very useful for chaining together code that can''t
    be written in a normal code block. For example, code blocks are always evaluated
    eagerly. If you want to define code that will be evaluated later or in pieces,
    the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe
    code or data that is not evaluated until it is referenced. This is contrary to
    the typical eager evaluation of Rust code that will execute immediately regardless
    of context. Here is the lazy monad pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This block defines statements that will be evaluated one at a time after a value
    is supplied, but not before. This may seem a bit trivial since we can do the same
    with a simple closure and code block; however, to make this pattern stick, let's
    consider a more complex case—an asynchronous web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A web server will typically receive a full HTTP request before processing it.
    Choosing what to do with a request is sometimes called **routing**. Then requests
    are sent to a request handler. In the following code, we define a server that
    helps us wrap routes and handlers into a single web server object. Here are the
    type and method definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This type defines `return` and `bind` like operations. However, the `bind` function
    is not polymorphic and the operation is not a pure function. Without these compromises,
    we would need to fight against the Rust type and ownership system; the preceding
    example is not written monadically due to complications when trying to box and
    copy closures. This is an expected trade-off and the semi-monad pattern should
    not be discouraged when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our web server responses, we can attach handlers like in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you run this program and send messages to localhost `8888`, then you may
    get a response if the message length is divisible by `2`, `3`, `5`, or `7`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the combinator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A combinator is a function that takes other functions as arguments and returns
    a new function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a combinator would be the composition operator, which chains
    two functions together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Parser combinators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major application of combinators is parser combinators. A parser combinator
    makes use of both the monad and combinator patterns. The monadic `bind` functions
    are used to bind data from parsers that are later returned as a parse result.
    The combinators join parsers into a sequence, failover, or other patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chomp` parser combinator library is a good implementation of this concept.
    Also, the library provides a nice `parse!` macro that makes the combinator logic
    much easier to read. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the example defines a grammar for a first name, last name parser. In the
    name function, the parser is defined with a macro. The inside of the macro looks
    almost like a normal code, like the `let` statements, function calls, and closure
    definitions. However, the generated code is actually a mix of monads and combinators.
  prefs: []
  type: TYPE_NORMAL
- en: Each `let` binding corresponds to a combinator. Each semicolon corresponds to
    a combinator. The functions `take_while1` and `token` are both combinators that
    introduce parser monads. Then, when the macro ends, we are left with an expression
    that processes the input to parse a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `chomp` parser combinator library is fully featured and may be hard to
    understand if you just casually examined the source code. To see what is happening
    here, let''s create our own parser combinators. First, let''s define the parser
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we define `ParseState`, `ParseRCon`, and `ParseResult`. The parse state
    keeps track of what character index the parser is at. The parse state often also
    records information, such as the line and column number.
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseRCon` structure encapsulates state along with an optional value wrapped
    in a result. If an unrecoverable error happens while parsing, the result will
    become `Err`. If a recoverable error happens while parsing, the option will be
    `None`. Otherwise, the parsers should work mostly as if they expect to always
    have the optional value.
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseResult` type is returned at the very end of a parse execution to provide
    a successful result or error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser monads and combinators are defined ad hoc with different functions.
    To create a parser, the simplest options would be `parse_mzero` and `parse_return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `parse_mzero` monad always fails and returns a simple message. The `parse_return`
    always succeeds and returns a given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, let''s actually look at a parser that consumes
    input. We create the following two functions—`parse_token` and `parse_satisfy`.
    `parse_token` will always consume one token and return its value unless there
    is no more input. `parse_satisfy` will consume a token if the token satisfies
    some condition. Here are the definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `parse_token` and `parse_satisfy` look at one token. If the token satisfies
    the provided condition, it then returns the input token. Here, we create several
    conditions to correspond to single character matching, digits, spaces, or arithmetic
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions can be composed using high-level combinators to create complex
    grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see how the monadic `parse_bind` or its derivative, `parse_sequence`,
    can be used to sequence two parsers together. We don't have an example here but
    the failover combinator is also defined in `parse_or`.
  prefs: []
  type: TYPE_NORMAL
- en: Using these primitives, we can create nice tools to help us generate complex
    parsers that expect, store, and manipulate data from token streams. Parse combinators
    are one of the more practical yet challenging applications of monads and combinators.
    The fact that these concepts are at all possible in Rust demonstrates how far
    the language has developed towards supporting functional concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Using the lazy evaluation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation is procrastination, doing work later rather than now. Why is
    this important? Well, it turns out if you procrastinate long enough, sometimes
    it turns out that the work never needed to be done after all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, a simple expression evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In a strict interpretation, the first expression will perform an arithmetic
    calculation. The second expression will define an arithmetic calculation but will
    wait before evaluating it.
  prefs: []
  type: TYPE_NORMAL
- en: This case is so simple that the compiler gives a warning and might choose to
    discard the unused constant expression. In more complicated cases, the lazy evaluated
    case will always perform better when not evaluated. This should be expected because
    unused lazy expressions do nothing, intentionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators are lazy. They don''t do anything until you collect or otherwise
    iterate over them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Another data structure that intentionally uses lazy evaluation is the lazy list.
    A lazy list is very similar to an iterator with the exception that lazy lists
    can be shared and consumed at different paces independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parser combinator example, we hid a lazy list inside of the parser state
    structure. Let''s isolate that and see what a pure definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that a lazy list is much like an iterator. In fact, a lazy
    list could implement the `Iterator` trait; then it really would be an iterator.
    However, iterators are not lazy lists. Lazy lists inherently have an unlimited
    capacity to look ahead to any number of items. Iterators, on the other hand, optionally,
    may implement the `Peekable` trait permitting one look ahead.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fundamental problem at the core of lazy programming, though. Too
    much procrastination will never complete any task. If you write a program to launch
    missiles, at some point in the program, it needs to actually launch missiles.
    This is an irreversible side-effect of running the program. We don't like side-effects,
    and lazy programming takes an extreme stance against side- effects. At the same
    time, we need to accomplish the given task though, and that involves making a
    choice at some point to push the launch button.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we can never fully contain the behavior of programs with side-effects.
    However, we can make them easier to work with. By wrapping side-effects into lazy
    evaluated expressions, then turning them into monads, what we create are side-effect
    units. These units can then be manipulated and composed in a more functional style.
  prefs: []
  type: TYPE_NORMAL
- en: The last lazy pattern that we will introduce is **functional reactive programming**,
    **FRP** for short. There are entire programming languages, such as Elm, based
    on this concept. Popular web UI frameworks, such as React or Angular, are also
    influenced by FRP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FRP concept is an extension of the side-effect/state monad example. Event
    handling, state transitions, and side-effects can be turned into units of reactive
    programming. Let''s define a monad to capture this reactive unit concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we find that a `ReactiveUnit` holds state, can respond to an input, cause
    side-effects, and return a value. Reactive units can be extended with `bind` or
    concatenated with `plus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a reactive unit. We will focus on web frameworks since those
    seem to be popular. First, we render a simple HTML page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the unit renders a simple page corresponding to `section 1` on a website.
    The unit will always render a whole page and does not consider any state or input.
    Let''s give the unit more responsibilities by telling it to render different content
    based on which section is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the unit makes use of the parameter to decide what section should be rendered.
    This is starting to feel more like a UI framework, but we aren't using the state,
    yet. Let's try using that to address a common web problem—page tearing. When a
    large portion of HTML is changed on a web page, the browser must recalculate how
    the page should be displayed. Most modern browsers do this in stages and the result
    is an ugly mishmash of components being visibly thrown around the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce or prevent page tearing, we should only update portions of the page
    that have changed. Let''s use the state variable along with the input parameter
    to only send updates when a component has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we issue commands to conditionally render changes to the header. If the
    header is already in the correct state, then we do nothing. This code only takes
    responsibility for the header component. We also need to render changes to page
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a component for the header and another component for the content.
    We should combine these two into a single unit. FRP libraries would probably have
    a cool neat way of doing this, but we don''t; so instead, we just write a little
    unit to combine them manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Each `apply` issues appropriate new update commands. The redundant `apply` to
    render `section 2` again returns no commands, as intended. This is really lazy
    code; the good kind of lazy.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would reactive programming be without event handling? Let''s handle a
    couple of signals and events. On top of the page state, let''s introduce some
    database interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We define four event types to react to. Responding to page state changes still
    works as previously defined. Events that should interact with the database issue
    commands to update the database locally and remotely. A view of the output JavaScript
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This correspondence demonstrates how simple side-effect units can be composed
    to create complex programmatic behavior. This is all built from an FRP library
    that is less than 50 lines long. Imagine the potential utility of a few more helper
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced many common functional design patterns. We used
    a lot of scary words, such as functor, monad, and combinator. You should try to
    remember these words and their meanings. Other scary words, such as contravariant,
    you can probably forget unless you want to pursue math.
  prefs: []
  type: TYPE_NORMAL
- en: In an applied context, we learned that functors can hide information to expose
    simple transformations on data. The monad pattern allows us to turn sequential
    actions into units of computation. Monads can be used to create iterators that
    also behave more like lists. Laziness can be used to defer computation. Also,
    these patterns can often be combined in useful ways, such as FRP, which is gaining
    popularity as a tool to develop user interfaces and other complex interactive
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore concurrency. We will introduce the Rust
    concepts of thread/data ownership, shared synchronized data, and message passing.
    Thread-level concurrency is something that Rust was specifically designed for.
    If you have worked with threads in other languages, then hopefully the next chapter
    will be encouraging.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a contravariant functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a monad?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the monad laws?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a combinator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `impl` keyword necessary for closure return values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is lazy evaluation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
