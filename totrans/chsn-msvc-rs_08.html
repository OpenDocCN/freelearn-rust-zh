<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Interaction to Database with Object-Relational Mapping</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will continue to interact with databases, but this time we will explore <strong>object-relational mapping</strong> (<strong>ORM</strong>) using the <kbd>diesel</kbd> crate.  This crate helps with generating Rust types that represent tables and records in SQL databases. ORM allows you to use native data structs in code and maps records and <span>database </span>tables to them. It's useful because the compiler takes care of matching types of data columns in a database and structs in source code.</p>
<p>After reading this chapter you will be familiar with the following:</p>
<ul>
<li>Using the <kbd>diesel</kbd> crate with <kbd>r2d2</kbd> pools</li>
<li>Generating and applying migrations</li>
<li>Accessing data with ORM types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will use the SQLite embedded database. You don't need to install and run databases, but you need development packages from the PostgreSQL, MySQL, and SQLite databases. Install them on your system.</p>
<p>You can find examples of this chapter on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The diesel crate</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about interacting with different databases. But the approach we <span>discussed </span>has potential difficulties—you have to check the raw requests you add to your application. It's better if the Rust compiler controls the structure of the data and generates all the necessary requests for the declared structs. This formal and strict approach is possible with the <kbd>diesel</kbd> crate.</p>
<p>Rust has an awesome feature that creates macros and generates code. It allowed the creators of the <kbd>diesel</kbd> crate to create a domain-specific language to query data from a database. To start using this crate, we need to add it to a new project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the necessary dependencies</h1>
                </header>
            
            <article>
                
<p>Create a new crate and add the following dependencies:</p>
<pre>[dependencies]<br/>clap = "2.32"<br/>diesel = { version = "^1.1.0", features = ["sqlite", "r2d2"] }<br/>failure = "0.1"<br/>r2d2 = "0.8"<br/>serde = "1.0"<br/>serde_derive = "1.0"<br/>uuid = { version = "0.5", features = ["serde", "v4"] }</pre>
<p>We have added the <kbd>clap</kbd>, <kbd>r2d2</kbd>, and <kbd>serde</kbd> crates along with the <kbd>serde_derive</kbd> crate. We also need the <kbd>uuid</kbd> crate for generating user IDs. We also added the <kbd>diesel</kbd> crate with the following features:</p>
<ul>
<li><kbd>sqlite</kbd>: To adapt the crate to use the SQLite database</li>
<li><kbd>r2d2</kbd>: To use a pool instead of a plain connection</li>
</ul>
<p>The next thing you need is the <kbd>diesel_cli</kbd> tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">diesel_cli</h1>
                </header>
            
            <article>
                
<p><kbd>diesel_cli</kbd> is needed to create migrations and apply them. To install the tool, use <kbd>cargo</kbd> with the following parameters:</p>
<pre><strong>cargo install diesel_cli</strong></pre>
<p>However you need development packages for PostgreSQL, MySQL, and SQLite to build this tool. If you don't have or can't install them, you can pass special parameters to <kbd>cargo install</kbd>. For example, if you want to use <kbd>diesel_cli</kbd> with the example in this chapter, it's enough to install the tool with the <kbd>sqlite</kbd> feature only:</p>
<pre><strong>cargo install diesel_cli --no-default-features --features <span class="pl-s"><span class="pl-pds">"</span>sqlite<span class="pl-pds">"</span></span></strong></pre>
<p>When you have installed the <kbd>diesel-cli</kbd> tool, run it to prepare the application using the <kbd>setup</kbd> command to use the <kbd>diesel</kbd> crate:</p>
<pre><strong>diesel setup</strong></pre>
<p>Now, we have to prepare all the necessary migrations for our example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating migrations</h1>
                </header>
            
            <article>
                
<p>This command creates a <kbd>migrations</kbd> folder, where you can store migrations using the following command:</p>
<pre><strong>diesel migration generate &lt;name&gt;</strong></pre>
<p>This command creates a migration called <kbd>&lt;name&gt;</kbd> and stores it in the  <kbd>migrations</kbd> <span>folder</span>. For example, if you set the name of the created migration to <kbd>create_tables</kbd>, you will see in the following structure in the <kbd>migrations</kbd> folder:</p>
<pre>migrations/<br/>└── 2018-11-22-192300_create_tables/<br/>    ├── up.sql<br/>    └── down.sql</pre>
<p>For every migration, the <kbd>generate</kbd> command creates a folder and a pair of files:</p>
<ul>
<li><kbd>up.sql</kbd>: Statements for applying migrations</li>
<li><kbd>down.sql</kbd>: Statements for reverting migrations</li>
</ul>
<p>All migrations are handwritten. Add all the necessary statements for the migrations yourself. For our example, we need the following statements in the <kbd>up.sql</kbd> file:</p>
<pre>CREATE TABLE users (<br/>   id TEXT PRIMARY KEY NOT NULL,<br/>   name TEXT NOT NULL,<br/>   email TEXT NOT NULL<br/> );</pre>
<p>The opposite statement is in the <kbd>down.sql</kbd> file:</p>
<pre>DROP TABLE users;</pre>
<p>Applying the <kbd>up.sql</kbd> script creates the <kbd>users</kbd> database with the same struct we used in the previous chapter. The revert script drops the users table.</p>
<p>Now, we can create the database and apply all the migrations with this command:</p>
<pre><strong>DATABASE_URL=test.db diesel migration run</strong></pre>
<p>We set <kbd>DATABASE_URL</kbd> to <kbd>test.db</kbd> to create a SQLite database in the current folder. The <kbd>run</kbd> command runs all the migrations in order. You can have multiple migrations and move from one structure level to another, both forward and backward.</p>
<div class="packt_tip">Be careful! You can have multiple migrations, but you can't have competing migrations from different projects to the same database. The problem of automatic migrations is that you can't do it from multiple services, or you can't even start a microservice if it will try to migrate the database after another microservice has already migrated it.</div>
<p>We have created migrations, and now we have to declare the data structure in Rust sources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring the data structure</h1>
                </header>
            
            <article>
                
<p>Our tool will have two modules with a data structure. The first is the <kbd>src/schema.rs</kbd> module, which contains a <kbd>table!</kbd> macro call that declares the fields of every table. In our case, this module contains the following declaration:</p>
<pre>table! {<br/>    users (id) {<br/>        id -&gt; Text,<br/>        name -&gt; Text,<br/>        email -&gt; Text,<br/>    }<br/>}</pre>
<p>This file was automatically generated by the <kbd>diesel setup</kbd> command. When you run a setup, it creates a <kbd>diesel.toml</kbd> configuration file with the following contents:</p>
<pre># For documentation on how to configure this file,<br/># see diesel.rs/guides/configuring-diesel-cli<br/>[print_schema]<br/>file = "src/schema.rs"</pre>
<p>As you can see, the config has a schema module reference. A <kbd>schema.rs</kbd> file is also generated, and will be updated on every compilation. The <kbd>table!</kbd> macro creates the required declaration of DSL for the tables used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>Schema declaration defines a table structure only. To map tables to Rust types, you have to add a module with models that will be used to convert records from the <kbd>users</kbd> table to native Rust types. Let's create one and call it <kbd>models.rs</kbd>. It will contain the following code:</p>
<pre>use serde_derive::Serialize;<br/>use super::schema::users;<br/><br/>#[derive(Debug, Serialize, Queryable)]<br/>pub struct User {<br/>    pub id: String,<br/>    pub name: String,<br/>    pub email: String,<br/>}<br/><br/>#[derive(Insertable)]<br/>#[table_name = "users"]<br/>pub struct NewUser&lt;'a&gt; {<br/>    pub id: &amp;'a str,<br/>    pub name: &amp;'a str,<br/>    pub email: &amp;'a str,<br/>}</pre>
<p>We declared two models here: <kbd>User</kbd> to represent a user in a database and <kbd>NewUser</kbd> for creating a new record of a user. We derive the necessary traits for the <kbd>User</kbd> struct. The <kbd>Queryable</kbd> trait is implemented to allow you get this type from a database using queries.</p>
<p>There is the <kbd>Insertable</kbd> trait, which is derived from the <kbd>NewUser</kbd> struct. This trait allows a struct to be inserted as a new row in a table. This derivation requires an annotation with the name of the table. We can set it to the <kbd>users</kbd> table with the <kbd>#[table_name = "users"]</kbd> annotation.</p>
<p>The database structure has been prepared, and we can start to use the database from an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to a database</h1>
                </header>
            
            <article>
                
<p>In our tool, we will implement two subcommands—<kbd>add</kbd> to add a new user, and <kbd>list</kbd> to retrieve all available users from the database. Import all the necessary dependencies and add the modules with <kbd>schema</kbd> and <kbd>models</kbd>:</p>
<pre>extern crate clap;<br/>#[macro_use]<br/>extern crate diesel;<br/>extern crate failure;<br/>extern crate serde_derive;<br/><br/>use clap::{<br/>    crate_authors, crate_description, crate_name, crate_version,<br/>    App, AppSettings, Arg, SubCommand,<br/>};<br/>use diesel::prelude::*;<br/>use diesel::r2d2::ConnectionManager;<br/>use failure::Error;<br/><br/>pub mod models;<br/>pub mod schema;</pre>
<p>Since we are using the <kbd>r2d2</kbd> crate, we also have to import <kbd>ConnectionManager</kbd> to use diesel's abstraction over the traditional database connection.</p>
<div class="packt_tip">Modules declared with the <kbd>pub</kbd> modifier make them available in documentation. It's useful for modules that are <span>generated </span>by the <kbd>diesel</kbd> crate so that you can explore the functions <span>provided by</span> a generated DSL.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing arguments</h1>
                </header>
            
            <article>
                
<p>Similar to the examples in the previous chapter, we have a parser for arguments. It has the following declaration:</p>
<pre>let matches = App::new(crate_name!())<br/>    .version(crate_version!())<br/>    .author(crate_authors!())<br/>    .about(crate_description!())<br/>    .setting(AppSettings::SubcommandRequired)<br/>    .arg(<br/>        Arg::with_name("database")<br/>        .short("d")<br/>        .long("db")<br/>        .value_name("FILE")<br/>        .help("Sets a file name of a database")<br/>        .takes_value(true),<br/>        )<br/>    .subcommand(SubCommand::with_name(CMD_ADD).about("add user to the table")<br/>                .arg(Arg::with_name("NAME")<br/>                     .help("Sets the name of a user")<br/>                     .required(true)<br/>                     .index(1))<br/>                .arg(Arg::with_name("EMAIL")<br/>                     .help("Sets the email of a user")<br/>                     .required(true)<br/>                     .index(2)))<br/>    .subcommand(SubCommand::with_name(CMD_LIST).about("prints a list with users"))<br/>    .get_matches();</pre>
<p>We can get <kbd>--database</kbd> arguments with a path to a database file. The  <kbd>add</kbd> subcommand requires two arguments—<kbd>NAME</kbd> with the name of a user, and <kbd>EMAIL</kbd> with their email. The <kbd>list</kbd> subcommand doesn't require extra arguments and will print a <span>list of </span>users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a connection</h1>
                </header>
            
            <article>
                
<p>To create a connection, we extract the path to a database. Since we are using the SQLite database, in contrast to the previous examples, we don't expect a URL, but instead a path to a database file. That's why we use the <kbd>test.db</kbd> filename instead of a URL:</p>
<pre>let path = matches.value_of("database")<br/>     .unwrap_or("test.db");<br/> let manager = ConnectionManager::&lt;SqliteConnection&gt;::new(path);<br/> let pool = r2d2::Pool::new(manager)?;</pre>
<p><kbd>r2d2::Pool</kbd> requires a <kbd>ConnectionManager</kbd> instance to establish connections with a database, and we can provide <kbd>SqliteConnection</kbd> as an associated type to use the SQLite database. We provide a path to a database extracted from command-line arguments. Now let's look at how to use a generated DSL to interact with a database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing subcommands using a DSL</h1>
                </header>
            
            <article>
                
<p>The <kbd>diesel</kbd> crate generates a DSL for us to construct typed queries in a simple way. All instructions are generated as a submodule of schema and are available for every generated table mapping with a module path such as the following:</p>
<pre>use self::schema::users::dsl::*;</pre>
<p>Let's implement two commands using generated typed relations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a user subcommand implementation</h1>
                </header>
            
            <article>
                
<p>The first subcommand of our users management tool is <kbd>add</kbd>. This command extracts the <kbd>NAME</kbd> and <kbd>EMAIL</kbd> of the user from the arguments and generates a new user identifier using the <kbd>uuid</kbd> crate. We will use this type across all our microservices. Look at the following code:</p>
<pre>(CMD_ADD, Some(matches)) =&gt; {<br/>    let conn = pool.get()?;<br/>    let name = matches.value_of("NAME").unwrap();<br/>    let email = matches.value_of("EMAIL").unwrap();<br/>    let uuid = format!("{}", uuid::Uuid::new_v4());<br/>    let new_user = models::NewUser {<br/>        id: &amp;uuid,<br/>        name: &amp;name,<br/>        email: &amp;email,<br/>    };<br/>    diesel::insert_into(schema::users::table)<br/>        .values(&amp;new_user)<br/>        .execute(&amp;conn)?;<br/>}</pre>
<p>After we have extracted all the parameters, we create a <kbd>NewUser</kbd> instance from the <kbd>models</kbd> module. It requires references to values, and we don't need to pass ownership to values and reuse them in multiple requests.</p>
<p>The last line uses the <kbd>insert_into</kbd> function, which generates an <kbd>INSERT INTO</kbd> statement for the provided tables, but instead of textual names of tables, such as  <kbd>"users"</kbd>, we use the <kbd>table</kbd> <span>type </span>from the users <kbd>module</kbd> of schema. It helps you to see all the mistypes at compile time. We set the value for this request with the <kbd>values</kbd> function call. As a value, we use a reference to the <kbd>NewUser</kbd> instance because this map is already mapped to the <em><strong>users</strong></em> table in the struct declaration. To execute a statement, we call the <kbd>execute</kbd> function of the <kbd>InsertStatement</kbd> instance which is generated by the <kbd>values</kbd> method call.</p>
<p>The <kbd>execute</kbd> method expects a reference to a connection that we have already extracted from a pool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing users subcommand implementation</h1>
                </header>
            
            <article>
                
<p>In the previous example of data insertion, we didn't use the generated <kbd>users</kbd> type, and used the <kbd>table</kbd> nested type only. To list users in the implementation of the <kbd>list</kbd> subcommand, we will use types from the <kbd>dsl</kbd> submodule.</p>
<p>If you build some documentation and look into the <kbd>users::schema::users::dsl</kbd> <span>module, </span>you will see the following items:</p>
<pre>pub use super::columns::id;<br/>pub use super::columns::name;<br/>pub use super::columns::email;<br/>pub use super::table as users;</pre>
<p>All types are quite complex, and you can see all the features in the documentation. Since the <kbd>users</kbd> table type implements the <kbd>AsQuery</kbd> trait, we can use the <kbd>load</kbd> method of the <kbd>RunQueryDsl</kbd> trait for the <kbd>users</kbd> type. We set the associated type to <kbd>model::Users</kbd> to extract this type from the table. We also don't need any manual extractions like we did in the previous chapter. The <kbd>load</kbd> method expects a <kbd>Connection</kbd> that we <kbd>get</kbd> from a <kbd>Pool</kbd> instance<span><span>:</span></span></p>
<pre>(CMD_LIST, _) =&gt; {<br/>    use self::schema::users::dsl::*;<br/>    let conn = pool.get()?;<br/>    let mut items = users<br/>        .load::&lt;models::User&gt;(&amp;conn)?;<br/>    for user in items {<br/>        println!("{:?}", user);<br/>    }<br/>}</pre>
<p>Now, we can simply iterate over the users collections. That's pretty simple.</p>
<p>If you want to construct more complex requests, you can use other DSL functions that are generated by the <kbd>diesel</kbd> crate during building. For example, you can filter users by domain name and limit the quantity of users in a list with the following DSL expression:</p>
<pre>let mut items = users<br/>    .filter(email.like("%@example.com"))<br/>    .limit(10)<br/>    .load::&lt;models::User&gt;(&amp;conn)?;</pre>
<p>We have filtered all users by the <kbd>example.com</kbd> domain using the <kbd>filter</kbd> method with a parameter created by the <kbd>like</kbd> method call of the <kbd>email</kbd> column.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Let's test our tool. Compile and run it with the following commands:</p>
<pre><strong>cargo run -- add user1 user1@example.com</strong><br/><strong>cargo run -- add user2 user2@example.com</strong><br/><strong>cargo run -- add userx userx@xample.com</strong></pre>
<p>If you add filtering and call the <kbd>list</kbd> subcommand, you will see the following output:</p>
<pre><strong>cargo run -- list</strong><br/><strong>User { id: "a9ec3bae-c8c6-4580-97e1-db8f988f10f8", name: "user1", email: "user1@example.com" }</strong><br/><strong>User { id: "7f710d18-aea5-46f9-913c-b60d4e4529c9", name: "user2", email: "user2@example.com" }</strong></pre>
<p>We got a perfect example of mapping pure Rust types to relational database types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Complex database structure</h1>
                </header>
            
            <article>
                
<p>We have covered one example with a single table. In this section, we will create an example with a complex table structure to cover holistic database interaction. We will develop a separate crate for database interaction that covers the functionality of a complex chat application—chat with users, channels, and roles. Also, we will test the functionality we have implemented and show you how to test the database interaction layer of the Rust application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business logic of the example application</h1>
                </header>
            
            <article>
                
<p>In this section, we will learn how to transform data relations into ORM models. We will implement a database interaction crate for a chat application. Imagine, we need to express these data relations in Rust:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d814f00c-892e-439a-be5c-89a444c2afc9.png" style="width:46.00em;height:33.50em;"/></p>
<p>We have four tables. The first table contains users. It's the main table and is used by all the other tables. Every user can create a channel and become the owner of a channel. The second table contains channels, and every channel has the owner represented by a record in the <kbd>users</kbd> table.</p>
<p>In our chat application, every user can join a channel and post messages to it. To maintain this relation, we will add a <kbd>memberships</kbd> table that contains records with two references—a user who is a member of a channel and a channel record that contains a user as a member.</p>
<p>Also, users can post messages to channels. We will keep all messages in a separate <kbd>messages</kbd> table. Every message has two relations: the channel that contains the message and the user who posted the message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API methods</h1>
                </header>
            
            <article>
                
<p>To maintain the data, we need to provide the following methods:</p>
<ul>
<li><kbd>register_user</kbd>: Adds a new user to the <kbd>users</kbd> table</li>
<li><kbd>create_channel</kbd>: Creates a new channel with the provided user as the owner of the channel</li>
<li><kbd>publish_channel</kbd>: Makes the channel public</li>
<li><kbd>add_member</kbd>: Adds a member to a channel</li>
<li><kbd>add_message</kbd>: Adds a message from a user to a channel</li>
<li><kbd>delete_message</kbd>: Deletes a message</li>
</ul>
<p>You may have noticed that we don't have methods to delete a channel, but we have a method to delete a message. That's because users can post a message accidentally, which they may want to delete. Perhaps the user posts some private information that they want removed from the database.</p>
<p>We don't allow the deletion of channels and users, because they are an important part of the business logic. If user deletes a channel, then all the messages from other users will be deleted as well. It's not a behavior other users want.</p>
<div class="packt_tip">If you need a deleting feature, you can add a boolean column to every table that means the record was deleted. Don't delete the physical record, but mark it as deleted. You can add it yourself to this example. In real cases you also have to take into account the laws in the country that the user lives in, because they can require the physical deletion of records.</div>
<p>Now, we can express these relations in Rust with ORM using the <kbd>diesel</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database structure and migrations</h1>
                </header>
            
            <article>
                
<p>Let's start by creating the database structure. We need four tables:</p>
<ul>
<li><kbd>users</kbd>: Contains users' accounts</li>
<li><kbd>channels</kbd>: Contains channels created by users</li>
<li><kbd>memberships</kbd>: Users belonging to a channel</li>
<li><kbd>messages</kbd>: Messages of users in channels</li>
</ul>
<p>To add these tables, we will add four migrations to a new project:</p>
<pre><strong>cargo new --lib chat</strong><br/><strong>cd chat</strong><br/><strong>diesel setup</strong><br/><strong>diesel migration generate create_users</strong><br/><strong>diesel migration generate create_channels</strong><br/><strong>diesel migration generate create_memberships</strong><br/><strong>diesel migration generate create_messages</strong></pre>
<p>The preceding commands created these migrations:</p>
<pre>00000000000000_diesel_initial_setup<br/>2019-01-06-192329_create_users<br/>2019-01-06-192333_create_channels<br/>2019-01-06-192338_create_memberships<br/>2019-01-06-192344_create_messages</pre>
<p>As you may remember, every migration folder contains two files: <kbd>up.sql</kbd> and <kbd>down.sql</kbd>. Now, we can add SQL statements to execute the necessary migration operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diesel initial setup</h1>
                </header>
            
            <article>
                
<p>The first migration is <kbd>diesel_initial_setup</kbd>. It was created by the <kbd>diesel</kbd> CLI tool automatically and contains a function to set a trigger to update the <kbd>updated_at</kbd> column of a table. We will use this feature for the channel table. Like every migration, it consists of two files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">up.sql</h1>
                </header>
            
            <article>
                
<p>This SQL file contains two statements. The first is the <kbd>diesel_manage_updated_at</kbd> function, whichcreates a trigger for a table to call the <kbd>diesel_set_updated_at</kbd> function for each row update:</p>
<pre>CREATE OR REPLACE FUNCTION diesel_manage_updated_at(_tbl regclass) RETURNS VOID AS $$<br/>BEGIN<br/>    EXECUTE format('CREATE TRIGGER set_updated_at BEFORE UPDATE ON %s<br/>                    FOR EACH ROW EXECUTE PROCEDURE diesel_set_updated_at()', _tbl);<br/>END;<br/><strong>$$ LANGUAGE plpgsql;</strong></pre>
<p>This function only executes the <kbd>CREATE TRIGGER</kbd> statement for a table you provided with the <kbd>_tbl</kbd> argument.</p>
<p>The second function is <kbd>diesel_set_updated_at</kbd>, which updates the <kbd>updated_at</kbd> column with the current timestamp if the processed row has changed:</p>
<pre>CREATE OR REPLACE FUNCTION diesel_set_updated_at() RETURNS trigger AS $$<br/>BEGIN<br/>    IF (<br/>        NEW IS DISTINCT FROM OLD AND<br/>        NEW.updated_at IS NOT DISTINCT FROM OLD.updated_at<br/>    ) THEN<br/>        NEW.updated_at := current_timestamp;<br/>    END IF;<br/>    RETURN NEW;<br/>END;<br/>$$ LANGUAGE plpgsql;</pre>
<p>To make this function work, you have to add the <kbd>updated_at</kbd> column to your table and a field with the same name to your model. We will do this for the <kbd>channel</kbd> table later in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">down.sql</h1>
                </header>
            
            <article>
                
<p>The down script removes both functions, if they exist:</p>
<pre>DROP FUNCTION IF EXISTS diesel_manage_updated_at(_tbl regclass);<br/>DROP FUNCTION IF EXISTS diesel_set_updated_at();</pre>
<p><span><span>This </span></span>was a default migration created by the <kbd>diesel</kbd> tool. As you can see, it contains a functionality you can drop or replace with your own. Now, we can add the <kbd>users</kbd> table to the next migration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Users table</h1>
                </header>
            
            <article>
                
<p>The second migration is <kbd>create_users</kbd>. It creates a <kbd>users</kbd> table that is required to keep all the users' accounts in a database. To create this table, we create a separate migration that contains two scripts—one to create the <kbd>users</kbd> table and one to drop it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">up.sql</h1>
                </header>
            
            <article>
                
<p>Add the following statement to the <kbd>up.sql</kbd> script:</p>
<pre>CREATE TABLE users (<br/>  id SERIAL PRIMARY KEY,<br/>  email TEXT NOT NULL UNIQUE<br/>);</pre>
<p>As you can see, the table has two columns. <kbd>id</kbd> represents the unique ID of the user, and we will use this identifier in other tables later. The <kbd>email</kbd> column contains the unique e-mail of the user. For real applications, the <kbd>users</kbd> table also has to contain a hashed password, and two columns to store when the user was created and updated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">down.sql</h1>
                </header>
            
            <article>
                
<p>The down script drops the <kbd>users</kbd> table:</p>
<pre>DROP TABLE users;</pre>
<p>Now, we can use the users' IDs to create channels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Channels table</h1>
                </header>
            
            <article>
                
<p>The third migration is <kbd>create_channels</kbd>. It creates a <kbd>channels</kbd> table that contains all of the channels that have been created by users. Channels can be private or public, and each has a title. Let's look at a script that creates a table of channels in a database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">up.sql</h1>
                </header>
            
            <article>
                
<p>The up script contains a statement that creates the <kbd>channels</kbd> table. Columns includes the channel <kbd>id</kbd> and <kbd>user_id</kbd> , which refers to the user in the <kbd>users</kbd> table. The channel also has a <kbd>title</kbd> column and an <kbd>is_public</kbd> column that contains a flag that represents the visibility of the channel. If <kbd>is_public</kbd> equals <kbd>TRUE</kbd>, it means the channel is public. Look at the following statement:</p>
<pre>CREATE TABLE channels (<br/>  id SERIAL PRIMARY KEY,<br/>  user_id INTEGER NOT NULL REFERENCES users,<br/>  title TEXT NOT NULL,<br/>  is_public BOOL NOT NULL,<br/>  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,<br/>  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP<br/>);<br/><br/>SELECT diesel_manage_updated_at('channels');</pre>
<p>The table also has two columns—<kbd>create_at</kbd>, which takes the current timestamp when the row is created, and <kbd>updated_at</kbd>, which contains the timestamp of the latest update of the row. By default, the <kbd>updated_at</kbd> column takes the current timestamp as the default value on creation.</p>
<p>As we mentioned before, diesel creates a <kbd>diesel_manage_updated_at</kbd> function that sets a trigger to a table, which updates the <kbd>updated_at</kbd> column of rows automatically when the row is updated. Since we have the <kbd>updated_at</kbd> column in the table declaration, we can call this function in the <kbd>SELECT</kbd> statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">down.sql</h1>
                </header>
            
            <article>
                
<p>The down script drops the <kbd>channels</kbd> table:</p>
<pre>DROP TABLE channels;</pre>
<p>In the <kbd>up.sql</kbd> script,we created a trigger with a <kbd>diesel_manage_updated_at</kbd> call, but we don't need to drop it manually, because it is automatically removed with the table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memberships table</h1>
                </header>
            
            <article>
                
<p>The fourth migration is <kbd>create_memberships</kbd>. It creates a <kbd>memberships</kbd> table that is necessary to manage the participants of the channel who can read messages and write new ones. This table depends on both the <kbd>users</kbd> and <kbd>channels</kbd> tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">up.sql</h1>
                </header>
            
            <article>
                
<p>The <kbd>up</kbd> script is simple and contains a statement that creates the memberships table with three fields—the <kbd>id</kbd> of a membership, the <kbd>id</kbd> of a channel in the <kbd>channel_id</kbd> column whose member is a user with the <kbd>user_id</kbd> column:</p>
<pre>CREATE TABLE memberships (<br/>  id SERIAL PRIMARY KEY,<br/>  channel_id INTEGER NOT NULL REFERENCES channels,<br/>  user_id INTEGER NOT NULL REFERENCES users<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">down.sql</h1>
                </header>
            
            <article>
                
<p>The down script drops the table:</p>
<pre>DROP TABLE memberships;</pre>
<p>We now need to add a table that stores messages that users have posted to the channels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Messages table</h1>
                </header>
            
            <article>
                
<p>The fifth migration is <kbd>create_messages</kbd>. It creates a <kbd>messages</kbd> table that contains every message that has been written by the users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">up.sql</h1>
                </header>
            
            <article>
                
<p>Look at the following up script:</p>
<pre>CREATE TABLE messages (<br/>  id SERIAL PRIMARY KEY,<br/>  timestamp TIMESTAMP NOT NULL,<br/>  channel_id INTEGER NOT NULL REFERENCES channels,<br/>  user_id INTEGER NOT NULL REFERENCES users,<br/>  text TEXT NOT NULL<br/>);</pre>
<p>It creates a table that contains a message that is associated with a channel and a user by ID. Also, it contains a timestamp showing when the messages were added, as well as the text of each message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">down.sql</h1>
                </header>
            
            <article>
                
<p>The down script drops the table:</p>
<pre>DROP TABLE messages;</pre>
<p>We have finished all the migrations, and now we can look at the schema that was generated by the <kbd>diesel</kbd> tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Schema</h1>
                </header>
            
            <article>
                
<p><kbd>diesel</kbd> creates a schema file that contains macro calls that generate a DSL language to use in the sources of your crate. A schema of tables that have relations to each other need extra declarations. Let's explore a generated schema in the <kbd>src/schema.rs</kbd> file to see how it differs from the simple schema we created earlier in this chapter.</p>
<p>The first table is <kbd>users</kbd>. It has the same columns we declared in the SQL file:</p>
<pre>table! {<br/>    users (id) {<br/>        id -&gt; Int4,<br/>        email -&gt; Text,<br/>    }<br/>}</pre>
<p>The <kbd>table!</kbd> macro will be expanded during compilation to some type and trait implementations that you can see with the following command:</p>
<pre><strong>cargo rustc -- -Z unstable-options --pretty=expanded</strong></pre>
<p>This command prints all expanded macros to a Terminal.</p>
<p>The diesel tool has also generated a DSL declaration for the <kbd>channels</kbd> table:</p>
<pre>table! {<br/>    channels (id) {<br/>        id -&gt; Int4,<br/>        user_id -&gt; Int4,<br/>        title -&gt; Text,<br/>        is_public -&gt; Bool,<br/>        created_at -&gt; Timestamp,<br/>        updated_at -&gt; Timestamp,<br/>    }<br/>}</pre>
<p class="mce-root">For the <kbd>memberships</kbd> table, we have this declaration:</p>
<pre>table! {<br/>    memberships (id) {<br/>        id -&gt; Int4,<br/>        channel_id -&gt; Int4,<br/>        user_id -&gt; Int4,<br/>    }<br/>}</pre>
<p>And for the <kbd>messages</kbd> table<span>, we have this declaration</span>:</p>
<pre>table! {<br/>    messages (id) {<br/>        id -&gt; Int4,<br/>        timestamp -&gt; Timestamp,<br/>        channel_id -&gt; Int4,<br/>        user_id -&gt; Int4,<br/>        text -&gt; Text,<br/>    }<br/>}</pre>
<p>But you might have noticed that the table declarations don't contain any information about relations. Relations created by the <kbd>joinable!</kbd> macro expect a table name and a parent table with the ID column name:</p>
<p class="mce-root"/>
<pre>joinable!(channels -&gt; users (user_id));<br/>joinable!(memberships -&gt; channels (channel_id));<br/>joinable!(memberships -&gt; users (user_id));<br/>joinable!(messages -&gt; channels (channel_id));<br/>joinable!(messages -&gt; users (user_id));</pre>
<p>All relations are listed with the <kbd>joinable!</kbd> macro, but the schema also contains a <kbd>allow_tables_to_appear_in_same_query!</kbd> macro call that represents which tables can be used in <kbd>JOIN</kbd> queries:</p>
<pre>allow_tables_to_appear_in_same_query!(<br/>    channels,<br/>    memberships,<br/>    messages,<br/>    users,<br/>);</pre>
<p>Since we have a complete schema declaration with all relations, we can declare models with the same relations as native Rust structs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>Now, we can use the generated schema to create all the necessary models that represent database records to native Rust structs. First, we have to import the <kbd>NaiveDateTime</kbd> type, because we have the timestamp column. Also, we have to import all tables: <kbd>users</kbd>, <kbd>channels</kbd>, <kbd>memberships</kbd>, and <kbd>messages</kbd>:</p>
<pre>use chrono::NaiveDateTime;<br/>use crate::schema::{users, channels, memberships, messages};</pre>
<p>We will use the <kbd>i32</kbd> type as the identifier of records, but it's better to use an alias to make its intent more clear:</p>
<pre>pub type Id = i32;</pre>
<p>Let's add a model to represent a record in the <kbd>users</kbd> table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User</h1>
                </header>
            
            <article>
                
<p>To represent a user stored in the <kbd>users</kbd> table, we will add a <kbd>User</kbd> struct with the following declaration:</p>
<pre>#[derive(Debug, Identifiable, Queryable, Serialize, Deserialize)]<br/>#[table_name = "users"]<br/>pub struct User {<br/>    pub id: Id,<br/>    pub email: String,<br/>}</pre>
<p>As you can see, we use the <kbd>Id</kbd> type for the ID column that has the <kbd>SERIAL</kbd> SQL type. For the email field, we use the String type, which maps to the <kbd>TEXT</kbd> column type in PostgreSQL.</p>
<p>There is also the <kbd>table_name</kbd> attribute to bind this struct with a table. We also derive some traits for this model—<kbd>Debug</kbd> for printing the model's value to a terminal, and the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits to make this model convertible to any serialization format. Theser are basic traits that I recommend to implement for database models, especially if you want to use the same types in a REST API.</p>
<p>The <kbd>Queryable</kbd> trait represents the result of SQL expressions that can be converted in a struct that implements the trait. This lets us convert tuples to the <kbd>User</kbd> struct in our database interaction API later.</p>
<p>The <kbd>Identifiable</kbd> trait means the struct that implements this trait represents a single record in a table. This trait has an associated <kbd>Id</kbd> type that is set to the corresponding type in the SQL table. This trait also contains an <kbd>id</kbd> method that returns the identifier of a record in a table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Channel</h1>
                </header>
            
            <article>
                
<p>The next model is <kbd>Channel</kbd>, which represents a record in the <kbd>channels</kbd> table:</p>
<pre>#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]<br/>#[belongs_to(User)]<br/>#[table_name = "channels"]<br/>pub struct Channel {<br/>    pub id: Id,<br/>    pub user_id: Id,<br/>    pub title: String,<br/>    pub is_public: bool,<br/>    pub created_at: NaiveDateTime,<br/>    pub updated_at: NaiveDateTime,<br/>}</pre>
<p>This model binds to a table using the <kbd>table_name</kbd> attribute and contains all the fields that map to the corresponding columns of the table. To represent the <kbd>TIMESTAMP</kbd> SQL type, we use <kbd>NaiveDateTime</kbd> from the <kbd>chrono</kbd> crate.</p>
<p>The model has a <kbd>user_id</kbd> field that maps to a record in the <kbd>users</kbd> table. To indicate whether a <kbd>User</kbd> model belongs to the <kbd>users</kbd> table, we added the <kbd>belongs_to</kbd> attribute to this model. The model also has to implement the <kbd>Associations</kbd> trait. If the model does that, you can use the <kbd>belonging_to</kbd> method of a model to get records belonging to other records with a parental relation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Membership</h1>
                </header>
            
            <article>
                
<p>To represent records in the memberships model, we added the <kbd>Membership</kbd> model:</p>
<pre>#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]<br/>#[belongs_to(Channel)]<br/>#[belongs_to(User)]<br/>#[table_name = "memberships"]<br/>pub struct Membership {<br/>    pub id: Id,<br/>    pub channel_id: Id,<br/>    pub user_id: Id,<br/>}</pre>
<p>This model has set relations with the <kbd>Channel</kbd> and <kbd>User</kbd> models. For example, if you want to get all the memberships of a user, you can use the <kbd>belonging_to</kbd> method:</p>
<pre>let memberships = Membership::belonging_to(&amp;user)<br/>    .load::&lt;Membership&gt;(&amp;conn);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message</h1>
                </header>
            
            <article>
                
<p>The last model we need is <kbd>Message</kbd>, which relates to the records in the <kbd>messages</kbd> table:</p>
<pre>#[derive(Debug, Identifiable, Queryable, Associations, Serialize, Deserialize)]<br/>#[belongs_to(Channel)]<br/>#[belongs_to(User)]<br/>#[table_name = "messages"]<br/>pub struct Message {<br/>    pub id: Id,<br/>    pub timestamp: NaiveDateTime,<br/>    pub channel_id: Id,<br/>    pub user_id: Id,<br/>    pub text: String,<br/>}</pre>
<p>This model also uses derived traits which we discussed in the first example. Now, we can implement our database interaction crate using the generated schema and the declared models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database interaction API crate</h1>
                </header>
            
            <article>
                
<p>Let's add an implementation of the database interaction API to the <kbd>lib.rs</kbd> source file. We need to import the <kbd>diesel</kbd> crate and declare the module:</p>
<pre>#[macro_use]<br/>extern crate diesel;<br/><br/>mod models;<br/>mod schema;</pre>
<p>You can see that we have added two modules: <kbd>models</kbd> and <kbd>schema</kbd>. In the implementation, we need the following types:</p>
<pre>use diesel::{Connection, ExpressionMethods, OptionalExtension, PgConnection, QueryDsl, RunQueryDsl, insert_into};<br/>use chrono::Utc;<br/>use failure::{Error, format_err};<br/>use self::models::{Channel, Id, Membership, Message, User};<br/>use self::schema::{channels, memberships, messages, users};<br/>use std::env;</pre>
<p>The imports include all models and all tables. We also imported the <kbd>Connection</kbd> trait to the <kbd>establish</kbd> connection, <span>the </span><kbd>ExpressionMethods</kbd> trait to use <span>the </span><kbd>eq</kbd> method of DSL to set the equality of columns to values, <span>the </span><kbd>OptionalExtension</kbd> trait to use <span>the </span><kbd>optional</kbd> method to try to get a record that cannot be in a table, <span>the </span><kbd>QueryDsl</kbd> trait that has <span>the </span><kbd>filter</kbd> method, and <kbd>RunQueryDsl</kbd> to use <span>the </span><kbd>get_result</kbd> method that tries to convert a record to the Rust type. The <kbd>insert_into</kbd> method lets us insert new records into a table. Now, we have everything we need to declare the <kbd>Api</kbd> struct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Api</h1>
                </header>
            
            <article>
                
<p>We will declare a struct with a connection instance inside and add methods over this connection:</p>
<pre>pub struct Api {<br/>    conn: PgConnection,<br/>}</pre>
<p>The <kbd>Api</kbd> struct can be created with the <kbd>connect</kbd> method, which uses the <kbd>DATABASE_URL</kbd> <span>environment variable </span>to bootstrap a connection to PostgreSQL:</p>
<pre>impl Api {<br/>    pub fn connect() -&gt; Result&lt;Self, Error&gt; {<br/>        let database_url = env::var("DATABASE_URL")<br/>            .unwrap_or("postgres://postgres@localhost:5432".to_string());<br/>        let conn = PgConnection::establish(&amp;database_url)?;<br/>        Ok(Self { conn })<br/>    }<br/>}</pre>
<p>We use a direct connection here without an <kbd>r2d2</kbd> pool, but you can also make <span>the </span><kbd>Api</kbd> struct compatible with concurrent access. Let's add first <span>the </span>API method for registering new users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Register user</h1>
                </header>
            
            <article>
                
<p>To register a new user with an email address, add the following method:</p>
<pre>pub fn register_user(&amp;self, email: &amp;str) -&gt; Result&lt;User, Error&gt; {<br/>    insert_into(users::table)<br/>        .values((<br/>                users::email.eq(email),<br/>                ))<br/>        .returning((<br/>                users::id,<br/>                users::email<br/>                ))<br/>        .get_result(&amp;self.conn)<br/>        .map_err(Error::from)<br/>}</pre>
<p>The <kbd>register_user</kbd> function expects a string with <span>the </span>email of a user, adds a record to a database, and returns a <kbd>User</kbd> instance, which represents a record in the <kbd>users</kbd> table.</p>
<p>We use <span>the </span><kbd>insert_into</kbd> method with a table type from <span>the </span>users scope, which is automatically created by <span>the </span><kbd>table!</kbd> macro in <span>the </span><kbd>schema</kbd> module. This method returns an <kbd>IncompleteInsertStatement</kbd> instance that provides a <kbd>values</kbd> method to set values with an <kbd>INSERT</kbd> statement. We set <span>the </span><kbd>email</kbd> column equal to <span>the </span><kbd>email</kbd> variable. T<span>he </span><kbd>values</kbd> method call returns an <kbd>InsertStatement</kbd> type instance that has <span>the </span><kbd>returning</kbd> method to set columns that will be returned with this statement. We set the returning values to <span>the </span><kbd>id</kbd> and <kbd>email</kbd> columns of <span>the </span><kbd>users</kbd> table. T<span>he </span><kbd>returning</kbd> method takes ownership of a statement and returns a new <kbd>InsertStatement</kbd> instance with <span>the </span>returning values.</p>
<p>At the end, we call <span>the </span><kbd>get_result</kbd> method of <span>the </span><kbd>InsertStatement</kbd> struct to execute <span>the </span>statement and convert <span>the </span>result to <span>the </span><kbd>User</kbd> model. Because we have a different error type of <kbd>Result</kbd>, we have to convert <span>the </span><kbd>diesel::result::Error</kbd> type returned by <span>the </span><kbd>get_result</kbd>, method call to <span>the </span><kbd>failure::Error</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create channel</h1>
                </header>
            
            <article>
                
<p>The next method is <kbd>create_channel</kbd>, which creates a new channel for a user. Take a look at the implementation:</p>
<pre>pub fn create_channel(&amp;self, user_id: Id, title: &amp;str, is_public: bool)<br/>    -&gt; Result&lt;Channel, Error&gt;<br/>{<br/>    self.conn.transaction::&lt;_, _, _&gt;(|| {<br/>        let channel: Channel = insert_into(channels::table)<br/>            .values((<br/>                    channels::user_id.eq(user_id),<br/>                    channels::title.eq(title),<br/>                    channels::is_public.eq(is_public),<br/>                    ))<br/>            .returning((<br/>                    channels::id,<br/>                    channels::user_id,<br/>                    channels::title,<br/>                    channels::is_public,<br/>                    channels::created_at,<br/>                    channels::updated_at,<br/>                    ))<br/>            .get_result(&amp;self.conn)<br/>            .map_err(Error::from)?;<br/>        self.add_member(channel.id, user_id)?;<br/>        Ok(channel)<br/>    })<br/>}</pre>
<p>The function expects <kbd>user_id</kbd>, <span>the </span><kbd>title</kbd> of a channel, and <span>the </span><kbd>is_public</kbd> flag, which means the channel is public.</p>
<p>Since we have to add <span>the </span>user who created the channel as the first member of a created channel, we will join two statements to a single transaction. To create a transaction with <kbd>diesel</kbd>, you can use <span>the </span><kbd>transaction</kbd> method of the <kbd>Connection</kbd> instance. This method expects three type parameters—successful value type, error value type, and a type of a closure provided as a single argument with a function call. We skip all types, because <span>the </span>compiler can detect them.</p>
<p>In <span>the </span>transaction implementation we create a <kbd>Channel</kbd> model instance that represents a new record in a database. After that, we use <span>the </span><kbd>add_member</kbd> method of our <kbd>Api</kbd> struct. As you can see, neither the transaction and connection instances need a mutable reference, and we can combine multiple methods to get an immutable reference to a <kbd>Connection</kbd> instance. You will see the implementation of <span>the </span><kbd>add_member</kbd> method later, but now we will add a method to update a channel's record in a table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publish channel</h1>
                </header>
            
            <article>
                
<p>We will add a method that sets <span>the </span><kbd>is_public</kbd> flag of a channel record to <kbd>true</kbd>. Look at the following implementation:</p>
<pre>pub fn publish_channel(&amp;self, channel_id: Id) -&gt; Result&lt;(), Error&gt; {<br/>    let channel = channels::table<br/>        .filter(channels::id.eq(channel_id))<br/>        .select((<br/>                channels::id,<br/>                channels::user_id,<br/>                channels::title,<br/>                channels::is_public,<br/>                channels::created_at,<br/>                channels::updated_at,<br/>                ))<br/>        .first::&lt;Channel&gt;(&amp;self.conn)<br/>        .optional()<br/>        .map_err(Error::from)?;<br/>    if let Some(channel) = channel {<br/>        diesel::update(&amp;channel)<br/>            .set(channels::is_public.eq(true))<br/>            .execute(&amp;self.conn)?;<br/>        Ok(())<br/>    } else {<br/>        Err(format_err!("channel not found"))<br/>    }<br/>}</pre>
<p>The function expects <kbd>channel_id</kbd>, and we use <span>the </span><kbd>table</kbd> value to create a statement. We use <span>the </span><kbd>filter</kbd> method of <span>the </span><kbd>QueryDsl</kbd> trait to get a single record with <span>the </span>provided ID, and <span>the </span><kbd>select</kbd> method of the same trait to extract values from <span>the </span>table needed for conversion to <span>the </span><kbd>Channel</kbd> model instance. Then, we call <span>the </span><kbd>first</kbd> method that returns <span>the </span>first record found with <span>the </span>executed statement. If no record is found, it will return an error, but since <kbd>Result</kbd> types are returned, we can drop the error part of this by converting it in <kbd>Option</kbd> with the <kbd>optional</kbd> method call. It lets us decide later what to do if a record hasn't been found later.</p>
<p>If a record is found, we use <span>the </span><kbd>update</kbd> method with a reference to a <kbd>Channel</kbd> model. This call returns an <kbd>UpdateStatement</kbd> value, which has a <kbd>set</kbd> method that we use to set <span>the </span><kbd>is_public</kbd> column to <kbd>true</kbd>. At the end, we <kbd>execute</kbd> this statement for a connection instance. This call also updates <span>the </span><kbd>updated_at</kbd> column of the record automatically since we registered a trigger for <span>the </span><kbd>channels</kbd> table. Now, we can implement <span>the </span><kbd>add_member</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add member</h1>
                </header>
            
            <article>
                
<p>The <kbd>add_member</kbd> function requires a channel ID and a user ID to add a membership record to <span>the </span><kbd>memberships</kbd> table:</p>
<pre>pub fn add_member(&amp;self, channel_id: Id, user_id: Id)<br/>    -&gt; Result&lt;Membership, Error&gt;<br/>{<br/>    insert_into(memberships::table)<br/>        .values((<br/>                memberships::channel_id.eq(channel_id),<br/>                memberships::user_id.eq(user_id),<br/>                ))<br/>        .returning((<br/>                memberships::id,<br/>                memberships::channel_id,<br/>                memberships::user_id,<br/>                ))<br/>        .get_result(&amp;self.conn)<br/>        .map_err(Error::from)<br/>}</pre>
<p>The implementation is simple and it uses <span>the </span><kbd>insert_into</kbd> function call to prepare <span>the </span><kbd>INSERT</kbd> statement to insert a new <kbd>Membership</kbd> value in the table. We also need a function to add new messages to a channel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add message</h1>
                </header>
            
            <article>
                
<p>The <kbd>add_message</kbd> method adds a message related to a channel and a user to <span>the </span><kbd>messages</kbd> table:</p>
<pre>pub fn add_message(&amp;self, channel_id: Id, user_id: Id, text: &amp;str)<br/>    -&gt; Result&lt;Message, Error&gt;<br/>{<br/>    let timestamp = Utc::now().naive_utc();<br/>    insert_into(messages::table)<br/>        .values((<br/>                messages::timestamp.eq(timestamp),<br/>                messages::channel_id.eq(channel_id),<br/>                messages::user_id.eq(user_id),<br/>                messages::text.eq(text),<br/>                ))<br/>        .returning((<br/>                messages::id,<br/>                messages::timestamp,<br/>                messages::channel_id,<br/>                messages::user_id,<br/>                messages::text,<br/>                ))<br/>        .get_result(&amp;self.conn)<br/>        .map_err(Error::from)<br/>}</pre>
<p>The implementation also uses <span>the </span><kbd>insert_into</kbd> function, but we also created <span>the </span>timestamp manually. You can avoid setting this field manually and set a default value to the current timestamp in <span>the </span><kbd>timestamp</kbd> column.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delete message</h1>
                </header>
            
            <article>
                
<p>If you posted a message and decided to remove it, we need a method to delete messages from <kbd>messages</kbd> table. Look at <kbd>delete_message</kbd> method implementation:</p>
<pre>pub fn delete_message(&amp;self, message_id: Id) -&gt; Result&lt;(), Error&gt; {<br/>    diesel::delete(messages::table)<br/>        .filter(messages::id.eq(message_id))<br/>        .execute(&amp;self.conn)?;<br/>    Ok(())<br/>}</pre>
<p>This function uses <span>the </span><kbd>delete</kbd> method, which returns a <kbd>DeleteStatement</kbd> instance, which has a <kbd>filter</kbd> method as well. We set a filter with <span>the </span><kbd>id</kbd> column equal to <span>the </span>provided <kbd>message_id</kbd> and execute <span>the </span>generated <kbd>DELETE</kbd> SQL statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the crate</h1>
                </header>
            
            <article>
                
<p>That's all, and now we have a crate that can be used to interact with a database. Since it's not binary, we need to guarantee that the code works correctly. It's a good practice to cover your code with tests, and we will do that now.</p>
<p>Add the following code to <span>the </span><kbd>lib.rs</kbd> file:</p>
<pre>#[cfg(test)]<br/>mod tests {<br/>    use super::Api;<br/><br/>    #[test]<br/>    fn create_users() {<br/>        let api = Api::connect().unwrap();<br/>        let user_1 = api.register_user("user_1@example.com").unwrap();<br/>        let user_2 = api.register_user("user_2@example.com").unwrap();<br/>        let channel = api.create_channel(user_1.id, "My Channel", false).unwrap();<br/>        api.publish_channel(channel.id).unwrap();<br/>        api.add_member(channel.id, user_2.id).unwrap();<br/>        let message = api.add_message(channel.id, user_1.id, "Welcome!").unwrap();<br/>        api.add_message(channel.id, user_2.id, "Hi!").unwrap();<br/>        api.delete_message(message.id).unwrap();<br/>    }<br/>}</pre>
<p>We added a <kbd>test</kbd> module and a <kbd>create_users</kbd> testing function. This function tests all <span>the </span>API methods we implemented. It creates an <kbd>Api</kbd> instance with a connect method call and uses that instance to register two users with the following emails—<kbd>"user_1@example.com"</kbd> and <kbd>"user_2@example.com"</kbd>. After that, it creates a channel for the first user, publishes it, and add the second user as a member. At the end, it adds two messages and deletes <span>the </span>first one. Let's run this test, but you have to run a PostgreSQL database instance with Docker. You can read how to do this in the previous chapter.</p>
<p>Apply all <span>the </span>migrations and run the test:</p>
<pre><strong>DATABASE_URL=postgres://postgres@localhost:5432 diesel migration run &amp;&amp; cargo test</strong></pre>
<p>When the testing is over, you will get a message with from <span>the </span><kbd>psql</kbd> client:</p>
<pre><strong>postgres=# select * from messages;</strong><br/><strong> id | timestamp | channel_id | user_id | text </strong><br/><strong>----+----------------------------+------------+---------+------</strong><br/><strong> 2 | 2019-01-08 18:30:48.465001 | 1 | 2 | Hi!</strong><br/><strong>(1 row)</strong></pre>
<p>As you can see, <span>the </span>test added two records and removed the first. In <a href="1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml">Chapter 13</a>, <em>Testing and Debugging Rust Microservices</em>, we will discuss testing microservices in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to use object-relational mapping to store and load pure Rust types to databases. First, we created migrations with <span>the </span><kbd>diesel-cli</kbd> tool that comes with the <kbd>diesel</kbd> crate. After that, we added models to map columns to Rust types and created a minimal connection using <span>the </span><kbd>r2d2</kbd> crate with a <kbd>diesel</kbd> crate abstraction.</p>
<p>We also touched on DSL constructs. however <span>the </span><kbd>diesel</kbd> crate provides a lot of features, and if you want to construct more complex queries, you can refer to the documentation.</p>
<p>In the next chapter, we will learn about some frameworks that simplify writing microservices and let you implement your ideas faster.</p>


            </article>

            
        </section>
    </body></html>