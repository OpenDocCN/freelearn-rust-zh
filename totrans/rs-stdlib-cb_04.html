<html><head></head><body>
        

                            
                    <h1 class="header-title">Serialization</h1>
                
            
            
                
<p> In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Working with CSV</li>
<li>Serialization basics with Serde</li>
<li>Working with TOML</li>
<li class="mce-root">Working with JSON</li>
<li class="mce-root">Building JSON dynamically</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Reinventing the wheel doesn't make sense. A great deal of functionality has already been provided by many programs that are more than happy to interact with your program. Of course, this offer is worthless if you're not able to communicate with them.</p>
<p>In this chapter, we are going to look at the most important formats in the Rust ecosystem in order to enable you to comfortably speak with other services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with CSV</h1>
                
            
            
                
<p>A nice and simple way to store uncomplicated and small datasets is CSV. This format is also of interest if you're working with spreadsheet applications such as Microsoft Excel, as they have excellent support for importing and exporting various flavors of CSV.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>You probably already know what a CSV is, but a little refresher won't hurt.</p>
<p>The idea of the format is to take a table of values and write all rows down as <em>records</em>. Inside a record, every column item is written down and separated by a comma. That's where the format's name comes from—comma-separated values.</p>
<p>Let's do an example. In the following code, we are going to write a CSV comparing various planets in the solar system to our own. A radius, distance from the sun, and gravity of <kbd>1</kbd> means <em>exactly as on earth</em>. Written as a table, our values look like this:</p>
<table>
<tbody>
<tr>
<td><strong>name</strong></td>
<td><strong>radius</strong></td>
<td><strong>distance_from_sun</strong></td>
<td><strong>gravity</strong></td>
</tr>
<tr>
<td>Mercury</td>
<td>0.38</td>
<td>0.47</td>
<td>0.38</td>
</tr>
<tr>
<td>Venus</td>
<td>0.95</td>
<td>0.73</td>
<td>0.9</td>
</tr>
<tr>
<td>Earth</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Mars</td>
<td>0.53</td>
<td>1.67</td>
<td>0.38</td>
</tr>
<tr>
<td>Jupiter</td>
<td>11.21</td>
<td>5.46</td>
<td>2.53</td>
</tr>
<tr>
<td>Saturn</td>
<td>9.45</td>
<td>10.12</td>
<td>1.07</td>
</tr>
<tr>
<td>Uranus</td>
<td>4.01</td>
<td>20.11</td>
<td>0.89</td>
</tr>
<tr>
<td>Neptune</td>
<td>3.88</td>
<td>30.33</td>
<td>1.14</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Take every row, separate the values by commas, put them each on a separate line, and you end up with the CSV file:</p>
<pre>name,radius,distance_from_sun,gravity<br/>Mercury,0.38,0.47,0.38<br/>Venus,0.95,0.73,0.9<br/>Earth,1,1,1<br/>Mars,0.53,1.67,0.38<br/>Jupiter,11.21,5.46,2.53<br/>Saturn,9.45,10.12,1.07<br/>Uranus,4.01,20.11,0.89<br/>Neptune,3.88,30.33,1.14</pre>
<p>As you can see, the heading ( <kbd>planet,radius,distance_from_sun,gravity</kbd>) is simply written as the first record.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a Rust project to work on during this chapter with <kbd>cargo new chapter_four</kbd>.</li>
<li>Navigate into the newly-created <kbd>chapter_four</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory.</li>
<li>Inside the <kbd>src</kbd> folder, create a new folder called <kbd>bin</kbd>.</li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library.</li>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px"> csv = "1.0.0-beta.5"</pre>
<ol start="7">
<li>If you want, you can go to <kbd>csv</kbd>'s crates.io page (<a href="https://crates.io/crates/csv">https://crates.io/crates/csv</a>) to check for the newest version and use that one instead.</li>
<li>In the <kbd>src/bin</kbd> folder, create a file called <kbd>csv.rs</kbd></li>
<li>Add the following code and run it with <kbd>cargo run --bin csv</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1    extern crate csv;<br/>2 <br/>3    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom,<br/>  Write};<br/>4    use std::fs::OpenOptions;<br/>5 <br/>6    fn main() {<br/>7      let file = OpenOptions::new()<br/>8        .read(true)<br/>9        .write(true)<br/>10       .create(true)<br/>11       .open("solar_system_compared_to_earth.csv")<br/>12       .expect("failed to create csv file");<br/>13 <br/>14     let buf_writer = BufWriter::new(&amp;file);<br/>15     write_records(buf_writer).expect("Failed to write csv");<br/>16 <br/>17     let mut buf_reader = BufReader::new(&amp;file);<br/>18     buf_reader<br/>19       .seek(SeekFrom::Start(0))<br/>20       .expect("Failed to jump to the beginning of the csv");<br/>21     read_records(buf_reader).expect("Failed to read csv");<br/>22   }<br/>23 <br/>24   fn write_records&lt;W&gt;(writer: W) -&gt; csv::Result&lt;()&gt;<br/>25   where<br/>26   W: Write,<br/>27   {<br/>28     let mut wtr = csv::Writer::from_writer(writer);<br/>29 <br/>30     // The header is just a normal record<br/>31     wtr.write_record(&amp;["name", "radius", "distance_from_sun", <br/>32     "gravity"])?;<br/>33 <br/>34     wtr.write_record(&amp;["Mercury", "0.38", "0.47", "0.38"])?;<br/>35     wtr.write_record(&amp;["Venus", "0.95", "0.73", "0.9"])?;<br/>36     wtr.write_record(&amp;["Earth", "1", "1", "1"])?;<br/>37     wtr.write_record(&amp;["Mars", "0.53", "1.67", "0.38"])?;<br/>38     wtr.write_record(&amp;["Jupiter", "11.21", "5.46", "2.53"])?;<br/>39     wtr.write_record(&amp;["Saturn", "9.45", "10.12", "1.07"])?;<br/>40     wtr.write_record(&amp;["Uranus", "4.01", "20.11", "0.89"])?;<br/>41     wtr.write_record(&amp;["Neptune", "3.88", "30.33", "1.14"])?;<br/>42     wtr.flush()?;<br/>43     Ok(())<br/>44   }<br/>45 <br/>46   fn read_records&lt;R&gt;(reader: R) -&gt; csv::Result&lt;()&gt;<br/>47   where<br/>48   R: Read,<br/>49   {<br/>50     let mut rdr = csv::Reader::from_reader(reader);<br/>51     println!("Comparing planets in the solar system with the <br/>52     earth");<br/>53     println!("where a value of '1' means 'equal to earth'");<br/>54     for result in rdr.records() {<br/>55       println!("-------");<br/>56       let record = result?;<br/>57       if let Some(name) = record.get(0) {<br/>58         println!("Name: {}", name);<br/>59       }<br/>60       if let Some(radius) = record.get(1) {<br/>61         println!("Radius: {}", radius);<br/>62       }<br/>63       if let Some(distance) = record.get(2) {<br/>64         println!("Distance from sun: {}", distance);<br/>65       }<br/>66       if let Some(gravity) = record.get(3) {<br/>67         println!("Surface gravity: {}", gravity);<br/>68       }<br/>69     }<br/>70     Ok(())<br/>71   }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First of all, we prepare our file[9] and its <kbd>OpenOptions</kbd> so that we have both <kbd>read</kbd> and <kbd>write</kbd> access on the file. You will remember this from <a href="6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml" target="_blank">Chapter 3</a>, <em>Handling Files and the Filesystem</em>; <em>Working with text files</em>. </p>
<p>Then we write the CSV. We do this by wrapping any kind of <kbd>Write</kbd> in a <kbd>csv::Writer</kbd>[30]. You can then use <kbd>write_record</kbd> on it to write any data type that can be represented as an iterator over <kbd>&amp;[u8]</kbd>. Most of the time, this will simply be an array of strings.</p>
<p>While reading, we similarly wrap a <kbd>Read</kbd> in a <kbd>csv::Read</kbd>. The <kbd>records()</kbd> method returns an iterator over <kbd>Result</kbd> of <kbd>StringRecord</kbd>. This way, you get to decide how to handle a malformed record. In our example, we simply skip it. Lastly, we call <kbd>get()</kbd> on a record to get a certain field. If there was no entry at the specified index or if it was out of bounds, this would return <kbd>None</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you need to read or write a custom CSV format, like one that uses tabs instead of commas as a delimiter, you can use <kbd>WriterBuilder</kbd> and <kbd>ReaderBuilder</kbd> to customize the expected format. Remember this well if you're planning on using Microsoft Excel, as it has the annoying tendency to be regionally inconsistent in its choice of delimiters (<a href="https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon">https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon</a>).</p>
<p>When working with CSV and Microsoft Excel, be careful and sanitize your data before handing it to Excel. Even though CSV is defined as plain data with no control identifiers, Excel will interpret and execute macros when importing CSV. For examples of possible attack vectors opened by this, see <a href="http://georgemauer.net/2017/10/07/csv-injection.html">http://georgemauer.net/2017/10/07/csv-injection.html</a>.</p>
<p>This is also useful if a Windows application refuses to accept the <kbd>\n</kbd> terminator that <kbd>csv</kbd> uses as per default. In this case, simply specify the following code in the builder to use the Windows-native <kbd>\r\n</kbd> terminator:</p>
<pre class="rust rust-example-rendered" style="padding-left: 30px">.terminator(csv::Terminator::CRLF)</pre>
<p>The <kbd>csv</kbd> crate allows you to manipulate your data much more than what is shown in this recipe. You can, for example, insert new fields on the fly into a <kbd>StringRecord</kbd>. We deliberately don't explore these possibilities in detail as the CSV format is not meant for these kinds of data manipulation. If you need to do more than simple import/export, you should use a more suitable format, such as JSON, which we will explore in this chapter as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Using the builder pattern</em> recipe in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><em>Working with text files</em> recipe in <a href="6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml" target="_blank">Chapter 3</a>, <em>Handling Files and the Filesystem</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Serialization basics with Serde</h1>
                
            
            
                
<p>The <em>de facto</em> standard for all things serialization in Rust is the Serde framework. All the other recipes in this chapter are going to use it to some extent. In order to make you familiar with the Serde way of doing things, we are going to rewrite the last recipe using it. Later in the chapter, we will learn in detail how Serde works in order to implement idiomatic deserialization into a homemade format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following lines:</li>
</ol>
<pre style="padding-left: 60px">serde = "1.0.24"<br/>serde_derive = "1.0.24"</pre>
<ol start="3">
<li>If you haven't done so already in the last recipe, add the following line as well:</li>
</ol>
<pre style="padding-left: 60px">csv = "1.0.0-beta.5"<br/></pre>
<ol start="4">
<li>If you want, you can go to the crates.io web pages for Serde (<a href="https://crates.io/crates/serde">https://crates.io/crates/serde</a>), <kbd>serde_derive</kbd> (<a href="https://crates.io/crates/serde_derive">https://crates.io/crates/serde_derive</a>), and CSV (<a href="https://crates.io/crates/csv">https://crates.io/crates/csv</a>) to check for the newest versions and use those ones instead.</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>serde_csv.rs</kbd>.</p>
</li>
</ol>
<p> </p>
<p> </p>
<ol start="4">
<li>
<p>Add the following code and run it with <kbd>cargo run --bin serde_csv</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    extern crate csv;<br/>2    extern crate serde;<br/>3    #[macro_use]<br/>4    extern crate serde_derive;<br/>5 <br/>6    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, <br/>     Write};<br/>7    use std::fs::OpenOptions;<br/>8 <br/>9    #[derive(Serialize, Deserialize)]<br/>10   struct Planet {<br/>11     name: String,<br/>12     radius: f32,<br/>13     distance_from_sun: f32,<br/>14     gravity: f32,<br/>15   }<br/>16 <br/>17   fn main() {<br/>18     let file = OpenOptions::new()<br/>19       .read(true)<br/>20       .write(true)<br/>21       .create(true)<br/>22       .open("solar_system_compared_to_earth.csv")<br/>23       .expect("failed to create csv file");<br/>24 <br/>25     let buf_writer = BufWriter::new(&amp;file);<br/>26     write_records(buf_writer).expect("Failed to write csv");<br/>27 <br/>28     let mut buf_reader = BufReader::new(&amp;file);<br/>29     buf_reader<br/>30       .seek(SeekFrom::Start(0))<br/>31       .expect("Failed to jump to the beginning of the csv");<br/>32     read_records(buf_reader).expect("Failed to read csv");<br/>33   }<br/>34 <br/>35   fn write_records&lt;W&gt;(writer: W) -&gt; csv::Result&lt;()&gt;<br/>36   where<br/>37   W: Write,<br/>38  {<br/>39     let mut wtr = csv::Writer::from_writer(writer);<br/>40 <br/>41     // No need to specify a header; Serde creates it for us<br/>42     wtr.serialize(Planet {<br/>43       name: "Mercury".to_string(),<br/>44       radius: 0.38,<br/>45       distance_from_sun: 0.47,<br/>46       gravity: 0.38,<br/>47     })?;<br/>48     wtr.serialize(Planet {<br/>49       name: "Venus".to_string(),<br/>50       radius: 0.95,<br/>51       distance_from_sun: 0.73,<br/>52       gravity: 0.9,<br/>53     })?;<br/>54     wtr.serialize(Planet {<br/>55       name: "Earth".to_string(),<br/>56       radius: 1.0,<br/>57       distance_from_sun: 1.0,<br/>58       gravity: 1.0,<br/>59     })?;<br/>60     wtr.serialize(Planet {<br/>61       name: "Mars".to_string(),<br/>62       radius: 0.53,<br/>63       distance_from_sun: 1.67,<br/>64       gravity: 0.38,<br/>65     })?;<br/>66     wtr.serialize(Planet {<br/>67       name: "Jupiter".to_string(),<br/>68       radius: 11.21,<br/>69       distance_from_sun: 5.46,<br/>70       gravity: 2.53,<br/>71     })?;<br/>72     wtr.serialize(Planet {<br/>73       name: "Saturn".to_string(),<br/>74       radius: 9.45,<br/>75       distance_from_sun: 10.12,<br/>76       gravity: 1.07,<br/>77    })?;<br/>78    wtr.serialize(Planet {<br/>79      name: "Uranus".to_string(),<br/>80      radius: 4.01,<br/>81      distance_from_sun: 20.11,<br/>82      gravity: 0.89,<br/>83    })?;<br/>84    wtr.serialize(Planet {<br/>85      name: "Neptune".to_string(),<br/>86      radius: 3.88,<br/>87      distance_from_sun: 30.33,<br/>88      gravity: 1.14,<br/>89    })?;<br/>90    wtr.flush()?;<br/>91    Ok(())<br/>92  }<br/>93 <br/>94  fn read_records&lt;R&gt;(reader: R) -&gt; csv::Result&lt;()&gt;<br/>95  where<br/>96  R: Read,<br/>97  {<br/>98    let mut rdr = csv::Reader::from_reader(reader);<br/>99    println!("Comparing planets in the solar system with the <br/>   earth");<br/>100   println!("where a value of '1' means 'equal to earth'");<br/>101   for result in rdr.deserialize() {<br/>102     println!("-------");<br/>103     let planet: Planet = result?;<br/>104     println!("Name: {}", planet.name);<br/>105     println!("Radius: {}", planet.radius);<br/>106     println!("Distance from sun: {}", planet.distance_from_sun);<br/>107     println!("Surface gravity: {}", planet.gravity);<br/>108   }<br/>109   Ok(())<br/>110 }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The code in this recipe reads and writes the exact same CSV as the last recipe. The only difference is how we treat a single record. Serde helps us by enabling us to use plain old Rust structures for this. The only thing we need to do is derive our <kbd>Planet</kbd> structure from <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> [9]. The rest is taken care of automatically by Serde.</p>
<p>Because we now use actual Rust structures to represent a planet, we create a record by calling <kbd>serialize</kbd> with a structure instead of <kbd>write_record</kbd> as before [42]. Looks way more readable, doesn't it? If you think that the example became a little bit too verbose, you could hide the actual object creation behind a constructor, as described in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; <em>Using the Constructor Pattern</em>.</p>
<p>When reading a CSV, we also no longer have to manually access the fields of a <kbd>StringRecord</kbd>. Instead, <kbd>deserialize()</kbd> returns an iterator over a <kbd>Result</kbd> of an already deserialized <kbd>Planet</kbd> object. Again, look how much more readable this has become.</p>
<p>As you may have already guessed, you should use Serde whenever you can, as it helps you catch possible errors early by providing you with readability and compile-time type safety.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Serde gives you the ability to tweak the serialization process somewhat by annotating your fields. For example, you can give a field a standard value if it wasn't able to be parsed by writing <kbd>#[serde(default)]</kbd> above its declaration. In a struct, it would look like this:</p>
<pre style="padding-left: 30px">#[derive(Serialize, Deserialize)]<br/>struct Foo {<br/>    bar: i32,<br/>    #[serde(default)]<br/>    baz: i32,<br/>}</pre>
<p>If <kbd>baz</kbd> hasn't been parsed, its <kbd>Default::default</kbd> value (See <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; Providing a default implementation) will be used. Another useful thing you can do with annotations is changed the expected case convention. By default, Serde will expect Rust's <kbd>snake_case</kbd>, however, you can change this by annotating a <kbd>struct</kbd> or <kbd>enum</kbd> with <kbd>#[serde(rename_all = "PascalCase")]</kbd>. You can use it on a struct like this:</p>
<pre style="padding-left: 30px">#[derive(Serialize, Deserialize)]<br/>#[serde(rename_all = "PascalCase")]<br/>struct Stats {<br/>    number_of_clicks: i32,<br/>    total_time_played: i32,<br/>}</pre>
<p>This would, instead of parsing <kbd>number_of_clicks</kbd> and <kbd>total_time_played</kbd>, expect the <kbd>NumberOfClicks</kbd> and <kbd>TotalTimePlayed</kbd> keys to be called. Other possible case conventions than <kbd>PascalCase</kbd> that Serde supports are lowercase, <em>camelCase</em>, and <em>SCREAMING_SNAKE_CASE</em>.</p>
<p>There are many different and useful attributes. If you want to, you can familiarize yourself with them at <a href="https://serde.rs/attributes.html">https://serde.rs/attributes.html</a>.</p>
<p>You can use Serde to provide idiomatic serialization and deserialization, however, discussing all best practices would cover an entire chapter on its own. If you want to delve into such things, Serde has a nice write-up on how to do it at <a href="https://serde.rs/data-format.html">https://serde.rs/data-format.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Using the constructor pattern</em> and <em>Providing a default implementation</em> recipes in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><em>Working with text files </em>recipe in <a href="6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml" target="_blank">Chapter 3</a>, <em>Handling Files and the Filesystem</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with TOML</h1>
                
            
            
                
<p>Do you like the simplicity of INI files but wish they were formally specified and had a few more features? So did Tom Preston-Werner, founder of services such as GitHub and Gravatar. He created Tom's Obvious, Minimal Language, or TOML for short. This relatively new format is seeing increasing adoption in new projects. In fact, you have used it multiple times by now as well: Cargo's dependencies are specified in every project's <kbd>Cargo.toml</kbd> file!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>At its heart, TOML is all about <em>key-value</em> pairs. This is the simplest TOML file you can create:</p>
<pre style="padding-left: 30px">message = "Hello World"</pre>
<p>Here, the key message has the <kbd>"Hello World"</kbd> value. A value can also be an array:</p>
<pre style="padding-left: 30px">messages: ["Hello", "World", "out", "there"]</pre>
<p>A group of key-values is called a <em>table</em>. The following TOML lets the <kbd>smileys</kbd> table contain the <kbd>happy</kbd> key with the <kbd>":)"</kbd> value and the <kbd>sad</kbd> key with the <kbd>":("</kbd> value:</p>
<pre style="padding-left: 30px">[smileys]<br/>happy = ":)"<br/>sad = ":("</pre>
<p>A particularly small table can be <em>inlined</em>, that is, written in one line. The last example is the exact same as the following:</p>
<pre style="padding-left: 30px">smileys = { happy = ":)", sad = ":(" }</pre>
<p>Tables can be nested by separating their names with a dot:</p>
<pre style="padding-left: 30px">[servers]<br/>  [servers.production]<br/>  ip = "192.168.0.1"<br/>  [servers.beta]<br/>  ip = "192.169.0.2"<br/>  [servers.testing]<br/>  ip = "192.169.0.3"</pre>
<p>A nice property of TOML is that you can convert any key into a table if you need to specify additional information. For example, Cargo itself expects this when declaring dependency versions. For example, if you wanted to use <kbd>rocket_contrib</kbd>, a helper crate of the popular <kbd>rocket</kbd> web framework for Rust, at version 0.3.3, you would write this:</p>
<pre style="padding-left: 30px">[dependencies]<br/>rocket_contrib = 0.3.3</pre>
<p>However, if you wanted to specify the exact features to be included in <kbd>rocket_contrib</kbd>, you would need to instead write it as a sub-table of <kbd>dependencies</kbd>. The following TOML would tell <kbd>Cargo</kbd> to use its JSON serialization feature:</p>
<pre style="padding-left: 30px">[dependencies]<br/>[dependencies.rocket_contrib]<br/>version = "0.3.3"<br/>default-features = false<br/>features = ["json"]</pre>
<p>Another nice thing TOML brings to the table is that its whitespace is not significant, that is, you can indent a file however you want. You can even add comments by beginning a line with the following:</p>
<pre style="padding-left: 30px"># some comment</pre>
<p>If you want to explore the format further, the entirety of the TOML syntax is specified at <a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you</p>
</li>
</ol>
<ol start="2">
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">toml = "0.4.5"</pre>
<ol start="3">
<li>If you haven't done so already, add the following lines as well:</li>
</ol>
<pre style="padding-left: 60px">serde = "1.0.24"<br/>serde_derive = "1.0.24"</pre>
<ol start="4">
<li>If you want, you can go to the crates.io web pages for TOML (<a href="https://crates.io/crates/toml">https://crates.io/crates/toml</a>), Serde (<a href="https://crates.io/crates/serde">https://crates.io/crates/serde</a>), and <kbd>serde_derive</kbd> (<a href="https://crates.io/crates/serde_derive">https://crates.io/crates/serde_derive</a>) to check for the newest versions and use those ones instead</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>toml.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin toml</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    #[macro_use]<br/>2    extern crate serde_derive;<br/>3    extern crate toml;<br/>4<br/>5    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, <br/>     Write};<br/>6    use std::fs::OpenOptions;</pre>
<ol start="7">
<li>These are the structures we are going to use throughout the recipe:</li>
</ol>
<pre style="padding-left: 60px">8    #[derive(Serialize, Deserialize)]<br/>9    struct Preferences {<br/>10     person: Person,<br/>11     language: Language,<br/>12     privacy: Privacy,<br/>13   }<br/>14 <br/>15   #[derive(Serialize, Deserialize)]<br/>16   struct Person {<br/>17     name: String,<br/>18     email: String,<br/>19   }<br/>20 <br/>21   #[derive(Serialize, Deserialize)]<br/>22   struct Language {<br/>23     display: String,<br/>24     autocorrect: Option&lt;Vec&lt;String&gt;&gt;,<br/>25   }<br/>26 <br/>27   #[derive(Serialize, Deserialize)]<br/>28   struct Privacy {<br/>29     share_anonymous_statistics: bool,<br/>30     public_name: bool,<br/>31     public_email: bool,<br/>32   }</pre>
<ol start="8">
<li>Prepare a new file and call the other functions:</li>
</ol>
<pre style="padding-left: 60px">34   fn main() {<br/>35     let file = OpenOptions::new()<br/>36      .read(true)<br/>37      .write(true)<br/>38      .create(true)<br/>39      .open("preferences.toml")<br/>40      .expect("failed to create TOML file");<br/>41 <br/>42     let buf_writer = BufWriter::new(&amp;file);<br/>43     write_toml(buf_writer).expect("Failed to write TOML");<br/>44 <br/>45     let mut buf_reader = BufReader::new(&amp;file);<br/>46     buf_reader<br/>47       .seek(SeekFrom::Start(0))<br/>48       .expect("Failed to jump to the beginning of the TOML <br/>         file");<br/>49     read_toml(buf_reader).expect("Failed to read TOML");<br/>50   }</pre>
<ol start="9">
<li>Save our structures as a TOML file:</li>
</ol>
<pre style="padding-left: 60px">52   type SerializeResult&lt;T&gt; = Result&lt;T, toml::ser::Error&gt;;<br/>53   fn write_toml&lt;W&gt;(mut writer: W) -&gt; SerializeResult&lt;()&gt;<br/>54   where<br/>55   W: Write,<br/>56   {<br/>57     let preferences = Preferences {<br/>58       person: Person {<br/>59         name: "Jan Nils Ferner".to_string(),<br/>60         email: "jn_ferner@hotmail.de".to_string(),<br/>61       },<br/>62       language: Language {<br/>63         display: "en-GB".to_string(),<br/>64         autocorrect: Some(vec![<br/>65           "en-GB".to_string(),<br/>66           "en-US".to_string(),<br/>67           "de-CH".to_string(),<br/>68         ]),<br/>69       },<br/>70       privacy: Privacy {<br/>71         share_anonymous_statistics: false,<br/>72         public_name: true,<br/>73         public_email: true,<br/>74       },<br/>75     };<br/>76 <br/>77     let toml = toml::to_string(&amp;preferences)?;<br/>78     writer<br/>79       .write_all(toml.as_bytes())<br/>80       .expect("Failed to write file");<br/>81     Ok(())<br/>82   }</pre>
<ol start="10">
<li><kbd>Read</kbd> the TOML file we just created:</li>
</ol>
<pre style="padding-left: 60px">84   type DeserializeResult&lt;T&gt; = Result&lt;T, toml::de::Error&gt;;<br/>85   fn read_toml&lt;R&gt;(mut reader: R) -&gt; DeserializeResult&lt;()&gt;<br/>86   where<br/>87   R: Read,<br/>88   {<br/>89     let mut toml = String::new();<br/>90     reader<br/>91       .read_to_string(&amp;mut toml)<br/>92       .expect("Failed to read TOML");<br/>93     let preferences: Preferences = toml::from_str(&amp;toml)?;<br/>94 <br/>95     println!("Personal data:");<br/>96     let person = &amp;preferences.person;<br/>97     println!(" Name: {}", person.name);<br/>98     println!(" Email: {}", person.email);<br/>99 <br/>100     println!("\nLanguage preferences:");<br/>101     let language = &amp;preferences.language;<br/>102     println!(" Display language: {}", language.display);<br/>103     println!(" Autocorrect priority: {:?}", <br/>        language.autocorrect);<br/>104 <br/>105 <br/>106     println!("\nPrivacy settings:");<br/>107     let privacy = &amp;preferences.privacy;<br/>108     println!(<br/>109       " Share anonymous usage statistics: {}",<br/>110         privacy.share_anonymous_statistics<br/>111     );<br/>112     println!(" Display name publically: {}", <br/>        privacy.public_name);<br/>113     println!(" Display email publically: {}", <br/>        privacy.public_email);<br/>114 <br/>115     Ok(())<br/>116  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As always with Serde, we first need to declare the structures we plan on using [8 to 32].</p>
<p>While serializing, we can directly call Serde's <kbd>to_string</kbd> method with a structure as TOML re-exports them [77]. This returns a <kbd>String</kbd> that we can then write into a file [79]. The same is true of Serde's <kbd>from_str</kbd>, which, when type-annotated, takes a <kbd>&amp;str</kbd> and converts it into a structure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You might have noticed that we are not using the try-operator (<kbd>?</kbd>) while reading or writing in this recipe. This is because the function's expected error types, <kbd>se::Error</kbd> [77] and <kbd>de::Error</kbd>[93], are incompatible with <kbd>std::io::Error</kbd>. In <a href="d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml" target="_blank">Chapter 6</a>, <em>Handling Errors</em>;<em> Providing user-defined Error types</em>, we will explore how to avoid this by returning our own error type that encompasses the other ones mentioned.</p>
<p>The TOML crate used in this recipe is the same one that Cargo itself uses. If you are interested in how Cargo parses its own <kbd>Cargo.toml</kbd> file, you can check out <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs">https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Working with</em> text <em>files</em> recipe in <a href="6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml" target="_blank">Chapter 3</a>, <em>Handling Files and the Filesystem</em></li>
<li><em>Providing user-defined error types</em> recipe in <a href="d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml" target="_blank">Chapter 6</a>, <em>Handling Errors</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with JSON</h1>
                
            
            
                
<p>Most Web APIs and many native APIs speak JSON nowadays. It should be your format of choice when designing data meant for consumption by other programs, as it is lightweight, simple, easy to use and understand, and has excellent library support across programming languages, most notably JavaScript, of course.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>JSON was created at a time when most web communication was done by sending XML over browser plugins such as Java or Flash. This was cumbersome and made the exchanged information quite bloated. Douglas Crockford, the creator of JSLint and author of the famous <em>JavaScript: The Good Parts</em>, decided in the early 2000s that it was time for a lightweight format that was easily integrated with JavaScript. He oriented himself on a small subset of JavaScript, namely the way it defined objects, and extended it a little bit to form the JavaScript Object Notation or JSON. Yes, you've read that right; JSON is <em>not</em> a subset of JavaScript, as it accepts things that JavaScript doesn't. You can read more about that at <a href="http://timelessrepo.com/json-isnt-a-javascript-subset">http://timelessrepo.com/json-isnt-a-javascript-subset.</a></p>
<p>The sad irony of the story is that today we have gone full-circle: our best practices for web development include a labyrinth of task runners, frameworks, and transpilers, which are all quite nice in theory but end up being a giant bloated mess in the end. But that is a story for another time.</p>
<p>JSON is built upon two structures:</p>
<ul>
<li>A group of key-value pairs surrounded by <kbd>{</kbd> and <kbd>}</kbd>, which is called an <em>object</em> and can be a value itself</li>
<li>A list of values surrounded by <kbd>[</kbd> and <kbd>]</kbd> called an <em>array</em></li>
</ul>
<p>This might remind you a bit of the TOML syntax we discussed earlier, and you might ask yourself when you should prefer one over the other. The answer is that JSON is a good format when your data is going to be read automatically by a tool, while TOML is excellent when your data is meant to be read and modified manually by a human.</p>
<p>Take note that one thing that JSON <em>doesn't</em> allow is comments. This makes sense, as comments are not readable by tools anyway.</p>
<p>An example of a JSON object with values, sub-objects, and arrays could be the following:</p>
<pre style="padding-left: 30px">{<br/>  name: "John",<br/>  age: 23,<br/>  pets: [<br/>    {<br/>      name: "Sparky",<br/>      species: "Dog",<br/>      age: 2<br/>    },<br/>    {<br/>      name: "Speedy",<br/>      species: "Turtle",<br/>      age: 47,<br/>      colour: "Green"<br/>    },<br/>    {<br/>      name: "Meows",<br/>      species: "Cat",<br/>      colour: "Orange"<br/>    }<br/>  ]<br/>}</pre>
<p>We are going to write and read this exact example in the following code. The definitions of the pets are intentionally inconsistent because many web APIs omit certain keys in some situations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">serde_json = "1.0.8"</pre>
<ol start="3">
<li>If you haven't done so already, add the following lines as well:</li>
</ol>
<pre style="padding-left: 60px">serde = "1.0.24"<br/>serde_derive = "1.0.24"</pre>
<ol start="4">
<li>If you want, you can go to the crates.io web pages for <kbd>serde_json</kbd> (<a href="https://crates.io/crates/serde_json">https://crates.io/crates/serde_json</a>), Serde (<a href="https://crates.io/crates/serde">https://crates.io/crates/serde</a>), and <kbd>serde_derive</kbd> (<a href="https://crates.io/crates/serde_derive">https://crates.io/crates/serde_derive</a>) to check for the newest versions and use those ones instead</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>json.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin json</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    extern crate serde;<br/>2    extern crate serde_json;<br/>3<br/>4    #[macro_use]<br/>5    extern crate serde_derive;<br/>6<br/>7    use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, <br/>     Write};<br/>8    use std::fs::OpenOptions;</pre>
<ol start="7">
<li>These are the structures we are going to use throughout the recipe:</li>
</ol>
<pre style="padding-left: 60px">10   #[derive(Serialize, Deserialize)]<br/>11   struct PetOwner {<br/>12     name: String,<br/>13     age: u8,<br/>14     pets: Vec&lt;Pet&gt;,<br/>15   }<br/>16 <br/>17   #[derive(Serialize, Deserialize)]<br/>18   struct Pet {<br/>19     name: String,<br/>20     species: AllowedSpecies,<br/>21     // It is usual for many JSON keys to be optional<br/>22     age: Option&lt;u8&gt;,<br/>23     colour: Option&lt;String&gt;,<br/>24   }<br/>25 <br/>26   #[derive(Debug, Serialize, Deserialize)]<br/>27   enum AllowedSpecies {<br/>28     Dog,<br/>29     Turtle,<br/>30     Cat,<br/>31   }</pre>
<ol start="8">
<li>Prepare a new file and call the other functions:</li>
</ol>
<pre style="padding-left: 60px">33   fn main() {<br/>34     let file = OpenOptions::new()<br/>35       .read(true)<br/>36       .write(true)<br/>37       .create(true)<br/>38       .open("pet_owner.json")<br/>39       .expect("failed to create JSON file");<br/>40 <br/>41     let buf_writer = BufWriter::new(&amp;file);<br/>42     write_json(buf_writer).expect("Failed to write JSON");<br/>43 <br/>44     let mut buf_reader = BufReader::new(&amp;file);<br/>45     buf_reader<br/>46       .seek(SeekFrom::Start(0))<br/>47       .expect("Failed to jump to the beginning of the JSON <br/>          file");<br/>48     read_json(buf_reader).expect("Failed to read JSON");<br/>49   }</pre>
<ol start="9">
<li>Save our structures as a JSON file:</li>
</ol>
<pre style="padding-left: 60px">52   fn write_json&lt;W&gt;(mut writer: W) -&gt; serde_json::Result&lt;()&gt;<br/>53   where<br/>54   W: Write,<br/>55   {<br/>56     let pet_owner = PetOwner {<br/>57       name: "John".to_string(),<br/>58       age: 23,<br/>59       pets: vec![<br/>60         Pet {<br/>61           name: "Waldo".to_string(),<br/>62           species: AllowedSpecies::Dog,<br/>63           age: Some(2),<br/>64           colour: None,<br/>65         },<br/>66         Pet {<br/>67           name: "Speedy".to_string(),<br/>68           species: AllowedSpecies::Turtle,<br/>69           age: Some(47),<br/>70           colour: Some("Green".to_string()),<br/>71         },<br/>72         Pet {<br/>73           name: "Meows".to_string(),<br/>74           species: AllowedSpecies::Cat,<br/>75           age: None,<br/>76           colour: Some("Orange".to_string()),<br/>77         },<br/>78       ],<br/>79     };<br/>80 <br/>81     let json = serde_json::to_string(&amp;pet_owner)?;<br/>82     writer<br/>83      .write_all(json.as_bytes())<br/>84      .expect("Failed to write file");<br/>85     Ok(())<br/>86   }</pre>
<ol start="10">
<li>Read the JSON file we just created:</li>
</ol>
<pre style="padding-left: 60px">88   fn read_json&lt;R&gt;(mut reader: R) -&gt; serde_json::Result&lt;()&gt;<br/>89   where<br/>90   R: Read,<br/>91   {<br/>92     let mut json = String::new();<br/>93     reader<br/>94       .read_to_string(&amp;mut json)<br/>95       .expect("Failed to read TOML");<br/>96     let pet_owner: PetOwner = serde_json::from_str(&amp;json)?;<br/>97 <br/>98     println!("Pet owner profile:");<br/>99     println!(" Name: {}", pet_owner.name);<br/>100    println!(" Age: {}", pet_owner.age);<br/>101 <br/>102    println!("\nPets:");<br/>103    for pet in pet_owner.pets {<br/>104      println!(" Name: {}", pet.name);<br/>105      println!(" Species: {:?}", pet.species);<br/>106      if let Some(age) = pet.age {<br/>107        println!(" Age: {}", age);<br/>108      }<br/>109      if let Some(colour) = pet.colour {<br/>110        println!(" Colour: {}", colour);<br/>111      }<br/>112      println!();<br/>113    }<br/>114    Ok(())<br/>115  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Notice how this recipe looks nearly identical to the last one? Except for the structures, the only significant difference is that we called <kbd>serde_json::to_string()</kbd> [81] instead of <kbd>toml::to_string()</kbd>, and <kbd>serde_json::from_str()</kbd> [96] instead of <kbd>toml::from_str()</kbd>. This is the beauty of a well-thought-out framework like Serde: the custom serialization and deserialization code are hidden behind trait definitions and we can use the same API without caring about internal implementation details.</p>
<p>Other than that, there is nothing to say that hasn't been said in the previous recipe, which is why we are not going to go over any other formats. All important formats support Serde, so you can use them the exact same way you use the other formats in this chapter. For a full list of all supported formats, see <a href="https://docs.serde.rs/serde/index.html">https://docs.serde.rs/serde/index.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>JSON has no concept of something resembling an <kbd>enum</kbd>. As many languages <em>do</em> work with them, however, multiple conventions on how to handle the conversion from JSON into <kbd>enum</kbd> have emerged over the years. Serde allows you to support these conventions with annotations on your enums. For a full list of supported conversions, visit <a href="https://serde.rs/enum-representations.html">https://serde.rs/enum-representations.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Working with text</em> <em>files</em> recipe in <a href="6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml" target="_blank">Chapter 3</a>, <em>Handling Files and the Filesystem</em></li>
<li><em>Providing user-defined error types</em> recipe in <a href="d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml" target="_blank">Chapter 6</a>, <em>Handling Errors</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Building JSON dynamically</h1>
                
            
            
                
<p>When a JSON API is designed with a poorly-thought-out schema and inconsistent objects, you might end up with giant structures where most members are an <kbd>Option</kbd>. If you find yourself only sending data to such a service, it might be a bit easier to dynamically build your JSON property by property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, if you haven't done so already, add the following line:</li>
</ol>
<pre style="padding-left: 60px">serde_json = "1.0.8"<br/></pre>
<ol start="3">
<li>If you want, you can go to the <kbd>serde_json</kbd> crates.io web page (<a href="https://crates.io/crates/serde_json">https://crates.io/crates/serde_json</a>) to check for the newest version and use that one instead</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>dynamic_json.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin dynamic_json</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    #[macro_use] <br/>2    extern crate serde_json;<br/>3 <br/>4    use std::io::{self, BufRead};<br/>5    use std::collections::HashMap;<br/>6 <br/>7    fn main() {<br/>8      // A HashMap is the same as a JSON without any schema<br/>9      let mut key_value_map = HashMap::new();<br/>10     let stdin = io::stdin();<br/>11     println!("Enter a key and a value");<br/>12     for input in stdin.lock().lines() {<br/>13       let input = input.expect("Failed to read line");<br/>14       let key_value: Vec&lt;_&gt; = input.split_whitespace().collect();<br/>15       let key = key_value[0].to_string();<br/>16       let value = key_value[1].to_string();<br/>17 <br/>18       println!("Saving key-value pair: {} -&gt; {}", key, value);<br/>19       // The json! macro lets us convert a value into its JSON <br/>            representation<br/>20       key_value_map.insert(key, json!(value));<br/>21       println!(<br/>22         "Enter another pair or stop by pressing '{}'",<br/>23          END_OF_TRANSMISSION<br/>24       );<br/>25     }<br/>26     // to_string_pretty returns a JSON with nicely readable <br/>          whitespace<br/>27     let json =<br/>28     serde_json::to_string_pretty(&amp;key_value_map).expect("Failed <br/>       to convert HashMap into JSON");<br/>29     println!("Your input has been made into the following <br/>       JSON:");<br/>30     println!("{}", json);<br/>31   }<br/>32 <br/>33   #[cfg(target_os = "windows")]<br/>34   const END_OF_TRANSMISSION: &amp;str = "Ctrl Z";<br/>35 <br/>36   #[cfg(not(target_os = "windows"))]<br/>37   const END_OF_TRANSMISSION: &amp;str = "Ctrl D";</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this example, the user can enter any number of key-value pairs until they decide to stop, at which point they receive their input back in the form of JSON. Some example input you could enter could include:</p>
<pre style="padding-left: 30px"><strong>name abraham</strong><br/><strong>age 49</strong><br/><strong>fav_colour red</strong><br/><strong>hello world</strong><br/><strong>(press 'Ctrl Z' on Windows or 'Ctrl D' on Unix)</strong></pre>
<p>Use <kbd>#[cfg(target_os = "some_operating_system")]</kbd> to handle operating system specific circumstances. In this recipe, we use this to conditionally compile the <kbd>END_OF_TRANSMISSION</kbd> constant differently on Windows than on Unix. This key combination tells the OS to stop the current input stream.</p>
<p class="mce-root">This program begins with the idea that a JSON object without a clearly defined schema is nothing but a <kbd>HashMap&lt;String, String&gt;</kbd>[9]. Now, <kbd>serde_json</kbd> doesn't accept a <kbd>String</kbd> as a value, as that would not be general enough. Instead, it wants a <kbd>serde_json::Value</kbd>, which you can easily construct by calling the <kbd>json!</kbd> macro on pretty much any type [20].</p>
<p>When we are done, we don't call <kbd>serde_json::to_string()</kbd> as before, but use <kbd>serde_json::to_string_pretty()</kbd> instead [28], as this results in a less efficient but much more readable JSON. Remember, JSON is not supposed to be primarily read by humans, which is why the default way Serde serialized it is without any whitespace whatsoever. If you're curious about the exact difference, feel free to go ahead and change <kbd>to_string_pretty()</kbd> to <kbd>to_string()</kbd> and compare the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Reading from stdin</em> recipe in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><em>Access collections as Iterators</em> and <em>Using a HashMap</em> recipe in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    </body></html>