- en: Involving Concurrency with Actors and the Actix Crate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Actix Crate和演员进行并发
- en: This chapter will show an alternative approach to creating microservices based
    on the actors model (like Erlang or Akka). This approach allows you to write clear
    and effective code by splitting a microservice into small independent tasks that
    interact with each other by message passing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示一种基于演员模型（如Erlang或Akka）创建微服务的替代方法。这种方法允许您通过将微服务拆分为小型独立任务，并通过消息传递相互交互来编写清晰和有效的代码。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够做到以下事情：
- en: Create a microservice using the Actix framework and the `actix-web` crate
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Actix框架和`actix-web`包创建微服务
- en: Create middleware for the Actix Web framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Actix Web框架创建中间件
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To implement and run all the examples of this chapter, you'll need the Rust
    compiler with version 1.31 as a minimum.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现和运行本章的所有示例，您至少需要一个版本为1.31的Rust编译器。
- en: 'You can find the sources for the code examples in this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter11)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章代码示例的来源：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter11)
- en: Actor concurrency in microservices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的演员并发
- en: If you are familiar with Erlang or Akka, you may already know what actors are
    and how to use them. But in any case, we'll refresh our knowledge about the actors
    model in this section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Erlang或Akka，您可能已经知道演员是什么以及如何使用它们。但无论如何，我们将在本节中回顾演员模型的知识。
- en: Understanding actors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解演员
- en: We already became familiar with actors in [Chapter 10](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml),
    *Background Tasks and Thread Pools in Microservices*, but let's talk about using
    actors for microservices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第10章中熟悉了演员，*微服务中的后台任务和线程池*，但让我们谈谈使用演员进行微服务。
- en: 'An actor is a model for doing concurrent computations. We should know the following
    models:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 演员是进行并发计算的模式。我们应该了解以下模型：
- en: '**Threads**: In this model, every task works in a separate thread'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**：在这个模型中，每个任务都在单独的线程中工作'
- en: '**Fibers or green threads**: In this model, every task has work scheduled by
    a special runtime'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纤程或绿色线程**：在这个模型中，每个任务都有由特殊运行时安排的工作'
- en: '**Asynchronous code**: In this model, every task is run by a reactor (actually,
    this is similar to fibers)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步代码**：在这个模型中，每个任务都由一个反应器（实际上，这类似于纤程）运行'
- en: Actors combine all these approaches into an elegant one. To do any part of the
    work, you can implement actors that perform their own part of the work, and interact
    with other actors through messages to inform each other on the overall progress.
    Every actor has a mailbox for incoming messages and can send messages to other
    actors using this address.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 演员将这些方法结合成一个优雅的解决方案。要完成任何工作的一部分，您可以实现执行自己部分工作的演员，并通过消息与其他演员交互，以通知彼此整体进度。每个演员都有一个用于接收消息的邮箱，并且可以使用此地址向其他演员发送消息。
- en: Actors in microservices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的演员
- en: To develop a microservice using actors, you should split your service into tasks
    that solves different kinds of work. For example, you can use a separate actor
    for every incoming connection or database interaction, and even as a supervisor
    to control other actors. Every actor is an asynchronous task that is executed
    in a reactor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用演员开发微服务，您应该将您的服务拆分为解决不同类型工作的任务。例如，您可以为每个传入的连接或数据库交互使用单独的演员，甚至作为管理员来控制其他演员。每个演员都是一个在反应器中执行的非同步任务。
- en: 'The benefits of this approach are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点如下：
- en: It's simpler to write separate actors than a bulk of functions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单独的演员编写比编写大量函数要简单
- en: Actors can fail and respawn
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员可能会失败并重新启动
- en: You can reuse actors
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以重用演员
- en: One important benefit of using actors is reliability, because every actor can
    be failed and respawned, so you don't need a long recovery code to handle failures.
    It doesn't mean your code can call the `panic!` macro everywhere, but this does
    mean that you can consider actors as short life cycle tasks that work concurrently
    on small tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用演员的一个重要好处是可靠性，因为每个演员都可以失败并重新启动，因此您不需要编写冗长的恢复代码来处理故障。这并不意味着您的代码可以在任何地方调用`panic!`宏，但这确实意味着您可以将演员视为短生命周期任务，它们在小型任务上并发工作。
- en: If you design actors well, you also gain great performance, because interaction
    with messages helps you to split work into short reactions, which won't block
    the reactor for a long time. Also, your source code becomes more structured.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设计演员得当，你也会获得很好的性能，因为与消息的交互可以帮助你将工作分成短反应，这不会长时间阻塞反应器。此外，你的源代码结构也会更加清晰。
- en: The Actix framework
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actix 框架
- en: The Actix framework provides an actors model for Rust, based on the `futures`
    crate and some asynchronous code to allow actors to work concurrently with minimal
    resources needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Actix 框架为 Rust 提供了一个基于 `futures` crate 和一些异步代码的演员模型，允许演员以最小资源需求并发工作。
- en: I think this is one of the best tools for creating web applications and microservices
    with Rust. The framework includes two good crates—the `actix` crate that contains
    core structures, and the `actix-web` crate that implements the HTTP and WebSocket
    protocols. Let's create a microservice that routes requests to other microservices.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是用 Rust 创建网络应用和微服务的最佳工具之一。该框架包括两个优秀的crate——包含核心结构的 `actix` crate 和实现 HTTP
    和 WebSocket 协议的 `actix-web` crate。让我们创建一个将请求路由到其他微服务的微服务。
- en: Creating a microservice with actix-web
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 actix-web 创建微服务
- en: In this section, we will create a microservice that looks similar to other microservices
    we created in [Chapter 9](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml), *Simple
    REST Definition and Requests Routing with Frameworks*, but use an actors model
    internally to achieve full resource utilization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个微服务，它看起来与我们之前在 [第9章](6d371e55-d1cf-45b4-83a9-4d5098a885d0.xhtml)
    中创建的其他微服务类似，即 *使用框架进行简单的REST定义和请求路由*，但内部使用演员模型来实现资源充分利用。
- en: To create a microservice using `actix-web`, you need to add both the `actix`
    and `actix-web` crates. First, we need to start the `System` actor that manages
    the runtime of other actors. Let's create a `System` instance and start an `actix-web`
    server with the necessary routes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `actix-web` 创建一个微服务，你需要添加 `actix` 和 `actix-web` 两个crate。首先，我们需要启动管理其他演员运行时的
    `System` 演员实例。让我们创建一个 `System` 实例，并使用必要的路由启动一个 `actix-web` 服务器。
- en: Bootstrapping an actix-web server
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 actix-web 服务器
- en: Starting an `actix-web` server instance looks similar to other Rust web frameworks,
    but requires a `System` actor instance. We don't need to use `System` directly,
    but need to run it by calling the `run` method when everything is ready. This
    call starts the `System` actor and blocks the current thread. Internally, it uses
    the `block_on` method that we discussed in previous chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 `actix-web` 服务器实例看起来与其他 Rust 网络框架类似，但需要 `System` 演员实例。我们不需要直接使用 `System`，但需要在一切准备就绪时通过调用
    `run` 方法来运行它。这个调用启动了 `System` 演员并阻塞了当前线程。内部，它使用了我们在前几章讨论过的 `block_on` 方法。
- en: Starting a server
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'Consider the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a new server with the `server::new` method call that expects a closure
    to return the `App` instance. Before we create the `App` instance, we have to
    finish our server and run it. The `workers` method sets the number of threads
    to run actors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `server::new` 方法创建一个新的服务器，该方法期望一个闭包来返回 `App` 实例。在我们创建 `App` 实例之前，我们必须完成服务器并运行它。`workers`
    方法设置运行演员的线程数。
- en: You can choose not to set this value explicitly, and by default, it will be
    equal to the number of CPUs on the system. In many cases, it's the best possible
    value for performance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择不显式设置此值，默认情况下，它将等于系统上的 CPU 数量。在许多情况下，这是性能的最佳可能值。
- en: The next call of the `bind` method binds the server's socket to an address.
    If it can't be bound to an address, the method returns `Err`, and we `unwrap`
    the result to halt a server if we can't start a server on a desired port. At the
    end, we call the `start` method to start the `Server` actor. It returns an `Addr`
    struct with an address that you can use to send messages to a `Server` actor instance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `bind` 方法的调用将服务器的套接字绑定到一个地址。如果无法绑定到地址，该方法返回 `Err`，如果我们不能在期望的端口上启动服务器，我们将
    `unwrap` 结果以停止服务器。最后，我们调用 `start` 方法来启动 `Server` 演员。它返回一个包含地址的 `Addr` 结构体，你可以使用该地址向
    `Server` 演员实例发送消息。
- en: Actually, the `Server` actor won't run until we call run the method of the `System`
    instance. Add this method call, and then we'll go on to look at creating an `App`
    instance in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Server` 演员不会运行，直到我们调用 `System` 实例的 `run` 方法。添加这个方法调用，然后我们将详细查看创建 `App`
    实例。
- en: App creation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用
- en: 'Insert the following code into a closure of the `server::new` function call:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码插入到 `server::new` 函数调用的闭包中：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `App` struct contains information about the state, middleware, and the scopes
    of routes. To set shared state to our application, we use the `with_state` method
    to construct the `App` instance. We create a default instance of the `State` struct,
    which is declared as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 结构体包含有关状态、中间件和路由作用域的信息。为了将共享状态设置到我们的应用程序中，我们使用 `with_state` 方法来构建 `App`
    实例。我们创建 `State` 结构体的默认实例，其声明如下：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`State` contains a cell with an `i64` value to count all requests. By default,
    it is created with a `0` value.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`State` 包含一个带有 `i64` 值的 cell，用于计算所有请求。默认情况下，它使用 `0` 值创建。'
- en: 'After this, we use the middleware method of `App` to set the three following
    middlewares:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们使用 `App` 的中间件方法来设置以下三个中间件：
- en: '`actix_web::middleware::Logger` is a logger that uses the `log` crate to log
    request and responses'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actix_web::middleware::Logger` 是一个使用 `log` crate 记录请求和响应的日志器'
- en: '`actix_web::middleware::identity::IdentityService` helps to identity requests
    using an identity backend that implements the `IdentityPolicy` trait'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actix_web::middleware::identity::IdentityService` 通过实现 `IdentityPolicy` 特性的身份后端来帮助识别请求'
- en: '`Counter` is a piece of middleware that we will create in the following *Middleware*
    section, and uses `State` to count the total quantity of requests'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter` 是一个中间件，我们将在接下来的 *中间件* 部分中创建它，并使用 `State` 来计算请求的总数量'
- en: For our `IdentityPolicy` backend, we use `CookieIdentityPolicy` from the same
    identity submodule where `IdentityService` lives. `CookieIdentityPolicy` expects
    a key with at least 32 bytes. When an instance of an identity policy for cookies
    has been created, we can use methods like `path`, `name`, and `domain` to set
    specific cookies parameters. We also allow the sending of cookies with insecure
    connections by using the `secure` method with a `false` value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `IdentityPolicy` 后端，我们使用与 `IdentityService` 同一身份子模块中的 `CookieIdentityPolicy`。`CookieIdentityPolicy`
    期望一个至少有 32 字节的密钥。当创建了一个身份策略的 cookie 实例后，我们可以使用 `path`、`name` 和 `domain` 等方法来设置特定的
    cookie 参数。我们还通过使用 `secure` 方法并设置 `false` 值来允许通过不安全的连接发送 cookie。
- en: 'There are two special parameters of cookies you should know about: `Secure`
    and `HttpOnly`. The first requires secure HTTPS connection to send cookies. If
    you run a service for testing and use plain HTTP to connect to it, then the `CookieIdentityPolicy`
    won''t work. `HttpOnly` parameters don''t allow the use of cookies from JavaScript.
    `CookieIdentityPolicy` sets this parameter to true and you can''t override this
    behavior.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解 cookie 的两个特殊参数：`Secure` 和 `HttpOnly`。第一个要求使用安全的 HTTPS 连接来发送 cookie。如果你运行一个用于测试的服务并使用纯
    HTTP 连接到它，那么 `CookieIdentityPolicy` 将不会工作。`HttpOnly` 参数不允许从 JavaScript 使用 cookie。`CookieIdentityPolicy`
    将此参数设置为 true，并且你不能覆盖这种行为。
- en: Scope and routes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和路由
- en: 'The next thing we have to add to our `App` instance is routing. There is a `route`
    function that lets you set a handler for any route. But it''s more thoughtful
    to use scopes to construct a structure of nested paths. Look at the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加到我们的 `App` 实例中的下一件事是路由。有一个 `route` 函数可以让你为任何路由设置处理器。但使用作用域来构建嵌套路径的结构会更周到。看看下面的代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `scope` method of our `App` struct expects a prefix of a path and a closure
    with a `scope` as a single argument, and creates a scope that can contain subroutes.
    We create a `scope` for the `/api` path prefix and add four routes using the `route`
    method: `/signup`, `/signin`, `/new_comment`, and `/comments`. The `route` method
    expects a suffix including a path, a method, and a handler. For example, if a
    server now takes a request for `/api/singup` with the `POST` method, it will call
    the `signup` function. Let''s add a default handler for other paths.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `App` 结构体的 `scope` 方法期望一个路径的前缀和一个以 `scope` 作为单一参数的闭包，并创建一个可以包含子路由的作用域。我们为
    `/api` 路径前缀创建一个 `scope`，并使用 `route` 方法添加了四个路由：`/signup`、`/signin`、`/new_comment`
    和 `/comments`。`route` 方法期望一个包括路径、方法和处理器的后缀。例如，如果服务器现在接收一个使用 `POST` 方法的 `/api/singup`
    请求，它将调用 `signup` 函数。让我们为其他路径添加一个默认处理器。
- en: 'Our microservice also uses `Counter` middleware, which we will implement later,
    to count the total quantity of requests. We need to add a route to render statistics
    for the microservice, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务还使用 `Counter` 中间件，我们将在稍后实现它，来计算请求的总数量。我们需要添加一个路由来渲染微服务的统计信息，如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we don't need `scope` here, since we have only one handler and
    can call the `route` method directly for the `App` instance (not `scope`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们这里不需要 `scope`，因为我们只有一个处理器，可以直接为 `App` 实例（而不是 `scope`）调用 `route` 方法。
- en: Static files handler
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态文件处理器
- en: 'For the other paths that were not listed in the previous `scope`, we will use
    a `handler` that will return a file''s content from a folder to serve static assets.
    The `handler` method expects a prefix for a path, and a type that implements the
    `Handler` trait. In our case, we will use a ready-to-use static files handler, `actix_web::fs::StaticFiles`.
    It needs a path to a local folder and we can also set an index file by calling the
    `index_file` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前 `scope` 中未列出的其他路径，我们将使用一个 `handler`，它将从文件夹中返回文件的 内容以提供静态资源。`handler` 方法期望一个路径的前缀，以及一个实现了
    `Handler` 特质的类型。在我们的情况下，我们将使用一个现成的静态文件处理程序，`actix_web::fs::StaticFiles`。它需要一个指向本地文件夹的路径，我们还可以通过调用
    `index_file` 方法设置索引文件：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, if a client send a `GET` request to a path such as `/index.html` or `/css/styles.css`,
    then the `StaticFiles` handler will send the contents of the corresponding files
    from the `./static/` local folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果客户端向路径例如 `/index.html` 或 `/css/styles.css` 发送 `GET` 请求，那么 `StaticFiles`
    处理程序将发送来自 `./static/` 本地文件夹中相应文件的 内容。
- en: HTTP client
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端
- en: 'The handlers of this microservice work as proxies and resend incoming requests
    to other microservices, which will not be available to users directly. To send
    requests to other microservices, we need an HTTP client. The `actix_web` crate
    contains one. To use a client, we add two functions: one for proxfying `GET` requests,
    and the other to send `POST` requests.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该微服务的处理程序作为代理工作，并将传入的请求重新发送到其他微服务，这些微服务将不会直接对用户可用。要向其他微服务发送请求，我们需要一个 HTTP 客户端。`actix_web`
    包含一个。要使用客户端，我们需要添加两个函数：一个用于代理 `GET` 请求，另一个用于发送 `POST` 请求。
- en: GET requests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET 请求
- en: 'To send `GET` requests, we create a `get_request` function that expects a `url`
    parameter and returns a `Future` instance with binary data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送 `GET` 请求，我们创建一个 `get_request` 函数，它期望一个 `url` 参数并返回一个包含二进制数据的 `Future` 实例：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We use `ClientRequestBuilder` to create the `ClientRequest` instance. The `ClientRequest`
    struct already has shortcuts that create builders with a preset HTTP method. We
    call the `get` method that only sets the `Method::GET` value to a request that
    is implemented as the calling method of the `ClientRequestBuilder` instance. You
    can also use a builder to set extra headers or cookies. When you are done with
    these values, you have to create a `ClientRequest` instance from a builder by
    calling one of the following methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ClientRequestBuilder` 来创建 `ClientRequest` 实例。`ClientRequest` 结构体已经具有创建具有预设
    HTTP 方法的构建器的快捷方式。我们调用 `get` 方法，该方法仅将 `Method::GET` 值设置到作为 `ClientRequestBuilder`
    实例调用方法的请求中。您还可以使用构建器设置额外的头或cookie。当您完成这些值后，您必须通过调用以下方法之一从构建器创建 `ClientRequest`
    实例：
- en: '`body` sets a body value to binary data that can be converted `Into<Body>`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body` 将体值设置为可以转换为 `Into<Body>` 的二进制数据'
- en: '`json` sets a body value to any type that can be serialized into JSON value'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 将体值设置为一个可以序列化为 JSON 值的任何类型'
- en: '`form` sets a body value to a type that can be serialized with `serde_urlencoded:
    serializer`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form` 将体值设置为一个可以使用 `serde_urlencoded: serializer` 序列化的类型'
- en: '`streaming` consumes a body value from a `Stream` instance'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streaming` 从 `Stream` 实例中消耗体值'
- en: '`finish` creates a request without a body value'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish` 创建一个不带体值的请求'
- en: We use `finish`, because `GET` requests don't contain a body value. All these
    methods return a `Result` with a `ClientRequest` instance as a successful value.
    We don't unwrap the `Result` and will convert it into a `Future` value with  the `into_future`
    method call to return an `Error` value to a client if the handler can't even build
    a request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `finish`，因为 `GET` 请求不包含体值。所有这些方法都返回一个包含 `ClientRequest` 实例的成功值的 `Result`。我们不展开
    `Result`，而是通过调用 `into_future` 方法将其转换为 `Future` 值，以便在处理程序甚至无法构建请求时向客户端返回一个错误值。
- en: Since we have a `Future` value, we can use the `and_then` method to add the
    next processing step. We call the `send` method of a `ClientRequest` to create
    a `SendRequest` instance, which implements the `Future` trait and sends a request
    to a server. Since the `send` call can return the `SendRequestError` error type,
    we wrap it with `failure::Error`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个 `Future` 值，我们可以使用 `and_then` 方法添加下一个处理步骤。我们调用 `ClientRequest` 的 `send`
    方法来创建一个 `SendRequest` 实例，该实例实现了 `Future` 特质并向服务器发送请求。由于 `send` 调用可以返回 `SendRequestError`
    错误类型，我们将其包装在 `failure::Error` 中。
- en: If a request has sent successfully we can take a `MessageBody` value with the `body`
    method call. This method is a part of the `HttpMessage` trait. `MessageBody` also
    implements a `Future` trait with a `Bytes` value and we use the `and_then` method
    to extend a chain of futures and transform a value from `SendRequest` to `Bytes`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功发送，我们可以使用 `body` 方法调用获取 `MessageBody` 值。此方法是 `HttpMessage` 特质的一部分。`MessageBody`
    还实现了具有 `Bytes` 值的 `Future` 特质，我们使用 `and_then` 方法扩展未来链并从 `SendRequest` 转换值。
- en: Finally, we use the `to_vec` method of `Bytes` to convert it into `Vec<u8>`
    and provide this value as a response to a client. We have finished our method
    that proxies `GET` requests to another microservice. Let's create a similar method
    for `POST` requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `Bytes` 的 `to_vec` 方法将其转换为 `Vec<u8>` 并将此值作为对客户端的响应。我们已经完成了将 `GET` 请求代理到另一个微服务的函数。让我们为
    `POST` 请求创建一个类似的方法。
- en: POST requests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`POST` 请求'
- en: 'For `POST` requests, we need input parameters that will be serialized to the
    request''s body, and output parameters that will be deserialized from the request''s
    response body. Look at the following function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POST` 请求，我们需要输入参数，这些参数将被序列化到请求体中，以及输出参数，这些参数将从请求的响应体中反序列化。看看下面的函数：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `post_request` function creates `ClientRequestBuilder` with the `post` method
    of `ClientRequest` and fills a form with values from the `params` variable. We
    convert `Result` into `Future` and send a request to a server. Also, as in the
    `GET` version, we process a response, but do it another way. We get a status of
    a response with the `status` method call of `HttpResponse`, and check whether
    it's successful, with the `is_sucess` method call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_request` 函数使用 `ClientRequest` 的 `post` 方法创建 `ClientRequestBuilder`，并用
    `params` 变量的值填充一个表单。我们将 `Result` 转换为 `Future` 并向服务器发送一个请求。同样，在 `GET` 版本中，我们处理响应，但采用不同的方式。我们通过
    `HttpResponse` 的 `status` 方法调用获取响应的状态，并使用 `is_success` 方法调用检查它是否成功。'
- en: For successful responses, we use the `json` method of `HttpResponse` to get
    a `Future` that collects a body and deserializes it from JSON. If the response
    wasn't successful, we return an error to the client. Now, we have methods to send
    requests to other microservices, and can implement handlers for every route.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的响应，我们使用 `HttpResponse` 的 `json` 方法获取一个收集体并从 JSON 中反序列化的 `Future`。如果响应不成功，我们向客户端返回一个错误。现在，我们有了向其他微服务发送请求的方法，并且可以为每个路由实现处理器。
- en: Handlers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: We added methods to proxy incoming requests and resend them to other microservices.
    Now, we can implement handlers for every supported path of our microservice we
    will provide a holistic API to a client, but actually, we will use a set of microservices
    to provide all the necessary services to the client. Let's start with implementation
    of a handler for the `/signup` path.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了代理传入请求并将它们重新发送到其他微服务的方法。现在，我们可以为我们的微服务支持的每个路径实现处理器。我们将为客户端提供一个整体API，但实际上，我们将使用一组微服务向客户端提供所有必要的服务。让我们从实现
    `/signup` 路径的处理器开始。
- en: Signup
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: 'The Router microservice uses the `/signup` route to resend a signup request
    to a users microservice bound to  the `127.0.0.1:8001` address. This request creates
    a new users with filled from `UserForm`, passed with a parameter wrapped with the `Form`
    type. Look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 路由微服务使用 `/signup` 路由将注册请求重新发送到绑定在 `127.0.0.1:8001` 地址的用户微服务。此请求使用 `UserForm`
    填充并带有 `Form` 类型参数创建一个新的用户。看看下面的代码：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We call the `post_request` function that we declared before to send a `POST`
    request to a users microservice and if it returns a successful response, we return
    a response with a `302` status code. We create `HttpResponseBuilder` with the
    corresponding status code by the  `HttpResponse::Found` function call. After this,
    we also set the `LOCATION` header to redirect the user to a login form with the
    `header` method call of `HttpResponseBuilder`. Lastly, we call `finish()` to create
    a `HttpResponse` from a builder and return it as a boxed `Future` object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用之前声明的 `post_request` 函数，向用户微服务发送一个 `POST` 请求，如果它返回一个成功的响应，我们返回一个带有 `302`
    状态码的响应。我们通过 `HttpResponse::Found` 函数调用创建一个带有相应状态码的 `HttpResponseBuilder`。之后，我们还通过
    `HttpResponseBuilder` 的 `header` 方法调用设置 `LOCATION` 标头，将用户重定向到登录表单。最后，我们调用 `finish()`
    从构建器创建一个 `HttpResponse` 并将其作为boxed `Future` 对象返回。
- en: 'The function has a `FutureResponse` return type that is implemented as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数具有 `FutureResponse` 返回类型，其实现如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it's a `Box` with a type that implements a `Future` trait.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它是一个实现了 `Future` 特质的类型的 `Box`。
- en: 'Also, the function expects `Form<UserForm>` as a parameter. The `UserForm`
    structs are declared as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数还期望`Form<UserForm>`作为参数。`UserForm`结构体声明如下：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, it expects two parameters: `email` and `password`. Both will
    be extracted from the query string of a request in the format of `email=user@example.com&password=<secret>`.
    The `Form` wrapper helps to extract data from the response''s body.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它期望两个参数：`email`和`password`。两者都将从请求的查询字符串中提取，格式为`email=user@example.com&password=<secret>`。`Form`包装器有助于从响应体中提取数据。
- en: The `actix_web` crate limits requests and responses by size. If you want to
    send or receive huge payloads, you have to override defaults that often won't
    allow requests larger than 256 KB. For example, if you want to increase the limit,
    you can use the `FormConfig` struct provided with the `with_config` method call
    of `Route`, and call the `limit` method of a config with the desired quantity
    of bytes. The HTTP client is also limited by response size. For example, if you
    try to read a large JSON object from a `JsonBody` instance, you may need to limit
    it with the `limit` method call before you use it as a `Future` object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix_web` 包通过大小限制请求和响应。如果您想发送或接收大量负载，您必须覆盖默认设置，这些设置通常不允许请求超过256 KB。例如，如果您想增加限制，您可以使用`Route`的`with_config`方法调用提供的`FormConfig`结构体，并使用所需字节数调用配置的`limit`方法。HTTP客户端也受到响应大小的限制。例如，如果您尝试从`JsonBody`实例中读取大型JSON对象，您可能需要在将其用作`Future`对象之前使用`limit`方法调用对其进行限制。'
- en: Signin
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: 'Other methods allow users to sign in to a microservice with the provided credentials.
    Look at the following `signin` function that processes requests that are sent
    to the `/signin` path:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法允许用户使用提供的凭据登录到微服务。看看以下发送到`/signin`路径的`signin`函数，它处理发送的请求：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function has two parameters: `HttpRequest` and `Form`. The first we need to get
    access to a shared `State` object. The second we need to extract the `UserForm`
    struct from the request body. We can also use the `post_request` function here,
    but expect it to return a `UserId` value in its response. The `UserId` struct
    is declared as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有两个参数：`HttpRequest`和`Form`。第一个我们需要获取对共享`State`对象的访问权限。第二个我们需要从请求体中提取`UserForm`结构体。我们也可以在这里使用`post_request`函数，但期望它在其响应中返回一个`UserId`值。`UserId`结构体声明如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since `HttpRequest` implements the `RequestIdentity` trait and we plugged in 
    `IdentityService` to `App`, we can call the `remember` method with a user's ID
    to associate the current session with a user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`HttpRequest`实现了`RequestIdentity`特质，并且我们将`IdentityService`连接到了`App`，我们可以使用用户的ID调用`remember`方法，将当前会话与用户关联。
- en: After this, we create a response with the `302` status code, as we did in the
    previous handler, and redirect users to  the `/comments.html` page. But we have
    to build an `HttpResponse` instance from `HttpRequest` to keep the changes of
    the `remember` function call.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个带有`302`状态码的响应，就像我们在前面的处理器中所做的那样，并将用户重定向到`/comments.html`页面。但我们必须从`HttpRequest`构建一个`HttpResponse`实例，以保持`remember`函数调用时的更改。
- en: New comment
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新评论
- en: 'The handler for creating new comments uses the identity of a user to check
    that there are credentials to add a new comment:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新评论的处理程序使用用户的身份来检查是否有凭据添加新评论：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This handler allows every user who has signed it to leave a comment. Let's look
    at how this handler works.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器允许每个已签名的用户留下评论。让我们看看这个处理器是如何工作的。
- en: First, it calls the `identity` method of the `RequestIdentity` trait that returns
    the user's ID. We convert it to `Result` to make it possible to convert it into
    `Future` and return an error if the user is not identified.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它调用`RequestIdentity`特质的`identity`方法，该方法返回用户的ID。我们将它转换为`Result`，以便将其转换为`Future`，并在用户未识别时返回错误。
- en: 'We use the returned user ID value to prepare a request for the comments microservice.
    We extract the `text` field from an `AddComment` form, and create a `NewComment`
    struct with the user ''s ID and a comment. Structs are declared as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用返回的用户ID值来准备对评论微服务的请求。我们从`AddComment`表单中提取`text`字段，并使用用户的ID和评论创建一个`NewComment`结构体。结构体声明如下：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can also use a single struct with an optional `uid`, but it's safer to use
    a separate struct for different needs, because if we use the same struct and resend
    it to another microservice without validation, we can create a vulnerability that
    allows any user to add a comment with another user's identity. Try to avoid these
    kind of mistakes by using exact, strict types, instead of universal, flexible
    ones.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用一个带有可选`uid`的单个结构体，但为了安全起见，最好为不同的需求使用单独的结构体，因为如果我们使用相同的结构体并且在没有验证的情况下将其重新发送到另一个微服务，我们可能会创建一个漏洞，允许任何用户以另一个用户的身份添加评论。通过使用精确、严格的类型而不是通用、灵活的类型来尽量避免这类错误。
- en: Finally, we create a redirect a client as we did before, and send the user to the
    `/comments.html` page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们像之前一样创建一个重定向客户端，并将用户发送到`/comments.html`页面。
- en: Comments
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论
- en: 'To view all comments that were created by the previous handler, we have to
    send a `GET` request to the comments microservice with the `get_request` function
    that we created before and resend the response data to a client:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前处理程序创建的所有评论，我们必须向评论微服务发送一个`GET`请求，使用我们之前创建的`get_request`函数，并将响应数据重新发送给客户端：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Counter
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器
- en: 'The handler that prints the total quantity of requests also has quite simple
    implementation, but in this case, we get access to a shared state:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打印请求总量的处理程序也有相当简单的实现，但在这个案例中，我们能够访问共享状态：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use the `state` method of `HttpRequest` to get a reference to a `State` instance.
    Since the counter value is stored in `RefCell`, we use the `borrow` method to
    get the value from a cell. We implemented all handlers, and now we have to add
    some middleware that will count every request to the microservice.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`HttpRequest`的`state`方法来获取对`State`实例的引用。由于计数器值存储在`RefCell`中，我们使用`borrow`方法从单元格中获取值。我们实现了所有处理程序，现在我们必须添加一些中间件来计算对微服务的每个请求。
- en: Middleware
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: 'The `actix-web` crate supports middleware that can be attached to an `App`
    instance to process every request and response. Middleware helps to log requests,
    transform them, or even control access to a group of paths using regular expressions.
    Consider middleware as handlers for all incoming requests and outgoing responses.
    To create the middleware, we first have to implement the `Middleware` trait for
    it. Look at the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix-web`包支持可以附加到`App`实例上的中间件，以处理每个请求和响应。中间件有助于记录请求、转换它们，甚至可以使用正则表达式控制对一组路径的访问。将中间件视为所有传入请求和传出响应的处理程序。要创建中间件，我们首先必须为其实现`Middleware`特质。看看以下代码：'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We declare an empty `Counter` struct and implement the `Middleware` trait for
    it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个空的`Counter`结构体，并为其实现`Middleware`特质。
- en: The `Middleware` trait has a type parameter with a state. Since we want to use
    the counter of our `State` struct, we set it as a type parameter, but if you want
    to create middleware that is compatible with different states, you need to add
    type parameters to your implementation and add an implementation of necessary
    traits that you can export to your module or crate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Middleware`特质有一个带有状态的类型参数。由于我们想要使用`State`结构体的计数器，我们将其设置为类型参数，但如果你想要创建与不同状态兼容的中间件，你需要添加类型参数到你的实现中，并添加必要的特质的实现，以便你可以将其导出到你的模块或包中。'
- en: 'The `Middleware` trait contains three methods. We implemented all of them:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Middleware`特质包含三个方法。我们实现了所有这些方法：'
- en: '`start` is called when the request is ready and will be sent to a handler'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求准备就绪并将发送到处理程序时调用`start`
- en: '`response` is called after the handler returns a response'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理程序返回响应后调用`response`
- en: '`finish` is called when data has been sent to a client'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据已发送到客户端时调用`finish`
- en: We use the default implementation for the `response` and `finish` methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`response`和`finish`方法使用默认实现。
- en: For the first method, we return a response without any changes in the `Response::Done`
    wrapper. `Response` also has a variant, `Future`, if you want to return a `Future`
    that generates an `HttpResponse`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，我们在`Response::Done`包装器中返回没有任何更改的响应。如果想要返回生成`HttpResponse`的`Future`，`Response`还有一个`Future`变体。
- en: For the second method, we return a `Done` variant of the `Finished` enum. It
    also has a `Future` variant that can contain a boxed `Future` object, which will
    be run after the `finish` method ends. Let's explore how the `start` method works
    in our implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种方法，我们返回`Finished`枚举的`Done`变体。它还有一个可以包含boxed `Future`对象的`Future`变体，该对象将在`finish`方法结束后运行。让我们来探讨一下在我们的实现中`start`方法是如何工作的。
- en: 'In the `start` method implementation of the `Counter` middleware, we will count
    all incoming requests. To do this, we get the current counter value from `RefCell`,
    add `1`, and replace the cell with a new value. At the end, the method returns
    a `Started::Done` value to notify you that the current request will be reused
    in the next handler/middleware of the processing chain. The `Started` enum also
    has variants:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Counter`中间件的`start`方法实现中，我们将计算所有传入的请求。为此，我们从`RefCell`获取当前计数器的值，加`1`，并用新值替换单元格。最后，该方法返回一个`Started::Done`值，通知您当前请求将在处理链的下一个处理器/中间件中重用。`Started`枚举还有其他变体：
- en: '`Response` should be used if you want to return a response immediately'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想立即返回响应，则应使用`Response`。
- en: '`Future` should be used if you want to run a `Future` that will return a response'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想运行一个将返回响应的`Future`，则应使用`Future`。
- en: Now, the microservice is ready to build and run.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，微服务已经准备好构建和运行。
- en: Building and running
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行
- en: To run a microservice, use the `cargo run` command. Since we don't have an other
    microservice for handlers, we can use the `counter` method to check that the server
    and `Counter` middleware works. Try to open `http://127.0.0.1:8080/stats/counter` in
    the browser. It will show a `1` value on a blank page. If you refresh the page,
    you will see a `3` value. That's because the browser also sends a request to get
    a `favicon.ico` file after the main request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行微服务，请使用`cargo run`命令。由于我们没有其他微服务用于处理器，我们可以使用`counter`方法来检查服务器和`Counter`中间件是否正常工作。尝试在浏览器中打开`http://127.0.0.1:8080/stats/counter`。它将在空白页面上显示一个`1`值。如果你刷新页面，你会看到一个`3`值。那是因为浏览器在主请求之后也会发送一个请求来获取`favicon.ico`文件。
- en: Using databases
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: Another good feature of `actix-web`, in combination with the `actix` crate,
    is the ability to use databases. Do you remember how we used `SyncArbyter` to
    perform background tasks? It's a good approach to implement database interaction
    since there are not enough asynchronous database connectors and we have to use
    synchronous ones. Let's add the caching of responses to a Redis database for our
    previous example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`actix-web`与`actix` crate结合的另一个好功能是使用数据库的能力。你还记得我们如何使用`SyncArbyter`来执行后台任务吗？这是一个实现数据库交互的好方法，因为异步数据库连接器不足，我们必须使用同步的。让我们为我们的上一个示例添加将响应缓存到Redis数据库的功能。'
- en: The database interaction actor
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库交互actor
- en: 'We start by implementing an actor that interacts with a database. Copy the
    previous example and add the `redis` crate to the dependencies:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现一个与数据库交互的actor。复制上一个示例并添加`redis` crate到依赖项中：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use Redis because it's great for caching, but we can also store cached values
    in memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Redis，因为它非常适合缓存，但我们也可以在内存中存储缓存的值。
- en: 'Create a `src/cache.rs` module and add the following dependencies:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`src/cache.rs`模块并添加以下依赖项：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It adds types from the `redis` crate that we already used in [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable
    Integration with Databases*, to interact with Redis storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了来自`redis` crate的类型，我们已经在第7章[与数据库的可靠集成](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml)中使用过，用于与Redis存储交互。
- en: Actors
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actors
- en: 'Our actor has to keep an instance of `Client`. We don''t use a connection pool,
    because we will use multiple actors for handing parallel requests to a database.
    Look at the following struct:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的actor必须保持一个`Client`实例。我们不使用连接池，因为我们将为处理数据库的并行请求使用多个actor。看看下面的结构：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The struct also contains an `expiration` field that holds the **time-to-live**
    (**TTL**) period. This defines how long Redis will hold the value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 结构中还包含一个`expiration`字段，该字段持有**生存时间**（**TTL**）周期。这定义了Redis将保持值的时间。
- en: 'Add a `new` method to the implementation that uses a provided address string
    to create a `Client` instance, and adds both the `client` and `expiration` values
    to the `CacheActor` struct, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中添加一个`new`方法，该方法使用提供的地址字符串创建一个`Client`实例，并将`client`和`expiration`值添加到`CacheActor`结构中，如下所示：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, we have to implement an `Actor` trait for `SyncContext`, just as we did
    when resizing the worker in [Chapter 10](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml),
    *Background Tasks and Thread Pools in Microservices*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为`SyncContext`实现一个`Actor` trait，就像我们在第10章[背景任务和线程池在微服务中](ba240208-414e-4dd4-bba8-8bd2658949cd.xhtml)中调整工作者时做的那样：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we can add support for messages to set and get cached values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加支持设置和获取缓存值的消息。
- en: Messages
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Messages
- en: 'To interact with `CacheActor`, we have to add two types of messages: to set
    a value and to get a value.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`CacheActor`交互，我们必须添加两种类型的消息：设置值和获取值。
- en: Setting a value message
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置值消息
- en: 'The first message type we add is `SetValue`, which provides a pair of key and
    new value for caching. The struct has two fields—`path`, which is used as a key,
    and `content`, which holds a value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一个消息类型是`SetValue`，它提供了一对用于缓存的键和新的值。结构体有两个字段——`path`用作键，`content`持有值：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s implement a `Message` trait for the `SetValue` struct with an empty
    unit type if the value is set, and return `RedisError` if there are issues with
    a database connection:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`SetValue`结构体实现一个`Message`特质，如果设置了值，则使用空单元类型，如果数据库连接有问题，则返回`RedisError`：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`CacheActor` has support for receiving `SetValue` messages. Let''s implement
    this with the `Handler` trait:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheActor`支持接收`SetValue`消息。让我们使用`Handler`特质来实现这一点：'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We used a `Client` instance stored in `CacheActor` to execute the `SETEX` command
    from Redis with the `set_ex` method call. This command sets a value with an expiration
    period in seconds. As you can see, the implementation is close to the database
    interaction functions of [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable
    Integration with Databases*, but implemented as a `Handler` of the specific message.
    This code structuring is simpler and more intuitive.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用存储在`CacheActor`中的`Client`实例通过`set_ex`方法调用执行Redis的`SETEX`命令。这个命令以秒为单位设置一个带有过期时间的值。如您所见，实现接近第七章[可靠与数据库集成](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml)的数据库交互函数，但作为特定消息的`Handler`实现。这种代码结构更简单、更直观。
- en: Get value message
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取值消息
- en: 'The `GetValue` struct represents a message to extract a value from Redis by
    key (or path, in our case). It contains only one field with a `path` value:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetValue`结构体代表一个通过键（或路径，在我们的情况下）从Redis提取值的消息。它只包含一个带有`path`值的字段：'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also have to implement the `Message` trait to it, but we want it to return
    an optional `Vec<u8>` value if Redis contains a value for the provided key:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须实现`Message`特质，但我们希望它返回一个可选的`Vec<u8>`值，如果Redis包含提供的键的值：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`CacheActor` also implements a `Handler` trait for the `GetValue` message type,
    and uses the `GET` command of Redis storage by calling the `get` method of `Client` to
    extract a value from storage:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheActor`还实现了`GetValue`消息类型的`Handler`特质，并调用`Client`的`get`方法通过Redis存储的`GET`命令提取存储中的值：'
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, actors and messages are simple enough, but we have to use an `Addr`
    value to interact with them. It's not a concise approach. We will add a special
    type that allows methods to interact with the `CacheActor` instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，演员和消息足够简单，但我们必须使用`Addr`值来与他们交互。这不是一个简洁的方法。我们将添加一个特殊类型，允许方法与`CacheActor`实例交互。
- en: Link to actor
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接到演员
- en: 'The following struct wraps an address of `CacheActor`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结构体包装了`CacheActor`的地址：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constructor only fills this `addr` field with an `Addr` value:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只填充这个`addr`字段以一个`Addr`值：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need a `CacheLink` wrapping struct to add methods to get access to caching
    features, but need to hide the implementation details and message interchange.
    First, we need a method to get cached values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`CacheLink`包装结构体来添加获取缓存功能的方法，但需要隐藏实现细节和消息交互。首先，我们需要一个获取缓存值的方法：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding function creates a new `GetValue` message with a `path` inside,
    and sends this message to `Addr`, contained in `CacheLink`. After this, it waits
    for the result. The function returns this interaction sequence as a boxed `Future`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数创建了一个带有`path`的新`GetValue`消息，并将此消息发送到`CacheLink`中包含的`Addr`。之后，它等待结果。函数返回这个交互序列作为一个boxed
    `Future`。
- en: 'The next method is implemented in a similar way—the `set_value` method sets
    a new value to a cache by sending a `SetValue` message to `CacheActor`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法以类似的方式实现——`set_value`方法通过向`CacheActor`发送`SetValue`消息来设置缓存中的新值：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To compose a message, we use a `path` and a bytes array reference converted
    into a `Vec<u8>` value. Now, we can use `CacheActor` and `CacheLink` in a server
    implementation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合一个消息，我们使用一个`path`和一个字节数组引用转换为`Vec<u8>`值。现在，我们可以在服务器实现中使用`CacheActor`和`CacheLink`。
- en: Using database actors
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库演员
- en: 'In the previous example in this chapter, we used shared `State` to provide
    access to a counter stored as `i64`, wrapped with `RefCell`. We reuse this struct,
    but add a `CacheLink` field to use connections with a `CacheActor` to get or set
    cached values. Add this field:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们使用了共享的`State`来提供对存储为`i64`的计数器的访问，并用`RefCell`包装。我们重用这个结构体，但添加一个`CacheLink`字段来使用与`CacheActor`的连接来获取或设置缓存值。添加此字段：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We derived a `Default` trait for the `State` struct before, but now we need
    a new constructor, because we have to provide a `CacheLink` instance with the
    actual address of the caching actor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为`State`结构体推导了一个`Default`特质，但现在我们需要一个新的构造函数，因为我们必须提供一个带有缓存演员实际地址的`CacheLink`实例：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In most cases, caching works this way—it tries to extract a value from a cache;
    if it exists and hasn't expired, then the value is returned to a client. If there
    is no valid value, we need to obtain a new one. After we have taken it, we have
    to store it in a cache for future use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，缓存是这样工作的——它试图从一个缓存中提取一个值；如果它存在且未过期，则将值返回给客户端。如果没有有效的值，我们需要获取一个新的值。在我们获取它之后，我们必须将其存储在缓存中以供将来使用。
- en: 'In the previous example, we often used a `Future` instance that receives a
    `Response` from another microservice. To simplify our use of caching, let''s add the
    `cache` method to our `State` implementation. This method will wrap any provided
    `future` with a path and try to extract the cached value. If the value isn''t
    available, it will obtain a new one, and afterwards, it receives the store-copied
    value to cache, and returns the value to the client. This method wraps the provided
    `Future` value with another `Future` trait implementation. Look at the following
    implementation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们经常使用一个接收来自另一个微服务的`Response`的`Future`实例。为了简化我们对缓存的用法，让我们向我们的`State`实现添加`cache`方法。此方法将任何提供的`future`包装在一个路径中，并尝试提取缓存的值。如果值不可用，它将获取一个新的值，之后，它接收存储复制的值以缓存，并将值返回给客户端。此方法将提供的`Future`值包装在另一个`Future`特质实现中。看看以下实现：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The implementation uses the `State` instance to clone `CacheLink`. We have to
    use a cloned `link` because we have to move it to the closure that uses it to
    store a new value, should we need to obtain it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实现使用`State`实例来克隆`CacheLink`。我们必须使用克隆的`link`，因为我们必须将其移动到使用它的闭包中，以存储一个新值，如果我们需要获取它的话。
- en: First, we call the `get_value` method of `CacheLink` and get a `Future` that
    requests a value from the cache. Since the method returns `Option`, we will use the
    `and_then` method to check that the value exists in a cache, and return that value
    to the client. If the value is expired or not available, we will obtain it by
    executing the provided `Future` and use a link to call the `set_value` method
    if the new value is returned successfully.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`CacheLink`的`get_value`方法，并获取一个请求从缓存中获取值的`Future`。由于该方法返回`Option`，我们将使用`and_then`方法检查该值是否存在于缓存中，并将该值返回给客户端。如果值已过期或不可用，我们将通过执行提供的`Future`来获取它，如果返回新值，则使用链接调用`set_value`方法。
- en: 'Now, we can use the `cache` method to cache the list of comments that are returned
    for the `comments` handler of the previous example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`cache`方法来缓存前一个例子中`comments`处理程序返回的评论列表：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we create a `Future` to get a value from another microservice using the
    `get_request` method that we have implemented before. After that, we get a reference
    to `State` using the `state` method of the request, and call the `cache` method
    by passing the `/list` path, then create a `Future` instance to obtain a new value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`Future`，使用我们之前实现的`get_request`方法从另一个微服务获取值。之后，我们使用请求的`state`方法获取`State`的引用，通过传递`/list`路径调用`cache`方法，然后创建一个`Future`实例以获取新值。
- en: 'We have implemented all of the parts of our database actor. We still need to
    start a set of caching actors with `SyncArbiter`, and wrap the returned `Addr`
    value with `CacheLink`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了我们数据库演员的所有部分。我们仍然需要使用`SyncArbiter`启动一组缓存演员，并将返回的`Addr`值包装在`CacheLink`中：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, you can build the server. It will return the cached value of the `/api/list`
    request every 10 seconds.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以构建服务器。它将每10秒返回`/api/list`请求的缓存值。
- en: The other good benefit of using actors is WebSocket. With this, we can add stateful
    interaction to our microservices using a state-machine implemented as an actor.
    Let's look at this in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用演员的另一个好处是WebSocket。有了这个，我们可以通过作为演员实现的状态机添加有状态交互到我们的微服务中。让我们在下一节中看看这个。
- en: WebSocket
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: WebSocket is a full-duplex communication protocol worked over HTTP. WebSockets
    are often used as an extension of main HTTP interaction and can be used for live
    updates or notifications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种全双工通信协议，通过HTTP工作。WebSockets通常作为主要HTTP交互的扩展使用，可用于实时更新或通知。
- en: 'An actors model is well-suited for implementing WebSocket handlers, because
    you can combine and isolate code in a single place: in the implementation of the
    actor. `actix-web` supports the WebSocket protocol, and in this section, we will
    add notification functionality to our microservice. Maybe all the features we
    have implemented with `actix-web` make our example a bit complex, but it''s important
    for demonstration purposes to keep all features to show how you can combine a
    server with multiple actors and tasks.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型非常适合实现WebSocket处理器，因为你可以将代码组合和隔离在一个地方：在演员的实现中。`actix-web`支持WebSocket协议，在本节中，我们将向我们的微服务添加通知功能。也许我们用`actix-web`实现的所有功能使我们的示例变得有些复杂，但为了演示目的，保持所有功能以展示如何将服务器与多个演员和任务结合在一起是非常重要的。
- en: Repeater actor
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复演员
- en: We have to send notifications about new comments to all connected clients. To
    do this, we have to keep the list of all connected clients to send a notification
    to them. We could update the `State` instance on every connection to add every
    new client to it, but instead, we will create a more elegant solution with a router
    that resends messages to multiple subscribers. Subscribers or listeners, in this
    case, will be actors that handle incoming WebSocket connections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须向所有连接的客户端发送关于新评论的通知。为此，我们必须保留所有连接客户端的列表以向他们发送通知。我们可以在每次连接时更新`State`实例以将每个新客户端添加到其中，但我们将创建一个更优雅的解决方案，使用一个路由器将消息重新发送给多个订阅者。在这种情况下，订阅者或监听器将是处理传入WebSocket连接的演员。
- en: Actors
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'We will add an actor to resend messages to other actors. We need some basic
    types from the `actix` crate, along with a `HashSet` to keep addresses of actors.
    Import the `NewComment` struct, which we will clone and resend:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个演员来重新发送消息给其他演员。我们需要从`actix`crate中获取一些基本类型，以及一个`HashSet`来保存演员的地址。导入`NewComment`结构体，我们将克隆并重新发送：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add a `RepeaterActor` struct with a `listeners` field of the `HashSet` type
    that contains `Recipient` instances:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个包含`Recipient`实例的`HashSet`类型的`listeners`字段的`RepeaterActor`结构体：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You are familiar with the `Addr` type, but we haven't used `Recipient` before.
    Actually, you can convert any `Addr` instance into a `Recipient` using the `recipient`
    method call. The `Recipient` type is an address that supports only one type of
    `Message`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉`Addr`类型，但我们之前还没有使用过`Recipient`。实际上，你可以使用`recipient`方法调用将任何`Addr`实例转换为`Recipient`。`Recipient`类型是一个只支持一种`Message`类型的地址。
- en: 'Add a constructor that creates an empty `HashSet`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个构造函数来创建一个空的`HashSet`：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, implement an `Actor` trait for this struct:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为这个结构体实现`Actor`特质：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It's enough to have a standard `Context` type as an associated context type
    of `Actor`, because it can work asynchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要一个标准的`Context`类型作为`Actor`的关联上下文类型就足够了，因为它可以异步工作。
- en: Now, we have to add messages to this actor type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须向这个演员类型添加消息。
- en: Messages
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: We will support two types of messages. The first is an update message that transfers
    a new comment from one actor to another. The second is a control message that
    adds or removes listeners to the actor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将支持两种类型的消息。第一种是更新消息，它将一个新评论从一个演员传输到另一个演员。第二种是控制消息，它向演员添加或删除监听器。
- en: Updating the message
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新消息
- en: 'We will start with updating the message. Add a `RepeaterUpdate` struct that
    wraps a `NewComment` type:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更新消息开始。添加一个包装`NewComment`类型的`RepeaterUpdate`结构体：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, we also derived the `Clone` trait, because we need to clone
    this message to resend it to multiple subscribers. `NewComment` also has to be
    cloneable now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们还推导了`Clone`特质，因为我们需要克隆这条消息以将其重新发送给多个订阅者。`NewComment`现在也必须是可克隆的。
- en: 'Let''s implement the `Message` trait for the `RepeaterUpdate` struct. We will
    use an empty type for the `Result` associated type, because we don''t care about the
    delivery of these messages:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`RepeaterUpdate`结构体实现`Message`特质。我们将为`Result`关联类型使用一个空类型，因为我们不关心这些消息的投递：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can implement a `Handler` for the `RepeaterUpdate` message type:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`RepeaterUpdate`消息类型实现一个`Handler`：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The algorithm of the handler is simple: it iterates over all listeners (actually,
    addresses of listeners stored as `Recipient` instances) and sends a cloned message
    to them. In other words, this actor receives a message and immediately sends it
    to all known listeners.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的算法很简单：它遍历所有监听器（实际上，存储为`Recipient`实例的监听器地址）并向它们发送克隆的消息。换句话说，这个演员接收一条消息，然后立即将其发送给所有已知的监听器。
- en: Control message
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制消息
- en: 'The following message type is necessary to subscribe or unsubscribe from `RepeaterUpdate`
    messages. Add the following enumeration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下消息类型是订阅或取消订阅`RepeaterUpdate`消息所必需的。添加以下枚举：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It has two variants with the same `Recipient<RepeaterUpdate>` type inside. Actors
    will send their own `Recipient` addresses to start listening for updates or to
    stop any notifications about new comments.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个变体，内部具有相同的`Recipient<RepeaterUpdate>`类型。actor将发送它们自己的`Recipient`地址以开始监听更新或停止关于新评论的任何通知。
- en: 'Implement the `Message` trait for the `RepeaterControl` struct to turn it into
    the `message` type and use an empty `Result` associated type:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为`RepeaterControl`结构实现`Message`特质，将其转换为`message`类型并使用一个空的`Result`关联类型：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can implement a `Handler` trait for the `RepeaterControl` message:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`RepeaterControl`消息实现一个`Handler`特质：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The implementation of the preceding handler is also pretty simple: it adds
    a new `Recipient` to listeners set on the `Subscribe` message variant, and removes
    the `Recipient` upon `Unsubscribe` messages.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个处理器的实现也很简单：它在`Subscribe`消息变体上添加一个新的`Recipient`到监听器集合中，并在`Unsubscribe`消息中移除`Recipient`。
- en: The actor that resends `NewComment` values to other actors is ready, and now
    we can start to implement an actor for handling WebSocket connections.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重发`NewComment`值的actor已经准备好了，现在我们可以开始实现一个处理WebSocket连接的actor。
- en: The notification actor
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知actor
- en: The notification actor is actually a handler of WebScoket connections, but it
    performs only one function—sending a `NewComment` value, serialized to JSON, to
    clients.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通知actor实际上是WebSocket连接的处理程序，但它只执行一个功能——将`NewComment`值序列化为JSON并发送给客户端。
- en: 'Since we need a JSON serializer, add the `serde_json` crate to dependencies:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个JSON序列化器，将`serde_json`crate添加到依赖项中：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then, add the `src/notify.rs` module and start implementing the actor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`src/notify.rs`模块并开始实现actor。
- en: Actor
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员
- en: 'The notification actor is more complex and we need more types to implement
    it. Let''s look into them:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通知actor更复杂，我们需要更多类型来实现它。让我们来看看它们：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, we started by using the `ws` module of the `actix_web` crate. It contains
    a necessary `WebsocketContext` that we will use as a context value in the `Actor`
    trait implementation. Also, we need `Message` and `ProtocolError` types to implement
    WebSocket stream handling. We also imported `ActorContext` to stop the method
    of the `Context` instance to break the connection with a client. We imported the `AsyncContext`
    trait to get an address of a context and to run a task that performs on time intervals.
    One new type that we have not used yet is `StreamHandler`. It is necessary to
    implement the handing of values that are sent from `Stream` to `Actor`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始使用`actix_web`crate的`ws`模块。它包含必要的`WebsocketContext`，我们将将其用作`Actor`特质实现中的上下文值。我们还需要`Message`和`ProtocolError`类型来实现WebSocket流处理。我们还导入了`ActorContext`以停止`Context`实例的方法来断开与客户端的连接。我们导入了`AsyncContext`特质以获取上下文的地址并运行在时间间隔上执行的任务。我们还没有使用的一个新类型是`StreamHandler`。它是实现从`Stream`发送到`Actor`的值的处理所必需的。
- en: 'You can use either `Handler` or `StreamHandler` for handling messages of the
    same type. Which one is preferable? The rule is simple: if your actor will process
    a lot of messages, it''s better to use `StreamHandler` and connect the messages
    flow as a `Stream` to an `Actor`. The `actix` runtime has check and if it calls
    the same `Handler`, you may receive warnings.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Handler`或`StreamHandler`来处理相同类型的消息。哪个更可取？规则很简单：如果你的actor将处理大量消息，最好使用`StreamHandler`并将消息流连接为一个`Stream`到`Actor`。`actix`运行时会进行检查，如果它调用相同的`Handler`，你可能会收到警告。
- en: 'Add the constants that we will use for sending `ping` messages to our clients:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们将用于向客户端发送`ping`消息的常量：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The constants contain interval and timeout values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 常量包含间隔和超时值。
- en: We will send pings to a client, because we have to keep a connection alive,
    since servers often have default timeouts for WebSocket connections. For example,
    `nginx` will close the connection after 60 seconds if there isn't any activity.
    And if you use `nginx` as a proxy with default configuration for WebSocket connections,
    then your connections can be broken. Browsers don't send pings and only send pongs
    for incoming pings. The server is responsible for sending pings to clients connected
    via browsers to prevent disconnecting through a timeout.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向客户端发送ping，因为我们必须保持连接活跃，因为服务器通常为WebSocket连接设置默认的超时时间。例如，如果没有任何活动，`nginx`将在60秒后关闭连接。如果你使用默认配置的`nginx`作为WebSocket连接的代理，那么你的连接可能会被中断。浏览器不会发送ping，只会对传入的ping发送pong。服务器负责向通过浏览器连接的客户端发送ping，以防止因超时而断开连接。
- en: 'Add the following `NotifyActor` struct to the code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`NotifyActor`结构体添加到代码中：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This actor has a `last_ping` of the `Instant` type to keep the timestamp of
    the latest ping. Also, the actor holds a `Recipient` address to send `RepeaterControl`
    messages. We will provide the address of `RepeaterActor` for this field with the
    constructor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此actor有一个`last_ping`字段，用于保存最新ping的时间戳。此外，actor还持有`Recipient`地址以发送`RepeaterControl`消息。我们将使用构造函数提供`RepeaterActor`的地址：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we have to implement the `Actor` trait for the `NotifyActor` struct:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为`NotifyActor`结构体实现`Actor`特质：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is the first time where we need to override the empty `started` and `stopped`
    methods. In the `started` method implementation, we will create a `Subscribe`
    message and send it using `Repeater`. Also, we add a task that will be executed
    on `PING_INTERVAL` and will send a ping message using the `ping` method of `WebsocketContext`.
    If a client never responds to us, then the `last_ping` field won't be updated.
    If the interval is larger than our `PING_TIMEOUT` value, we will interrupt the
    connection using the `stop` method of the context.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次需要重写空的`started`和`stopped`方法。在`started`方法实现中，我们将创建一个`Subscribe`消息并通过`Repeater`发送它。此外，我们添加一个将在`PING_INTERVAL`上执行的任务，并使用`WebsocketContext`的`ping`方法发送ping消息。如果客户端从未向我们响应，则`last_ping`字段不会更新。如果间隔大于我们的`PING_TIMEOUT`值，我们将使用上下文的`stop`方法中断连接。
- en: 'The `stopped` method implementation is much simpler: it prepares an `Unsubscribe`
    event with the same address of the actor and sends it to `RepeaterActor`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopped`方法实现要简单得多：它准备一个与actor相同地址的`Unsubscribe`事件，并将其发送给`RepeaterActor`。'
- en: Our actor implementation is ready and now we have to add handlers for messages
    and a stream.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了actor实现，现在我们必须添加消息和流的处理器。
- en: Handlers
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: 'First, we will implement a `StreamHandler` instance of the `ws::Message` messages:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现`ws::Message`消息的`StreamHandler`实例：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is a basic approach for implementing the WebSocket protocol interaction
    with `actix-web`. We will use the `ws::start` method later to attach a `Stream`
    of WebSocket messages to this actor.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`actix-web`实现WebSocket协议交互的基本方法。我们将在稍后使用`ws::start`方法将WebSocket消息的`Stream`附加到此actor。
- en: The `Message` type has multiple variants that reflects types of WebSocket messages
    from RFC 6455 (the official protocol specification). We use `Ping` and `Pong`
    to update the `last_ping` field of the actor's struct, and use `Close` to stop
    the connection by user's demand.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类型有多个变体，反映了RFC 6455（官方协议规范）中的WebSocket消息类型。我们使用`Ping`和`Pong`来更新actor结构体的`last_ping`字段，并使用`Close`来根据用户的要求停止连接。'
- en: 'The last `Handler` we have to implement allows us to receive `RepeaterUpdate`
    messages and to send `NewComment` values to a client:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现的最后一个`Handler`允许我们接收`RepeaterUpdate`消息并将`NewComment`值发送给客户端：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The implementation destructs a `RepeaterUpdate` message to get a `NewComment`
    value, serializes it to JSON using the `serde_json` crate, and sends it to a client
    using the `text` method of `WebsocketContext`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实现会解构一个`RepeaterUpdate`消息以获取`NewComment`值，使用`serde_json`crate将其序列化为JSON，并通过`WebsocketContext`的`text`方法将其发送给客户端。
- en: We have all necessary actors, so let's join them with a server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有必要的actor，所以让我们将它们与服务器连接起来。
- en: Adding WebSocket support to a server
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为服务器添加WebSocket支持
- en: 'Since we will be extended the example from the previous section, we reuse the
    `State` struct, but add an `Addr` to the `Repeater` actor that we will create
    later in the `main` function:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将扩展上一节中的示例，我们将重用`State`结构体，但为稍后在`main`函数中创建的`Repeater`actor添加一个`Addr`：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Update the constructor to fill the `repeater` field:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更新构造函数以填充`repeater`字段：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can spawn a `RepeaterActor`, set the address of the actor to `State`,
    and use it as the state for our `App`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 `RepeaterActor`，将演员的地址设置为 `State`，并将其用作我们 `App` 的状态：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Also, we added a handler for HTTP requests with a resource method call of `App`,
    and passed the `ws_connect` function to it. Let''s look at the implementation
    of this function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了一个处理 HTTP 请求的处理程序，该处理程序具有 `App` 的资源方法调用，并将 `ws_connect` 函数传递给它。让我们看看这个函数的实现：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This clones an address of `RepeaterActor`, converting it into a `Recipient` which
    is then used for creating a `NotifyActor` instance. To start that actor instance,
    you have to use the `ws::start` method that uses the current `Request` and bootstraps `WebsocketContext`
    for this actor.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `RepeaterActor` 的地址克隆成一个 `Recipient`，然后用于创建一个 `NotifyActor` 实例。要启动该演员实例，你必须使用
    `ws::start` 方法，该方法使用当前的 `Request` 并为该演员启动 `WebsocketContext`。
- en: 'The remaining thing is to send a `NewComment` to `RepeaterActor`, which will
    resend it to any `NotifyActor` instances of connected clients:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是将一个 `NewComment` 发送到 `RepeaterActor`，它将重新发送到任何连接客户端的 `NotifyActor` 实例：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We extended the `new_comment` handler that is called when a user adds a new
    comment, and add an extra step to send a `NewComment` value to a repeater. In
    any case, we ignore the result of delivery of this message to an actor, and we
    send a POST request to another microservice. It's worth noting that clients will
    be notified about the new comment, even it won't send to the other microservice,
    but you can improve it by changing the order of the corresponding `Future` in
    the chain.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了当用户添加新评论时被调用的 `new_comment` 处理程序，并添加了一个额外的步骤来向重复器发送 `NewComment` 值。在任何情况下，我们都会忽略将此消息发送给演员的结果，并向另一个微服务发送
    POST 请求。值得注意的是，即使没有发送到其他微服务，客户端也会收到关于新评论的通知，但你可以通过改变链中相应 `Future` 的顺序来改进它。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered creating a microservice using the Actix framework.
    We discovered how to create and configure an `App` instance, which describes all
    routes and middleware to be used. After that, we implemented all handlers that
    return a `Future` instance. In all handlers, we also use `ClientRequest` to send
    a request to another microservice and return a response back to the client using
    an asynchronous approach with futures. Finally, we explored how to create our
    own `Middleware` for the `actix-web` crate.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 Actix 框架创建微服务。我们发现了如何创建和配置一个 `App` 实例，该实例描述了所有要使用的路由和中间件。之后，我们实现了所有返回
    `Future` 实例的处理程序。在所有处理程序中，我们也使用 `ClientRequest` 向另一个微服务发送请求，并使用异步方法通过 futures
    将响应返回给客户端。最后，我们探讨了如何为 `actix-web` 包创建自己的 `Middleware`。
- en: In the next chapter, we'll examine the scalable microservices architecture,
    and look at how to achieve loose coupling of microservices. We'll also consider
    the use of message brokers to provide a flexible and manageable way to exchange
    messages between parts of a large application.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将检查可扩展的微服务架构，并探讨如何实现微服务之间的松耦合。我们还将考虑使用消息代理以灵活和可管理的方式在大型应用程序的部分之间交换消息。
