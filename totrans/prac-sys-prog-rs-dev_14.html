<html><head></head><body>
		<div><h1 id="_idParaDest-172"><em class="italic"><a id="_idTextAnchor180"/>Chapter 11</em>: <a id="_idTextAnchor181"/>Learning Network Programming</h1>
			<p>In the previous chapter, we learned how to communicate with peripheral devices from Rust programs. In this chapter, we will switch our focus to another important system programming topic – networking.</p>
			<p>Most modern operating systems, including Unix/Linux and Windows variants, have native support for networking using TCP/IP. Do you know how you can use TCP/IP to send byte streams or messages from one computer to another? Do you want to know what kind of language support Rust provides for synchronous network communications between two processes running on different machines? Are you interested in learning the basics of configuring TCP and UDP sockets, and working with network addresses and listeners in Rust? Then, read on.</p>
			<p>We will cover these topics in the following order:</p>
			<ul>
				<li>Reviewing networking basics in Linux</li>
				<li>Understanding networking primitives in the Rust standard library</li>
				<li>Programming with TCP and UDP in Rust</li>
				<li>Writing a TCP reverse proxy (project)</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to work with network addresses, determine address types, and do address conversions. You will also learn how to create and configure sockets and query on them. You will work with TCP listeners, create a TCP socket server, and receive data. Lastly, you'll put these concepts into practice through an example project.</p>
			<p>It is important to learn these topics because sockets-based programming using TCP or UDP forms the basis for writing distributed programs. Sockets help two processes on different (or even the same) machines to establish communication with each other and exchange information. They form the foundation for practically all web and distributed applications on the internet, including how an internet browser accesses a web page and how a mobile application retrieves data from an API server. In this chapter, you will learn what kind of support is provided by the Rust standard library for <em class="italic">socket-based</em> network communications.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>Verify that <code>rustup</code>, <code>rustc</code>, and <code>cargo</code> have been installed correctly with the following command: </p>
			<pre>rustup --version
rustc --version
cargo --version</pre>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter11</a>.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Reviewing networking basics in Linux</h1>
			<p>The internet <a id="_idIndexMarker769"/>connects several different networks across the <a id="_idIndexMarker770"/>globe, enabling machines across networks to communicate with each other in different ways, including the <strong class="bold">request-response</strong> model (synchronous), <strong class="bold">asynchronous messaging</strong>, and <strong class="bold">publish-subscribe</strong>-style notifications. <em class="italic">Figure 11.1</em> shows an example of a connection between two networks:</p>
			<div><div><img src="img/Figure_11.1_B16405.jpg" alt="Figure 11.1 – Internet router connecting two networks"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Internet router connecting two networks</p>
			<p>The internet also provides abstractions in the form of <strong class="bold">networking protocols and standards</strong> to make it easy for hosts on different networks to communicate with each other. </p>
			<p>Examples of <a id="_idIndexMarker771"/>standards include a common <em class="italic">host addressing format</em>, a <a id="_idIndexMarker772"/>combination of host address and port to define a <em class="italic">network endpoint</em>. The IP address of a host is a <em class="italic">32-bit</em> number for IPv4 addresses and a <em class="italic">128-bit</em> number for IPv6 addresses.</p>
			<p>Examples of network protocols include for web browsers to <a id="_idIndexMarker773"/>retrieve documents from web servers, <strong class="bold">domain name system</strong> (<strong class="bold">DNS</strong>) to map domain names to host addresses, the IP protocol to package and route packets of data across the internet, and TCP to add reliability and error handling for IP data packets.</p>
			<p>In particular, <em class="italic">networking protocols</em> are very important in defining how information is transmitted and interpreted by programs running in different host computers across different networks. The <strong class="bold">TCP/IP protocol suite</strong> is the foundation of how the internet, which we use on a daily basis, enables our digital world of information, transactions, and entertainment.</p>
			<p><em class="italic">Figure 11.2</em> shows the layered <a id="_idIndexMarker774"/>TCP/IP protocol suite:</p>
			<div><div><img src="img/Figure_11.2_B16405.jpg" alt="Figure 11.2 – Internet router connecting two networks"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Internet router connecting two networks</p>
			<p>In the previous chapter, we discussed device drivers. In <em class="italic">Figure 11.2</em>, the lowest layer of the <em class="italic">TCP/IP protocol suite</em> shown – the <strong class="bold">data link layer</strong> – comprises the <strong class="bold">device driver</strong> and <strong class="bold">network interface card</strong> corresponding to the <a id="_idIndexMarker775"/>network medium used for communication <a id="_idIndexMarker776"/>between the hosts (for example, coax cable, fiber, or wireless). The data link layer assembles data packets received from the higher network (IP) layer into <strong class="bold">data frames</strong>, and transmits them over the physical link.</p>
			<p>The next layer up in the TCP/IP protocol suite is the <strong class="bold">IP layer</strong>, which is the most important layer in the TCP/IP stack. It assembles data into packets and sends them to the data link layer. The IP layer is also responsible for routing data across the internet. This is achieved by adding a header for each datagram (packet) transmitted, which includes the address of the remote host to which the packet should be transmitted. Two packets sent from host A to host B can take different routes through the internet. IP is a connectionless protocol, which means there is no communication channel created between two hosts to have multi-step communication. This layer just sends a data packet from one host IP address to another host IP address without any guarantees.</p>
			<p>The next layer up in the TCP/IP protocol suite is the <strong class="bold">transport layer</strong>. Here, there are two popular <a id="_idIndexMarker777"/>protocols used on the internet – TCP and UDP. <strong class="bold">TCP</strong> stands for <strong class="bold">transmission control protocol</strong> and <strong class="bold">UDP</strong> is <strong class="bold">user datagram protocol</strong>. While the <a id="_idIndexMarker778"/>network (IP) layer is concerned with sending data packets between two hosts, the transport layer (TCP and UDP) is concerned with sending data streams between two processes (applications or programs) running on the same host or different hosts.</p>
			<p>If there are two applications running on a single host IP address, the way to uniquely identify each application is by using a <em class="italic">port number</em>. Each application that is involved in network communications listens on a specific port, which is a 16-bit number.</p>
			<p>Examples of popular ports are <code>80</code> for the <em class="italic">HTTP</em> protocol, <code>443</code> for the <em class="italic">HTTPS</em> protocol, and <code>22</code> for the <em class="italic">SSH</em> protocol. The combination of an IP address <a id="_idIndexMarker779"/>and a port number is called a <strong class="bold">socket</strong>. We'll see in this <a id="_idIndexMarker780"/>chapter how to work with sockets <a id="_idIndexMarker781"/>using the Rust standard library. UDP, like IP, is connectionless and does not incorporate any reliability mechanisms. But it is fast and has a low overhead compared to TCP. It is used in higher-level services, such as DNS, to get host IP addresses corresponding to a domain name.</p>
			<p>Compared to UDP, TCP provides a connection-oriented, reliable communication channel between two endpoints (application/user space programs) over which byte streams can be exchanged while preserving the sequence of data. It incorporates features such as <strong class="bold">retransmission</strong> in the case of errors, <strong class="bold">acknowledgments</strong> of packets received, and <strong class="bold">timeouts</strong>. We'll discuss TCP-based communication in detail in this chapter and later build a reverse proxy using TCP socket-based communications.</p>
			<p>The uppermost layer in the TCP/IP protocol suite is the <strong class="bold">application layer</strong>. While the TCP layer is connection-oriented and works with byte streams, it has no knowledge of the semantics of a message transmitted. This is provided by the application layer. For example, HTTP, which is the most popular application protocol on the internet, uses HTTP request and response messages to communicate between <strong class="bold">HTTP clients</strong> (for example, internet browsers) and <strong class="bold">HTTP servers</strong> (for example, web servers). The application layer reads the byte streams received from the TCP layer and interprets them into HTTP messages, which are then processed by the application program that we write in Rust or other languages. There are several libraries (or crates) available in the Rust ecosystem that implement the HTTP protocol, so Rust programs can leverage them (or write their own) to send and receive HTTP messages. In the example project for this chapter, we will write some code to interpret an incoming HTTP request message and send back an HTTP response message.</p>
			<p>The primary Rust Standard Library module for <a id="_idIndexMarker782"/>networking communications is <code>std::net</code>. This focuses on writing code for <a id="_idIndexMarker783"/>communicating using TCP and UDP. The Rust <code>std::net</code> module does not deal directly with the data link layer or application layer of the TCP/IP protocol suite. With this background, we are ready to understand the networking primitives provided in the Rust standard library for TCP and UDP communications.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/>Understanding networking primitives in the Rust standard library</h1>
			<p>In this section, we'll <a id="_idIndexMarker784"/>discuss the foundational <a id="_idIndexMarker785"/>data structures in the Rust standard library for networking. <em class="italic">Figure 11.3</em> lists the commonly used data structures:</p>
			<div><div><img src="img/Figure_11.3_B16405.jpg" alt="Figure 11.3 – Networking primitives in the Rust standard library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Networking primitives in the Rust standard library</p>
			<p>Let's look at the <a id="_idIndexMarker786"/>data structures one by <a id="_idIndexMarker787"/>one:</p>
			<ul>
				<li><code>Ipv4Addr</code>: This is a struct that stores a 32-bit integer representing an IPv4 address, and provides associated functions and methods to set and query address values.</li>
				<li><code>Ipv6Add</code>: This is a struct that stores a 128-bit integer representing an IPv6 address, and provides associated functions and methods to query and set address values.</li>
				<li><code>SocketAddrv4</code>: This is a struct representing an internet domain socket. It stores an IPv4 address and a 16-bit port number and provides associated functions and methods to set and query socket values.</li>
				<li><code>SocketAddrv6</code>: This is a struct representing an internet domain socket. It stores an IPv6 address and a 16-bit port number and provides associated functions and methods to set and query socket values.</li>
				<li><code>IpAddr</code>: This is an enum with two variants – <code>V4(Ipv4Addr)</code> and <code>V6(Ipv6Addr)</code>. This means that it can hold either an IPv4 host address or an IPv6 host address. </li>
				<li><code>SocketAddr</code>: This is an enum with two variants – <code>V4(SocketAddrV4)</code> and <code>V6(SocketAddrV6)</code>. This means that it can hold either an IPv4 socket address or an IPv6 socket address. <p class="callout-heading">Note </p><p class="callout">The size of an <em class="italic">Ipv6</em> address might vary, depending on the target operating system architecture.</p></li>
			</ul>
			<p>Let's now see a few examples of how to use them. We'll start by creating IPv4 and IPv6 addresses.</p>
			<p>In the example shown next, we're creating IPv4 and IPv6 addresses using the <code>std::net</code> module and using built-in methods to query on the created addresses. The <code>is_loopback()</code> method <a id="_idIndexMarker788"/>confirms whether the address <a id="_idIndexMarker789"/>corresponds to <code>localhost</code>, and the <code>segments()</code> method returns the various segments of the IP address. Note also that the <code>std::net</code> module provides a special constant, <code>Ipv4Addr::LOCALHOST</code>, which can be used to initialize the IP address with the <code>localhost</code> (loopback) address:</p>
			<pre>use std::net::{Ipv4Addr, Ipv6Addr};
 
fn main() {
    // Create a new IPv4 address with four 8-bit integers
    let ip_v4_addr1 = Ipv4Addr::new(106, 201, 34, 209);
    // Use the built-in constant to create a new loopback 
    // (localhost) address
    let ip_v4_addr2 = Ipv4Addr::LOCALHOST;
    println!(
        "Is ip_v4_addr1 a loopback address? {}",
        ip_v4_addr1.is_loopback()
    );
    println!(
        "Is ip_v4_addr2 a loopback address? {}",
        ip_v4_addr2.is_loopback()
    );
    //Create a new IPv6 address with eight 16-bit  
    // integers, represented in hex
    let ip_v6_addr = Ipv6Addr::new(2001, 0000, 3238, 
        0xDFE1, 0063, 0000, 0000, 0xFEFB);
    println!("IPV6 segments {:?}", ip_v6_addr.segments());
}</pre>
			<p>The following example shows how to use the <code>IpAddr</code> enum. In this example, usage of the <code>IpAddr</code> enum is shown to create IPv4 and IPv6 addresses. The <code>IpAddr</code> enum helps us to define IP <a id="_idIndexMarker790"/>addresses in a more generic way in our <a id="_idIndexMarker791"/>program data structures and gives us the flexibility to work with both IPv4 and IPv6 addresses in our programs:</p>
			<pre>use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
 
fn main() {
    // Create an ipv4 address
    let ip_v4_addr = IpAddr::V4(Ipv4Addr::new(106, 201, 34, 
        209));
    // check if an address is ipv4 or ipv6 address
    println!("Is ip_v4_addr an ipv4 address? {}", 
        ip_v4_addr.is_ipv4());
    println!("Is ip_v4_addr an ipv6 address? {}", 
        ip_v4_addr.is_ipv6());
 
    // Create an ipv6 address
    let ip_v6_addr = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 
        0, 0, 0, 1));
    println!("Is ip_v6_addr an ipv6 address? {}", 
        ip_v6_addr.is_ipv6());
}</pre>
			<p>Let's now turn our attention to sockets. As discussed earlier, sockets comprise an IP address and a port. Rust has separate data structures for both <a id="_idIndexMarker792"/>IPv4 and IPv6 sockets. Let's see an example <a id="_idIndexMarker793"/>next. Here, we're creating a new IPv4 socket, and querying for the IP address and port numbers from the constructed socket, using the <code>ip()</code> and <code>port()</code> methods, respectively:</p>
			<pre>use std::net::{IpAddr, Ipv4Addr, SocketAddr};
fn main() {
    // Create an ipv4 socket 
    let socket = SocketAddr::new(IpAddr::V4(
        Ipv4Addr::new(127,0,0,1)),8000);
    println!("Socket address is {}, port is {}",
        <a href="http://socket.ip">socket.ip</a>(), socket.port());
    println!("Is this IPv6 socket?{}",socket.is_ipv6());
}</pre>
			<p>IP addresses and sockets represent the foundational data structures for network programming using the Rust standard library. In the next section, we'll see how to write programs in Rust that can communicate over TCP and UDP protocols.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Programming with TCP and UDP in Rust</h1>
			<p>As discussed <a id="_idIndexMarker794"/>earlier, TCP and UDP are the fundamental <a id="_idIndexMarker795"/>transport layer network protocols for the <a id="_idIndexMarker796"/>internet. In this section, let's first write a UDP server and client. Then we'll look <a id="_idIndexMarker797"/>at doing the same using TCP. </p>
			<p>Create a new project called <code>tcpudp</code> where we will write the TCP and UDP servers and clients:</p>
			<pre>cargo new tcpudp &amp;&amp; cd tcpudp</pre>
			<p>Let's first look at network communication using UDP.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Writing a UDP server and client</h2>
			<p>In this section, we'll learn how to <a id="_idIndexMarker798"/>configure UDP sockets, and how to send and receive data. We'll write both a UDP server and a UDP client. </p>
			<h3>Starting with the UDP server</h3>
			<p>In the <a id="_idIndexMarker799"/>example shown, we're creating a UDP server by binding to a local socket using <code>UdpSocket::bind</code>. We're then creating a fixed-size buffer, and listening for incoming data streams in a loop. If data is received, we are spawning a new thread to process the data by echoing it back to the sender. As we already covered how to spawn new threads in <a href="B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150"><em class="italic">Chapter 9</em></a>, <em class="italic">Managing Concurrency</em>, it shouldn't need explanation again here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpudp/src/bin/<a href="http://udp-server.rs">udp-server.rs</a></p>
			<pre>use std::str;
use std::thread;
 
fn main() {
    let socket = UdpSocket::bind("127.0.0.1:3000").expect(
        "Unable to bind to port");
    let mut buffer = [0; 1024];
    loop {
        let socket_new = socket.try_clone().expect(
            "Unable to clone socket");
        match socket_new.recv_from(&amp;mut buffer) {
            Ok((num_bytes, src_addr)) =&gt; {
                thread::spawn(move || {
                    let send_buffer = &amp;mut 
                        buffer[..num_bytes];
                    println!(
                        "Received from client:{}",
                        str::from_utf8(
                            send_buffer).unwrap()
                    );
                    let response_string =
                        format!("Received this: {}", 
                            String::from_utf8_lossy(
                            send_buffer));
                    socket_new
                        .send_to(&amp;response_string
                            .as_bytes(), &amp;src_addr)
                        .expect("error in sending datagram 
                            to remote socket");
                });
            }
            Err(err) =&gt; {
                println!("Error in receiving datagrams over 
                    UDP: {}", err);
            }
        }
    }
}</pre>
			<h3>Writing a UDP client to send data packets to the server</h3>
			<p>In the code shown, we're first asking the standard library to bind to a local port (by providing an <a id="_idIndexMarker800"/>address port combination of <code>0.0.0.0:0</code>, which allows the operating system to pick a transient IP address/port to send the datagram from). Then, we are trying to connect to the remote socket where the server is running, and displaying an error in the case of failure to connect. In the case of a successful connection, we are printing out the socket address of the peer using the <code>peer_addr()</code> method. Lastly, we are using the <code>send()</code> method to send a message to the remote socket (server):</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpudp/src/bin/<a href="http://udp-client.rs">udp-client.rs</a></p>
			<pre>use std::net::UdpSocket;
fn main() {
    // Create a local UDP socket
    let socket = UdpSocket::bind("0.0.0.0:0").expect(
        "Unable to bind to socket");
    // Connect the socket to a remote socket
    socket
        .connect("127.0.0.1:3000")
        .expect("Could not connect to UDP server");
    println!("socket peer addr is {:?}", 
        socket.peer_addr());
    // Send a datagram to the remote socket
    socket
        .send("Hello: sent using send() call".as_bytes())
        .expect("Unable to send bytes");
}</pre>
			<p>Run the UDP server with the following:</p>
			<pre>cargo run --bin  udp-server</pre>
			<p>From a separate terminal, run the UDP client with the following:</p>
			<pre>cargo run --bin  udp-client</pre>
			<p>You'll see the message received at the server, which was sent from the client.</p>
			<p>We've seen so far <a id="_idIndexMarker801"/>how to write programs in Rust to do communications over UDP. Let's now look at how TCP communications are done.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/>Writing a TCP server and client</h2>
			<p>In this section, we'll <a id="_idIndexMarker802"/>learn how to configure <a id="_idIndexMarker803"/>TCP listeners, create a TCP socket server, and send and receive data over TCP. We'll write both a TCP server and a TCP client.</p>
			<p>We'll start with the TCP server. In the code shown next, we're using <code>TcpListener::bind</code> to create a TCP server listening on a socket. Then, we use the <code>incoming()</code> method, which returns an iterator of incoming connections. Each connection returns a TCP stream that can be read from using the <code>stream.read()</code> method. We're reading the data and printing out the values. Also, we're echoing back the received data over the connection using the <code>stream.write()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpudp/src/bin/<a href="http://tcp-server.rs">tcp-server.rs</a></p>
			<pre>use std::io::{Read, Write};
use std::net::TcpListener;
fn main() {
    let connection_listener = TcpListener::bind(
        "127.0.0.1:3000").unwrap();
    println!("Running on port 3000");
    for stream in connection_listener.incoming() {
        let mut stream = stream.unwrap();
        println!("Connection established");
        let mut buffer = [0; 100];
        stream.read(&amp;mut buffer).unwrap();
        println!("Received from client: {}", 
            String::from_utf8_lossy(&amp;buffer));
        stream.write(&amp;mut buffer).unwrap();
    }
}</pre>
			<p>This concludes the <a id="_idIndexMarker804"/>code for the TCP server. Let's <a id="_idIndexMarker805"/>now write a TCP client to send some data to the TCP server.</p>
			<p>In the TCP client code shown next, we're using the <code>TcpStream::connect</code> function to connect to a <strong class="bold">remote socket</strong> where the server is listening. This function returns a <strong class="bold">TCP stream</strong>, which can be <em class="italic">read from</em> and <em class="italic">written to</em> (as we saw in the previous example). Here, we're first going to write some data to the TCP stream, and then read back the response received from the server:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpudp/src/bin/<a href="http://tcp-client.rs">tcp-client.rs</a></p>
			<pre>use std::io::{Read, Write};
use std::net::TcpStream;
use std::str;
fn main() {
    let mut stream = TcpStream::connect(
        "localhost:3000").unwrap();
    let msg_to_send = "Hello from TCP client";
    stream.write(msg_to_send.as_bytes()).unwrap();
    let mut buffer = [0; 200];
    stream.read(&amp;mut buffer).unwrap();
    println!(
        "Got echo back from server:{:?}",
        str::from_utf8(&amp;buffer)
            .unwrap()
            .trim_end_matches(char::from(0))
    );
}</pre>
			<p>Run the TCP <a id="_idIndexMarker806"/>server with <a id="_idIndexMarker807"/>the following:</p>
			<pre>cargo run --bin  tcp-server</pre>
			<p>From a separate terminal, run the TCP client with the following:</p>
			<pre>cargo run --bin  tcp-client</pre>
			<p>You'll see the message that was sent from the client being received at the server and echoed back.</p>
			<p>This concludes this <a id="_idIndexMarker808"/>section on performing TCP and UDP communications using the Rust standard library. In the <a id="_idIndexMarker809"/>next section, let's use the concepts learned so far to build a TCP reverse proxy.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Writing a TCP reverse proxy (project)</h1>
			<p>In this section, we will <a id="_idIndexMarker810"/>demonstrate the basic functionality of a <strong class="bold">TCP reverse proxy</strong> using just the Rust standard library, without the use of any external libraries or frameworks.</p>
			<p>A proxy server is an intermediary software service that is used while navigating across multiple networks on the internet. There are two <a id="_idIndexMarker811"/>types of proxy <a id="_idIndexMarker812"/>servers – a <strong class="bold">forward proxy </strong>and a <strong class="bold">reverse proxy</strong>. A <a id="_idIndexMarker813"/>forward proxy acts as <a id="_idIndexMarker814"/>an intermediary for clients making requests out to the internet, and a reverse proxy acts as an intermediary for servers. <em class="italic">Figure 11.4</em> illustrates the usage of forward and reverse proxy servers:</p>
			<div><div><img src="img/Figure_11.4_B16405.jpg" alt="Figure 11.4 – Types of proxy servers"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Types of proxy servers</p>
			<p>Forward proxies act as <a id="_idIndexMarker815"/>gateways to the internet for a group of client machines. They help individual client machines to hide their IP addresses while browsing the internet. They also help to enforce organizational policies for machines within a network to access the internet, such as restricting websites to visit. </p>
			<p>While a forward proxy acts on behalf of clients, a reverse proxy acts on behalf of hosts (for example, web servers). They hide the identity of the backend servers from the clients. The clients only make a request to the reverse proxy server address/domain, and the reverse proxy server, in turn, knows how to route that request to the backend server (also sometimes <a id="_idIndexMarker816"/>called the <strong class="bold">origin server</strong>), and returns the response received from the origin server to the requesting client. A reverse proxy can also be used to perform other functions, such as load balancing, caching, and compression. We will, however, just focus on demonstrating the core concept of a reverse proxy by directing requests received from clients to the backend origin servers and routing responses back to the requesting client.</p>
			<p>To demonstrate a working <em class="italic">reverse proxy</em>, we will build two servers:</p>
			<ul>
				<li><strong class="bold">Origin server</strong>: TCP server (which understands <a id="_idIndexMarker817"/>limited HTTP <a id="_idIndexMarker818"/>semantics).</li>
				<li><strong class="bold">Reverse proxy server</strong>: Client requests <a id="_idIndexMarker819"/>coming to this server will be directed to the <em class="italic">origin server</em>, and responses from the origin <a id="_idIndexMarker820"/>server will be routed back to the client.</li>
			</ul>
			<p>Create a <a id="_idIndexMarker821"/>new project to write the origin and proxy servers:</p>
			<pre>cargo new tcpproxy &amp;&amp; cd tcpproxy</pre>
			<p>Create two files: <code>tcpproxy/src/bin/</code><a href="http://origin.rs">origin.rs</a> and <code>tcpproxy/src/bin/</code><a href="http://proxy.rs">proxy.rs</a>.</p>
			<p>Let's start with the code for the origin server. This server will do the following:</p>
			<ul>
				<li>Receive an incoming HTTP request.</li>
				<li>Extract the first line of the <a id="_idIndexMarker822"/>request (called the <strong class="bold">HTTP request line</strong>).</li>
				<li>Accept a <code>GET HTTP</code> request on a specific route (for example, <code>/order/status/1</code>).</li>
				<li>Return the status of the order. We will demonstrate parsing of the HTTP request line to retrieve the order number and just send back a response stating <strong class="bold">Order status for order number 1 is: Shipped</strong>.</li>
			</ul>
			<p>Let's see the code now for the origin server. </p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor189"/>Writing the origin server – structs and methods</h2>
			<p>We'll first see the code for module imports, struct definitions and methods. Then, <a id="_idIndexMarker823"/>we'll see the code for the <code>main()</code> function. All the code for the origin server can be found in <code>tcpproxy/src/bin/</code><a href="http://origin.rs">origin.rs</a>.</p>
			<p>The module imports are <a id="_idIndexMarker824"/>shown first in the code <a id="_idIndexMarker825"/>snippet. We're importing various modules from the standard library here. The <code>std::io</code> module will be used to read and write to the TCP stream, and the <code>std::net</code> module provides the primitives for the TCP listener, sockets, and addresses. The string modules (<code>std::str</code> and <code>std::String</code>) are used for string manipulations and handling string parsing errors:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>use std::io::{Read, Write};
use std::net::TcpListener;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::str;
use std::str::FromStr;
use std::string::ParseError;</pre>
			<p>Next, let's declare a struct to hold the incoming HTTP request line (the first line of the multi-line HTTP request message). We'll also write some helper methods for this struct.</p>
			<p>In the code shown next, we'll declare a <code>RequestLine</code> struct consisting of three fields – the HTTP method, the path of the resource requested, and the HTTP protocol version supported by the internet browser or another HTTP client sending the request. We'll also write some methods to return the values of the struct members. Custom logic will be implemented for the <code>get_order_number()</code> method. If we get a request for a resource with the <code>/order/status/1</code> path, we will split this string by <code>/</code>, and return the last part of the string, which is order number <code>1</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>#[derive(Debug)]
struct RequestLine {
    method: Option&lt;String&gt;,
    path: Option&lt;String&gt;,
    protocol: Option&lt;String&gt;,
}
 
impl RequestLine {
    fn method(&amp;self) -&gt; String {
        if let Some(method) = &amp;self.method {
            method.to_string()
        } else {
            String::from("")
        }
    }
    fn path(&amp;self) -&gt; String {
        if let Some(path) = &amp;self.path {
            path.to_string()
        } else {
            String::from("")
        }
    }
    fn get_order_number(&amp;self) -&gt; String {
        let path = self.path();
        let path_tokens: Vec&lt;String&gt; = path.split("/").map(
            |s| s.parse().unwrap()).collect();
        path_tokens[path_tokens.len() - 1].clone()
    }
}</pre>
			<p>Let's also implement the <code>FromStr</code> trait for the <code>RequestLine</code> struct so that we can convert the incoming HTTP request line (string) into our internal Rust data structure – <code>RequestLine</code>. The structure of the HTTP request line is shown here:</p>
			<pre>&lt;HTTP-method&gt; &lt;path&gt; &lt;protocol&gt;</pre>
			<p>These <a id="_idIndexMarker826"/>three values are separated by white spaces and are all present in the first line of an HTTP <a id="_idIndexMarker827"/>request message. In the program <a id="_idIndexMarker828"/>shown, we're going to parse these three values and load them into the <code>RequestLine</code> struct. Later, we will further parse the path member and extract the order number from it, for processing:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>impl FromStr for RequestLine {
    type Err = ParseError;
    fn from_str(msg: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let mut msg_tokens = msg.split_ascii_whitespace();
        let method = match msg_tokens.next() {
            Some(token) =&gt; Some(String::from(token)),
            None =&gt; None,
        };
        let path = match msg_tokens.next() {
            Some(token) =&gt; Some(String::from(token)),
            None =&gt; None,
        };
        let protocol = match msg_tokens.next() {
            Some(token) =&gt; Some(String::from(token)),
            None =&gt; None,
        };
 
        Ok(Self {
            method: method,
            path: path,
            protocol: protocol,
        })
    }
}</pre>
			<p>We've <a id="_idIndexMarker829"/>so far seen the module <a id="_idIndexMarker830"/>imports, struct definition, and <a id="_idIndexMarker831"/>methods for the <code>RequestLine</code> struct. Let's now write the <code>main()</code> function.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor190"/>Writing the origin server – the main() function</h2>
			<p>In <a id="_idIndexMarker832"/>the <code>main</code> function of the origin server, we are going to do the following:</p>
			<ol>
				<li>Start the TCP server.</li>
				<li>Listen for incoming connections.</li>
			</ol>
			<p>For each incoming connection, we will then perform the following:</p>
			<ol>
				<li value="1">Read the first line of the incoming HTTP request message and convert it into a <code>RequestLine</code> struct.</li>
				<li>Construct the HTTP response message and write it to the TCP stream.</li>
			</ol>
			<p>Let's now see the code for the main function in two parts – starting the TCP server and listening for connections, and processing incoming HTTP requests.</p>
			<h3>Starting the TCP server and listening for connections</h3>
			<p>To start the <a id="_idIndexMarker833"/>TCP server, we will construct a <a id="_idIndexMarker834"/>socket address, and bind to a socket using <code>TcpStream::bind</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>    // Start the origin server
    let port = 3000;
    let socket_addr = SocketAddr::new(IpAddr::V4(
        Ipv4Addr::new(127, 0, 0, 1)), port);
    let connection_listener = TcpListener::bind(
        socket_addr).unwrap();
 
    println!("Running on port: {}", port);</pre>
			<p>Then, we'll listen for incoming connections, and read from the stream for each connection:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>    for stream in connection_listener.incoming() {
    //processing of incoming HTTP requests
}</pre>
			<p>Let's now see the processing of the incoming request.</p>
			<h3>Processing incoming HTTP requests</h3>
			<p>For processing incoming requests, the <a id="_idIndexMarker835"/>first step is to retrieve the first line of the request message and convert it into a <code>RequestLine</code> struct. In the code shown next, we're using the <code>lines()</code> method to return an iterator of lines. We're then retrieving the first line of the HTTP request using <code>lines().next()</code>. We are converting this into a <code>RequestLine</code> struct using <code>RequestLine::from_str()</code>. This is possible only because we have implemented the <code>FromStr</code> trait for the <code>RequestLine</code> struct:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>        // Read the first line of incoming HTTP request 
        // and convert it into RequestLine struct
        let mut stream = stream.unwrap();
        let mut buffer = [0; 200];
        stream.read(&amp;mut buffer).unwrap();
        let req_line = "";
        let string_request_line =
            if let Some(line) = str::from_utf8(
                &amp;buffer).unwrap().lines().next() {
                line
            } else {
                println!("Invalid request line received");
                req_line
            }; 
        let req_line = RequestLine::from_str(
            string_request_line).unwrap();</pre>
			<p>Now that we have <a id="_idIndexMarker836"/>parsed the required data into the <code>RequestLine</code> struct, we can process it and send the HTTP response back. Let's see the code. If the message received is not a <code>GET</code> request, if the path in the request message does not start with <code>/order/status</code>, or if the order number is not provided, construct an HTTP response message with the <code>404 Not found</code> HTTP status code:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>        // Construct the HTTP response string 
        let html_response_string;
        let order_status;
        println!("len is {}", req_line.get_order_number()
            .len());
 
        if req_line.method() != "GET"
            || !req_line.path().starts_with(
               "/order/status")
            || req_line.get_order_number().len() == 0
        {
            if req_line.get_order_number().len() == 0 {
                order_status = format!("Please provide 
                    valid order number");
            } else {
                order_status = format!("Sorry,this page is 
                    not found");
            }
 
            html_response_string = format!(
                "HTTP/1.1 404 Not Found\nContent-Type: 
                    text/html\nContent-Length:{}\n\n{}",
                order_status.len(),
                order_status
            );
}</pre>
			<p>If the request is correctly formatted to retrieve the order status for an order number, we should construct an HTML response message with the <code>200 OK</code> HTTP status code for sending the response back to the client:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>         else {
            order_status = format!(
                "Order status for order number {} is: 
                    Shipped\n",
                req_line.get_order_number()
            );
            html_response_string = format!(
                "HTTP/1.1 200 OK\nContent-Type: 
                    text/html\nContent-Length:{}\n\n{}",
                order_status.len(),
                order_status
            );
        }</pre>
			<p>Lastly, let's write the <a id="_idIndexMarker837"/>constructed HTTP response message to the TCP stream:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://origin.rs">origin.rs</a></p>
			<pre>stream.write(html_response_string.as_bytes()).unwrap();</pre>
			<p>This concludes the code for the origin server. The complete code can be found in the Packt GitHub repo for <code>Chapter12</code> at <code>tcpproxy/src/bin/</code><a href="http://origin.rs">origin.rs</a>.</p>
			<p>Run the program with the following:</p>
			<pre>cargo run --bin origin</pre>
			<p>You should see the server start with the following message:</p>
			<p><strong class="bold">Running on port: 3000</strong></p>
			<p>In a browser window, enter the following URL:</p>
			<pre>localhost:3000/order/status/2</pre>
			<p>You should see the following response displayed on the browser screen:</p>
			<p><strong class="bold">Order status for order number 2 is: Shipped</strong></p>
			<p>Try entering a URL with an invalid path, such as the following:</p>
			<pre>localhost:3000/invalid/path</pre>
			<p>You should see the following message displayed:</p>
			<p><strong class="bold">Sorry, this page is not found</strong></p>
			<p>Further, you can provide a valid path <a id="_idIndexMarker838"/>but without an order number, such as the following:</p>
			<pre>localhost:3000/order/status/</pre>
			<p>You'll see the following error message displayed:</p>
			<p><strong class="bold">Please provide valid order number</strong></p>
			<p>With this, we conclude the section on the origin server. Let's now write the code for the <em class="italic">reverse proxy</em>.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor191"/>Writing the reverse proxy server</h2>
			<p>Let's dive into the code for <a id="_idIndexMarker839"/>the reverse proxy, starting with the module imports. All of the code for this reverse proxy server can be found in <code>tcpproxy/src/bin/</code><a href="http://proxy.rs">proxy.rs</a>.</p>
			<p>Let's first look at the module imports. </p>
			<p>The <code>std::env</code> module is used to read command-line parameters. <code>std::io</code> is used to read and write to TCP streams. <code>std::net</code> is the main module for communications, as we have seen. <code>std::process</code> is used to exit the program in case of unrecoverable errors. <code>std::thread</code> is used to spawn a new thread for processing incoming requests:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://proxy.rs">proxy.rs</a></p>
			<pre>use std::env;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::process::exit;
use std::thread;</pre>
			<p>Let's write the <code>main()</code> function next. When we start the reverse proxy server, let's accept two command-line parameters, corresponding to socket addresses of the <em class="italic">reverse proxy</em> and <em class="italic">origin server</em>, respectively. If two command-line parameters are not provided by the user, then print out an error message and exit the program. Then, let's parse the <a id="_idIndexMarker840"/>command-line inputs and start the server using <code>TcpListener::bind</code>. After binding to the local port, we connect to the origin server and print out an error message in the case of failure to connect.</p>
			<p>Place the following code within the <code>main()</code> function block:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://proxy.rs">proxy.rs</a></p>
			<pre>    // Accept command-line parameters for proxy_stream and 
    // origin_stream
    let args: Vec&lt;_&gt; = env::args().collect();
    if args.len() &lt; 3 {
        eprintln!("Please provide proxy-from and proxy-to 
            addresses");
        exit(2);
    }
    let proxy_server = &amp;args[1];
    let origin_server = &amp;args[2];
    // Start a socket server on proxy_stream
    let proxy_listener;
    if let Ok(proxy) = TcpListener::bind(proxy_server) {
        proxy_listener = proxy;
        let addr = proxy_listener.local_addr()
            .unwrap().ip();
        let port = proxy_listener.local_addr().unwrap()
            .port();
        if let Err(_err) = TcpStream::connect(
            origin_server) {
            println!("Please re-start the origin server");
            exit(1);
        }
        println!("Running on Addr:{}, Port:{}\n", addr, 
            port);
    } else {
        eprintln!("Unable to bind to specified proxy 
            port");
        exit(1);
    }</pre>
			<p>After <a id="_idIndexMarker841"/>starting the server, we must listen for incoming connections. For every connection, spawn a separate thread to handle the connection. The thread in turn calls the <code>handle_connection()</code> function, which we will describe shortly. Then, join the child thread handles with the main thread to make sure that the <code>main()</code> function does not <em class="italic">exit</em> before <a id="_idIndexMarker842"/>the child threads are completed:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://proxy.rs">proxy.rs</a></p>
			<pre>    // Listen for incoming connections from proxy_server 
    // and read byte stream
    let mut thread_handles = Vec::new();
    for proxy_stream in proxy_listener.incoming() {
        let mut proxy_stream = proxy_stream.expect("Error 
            in incoming TCP connection");
        // Establish a new TCP connection to origin_stream
        let mut origin_stream =
            TcpStream::connect(origin_server).expect(
                "Please re-start the origin server");
        let handle =
            thread::spawn(move || handle_connection(&amp;mut  
                proxy_stream, &amp;mut origin_stream));
        thread_handles.push(handle);
    }
    for handle in thread_handles {
        handle.join().expect("Unable to join child 
            thread");
    }</pre>
			<p>This concludes the <code>main()</code> function. Let's now write the code for <code>handle_function()</code>. This contains the core logic for proxying to the origin server:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">tcpproxy/src/bin/<a href="http://proxy.rs">proxy.rs</a></p>
			<pre>fn <strong class="bold">handle_connection</strong>(proxy_stream: &amp;mut TcpStream, 
    origin_stream: &amp;mut TcpStream) {
    let mut in_buffer: Vec&lt;u8&gt; = vec![0; 200];
    let mut out_buffer: Vec&lt;u8&gt; = vec![0; 200];
    // Read incoming request to proxy_stream
    if let Err(err) = proxy_stream.read(&amp;mut in_buffer) {
        println!("Error in reading from incoming proxy 
            stream: {}", err);
    } else {
        println!(
            "1: Incoming client request: {}",
            String::from_utf8_lossy(&amp;in_buffer)
        );
    }
    // Write the byte stream to origin_stream
    let _ = origin_stream.write(&amp;mut in_buffer).unwrap();
    println!("2: Forwarding request to origin server\n");
    // Read response from the backend server
    let _ = origin_stream.read(&amp;mut out_buffer).unwrap();
    println!(
        "3: Received response from origin server: {}",
        String::from_utf8_lossy(&amp;out_buffer)
    );
    // Write response back to the proxy client
    let _ = proxy_stream.write(&amp;mut out_buffer).unwrap();
    println!("4: Forwarding response back to client");
}</pre>
			<p>For ease of debugging, the four key steps involved in the proxy functionality are marked in the code and also printed out to the console:</p>
			<ol>
				<li value="1">In the first step, we read the incoming data from the incoming <em class="italic">client connection</em>.</li>
				<li>In the second step, we open a new TCP stream with the <em class="italic">origin server</em>, and send the data we received from the <em class="italic">client</em> to the origin server.</li>
				<li>In the third step, we are reading the response we received from the origin server and store the data in a buffer.</li>
				<li>In the final step, we <a id="_idIndexMarker843"/>are using the data received in the previous step to write to the TCP stream corresponding to the client that sent the original request.</li>
			</ol>
			<p>This concludes the code for reverse proxy. We've kept the functionality simple and handled only the base case. As an extra exercise, you can add edge cases to make the server more robust, and also add additional functionality such as load-balancing and caching.</p>
			<p>This concludes the code for the origin server. The complete code can be found in the Packt GitHub repo for <code>Chapter12</code> at <code>tcpproxy/src/bin/</code><a href="http://proxy.rs">proxy.rs</a>.</p>
			<p>First, start the origin server with the following:</p>
			<pre>cargo run --bin origin</pre>
			<p>Then, run the proxy server with the following:</p>
			<pre>cargo run --bin proxy localhost:3001 localhost:3000</pre>
			<p>The first command-line parameter that we pass is used by the <em class="italic">reverse proxy</em> server to bind to the specified socket address. The second command-line parameter corresponds to the socket address at which the <em class="italic">origin server</em> is running. This is the address to which we have to proxy the incoming requests.</p>
			<p>Let's now run the same tests from a browser that we did for the origin server, only this time we'll send the request to port <code>3001</code>, where the reverse proxy server is running. You'll notice that you will get similar response messages. This demonstrates that the requests sent by the internet browser client are being proxied by the reverse proxy server to the backend origin server, and the response received from the origin server is being routed back to the browser client.</p>
			<p>You should see the server start with the following message:</p>
			<p><strong class="bold">Running on Addr:127.0.0.1, Port:3001</strong></p>
			<p>In a browser window, enter the following URL:</p>
			<pre>localhost:3001/order/status/2</pre>
			<p>You <a id="_idIndexMarker844"/>should see the following response displayed on the browser screen:</p>
			<p><strong class="bold">Order status for order number 2 is: Shipped</strong></p>
			<p>Try entering a URL with an invalid path, such as the following:</p>
			<pre>localhost:3001/invalid/path</pre>
			<p>You should see the following message displayed:</p>
			<p><strong class="bold">Sorry, this page is not found</strong></p>
			<p>Further, you can provide a valid path but without an order number, such as the following:</p>
			<pre>localhost:3001/order/status/</pre>
			<p>You'll see the following error message displayed:</p>
			<p><strong class="bold">Please provide valid order number</strong></p>
			<p>This concludes this example project, where we wrote two servers – a TCP origin server and a simple TCP reverse proxy server.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor192"/>Summary</h1>
			<p>In this chapter, we reviewed the basics of networking in Linux/Unix. We learned about the networking primitives in the Rust standard library, including data structures for IPv4 and IPv6 addresses, IPv4 and IPv6 sockets, and associated methods. We learned how to create addresses, as well as create sockets and query them.</p>
			<p>We then learned how to use UDP sockets and wrote a UDP client and server. We also reviewed the TCP communication basics, including how to configure TCP listeners, how to create a TCP socket server, and how to send and receive data. Lastly, we wrote a project consisting of two servers – an <em class="italic">origin server</em> and a <em class="italic">reverse proxy server</em> that routes requests to the origin server.</p>
			<p>In the next and final chapter of the book, we'll cover another <a id="_idTextAnchor193"/>important topic for system programming – <strong class="bold">unsafe Rust and FFI</strong>.</p>
		</div>
	</body></html>