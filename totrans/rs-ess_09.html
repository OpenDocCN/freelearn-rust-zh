<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Programming at the Boundaries" id="aid-21PMQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Programming at the Boundaries</h1></div></div></div><p>In this chapter, we look at how we can start up a Rust program with command-line parameters. Then, we go on to look at situations where we have to leave the safety boundaries, such as when interfacing with C programs, and how Rust minimizes potential dangers when doing so.</p><p>We will discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Program arguments</li><li class="listitem">Unsafe code</li><li class="listitem">Raw pointers</li><li class="listitem">Interfacing with C</li><li class="listitem">Inlining assembly code</li><li class="listitem">Calling Rust from other languages</li></ul></div><div class="section" title="Program arguments"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Program arguments</h1></div></div></div><p>Reading program <a id="id295" class="indexterm"/>parameters from the command line at startup is easy in Rust; just use the <code class="literal">std::env::args()</code> method. We can collect these parameters into a vector of <code class="literal">String</code> like this:</p><div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/arguments.rs:
<span class="strong"><strong>use std::env;</strong></span>

fn main() {
<span class="strong"><strong>   let args: Vec&lt;String&gt; = env::args().collect();</strong></span>
<span class="strong"><strong>   println!("The program's name is: {}", args[0]);</strong></span>
<span class="strong"><strong>   for arg in args.iter() {</strong></span>
<span class="strong"><strong>       println!("Next argument is: {}", arg)</strong></span>
<span class="strong"><strong>   }</strong></span>
<span class="strong"><strong>   println!("I got {:?} arguments: {:?}.", args.len() - 1);</strong></span>
<span class="strong"><strong>  for n in 1..args.len() {</strong></span>
<span class="strong"><strong>      println!("The {}th argument is {}", n, args[n]);</strong></span>
<span class="strong"><strong>   }</strong></span>
}</pre></div><p>Call the <a id="id296" class="indexterm"/>program in the following format:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">arguments arg1 arg2</code> on Windows</li><li class="listitem"><code class="literal">./arguments arg1 arg2</code> on Linux and Mac OS X</li></ul></div><p>The following is the output from a real call:</p><div class="mediaobject"><img src="../Images/image00185.jpeg" alt="Program arguments"/></div><p style="clear:both; height: 1em;"> </p><p>The program's name is <code class="literal">args[0]</code>; the next arguments are the command-line parameters. We can iterate through the arguments or access them by index. The number of parameters is given by <code class="literal">args.len() – 1</code>.</p><p>For more complex parsing with options and flags, use the <code class="literal">getopts</code> or <code class="literal">docopt</code> crate. To get started, there is<a id="id297" class="indexterm"/> an example at <a class="ulink" href="http://rustbyexample.com">http://rustbyexample.com</a>.</p><p>Now, <code class="literal">env::vars()</code> returns the operating system's environment variables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>let osvars = env::vars();</strong></span>
<span class="strong"><strong>for (key, value) in osvars {</strong></span>
       println!("{}: {}", key, value);
}</pre></div><p>This starts with printing out the following on Windows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HOMEDRIVE: C:</strong></span>
<span class="strong"><strong>USERNAME: CVO</strong></span>
<span class="strong"><strong>LOGONSERVER: \\MicrosoftAccount</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div></div></div>
<div class="section" title="Unsafe code" id="aid-22O7C1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Unsafe code</h1></div></div></div><p>There are situations in which even the Rust compiler cannot guarantee us that our code will behave in a safe manner. This can occur in the following scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">When we have to program against the "metal", close to the operating system, processors, and<a id="id298" class="indexterm"/> hardware</li><li class="listitem">When we want to work with the same amount of control that is possible in C</li><li class="listitem">When we delegate a part of program execution to an unsafe language such as C</li><li class="listitem">When we want to inline assembly language</li></ul></div><p>Rust allows us to code for these scenarios, but we have to envelop this possibly dangerous code in an <code class="literal">unsafe</code> block:</p><div class="informalexample"><pre class="programlisting">  unsafe {
    // possibly dangerous code
  }</pre></div><p>Now, the programmer takes full responsibility. The <code class="literal">unsafe</code> block is a promise to the compiler that the unsafety will not leak out of the block. The compiler will check the code areas that are marked as <code class="literal">unsafe</code> more loosely and allow otherwise forbidden manipulations, but a number of rules from the ownership system (refer to <a class="link" title="Chapter 6. Pointers and Memory Safety" href="part0056.xhtml#aid-1LCVG2">Chapter 6</a>, <span class="emphasis"><em>Pointers and Memory Safety</em></span>, for more information) will still remain in place.</p><p>The clear advantage is that problem areas will now appear very well isolated; if a problem occurs, we will know that it can only occur in these marked code areas. Having a code base where 99 percent of the code is safe and 1 percent is unsafe is much easier to maintain than a code base with 100 percent unsafe code, as in C!</p><p>Here is what we can do in an <code class="literal">unsafe</code> block:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Work with raw pointers, especially by dereferencing them. For more information, refer to the <span class="emphasis"><em>Raw pointers</em></span> section of this chapter.</li><li class="listitem">Call a function in another<a id="id299" class="indexterm"/> language through a <span class="strong"><strong>Foreign Function Interface</strong></span> (<span class="strong"><strong>FFI</strong></span>). For more information, see the <span class="emphasis"><em>Interfacing with C</em></span> section of this chapter.</li><li class="listitem">Inline assembly code</li><li class="listitem">Use <code class="literal">std::mem::transmute</code> to convert simple types bitwise; here is an example of its use in which a string is transformed into a slice of bytes:<div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/unsafe.rs:
use std::mem;

fn main() {
  let v: &amp;[u8] = unsafe { 
    mem::transmute("Gandalf") 
  };
  println!("{:?}", v);
}</pre></div></li></ul></div><p>This prints the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[71, 97, 110, 100, 97, 108, 102]</strong></span>
</pre></div><p>An <code class="literal">unsafe</code> block can also call the <code class="literal">unsafe</code> functions that perform these dangerous operations and are marked as <code class="literal">unsafe fn dangerous() { }</code>.</p><p>In <code class="literal">unsafe</code> code, the use of the <code class="literal">std::mem</code> module (which contains functions to work with memory at a low level) and the <code class="literal">std::ptr</code> module (which contains functions to work with raw<a id="id300" class="indexterm"/> pointers) is common.</p><div class="note" title="Note"><h3 class="title"><a id="tip06"/>Tip</h3><p>We recommend that you use <code class="literal">assert!</code> statements abundantly inside unsafe code to check at runtime whether it is doing what you expect it to. For instance, before dereferencing a raw <code class="literal">ptr</code> pointer of unknown origin, always call <code class="literal">assert!(!ptr.is_null());</code> to ensure that the pointer points to a valid memory location.</p></div></div>
<div class="section" title="Raw pointers" id="aid-23MNU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Raw pointers</h1></div></div></div><p>In unsafe code blocks, Rust allows the use of a new kind of pointers called <span class="emphasis"><em>raw pointers</em></span>. For these pointers, there is<a id="id301" class="indexterm"/> no built-in security, and you can work with them with the same freedom as C pointers. They are written as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">*const T</code>: This is used for a pointer of an immutable value or the <code class="literal">T</code> type</li><li class="listitem"><code class="literal">*mut T</code>: This is used as a mutable pointer</li></ul></div><p>They can point to invalid memory, and the memory resource needs to be manually freed. This means that a raw pointer could inadvertently be used after freeing the memory that it points to. In addition, multiple concurrent threads have nonexclusive access to mutable raw pointers. Since we're not sure of the contents (at least we have no compiler guarantee of valid content), dereferencing a raw pointer can also lead to program failure.</p><p>That's why dereferencing a raw pointer can only be done inside an <code class="literal">unsafe</code> block, as illustrated in the following code fragment:</p><div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/raw_pointers.rs:
<span class="strong"><strong>let p_raw: *const u32 = &amp;10;</strong></span>
// let n = *p_raw; // compiler error!
unsafe {
<span class="strong"><strong>     let n = *p_raw;</strong></span>
     println!("{}", n); // prints 10
}</pre></div><p>If you try to do this in normal code, you will get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>error: dereference of unsafe pointer requires unsafe function or block [E0133]</strong></span>
</pre></div><p>We can make raw pointers safely out of references, implicitly or explicitly, with <code class="literal">&amp;</code> as <code class="literal">*const</code>, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">  let gr: f32 = 1.618;
<span class="strong"><strong>  let p_imm: *const f32 = &amp;gr as *const f32; // explicit cast</strong></span>
  let mut m: f32 = 3.14;
  let p_mut: *mut f32 = &amp;mut m; // implicit cast</pre></div><p>However, converting <a id="id302" class="indexterm"/>a raw pointer into a reference, which should be done through a <code class="literal">&amp;*</code> (address of a dereference) operation, must be done within an <code class="literal">unsafe</code> block:</p><div class="informalexample"><pre class="programlisting">unsafe {
<span class="strong"><strong>    let ref_imm: &amp;f32 = &amp;*p_imm;</strong></span>
<span class="strong"><strong>    let ref_mut: &amp;mut f32 = &amp;mut *p_mut;</strong></span>
}</pre></div><p>Raw pointers could also be useful when defining other more intelligent pointers; for example, they are used to implement the <code class="literal">Rc</code> and <code class="literal">Arc</code> pointer types.</p></div>
<div class="section" title="Interfacing with C"><div class="titlepage" id="aid-24L8G2"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Interfacing with C</h1></div></div></div><p>Due to the vast functionality that exists in C's code, it can sometimes be useful to delegate processing to a C routine, instead of writing everything in Rust.</p><p>You can call all functions from the C standard library by using the <code class="literal">libc</code> crate, which must be obtained through Cargo. To do this, simply add the following to your Rust code:</p><div class="informalexample"><pre class="programlisting">#![feature(libc)]
extern crate libc;</pre></div><p>To import C<a id="id303" class="indexterm"/> functions and types, you can sum them up like this:</p><div class="informalexample"><pre class="programlisting">use libc::{c_void, size_t, malloc, free};</pre></div><p>Alternatively, you can use a <code class="literal">*</code> wildcard, such as <code class="literal">use libc::*;</code>, to make them all available.</p><p>To work with C (or another language) from Rust, you will have to use the FFI, which has its utilities in the <code class="literal">std::ffi</code> module.</p><p>Here is a simple example to call C for printing out a Rust string with the <code class="literal">puts</code> function in C:</p><div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/calling_libc.rs:
#![feature(libc)]
<span class="strong"><strong>extern crate libc;</strong></span>
<span class="strong"><strong>use libc::puts;</strong></span>
<span class="strong"><strong>use std::ffi::CString;</strong></span>

fn main() {
  let sentence = "Merlin is the greatest magician!";
<span class="strong"><strong>  let to_print = CString::new(sentence).unwrap();</strong></span>
<span class="strong"><strong>  unsafe {</strong></span>
<span class="strong"><strong>        puts(to_print.as_ptr());</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>This prints out the following sentence:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Merlin is the greatest magician!</strong></span>
</pre></div><p>The <code class="literal">new()</code> method of <code class="literal">CString</code> will produce a string (ending with a 0 byte) that is compatible<a id="id304" class="indexterm"/> with C from the Rust string. The <code class="literal">as_ptr()</code> method returns a pointer to this C string.</p><p>The <code class="literal">#![feature(libc)]</code> attribute (a so called feature gate) is (temporarily) necessary to enable the use of <code class="literal">libc</code>. It does not work with Rust from the beta channel, you need to take the Rust compiler from the nightly channel.</p><div class="note" title="Note"><h3 class="title"><a id="note10"/>Note</h3><p>Feature gates are common in Rust to enable the use of a certain functionality, but they are not available in stable Rust; they are only available in the current development branch (the nightly release).</p></div><div class="section" title="Using a C library"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec43"/>Using a C library</h2></div></div></div><p>Suppose we <a id="id305" class="indexterm"/>want to calculate the tangents of a complex number. The <code class="literal">num</code> crate offers basic operations on complex numbers, but at this time, the <code class="literal">tangents</code> function is not yet included, so we will call the <code class="literal">ctanf</code> function from the C library <code class="literal">libm</code>, which is a collection of mathematical functions that<a id="id306" class="indexterm"/> are implemented in C. </p><p>The following code does just that and defines a complex number as a simple <code class="literal">struct</code>:</p><div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/calling_clibrary.rs:
<span class="strong"><strong>#[repr(C)]</strong></span>
#[derive(Copy, Clone)]
#[derive(Debug)]
struct Complex {
    re: f32,
    im: f32,
}

<span class="strong"><strong>#[link(name = "m")]</strong></span>
<span class="strong"><strong>extern {</strong></span>
<span class="strong"><strong>   fn ctanf(z: Complex) -&gt; Complex;</strong></span>
<span class="strong"><strong>}</strong></span>

fn tan(z: Complex) -&gt; Complex {
<span class="strong"><strong>    unsafe { ctanf(z) }</strong></span>
}

fn main() {
    let z = Complex { re: -1., im: 1. }; // z is -1 + i
    let z_tan = tan(z);
    println!("the tangens of {:?} is {:?}", z, z_tan);
}</pre></div><p>This program prints the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>the tangens of Complex { re: -1, im: 1 } is Complex { re: -0.271753, im: 1.083923 }</strong></span>
</pre></div><p>The <code class="literal">#[derive(Debug)]</code> attribute is necessary because we want to show the number in a <code class="literal">{:?}</code> format string. The <code class="literal">#[derive(Copy, Clone)]</code> attribute is needed because we want to use <code class="literal">z</code> in the <code class="literal">println!</code> statement, after we have moved it by calling <code class="literal">ctanf(z)</code>. The function of <code class="literal">#[repr(C)]</code> is to reassure the compiler that the type we are passing to C is foreign function-safe, and it tells <code class="literal">rustc</code> to create <code class="literal">struct</code> with the same layout as C.</p><p>The signatures of the C functions that we want to use must be listed in an <code class="literal">extern {}</code> block. The <a id="id307" class="indexterm"/>compiler cannot check these signatures, so it is important to specify them accurately to make the correct bindings at runtime. This block can also declare global variables that are exported by C to use in Rust. They must be marked as <code class="literal">static</code> or <code class="literal">static mut</code>, for example, <code class="literal">static mut version: libc::c_int</code>.</p><p>The <code class="literal">extern</code> block must be preceded by a <code class="literal">#[link(name = "m")]</code> attribute to link the <code class="literal">libm</code> library. This instructs <code class="literal">rustc</code> to link to that native library so that symbols from that library are resolved.</p><p>The C call itself must evidently be done inside an <code class="literal">unsafe {}</code> block. This block is enveloped inside a <code class="literal">tan(z)</code> wrapper function, which only uses Rust types. This way this wrapper can be exposed as a safe interface, by hiding the unsafe calls and type conversions between Rust and C types, especially C pointers. When the C code returns a resource, the Rust code must contain destructors for these values to assure their memory release.</p></div><div class="section" title="Inlining assembly code"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec44"/>Inlining assembly code</h2></div></div></div><p>In Rust, we can embed assembly code. This should be extremely rare, but we can think of situations where this<a id="id308" class="indexterm"/> might be useful, for example, when you have to get the utmost performance or very low-level control. However, the portability of your code and perhaps its stability are decreased when you do this. The Rust compiler will probably generate better assembly code than you could write, so it isn't worth the effort most of the time.</p><div class="note" title="Note"><h3 class="title"><a id="tip07"/>Tip</h3><p>This feature is not yet enabled in Rust 1.0 on the stable release channel. To use this mechanism (or other unstable features) in the meantime, you have to use Rust from the master branch (which is the nightly release).</p></div><p>The mechanism works by using the <code class="literal">asm!</code> macro, like this example where we calculate <code class="literal">b</code> in the subtract function by calling assembly code:</p><div class="informalexample"><pre class="programlisting">// code from Chapter 9/code/asm.rs:
<span class="strong"><strong>#![feature(asm)]</strong></span>

fn subtract(a: i32, b: i32) -&gt; i32 {
    let sub: i32;
    unsafe {
<span class="strong"><strong>        asm!("sub $2, $1; mov $1, $0" </strong></span>
<span class="strong"><strong>        : "=r"(sub) </strong></span>
<span class="strong"><strong>        : "r"(a), "r"(b)</strong></span>
<span class="strong"><strong>            );</strong></span>
    }
    sub
}

fn main() {
    println!("{}", subtract(42, 7)) }
}</pre></div><p>This prints<a id="id309" class="indexterm"/> out the result as <code class="literal">35</code>.</p><p>We can only use <code class="literal">asm!</code> with a so-called feature gate, which is <code class="literal">#![feature(asm)]</code> here.</p><p>The <code class="literal">asm!</code> macro has a number of parameters separated by <code class="literal">:</code>. The first is the assembly template, containing the assembly code as a string, then the output and input operands follow.</p><p>You can indicate the kind of processor your assembly code is meant to execute on with the <code class="literal">cfg</code> attribute and its <code class="literal">target_arch</code> value, for example:</p><div class="informalexample"><pre class="programlisting">  #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]</pre></div><p>The compiler will then check whether you have specified valid assembly code for that processor.</p><p>For more <a id="id310" class="indexterm"/>detailed information about the use of <code class="literal">asm!</code>, refer to the <span class="emphasis"><em>Inline Assembly</em></span> section of this chapter at <a class="ulink" href="http://doc.rust-lang.org/book/unsafe.html">http://doc.rust-lang.org/book/unsafe.html</a>.</p></div></div>
<div class="section" title="Calling Rust from other languages" id="aid-25JP21"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Calling Rust from other languages</h1></div></div></div><p>A Rust code can be called from any language that can call C. However, the Rust library should have the <code class="literal">dylib</code> crate type value. When <code class="literal">rustfn1</code> is the Rust function to be called, this must be<a id="id311" class="indexterm"/> declared as follows:</p><div class="informalexample"><pre class="programlisting">#[no_mangle]
pub extern "C" fn rustfn1() { }</pre></div><p>Here, <code class="literal">#[no_mangle]</code> serves to keep the function names plain and simple so that they are easier to link to. C exports the function to the outside world with the C calling convention.</p><p>Examples of calling Rust from <a id="id312" class="indexterm"/>C, Python, Haskell, and Node.js can be found in the article at <a class="ulink" href="https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/">https://siciarz.net/24-days-of-rust-calling-rust-from-other-languages/</a>. Calling Rust from Perl and Julia is shown at <a class="ulink" href="http://paul.woolcock.us/posts/rust-perl-julia-ffi.html">http://paul.woolcock.us/posts/rust-perl-julia-ffi.html</a>.</p></div>
<div class="section" title="Summary" id="aid-26I9K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Summary</h1></div></div></div><p>In this chapter, we showed you how to process parameters for your program that are read from the command line at startup. Then, we proceeded to unsafe territory where raw pointers point the way. We covered how to use assembly code, how to call C functions from Rust, and how to call Rust functions from other languages.</p><p>This chapter concludes our essential tour of Rust. In the <a class="link" title="Appendix A. Exploring Further" href="part0075.xhtml#aid-27GQ61">Appendix</a>, <span class="emphasis"><em>Exploring Further</em></span>, that follows this chapter, we provide you with pointers (no pun intended!) to pursue your Rust journey.</p></div></body></html>