- en: Data Serialization and Deserialization with the Serde Crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can either interact with clients or each other. To implement interaction,
    you have to choose a protocol and a format to send messages from one communication
    participant to another. There are many formats and RPC frameworks that simplify
    the interaction process. In this chapter, we'll discover features of the `serde`
    crate, which helps you to make structs serializable and deserializable and compatible
    with different formats, such as JSON, CBOR, MessagePack, and BSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to serialize and deserialize data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make custom types types serializable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which serialization formats to choose and which to avoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore some of the features that are available in the `serde`
    crates family. This family includes the inseparable pair – the `serde` and `serde_derive`
    crates. It also includes crates such as `serde_json`, `serde_yaml`, and `toml`
    that provide you support for special formats, such as JSON, YAML, and **`TOML`**.
    All of these crates are pure Rust and don't require any external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the source code of the examples in this chapter from GitHub at:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04)[.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter4)'
  prefs: []
  type: TYPE_NORMAL
- en: Data formats for interaction with microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can interact with different participants, such as clients, other
    microservices, and third-party APIs. Typically, interactions are performed by
    the network using serialized data messages in a certain format. In this section,
    we'll learn how to choose a format for these interactions. We'll also explore
    the basic features of a `serde` crate – how to make our structs serializable and
    use a specific format.
  prefs: []
  type: TYPE_NORMAL
- en: The serde crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I started to use Rust in my projects, I used to use the popular `rustc_serialize`
    crate. This wasn't bad, but I found that it wasn't flexible enough. For example,
    I couldn't use generic data types in my own structs. The `serde` crate was created
    to eliminate the shortcomings of the `rustc_serialize`crate. `serde` has been
    the main crate for serialization and deserialization in Rust since the `serde`
    crate reached the 1.0 release branch.
  prefs: []
  type: TYPE_NORMAL
- en: We used this crate in the previous chapter to deserialize a configuration file.
    We're now going to use it to transform request and response data to text or binary
    data.
  prefs: []
  type: TYPE_NORMAL
- en: To explore serialization, we'll use a microservice that generates random numbers.
    We'll rewrite a very simple version without logging, reading arguments, environment
    variables, or configuration files. It will use the HTTP body to specify a range
    of random values and a random distribution to generate a number from.
  prefs: []
  type: TYPE_NORMAL
- en: Our service will handle requests for the `/random` path only. It will expect
    both a request and a response in JSON format. As mentioned, the `serde` crate
    provides serialization capabilities to the code. We also need the `serde_derive`
    crate to derive the serialization method automatically. The `serde` crate contains
    only core types and traits to make the serialization process universal and reusable,
    but specific formats are implemented in other crates. We'll use `serde_json`,
    which provides a `serializer` in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the code of the minimal random-number-generating service and add these
    dependencies to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Import these crates into the `main.rs` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we imported a macro from the `serde_derive` and `serde_json`
    crates to use a JSON `serializer`. We don't import the `serde` crate, because
    we won't use it directly, but it's necessary to use the macro. We can now look
    at the different parts of the code. At first, we'll examine the request and response
    types. After that, we'll implement a handler to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The service returns random numbers represented as the `f64` type. We want to
    return it packed to a JSON object, because we may need to add more fields to the
    object. It''s simple to use objects in JavaScript. Declare the `RngResponse` struct
    and add the `#[derive(Serailize)]` attribute. This makes this struct serializable,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To make this struct deserializable, we should derive the `Deserialize` trait.
    Deserialization may be useful it you want to use the same type for requests and
    responses. It's also important to derive both `Serialize` and `Deserialize` if
    you want to use the same type in a server and a client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The serialized object will be represented as a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Deserializing requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The service will support complex requests in which you can specify a distribution
    and parameters. Let''s add this enumeration to the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may want to know what the serialized value looks like. `serde_derive` provides
    extra attributes, which you can use to tweak the serialization format. The current
    `deserializer` expects a `RngRequest` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be represented as the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create your own protocol from scratch, there won''t be any problems
    with the layout, because you can easily make it conform to any restrictions specified
    by serializers that are automatically generated by the `serde` crate. If you have
    to use an existing protocol, however, you can try to add extra attributes to a
    declaration. If this doesn''t help, you can implement the `Serialize` or `Deserialize`
    traits manually. For example, let''s say we want to use the following request
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `serde` attributes to the `RngRequest` declaration, which transform
    the `deserializer` to support the preceding format. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the enumeration uses the aforementioned request format. There are a lot
    of attributes in the `serde_derive` crate and it's important to explore them in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`serde_derive` supports a lot of attributes that help you to avoid manual implementations
    of the `serializer` or `deserializer` for the struct. In this section, we take
    a look at useful attributes in detail. We''ll learn how to change the letter case
    of variants, how to remove a level of nesting, and how to use specific names for
    a tag and for a content of an enumeration.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the case of names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`serde_derive` maps names of fields in the code to fields of data. For example,
    the `title` field of a struct will expect the `title` field of a data object.
    If the protocol uses other names for fields, you have to take this into account
    to avoid warnings. For example, a struct in a protocol might contain the `stdDev` field,
    but if you use the name of this field in Rust, you get the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can fix this adding the `#![allow(non_snake_case)]` attribute, but this
    makes the code unsightly. A better solution is to use the `#[serde(rename="stdDev")]`
    attribute and use the other naming convention for serialization and deserialization
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two variants of renaming attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the naming convention for all variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the name of a field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change all variants of an enumeration, add the `#[serde(rename_all="...")]`
    attribute with one of the following values: `"lowercase"`, `"PascalCase"`, `"camelCase"`,
    `"snake_case"`, `"SCREAMING_SNAKE_CASE"`, or `"kebab-case"`. To be more representative,
    naming values are written according to the rules of their own convention.'
  prefs: []
  type: TYPE_NORMAL
- en: To change the name of a field, use the `#[serde(rename="...")]` attribute with
    the name of the field used in the serialization process. You can see an example
    of the usage of this attribute in [Chapter 17](2dceb3bc-2f03-47d9-88cd-561b4f0b50d7.xhtml),
    *Bounded Microservices with AWS Lambda*.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use renaming is when the names of fields are keywords in Rust.
    For example, a struct can't contain a field with the popular name `type`, because
    it's a keyword. You can rename it to `typ` in the struct and add `#[serde(rename="type")]`
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `serializer` derived automatically uses the same nesting structure as your
    type. If you need to reduce the levels of nesting, you can set the `#[serde(flatten)]`
    attribute to use fields without enclosing objects. In the previous example, we
    used the `Range` type from the standard library to set a range in which to generate
    a random value, but we also want to see the implementation details in the serialized
    data. To do this, we need the `start` and `end` fields of the `Range`. We added
    this attribute to the field to cut out the `{ "range": ... }` level of the structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For enumeration, `serde_derive` uses a tag as the name of the object. For example,
    the following JSON-RPC contains two variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `params` field contains an array of any JSON values represented by the `serde_json::Value`
    type, we''ll explore this type later in this chapter. If you serialize an instance
    of this struct, it will include the name of a variant. Consider the following,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This request isn''t compatible with the JSON-RPC specification ([https://www.jsonrpc.org/specification#request_object](https://www.jsonrpc.org/specification#request_object)).
    We can drop the enclosing object with the `#[serde(untagged)]` attribute and the
    struct becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After this change, this serialized data can be sent as JSON-RPC. However, if
    you still want to keep the variant value in a serialized data form, you have to
    use another approach, which is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using specific names for a tag and content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example, we want to have two fields in a serialized data form: `distribution`
    and `parameters`. In the first field, we want to hold a variant of enumeration,
    but renamed so that it''s in lowercase. In the second field, we''ll keep the parameters
    of the specific variant.'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, you can write your own `Serializer` and `Deserializer`, an
    approach that we'll explore later in this chapter. For this case, however, we
    can use the `#[serde(tag = "...")]` and `#[serde(context = "...")]` attributes.
    `context` can only be used in a pair with `tag`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added this to our `RngRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This attribute specifies the `distribution` key of the serialized object to
    hold a variant of the enumeration. The variants of the enumeration move to the `parameters`
    field of the serialized object. The last attribute, `rename_all`, changes the
    case of the name of a variant. Without renaming, we would be forced to use title
    case for distributions, such as `"Uniform"` instead of the tidier `"uniform"`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a serialized value has to include an object with a dynamic structure.
    Formats such as JSON support free data structures. I don't like unspecified structures,
    but we may need them to create services that are compatible with existent services.
  prefs: []
  type: TYPE_NORMAL
- en: Any Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to keep a certain part of your data deserialized but you don't know
    the structure of the data and you want to explore it later in runtime, you can
    use the generic `serde_json::Value`, which represents a value of any type. For
    example, the `serde_json` crate includes a `Value` object and a method to deserialize
    types from an instance of `Value`. This may be useful in difficult deserialization
    cases in which you need to reorder the representation before it's completely deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a generic `Value`, add it to your struct. Consider the following, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used a generic value of the `serde_json` crate. When you need to deserialize
    it to a `User` struct, for example, you can use the `serde_json::from_value` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned about deserialization processes. It's now time to
    add a handler to our server to process requests. This handler will deserialize
    the data, generate a random value, and return the data back in its serialized
    form to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If I write a proxy service, should I deserialize and serialize requests to send
    them unchanged to another service? This depends on the purpose of the service. Serialization
    and deserialization take up a substantial amount of CPU resources. If the service
    is used to balance requests, you don't need the inner data of the request. This
    is especially the case if you only use HTTP headers to choose the destination
    of the request. However, you might want to use the processing benefits of deserialized
    data – for example, you can patch some values of the data before sending it to
    other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Using hyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added the `RngRequest` and `Response` types and implemented the `Serialize`
    and `Deserialize` traits. Now we can use them with `serde_json` in a handler.
    In this section, we'll explore how get the full body of a request, deserialize
    it into an instance of a specific type, and serialize a response.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a body from a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In fact, the body of a request in a `hyper` crate is a stream. You can't get
    access to the full body immediately, but you can read incoming chunks, write them
    to a vector, and use the resulting data set as a single object.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have access to the whole body because it may be a huge block of data
    that we can't keep in the memory. Our service could be used, for example, to upload
    multiple terabytes of data files or for video streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're using an asynchronous approach, we can't block the current thread
    while we read the stream to the end. This is because it would block the thread
    and cause the program to stop working, because the same thread is used for polling
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: The `serde` crate doesn't support the deserialization of a continuous flow of
    data, but you can create and use a `Deserializer` instance directly to handle
    infinite streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read data from a stream, you have to take a `Stream` instance and put it
    into a `Future` object, which will collect the data from that stream. We''ll explore
    this topic in the next chapter in more detail. Let''s implement a `Future` that
    collects data from a `Stream` instance. Add the following code to a branch of
    the `/random` path in the `match` expression of the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Request` instance has the `into_body` method, which returns the body of
    the request. We used the `Body` type to represent a body for our handler. The `Body`
    type is a stream of chunks that implement the `Stream` trait. It has the `concat2`
    method, which concatenates all chunks to a single object. This is possible because
    the `Chunk` type implements the `Extend` trait and can be extended with the other
    `Chunk`. The `concat2` method transforms the `Stream` to `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with the `futures` crate, you can learn more about it
    in the next chapter. For now, you can think of a `Future` object as a `Result`
    that will be completed later. You can think of a `Stream` as an `Iterator` that
    doesn't have a reference to any item and has to poll for the next item from a
    data stream.
  prefs: []
  type: TYPE_NORMAL
- en: After we take the whole body of a request, we can use deserialize. `serde_derive`
    derives a generic `deserializer`, so we have to use a crate to get a specific
    serialization format. In this case, we'll use the JSON format, so we'll use the `serde_json`
    crate. This includes a `from_slice` function, which creates a `Deserializer` for
    our type and uses it to read an instance from a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The `from_slice` method returns a `Result<T, serde_json::Error>` and we'll `map`
    this result to our own `handle_request` function, which reads the request and
    generates a response. We'll discuss this function later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: When the result is ready, we use the `serde_json::to_string` function to convert
    the response to a JSON string. We use `and_then`, because `to_string` returns
    a Result and we have to handle errors if there are any.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `Result`, which contains a serialized response or `serde_json::Error`
    if anything goes wrong. We'll use the `match` expression to return a successful
    `Response` if the response is created and serialized to a `String` successfully
    or a response with the `UNPROCESSABLE_ENTITY` status and a body with an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we created a `Future` object, which doesn't have any results. We
    have to add that future to a reactor to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When discussing the preceding code, we mentioned the `handle_request` function.
    Let''s take a closer look at the implementation of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function takes a `RngRequest` value. The first line of the implementation
    uses a `rand::thread_rng` function to create a random-number-generator instance.
    We'll use the `sample` method to generate a random value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our request supports three kinds of distributions: `Uniform`, `Normal`, and
    `Bernoulli`. We used destructuring patterns to get the parameters of a request
    to create a distribution instance. After this, we used a deserialized request
    for sampling and converted the result into the `f64` type to pack it into the `RngResponse`
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your microservice uses custom data structures, it needs a custom serialization
    format. You can add your own serialization by implementing the `Serialize` and
    `Deserialize` traits, or by adding special attributes to your struct or field
    of struct. We'll explore both approaches here.
  prefs: []
  type: TYPE_NORMAL
- en: Custom serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll extend our random-number-generating service with two features – generating
    random colors and shuffling an array of bytes. For the first feature, we need
    to add the `Color` struct to hold the color components. Create a new file, `color.rs`,
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two constant colors that we''ll use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The struct also implements `PartialEq` and `Eq` to compare a value with these
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a textual representation of color that''s compatible with CSS. We''ll
    support RGB colors in hex format and two textual colors: `black` and `white`.
    To convert a color to a string, implement the `Display` trait for `Color`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This implementation writes three color components to a string with the `'#'`
    prefix. Every color component byte is written in hex format with the `'0'` prefix
    for nonsignificant digits and with a width of two characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this formatter to implement the `Serialize` trait for the `Color`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Serialize` implementation calls the `serialize_str` method of the `Serializer`
    to store a hex representation of a color to a string. Before implementing a custom
    deserialization, add all necessary imports to the `color.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Color` type has to be convertible from a string. We can do this by implementing
    the `FromStr` trait, which makes it possible to call the `parse` method of `str`
    to parse the struct from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we use a match expression with four branches to check
    the cases. We indicate that the expression should have a textual value of either
    `"white"` or `"black"`, or that it can start with a `#`, and that it should contain
    exactly seven characters. Otherwise, an error should be returned to indicate that
    an unsupported format has been provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Deserialization` trait, we need to add the `ColorVisitor`
    struct, which implements the `Visitor` trait of the `serde` crate. The `Visitor`
    trait is used to extract a value of a specific type from different input values.
    For example, we can use the `u32` and `str` input types to deserialize decimal
    values. The `ColorVisitor` in the following example tries to parse the incoming
    strings to a color. It has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `parse` method of `str`, which works with types that
    implement the `FromStr` trait to convert a string to a `Color` instance. We implemented
    two methods to extract values from different types of strings – the first for
    `String` instances and the second for `str` references. We can now add the `Color`
    type as a field in the other deserializable struct. Let's take a closer look at
    the `ColorError` type before we look closer at working with binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error types with the failure crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding parsing needs its own error type to cover both errors—incorrect
    parsing of numbers, and invalid variants. Let's declare the `ColorError` type
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in Rust is particularly easy. There's a `Result` type that wraps
    successful and unsuccessful outcomes in a single entity. `Result` interprets any
    type as an error type and you can transform one result to another using the `try!`
    macro or the `?` operator. Joining different error types, however, is much more
    complicated. There's the `std::error::Error` trait, which provides a generic interface
    for all errors, but it's a little clumsy. To create errors in a more user-friendly
    way, you can use the `failure` crate.
  prefs: []
  type: TYPE_NORMAL
- en: This crate helps with error handling and contains extensive `failure::Error`
    types, which are compatible with other errors that implement the `std::Error::Error`
    trait. You can convert any error type that implements this trait to a generic
    `failure::Error`. This crate also includes macros that can be used to derive your
    own error type and the `failure::Fail` trait to implement extra features, such
    as `Backtrace`, which provides extra information about the primary cause of an
    error at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare this type in the `color.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ColorError` enumeration has two variants: `InvalidComponent` for parsing
    issues and `InvalidValue` if the wrong value is provided. To implement the necessary
    error traits for this type, we derive the `Fail` trait with the `#[derive(Debug,
    Fail)]` attribute. The `Debug` trait implementation is also necessary for `Fail`
    deriving.'
  prefs: []
  type: TYPE_NORMAL
- en: To create error messages, we added the `fail` attribute with a `display` parameter
    that expects a message with parameters to interpolate into a format string. For
    fields, you can use names, such as `value`, and numbers with the underscore prefix
    to indicate their field position. To insert the first field, for example, use
    the name `_0`. To mark a field as a nested error, use the `#[cause]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deriving the `Fail` trait won''t implement `From` for types that we used as
    variants of the `ColorError` enum. You should do this yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `ColorError` type is now ready to use with the `?` operator, and we can
    add random color generation to our microservice, together with the shuffling of
    a binary array.
  prefs: []
  type: TYPE_NORMAL
- en: Binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before improving the microservice, add all the necessary dependencies to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using a lot of dependencies that work well with each other, thanks to
    Rust and crates. As you might have noticed, we have added the `base64` crate and
    the `base64-serde` crate. The first is a binary-to-text converter and the second
    is necessary to work with a converter in the serialization processes of `serde`.
    Import all of these to `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We also added the `color` module and used `color:Color` from that module. We
    also imported macros from the `failure` and `base64_serde` crates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two extra variants to the `RngRequest` enumeration for color generation
    and array shuffling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shuffle` variant has field data of the  `Vec<u8>` type. Since JSON doesn''t
    support binary data, we have to convert it to text. We added the `#[serde(with
    = "Base64Standard")]` attribute, which requires us to use the `Base64Standard`
    type for deserialization. You can customize fields with your own serialization
    and deserialization functions; now, we have to declare `Base64Standard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have to declare this since `base64_serde` doesn't contain predefined deserializers.
    This is because Base64 needs extra parameters that can't have universal values.
  prefs: []
  type: TYPE_NORMAL
- en: The `Color` variant contains two fields, which can be used to specify a range
    in which the color will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some new variants of a response to the `RngResponse` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have to improve the `handle_request` function with additional variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We refactored the code a bit here and there are two extra branches. The first
    branch, for the `RngRequest::Shuffle` variant, uses the `shuffle` method of the
    `Rng` trait to shuffle incoming binary data and return it as converted to Base64
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second variant, `RngRequest::Color`, uses the `color_range` function that
    we''ll declare. This branch generates three colors in a range and returns a generated
    color. Let''s explore the `color_range` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a new `Uniform` distribution with an inclusive range using
    `from` and `to` values. We're now ready to compile and test our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling, running, and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile this example and run it with the `cargo run` command. Use `curl` to
    send requests to the service. In the first request, we''ll generate a random number
    with a uniform distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We sent a `POST` request to the `localhost:8080/random` URL with a JSON body.
    This will return `{"value":-55.0}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command requests a shuffle of the `"1234567890"` binary string converted
    to Base64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The expected response will be `{"bytes":"MDk3NjgxNDMyNQ=="}`, which equals the
    string `"0976814325"`. You'll get another value for this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next request will take a random color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used both representations of a color value: a string value of `"black"`
    and a hex value of `"#EC670F"`. The response will be something similar to `{"color":"#194A09"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example shows what happens if we try to send a request with an unsupported
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Since the service doesn't support `"gamma"` distribution, it will return an
    error reading ``"unknown variant `gamma`, expected one of `uniform`, `normal`,
    `bernoulli`, `shuffle`, `color` at line 1 column 24"``.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices with multiple formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes microservices have to be flexible and support multiple formats. For
    example, some modern clients use JSON, but some need XML or another format. In
    this section, we'll improve our microservices by adding the **Concise Binary Object
    Representation** (**CBOR**) serialization format.
  prefs: []
  type: TYPE_NORMAL
- en: '**CBOR** is a binary data serialization format based on JSON. It''s more compact,
    supports binary strings, works faster, and is defined as a standard. You can read
    more about this at [https://tools.ietf.org/html/rfc7049](https://tools.ietf.org/html/rfc7049).'
  prefs: []
  type: TYPE_NORMAL
- en: Different formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need two extra crates: `queryst` for parsing parameters from the query string,
    and the `serde_cbor` crate to support the CBOR serialization format. Add these
    to your `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, import them in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `serde_json::to_string` directly in the handler, we''ll move
    it to a separate function that serializes data depending on the expected format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we used a match expression to detect a format. Significantly,
    we changed the `String` result to a binary type, `Vec<u8>`. We also used `failure::Error`
    as an error type, because both `serde_json` and `serde_cbor` have their own error
    types and we can convert them to a generic error using the `?` operator.
  prefs: []
  type: TYPE_NORMAL
- en: If the provided format is unknown, we can construct an `Error` with the `format_err!`
    macro of the `failure` crate. This macro works like the `println!` function, but
    it creates a generic error based on a string value.
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the `Error` type in import section. Previously, it was the `hyper::Error`
    type from the `hyper` crate, but we'll now use the `failure::Error` type instead
    and use a crate name prefix for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP URI can contain a query string with parameters that we can use to
    tune a request. The `Request` type has a method, `uri`, which returns a query
    string if it''s available. We added the `queryst` crate, which parses a query
    string to `serde_json::Value`. We''ll use this value to extract the `"format"`
    parameters from the query string. If the format isn''t provided, we''ll use `"json"`
    as a default value. Add the format-extracting block to the branch that handles
    requests to the `/random` path and use the `serialize` function that we previously
    declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code extracts a format value from a query string, processes a request,
    and returns a serialized value using a chosen format.
  prefs: []
  type: TYPE_NORMAL
- en: Checking different formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile the code, run it, and use `curl` to check the result. First, let''s
    check the traditional JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a JSON response that we''ve seen before: `{"value":-19.0}`.
    The next request will return a CBOR value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This command won''t print a response to the console, because it''s in binary
    format. You''ll see the following warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to request a response in XML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This has worked correctly; it printed `unsupported format xml` to indicate that
    it doesn't support XML format. Let's now move on to discussing transcoding `serde`
    values and looking at why XML isn't a format that's widely supported by `serde`.
  prefs: []
  type: TYPE_NORMAL
- en: Transcoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you''ll be faced with situations in which you need to convert one
    format to another. In this instance, you can use the `serde_transcode` crate,
    which converts one format to another using a standard `serde` serialization process.
    The crate has a `transcode` function that expects a `serializer` and a `deserializer`
    as arguments. You can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code converts incoming JSON data into CBOR data. You can read more about
    this crate at: [https://crates.io/crates/serde-transcode](https://crates.io/crates/serde-transcode).'
  prefs: []
  type: TYPE_NORMAL
- en: XML support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`serde` doesn''t provide very good support for XML. The main reason for this
    is the complexity of the format. It has so many rules and exceptions that you
    can''t describe the expected format in a simple form. However, there are also
    some implementations that aren''t compatible with `serde`. The following links
    explain streaming, reading, and writing XML data: [https://crates.io/crates/xml-rs](https://crates.io/crates/xml-rs)
    and [https://crates.io/crates/quick-xml](https://crates.io/crates/quick-xml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another format that isn''t compatible with the `serde` infrastructure is Protocol
    Buffers ([https://developers.google.com/protocol-buffers/](https://crates.io/crates/protobuf)).
    Developers often choose this format for performance reasons and to use one scheme
    of data for different applications. To use this format in Rust code, try to use
    the `protobuf` crate: [https://crates.io/crates/protobuf](https://crates.io/crates/protobuf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, it''s better to use a format that''s compatible with the `serde`
    crate in Rust for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It's simpler to use in a code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs don't need a scheme, because they're strict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a separated crate with a determined protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only situation in which you shouldn't follow the `serde` approach is if
    you have to support a format that isn't compatible with `serde`, but has been
    used in existing services or clients.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed serialization and deserialization processes using
    the `serde` crate. We looked at how `serde` supports multiple formats and can automatically derive
    `Serialize` and `Deserialize` implementations for structs or enumerations. We
    implemented a service that generates random numbers from incoming parameters serialized
    in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you learned how to implement these traits yourself and add extra
    features to shuffle an array or to generate a random color. Finally, we discussed
    how to support multiple formats in one handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to use full potential of asynchronous
    code, and write microservices with Rust that can handle thousands of clients simultaneously.
  prefs: []
  type: TYPE_NORMAL
