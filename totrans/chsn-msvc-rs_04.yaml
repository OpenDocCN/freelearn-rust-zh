- en: Data Serialization and Deserialization with the Serde Crate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Serde Crate 进行数据序列化和反序列化
- en: Microservices can either interact with clients or each other. To implement interaction,
    you have to choose a protocol and a format to send messages from one communication
    participant to another. There are many formats and RPC frameworks that simplify
    the interaction process. In this chapter, we'll discover features of the `serde`
    crate, which helps you to make structs serializable and deserializable and compatible
    with different formats, such as JSON, CBOR, MessagePack, and BSON.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以与客户端或彼此交互。要实现交互，你必须选择一个协议和一个格式，以便从一个通信参与者向另一个通信参与者发送消息。有许多格式和 RPC 框架可以简化交互过程。在本章中，我们将发现
    `serde` Crate 的功能，它可以帮助你使结构体可序列化和可反序列化，并兼容不同的格式，如 JSON、CBOR、MessagePack 和 BSON。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to serialize and deserialize data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何序列化和反序列化数据
- en: How to make custom types types serializable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使自定义类型可序列化
- en: Which serialization formats to choose and which to avoid
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应选择哪些序列化格式以及应避免哪些格式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll explore some of the features that are available in the `serde`
    crates family. This family includes the inseparable pair – the `serde` and `serde_derive`
    crates. It also includes crates such as `serde_json`, `serde_yaml`, and `toml`
    that provide you support for special formats, such as JSON, YAML, and **`TOML`**.
    All of these crates are pure Rust and don't require any external dependencies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 `serde` Crate 家族中的一些可用功能。这个家族包括不可分割的一对——`serde` 和 `serde_derive`
    Crate。它还包括如 `serde_json`、`serde_yaml` 和 `toml` 这样的 Crate，它们为你提供了对特殊格式（如 JSON、YAML
    和 **`TOML`**）的支持。所有这些 Crate 都是纯 Rust 编写的，并且不需要任何外部依赖。
- en: 'You can get the source code of the examples in this chapter from GitHub at:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04)[.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter4)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 获取本章示例的源代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04)[.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter4)
- en: Data formats for interaction with microservices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与微服务交互的数据格式
- en: Microservices can interact with different participants, such as clients, other
    microservices, and third-party APIs. Typically, interactions are performed by
    the network using serialized data messages in a certain format. In this section,
    we'll learn how to choose a format for these interactions. We'll also explore
    the basic features of a `serde` crate – how to make our structs serializable and
    use a specific format.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以与不同的参与者交互，例如客户端、其他微服务和第三方 API。通常，交互是通过网络使用特定格式的序列化数据消息来执行的。在本节中，我们将学习如何选择这些交互的格式。我们还将探索
    `serde` Crate 的基本功能——如何使我们的结构体可序列化并使用特定格式。
- en: The serde crate
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Serde Crate
- en: When I started to use Rust in my projects, I used to use the popular `rustc_serialize`
    crate. This wasn't bad, but I found that it wasn't flexible enough. For example,
    I couldn't use generic data types in my own structs. The `serde` crate was created
    to eliminate the shortcomings of the `rustc_serialize`crate. `serde` has been
    the main crate for serialization and deserialization in Rust since the `serde`
    crate reached the 1.0 release branch.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始在我的项目中使用 Rust 时，我通常使用流行的 `rustc_serialize` Crate。这并不坏，但我发现它不够灵活。例如，我无法在我的结构体中使用泛型数据类型。`serde`
    Crate 的创建是为了消除 `rustc_serialize` Crate 的不足。自从 `serde` Crate 达到 1.0 版本分支以来，`serde`
    一直是 Rust 中序列化和反序列化的主要 Crate。
- en: We used this crate in the previous chapter to deserialize a configuration file.
    We're now going to use it to transform request and response data to text or binary
    data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中使用这个 Crate 来反序列化配置文件。现在我们将使用它来将请求数据和响应数据转换为文本或二进制数据。
- en: To explore serialization, we'll use a microservice that generates random numbers.
    We'll rewrite a very simple version without logging, reading arguments, environment
    variables, or configuration files. It will use the HTTP body to specify a range
    of random values and a random distribution to generate a number from.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索序列化，我们将使用一个生成随机数的微服务。我们将重写一个非常简单的版本，不包含日志记录、读取参数、环境变量或配置文件。它将使用 HTTP 主体来指定随机值的范围和随机分布，以生成一个数字。
- en: Our service will handle requests for the `/random` path only. It will expect
    both a request and a response in JSON format. As mentioned, the `serde` crate
    provides serialization capabilities to the code. We also need the `serde_derive`
    crate to derive the serialization method automatically. The `serde` crate contains
    only core types and traits to make the serialization process universal and reusable,
    but specific formats are implemented in other crates. We'll use `serde_json`,
    which provides a `serializer` in JSON format.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将只处理 `/random` 路径的请求。它将期望请求和响应都使用 JSON 格式。如前所述，`serde` crate 为代码提供了序列化能力。我们还需要
    `serde_derive` crate 来自动推导序列化方法。`serde` crate 只包含核心类型和特性，以使序列化过程通用和可重用，但特定格式是在其他
    crate 中实现的。我们将使用 `serde_json`，它提供了一个 JSON 格式的 `serializer`。
- en: 'Copy the code of the minimal random-number-generating service and add these
    dependencies to `Cargo.toml`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 复制最小随机数生成服务的代码，并将以下依赖项添加到 `Cargo.toml` 中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Import these crates into the `main.rs` source file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 crate 导入到 `main.rs` 源文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we imported a macro from the `serde_derive` and `serde_json`
    crates to use a JSON `serializer`. We don't import the `serde` crate, because
    we won't use it directly, but it's necessary to use the macro. We can now look
    at the different parts of the code. At first, we'll examine the request and response
    types. After that, we'll implement a handler to use it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们从 `serde_derive` 和 `serde_json` crate 中导入了一个宏来使用 JSON `serializer`。我们不需要导入
    `serde` crate，因为我们不会直接使用它，但使用宏是必要的。现在我们可以查看代码的不同部分。首先，我们将检查请求和响应类型。之后，我们将实现一个处理器来使用它。
- en: Serializing responses
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化响应
- en: 'The service returns random numbers represented as the `f64` type. We want to
    return it packed to a JSON object, because we may need to add more fields to the
    object. It''s simple to use objects in JavaScript. Declare the `RngResponse` struct
    and add the `#[derive(Serailize)]` attribute. This makes this struct serializable,
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 服务返回以 `f64` 类型表示的随机数。我们希望将其打包到一个 JSON 对象中，因为我们可能需要向对象中添加更多字段。在 JavaScript 中使用对象很简单。声明
    `RngResponse` 结构体并添加 `#[derive(Serialize)]` 属性。这使得这个结构体可序列化，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To make this struct deserializable, we should derive the `Deserialize` trait.
    Deserialization may be useful it you want to use the same type for requests and
    responses. It's also important to derive both `Serialize` and `Deserialize` if
    you want to use the same type in a server and a client.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个结构体可反序列化，我们应该推导 `Deserialize` 特性。如果你想要使用相同的类型进行请求和响应，反序列化可能很有用。如果你想在服务器和客户端中使用相同的类型，那么推导
    `Serialize` 和 `Deserialize` 都是很重要的。
- en: 'The serialized object will be represented as a string, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化的对象将被表示为以下字符串：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Deserializing requests
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反序列化请求
- en: 'The service will support complex requests in which you can specify a distribution
    and parameters. Let''s add this enumeration to the source file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将支持复杂的请求，你可以指定分布和参数。让我们将这个枚举添加到源文件中：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may want to know what the serialized value looks like. `serde_derive` provides
    extra attributes, which you can use to tweak the serialization format. The current
    `deserializer` expects a `RngRequest` instance, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道序列化值看起来像什么。`serde_derive` 提供了额外的属性，你可以使用这些属性来调整序列化格式。当前的 `deserializer`
    期望一个 `RngRequest` 实例，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be represented as the string:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被表示为以下字符串：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you create your own protocol from scratch, there won''t be any problems
    with the layout, because you can easily make it conform to any restrictions specified
    by serializers that are automatically generated by the `serde` crate. If you have
    to use an existing protocol, however, you can try to add extra attributes to a
    declaration. If this doesn''t help, you can implement the `Serialize` or `Deserialize`
    traits manually. For example, let''s say we want to use the following request
    format:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头开始创建自己的协议，由于你可以轻松地使其符合由 `serde` crate 自动生成的序列化器的任何限制，因此布局不会有任何问题。然而，如果你必须使用现有的协议，你可以尝试向声明中添加额外的属性。如果这不起作用，你可以手动实现
    `Serialize` 或 `Deserialize` 特性。例如，假设我们想使用以下请求格式：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the `serde` attributes to the `RngRequest` declaration, which transform
    the `deserializer` to support the preceding format. The code will look as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `serde` 属性添加到 `RngRequest` 声明中，这将使 `deserializer` 支持前面的格式。代码将如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the enumeration uses the aforementioned request format. There are a lot
    of attributes in the `serde_derive` crate and it's important to explore them in
    more detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，枚举使用上述请求格式。`serde_derive` 包中有很多属性，探索它们非常重要。
- en: Tweaking serialization
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整序列化
- en: '`serde_derive` supports a lot of attributes that help you to avoid manual implementations
    of the `serializer` or `deserializer` for the struct. In this section, we take
    a look at useful attributes in detail. We''ll learn how to change the letter case
    of variants, how to remove a level of nesting, and how to use specific names for
    a tag and for a content of an enumeration.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde_derive` 支持许多属性，可以帮助你避免为结构体手动实现 `serializer` 或 `deserializer`。在本节中，我们将详细探讨有用的属性。我们将学习如何更改变体的字母大小写，如何移除嵌套级别，以及如何为枚举的标签和内容使用特定名称。'
- en: Changing the case of names
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改名称的大小写
- en: '`serde_derive` maps names of fields in the code to fields of data. For example,
    the `title` field of a struct will expect the `title` field of a data object.
    If the protocol uses other names for fields, you have to take this into account
    to avoid warnings. For example, a struct in a protocol might contain the `stdDev` field,
    but if you use the name of this field in Rust, you get the following warning:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde_derive` 将代码中字段的名称映射到数据字段。例如，结构体中的 `title` 字段将期望数据对象中的 `title` 字段。如果协议使用其他名称作为字段，你必须考虑到这一点以避免警告。例如，协议中的一个结构体可能包含
    `stdDev` 字段，但如果你在 Rust 中使用这个字段的名称，你会得到以下警告：'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can fix this adding the `#![allow(non_snake_case)]` attribute, but this
    makes the code unsightly. A better solution is to use the `#[serde(rename="stdDev")]`
    attribute and use the other naming convention for serialization and deserialization
    only.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加 `#![allow(non_snake_case)]` 属性来修复这个问题，但这会使代码看起来不美观。更好的解决方案是使用 `#[serde(rename="stdDev")]`
    属性，并仅对序列化和反序列化使用其他命名约定。
- en: 'There are two variants of renaming attributes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名属性有两种变体：
- en: Changing the naming convention for all variants
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改所有变体的命名约定
- en: Changing the name of a field
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改字段的名称
- en: 'To change all variants of an enumeration, add the `#[serde(rename_all="...")]`
    attribute with one of the following values: `"lowercase"`, `"PascalCase"`, `"camelCase"`,
    `"snake_case"`, `"SCREAMING_SNAKE_CASE"`, or `"kebab-case"`. To be more representative,
    naming values are written according to the rules of their own convention.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改枚举的所有变体，请添加 `#[serde(rename_all="...")]` 属性并使用以下值之一：`"lowercase"`、`"PascalCase"`、`"camelCase"`、`"snake_case"`、`"SCREAMING_SNAKE_CASE"`
    或 `"kebab-case"`。为了更具有代表性，命名值将根据其自身约定的规则编写。
- en: To change the name of a field, use the `#[serde(rename="...")]` attribute with
    the name of the field used in the serialization process. You can see an example
    of the usage of this attribute in [Chapter 17](2dceb3bc-2f03-47d9-88cd-561b4f0b50d7.xhtml),
    *Bounded Microservices with AWS Lambda*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字段的名称，请使用 `#[serde(rename="...")]` 属性并指定在序列化过程中使用的字段名称。你可以在 [第 17 章](2dceb3bc-2f03-47d9-88cd-561b4f0b50d7.xhtml)
    中看到一个此属性使用示例，*使用 AWS Lambda 的有界微服务*。
- en: Another reason to use renaming is when the names of fields are keywords in Rust.
    For example, a struct can't contain a field with the popular name `type`, because
    it's a keyword. You can rename it to `typ` in the struct and add `#[serde(rename="type")]`
    to it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重命名的一个原因是当字段名称在 Rust 中是关键字时。例如，一个结构体不能包含名为 `type` 的字段，因为它是一个关键字。你可以在结构体中将它重命名为
    `typ` 并添加 `#[serde(rename="type")]` 到它。
- en: Removing a nesting
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除嵌套
- en: 'The `serializer` derived automatically uses the same nesting structure as your
    type. If you need to reduce the levels of nesting, you can set the `#[serde(flatten)]`
    attribute to use fields without enclosing objects. In the previous example, we
    used the `Range` type from the standard library to set a range in which to generate
    a random value, but we also want to see the implementation details in the serialized
    data. To do this, we need the `start` and `end` fields of the `Range`. We added
    this attribute to the field to cut out the `{ "range": ... }` level of the structure.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '自动派生的 `serializer` 使用与你的类型相同的嵌套结构。如果你需要减少嵌套级别，你可以设置 `#[serde(flatten)]` 属性以使用没有封装对象的字段。在之前的示例中，我们使用了标准库中的
    `Range` 类型来设置生成随机值的范围，但我们还希望在序列化数据中看到实现细节。为此，我们需要 `Range` 的 `start` 和 `end` 字段。我们向该字段添加了此属性以删除结构中的
    `{ "range": ... }` 级别。'
- en: 'For enumeration, `serde_derive` uses a tag as the name of the object. For example,
    the following JSON-RPC contains two variants:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于枚举，`serde_derive` 使用标签作为对象的名称。例如，以下 JSON-RPC 包含两个变体：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `params` field contains an array of any JSON values represented by the `serde_json::Value`
    type, we''ll explore this type later in this chapter. If you serialize an instance
    of this struct, it will include the name of a variant. Consider the following,
    for example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 字段包含一个由 `serde_json::Value` 类型表示的任何 JSON 值的数组，我们将在本章后面探讨此类型。如果你序列化此结构体的实例，它将包括变体的名称。例如，考虑以下内容：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This request isn''t compatible with the JSON-RPC specification ([https://www.jsonrpc.org/specification#request_object](https://www.jsonrpc.org/specification#request_object)).
    We can drop the enclosing object with the `#[serde(untagged)]` attribute and the
    struct becomes as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求与 JSON-RPC 规范不兼容 ([https://www.jsonrpc.org/specification#request_object](https://www.jsonrpc.org/specification#request_object))。我们可以使用
    `#[serde(untagged)]` 属性删除封装对象，结构体将如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After this change, this serialized data can be sent as JSON-RPC. However, if
    you still want to keep the variant value in a serialized data form, you have to
    use another approach, which is described in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改后，此序列化数据可以发送为 JSON-RPC。但是，如果你仍然希望将变体值保留在序列化数据形式中，你必须使用另一种方法，这将在下一节中描述。
- en: Using specific names for a tag and content
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定的名称为标签和内容命名
- en: 'In our example, we want to have two fields in a serialized data form: `distribution`
    and `parameters`. In the first field, we want to hold a variant of enumeration,
    but renamed so that it''s in lowercase. In the second field, we''ll keep the parameters
    of the specific variant.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们希望在序列化数据形式中有两个字段：`distribution` 和 `parameters`。在第一个字段中，我们希望保存枚举的变体，但重命名使其为小写。在第二个字段中，我们将保留特定变体的参数。
- en: To achieve this, you can write your own `Serializer` and `Deserializer`, an
    approach that we'll explore later in this chapter. For this case, however, we
    can use the `#[serde(tag = "...")]` and `#[serde(context = "...")]` attributes.
    `context` can only be used in a pair with `tag`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以编写自己的 `Serializer` 和 `Deserializer`，我们将在本章后面探讨这种方法。然而，在这种情况下，我们可以使用
    `#[serde(tag = "...")]` 和 `#[serde(context = "...")]` 属性。`context` 只能与 `tag` 配对使用。
- en: 'We have added this to our `RngRequest`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将此添加到我们的 `RngRequest` 中：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This attribute specifies the `distribution` key of the serialized object to
    hold a variant of the enumeration. The variants of the enumeration move to the `parameters`
    field of the serialized object. The last attribute, `rename_all`, changes the
    case of the name of a variant. Without renaming, we would be forced to use title
    case for distributions, such as `"Uniform"` instead of the tidier `"uniform"`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定了序列化对象的 `distribution` 键以保存枚举的变体。枚举的变体移动到序列化对象的 `parameters` 字段。最后一个属性
    `rename_all` 改变了变体名称的大小写。如果没有重命名，我们将被迫使用标题大小写来表示分布，例如使用 `"Uniform"` 而不是更整洁的 `"uniform"`。
- en: Sometimes, a serialized value has to include an object with a dynamic structure.
    Formats such as JSON support free data structures. I don't like unspecified structures,
    but we may need them to create services that are compatible with existent services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，序列化的值必须包含具有动态结构的对象。例如，JSON 格式支持自由数据结构。我不喜欢未指定的结构，但为了创建与现有服务兼容的服务，我们可能需要它们。
- en: Any Value
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任何值
- en: If you want to keep a certain part of your data deserialized but you don't know
    the structure of the data and you want to explore it later in runtime, you can
    use the generic `serde_json::Value`, which represents a value of any type. For
    example, the `serde_json` crate includes a `Value` object and a method to deserialize
    types from an instance of `Value`. This may be useful in difficult deserialization
    cases in which you need to reorder the representation before it's completely deserialized.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保持数据的一部分未序列化，但你不知道数据的结构，并且希望在运行时稍后探索它，你可以使用通用的 `serde_json::Value`，它表示任何类型的值。例如，`serde_json`
    包含一个 `Value` 对象和一个从 `Value` 实例反序列化类型的方法。这可能在对表示进行重新排序之前完全反序列化困难的反序列化情况中很有用。
- en: 'To use a generic `Value`, add it to your struct. Consider the following, for
    example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用通用的 `Value`，请将其添加到你的结构体中。例如，考虑以下内容：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we used a generic value of the `serde_json` crate. When you need to deserialize
    it to a `User` struct, for example, you can use the `serde_json::from_value` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `serde_json` 包的通用值。当你需要将其反序列化为 `User` 结构体，例如，你可以使用 `serde_json::from_value`
    函数：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this section, we learned about deserialization processes. It's now time to
    add a handler to our server to process requests. This handler will deserialize
    the data, generate a random value, and return the data back in its serialized
    form to the client.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了反序列化过程。现在是时候向我们的服务器添加一个处理器来处理请求了。这个处理器将反序列化数据，生成一个随机值，并以序列化的形式将数据返回给客户端。
- en: If I write a proxy service, should I deserialize and serialize requests to send
    them unchanged to another service? This depends on the purpose of the service. Serialization
    and deserialization take up a substantial amount of CPU resources. If the service
    is used to balance requests, you don't need the inner data of the request. This
    is especially the case if you only use HTTP headers to choose the destination
    of the request. However, you might want to use the processing benefits of deserialized
    data – for example, you can patch some values of the data before sending it to
    other microservices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我写一个代理服务，我应该反序列化和序列化请求以将它们不变地发送到另一个服务吗？这取决于服务的目的。序列化和反序列化会占用大量的CPU资源。如果服务用于平衡请求，你不需要请求的内部数据。特别是如果你只使用HTTP头选择请求的目的地。然而，你可能想使用反序列化数据的处理优势——例如，你可以在将其发送到其他微服务之前修补数据的一些值。
- en: Using hyper
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超
- en: We added the `RngRequest` and `Response` types and implemented the `Serialize`
    and `Deserialize` traits. Now we can use them with `serde_json` in a handler.
    In this section, we'll explore how get the full body of a request, deserialize
    it into an instance of a specific type, and serialize a response.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`RngRequest`和`Response`类型，并实现了`Serialize`和`Deserialize`特性。现在我们可以在处理器中使用它们与`serde_json`一起。在本节中，我们将探讨如何获取请求的全部内容，将其反序列化为特定类型的实例，以及序列化响应。
- en: Reading a body from a stream
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从流中读取主体
- en: In fact, the body of a request in a `hyper` crate is a stream. You can't get
    access to the full body immediately, but you can read incoming chunks, write them
    to a vector, and use the resulting data set as a single object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`hyper`包中请求的主体是一个流。你无法立即获取全部内容，但你可以读取传入的块，将它们写入一个向量，并使用结果数据集作为一个单一对象。
- en: We don't have access to the whole body because it may be a huge block of data
    that we can't keep in the memory. Our service could be used, for example, to upload
    multiple terabytes of data files or for video streaming.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问整个主体，因为它可能是一个巨大的数据块，我们无法将其保存在内存中。我们的服务可以用于上传多个太字节的数据文件或进行视频流传输。
- en: Since we're using an asynchronous approach, we can't block the current thread
    while we read the stream to the end. This is because it would block the thread
    and cause the program to stop working, because the same thread is used for polling
    streams.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是异步方法，我们不能在读取流到末尾时阻塞当前线程。这是因为这将阻塞线程并导致程序停止工作，因为相同的线程用于轮询流。
- en: The `serde` crate doesn't support the deserialization of a continuous flow of
    data, but you can create and use a `Deserializer` instance directly to handle
    infinite streams.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde`包不支持连续数据流的反序列化，但你可以直接创建并使用一个`Deserializer`实例来处理无限流。'
- en: 'To read data from a stream, you have to take a `Stream` instance and put it
    into a `Future` object, which will collect the data from that stream. We''ll explore
    this topic in the next chapter in more detail. Let''s implement a `Future` that
    collects data from a `Stream` instance. Add the following code to a branch of
    the `/random` path in the `match` expression of the handler:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要从流中读取数据，你必须获取一个`Stream`实例并将其放入一个`Future`对象中，该对象将收集该流中的数据。我们将在下一章中更详细地探讨这个主题。让我们实现一个从`Stream`实例收集数据的`Future`。将以下代码添加到处理器中`/random`路径的`match`表达式的分支：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Request` instance has the `into_body` method, which returns the body of
    the request. We used the `Body` type to represent a body for our handler. The `Body`
    type is a stream of chunks that implement the `Stream` trait. It has the `concat2`
    method, which concatenates all chunks to a single object. This is possible because
    the `Chunk` type implements the `Extend` trait and can be extended with the other
    `Chunk`. The `concat2` method transforms the `Stream` to `Future`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request`实例有一个`into_body`方法，它返回请求的主体。我们使用了`Body`类型来表示我们的处理器的主体。`Body`类型是一个实现了`Stream`特性的块流。它有一个`concat2`方法，可以将所有块连接成一个单一对象。这是因为`Chunk`类型实现了`Extend`特性，并且可以与其他`Chunk`扩展。`concat2`方法将`Stream`转换为`Future`。'
- en: If you aren't familiar with the `futures` crate, you can learn more about it
    in the next chapter. For now, you can think of a `Future` object as a `Result`
    that will be completed later. You can think of a `Stream` as an `Iterator` that
    doesn't have a reference to any item and has to poll for the next item from a
    data stream.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉`futures` crate，你可以在下一章中了解更多关于它的信息。现在，你可以将`Future`对象视为一个稍后完成的`Result`。你可以将`Stream`视为一个没有引用任何项的`Iterator`，它必须从数据流中轮询下一个项。
- en: After we take the whole body of a request, we can use deserialize. `serde_derive`
    derives a generic `deserializer`, so we have to use a crate to get a specific
    serialization format. In this case, we'll use the JSON format, so we'll use the `serde_json`
    crate. This includes a `from_slice` function, which creates a `Deserializer` for
    our type and uses it to read an instance from a buffer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们取完请求的全部正文后，我们可以使用反序列化。`serde_derive`派生一个通用的`deserializer`，因此我们必须使用一个crate来获取特定的序列化格式。在这种情况下，我们将使用JSON格式，所以我们将使用`serde_json`
    crate。这包括一个`from_slice`函数，它为我们的类型创建一个`Deserializer`，并使用它从缓冲区中读取一个实例。
- en: The `from_slice` method returns a `Result<T, serde_json::Error>` and we'll `map`
    this result to our own `handle_request` function, which reads the request and
    generates a response. We'll discuss this function later in this section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_slice`方法返回一个`Result<T, serde_json::Error>`，我们将`map`这个结果到我们自己的`handle_request`函数，该函数读取请求并生成响应。我们将在本节稍后讨论这个函数。'
- en: When the result is ready, we use the `serde_json::to_string` function to convert
    the response to a JSON string. We use `and_then`, because `to_string` returns
    a Result and we have to handle errors if there are any.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果准备好时，我们使用`serde_json::to_string`函数将响应转换为JSON字符串。我们使用`and_then`，因为`to_string`返回一个Result，我们必须处理任何错误。
- en: We now have a `Result`, which contains a serialized response or `serde_json::Error`
    if anything goes wrong. We'll use the `match` expression to return a successful
    `Response` if the response is created and serialized to a `String` successfully
    or a response with the `UNPROCESSABLE_ENTITY` status and a body with an error
    message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个`Result`，它包含一个序列化的响应或者如果发生错误则包含`serde_json::Error`。我们将使用`match`表达式来返回一个成功的`Response`，如果响应被成功创建并序列化为一个`String`，或者返回一个带有`UNPROCESSABLE_ENTITY`状态和错误信息的响应体。
- en: In our case, we created a `Future` object, which doesn't have any results. We
    have to add that future to a reactor to execute it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们创建了一个没有结果的`Future`对象。我们必须将这个未来添加到一个reactor中以便执行它。
- en: 'When discussing the preceding code, we mentioned the `handle_request` function.
    Let''s take a closer look at the implementation of this function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论前面的代码时，我们提到了`handle_request`函数。让我们更仔细地看看这个函数的实现：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The function takes a `RngRequest` value. The first line of the implementation
    uses a `rand::thread_rng` function to create a random-number-generator instance.
    We'll use the `sample` method to generate a random value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个`RngRequest`值。实现的第一行使用`rand::thread_rng`函数创建一个随机数生成器实例。我们将使用`sample`方法生成一个随机值。
- en: 'Our request supports three kinds of distributions: `Uniform`, `Normal`, and
    `Bernoulli`. We used destructuring patterns to get the parameters of a request
    to create a distribution instance. After this, we used a deserialized request
    for sampling and converted the result into the `f64` type to pack it into the `RngResponse`
    value.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求支持三种类型的分布：`Uniform`、`Normal`和`Bernoulli`。我们使用了解构模式来获取请求的参数以创建一个分布实例。之后，我们使用反序列化的请求进行采样，并将结果转换为`f64`类型以打包到`RngResponse`值中。
- en: Custom types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类型
- en: When your microservice uses custom data structures, it needs a custom serialization
    format. You can add your own serialization by implementing the `Serialize` and
    `Deserialize` traits, or by adding special attributes to your struct or field
    of struct. We'll explore both approaches here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的微服务使用自定义数据结构时，它需要一个自定义的序列化格式。你可以通过实现`Serialize`和`Deserialize`特质，或者通过添加特殊属性到你的结构体或结构体的字段中来自定义序列化。我们将在这里探讨这两种方法。
- en: Custom serialization
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义序列化
- en: 'We''ll extend our random-number-generating service with two features – generating
    random colors and shuffling an array of bytes. For the first feature, we need
    to add the `Color` struct to hold the color components. Create a new file, `color.rs`,
    and add the following code to it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的随机数生成服务，增加两个功能——生成随机颜色和打乱字节数组。对于第一个功能，我们需要添加一个`Color`结构体来保存颜色分量。创建一个新的文件，`color.rs`，并将以下代码添加到其中：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add two constant colors that we''ll use later:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个我们稍后会用到的常量颜色：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The struct also implements `PartialEq` and `Eq` to compare a value with these
    constants.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体还实现了 `PartialEq` 和 `Eq` 来比较值与这些常量。
- en: 'We''ll use a textual representation of color that''s compatible with CSS. We''ll
    support RGB colors in hex format and two textual colors: `black` and `white`.
    To convert a color to a string, implement the `Display` trait for `Color`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与 CSS 兼容的文本表示颜色。我们将支持十六进制格式的 RGB 颜色以及两种文本颜色：`black` 和 `white`。要将颜色转换为字符串，为
    `Color` 实现 `Display` 特性：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This implementation writes three color components to a string with the `'#'`
    prefix. Every color component byte is written in hex format with the `'0'` prefix
    for nonsignificant digits and with a width of two characters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现使用 `'#'` 前缀将三个颜色分量写入字符串。每个颜色分量字节都以十六进制格式写入，对于非重要数字使用 `'0'` 前缀，宽度为两个字符。
- en: 'We can now use this formatter to implement the `Serialize` trait for the `Color`
    struct:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个格式化程序来实现 `Color` 结构体的 `Serialize` 特性：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This `Serialize` implementation calls the `serialize_str` method of the `Serializer`
    to store a hex representation of a color to a string. Before implementing a custom
    deserialization, add all necessary imports to the `color.rs` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Serialize` 实现调用 `Serializer` 的 `serialize_str` 方法来将颜色的十六进制表示存储到字符串中。在实现自定义反序列化之前，将所有必要的导入添加到
    `color.rs` 文件中：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom deserialization
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义反序列化
- en: 'Our `Color` type has to be convertible from a string. We can do this by implementing
    the `FromStr` trait, which makes it possible to call the `parse` method of `str`
    to parse the struct from a string:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Color` 类型必须能够从字符串转换。我们可以通过实现 `FromStr` 特性来实现这一点，这使得我们可以调用 `str` 的 `parse`
    方法来从字符串解析结构体：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this implementation, we use a match expression with four branches to check
    the cases. We indicate that the expression should have a textual value of either
    `"white"` or `"black"`, or that it can start with a `#`, and that it should contain
    exactly seven characters. Otherwise, an error should be returned to indicate that
    an unsupported format has been provided.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，我们使用具有四个分支的匹配表达式来检查情况。我们指示表达式应该具有 `"white"` 或 `"black"` 的文本值，或者它可以以 `#`
    开头，并且应该包含恰好七个字符。否则，应返回错误以指示提供了不受支持的格式。
- en: 'To implement the `Deserialization` trait, we need to add the `ColorVisitor`
    struct, which implements the `Visitor` trait of the `serde` crate. The `Visitor`
    trait is used to extract a value of a specific type from different input values.
    For example, we can use the `u32` and `str` input types to deserialize decimal
    values. The `ColorVisitor` in the following example tries to parse the incoming
    strings to a color. It has the following implementation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `Deserialization` 特性，我们需要添加 `ColorVisitor` 结构体，该结构体实现了 `serde` crate 的 `Visitor`
    特性。`Visitor` 特性用于从不同的输入值中提取特定类型的值。例如，我们可以使用 `u32` 和 `str` 输入类型来反序列化十进制值。以下示例中的
    `ColorVisitor` 尝试将传入的字符串解析为颜色。它具有以下实现：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we use the `parse` method of `str`, which works with types that
    implement the `FromStr` trait to convert a string to a `Color` instance. We implemented
    two methods to extract values from different types of strings – the first for
    `String` instances and the second for `str` references. We can now add the `Color`
    type as a field in the other deserializable struct. Let's take a closer look at
    the `ColorError` type before we look closer at working with binary data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了 `str` 的 `parse` 方法，该方法与实现了 `FromStr` 特性的类型一起工作，将字符串转换为 `Color` 实例。我们实现了两个方法来从不同类型的字符串中提取值——第一个用于
    `String` 实例，第二个用于 `str` 引用。现在我们可以将 `Color` 类型作为其他可反序列化结构体的字段添加。在我们更详细地查看处理二进制数据之前，让我们先仔细看看
    `ColorError` 类型。
- en: Custom error types with the failure crate
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 failure crate 的自定义错误类型
- en: The preceding parsing needs its own error type to cover both errors—incorrect
    parsing of numbers, and invalid variants. Let's declare the `ColorError` type
    in this section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的解析需要一个自己的错误类型来覆盖两种错误——数字解析错误和无效变体。让我们在本节中声明 `ColorError` 类型。
- en: Error handling in Rust is particularly easy. There's a `Result` type that wraps
    successful and unsuccessful outcomes in a single entity. `Result` interprets any
    type as an error type and you can transform one result to another using the `try!`
    macro or the `?` operator. Joining different error types, however, is much more
    complicated. There's the `std::error::Error` trait, which provides a generic interface
    for all errors, but it's a little clumsy. To create errors in a more user-friendly
    way, you can use the `failure` crate.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的错误处理特别简单。有一个 `Result` 类型，它将成功和失败的结果包装在单个实体中。`Result` 将任何类型解释为错误类型，您可以使用
    `try!` 宏或 `?` 操作符将一个结果转换为另一个结果。但是，将不同的错误类型连接起来要复杂得多。有一个 `std::error::Error` 特性，它为所有错误提供了一个通用接口，但它有点笨拙。为了以更用户友好的方式创建错误，您可以使用
    `failure` 包。
- en: This crate helps with error handling and contains extensive `failure::Error`
    types, which are compatible with other errors that implement the `std::Error::Error`
    trait. You can convert any error type that implements this trait to a generic
    `failure::Error`. This crate also includes macros that can be used to derive your
    own error type and the `failure::Fail` trait to implement extra features, such
    as `Backtrace`, which provides extra information about the primary cause of an
    error at runtime.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此包有助于错误处理，并包含广泛的 `failure::Error` 类型，这些类型与其他实现 `std::Error::Error` 特性的错误兼容。您可以将实现此特性的任何错误类型转换为通用的
    `failure::Error`。此包还包括可以用于派生您自己的错误类型和 `failure::Fail` 特性的宏，例如 `Backtrace`，它提供了有关错误运行时主要原因的额外信息。
- en: 'Declare this type in the `color.rs` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `color.rs` 文件中声明此类型：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ColorError` enumeration has two variants: `InvalidComponent` for parsing
    issues and `InvalidValue` if the wrong value is provided. To implement the necessary
    error traits for this type, we derive the `Fail` trait with the `#[derive(Debug,
    Fail)]` attribute. The `Debug` trait implementation is also necessary for `Fail`
    deriving.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorError` 枚举有两个变体：`InvalidComponent` 用于解析问题，如果提供了错误值，则为 `InvalidValue`。为了实现此类型的必要错误特性，我们使用
    `#[derive(Debug, Fail)]` 属性从 `Fail` 特性派生。`Fail` 派生的 `Debug` 特性实现也是必要的。'
- en: To create error messages, we added the `fail` attribute with a `display` parameter
    that expects a message with parameters to interpolate into a format string. For
    fields, you can use names, such as `value`, and numbers with the underscore prefix
    to indicate their field position. To insert the first field, for example, use
    the name `_0`. To mark a field as a nested error, use the `#[cause]` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建错误消息，我们添加了 `fail` 属性，它带有 `display` 参数，该参数期望一个包含参数以插入到格式字符串中的消息。对于字段，您可以使用名称，例如
    `value`，以及带有下划线前缀的数字以指示它们的字段位置。例如，要插入第一个字段，请使用名称 `0`。要将字段标记为嵌套错误，请使用 `#[cause]`
    属性。
- en: 'Deriving the `Fail` trait won''t implement `From` for types that we used as
    variants of the `ColorError` enum. You should do this yourself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Fail` 特性派生不会为用作 `ColorError` 枚举变体的类型实现 `From`。您应该自己这样做：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `ColorError` type is now ready to use with the `?` operator, and we can
    add random color generation to our microservice, together with the shuffling of
    a binary array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorError` 类型现在可以使用 `?` 操作符，并且我们可以将随机颜色生成添加到我们的微服务中，同时进行二进制数组的洗牌。'
- en: Binary data
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制数据
- en: 'Before improving the microservice, add all the necessary dependencies to `Cargo.toml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进微服务之前，将所有必要的依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''re using a lot of dependencies that work well with each other, thanks to
    Rust and crates. As you might have noticed, we have added the `base64` crate and
    the `base64-serde` crate. The first is a binary-to-text converter and the second
    is necessary to work with a converter in the serialization processes of `serde`.
    Import all of these to `main.rs`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了很多与 Rust 和 crates 一起工作得很好的依赖项。如您所注意到的，我们已添加了 `base64` 包和 `base64-serde`
    包。第一个是一个二进制到文本的转换器，第二个是 `serde` 序列化过程中的转换器所必需的。将这些全部导入到 `main.rs` 文件中：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We also added the `color` module and used `color:Color` from that module. We
    also imported macros from the `failure` and `base64_serde` crates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `color` 模块，并使用该模块中的 `color:Color`。我们还从 `failure` 和 `base64_serde` 包中导入宏。
- en: 'Add two extra variants to the `RngRequest` enumeration for color generation
    and array shuffling:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为颜色生成和数组洗牌向 `RngRequest` 枚举添加两个额外变体：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Shuffle` variant has field data of the  `Vec<u8>` type. Since JSON doesn''t
    support binary data, we have to convert it to text. We added the `#[serde(with
    = "Base64Standard")]` attribute, which requires us to use the `Base64Standard`
    type for deserialization. You can customize fields with your own serialization
    and deserialization functions; now, we have to declare `Base64Standard`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shuffle` 变体的字段数据为 `Vec<u8>` 类型。由于 JSON 不支持二进制数据，我们必须将其转换为文本。我们添加了 `#[serde(with
    = "Base64Standard")]` 属性，这要求我们使用 `Base64Standard` 类型进行反序列化。您可以使用自己的序列化和反序列化函数自定义字段；现在，我们必须声明
    `Base64Standard`：'
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have to declare this since `base64_serde` doesn't contain predefined deserializers.
    This is because Base64 needs extra parameters that can't have universal values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须声明它，因为 `base64_serde` 不包含预定义的反序列化器。这是因为 Base64 需要额外的参数，这些参数不能有通用值。
- en: The `Color` variant contains two fields, which can be used to specify a range
    in which the color will be generated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 变体包含两个字段，可以用来指定颜色生成的范围。'
- en: 'Add some new variants of a response to the `RngResponse` enumeration:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `RngResponse` 枚举添加一些新的响应变体：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now have to improve the `handle_request` function with additional variants:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须通过添加额外的变体来改进 `handle_request` 函数：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We refactored the code a bit here and there are two extra branches. The first
    branch, for the `RngRequest::Shuffle` variant, uses the `shuffle` method of the
    `Rng` trait to shuffle incoming binary data and return it as converted to Base64
    text.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里稍微重构了代码，并增加了两个额外的分支。第一个分支，对于 `RngRequest::Shuffle` 变体，使用 `Rng` 特性的 `shuffle`
    方法来打乱传入的二进制数据，并将其作为转换为 Base64 文本返回。
- en: 'The second variant, `RngRequest::Color`, uses the `color_range` function that
    we''ll declare. This branch generates three colors in a range and returns a generated
    color. Let''s explore the `color_range` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变体，`RngRequest::Color`，使用我们将声明的 `color_range` 函数。此分支在范围内生成三种颜色并返回生成的颜色。让我们来探索
    `color_range` 函数：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function creates a new `Uniform` distribution with an inclusive range using
    `from` and `to` values. We're now ready to compile and test our microservice.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `from` 和 `to` 值创建一个新的 `Uniform` 分布，包含的范围。我们现在准备编译和测试我们的微服务。
- en: Compiling, running, and testing
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译、运行和测试
- en: 'Compile this example and run it with the `cargo run` command. Use `curl` to
    send requests to the service. In the first request, we''ll generate a random number
    with a uniform distribution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo run` 命令编译此示例并运行它。使用 `curl` 向服务发送请求。在第一个请求中，我们将使用均匀分布生成一个随机数：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We sent a `POST` request to the `localhost:8080/random` URL with a JSON body.
    This will return `{"value":-55.0}`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `localhost:8080/random` URL 发送了一个 `POST` 请求，带有 JSON 主体。这将返回 `{"value":-55.0}`。
- en: 'The next command requests a shuffle of the `"1234567890"` binary string converted
    to Base64:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令请求对 `"1234567890"` 二进制字符串进行 Base64 打乱：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expected response will be `{"bytes":"MDk3NjgxNDMyNQ=="}`, which equals the
    string `"0976814325"`. You'll get another value for this request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的响应将是 `{"bytes":"MDk3NjgxNDMyNQ=="}`, 这等于字符串 `"0976814325"`. 你将得到这个请求的另一个值。
- en: 'The next request will take a random color:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个请求将采用一个随机颜色：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we used both representations of a color value: a string value of `"black"`
    and a hex value of `"#EC670F"`. The response will be something similar to `{"color":"#194A09"}`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了颜色值的两种表示：字符串值 `"black"` 和十六进制值 `"#EC670F"`。响应将类似于 `{"color":"#194A09"}`。
- en: 'The last example shows what happens if we try to send a request with an unsupported
    value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例显示了如果我们尝试发送一个不支持值的请求会发生什么：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since the service doesn't support `"gamma"` distribution, it will return an
    error reading ``"unknown variant `gamma`, expected one of `uniform`, `normal`,
    `bernoulli`, `shuffle`, `color` at line 1 column 24"``.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务不支持 `"gamma"` 分布，它将返回错误信息 `"unknown variant `gamma`, expected one of `uniform`,
    `normal`, `bernoulli`, `shuffle`, `color` at line 1 column 24"`。
- en: Microservices with multiple formats
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多种格式的微服务
- en: Sometimes microservices have to be flexible and support multiple formats. For
    example, some modern clients use JSON, but some need XML or another format. In
    this section, we'll improve our microservices by adding the **Concise Binary Object
    Representation** (**CBOR**) serialization format.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时微服务必须灵活并支持多种格式。例如，一些现代客户端使用 JSON，但有些需要 XML 或其他格式。在本节中，我们将通过添加 **Concise Binary
    Object Representation** （**CBOR**）序列化格式来改进我们的微服务。
- en: '**CBOR** is a binary data serialization format based on JSON. It''s more compact,
    supports binary strings, works faster, and is defined as a standard. You can read
    more about this at [https://tools.ietf.org/html/rfc7049](https://tools.ietf.org/html/rfc7049).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**CBOR**是一种基于JSON的二进制数据序列化格式。它更紧凑，支持二进制字符串，运行速度更快，并被定义为标准。您可以在[https://tools.ietf.org/html/rfc7049](https://tools.ietf.org/html/rfc7049)上了解更多信息。'
- en: Different formats
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的格式
- en: 'We need two extra crates: `queryst` for parsing parameters from the query string,
    and the `serde_cbor` crate to support the CBOR serialization format. Add these
    to your `Cargo.toml`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个额外的包：`queryst`用于从查询字符串中解析参数，以及支持CBOR序列化格式的`serde_cbor`包。将这些添加到您的`Cargo.toml`中：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, import them in `main.rs`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`main.rs`中导入它们：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead of using `serde_json::to_string` directly in the handler, we''ll move
    it to a separate function that serializes data depending on the expected format:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在处理程序中直接使用`serde_json::to_string`，而是将其移动到一个单独的函数中，该函数根据预期的格式序列化数据：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this code, we used a match expression to detect a format. Significantly,
    we changed the `String` result to a binary type, `Vec<u8>`. We also used `failure::Error`
    as an error type, because both `serde_json` and `serde_cbor` have their own error
    types and we can convert them to a generic error using the `?` operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了一个匹配表达式来检测格式。值得注意的是，我们将`String`结果更改为二进制类型`Vec<u8>`。我们还使用了`failure::Error`作为错误类型，因为`serde_json`和`serde_cbor`都有自己的错误类型，我们可以使用`?`运算符将它们转换为通用错误。
- en: If the provided format is unknown, we can construct an `Error` with the `format_err!`
    macro of the `failure` crate. This macro works like the `println!` function, but
    it creates a generic error based on a string value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的格式未知，我们可以使用`failure`包的`format_err!`宏构建一个`Error`。这个宏就像`println!`函数一样工作，但它基于字符串值创建一个通用错误。
- en: We also changed the `Error` type in import section. Previously, it was the `hyper::Error`
    type from the `hyper` crate, but we'll now use the `failure::Error` type instead
    and use a crate name prefix for errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在导入部分更改了`Error`类型。之前它是来自`hyper`包的`hyper::Error`类型，但现在我们将使用`failure::Error`类型，并为错误使用包名前缀。
- en: Parsing a query
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析查询
- en: 'The HTTP URI can contain a query string with parameters that we can use to
    tune a request. The `Request` type has a method, `uri`, which returns a query
    string if it''s available. We added the `queryst` crate, which parses a query
    string to `serde_json::Value`. We''ll use this value to extract the `"format"`
    parameters from the query string. If the format isn''t provided, we''ll use `"json"`
    as a default value. Add the format-extracting block to the branch that handles
    requests to the `/random` path and use the `serialize` function that we previously
    declared:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP URI可以包含一个查询字符串，其中包含我们可以用来调整请求的参数。`Request`类型有一个`uri`方法，如果可用，它返回一个查询字符串。我们添加了`queryst`包，它将查询字符串解析为`serde_json::Value`。我们将使用这个值从查询字符串中提取`"format"`参数。如果没有提供格式，我们将使用默认值`"json"`。将格式提取块添加到处理`/random`路径请求的分支中，并使用我们之前声明的`serialize`函数：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code extracts a format value from a query string, processes a request,
    and returns a serialized value using a chosen format.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从查询字符串中提取格式值，处理请求，并使用所选格式返回序列化值。
- en: Checking different formats
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查不同的格式
- en: 'Compile the code, run it, and use `curl` to check the result. First, let''s
    check the traditional JSON format:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码，运行它，并使用`curl`检查结果。首先，让我们检查传统的JSON格式：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will return a JSON response that we''ve seen before: `{"value":-19.0}`.
    The next request will return a CBOR value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回我们之前看到的JSON响应：`{"value":-19.0}`。下一个请求将返回一个CBOR值：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command won''t print a response to the console, because it''s in binary
    format. You''ll see the following warning message:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令不会在控制台打印响应，因为它是以二进制格式。您将看到以下警告消息：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s try to request a response in XML format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以XML格式请求一个响应：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This has worked correctly; it printed `unsupported format xml` to indicate that
    it doesn't support XML format. Let's now move on to discussing transcoding `serde`
    values and looking at why XML isn't a format that's widely supported by `serde`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经正确工作；它打印了`unsupported format xml`来指示它不支持XML格式。现在让我们继续讨论`serde`值的转码，并看看为什么XML不是`serde`广泛支持的格式。
- en: Transcoding
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转码
- en: 'Sometimes, you''ll be faced with situations in which you need to convert one
    format to another. In this instance, you can use the `serde_transcode` crate,
    which converts one format to another using a standard `serde` serialization process.
    The crate has a `transcode` function that expects a `serializer` and a `deserializer`
    as arguments. You can use it as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到需要将一种格式转换为另一种格式的情况。在这种情况下，你可以使用`serde_transcode` crate，它通过标准的`serde`序列化过程将一种格式转换为另一种格式。该crate有一个`transcode`函数，它期望一个`serializer`和一个`deserializer`作为参数。你可以如下使用它：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code converts incoming JSON data into CBOR data. You can read more about
    this crate at: [https://crates.io/crates/serde-transcode](https://crates.io/crates/serde-transcode).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将传入的JSON数据转换为CBOR数据。你可以在以下链接中了解更多关于此crate的信息：[https://crates.io/crates/serde-transcode](https://crates.io/crates/serde-transcode)。
- en: XML support
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML支持
- en: '`serde` doesn''t provide very good support for XML. The main reason for this
    is the complexity of the format. It has so many rules and exceptions that you
    can''t describe the expected format in a simple form. However, there are also
    some implementations that aren''t compatible with `serde`. The following links
    explain streaming, reading, and writing XML data: [https://crates.io/crates/xml-rs](https://crates.io/crates/xml-rs)
    and [https://crates.io/crates/quick-xml](https://crates.io/crates/quick-xml).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde`对XML的支持并不很好。主要原因在于格式的复杂性。它有如此多的规则和例外，以至于你不能用简单形式描述预期的格式。然而，也有一些实现与`serde`不兼容。以下链接解释了流式传输、读取和写入XML数据：[https://crates.io/crates/xml-rs](https://crates.io/crates/xml-rs)和[https://crates.io/crates/quick-xml](https://crates.io/crates/quick-xml)。'
- en: 'Another format that isn''t compatible with the `serde` infrastructure is Protocol
    Buffers ([https://developers.google.com/protocol-buffers/](https://crates.io/crates/protobuf)).
    Developers often choose this format for performance reasons and to use one scheme
    of data for different applications. To use this format in Rust code, try to use
    the `protobuf` crate: [https://crates.io/crates/protobuf](https://crates.io/crates/protobuf).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种与`serde`基础设施不兼容的格式是Protocol Buffers ([https://developers.google.com/protocol-buffers/](https://crates.io/crates/protobuf))。开发者经常出于性能原因和为了在不同应用程序中使用一个数据方案而选择此格式。要在Rust代码中使用此格式，请尝试使用`protobuf`
    crate：[https://crates.io/crates/protobuf](https://crates.io/crates/protobuf)。
- en: 'In my opinion, it''s better to use a format that''s compatible with the `serde`
    crate in Rust for the following reasons:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，出于以下原因，最好使用与Rust中的`serde`crate兼容的格式：
- en: It's simpler to use in a code.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中使用它更简单。
- en: Structs don't need a scheme, because they're strict.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不需要方案，因为它们是严格的。
- en: You can use a separated crate with a determined protocol.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个具有确定协议的独立crate。
- en: The only situation in which you shouldn't follow the `serde` approach is if
    you have to support a format that isn't compatible with `serde`, but has been
    used in existing services or clients.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该遵循`serde`方法的唯一情况是，如果你必须支持一个与`serde`不兼容的格式，但已在现有服务或客户端中使用。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed serialization and deserialization processes using
    the `serde` crate. We looked at how `serde` supports multiple formats and can automatically derive
    `Serialize` and `Deserialize` implementations for structs or enumerations. We
    implemented a service that generates random numbers from incoming parameters serialized
    in JSON format.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用`serde`crate进行序列化和反序列化过程。我们探讨了`serde`如何支持多种格式，并可以自动为结构体或枚举派生`Serialize`和`Deserialize`实现。我们实现了一个服务，该服务从以JSON格式序列化的传入参数生成随机数。
- en: After that, you learned how to implement these traits yourself and add extra
    features to shuffle an array or to generate a random color. Finally, we discussed
    how to support multiple formats in one handler.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你学习了如何自己实现这些特性，并为洗牌数组或生成随机颜色添加额外功能。最后，我们讨论了如何在单个处理器中支持多种格式。
- en: In the next chapter, you'll learn how to use full potential of asynchronous
    code, and write microservices with Rust that can handle thousands of clients simultaneously.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用异步代码的完整潜力，并用Rust编写可以同时处理数千个客户端的微服务。
