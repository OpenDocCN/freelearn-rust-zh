- en: Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出
- en: Up to this point, we've only seen data coming from our examples, and then only
    using the `println!` macro function. While the `println!` macro is very useful,
    we really need to look at output. We also need to know how to get data in, and
    once the data is in, we have to check that the type entered is the type required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了来自我们示例的数据，并且只使用了 `println!` 宏函数。虽然 `println!` 宏非常有用，但我们真的需要查看输出。我们还需要知道如何获取数据，一旦数据进入，我们必须检查输入的类型是否是所需的类型。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Examining ways of outputting data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输出数据的方式
- en: Examining how to get data into an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查如何将数据输入到应用程序中
- en: Starting your program with command-line arguments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数启动程序
- en: Discussing how a method in Rust is different from a method in other languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Rust中的方法与其他语言中的方法的不同之处
- en: A brief introduction to the standard library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库的简要介绍
- en: Functions and methods in Rust
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的函数和方法
- en: 'When we look at C++ or C#, a method is a programming unit within a class that
    does a specific task. A method in Rust is a function attached to compound data
    structures, or structs. These methods have access to the data of the object using
    the self parameter. They are defined in an `impl` block, as shown in the following
    example (a fuller example is given in the source examples):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看C++或C#时，方法是一个类内的编程单元，它执行特定的任务。Rust中的方法是与复合数据结构或结构体相关联的函数。这些方法通过使用 `self`
    参数来访问对象的数据。它们在 `impl` 块中定义，如下面的示例所示（更完整的示例可以在源示例中找到）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we defined a struct, `Point`, for points in 2D space. Then, we defined
    two constructor methods for that struct: origin for making a new point in location
    `0`,`0` and another for making a new arbitrary point.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `Point` 的结构体，用于表示二维空间中的点。然后，我们为该结构体定义了两个构造方法：`origin` 用于创建位置在
    `0`,`0` 的新点，另一个用于创建任意新点。
- en: The difference between println! and println
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: println! 和 println 之间的区别
- en: Up to this point, we've used `println!` for outputting text. This is fine, but
    consider what `println!` does. Whenever you see a `!` mark, it symbolizes a macro.
    Macros are used when some part of the function needs to be executed at compile
    time, rather than at runtime.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 `println!` 来输出文本。这是可以的，但考虑一下 `println!` 做了什么。每次你看到 `!` 标记时，它都象征着宏。宏用于在编译时而不是在运行时执行函数的一部分。
- en: 'Consider the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `println!` macro is actually implemented in the Rust standard library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 宏实际上是在Rust标准库中实现的。'
- en: Introduction to the standard library
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库简介
- en: 'To be able to understand where `println!` comes from, we need to take a brief
    look at the Rust Standard Library. If you''re familiar with C, C++, or C# (or
    any of the other languages commonly used), you''ll have used something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `println!` 的来源，我们需要简要地看一下Rust标准库。如果你熟悉C、C++或C#（或任何其他常用语言），你可能会用到类似的东西：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are standard libraries that the compiler comes with, and which the developer
    can optionally include. They contain many useful procedures, functions, and methods,
    all designed to make development simpler so that you don't need to keep reinventing
    the wheel when you need to do a common task.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编译器附带的标准库，开发者可以选择性地包含。它们包含许多有用的过程、函数和方法，所有这些都是为了使开发更简单，这样你就不需要在需要执行常见任务时不断重新发明轮子。
- en: A similar system exists in Rust in the form of crates. The std crate contains
    the Rust Standard Library, and it is by default included in every other crate.
    This means that you can use functionality from there without extra steps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，类似的系统以crate的形式存在。std crate 包含Rust标准库，并且默认包含在所有其他crate中。这意味着你可以使用那里的功能，而无需额外步骤。
- en: The crates are further separated into module hierarchies, with a double colon
    `::` being a separator for the paths. So, for example, `std::fmt` is the `fmt`
    module inside the `std` module. It contains string formatting and printing functionality.
    For instance, the `println!` macro that we have used already is there.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子被进一步分为模块层次结构，其中双冒号 `::` 是路径的分隔符。例如，`std::fmt` 是 `std` 模块内的 `fmt` 模块。它包含字符串格式化和打印功能。例如，我们之前已经使用过的
    `println!` 宏就在那里。
- en: So why don't we have to write `std::fmt::println!` every time we use the `println!`
    macro? Because `println!` is one of the many standard macros which are imported
    to every namespace automatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们每次使用 `println!` 宏时都不需要写 `std::fmt::println!` 呢？因为 `println!` 是许多自动导入到每个命名空间的标准宏之一。
- en: 'You can also import things to the current namespace yourself, to save yourself
    some keystrokes. This is done by the use keyword. Here''s an example that uses
    the `HashMap` collection type from the standard library, without using the use
    keyword:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以自己将事物导入当前命名空间，以节省一些按键。这是通过使用关键字完成的。以下是一个使用标准库中的 `HashMap` 集合类型的示例，而不使用使用关键字：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Spelling out the full namespace explicitly every time is possible, but as you
    can see, the noise-to-signal ratio is a bit poorer. Importing the `HashMap` into
    the current namespace can help. This piece of code is equivalent to the previous:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都明确地拼写完整的命名空间是可能的，但如您所见，噪声与信号比略低。将 `HashMap` 导入当前命名空间可以有所帮助。这段代码与之前的代码等价：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Rust''s library system is a bit different from other languages, and may therefore
    be a bit of a stumbling block for newcomers. I found it a useful tidbit to realize
    that use clauses are not required to make code visible and callable: they just
    import a namespace into the current namespace.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的库系统与其他语言略有不同，因此可能对新手来说是一个绊脚石。我发现意识到使用子句不是使代码可见和可调用的必要条件是有用的：它们只是将命名空间导入到当前命名空间中。
- en: The libraries
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: The `std` libraries define the primitives we have already encountered (`array`,
    different sized floats and integers, `String`, and so on), but also contain a
    number of other modules. They also define the commonly used macros (such as `write!`
    and `println!`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`std` 库定义了我们已经遇到的原始类型（`array`、不同大小的浮点数和整数、`String` 等），但也包含了许多其他模块。它们还定义了常用的宏（如
    `write!` 和 `println!`）。'
- en: For the purposes of this chapter, we will cover only `std::io`, `std::fs,` and
    `std::fmt`. These deal with input/output, the filesystem, and formatting. The
    `io` and `fs` modules will be dealt with later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将仅涵盖 `std::io`、`std::fs` 和 `std::fmt`。这些模块涉及输入/输出、文件系统和格式化。`io` 和
    `fs` 模块将在本章后面讨论。
- en: Controlling the output formatting
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制输出格式
- en: The `std::fmt` module provides the developer with a range of utilities for formatting
    and printing strings. Let's start with the `format!` macro. This macro returns
    a string.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::fmt` 模块为开发者提供了一系列用于格式化和打印字符串的实用工具。让我们从 `format!` 宏开始。这个宏返回一个字符串。'
- en: We have seen that if we use `println!`(`Hello {}`, `myString`), the code will
    print the contents of `myString` after the `Hello`. The `format!` macro works
    pretty much the same, just that it returns the formatted string instead of outputting
    it. In fact, `println!` essentially uses `format!` itself under the hood.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果我们使用 `println!`(`Hello {}`, `myString`)，代码将在 `Hello` 后打印 `myString`
    的内容。`format!` 宏的工作方式几乎相同，只是它返回格式化的字符串而不是输出它。实际上，`println!` 在底层本质上使用 `format!`。
- en: Positioning the output
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位输出
- en: 'One of the more useful extensions in C# is `string.Format(...);.` This allows
    for a string to be constructed based on parameters at particular positions. For
    example, the following statement constructs a string where the parameter at a
    position after the string literal is inserted into the string (here, the letter
    `B` is inserted twice in the middle of the string and then at the end):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，更有用的扩展之一是 `string.Format(...);`。这允许根据特定位置的参数构建字符串。例如，以下语句构建了一个字符串，其中字符串字面量之后的参数位置被插入到字符串中（在这里，字母
    `B` 在字符串中间和末尾各插入了一次）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rust also supports this form, but with the difference that the positioning may
    be omitted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 也支持这种形式，但不同之处在于可以省略位置。
- en: 'Consider the following examples:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first example is what we've seen before. The format string gets filled with
    the parameters on the right, in order.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是我们之前看到的。格式字符串按顺序填充右侧的参数。
- en: 'In the second example, it would seem that we''re asking for four parameters,
    but have only supplied two. The way this works is that the positional arguments
    are ignored when filling in the non-positional arguments. Indexing, as is usual
    in programming, starts at zero. This is how the arguments are processed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，看起来我们要求四个参数，但实际上只提供了两个。这种方式是，当填充非位置参数时，会忽略位置参数。在编程中，索引通常从零开始。这就是处理参数的方式：
- en: '`{1}` inserts the second parameter `A`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{1}` 插入第二个参数 `A`'
- en: '`{}` inserts the first parameter `B`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`插入第一个参数`B`'
- en: '`{0}` inserts the first parameter `B`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0}`插入第一个参数`B`'
- en: '`{}` inserts the second parameter `A`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`插入第二个参数`A`'
- en: Therefore, the output is going to be A B B A.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出将是A B B A。
- en: 'The following are the two important rules governing the positional parameters:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对位置参数的两个重要规则：
- en: All of the arguments within the quotes must be used. Failure to do so will result
    in a compiler error.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引号内的所有参数都必须使用。未能这样做将导致编译器错误。
- en: You can refer to the same argument as many times as you like within the format
    string.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在格式化字符串中多次引用相同的参数。
- en: Named parameters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数
- en: As shown in the formatting table, it is possible to use a named parameter. The
    operation of these is similar to a positional parameter; the difference, though,
    is that a named parameter is used. This is very useful in ensuring that the value
    output in the string is the correct parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如格式化表所示，可以使用命名参数。这些参数的操作类似于位置参数；不过，区别在于使用的是命名参数。这在确保字符串中输出的值是正确的参数方面非常有用。
- en: 'It is perfectly acceptable to use an empty parameter within a formatted string
    when using a named parameter, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命名参数时，在格式化字符串中使用空参数是完全可接受的，例如：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The rules for handling non-positional parameters alongside named parameters
    are similar to the rules for positional parameters: the named parameters are ignored
    when figuring out the positions. This will, therefore, give the output B a B 33.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理非位置参数与命名参数的规则与位置参数的规则相似：在确定位置时忽略命名参数。因此，输出将是B a B 33。
- en: Specifying the argument types
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定参数类型
- en: As with much of the string handling in the C family of languages, it is possible
    to create a string based on a format string (for example, `{0:##.###}` would give
    a formatted output of the form xy.abc).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与C家族语言中的许多字符串处理一样，可以根据格式化字符串创建字符串（例如，`{0:##.###}`将给出形式为xy.abc的格式化输出）。
- en: 'Similar things can be done in Rust, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中也可以做类似的事情，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the format string, the colon says we're requesting formatting for the value.
    Dot and `3` says that we want the number formatted to three decimal points. The
    formatter rounds the value for us, so the output will be 3.142.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化字符串中，冒号表示我们正在请求对值的格式化。点号和数字`3`表示我们希望将数字格式化为三位小数。格式化器会为我们四舍五入值，因此输出将是3.142。
- en: Formatting traits
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化特性
- en: 'Formatting traits determine how the output of the format will be produced.
    They are all used in the same way: `{:trait_name}.`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化特性决定了格式化输出的生成方式。它们都以相同的方式进行使用：`{:trait_name}.`
- en: 'The following are the current traits available:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是目前可用的特性：
- en: '| **Format string** | **Trait** | **Meaning** | **Example** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **格式化字符串** | **特性** | **含义** | **示例** |'
- en: '| `{}` | Display | A human-readable representation. Not all things implement
    Display. | 123 => "123" |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `{}` | 显示 | 人类可读表示。并非所有事物都实现了Display。 | 123 => "123" |'
- en: '| `{:?}` | Debug | An internal representation. Almost everything implements
    Debug. | b"123" => [49, 50, 51] |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `{:?}` | Debug | 内部表示。几乎一切事物都实现了Debug。 | b"123" => [49, 50, 51] |'
- en: '| `{:b}` | Binary | Converts a number into binary | 123 => "1111011" |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `{:b}` | Binary | 将数字转换为二进制 | 123 => "1111011" |'
- en: '| `{:x}` | LowerHex | Hex in lowercase | 123 => 7b |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `{:x}` | LowerHex | 小写十六进制 | 123 => 7b |'
- en: '| `{:X}` | UpperHex | Hex in uppercase | 123 => 7B |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `{:X}` | UpperHex | 大写十六进制 | 123 => 7B |'
- en: '| `{:e}` | LowerExp | Number with exponential, lowercase | 123.0 => 1.23e2
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `{:e}` | LowerExp | 带有指数的小写数字 | 123.0 => 1.23e2 |'
- en: '| `{:E}` | UpperExp | Number with exponential, uppercase | 123.0 => 1.23E2
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `{:E}` | UpperExp | 带有指数的上标数字 | 123.0 => 1.23E2 |'
- en: '| `{:p}` | Pointer | Pointer location | &123 => 0x55b3fbe72980 (may point to
    a different address on every run) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `{:p}` | 指针 | 指针位置 | &123 => 0x55b3fbe72980（每次运行可能指向不同的地址） |'
- en: Similarly, the output can be formatted with formatting parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，输出也可以使用格式化参数进行格式化。
- en: Formatting parameters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化参数
- en: 'There are essentially four formatting parameters available. They are listed
    in the following table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有四个可用的格式化参数。它们列在下面的表中：
- en: '| **Parameter** | **Use** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **用途** |'
- en: '| `Fill`/`Alignment` | Used in conjunction with the `Width` parameter. Essentially,
    this will add extra characters if the output is smaller than the width. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Fill`/`Alignment` | 与`Width`参数一起使用。基本上，如果输出小于宽度，这将添加额外的字符。 |'
- en: '| `Sign`/`#`/`0` | Flags for the formatter being used:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Sign`/`#`/`0` | 格式化器使用的标志：'
- en: '`Sign` indicates that the sign should always be outputted (numeric values only).
    If the value is positive, the `+` sign will never show; similarly, a `-` will
    only show for a `Signed` value.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*#*` indicates that an alternate form of printing will be used. Normally,
    if `{:x}` is used, the lowercase hex format is used. By using `#x`, the argument
    is preceded with `0x`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` is used to pad a result with the `0` character. It is sign-aware.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| `Width` | Specifies how the output should be represented. For example, if
    you have a float calculation that has to be outputted to four decimal places,
    and the result only comes to two decimal places, the width formatter (in conjunction
    with the fill formatting parameter) will create the required filled output. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `Precision` | For anything non-numeric, the precision is the maximum width.
    For example, if you have a maximum width of five and a string containing eight
    characters, it will be truncated after five characters. It is ignored for integers.
    For floating point types, it indicates the number of decimal points after the
    point:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer `.N:`: In this case, `N` is the precision.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integer followed by a `$ (.N$:)`: This uses the format argument `N` as the
    precision. The argument must be a `usize`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.*:`: This means that the contents of the `{}` is associated with two format
    inputs. The first holds the `usize` precision, the second holds the value to be
    printed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Examples of all of these formatters are in the source code examples for this
    chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Getting information in
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have concentrated on getting information out from a Rust
    program rather than entering information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Input is done via the `std::io` module, getting a reader using the `io::stdin()`
    function, and then calling `read_line` on that reader. We put the inputted data
    into a dynamically growing `String`, which needs to be mutable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example for inputting would look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see Rust's error handling in action in the previous code. The `read_line`
    method returns a result type, which means that the operation could have failed.
    The result type encapsulates two generic types inside itself, which in the case
    of `read_line` are `usize` (for reporting how many bytes were read in) and `io::Error`
    (for reporting any errors during input). The actual read String is placed in the
    first argument of the function, in this case `input_text`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: On that result type, our example calls the `expect` method. It expects that
    everything went fine, and returns the first value (the `usize` in this case).
    If there were errors, the `expect` method prints reading failed to the standard
    output and exits the program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to handle result types, but it's a common one in cases
    where we expect things to usually work out fine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to handle the error is to explicitly call the `is_err` method on
    the result. It returns a boolean, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we wish to further parse the entry into another type, we can use the `parse`
    method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we''d like to get an `i32` from the input. The `read_line`
    method includes a carriage return in the input data, so we need to get rid of
    that using the `trim` method before parsing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从输入中获取一个`i32`。`read_line`方法在输入数据中包含一个回车符，因此我们需要在解析之前使用`trim`方法将其去除：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the sake of this example, this final line converts the result type into
    an `Option` using the `ok` method. Option is a simplified version of result. This
    is a useful library and it can have one of two results: `Some` or `None`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个示例，最后一行使用`ok`方法将结果类型转换为`Option`。`Option`是结果的简化版本。这是一个有用的库，它可以有两种结果：`Some`或`None`。
- en: 'Here, if the entry result is `None`, the value is not an integer, whereas `Some`
    would be an integer:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果条目结果是`None`，则值不是整数，而`Some`将是一个整数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Command-line arguments
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数
- en: 'When a program is started, it can be started with or without arguments. These
    arguments are normally fed in as parameters when the program is called. A simple
    example of this is starting the manual application (found on many BSD and Linux
    machines):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，它可以带参数或不带参数启动。这些参数通常在调用程序时作为参数传入。一个简单的例子是启动手册应用（在许多BSD和Linux机器上都可以找到）：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding statement, `man` is the name of the program or script to be
    called with the argument `ffmpeg`. Similarly, take a look at the following example
    for Windows users:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，`man`是要调用带有`ffmpeg`参数的程序或脚本的名称。类似地，看看以下针对Windows用户的示例：
- en: '![](img/00028.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: '`Notepad` is the program name with the first argument being the file to read
    in (in this example, the file doesn''t exist, so the UI asks if you wish to create
    it).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`记事本`是程序名称，第一个参数是要读取的文件（在这个例子中，文件不存在，因此UI询问是否要创建它）。'
- en: It is not uncommon for one program to load another program to perform a task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序加载另一个程序以执行任务的情况并不少见。
- en: 'In C, the parameter list for main is given as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，`main`的参数列表如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`argc` is the maximum number of arguments with `argv` holding the arguments.
    Here, the program name is `argv[0]`, so all additional arguments start at 1.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`argc`是`argv`中参数的最大数量，其中`argv`持有参数。在这里，程序名称是`argv[0]`，所以所有附加参数从1开始。'
- en: Rust's `main` takes no arguments like this. Command-line parameters are available
    through the standard library `std::env::args` (environment arguments). For simplicity,
    it is convenient to store the arguments in `Vec<String>`, because `env::args`
    returns an iterator that yields a `String`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的`main`不接收这样的参数。命令行参数可以通过标准库`std::env::args`（环境参数）获得。为了简单起见，将参数存储在`Vec<String>`中是很方便的，因为`env::args`返回一个迭代器，它产生一个`String`。
- en: 'No parameters are passed into `main` directly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将参数传递给`main`的情况并不少见：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `collect` method converts the iterator into a vector, making it possible
    to access it by indexing. Without it, we would have to go through the arguments
    one by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect`方法将迭代器转换为向量，使得可以通过索引访问它。没有它，我们就必须逐个处理参数。'
- en: Handling files
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理
- en: The final part of our tour of getting information in and out of a program is
    using files. As far as Rust is concerned, a file is just another stream, with
    the exception that this stream goes elsewhere.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对程序内外获取信息的巡视的最后一部分是使用文件。就Rust而言，文件只是另一个流，只是这个流去往别处。
- en: It is important when using anything to do with files that the `try!` macro is
    used to trap all errors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用与文件相关的任何东西时，使用`try!`宏来捕获所有错误是很重要的。
- en: Reading from a file
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: Here, we are going to use `std::io`, `std::io::prelude::*` and `std::fs::File`.
    `std::io` is the standard input/output library, the `*` after prelude means to
    use anything in the prelude library, and `std::fs` is the filesystem library.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`std::io`、`std::io::prelude::*`和`std::fs::File`。`std::io`是标准输入/输出库，`prelude`后的`*`表示使用预定义库中的任何内容，而`std::fs`是文件系统库。
- en: Filesystem calls are very platform-specific; Windows users use the likes of
    `C://Users/Paul/Documents/My Documents` for the user's home directory, whereas
    Linux and macOS machines would use `~/` for the user's home directory. If a path
    is not given for a file, the program will assume the file is in the same directory
    in which the binary resides.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统调用非常特定于平台；Windows用户使用类似`C://Users/Paul/Documents/My Documents`的路径作为用户的主目录，而Linux和macOS机器会使用`~/`作为用户的主目录。如果没有为文件指定路径，程序将假定文件位于二进制所在的同一目录中。
- en: Loading a file
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载文件
- en: 'To open a file, we use `File::open(filename)`. We can catch exceptions using
    the `try!` macro or `match`, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开文件，我们使用`File::open(filename)`。我们可以使用`try!`宏或`match`来捕获异常，如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or the following can be used:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以使用以下方法：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the file is available to open, `File::open` will grant read permissions
    to the file. To load the file, we create a `BufReader` based on the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件可以打开，`File::open`将授予文件读取权限。为了加载文件，我们基于文件创建一个`BufReader`：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the file has been read, the stream can be explicitly closed with `reader.close()`.
    However, Rust's resource management system guarantees that the file will be closed
    when its binding goes out of scope, so this is not mandatory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被读取，可以通过`reader.close()`显式关闭流。然而，Rust的资源管理系统保证了当其绑定超出作用域时文件将被关闭，所以这不是强制的。
- en: Writing a file
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'Writing to a file is a two-step process: opening the file (possibly creating
    it if it didn''t exist before) and then the writing of the file. This is very
    similar to how writing to a file in the C family of languages is carried out.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件是一个两步过程：打开文件（如果之前不存在，则可能创建它）然后写入文件。这与C系列语言中写入文件的方式非常相似。
- en: You can create a file for writing in a single call to `std::fs::File::create`.
    The `open` method in the same namespace opens a file for reading. If you need
    more fine-tuned permissions, `std::fs::OpenOptions::new` creates an object through
    which you can tweak the parameters and then open the file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对`std::fs::File::create`的单次调用来创建一个用于写入的文件。同一命名空间中的`open`方法用于打开文件进行读取。如果你需要更精细的权限，`std::fs::OpenOptions::new`创建一个对象，通过它可以调整参数然后打开文件。
- en: 'As with any file operation, anything could fail, so the result should always
    be checked:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何文件操作一样，任何操作都可能失败，因此应该始终检查结果：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As mentioned before, Rust uses a generic type, `Result<T,U>` , quite frequently
    as an error-trapping mechanism. It encapsulates two values: the left-hand side
    value is used when the operation succeeds, and the right-hand side value is used
    when it does not succeed.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Rust经常使用泛型类型`Result<T,U>`作为错误捕获机制。它封装了两个值：当操作成功时使用左侧的值，当操作不成功时使用右侧的值。
- en: Once we have completed the file creation, we can move on to writing to the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成文件创建，我们就可以继续写入文件。
- en: 'First, we check the results of the `Result` comparison. If an error hasn''t
    been thrown there was no error, and we can then create a `BufWriter`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`Result`比较的结果。如果没有抛出错误，则表示没有错误，然后我们可以创建一个`BufWriter`：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don't need to flush the buffer, as `write_all` will do that for us (it calls
    `flush()` once completed). If you don't use `write_all`, then you need to call
    `flush()` to ensure the buffer is cleared.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要刷新缓冲区，因为`write_all`会为我们完成这个操作（它会在完成后调用`flush()`）。如果你不使用`write_all`，那么你需要调用`flush()`以确保缓冲区被清除。
- en: The use of expect
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`expect`的使用'
- en: Rust contains a very useful function called `expect`. This method is used with
    any form of call that has an `Option` or a `Result` type (for example, `Result`
    in the file-writing example has the options of `File` or `Error`). It works by
    moving the value out of the option and returning it. If the `option`/`result`
    type contains an error, the `expect` call stops your program and prints out the
    error message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Rust包含一个非常有用的函数`expect`。此方法与任何具有`Option`或`Result`类型（例如，文件写入示例中的`Result`）的调用一起使用。它通过将值从选项中移出并返回它来工作。如果`option`/`result`类型包含错误，`expect`调用将停止你的程序并打印出错误信息。
- en: 'For example, the following statement will return either `File` or `Error` into `file`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下语句将返回`File`或`Error`到`file`中：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A shorter form is available in the `unwrap` method. This is the same as the
    `expect` method, but it doesn't print out anything in case of a failure. In general,
    `Some(a).unwrap()` will return `a`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`unwrap`方法中有一个简短的形式。这与`expect`方法相同，但在失败的情况下不会打印任何内容。一般来说，`Some(a).unwrap()`将返回`a`。
- en: '`Expect` is usually favored instead of `unwrap`, since the full error message
    makes it easier to find where the error came from.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常更喜欢使用`expect`而不是`unwrap`，因为完整的错误信息使得更容易找到错误来源。
- en: XML and Rust
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML和Rust
- en: As Rust is well suited to running on servers, it seems appropriate that we consider
    XML, and how it is handled within Rust.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rust非常适合在服务器上运行，因此考虑XML以及它在Rust中的处理似乎是合适的。
- en: Thankfully, Rust comes with a crate called `Xml`, which works in a way similar
    to how standard streams are read and written.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Rust自带一个名为`Xml`的crate，其工作方式与标准流读写类似。
- en: Reading a file
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'As with a standard file, we first have to open the file and create a reader:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准文件一样，我们首先需要打开文件并创建一个读取器：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we start the reading. Unlike a normal reader, we use `EventReader`. This
    provides a number of events (such as `StartElement`, `EndElement,` and `Error`),
    which are required for reading in from the differing nodes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始读取。与普通读取器不同，我们使用`EventReader`。这提供了一系列事件（如`StartElement`、`EndElement`和`Error`），这些事件对于从不同节点读取是必需的：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we iterate through the file, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下方式遍历文件：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We aren't going to use the iterator; we just need something to enable the iteration
    to go to the next value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用迭代器；我们只需要一些东西来使迭代能够跳到下一个值。
- en: Writing a file
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: Writing an XML file is far more complex than reading. Here, we have to explicitly
    use `XmlEvent` and `EventWriter`. We also use `EmitterConfig,` which does as the
    name suggests, that is, creates a configuration and then uses it. `EventWriter`,
    `EmitterConfig,` and `XmlEvent` are all part of `xml::writer`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 编写XML文件比读取复杂得多。在这里，我们必须显式使用`XmlEvent`和`EventWriter`。我们还使用`EmitterConfig`，正如其名称所暗示的，即创建一个配置然后使用它。`EventWriter`、`EmitterConfig`和`XmlEvent`都是`xml::writer`的一部分。
- en: 'Let us first consider the main function. First, create the file and two references,
    one to `stdin` and one to `stdout`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑主函数。首先，创建文件和两个引用，一个指向`stdin`，一个指向`stdout`，如下所示：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we create the writer via `EmitterConfig:`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`EmitterConfig`创建写入器：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now have the writer set up. `perform_indent` tells the writer to indent each
    node when true.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了写入器。`perform_indent`告诉写入器当为真时对每个节点进行缩进。
- en: 'Finally, we create a loop and write the XML. You will notice a call to `handle_event`;
    we will deal with this shortly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个循环并写入XML。你会注意到一个对`handle_event`的调用；我们很快就会处理这个问题：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The definition of the function `handle_event` is a bit more advanced than we
    have seen until now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`handle_event`的定义比我们之前看到的要复杂一些：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In C#, the preceding definition would be something similar, and would be written
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，前面的定义将类似，并且会写成如下所示：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We pass a type (be it a `class`, `string`, `i32,` or anything else for that
    matter) to the function to use as a parameter. In this case, we are using `std::io::Write`
    for the `EventWriter` to use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个类型（无论是`class`、`string`、`i32`还是其他任何类型）传递给函数作为参数。在这种情况下，我们使用`std::io::Write`作为`EventWriter`使用的参数。
- en: 'The function itself has nothing special. We start by trimming the string to
    remove any whitespace or returns:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身没有什么特别之处。我们首先通过修剪字符串来移除任何空白或回车：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now use `XmlEvent` to generate the code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`XmlEvent`来生成代码：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`into()` converts the pointer to the structure (known as `self`). In this case,
    it takes (say) `XmlEvent::characters(&line),` and sends it back into the line.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`into()`将指针转换为结构（称为`self`）。在这种情况下，它接受（比如说）`XmlEvent::characters(&line)`，并将其发送回行中。'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have covered quite a lot of material in this chapter, and you should feel
    more at home with handling strings, XML, and files, which can be used to add further
    functionality to your code. Please feel free to examine the examples supplied
    for this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了相当多的内容，你应该对处理字符串、XML和文件感到更加熟悉，这些都可以用来为你的代码添加更多功能。请随时检查本章提供的示例。
- en: In the next chapter, we will have a look at loops, recursion, and branching.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨循环、递归和分支。
