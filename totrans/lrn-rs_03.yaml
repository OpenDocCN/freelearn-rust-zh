- en: Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we've only seen data coming from our examples, and then only
    using the `println!` macro function. While the `println!` macro is very useful,
    we really need to look at output. We also need to know how to get data in, and
    once the data is in, we have to check that the type entered is the type required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining ways of outputting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining how to get data into an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting your program with command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how a method in Rust is different from a method in other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and methods in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we look at C++ or C#, a method is a programming unit within a class that
    does a specific task. A method in Rust is a function attached to compound data
    structures, or structs. These methods have access to the data of the object using
    the self parameter. They are defined in an `impl` block, as shown in the following
    example (a fuller example is given in the source examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a struct, `Point`, for points in 2D space. Then, we defined
    two constructor methods for that struct: origin for making a new point in location
    `0`,`0` and another for making a new arbitrary point.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between println! and println
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we've used `println!` for outputting text. This is fine, but
    consider what `println!` does. Whenever you see a `!` mark, it symbolizes a macro.
    Macros are used when some part of the function needs to be executed at compile
    time, rather than at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `println!` macro is actually implemented in the Rust standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to understand where `println!` comes from, we need to take a brief
    look at the Rust Standard Library. If you''re familiar with C, C++, or C# (or
    any of the other languages commonly used), you''ll have used something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These are standard libraries that the compiler comes with, and which the developer
    can optionally include. They contain many useful procedures, functions, and methods,
    all designed to make development simpler so that you don't need to keep reinventing
    the wheel when you need to do a common task.
  prefs: []
  type: TYPE_NORMAL
- en: A similar system exists in Rust in the form of crates. The std crate contains
    the Rust Standard Library, and it is by default included in every other crate.
    This means that you can use functionality from there without extra steps.
  prefs: []
  type: TYPE_NORMAL
- en: The crates are further separated into module hierarchies, with a double colon
    `::` being a separator for the paths. So, for example, `std::fmt` is the `fmt`
    module inside the `std` module. It contains string formatting and printing functionality.
    For instance, the `println!` macro that we have used already is there.
  prefs: []
  type: TYPE_NORMAL
- en: So why don't we have to write `std::fmt::println!` every time we use the `println!`
    macro? Because `println!` is one of the many standard macros which are imported
    to every namespace automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import things to the current namespace yourself, to save yourself
    some keystrokes. This is done by the use keyword. Here''s an example that uses
    the `HashMap` collection type from the standard library, without using the use
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Spelling out the full namespace explicitly every time is possible, but as you
    can see, the noise-to-signal ratio is a bit poorer. Importing the `HashMap` into
    the current namespace can help. This piece of code is equivalent to the previous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust''s library system is a bit different from other languages, and may therefore
    be a bit of a stumbling block for newcomers. I found it a useful tidbit to realize
    that use clauses are not required to make code visible and callable: they just
    import a namespace into the current namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: The libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std` libraries define the primitives we have already encountered (`array`,
    different sized floats and integers, `String`, and so on), but also contain a
    number of other modules. They also define the commonly used macros (such as `write!`
    and `println!`).
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will cover only `std::io`, `std::fs,` and
    `std::fmt`. These deal with input/output, the filesystem, and formatting. The
    `io` and `fs` modules will be dealt with later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the output formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::fmt` module provides the developer with a range of utilities for formatting
    and printing strings. Let's start with the `format!` macro. This macro returns
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that if we use `println!`(`Hello {}`, `myString`), the code will
    print the contents of `myString` after the `Hello`. The `format!` macro works
    pretty much the same, just that it returns the formatted string instead of outputting
    it. In fact, `println!` essentially uses `format!` itself under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more useful extensions in C# is `string.Format(...);.` This allows
    for a string to be constructed based on parameters at particular positions. For
    example, the following statement constructs a string where the parameter at a
    position after the string literal is inserted into the string (here, the letter
    `B` is inserted twice in the middle of the string and then at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Rust also supports this form, but with the difference that the positioning may
    be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first example is what we've seen before. The format string gets filled with
    the parameters on the right, in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, it would seem that we''re asking for four parameters,
    but have only supplied two. The way this works is that the positional arguments
    are ignored when filling in the non-positional arguments. Indexing, as is usual
    in programming, starts at zero. This is how the arguments are processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{1}` inserts the second parameter `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}` inserts the first parameter `B`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{0}` inserts the first parameter `B`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}` inserts the second parameter `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the output is going to be A B B A.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two important rules governing the positional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the arguments within the quotes must be used. Failure to do so will result
    in a compiler error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can refer to the same argument as many times as you like within the format
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the formatting table, it is possible to use a named parameter. The
    operation of these is similar to a positional parameter; the difference, though,
    is that a named parameter is used. This is very useful in ensuring that the value
    output in the string is the correct parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is perfectly acceptable to use an empty parameter within a formatted string
    when using a named parameter, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules for handling non-positional parameters alongside named parameters
    are similar to the rules for positional parameters: the named parameters are ignored
    when figuring out the positions. This will, therefore, give the output B a B 33.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the argument types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with much of the string handling in the C family of languages, it is possible
    to create a string based on a format string (for example, `{0:##.###}` would give
    a formatted output of the form xy.abc).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar things can be done in Rust, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the format string, the colon says we're requesting formatting for the value.
    Dot and `3` says that we want the number formatted to three decimal points. The
    formatter rounds the value for us, so the output will be 3.142.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Formatting traits determine how the output of the format will be produced.
    They are all used in the same way: `{:trait_name}.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the current traits available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format string** | **Trait** | **Meaning** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `{}` | Display | A human-readable representation. Not all things implement
    Display. | 123 => "123" |'
  prefs: []
  type: TYPE_TB
- en: '| `{:?}` | Debug | An internal representation. Almost everything implements
    Debug. | b"123" => [49, 50, 51] |'
  prefs: []
  type: TYPE_TB
- en: '| `{:b}` | Binary | Converts a number into binary | 123 => "1111011" |'
  prefs: []
  type: TYPE_TB
- en: '| `{:x}` | LowerHex | Hex in lowercase | 123 => 7b |'
  prefs: []
  type: TYPE_TB
- en: '| `{:X}` | UpperHex | Hex in uppercase | 123 => 7B |'
  prefs: []
  type: TYPE_TB
- en: '| `{:e}` | LowerExp | Number with exponential, lowercase | 123.0 => 1.23e2
    |'
  prefs: []
  type: TYPE_TB
- en: '| `{:E}` | UpperExp | Number with exponential, uppercase | 123.0 => 1.23E2
    |'
  prefs: []
  type: TYPE_TB
- en: '| `{:p}` | Pointer | Pointer location | &123 => 0x55b3fbe72980 (may point to
    a different address on every run) |'
  prefs: []
  type: TYPE_TB
- en: Similarly, the output can be formatted with formatting parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are essentially four formatting parameters available. They are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `Fill`/`Alignment` | Used in conjunction with the `Width` parameter. Essentially,
    this will add extra characters if the output is smaller than the width. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sign`/`#`/`0` | Flags for the formatter being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sign` indicates that the sign should always be outputted (numeric values only).
    If the value is positive, the `+` sign will never show; similarly, a `-` will
    only show for a `Signed` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*#*` indicates that an alternate form of printing will be used. Normally,
    if `{:x}` is used, the lowercase hex format is used. By using `#x`, the argument
    is preceded with `0x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` is used to pad a result with the `0` character. It is sign-aware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Width` | Specifies how the output should be represented. For example, if
    you have a float calculation that has to be outputted to four decimal places,
    and the result only comes to two decimal places, the width formatter (in conjunction
    with the fill formatting parameter) will create the required filled output. |'
  prefs: []
  type: TYPE_TB
- en: '| `Precision` | For anything non-numeric, the precision is the maximum width.
    For example, if you have a maximum width of five and a string containing eight
    characters, it will be truncated after five characters. It is ignored for integers.
    For floating point types, it indicates the number of decimal points after the
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer `.N:`: In this case, `N` is the precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integer followed by a `$ (.N$:)`: This uses the format argument `N` as the
    precision. The argument must be a `usize`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.*:`: This means that the contents of the `{}` is associated with two format
    inputs. The first holds the `usize` precision, the second holds the value to be
    printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of all of these formatters are in the source code examples for this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have concentrated on getting information out from a Rust
    program rather than entering information.
  prefs: []
  type: TYPE_NORMAL
- en: Input is done via the `std::io` module, getting a reader using the `io::stdin()`
    function, and then calling `read_line` on that reader. We put the inputted data
    into a dynamically growing `String`, which needs to be mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example for inputting would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see Rust's error handling in action in the previous code. The `read_line`
    method returns a result type, which means that the operation could have failed.
    The result type encapsulates two generic types inside itself, which in the case
    of `read_line` are `usize` (for reporting how many bytes were read in) and `io::Error`
    (for reporting any errors during input). The actual read String is placed in the
    first argument of the function, in this case `input_text`.
  prefs: []
  type: TYPE_NORMAL
- en: On that result type, our example calls the `expect` method. It expects that
    everything went fine, and returns the first value (the `usize` in this case).
    If there were errors, the `expect` method prints reading failed to the standard
    output and exits the program.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to handle result types, but it's a common one in cases
    where we expect things to usually work out fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to handle the error is to explicitly call the `is_err` method on
    the result. It returns a boolean, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we wish to further parse the entry into another type, we can use the `parse`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we''d like to get an `i32` from the input. The `read_line`
    method includes a carriage return in the input data, so we need to get rid of
    that using the `trim` method before parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of this example, this final line converts the result type into
    an `Option` using the `ok` method. Option is a simplified version of result. This
    is a useful library and it can have one of two results: `Some` or `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, if the entry result is `None`, the value is not an integer, whereas `Some`
    would be an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a program is started, it can be started with or without arguments. These
    arguments are normally fed in as parameters when the program is called. A simple
    example of this is starting the manual application (found on many BSD and Linux
    machines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding statement, `man` is the name of the program or script to be
    called with the argument `ffmpeg`. Similarly, take a look at the following example
    for Windows users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`Notepad` is the program name with the first argument being the file to read
    in (in this example, the file doesn''t exist, so the UI asks if you wish to create
    it).'
  prefs: []
  type: TYPE_NORMAL
- en: It is not uncommon for one program to load another program to perform a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, the parameter list for main is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`argc` is the maximum number of arguments with `argv` holding the arguments.
    Here, the program name is `argv[0]`, so all additional arguments start at 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Rust's `main` takes no arguments like this. Command-line parameters are available
    through the standard library `std::env::args` (environment arguments). For simplicity,
    it is convenient to store the arguments in `Vec<String>`, because `env::args`
    returns an iterator that yields a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No parameters are passed into `main` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `collect` method converts the iterator into a vector, making it possible
    to access it by indexing. Without it, we would have to go through the arguments
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Handling files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of our tour of getting information in and out of a program is
    using files. As far as Rust is concerned, a file is just another stream, with
    the exception that this stream goes elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: It is important when using anything to do with files that the `try!` macro is
    used to trap all errors.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are going to use `std::io`, `std::io::prelude::*` and `std::fs::File`.
    `std::io` is the standard input/output library, the `*` after prelude means to
    use anything in the prelude library, and `std::fs` is the filesystem library.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem calls are very platform-specific; Windows users use the likes of
    `C://Users/Paul/Documents/My Documents` for the user's home directory, whereas
    Linux and macOS machines would use `~/` for the user's home directory. If a path
    is not given for a file, the program will assume the file is in the same directory
    in which the binary resides.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To open a file, we use `File::open(filename)`. We can catch exceptions using
    the `try!` macro or `match`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the following can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file is available to open, `File::open` will grant read permissions
    to the file. To load the file, we create a `BufReader` based on the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the file has been read, the stream can be explicitly closed with `reader.close()`.
    However, Rust's resource management system guarantees that the file will be closed
    when its binding goes out of scope, so this is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing to a file is a two-step process: opening the file (possibly creating
    it if it didn''t exist before) and then the writing of the file. This is very
    similar to how writing to a file in the C family of languages is carried out.'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a file for writing in a single call to `std::fs::File::create`.
    The `open` method in the same namespace opens a file for reading. If you need
    more fine-tuned permissions, `std::fs::OpenOptions::new` creates an object through
    which you can tweak the parameters and then open the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any file operation, anything could fail, so the result should always
    be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned before, Rust uses a generic type, `Result<T,U>` , quite frequently
    as an error-trapping mechanism. It encapsulates two values: the left-hand side
    value is used when the operation succeeds, and the right-hand side value is used
    when it does not succeed.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have completed the file creation, we can move on to writing to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check the results of the `Result` comparison. If an error hasn''t
    been thrown there was no error, and we can then create a `BufWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to flush the buffer, as `write_all` will do that for us (it calls
    `flush()` once completed). If you don't use `write_all`, then you need to call
    `flush()` to ensure the buffer is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: The use of expect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust contains a very useful function called `expect`. This method is used with
    any form of call that has an `Option` or a `Result` type (for example, `Result`
    in the file-writing example has the options of `File` or `Error`). It works by
    moving the value out of the option and returning it. If the `option`/`result`
    type contains an error, the `expect` call stops your program and prints out the
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following statement will return either `File` or `Error` into `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A shorter form is available in the `unwrap` method. This is the same as the
    `expect` method, but it doesn't print out anything in case of a failure. In general,
    `Some(a).unwrap()` will return `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Expect` is usually favored instead of `unwrap`, since the full error message
    makes it easier to find where the error came from.'
  prefs: []
  type: TYPE_NORMAL
- en: XML and Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Rust is well suited to running on servers, it seems appropriate that we consider
    XML, and how it is handled within Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Rust comes with a crate called `Xml`, which works in a way similar
    to how standard streams are read and written.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with a standard file, we first have to open the file and create a reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the reading. Unlike a normal reader, we use `EventReader`. This
    provides a number of events (such as `StartElement`, `EndElement,` and `Error`),
    which are required for reading in from the differing nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we iterate through the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We aren't going to use the iterator; we just need something to enable the iteration
    to go to the next value.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing an XML file is far more complex than reading. Here, we have to explicitly
    use `XmlEvent` and `EventWriter`. We also use `EmitterConfig,` which does as the
    name suggests, that is, creates a configuration and then uses it. `EventWriter`,
    `EmitterConfig,` and `XmlEvent` are all part of `xml::writer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first consider the main function. First, create the file and two references,
    one to `stdin` and one to `stdout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the writer via `EmitterConfig:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We now have the writer set up. `perform_indent` tells the writer to indent each
    node when true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a loop and write the XML. You will notice a call to `handle_event`;
    we will deal with this shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the function `handle_event` is a bit more advanced than we
    have seen until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In C#, the preceding definition would be something similar, and would be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We pass a type (be it a `class`, `string`, `i32,` or anything else for that
    matter) to the function to use as a parameter. In this case, we are using `std::io::Write`
    for the `EventWriter` to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function itself has nothing special. We start by trimming the string to
    remove any whitespace or returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We now use `XmlEvent` to generate the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`into()` converts the pointer to the structure (known as `self`). In this case,
    it takes (say) `XmlEvent::characters(&line),` and sends it back into the line.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered quite a lot of material in this chapter, and you should feel
    more at home with handling strings, XML, and files, which can be used to add further
    functionality to your code. Please feel free to examine the examples supplied
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at loops, recursion, and branching.
  prefs: []
  type: TYPE_NORMAL
