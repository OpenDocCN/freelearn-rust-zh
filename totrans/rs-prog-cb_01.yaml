- en: Starting Off with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust ecosystem has grown considerably over the last year, and the 2018 edition,
    in particular, brought a significant push toward stabilization. The tooling is
    developing and important libraries are maturing to a point where many bigger companies
    use Rust in production.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of Rust is a steep learning curve—which is mostly due to
    a fundamental change in how to think about memory allocation. It is not uncommon
    for experienced programmers in other languages (such as C#) to feel overwhelmed
    with the way things are done in Rust. In this chapter, we will try to overcome
    this and lower the bar to get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting everything ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the command line I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling execution flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting your code with crates and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests and benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing code among types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence types in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the programming language comes with a variety of toolchains, tools, linkers,
    and compiler versions, choosing the best-fitting variation is not easy. Additionally,
    Rust works on all major operating systems—which adds another variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, installing Rust has become a trivial task when using `rustup` ([https://rustup.rs/](https://rustup.rs/)). On
    the website, a helpful script (or installer on Windows) that takes care of retrieving
    and installing the required components can be downloaded. The same tool lets you
    switch between and update (and uninstall) these components as well. This is the
    recommended way.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing to use the **Microsoft Visual Studio Compiler** (**MSVC**) together
    with Rust requires that you install additional software such as the Visual C++
    runtime and compiler tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write code, an editor is also required. Since Visual Studio Code sports
    some Rust parts, it is a great choice together with the Rust extension. It''s
    an open source editor developed by Microsoft and is well received across the world
    and the Rust community. In this recipe, we will install the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rustup` ([https://rustup.rs](https://rustup.rs))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rustc` (and the rest of the compiler toolchains)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cargo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RLS** (short for **Rust Language Server**—this is for autocompletion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust language support for Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a computer running either macOS, Linux, or Windows, only a web browser and
    internet connection are required. Bear in mind that the Windows installation works
    a little bit different from the ***nix** systems (Linux and macOS), which use
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the parts requires us to navigate to their respective websites, download
    the installer, and follow their instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser and navigate to [https://rustup.rs](https://rustup.rs) and [https://code.visualstudio.com/](https://code.visualstudio.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the installers fit for your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After downloading, run the installers and follow their instructions, choosing
    the `stable` branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once successfully installed, we'll go deeper into each installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the installation better
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Rust installation with rustup.rs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test whether the installation of the Rust toolchain with `rustup` was successful,
    the `rustc` command is available to run in Terminal (or PowerShell on Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that you will have a later version when you are running this. It doesn't
    matter if you stick to the 2018 edition for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Rust requires a native linker to be available on your system. On Linux or Unix
    systems (such as macOS), Rust calls `cc` for linking, whereas on Windows, the
    linker of choice is Microsoft Visual Studio's linker, which depends on having
    Microsoft Visual C++ Build Tools installed. While it's possible to use an open
    source toolchain on Windows as well, this exercise is left for more advanced users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with the 2018 edition, some useful features are still only available on
    `nightly`. To install the nightly edition of `rustc`, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `rustup install nightly` (use `nightly-msvc` on Windows if you are not using
    the GNU toolchain) in a Terminal or PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the command finishes, the default toolchain (used in `cargo`) can be switched
    using `rustup default nightly`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Visual Studio Code and extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its vanilla version, Visual Studio Code comes with syntax highlighting for
    many languages. However, for autocompletion or/and checking syntax, an extension
    is required. The Rust project supplies this extension:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use *Ctrl* + *P* (*cmd* + *P* on macOS) to open the command-line interface,
    then type `ext install rust-lang.rust` to install the extension. The process should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc247be2-1a02-41f7-9177-8f0bbc864424.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The extension uses RLS to do static code analysis and provide completion and
    syntax checking. The extension *should* install the RLS component automatically,
    but sometimes it will fail to do this. One solution is to add the following configuration
    to Visual Studio Code''s `settings.json` file (use *Ctrl* *+* *P*/*cmd* *+* *P*
    to find it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, `rustup` will also install RLS with the `rustup component add
    rls` command.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Occasionally, updating the tools will lead to errors that files are missing
    or cannot be overwritten. This can be for a wide range of reasons, but a full
    reset of the installations can help. On Linux or macOS systems, the following
    command takes care of deleting anything `rustup` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows''s PowerShell now supports many Linux-like commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This leads to the same result. After deleting the current installation, install
    `rustup` from scratch—this should install the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shell script, `rustup.sh`, is a great way to install Rust and it is the
    primary way to install Rust and other components today. In fact, it is common
    to use the script also in CI systems to install the compiler and other tools.
  prefs: []
  type: TYPE_NORMAL
- en: '`rustup` is an open source project maintained by the Rust project and can be
    found on GitHub: [https://github.com/rust-lang/rustup.rs](https://github.com/rust-lang/rustup.rs).'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to set up our environment. Now let's move on
    to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the command line I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional way of communicating with the user on the command line is using
    standard streams. Rust includes helpful macros to deal with these simple cases.
    In this recipe, we will explore the basic workings of the classic `Hello World` program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In just five steps, we will explore command line I/O and formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window (PowerShell on Windows) and run the `cargo new hello-world`
    command, which creates a new Rust project in a `hello-world` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once created, change into the directory with `cd hello-world` and open `src/main.rs`
    with a Visual Studio Code. The default code generated by `cargo` looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s expand it! These are variations on the preceding traditional `print`
    statement, showing some formatting options, parameters, and writing on streams,
    among other things. Let''s start with some common prints (and imports):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can do much more complex argument combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This should provide several variations of reading and writing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to Terminal and navigate to the directory where `Cargo.toml` is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `cargo run` to see the snippet''s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each line in the output represents a way to print text to the console! We recommend
    playing with the variations and seeing how it changes the result. On a side note, `rustc`
    will check for the correct number of arguments in any `println!()` or `format!()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through the code to understand the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo` is described in depth in [Chapter 2](cdcbf36d-9343-4b7b-ace1-b4c570dab62c.xhtml), *Managing
    Projects with Cargo*, in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial snippet is generated when `cargo new hello-world` is executed in
    *step 1*. As a project of type binary, a `main` function is required and `rustc` will
    be looking for it. Upon calling `cargo run`, `cargo` orchestrates compilation
    (with `rustc`) and linking (`msvc` on Windows, `cc` on *nix) and runs the resultant
    binary via its entry point: the `main` function (*step 5*).'
  prefs: []
  type: TYPE_NORMAL
- en: In the function we create in *step 3*, we write a series of `print!`/`println!`/`eprintln!`
    statements, which are Rust macros. These macros facilitate the writing to the
    standard output or standard error channels of a command-line application and include
    additional arguments. In fact, if arguments are missing, the compiler won't compile
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Rust's macros work directly on the syntax tree of the language, providing type
    safety and the ability to check the parameters and arguments. Therefore, they
    can be seen as a function call with a few special abilities—but more on that in
    [Chapter 6](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml), *Expressing Yourself
    with Macros*.
  prefs: []
  type: TYPE_NORMAL
- en: The various arguments and the template string are combined using formatters,
    a powerful way to add real variables to the output without the need of concatenations
    or similar workarounds. This will reduce the number of allocations, considerably
    improving performance and memory efficiency. There is a wide range of how to format
    data types; to understand it more deeply, check out Rust's excellent documentation
    ([https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/)).
  prefs: []
  type: TYPE_NORMAL
- en: The last step then shows the output that the various combinations produced.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned to work with the command line I/O. Now, let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust features all of the basic types: signed and unsigned integers up to 64
    bits in width; floating-point types up to 64 bits; character types; and Booleans.
    Of course, any program will need more complex data structures to remain readable.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with unit tests in Rust (or in general), we suggest going
    through the *Writing tests and benchmarks* recipe here in this chapterfirst.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at good basic practices to create and use data types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use Rust''s unit tests as a playground for some data type experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using `cargo new data-types -- lib` and use an editor to
    open the `projects` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `src/lib.rs` in your favorite text editor (Visual Studio Code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In there, you will find a small snippet to run a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace the default test to play with various standard data types. This
    test uses a few ways to work with data types and their math functions, as well
    as mutability and overflows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the basic numeric types covered, let''s check a major limitation: overflows!
    Rust panics when an overflow occurs, so we are going to expect that with the `#[should_panic]`
    attribute (the test will actually fail if it doesn''t panic):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a custom type as well. Rust''s types are `structs` and
    they add no overhead in memory. The type features a `new()` (constructor by convention)
    and a `sum()` function, both of which we''ll call in a test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the new `struct` function in action, let''s add a test to do some and
    clone memory tricks with types (note: pay attention to the asserts):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s see whether all of that works. Run `cargo test` in the `data-types`
    directory and you should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe played with several concepts, so let's unpack them here. After setting
    up a library to work with unit tests as our playground in *step 1* to *step 3*,
    we create a first test to work on some built-in data types to go through the basics
    in *step 4* and *step 5*. Since Rust is particularly picky about type conversions,
    the test applies some math functions on the outcomes and inputs of different types.
  prefs: []
  type: TYPE_NORMAL
- en: For experienced programmers, there is nothing new here, except for the fact
    that there is an `overflow_sub()` type operation that allows for overflowing operations.
    Other than that, Rust might be a bit more verbose thanks to the (intentional)
    lack of implicit casting. In *step 5*, we intentionally provoke an overflow, which
    leads to a runtime panic (and is the test result we are looking for).
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *step 5*, Rust offers `struct` as the foundation for complex types,
    which can have attached implementation blocks as well as derived (`#[derive(Clone,
    Copy, Debug)]`) implementations (such as the `Debug` and `Copy` traits). In *step
    6*, we go through using the type and its implications:'
  prefs: []
  type: TYPE_NORMAL
- en: No overhead on custom types: `struct` has exactly the size that the sum of its
    properties has
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some operations implicitly invoke a trait implementation—such as the assignment
    operator or the `Copy` trait (which is essentially a shallow copy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing property values requires the mutability of the entire `struct` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few aspects that work like that because the default allocation strategy
    is to prefer the stack whenever possible (or if nothing else is mentioned). Therefore,
    a shallow copy of the data performs a copy of the actual data as opposed to a
    reference to it, which is what happens with heap allocations. In this case, Rust
    forces an explicit call to `clone()` so the data behind the reference is copied
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to create and use data types. Now, let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling execution flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, controlling the execution flow of a program goes beyond simple `if`
    and `while` statements. We will see how to do that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using `cargo new execution-flow -- lib` and open the project
    in an editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Basic conditionals such as `if` statements work just like in any other language,
    so let''s start with those and replace the default `mod tests { ... }` statement
    in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Conditionals in Rust can do much more! Here is an additional test to show what
    they can do—add it before the last closing parenthesis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A conditional isn''t the only statement that can be used to change the flow
    of execution. There is, of course, also the loop and its variations. Let''s add
    another test for those as well, starting with a few basics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add more code to the test to see that loops are regular statements
    that can return values and that ranges can be used in `for` loops as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With these three tests prepared, let''s run `cargo test` to see them working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although not vastly different from many languages' control statements, the basic
    constructs in Rust can change the way you think about variable assignments. It
    certainly transformed our mental models to be more data-focused. This means that
    instead of thinking *if this condition is reached, assign this other value to
    a variable*, a reversed *assign this other value to a variable if this condition
    is reached*—or shorter *transform this variable if this condition applies—*may
    take over.
  prefs: []
  type: TYPE_NORMAL
- en: This is the functional stream in the Rust programming language and it lends
    itself well to shortening and focusing the important parts of a piece of code.
    Similar implications can be made from the loop constructs since everything is
    a scope and has a return value. Using these capabilities will make every program
    a lot more readable and shorter, especially if it's just simple operations.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to control execution flow. Now, let's move on
    to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting your code with crates and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust knows two types of code units: crates and modules. A crate is an external
    library, complete with its own `Cargo.toml` configuration file, dependencies,
    tests, and code. Modules, on the other hand, split the crate into logical parts
    that are only visible to the user if they import specific functions. Since the
    2018 edition of Rust, the difference in using these structural encapsulations
    has been minimized.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we are going to create two projects: one that offers some type of
    function and another one to use it. Therefore, use `cargo` to create both projects:
    `cargo new rust-pilib --lib` and `cargo new pi-estimator`. The second command
    creates a binary executable so we can run the compilation result, while the former
    is a library (crate).'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is going to create a small program that prints out estimations of
    pi (![](img/b35a6d88-0e56-4570-baee-314330859f14.png)) and rounds them to two
    decimal places. It's nothing fancy and easy for anyone to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Naming crates is hard. The main repository ([https://crates.io/](https://crates.io/))
    is very permissive and has already seen name squatting (where people reserve names
    with the intent to sell them—think of names such as *YouTube* or *Facebook*, which
    would make nice API client names for these companies), and many crates are re-implementations
    of C libraries or wrap them. A good practice is to call the repository or directory
    `rust-mycoolCwrapper` and use `mycoolCwrapper` to name the crate itself. This
    way, only issues specific to your crate come in while the name is easy to guess
    in people's dependencies!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In just a few steps, we will be working with different modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to implement the `rust-pilib` crate. As a simple example,
    it estimates the constant pi using the Monte Carlo method. This method is somewhat
    similar to throwing darts at a dartboard and counting the hits. Read more on Wikipedia
    ([https://en.wikipedia.org/wiki/Monte_Carlo_method](https://en.wikipedia.org/wiki/Monte_Carlo_method)).
    Add to the `tests` submodule this snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the Monte Carlo method uses a random number generator. Since
    Rust doesn''t come with one in its standard library, an external crate is required!
    Modify `Cargo.toml` of the `rust-pilib` project to add the dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As good engineers, we are also going to add tests to our new library. Replace
    the original `test` module with the following tests to approximate `pi` using
    the Monte Carlo method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even go beyond 500 iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s run the tests so we are certain of the quality of our product.
    Run `cargo test` in the root of the `rust-pilib` project. The output should be
    somewhat like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to offer the crate''s feature(s) to the user, which is why we created
    a second project for the user to execute. Here, we declare to use the other library
    as an external crate first. Add the following to `Cargo.toml` in the `pi-estimator`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s take a look at the `src/main.rs` file. Rust looks there to find
    a `main` function to run and, by default, it simply prints `Hello, World!` to
    standard output. Let''s replace that with a function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, where does this new function live? It has its own module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This module was implemented inline, which is common for tests—but works almost
    like it was its own file. Looking at the `use` statements, we are still missing
    a module, however: `rounding`. Create a file in the same directory as `main.rs`
    and name it `rounding.rs`. Add this public function and its test to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the module is ignored by the compiler since it was never declared.
    Let''s do just that and add two lines at the top of `main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we want to see whether everything worked. `cd` into the root directory
    of the `pi-estimator` project and run `cargo run`. The output should look similar
    to this (note that the library crate and dependencies are actually built with
    `pi-estimator`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Library crates are not the only ones to have tests. Run `cargo test` to execute
    the tests in the new `pi-estimator` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explored the relationship between crates and modules. Rust
    supports several ways of encapsulating code into units, and the 2018 edition has
    made it a lot easier to do. Seasoned Rust programmers will miss the `extern crate`
    declaration(s) at the top of the files, which is nowadays only necessary in special
    cases. Instead, the crate's contents can be used right away in a `use` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the line between modules and crates is now blurred. However, modules
    are much simpler to create since they are part of the project and only need to
    be declared in the root module to be compiled. This declaration is done using
    the `mod` statement, which also supports implementation in its body—something
    that is used a lot in testing. Regardless of the implementation's location, using
    an external or internal function requires a `use` statement, often prefixed with `crate::`
    to hint toward its location.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively to simple files, a module can also be a directory that contains
    at least a `mod.rs` file. This way, large code bases can nest and structure their
    traits and structs accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A note on function visibility: Rust''s default parameter is module visibility.
    Hence, a function declared and implemented in a module can only be seen from within
    that module. Contrary to that, the `pub` modifier exports the function to outside
    users. The same goes for properties and functions attached to a struct.'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to split our code with crates and modules. Now,
    let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests and benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start developing, tests take a backseat more often than not. There are
    several reasons why this might be necessary at the time, but the inability to
    set up a testing framework and surroundings is not one of them. Unlike many languages,
    Rust supports testing right out of the box. This recipe covers how to use these
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Although we mostly talk about unit testing here, that is, tests on a function/`struct`
    level, the tools remain the same for integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, this recipe is best worked on in its own project space. Use `cargo new
    testing --lib` to create the project. Inside the project directory, create another
    folder and call it `tests`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the benchmarks feature is still only available on the `nightly`
    branch of Rust. It is required to install the `nightly` build of Rust: `rustup
    install nightly`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn more about creating a test suite for your Rust
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, a library project already contains a very simple test (probably
    to encourage you to write more). The `cfg(test)` and `test` attributes tell `cargo`
    (the test runner) how to deal with the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we add further tests, let''s add a subject that needs testing. In this
    case, let''s use something interesting: a singly linked list from our other book (*Hands-On
    Data Structures and Algorithms with Rust*) made generic. It consists of three
    parts. First is a node type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have a `Link` type to make writing easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last type is the list complete with functions to add and remove nodes.
    First, we have the type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `impl` block, we can then specify the operations for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the list ready to be tested, let''s add some tests for each function,
    starting with a benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more tests for basic list functionality inside the `test` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also a good idea to have an integration test that tests the library from
    end to end. For that, Rust offers a special folder in the project called `tests`,
    which can house additional tests that treat the library as a black box. Create
    and open the `tests/list_integration.rs` file to add a test that inserts 10,000
    items into our list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, now each function has one test. Try it out by running `cargo +nightly
    test` in the `testing/` root directory. The result should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the benchmark, issue `cargo +nightly bench`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing frameworks are a third-party library in many programming languages although
    well-tested code should be the default! By providing a (tiny) testing framework
    along with a test runner and even a small benchmarking framework (only on `nightly`
    as of this writing), the barrier for testing your Rust code is significantly lower.
    Although there are still some missing features (for example, mocking), the community
    is working on providing many of these things via external crates.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting everything up in *step 1*, *step 2* creates a singly linked list
    as the test subject. A singly linked list is a series of the same node types,
    connected with some sort of pointer. In this recipe, we decided to use the interior
    mutability pattern, which allows for borrowing mutably at runtime to modify the
    node it points to. The attached operations (`append()` and `pop()`) make use of
    this pattern. *Step 3* then creates the tests that we can use to verify that our
    code does what we think it should. These tests cover the basic workings of the
    list: create an empty list, append a few items, and remove them again using `pop`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be failed using a variety of `assert!` macros. They cover equals (`assert_eq!`),
    not equals (`assert_ne!`), Boolean conditions (`assert!`), and non-release mode
    compilation only (`debug_assert!`). With these available and attributes such as `#[should_panic]`, there
    is no case that cannot be covered. Additionally, this great Rust book offers an
    interesting read as well: [https://doc.rust-lang.org/book/ch11-01-writing-tests.html](https://doc.rust-lang.org/book/ch11-01-writing-tests.html).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* adds a special integration test in a separate file. This restricts
    programmers to think like the user of the crate, without access to internal modules
    and functions that can be available in the nested `tests` module. As a simple
    test, we insert 10,000 items into the list to see whether it can handle the volume.'
  prefs: []
  type: TYPE_NORMAL
- en: The `+nightly` parameter instructs `cargo` to use the `nightly` toolchain for
    this command.
  prefs: []
  type: TYPE_NORMAL
- en: Only in *step 5* are we ready to run the benchmarks using `cargo +nightly test`,
    but tests are not automatically benchmarked. On top of that, benchmarks (`cargo
    +nightly bench`) compile the code using `--release` flags, thereby adding several
    optimizations that could lead to different outcomes from `cargo +nightly test`
    (including a headache for debugging those).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* shows the output of the benchmarking harness with nanosecond precision
    for each loop execution (and the standard deviation). Whenever doing any kind
    of performance optimization, have a benchmark ready to show that it actually worked!'
  prefs: []
  type: TYPE_NORMAL
- en: Other nice things that the Rust documentation tool adds to testing are `doctests`.
    These are snippets that are compiled and executed as well as rendered as documentation.
    We were so delighted, we gave it its own recipe! So, let's move on to the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documentation is an important part of software engineering. Instead of simply
    writing up some functions and chaining them together on a hunch, we like to promote
    writing reusable and readable code. Part of this is also writing sensible documentation—which,
    in ideal cases, can be rendered into other formats such as HTML or PDF. As many
    languages do by default, Rust provides a tool and language support as well: `rustdoc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Failing our high standards of software engineering, we did not document the
    code from the last recipe! To change that, let's load a project with code to be
    documented (such as the previous recipe, *Writing tests and benchmarks*) into
    an editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile your code comments to a shiny HTML in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust''s docstrings (strings that explicitly are documentation to be rendered)
    are denoted by `///` (instead of the regular `//`). Within these sections, markdown—a
    shorthand language for HTML—can be used to create full documentation. Let''s add
    the following before the `List<T>` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: /// let list = List::new_empty();
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE42]
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes the code a lot more verbose, but is this worth it? Let''s see with
    `cargo doc`, a subcommand that runs `rustdoc` on the code and outputs HTML in
    the `target/doc` directory of the project. When opened in a browser, the `target/doc/testing/index.html`
    page shows the following (and more):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe7c8e34-1c9e-445f-ac33-ad9809066e35.png)'
  prefs: []
  type: TYPE_IMG
- en: Replace `testing` with the name of your project!
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, let''s add more documentation in the code. There are even special sections
    that are recognized by the compiler (by convention):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: /// use testing::List;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let mut list = List::new_empty();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// list.append(10);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE44]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `///` comments add documentation for expressions that follow it. This is
    going to be a problem for modules: should we put the documentation outside of
    the current module? No. Not only will this make the maintainers confused, but
    it also has a limit. Let''s use `//!` to document the module from within:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick `cargo doc` run reveals whether it worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ab5a1ad-2ec2-4956-be4e-5bc3e6087d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While there is some benefit in having similar-looking documentation in any
    Rust project, corporate marketing often likes to have things such as logos or
    a custom favicon to stand out. `rustdoc` supports that with attributes on the
    module level—they can be added right below the module documentation (note: this
    is the logo of my Rust blog, [https://blog.x5ff.xyz](https://blog.x5ff.xyz)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To see whether it worked, let''s run `cargo doc` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/740bd4e6-4c7c-4972-8134-44fbff08e29c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Markdown is a great language that allows for creating formatted documentation
    quickly. However, feature support is typically tricky, so check out Rust's RFC
    for supported formatting ([https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md](https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md)) to
    find out whether some more advanced statements can be used. In general, writing
    documentation is dreaded by most developers, which is why it's very important
    to make it as simple and effortless as possible. The `///` pattern is quite common
    and has been expanded in Rust so that the documentation can apply to the code
    that follows (`///`) or that contains it (`//!`). Examples can be seen in *step
    1* and *step 4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach the Rust project chose allows for a few lines explaining the (`public`)
    function, and then the `rustdoc` compiler (invoked in *step 2* with `cargo doc`)
    does the rest: exposing public members, cross-linking, listing all of the available
    types and modules, and much more. While the output is fully customizable (*step
    6*), the default is already visually quite appealing (we think).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `cargo doc` builds the documentation for the entire project—including
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Special sections (*step 3*) add another dimension to the documentation output:
    they allow for IDEs or editors to make some sense of the provided information
    and highlight, for example, that (and when) a function may panic. The examples
    section in your newly generated documentation will even compile and run code in
    the form of `doctests` (see the *Testing your documentation* recipe) so you will
    be notified when your examples become invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: The `rustdoc` output is also independent of a web server, which means that it
    can be used wherever static hosting is supported. In fact, the Rust project builds
    and serves every crate's documentation that is hosted on [https://crates.io](https://crates.io),
    on [https://docs.rs](https://docs.rs).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can create documentation successfully, we should move on to the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out-of-date documentation and examples that aren't working as promised are an
    unfortunate truth of many technologies. However, these examples can be valuable
    (black box) regression tests to make sure that we didn't break anything while
    improving the code, so how can they be used as such? Rust's documentation strings
    (`///`) can include executable code snippets—and they can be seen all over the
    place on [https://www.rust-lang.org/learn](https://www.rust-lang.org/learn)!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue to improve the linked list from a previous recipe but focus some
    more on the documentation. However, the added code will work in any project, so
    pick one that you want to add documentation to and open it in your favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find a function or `struct` (or module) to add a documentation string, for
    example, the `new_empty()` function of `List<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the special (`H1`) section `# Example` to provide a cue for the compiler
    to run any snippet contained in that section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a code example. Since `doctests` are considered black box tests,
    we import the `struct` (only if it''s public, of course) and show what we want
    to show:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: /// use testing::List;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// let mut list: List<i32> = List::new_empty();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE50]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With that ready, let''s see whether the tests work: run `cargo +nightly test`
    in the project''s root directory. You can see that we cheated a little bit and
    added tests to the other functions as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The code obviously has been augmented with several examples that have been
    run in this case—is that always what we want? Sometimes, it''s all about the output,
    and adding all of the required imports for the test to successfully run is a pain.
    Hence, there are options to add to the *fenced* area ([PRE52] inside the fence
    [PRE53]`), and `ignore` will neither compile nor run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]ignore'
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: /// let list = List::new_empty();
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE55]
  prefs: []
  type: TYPE_NORMAL
- en: 'By running `cargo test` again, we see the changes reflected in the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the HTML output as well: run `cargo doc` to generate a `target/doc/`
    directory containing all of the `CSS/HTML/JavaScript/...` required to show the
    documentation in a local browser. Open `target/doc/testing/index.html` with your
    favorite browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02f40760-8124-4075-97e4-f98dace48423.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note: Replace `testing` with the name of your project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove the ugly `use` statement at the top of the snippet. At that point,
    it doubles the lines displayed without adding anything—and `rustdoc` provides
    a simple way to do that, too. Add `#` in front of the offending line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '/// # use testing::List;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// let list: List<i32> = List::new_empty();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE58]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, there are additional ways to configure the testing behavior of `doctests`.
    In this case, let''s change warnings to errors by *denying* the warning while
    ignoring (allowing) unused variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'One last time, let''s check whether the output is what we expect and run `cargo
    doc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94438ebb-bd22-4720-b1ec-1a8fc65c8bd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's see whether we can find out more about how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's documentation is very versatile and allows for variations on `doctests`
    that would not be possible to cover in a single recipe. However, the documentation
    of these tools is also excellent, so, for more details, check out [https://doc.rust-lang.org/rustdoc/documentation-tests.html](https://doc.rust-lang.org/rustdoc/documentation-tests.html).
  prefs: []
  type: TYPE_NORMAL
- en: What we covered in this recipe is a great way to document `structs` and functions
    in your code by adding examples that will be compiled and run on every test run.
    Not only will these be helpful for your readers and regression testing, but they
    also require you to think about how the code works as a black box. These tests
    are executed whenever code ([PRE60] in a fence [PRE61]`) is encountered in the
    `Example` section of the documentation. In *step 2* and *step 3*, we create these
    examples and see the result in *step 4* and *step 10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are now wondering how some documentation can show a fraction of the
    code required while it is supposed to be run, *step 8* shows the resolution to
    this riddle: `#` can hide individual lines while executing them. However, sometimes
    the code is not executed at all, as *step 5* shows. We can declare a section as
    `ignore` and this code won''t be run (without any visual indication in the output).'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, these tests can fail just like any other test by panicking (which
    can be allowed as well) or falling through an `assert!` macro. All in all, by
    hiding away boilerplate or other non-essential code, the reader can focus on the
    important bits, while the test still covers everything.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully tested our documentation—we can sleep easy and move on to
    the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing code among types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An unusual feature of the Rust programming language is the decision to use
    traits over interfaces. The latter is very common across modern object-oriented
    languages and unifies the API of a class (or similar) to the caller, making it
    possible to switch the entire implementation without the caller''s knowledge.
    In Rust, the separation is a bit different: traits are more akin to abstract classes
    since they provide the API aspect as well as default implementations. `struct`
    can implement various traits, thereby offering the same behavior with other structs
    that implement the same traits.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `cargo` to create a new project, `cargo new traits --lib`, or clone it from this
    book's GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
    Use Visual Studio Code and Terminal to open the project's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a simple configuration management service. To do that, we need some
    structs to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, some constructors make them easier to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a unified interface with other potential implementations, we have some
    traits to share the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust demands its own implementation block for each trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need some tests to show it in action. To cover some basics, let''s
    add best-case unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we run `cargo test` and see that everything works out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using traits instead of interfaces and other object-oriented constructs has
    many implications for the general architecture. In fact, common architectural
    thinking will likely lead to more complex and verbose code that may perform worse
    on top of that! Let''s examine popular object-oriented principles from the Gang
    of Four''s book, *Design Patterns* (1994):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program to an interface not to an implementation**: This principle requires
    some thinking in Rust. With the 2018 edition, functions can accept an `impl MyTrait`
    parameter, where earlier versions had to use `Box<MyTrait>` or `o: T` and later
    `where T: MyTrait`, all of which have their own issues. It''s a trade-off for
    every project: either less complex abstractions with the concrete type or more
    generics and other complexity for cleaner encapsulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Favor object composition over class inheritance**: While this only applies
    to some extent (there is no inheritance in Rust), object composition is still
    something that seems like a good idea. Add trait type properties to your struct
    instead of the actual type. However, unless it''s a boxed trait (that is, slower
    dynamic dispatch), there is no way for the compiler to know exactly the size it
    should reserve—a type instance could have 10 times the size of the trait from
    other things. Therefore, a reference is required. Unfortunately, though, that
    introduces explicit lifetimes—making the code a lot more verbose and complex to
    handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust clearly favors splitting off behavior from data, where the former goes
    into a trait and the latter remains with the original struct. In this recipe, `KeyValueConfigService`
    did not have to manage any data—its task was to read and write `Config` instances.
  prefs: []
  type: TYPE_NORMAL
- en: After creating these structs in *step 2*, we created the behavior traits in
    *step 3*. There, we split the tasks off into two individual traits to keep them
    small and manageable. Anything can implement these traits and thereby acquire
    the capabilities of writing or reading config files or retrieving a specific value
    by its key.
  prefs: []
  type: TYPE_NORMAL
- en: We kept the functions on the trait generic as well to allow for easy unit testing
    (we can use `Vec<T>` instead of faking files). Using Rust's `impl` trait feature,
    we only care about the fact that `std::io::Read` and `std::io::Write` have been
    implemented by whatever is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* implements the traits in an individual `impl` block for the structs.
    The `ConfigReader` strategy is naive: split into lines, split those lines at the
    first `=` character, and declare the left- and right-hand parts key and value
    respectively. The `ValueGetter` implementation then walks through the key-value
    pairs to find the requested key. We preferred `Vec` with `String` tuples here
    for simplicity, for example, `HashMap` can improve performance substantially.'
  prefs: []
  type: TYPE_NORMAL
- en: The tests implemented in *step 5* provide an overview of how the system works
    and how we seamlessly use the types by the traits they implement. `Vec` doubles
    as a read/write stream, no type-casting required. To make sure the tests actually
    run through, we run `cargo test` in *step 6*.
  prefs: []
  type: TYPE_NORMAL
- en: After this lesson on structuring code, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence types in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequences are supported in many forms in Rust. The regular array is strictly
    implemented: it has to be defined at compile time (using literals) and be of a
    single data type, and cannot change in size. Tuples can have members of different
    types, but cannot change in size either. `Vec<T>` is a generic sequence type (of
    whatever you define as type `T`) that provides dynamic resizing—but `T` can only
    be of a single type. All in all, each of them has its purpose and, in this recipe,
    we will explore each.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `cargo` to create a new project, `cargo new sequences --lib`, or clone it
    from this book's GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
    Use Visual Studio Code and Terminal to open the project's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the test module ready, let''s start with arrays. Arrays in Rust have a
    familiar syntax but they follow a stricter definition. We can try out various
    abilities of the Rust array in a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Users of more recent programming languages and data science/math environments
    will also be familiar with the tuple, a fixed-size variable type collection. Add
    a test for working with tuples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last collection, the vector is the basis for all of the other quick
    and expandable data types. Create the following test with several assertions that
    show how to use the `vec!` macro and the vector''s memory usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the test shows how to modify and read the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `cargo test` to see the working tests run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequence types are compound types that allocate a continuous part of the memory
    for faster and easier access. `Vec<T>` creates a simple, heap-allocated version
    of an array that grows (and shrinks) dynamically (*step 4*).
  prefs: []
  type: TYPE_NORMAL
- en: The original array (*step 2*) allocates memory on the stack and has to have
    a known size at compile time, which is a significant factor in using it. Both
    can be iterated and viewed using slices ([https://doc.rust-lang.org/book/ch04-03-slices.html](https://doc.rust-lang.org/book/ch04-03-slices.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Tuples (*step 3*) are a different beast since they don't lend themselves to
    slices and are more a group of variables that have a semantic relationship—like
    a point in a two-dimensional space. Another use case is to return more than one
    variable to the caller of a function without the use of an additional struct or
    misusing a collection type.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences in Rust are special because of the low overhead they produce. The
    size of `Vec<T>` is a pointer to an `n * size of T` memory on the heap, along
    with the size of the allocated memory, and how much of that is used. For arrays,
    the capacity is the current size (which the compiler can fill in during compilation),
    and tuples are more or less syntactic sugar on top of three distinct variables.
    Each of the three types provides convenience functions to change the contents—and,
    in the case of `Vec<T>`, the size of the collection. We recommend taking a close
    look at the tests and their comments to find out more about each type.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the basics of sequences in Rust, so let's move on to the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging has been a notoriously difficult topic in Rust, but still, it pales
    in comparison to Visual Studio debugging or IntelliJ IDEA's ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    capabilities in the Java world. However, debugging capabilities go beyond simple
    `println!` statements nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Rust is available via an additional extension in Visual Studio Code.
    Install it by running `ext install vadimcn.vscode-lldb` in the command window
    (*Ctrl* + *P*/*cmd* + *P*).
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, debugging is limited thanks to its incomplete LLVM support. However,
    the extension will prompt you to automatically install several things. Additionally,
    install **Python 3.6** and add it to `%PATH%`. With these dependencies installed,
    it worked well for us (in March 2019).
  prefs: []
  type: TYPE_NORMAL
- en: Read more at [https://github.com/vadimcn/vscode-lldb/wiki/Setup](https://github.com/vadimcn/vscode-lldb/wiki/Setup).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new binary project to debug: `cargo new debug-me`. Open this project
    in Visual Studio Code with the new extension loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before anything can happen, Visual Studio Code needs a launch configuration
    to recognize Rust''s LLVM output. First, let''s create this launch configuration;
    for that, add a `.vscode` directory containing a `launch.json` file to the project
    directory. This can be autogenerated, so make sure that `launch.json` contains
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open `src/main.rs` and add some code to debug:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and add a breakpoint in VS Code''s user interface. Click left of the line
    numbers and a red dot should appear there. This is a breakpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1131a2d-2e04-44c4-b77f-2bcfb2ad2df9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having set a breakpoint, we expect the program to pause there and give us some
    insights into the current memory layout, that is, the state of any variables at
    that particular point in time. Run the debug launch configuration with *F5* (or
    Debug *|* Start Debugging). The window configuration should change slightly and
    a panel on the left-hand side of the window shows local variables (among other
    things):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2e8a80c-fc38-45cc-bb91-0d2220b3ff7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the small control panel on top, you can then control the execution flow
    and watch the stack and memory on the left change accordingly. Note also the difference
    between an array and a (heap-allocated) vector!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is built on the LLVM compiler toolkit that comes with a range of features
    out of the box. When a Rust program compiles, it only gets translated into an
    intermediate language, from which the LLVM compiler creates native bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason why debugging can work in this case—it builds on the
    LLVM debug symbols. While it clearly lacks the convenience of modern IDEs, it's
    a large step forward and allows users to inspect types. Future development of
    the tools will hopefully improve this situation as well; for now, the general
    debugger, GDB ([https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)),
    handles most of the cases where debug symbols are compiled into the program. The
    configuration for connecting the debugger with the code in the IDE can be found
    in *step 2* and, by setting the breakpoint in *step 4*, it can track the relationship
    between lines of code and output. With the default setting to compile to debug,
    the debugger can then stop at this exact point. While it's not perfect (on the
    UX side), its capabilities are amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Even this simple connection to a (UX-wise) very basic debugger can have great
    benefits for developers and represents a huge step up from `println!()` statements
    to inspect the current value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that you can use the debugger's capabilities in the remainder of this
    book. With this knowledge, you can now move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
