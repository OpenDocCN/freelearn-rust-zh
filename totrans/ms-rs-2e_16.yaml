- en: Building Desktop Applications with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your software only supports a terminal or command-line-based interface, your
    target audience is likely limited to only people who know how to use the command
    line. Providing a **Graphical User Interface** (**GUI**) for your software widens
    your target audience and gives users a friendly and intuitive interface so that
    they can use the software effortlessly. For building GUIs, most languages provide
    frameworks that consist of several native libraries that are composed together
    and can access the graphics and the I/O interfaces of the platform. This enables
    developers to easily build GUIs for their applications without worrying about
    the low-level details.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few popular GUI frameworks targeting desktop platforms such
    as Qt, GTK+, and ImGUI, which are available for mainstream languages. At the time
    of writing this book, Rust doesn't have a mature ecosystem of GUI frameworks,
    but fortunately we have the convenient FFI mechanism through which it can piggyback
    onto the native GUI frameworks provided by languages such as C/C++. In this chapter,
    we'll go through one such crate that provides native bindings to the GTK+ framework
    for doing GUI development and build our ownnews reading desktop app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GUI development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GTK+ framework and the `gtk` crate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a hacker news desktop app in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other emerging frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to GUI development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"In programming, the hard part isn''t about solving problems, but deciding
    what problems to solve."'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: – *Paul Graham*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The advent of GUI-based software started with GUI operating systems. The first
    GUI operating system was the Alto Executive, which ran on the Xerox Alto computer
    that was developed in 1973\. Since then, many operating systems followed suit
    and came with their own GUI-based interface. Today, the most famous GUI-based
    operating systems are macOS, Windows, and Linux-based distributions such as Ubuntu
    and KDE. With users interacting with the OS via a visual point and click interface,
    demand for GUI-based applications increased and a lot of software started shipping
    with GUIs to provide users with a visual way of interacting with their software,
    similar to how they do with their OS. But the early days of GUI development were
    a lot of manual work and due to hardware constraints, different applications had
    specialized implementations and performance characteristics in their GUIs. Eventually,
    GUI frameworks started to proliferate, which provided developers with a common
    baseline and an abstraction layer from all the low-level details of the underlying
    OS, while also being cross-platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build our app, it is important for us to have a brief idea about
    the general design guidelines that are followed in integrating a GUI or a frontend
    to an application. We''ll be focusing our discussion from a Linux OS perspective,
    but there are similarities in the ideas on other platforms, too. A typical GUI
    application architecture is usually split into two components: the frontend and
    the backend. The frontend is the GUI thread or the main thread that the user interacts
    with. It is composed of interactive visual units called **widgets** that are contained
    in a parent container window. An example of a widget is a button that you click
    to perform a task, or a list view that can display multiple items in sequence.
    The GUI thread is mainly concerned with presenting visual information to the user
    and is also responsible for propagating any event that occurs when the user interacts
    with the widgets.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序之前，了解在将GUI或前端集成到应用程序中时遵循的一般设计指南对我们来说非常重要。我们将从Linux操作系统角度进行讨论，但其他平台上的理念也有相似之处。典型的GUI应用程序架构通常分为两个组件：前端和后端。前端是用户与之交互的GUI线程或主线程。它由包含在父容器窗口中的交互式视觉单元**小部件**组成。小部件的一个例子是点击执行任务的按钮，或者可以按顺序显示多个项目的列表视图。GUI线程主要关注向用户展示视觉信息，并且负责传播用户与这些小部件交互时发生的任何事件。
- en: The backend is a separate thread and contains event handlers or event emitters
    for propagating state changes, and is mainly used for performing compute heavy
    tasks. Processing inputs from the GUI layer is often offloaded to background threads
    as performing compute heavy tasks on the main thread blocks the user from interacting
    with the application frontend, which is not a good user experience. Also, for
    maintainability and separation of concerns, it is often desirable that we keep
    the frontend and the backend separate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是一个独立的线程，包含用于传播状态变化的事件处理程序或事件发射器，主要用于执行计算密集型任务。从GUI层处理输入通常被卸载到后台线程，因为如果在主线程上执行计算密集型任务会阻止用户与应用程序的前端交互，这不是一个好的用户体验。此外，为了维护性和关注点的分离，我们通常希望保持前端和后端分离。
- en: Building a GUI-based application without a dedicated framework can be a very
    cumbersome process, as without them we might need to handle a lot of details in
    our application code. GUI frameworks abstract all the details for the developer,
    such as drawing the widgets and the windows to the video memory or GPU's frame
    buffer, reading events from input devices, re-drawing and refreshing windows,
    and much more. With that said, let's look at one such framework called the Gimp
    toolkit or GTK+, which is a very mature and cross-platform solution for building
    scalable GUI applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有专用框架的情况下构建基于GUI的应用程序可能是一个非常繁琐的过程，因为没有它们，我们可能需要在应用程序代码中处理很多细节。GUI框架为开发者抽象了所有这些细节，例如将小部件和窗口绘制到视频内存或GPU的帧缓冲区，从输入设备读取事件，重新绘制和刷新窗口等等。话虽如此，让我们看看这样一个框架，即Gimp工具包或GTK+，它是一个构建可扩展GUI应用程序的非常成熟和跨平台的解决方案。
- en: GTK+ framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GTK+ 框架
- en: 'GTK+ (hereafter gtk) is a cross-platform GUI framework that was created in
    C. Being cross-platform, applications that are developed using gtk can run on
    all major platforms, such as Windows, Linux, or MacOS*.* The gtk project was originally
    created to develop GIMP, image manipulation software for Linux, and was later
    open sourced. gtk is also used by many other software projects, such as the Gnome
    desktop environment on many Linux distributions, which uses it for building its
    utility software. Architecture-wise, gtk is composed of several libraries that
    work together to handle various details that are needed to render and facilitate
    interaction with windows and widgets by the user in the application. Some of these
    components are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+（以下简称gtk）是一个用C语言编写的跨平台GUI框架。由于其跨平台性，使用gtk开发的应用程序可以在所有主要平台上运行，例如Windows、Linux或MacOS*.*
    gtk项目最初是为了开发Linux的图像处理软件GIMP而创建的，后来被开源。gtk也被许多其他软件项目使用，例如许多Linux发行版上的Gnome桌面环境，它使用gtk来构建其实用软件。在架构上，gtk由几个库组成，这些库协同工作以处理渲染和促进用户与应用程序中的窗口和小部件交互所需的各种细节。以下是一些这些组件的例子：
- en: '**GLib**: This is the basic core library and provides several data structures,
    wrappers for portability, and interfaces for runtime functionality such as the
    event loop, thread support, dynamic loading, and an object system. Glib itself
    is composed of components such as **GObject**, which provides an object model,
    and **GIO**, which provides high-level abstractions for I/O**.**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pango**: Pango is a library that provides text rendering and internationalization
    capabilities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cairo**: This is a 2D graphics library that takes care of drawing things
    on-screen and, tries to be as consistent across multiple devices, and handles
    details such as hardware acceleration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ATK**: ATK is the accessibility toolkit library that takes care of providing
    accessibility to input devices such as screen readers, magnifiers, and alternative
    input devices.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gtk also has an interface builder called **Glade**, which generates a gtk source
    code skeleton for rapid application development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: gtk uses the object-oriented model for representing widgets and windows. It
    leverages the GObject library to provide this abstraction. To use the gtk framework
    from Rust, we have the gtk-rs project, which contains many crates that follow
    the same naming convention as libraries that exist in gtk and provides native
    C bindings to these libraries. Among all the crates that the gtk-rs project contains,
    we'll be using the `gtk` crate to build our app.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The `gtk` crate provides the window and widget system for building GUIs and
    tries to model the same API as the native C library, though there are differences
    as Rust does not have an object-oriented type system. Widgets in the `gtk` crate
    are smart pointer types. To allow for flexibility when using the API, you can
    have many mutable references, similar to the one provided by interior mutability
    in Rust. Any non-trivial widget in `gtk` inherits from some base widget type.
    Rust supports this inheritance in widgets via the `IsA<T>` trait. For instance,
    the `gtk::Label` widget has an `impl` of `impl IsA<Widget> for Label`. Also, most
    widgets in `gtk` share functionality with each other—the `gtk` crate implements
    this with the idea of extension traits, such as the `WidgetExt` trait, for all
    widget types. Most widgets such as `gtk::Button` and `gtk::ScrollableWindow` implement
    the `WidgetExt` trait. A widget can also be downcast or upcast to other widgets
    in its hierarchy using the `Cast` trait. With that brief introduction aside, let's
    get into writing a desktop app in Rust.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Building a hacker news app using gtk-rs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `gtk` crate to build a simple hacker news app that fetches the
    top 10 trending stories from the [https://news.ycombinator.com/](https://news.ycombinator.com/)
    website. Hacker News is a website focusing on digital technologies and tech news
    from around the world. To start with, we have created a basic wireframe model
    of our app:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49b70584-a277-4793-8126-dc4419548ec4.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'At the very top, we have the app header bar, which has a Refresh button on
    the left that can update our stories on demand. A story is a news entry that''s
    posted by users on the Hacker News website. The header bar also contains the app
    title at the center and the usual window controls on the right. Below that, we
    have our main scrollable window where our stories will be rendered vertically
    as a story widget. The story widget is made up of two widgets: a widget for displaying
    the story''s name and its score, and another for rendering a link to the story
    that can be clicked on in the user''s default browser. Pretty simple!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: As we are using the `gtk` crate, which binds to native C libraries,
    we need to install the developmental C libraries for the gtk framework. For Ubuntu
    and Debian platforms, we can install these dependencies by running the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please refer to the gtk-rs documentation page at [http://gtk-rs.org/docs/requirements.html](http://gtk-rs.org/docs/requirements.html)
    for information on setting gtk up on other platforms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: To start things off, we'll create a new cargo project by running `cargo new
    hews`. We have creatively named our app **Hews**, which is short for **H** in
    hacker + **ews** from news.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the dependencies that we''ll need in our `Cargo.toml` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are using a bunch of crates here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`gtk`: This is used to build the GUI of the app. We use the bindings for gtk
    version `3.18` here.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reqwest`: This is used for fetching stories from the Hacker News API. `reqwest`
    is a high-level wrapper over the `hyper` crate. We are using the `reqwest` synchronous
    API for simplicity.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serde_json`: This is used for seamlessly converting the fetched JSON response
    from the network to a strongly typed `Story` struct.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serde`, `serde_derive`: These provide traits and implementations for automatically
    deriving serialization code for built-in Rust types. By using the `Serialize` and `Deserialize`
    traits from `serde_derive`, we can serialize and deserialize any native Rust type
    into a given format. `serde_json` relies on the same functionality to convert
    a `serde_json::Value` type into a Rust type.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To show news articles in our app, we'll fetch them by making HTTP requests to
    the official hacker news API, which is documented at [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
    We have divided our app into two modules. First, we have the `app` module, which
    contains all the UI-related functionality for rendering the app on-screen and
    handling UI state updates from the user. Second, we have the `hackernews` module,
    which provides APIs for fetching stories from the network. It runs in a separate
    thread so not block the GUI thread when network requests happen, which is a blocking
    I/O operation. From the hacker news API, a story is an item containing a news
    title and a link to the news, along with other properties such as how popular
    the story is and a list of comments on the story.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: To make this example simpler and easier to follow, our app does not have proper
    error handling and includes many `unwrap()` calls, which is a bad practice from
    an error handling perspective. After you are done exploring the demo, you are
    encouraged to integrate a better error handling strategy in the app. With that
    said, let's go through the code step by step.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll look at the entry point of our app in `main.rs`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our `main` function, we call `App::new()`, which returns an `App` instance,
    along with `rx`, which is a `mpsc::Receiver`. To keep our GUI decoupled from network
    requests, all state updates in hews are handled asynchronously via channels. The
    `App` instance internally invokes `mpsc::channel()`, giving back `tx` and `rx`.
    It stores the `tx` with it and also passes it to the network thread, allowing
    it to notify the UI of any new story. Following the `new` method call, we invoke
    `launch` on `app`, passing in the `rx`, which is used to listen for events from
    the network thread in the GUI thread.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's go through our `app` module in the `app.rs` module, which handles
    most of the orchestration needed to render our app on-screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about the widget explanation that follows, look
    for gtk-rs's excellent documentation at [https://gtk-rs.org/docs/gtk/](https://gtk-rs.org/docs/gtk/),
    where you can search for any widget and explore more about its properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have our `App` struct, which is the entry point for all things GUI:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This struct contains a bunch of fields:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`window`: This contains the base `gtk::Window` widget. Every gtk application
    starts with a window to which we can add child widgets in different layouts to
    design our GUI.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header`: This is a struct that''s defined by us and wraps a `gtk::HeaderBar`
    widget, which acts as the title bar for our app window.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stories`: This is a container `gtk::Box` widget that will store our stories
    vertically.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spinner`: This is a `gtk::Spinner` widget that provides a visual cue for loading
    stories.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx`: This is an mpsc `Sender` to send events from the GUI to the network thread.
    The messages are of type `Msg`, which is an enum:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our app starts with the initial state as `Loading` when the `fetch_posts` method
    is called from the `hackernews` module. We'll see that later. `NewStory` is the
    state that occurs when a new story is fetched. `Loaded` is the state that occurs
    when all of the stories are loaded and `Refresh` is sent when the user wants to
    reload the stories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the methods on the `App` struct. Here''s our `new` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `new` method first starts the gtk event loop using `gtk::init()`. If that
    fails, we exit, printing a message to the console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we create our `tx` and `rx` channel endpoints for communicating between
    the network thread and the GUI thread. Next, we create our `window`, which is
    a `TopLevel` window. Now, multiple stories might not fit into our app window if
    the window is resized, so we need a scrollable window here. For that, we will
    create a `ScrolledWindow` instance as `sw`. However, a gtk `ScrolledWindow` accepts
    only a single child within it and we need to store multiple stories, which is
    a problem. Fortunately, we can use the `gtk::Box` type, which is a generic container
    widget that''s used to lay out and organize child widgets. Here, we create a `gtk::Box`
    instance as `stories` with the `Orientation::Vertical` orientation so that each
    of our stories renders vertically on top of each other. We also want to show a
    spinner at the top of our scroll widget when the stories are being loaded, so
    we will create a `gtk::Spinner` widget and add it to `stories` to render it at
    the very top. We will also create our `Header` bar and pass a reference to `stories`
    as well as `tx`. Our header contains the refresh button and has a click handler,
    which needs the `stories` container to clear items within it, allowing us to load
    new stories:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we start composing our widgets. First, we add the `spinner` to `stories`.
    Then, we add the `stories` container widget to our scroll widget, `sw`, which
    is then added to our parent `window`. We also set the `window` size with `set_default_size`.
    We then set its title bar with `set_titlebar`, passing in our `header`. Following
    that, we attach a signal handler to our window:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will quit the app if we call `main_quit()`. The `Inhibit(false)` return
    type does not stop the signal from propagating to the default handler for `delete_event`.
    All widgets have a default signal handler. The signal handlers on the widgets
    in the gtk crate follow the naming convention of `connect_<event>` and take in
    a closure with the widget as their first parameter and the event object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `launch` method on `App`, which is called in `main.rs`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we enable the `window` widget, along with its child widgets. We make
    them visible by calling the `show_all` method as widgets in gtk are invisible
    by default. Next, we create our HTTP `Client` and wrap it in an `Arc` as we want
    to share it with our network thread. We then call `fetch_posts`, passing our client.
    Following that, we run our event loop by calling `run_event_loop`, passing in
    `rx`. The `fetch_posts` method is defined like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It starts our spinner animation by calling its `start` method, and sends the
    `Loading` message as the initial state. It then calls the `top_stories` function
    from the `hackernews` module, passing `10` as the number of stories to fetch and
    a `Sender` to notify the GUI thread of new stories.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling `fetch_posts`, we call the `run_event_loop` method on `App`,
    which is defined like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we get references to a bunch of objects that we'll use. Following that,
    we call `gtk::timeout_add`, which runs the given closure every 100 milliseconds.
    Within the closure, we poll on `rx` in a non-blocking way using `try_recv()` for
    events from the network or GUI thread. When we get a `NewStory` message, we call
    `render_story`. When we receive a `Loading` message, we disable the refresh button.
    In the case of the `Loaded` message, we stop our spinner and enable the refresh
    button so that the user can reload stories again. Finally, in the case of receiving
    a `Refresh` message, we start the spinner again and send the `Loading` message
    to the GUI thread itself, followed by calling the `top_stories` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `render_story` method is defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `render_story` method gets the `Story` instance as `s` and the `stories`
    container widget as arguments before creating two labels: `title_with_score`,
    which holds the story title along with its score, and `link_label`, which holds
    the link to the story. For the `link_label`, we will add a custom markup that
    contains an `<a>` tag with the URL. Finally, we put both these labels onto our
    `stories` container and call `show_all` at the end to make those labels visible
    on the screen.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Header` struct and its methods, which we mentioned previously, are part
    of the `App` struct and are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This struct contains the following fields:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`header`: A gtk `HeaderBar`, which is like a horizontal gtk `Box` that''s suitable
    for title bars for a window'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_btn`: A gtk `Button` that is used to reload stories on demand'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Header` also has three methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`new`: This creates a new `Header` instance. Within the new method, we create
    a new gtk `HeaderBar`, set its close button to show, and add a title. Then, we
    create a Refresh button and attach a click handler to it using the `connect_clicked`
    method, which takes in a closure. Within this closure, we iterate over all of
    the children of the scrolled window container, which are passed to this method
    as `story_container`. However, we skip the first one because the first widget
    is a `Spinner` and we want to keep it across multiple reloads to show its progress.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disable_refresh`: This disables the refresh button, setting its sensitivity
    to `false`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable_refresh`: This enables the refresh button, setting its sensitivity
    to `true`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s go through our `hackernews` module, which does all the heavy lifting
    of getting the stories as json from the API endpoint and parsing it as a `Story`
    instance using `serde_json`. Here''s the first piece of content of `hackernews.rs`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we have a declaration of the base URL endpoint, `HN_BASE_URL`, for the
    hackernews API that's hosted on firebase. Firebase is a real-time database from
    Google. Then, we have the `Story` struct declaration, annotated with the `Deserialize`
    and `Debug` traits. The `Deserialize` trait comes from the `serde_derive` crate,
    which provides a derive macro to convert any value into a native Rust type. We
    need it because want to be able to parse the incoming json reply from the network
    as a `Story` struct.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Story` struct contains the same fields as the ones that are found in the
    json reply from the stories endpoint. For more information on the json structure,
    refer to [https://github.com/HackerNews/API#items](https://github.com/HackerNews/API#items).
    Also, among all our fields in the `Story` struct, we have one field named `type`.
    However, `type` is also a keyword in Rust for declaring type aliases and it''s
    invalid for `type` to be a field of a struct, so we will name it `_type` instead.
    However, this wouldn''t parse as our json reply as a field named `type`. To solve
    this conflict, `serde` provides us with a field-level attribute to allow us to
    parse values, even in the case of such conflicts when using the `#[serde(rename
    = "type")]` attribute on the field. The value of `rename` should match whatever
    the value is in the incoming json response''s field name. Next, let''s look at
    the set of methods that are provided by this module:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our only public function that's been exposed by this module is `top_stories`.
    This function takes a reference to `Client`, which comes from the `reqwest` crate,
    then a `count` parameter specifying how many stories to retrieve, and a `Sender`
    instance `tx`, which can send messages of type `Msg`, an enum. `tx` is used to
    communicate to the GUI thread about the state of our network request. Initially,
    the GUI starts in the `Msg::Loading` state, which keeps the refresh button disabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Within this function, we first clone our copy of the `tx` sender and then spawn
    a thread where we'll use this `tx`. We spawn a thread so not to block the UI thread
    when the network request is in progress. Within the closure, we call `fetch_stories_parsed()`.
    In this method, we first construct our `/top_stories.json` endpoint by concatenating
    it with `HN_BASE_URL` using the `format!` macro. We then make a request to the
    constructed endpoint to get a list of all stories. We call the `text()` method
    to convert the response into a json string. The returned json response is a list
    of story IDs, each of which can be used to make another set of requests, which
    gives us detailed information on the story as another json object. We then parse
    this response using `serde_json::from_str(&body)`. This gives us a `Value` enum
    value, which is a parsed json array containing a list of story IDs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once we have the story IDs stored in `story_ids`, we explicitly convert
    it into an array by calling `as_array()` and then we `iter()` on it and limit
    the stories we want by calling `take(count)`, followed by calling `collect()`
    on it, which gives us back a `Vec<Story>`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we check whether our filtered story ID is empty. If it is, we set the
    `loaded` variable to `false`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `loaded` boolean value is used to send a notification to the main GUI thread
    if any of our story was loaded. Next, if the `filtered` list is not empty, we
    iterate over our `filtered` stories and construct a `story_url` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We make get requests for each constructed `story_url ` from the story `id`,
    take the json response, and parse it as a `Story` struct using the `serde_json::from_str`
    function. Following that, we send the story by wrapping it in `Msg::NewStory(story)`
    to the GUI thread using `tx_clone`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Once we have sent all the stories, we send a `Msg::Loaded` message to the GUI
    thread, which enables the refresh button so that the user can reload the stories
    again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'All right! It''s time for us to read popular news stories on our app. After
    running `cargo run`, we can see our stories being pulled and rendered in the window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/226a3f3d-1e2b-4998-9308-607251bb4cf4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Upon clicking the link of any for the stories, hews will open in your default
    browser. That's about it. We've made our GUI application in Rust using very few
    lines of code. Now, it's time for you to explore and experiment with the app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app works great, but there are lots of ways we can improve it. If you are
    feeling ambitious, you can take a look at the following challenges:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Improve error handling in the app and handle cases where the network is slow
    by adding retry mechanisms.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the number of stories that get loaded by placing an input field widget
    on the header bar, and parse and pass that number to the network thread.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a button to each story to view comments. When the user clicks on the comments
    button, the app should open a scrollable widget on the right and populate the
    comments in that story, one by one.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets can be styled using CSS. Try adding colors to the story container, depending
    on the popularity of posts, using the `gtk::StyleProvider` APIs.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other emerging GUI frameworks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen, the APIs exposed by the `gtk` crate can be a bit uncomfortable
    to write complex GUIs with. Fortunately, we have a wrapper crate called `relm`.
    The relm crate is inspired by the *Elm* language's architecture of `Model-View-Update`,
    which provides a simplistic approach for building reactive GUIs. Apart from relm,
    there are many other standalone GUI toolkits and crates in the works by the Rust
    community. One of the new and promising ones is `Azul`, which can be found at
    [https://azul.rs/](https://azul.rs/). It is a functional GUI framework that supports
    async I/O, along with features such as two-way data binding, which allows you
    to build reactive widgets and employs the principle of composition for building
    widgets, as opposed to the object-oriented model, which we explored in the gtk
    framework when building hews. As the rendering backend, Azul uses the performant
    Webrender rendering engine that's used in Servo from Mozilla.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Other notable mentions are `conrod` from the Piston Developers organization
    at [https://github.com/PistonDevelopers/conrod](https://github.com/PistonDevelopers/conrod),
    and `imgui-rs` at [https://github.com/Gekkio/imgui-rs](https://github.com/Gekkio/imgui-rs),
    which is a bindings library for the popular immediate mode ImGUI framework in
    C++.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a very brief tour of GUI development with Rust. This chapter gave us
    a glimpse into the current experience of developing GUI applications. At the time
    of writing, the experience isn't all that great, but there are emerging frameworks,
    such as Azul, that aim to take this experience to the next level.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about finding and fixing bugs in your program using
    debuggers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
