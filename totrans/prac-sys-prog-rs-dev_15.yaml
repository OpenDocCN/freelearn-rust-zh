- en: '*Chapter 12*: Writing Unsafe Rust and FFI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：编写 unsafe Rust 和 FFI'
- en: In the previous chapter, we learned about the network primitives built into
    the Rust Standard Library and saw how to write programs that communicate over
    TCP and UDP. In this chapter, we will conclude the book by covering a few advanced
    topics related to **unsafe Rust** and **foreign function interfaces** (**FFIs**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了内置在 Rust 标准库中的网络原语，并看到了如何编写通过 TCP 和 UDP 通信的程序。在本章中，我们将通过介绍一些与 **unsafe
    Rust** 和 **外部函数接口**（**FFIs**）相关的高级主题来结束本书。
- en: We have seen how the Rust compiler enforces rules of ownership for memory and
    thread safety. While this is a blessing most of the time, there may be situations
    when you want to implement a new low-level data structure or call out to external
    programs written in other languages. Or, you may want to perform other operations
    prohibited by the Rust compiler, such as dereferencing raw pointers, mutating
    static variables, or dealing with uninitialized memory. Have you wondered how
    the Rust Standard Library itself makes system calls to manage resources, when
    system calls involve dealing with raw pointers? The answer lies in understanding
    unsafe Rust and FFIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Rust 编译器如何强制执行内存和线程安全的所有权规则。虽然这大多数时候都是一种祝福，但可能存在您想要实现新的低级数据结构或调用用其他语言编写的外部程序的情况。或者，您可能想要执行
    Rust 编译器禁止的其他操作，例如取消引用原始指针、修改静态变量或处理未初始化的内存。您是否想过 Rust 标准库本身是如何进行系统调用来管理资源的，当系统调用涉及处理原始指针时？答案在于理解
    unsafe Rust 和 FFIs。
- en: In this chapter, we'll first look at why and how Rust code bases use unsafe
    Rust code. Then, we'll cover the basics of FFIs and talk about special considerations
    while working with them. We'll also write Rust code that calls a C function, and
    a C program that calls a Rust function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将探讨为什么以及如何使用 unsafe Rust 代码。然后，我们将介绍 FFIs 的基础知识，并讨论在使用它们时的特殊注意事项。我们还将编写调用
    C 函数的 Rust 代码，以及调用 Rust 函数的 C 程序。
- en: 'We will cover these topics in the following order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序介绍这些主题：
- en: Introducing unsafe Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 unsafe Rust
- en: Introducing FFIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 FFIs
- en: Reviewing guidelines for safe FFIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习安全 FFIs 的指南
- en: Calling Rust from C (project)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 调用 Rust（项目）
- en: Understanding the ABI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ABI
- en: By the end of this chapter, you will have learned when and how to use unsafe
    Rust. You will learn how to interface Rust to other programming languages, through
    FFIs, and learn how to work with them. You'll also get an overview of a few advanced
    topics, such as **application binary interfaces** (**ABIs**), conditional compilation,
    data layout conventions, and providing instructions to the linker. Understanding
    these will be helpful when building Rust binaries for different target platforms,
    and for linking Rust code with code written in other programming languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会何时以及如何使用 unsafe Rust。您将学习如何通过 FFIs 将 Rust 与其他编程语言接口，并学习如何与之交互。您还将了解一些高级主题的概述，例如
    **应用程序二进制接口**（**ABIs**）、条件编译、数据布局约定以及向链接器提供指令。了解这些内容将有助于构建针对不同目标平台的 Rust 二进制文件，以及将
    Rust 代码与用其他编程语言编写的代码链接。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Verify that `rustup`, `rustc`, and `cargo` have been installed correctly with
    the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证 `rustup`、`rustc` 和 `cargo` 是否已正确安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since this chapter involves compiling C code and generating a binary, you will
    need to set up the C development environment on your development machine. After
    setup, run the following command to verify that the installation is successful:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涉及编译 C 代码和生成二进制文件，您需要在您的开发机器上设置 C 开发环境。设置完成后，运行以下命令以验证安装是否成功：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this command does not execute successfully, please revisit your installation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此命令无法成功执行，请重新检查您的安装。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that those developing on a Windows platform use a Linux virtual
    machine to try out the code in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在 Windows 平台上开发的人员使用 Linux 虚拟机来尝试本章中的代码。
- en: The code in this section has been tested on Ubuntu 20.04 (LTS) x64 and should
    work on any other Linux variant.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码已在 Ubuntu 20.04（LTS）x64 上进行测试，并应在任何其他 Linux 变体上工作。
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 Git 仓库可以在 [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12)
    找到。
- en: Introducing unsafe Rust
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍不安全 Rust
- en: So far in this book, we've seen and used Rust language that enforces memory
    and type safety at compilation time and prevents various kinds of undefined behavior,
    such as memory overflows, null or invalid pointer constructions, and data races.
    This is *safe* Rust. In fact, the Rust Standard Library gives us good tools and
    utilities to write safe, idiomatic Rust, and helps to keep the program safe (and
    you sane!).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们看到了并使用了 Rust 语言，它在编译时强制执行内存和类型安全，并防止各种未定义的行为，例如内存溢出、空或无效指针构造以及数据竞争。这是
    *安全* Rust。实际上，Rust 标准库为我们提供了良好的工具和实用程序来编写安全、惯用的 Rust，并有助于保持程序安全（以及您的心情！）。
- en: But in some situations, the compiler can *get in the way*. The Rust compiler
    performs static analysis of code that is conservative (meaning the Rust compiler
    does not mind generating a few false positives and rejecting valid code, as long
    as it does not let bad code get through). You, as a programmer, know that a piece
    of code is safe, but the compiler thinks it is risky, so it rejects this code.
    This includes operations such as system calls, type coercions, and direct manipulations
    of memory pointers, which are used in the development of several categories of
    system software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，编译器可能会 *妨碍*。Rust 编译器对代码进行保守的静态分析（这意味着 Rust 编译器不介意生成一些假阳性并拒绝有效代码，只要它不让坏代码通过）。您作为程序员知道某段代码是安全的，但编译器认为它是危险的，因此拒绝此代码。这包括系统调用、类型转换和直接操作内存指针等操作，这些操作用于开发几类系统软件。
- en: Another example is in embedded systems where registers are accessed through
    a fixed memory address and require the dereferencing of pointers. So, to enable
    such actions, the Rust language provides the `unsafe` keyword. For Rust as a system
    programming language, it is essential to enable the programmer to have the means
    to write low-level code to interface directly with the operating system, bypassing
    the Rust Standard Library if needed. *This is unsafe Rust*. This is the part of
    the Rust language that does not adhere to the rules of the borrow checker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在嵌入式系统中，寄存器通过固定的内存地址访问并需要指针解引用。因此，为了启用此类操作，Rust 语言提供了 `unsafe` 关键字。对于
    Rust 作为系统编程语言，它对于使程序员能够编写低级代码以直接与操作系统接口至关重要，如果需要，可以绕过 Rust 标准库。*这是不安全 Rust*。这是
    Rust 语言中不遵循借用检查器规则的部分。
- en: Unsafe Rust can be thought of as a superset of safe Rust. It is a superset because
    it allows you to do all the things you can do in standard Rust, but you can do
    more things that are otherwise prohibited by the Rust compiler. In fact, Rust's
    own compiler, and the standard library, include unsafe Rust code that is carefully
    written.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全 Rust 可以被视为安全 Rust 的超集。它是超集，因为它允许您做所有在标准 Rust 中可以做的事情，但您可以做更多被 Rust 编译器禁止的事情。实际上，Rust
    的编译器和标准库都包含了精心编写的 `unsafe` Rust 代码。
- en: How do you distinguish between safe and unsafe Rust code?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您如何区分安全和不安全 Rust 代码？
- en: 'Rust provides a convenient and intuitive mechanism where a block of code can
    be enclosed within an unsafe block using the `unsafe` keyword. Try the following
    code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了一种方便且直观的机制，可以使用 `unsafe` 关键字将代码块封装在 `unsafe` 块中。尝试以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compile this code with `cargo check` (or run it from Rust playground IDE).
    You''ll see the following error message:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo check`（或从 Rust playground IDE 运行）编译此代码。您将看到以下错误信息：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now modify the code by enclosing the dereferencing of the raw pointer
    within an `unsafe` block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过将原始指针的解引用封装在 `unsafe` 块中来修改代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will see that the compilation is successful now, even though this code can
    potentially cause undefined behavior. This is because, once you enclose some code
    within an unsafe block, the compiler expects the programmer to ensure the safety
    of unsafe code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到现在编译成功，尽管这段代码可能引发未定义的行为。这是因为一旦将某些代码封装在 `unsafe` 块中，编译器就期望程序员确保不安全代码的安全性。
- en: Let's now look at the kind of operations unsafe Rust enables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看不安全 Rust 允许的操作类型。
- en: Operations in unsafe Rust
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安全 Rust 中的操作
- en: There are really only five key operations in the *unsafe* category – dereferencing
    a raw pointer, working with mutable static variables, implementing unsafe traits,
    calling an external function through an FFI interface, and sharing union structs
    across FFI boundaries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在*unsafe*类别中只有五个关键操作——解引用原始指针、处理可变静态变量、实现不安全特性和通过FFI接口调用外部函数，以及跨FFI边界共享联合结构体。
- en: 'We''ll look at the first three in this section and the last two in the next
    section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中查看前三个，在下一节中查看最后两个：
- en: '`*const T` is a pointer type that corresponds to `&T` (immutable reference
    type) in safe Rust, and `*mut T` is a pointer type that corresponds to `&mut T`
    (mutable reference type in safe Rust). Unlike Rust reference types, these raw
    pointers can have both immutable and mutable pointers to a value at the same time
    or have multiple pointers simultaneously to the same value in memory. There is
    no automatic cleanup of memory when these pointers go out of scope, and these
    pointers can be null or refer to invalid memory locations too. The guarantees
    provided by Rust for memory safety do not apply to these pointer types. Examples
    of how to define and access pointers in an unsafe block are shown next:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*const T`是一个指针类型，对应于安全Rust中的`&T`（不可变引用类型），而`*mut T`是一个指针类型，对应于`&mut T`（安全Rust中的可变引用类型）。与Rust引用类型不同，这些原始指针可以同时具有对值的不可变和可变引用，或者同时有多个指针指向内存中的同一值。当这些指针超出作用域时，没有自动清理内存，这些指针也可以是null或指向无效的内存位置。Rust提供的内存安全保证不适用于这些指针类型。下面将展示如何在`unsafe`块中定义和访问指针的示例：'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You'll note from this code that we've simultaneously created both an immutable
    reference and a mutable reference to the same value, by casting from the corresponding
    immutable and mutable reference types. Note that to create the raw pointers, we
    do not need an `unsafe` block, but only for dereferencing them. This is because
    dereferencing a raw pointer may result in unpredictable behavior as the borrow
    checker does not take responsibility for verifying its validity or lifetime.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到从这段代码中，我们通过从相应的不可变和可变引用类型进行转换，同时创建了同一值的不可变引用和可变引用。请注意，为了创建原始指针，我们不需要`unsafe`块，但需要解引用它们。这是因为解引用原始指针可能会导致不可预测的行为，因为借用检查器不负责验证其有效性或生命周期。
- en: '`unsafe` block. In the example shown next, we are declaring a mutable static
    variable that is initialized with a default value for the number of threads to
    be spawned. Then, in the `main()` function, we are checking for an environment
    variable, which if specified will override the default. This override of the value
    in the static variable must be enclosed in an *unsafe* block:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsafe`块。在下面的示例中，我们声明了一个可变静态变量，它使用默认值初始化线程数量。然后，在`main()`函数中，我们检查环境变量，如果指定了该变量，它将覆盖默认值。在静态变量中的值覆盖必须包含在`*unsafe*`块中：'
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code snippet shows the declaration of a mutable static variable, `THREAD_COUNT`,
    initialized to `4`. When the `main()` function executes, it looks for an environmental
    variable with the name `THREAD_COUNT`. If the `env` variable is found, it calls
    the `change_thread_count()` function, which mutates the value of the static variable
    in an `unsafe` block. The `main()` function then prints out the value in an `unsafe`
    block.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段展示了可变静态变量的声明，`THREAD_COUNT`，初始化为`4`。当`main()`函数执行时，它会查找名为`THREAD_COUNT`的环境变量。如果找到`env`变量，它将调用`change_thread_count()`函数，在`unsafe`块中修改静态变量的值。然后`main()`函数在`unsafe`块中打印出该值。
- en: '`Send` or `Sync` traits. To implement these two traits for the raw pointer,
    we have to use unsafe Rust, as shown:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`或`Sync`特性。为了为原始指针实现这两个特性，我们必须使用不安全Rust，如下所示：'
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The reason for the `unsafe` keyword is because raw pointers have untracked ownership,
    which then becomes the responsibility of the programmer to track and manage.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`unsafe`关键字的原因是因为原始指针具有未跟踪的所有权，这随后成为程序员的职责来跟踪和管理。'
- en: There are two more features of unsafe Rust that are related to interfacing with
    other programming languages, which we will discuss in the next section on FFIs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言接口相关的不安全Rust有两个更多特性，我们将在下一节关于FFI的讨论中讨论。
- en: Introducing FFIs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍FFI
- en: In this section, we'll understand what FFI is, and then see the two unsafe Rust
    features related to FFI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解FFI是什么，然后查看与FFI相关的两个不安全Rust特性。
- en: 'To understand FFI, let''s look at the following two examples:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解FFI，让我们看看以下两个示例：
- en: There is a blazing-fast machine learning algorithm written in Rust for linear
    regression. A Java or Python developer wants to use this Rust library. How can
    this be done?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个用于线性回归的Rust编写的快速机器学习算法。一个Java或Python开发者想要使用这个Rust库。这该如何实现？
- en: You want to make Linux **syscalls** without using the Rust Standard Library
    (which essentially means you want to either implement a feature that's not available
    in the standard library or want to improve an existing feature). How would you
    do it?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在不用Rust标准库的情况下（这基本上意味着你想实现标准库中没有的功能或想改进现有功能）进行Linux系统调用。你将如何做？
- en: While there may be other ways to solve this problem, one popular method is to
    use FFI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能有其他方法可以解决这个问题，但一种流行的方法是使用FFI。
- en: 'In the first example, you can wrap the Rust library with an FFI defined in
    Java or Python. In the second example, Rust has a keyword, `extern`, with which
    an FFI to a C function can be set up and called. Let''s see an example of the
    second case next:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，你可以用Java或Python中定义的FFI包装Rust库。在第二个例子中，Rust有一个关键字`extern`，可以用它来设置和调用C函数的FFI。让我们看看第二个案例的例子：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in the `main()` function, we are invoking the `getenv()` external C function
    (instead of directly using the Rust Standard Library) to retrieve the value of
    the `MY_VAR` environment variable. The `getenv()` function accepts a `*const c_char`
    type parameter as input. To create this type, we are first instantiating the `CString`
    type, passing in the name of the environment variable, and then converting it
    into the required function input parameter type using the `as_ptr()` method. The
    `getenv()` function returns a `*mut c_char` type. To convert this into a Rust-compatible
    type, we are using the `Cstr::from_ptr()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`main()`函数中，我们正在调用外部C函数`getenv()`（而不是直接使用Rust标准库）来检索`MY_VAR`环境变量的值。`getenv()`函数接受一个`*const
    c_char`类型的参数作为输入。为了创建这种类型，我们首先实例化`CString`类型，传入环境变量的名称，然后使用`as_ptr()`方法将其转换为所需的函数输入参数类型。`getenv()`函数返回一个`*mut
    c_char`类型的值。为了将其转换为Rust兼容的类型，我们使用`Cstr::from_ptr()`函数。
- en: 'Note the two main considerations here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的两个主要考虑因素：
- en: We are specifying the call to the C function within an `extern "C"` block. This
    block contains the signature of the function that we want to call. Note that the
    data types in the function are not Rust data types, but those that belong to C.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`extern "C"`块中指定对C函数的调用。此块包含我们想要调用的函数的签名。请注意，函数中的数据类型不是Rust数据类型，而是属于C的数据类型。
- en: We are importing a couple of modules – `std::ffi` and `std::os::raw` – from
    the Rust Standard Library. The `ffi` module provides utility functions and data
    structures related to FFI bindings, which makes it easier to do data mapping across
    non-Rust interfaces. We are using the `CString` and `CStr` types from the `ffi`
    module, to transfer UTF-8 strings to and from C. The `os::raw` module contains
    platform-specific types that map to the C data types so that the Rust code that
    interacts with C will refer to the correct types.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从Rust标准库中导入了一些模块——`std::ffi`和`std::os::raw`。`ffi`模块提供了与FFI绑定相关的实用函数和数据结构，这使得在非Rust接口之间进行数据映射变得更容易。我们使用`ffi`模块中的`CString`和`CStr`类型，在C之间传输UTF-8字符串。`os::raw`模块包含映射到C数据类型的平台特定类型，以便与C交互的Rust代码引用正确的类型。
- en: 'Now, let''s run the program using the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令运行程序：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You'll see the value of `MY_VAR` printed out to the console. With this, we have
    successfully retrieved the value of an environment variable using a call to an
    external C function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到`MY_VAR`的值被打印到控制台。通过这种方式，我们已经成功使用外部C函数调用来检索环境变量的值。
- en: Recall that we learned how to get and set environment variables in previous
    chapters using the Rust Standard Library. Now we have done something similar,
    but this time using the Rust FFI interface to invoke a C library function. Note
    that the call to the C function is enclosed in an `unsafe` block.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在前面的章节中学习了如何使用Rust标准库来获取和设置环境变量。现在我们已经做了类似的事情，但这次是使用Rust FFI接口调用C库函数。请注意，对C函数的调用被包含在一个`unsafe`块中。
- en: So far, we've seen how to invoke a C function from Rust. Later, in the *Calling
    Rust from C (project)* section, we'll see how to do it the other way around, that
    is, invoke a Rust function from C.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在Rust中调用C函数。稍后，在*从C调用Rust（项目）*部分，我们将看到如何反过来操作，即从C调用Rust函数。
- en: Let's now take a look at another feature of unsafe Rust, which is to define
    and access fields of a union struct, for communicating with a C function across
    an FFI interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下不安全的Rust的另一个特性，即定义和访问联合结构体的字段，以便通过FFI接口与C函数进行通信。
- en: 'Unions are data structures used in C, and are not memory-safe. This is because
    in a union type, you can set the instance of a `union` to one of the invariants
    and access it as another invariant. Rust does not directly provide `union` as
    a type in safe Rust. Rust, however, has a type of union called a `enum` data type
    in safe Rust. Let''s see an example of `union`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 联合结构体是在C中使用的，并且不是内存安全的。这是因为在一个联合类型中，你可以将一个`union`的实例设置为其中一个不变量，并以另一个不变量的方式访问它。Rust不直接在安全Rust中提供`union`作为类型。然而，Rust在安全Rust中有一个称为`enum`的联合类型。让我们看看`union`的一个例子：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the code shown, we are first using a `repr(C)` annotation, which tells the
    compiler that the order, size, and alignment of fields in the `MyUnion` union
    is what you would expect in the C language (we''ll discuss more about `repr(C)`
    in the *Understanding the ABI* section). We''re then defining two invariants of
    the union: one is an integer of type `u32` and the other is a float of type `f32`.
    For any given instance of this union, only one of these invariants is valid. In
    the code, we''re creating an instance of this union, initializing it with a `float`
    invariant, and then accessing its value from the `unsafe` block.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，我们首先使用`repr(C)`注解，这告诉编译器`MyUnion`联合结构体中字段的顺序、大小和对齐方式与C语言中预期的一致（我们将在*理解ABI*部分中讨论更多关于`repr(C)`的内容）。然后我们定义联合结构体的两个不变量：一个是`u32`类型的整数，另一个是`f32`类型的浮点数。对于这个联合结构体的任何给定实例，只有一个这些不变量是有效的。在代码中，我们创建了这个联合结构体的一个实例，使用`float`不变量初始化它，然后从`unsafe`块中访问其值。
- en: 'Run the program with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You''ll see the value `f is 2.000` printed to your terminal. So far, it looks
    right. Now, let''s try to access the union as an integer, instead of a float type.
    To do this, just alter one line of code. Locate the following line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在终端上看到打印出`f is 2.000`的值。到目前为止，看起来是正确的。现在，让我们尝试将联合结构体作为整数而不是浮点类型来访问。为此，只需更改一行代码。定位以下行：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Change it to the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 改成以下内容：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program again. This time, you won''t get an error but you''ll see an
    invalid value printed like this. The reason is that the value in the memory location
    pointed to is now being interpreted as an integer even though we had stored a
    float value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序。这次，你不会得到错误，但你将看到像这样打印出无效值。原因是现在指向的内存位置中的值现在被解释为整数，尽管我们存储了一个浮点数值：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using unions in C is dangerous unless it is done with the utmost care, and Rust
    provides the ability to work with unions as part of unsafe Rust.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中使用联合结构体是危险的，除非做得非常小心，而Rust提供了在`unsafe Rust`中与联合结构体一起工作的能力。
- en: So far, you've seen what unsafe Rust and FFI are. You've also seen examples
    of calling unsafe and external functions. In the next section, we'll discuss guidelines
    for creating safe FFI interfaces.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了`unsafe Rust`和FFI是什么。你也看到了调用`unsafe`和外部函数的例子。在下一节中，我们将讨论创建安全FFI接口的指南。
- en: Reviewing guidelines for safe FFIs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查安全的FFI指南
- en: 'In this section, we''ll look at a few guidelines to keep in mind while interfacing
    with other languages using FFI in Rust:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在使用Rust中的FFI与其他语言进行接口时需要记住的一些指南：
- en: '`extern` keyword in Rust is inherently unsafe, and such calls must be done
    from an `unsafe` block.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust中的`extern`关键字本身是不安全的，此类调用必须从`unsafe`块中进行。
- en: '`#repr(C)` annotation) is important to maintain memory safety. We''ve seen
    an example earlier of how to use this. Another thing to note is that only C-compatible
    types should be used as parameters or return values for external functions. Examples
    of C-compatible types in Rust include integers, floats, `repr(C)`-annotated structs,
    and pointers. Examples of Rust types incompatible with C include trait objects,
    dynamically sized types, and enums with fields. There are tools available such
    as `rust-bindgen` and `cbindgen` that can help in generating types that are compatible
    between Rust and C (with some caveats).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#repr(C)`注解对于保持内存安全非常重要。我们之前已经看到了如何使用这个注解的例子。另一个需要注意的事项是，外部函数的参数或返回值应仅使用与C兼容的类型。在Rust中，与C兼容的类型包括整数、浮点数、`repr(C)`注解的结构体和指针。与C不兼容的Rust类型包括特质对象、动态大小类型和具有字段的枚举。有一些工具，如`rust-bindgen`和`cbindgen`，可以帮助生成Rust和C之间兼容的类型（有一些注意事项）。'
- en: '`int` and `long`, which means the exact length of these types vary based on
    the platform architecture. When interacting with C functions that use these types,
    the Rust Standard Library `std::raw` module can be used, which offers type aliases
    that are portable across platforms. `c_char` and `c_uint` are two examples of
    raw types we used in an example earlier. In addition to the standard library,
    the `libc` crate also provides such portable type aliases for these data types.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 和 `long`，这意味着这些类型的长度根据平台架构而变化。当与使用这些类型的 C 函数交互时，可以使用 Rust 标准库 `std::raw`
    模块，该模块提供跨平台的可移植类型别名。`c_char` 和 `c_uint` 是我们在早期示例中使用的原始类型中的两个例子。除了标准库之外，`libc`
    crate 也为这些数据类型提供了这样的可移植类型别名。'
- en: '**References and pointers**: Due to differences between C''s pointer types
    and Rust''s reference types, Rust code should not use reference types but rather
    pointer types while working across FFI boundaries. Any Rust code that dereferences
    a pointer type must make null checks before use.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用和指针**：由于 C 的指针类型和 Rust 的引用类型之间存在差异，Rust 代码在跨 FFI 边界工作时不应使用引用类型，而应使用指针类型。任何解引用指针类型的
    Rust 代码必须在使用之前进行空检查。'
- en: '`Drop` trait for any type that is transmitted directly to foreign code. It
    is even safer to use only `Copy` types for use across FFI boundaries.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任何直接传递给外部代码的类型提供 `Drop` 特性。仅使用 `Copy` 类型跨 FFI 边界使用则更为安全。
- en: '`std::panic::catch_unwind` or `#[panic_handler]` (which we saw in [*Chapter
    9*](B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150), *Managing* *Concurrency*).
    This will ensure that the Rust code will not abort or return in an unstable state.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::panic::catch_unwind` 或 `#[panic_handler]`（我们在 [*第 9 章*](B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150)，*管理*
    *并发性*）中看到）。这将确保 Rust 代码不会在不稳定状态下终止或返回。'
- en: '**Exposing a Rust library to a foreign language**: Exposing a Rust library
    and its functions to a foreign language (such as Java, Python, or Ruby) should
    only be done through a C-compatible API.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 Rust 库暴露给外语**：将 Rust 库及其函数暴露给外语（如 Java、Python 或 Ruby）应仅通过 C 兼容的 API 完成。'
- en: This concludes the section on writing safe FFI interfaces. In the next section,
    we'll see an example of using a Rust library from C code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于编写安全 FFI 接口的章节。在下一节中，我们将看到一个从 C 代码中使用 Rust 库的示例。
- en: Calling Rust from C (project)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C 调用 Rust（项目）
- en: In this section, we will demonstrate the setup needed to build a Rust shared
    library (with a `.so` extension on Linux) incorporating an FFI interface and invoke
    it from a C program. The C program would be a simple program that just prints
    out a greeting message. The example is deliberately kept simple to enable you
    (as you're not expected to be familiar with complex C syntax) to focus on the
    steps involved, and for easy verification of this first FFI program in a variety
    of operating system environments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示构建一个 Rust 共享库（在 Linux 上具有 `.so` 扩展名）所需的设置，该库包含 FFI 接口，并从 C 程序中调用它。该
    C 程序将是一个简单的程序，仅打印问候消息。示例故意保持简单，以便您（由于您不需要熟悉复杂的 C 语法）可以专注于涉及到的步骤，并便于在各种操作系统环境中验证此第一个
    FFI 程序。
- en: 'Here are the steps that we will go through to develop and test a working example
    of a C program that calls a function from a Rust library using the FFI interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将采取的步骤，以开发并测试一个 C 程序的工作示例，该程序使用 FFI 接口从 Rust 库中调用函数：
- en: Create a new Cargo lib project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Cargo lib 项目。
- en: Modify `Cargo.toml` to specify that we want a shared library to be built.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Cargo.toml` 以指定要构建共享库。
- en: Write an FFI in Rust (in the form of a C-compatible API).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Rust 中编写 FFI（以 C 兼容的 API 形式）：
- en: Build the Rust shared library.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 Rust 共享库。
- en: Verify whether the Rust shared library has been built correctly.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 Rust 共享库是否已正确构建。
- en: Create a C program that invokes a function from the Rust shared library.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用 Rust 共享库中函数的 C 程序。
- en: Build the C program specifying the path of the Rust shared library.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 Rust 共享库路径构建 C 程序。
- en: Set `LD_LIBRARY_PATH`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `LD_LIBRARY_PATH`。
- en: Run the C program.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 C 程序。
- en: 'Let''s get going and execute the aforementioned steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始执行上述步骤：
- en: 'Create a new cargo project:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 cargo 项目：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following to `Cargo.toml`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `Cargo.toml` 中：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write an FFI in Rust in `src/lib.rs`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/lib.rs` 中编写 FFI（以 C 兼容的 API 形式）：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `#[no_mangle]` annotation tells the Rust compiler that the `see_ffi_in_action()`
    function should be accessible to external programs with the same name. Otherwise,
    by default, the Rust compiler alters it.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#[no_mangle]` 注解告诉 Rust 编译器，`see_ffi_in_action()` 函数应该可以被具有相同名称的外部程序访问。否则，默认情况下，Rust
    编译器会修改它。'
- en: The function uses the `extern "C"` keyword. As discussed earlier, the Rust compiler
    makes any functions marked with `extern` compatible with C code. The `"C"` keyword
    in `extern "C"` indicates the standard C calling convention on the target platform.
    In this function, we are simply printing out a greeting.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数使用了`extern "C"`关键字。如前所述，Rust编译器使标记为`extern`的任何函数与C代码兼容。`extern "C"`中的`"C"`关键字表示目标平台上的标准C调用约定。在这个函数中，我们只是打印出问候语。
- en: 'Build the Rust shared library from the `ffi` folder with the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从`ffi`文件夹构建Rust共享库：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Verify whether the shared library has been built correctly:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证共享库是否已正确构建：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: .dylib extension on the Mac platform.)
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在Mac平台上为`.dylib`扩展名。）
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create a C program that invokes the function from the Rust shared library
    that we have built. Create a `rustffi.c` file in the root of the `ffi` project
    folder and add the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个C程序，调用我们构建的Rust共享库中的函数。在`ffi`项目文件夹的根目录中创建一个`rustffi.c`文件，并添加以下代码：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a simple C program that includes a header file and has a `main()` function
    that in turn invokes a `see_ffi_in_action()` function. At this point, the C program
    does not know where this function is located. We''ll provide this information
    to the C compiler when we build the binary. Let''s now write the header file that''s
    referred to in this program. Create a `rustffi.h` file in the same folder as the
    C source file, and include the following:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的C程序，它包含一个头文件，并有一个`main()`函数，该函数反过来调用一个`see_ffi_in_action()`函数。在这个时候，C程序不知道这个函数在哪里。当我们构建二进制文件时，我们将提供这个信息给C编译器。现在让我们编写这个程序中提到的头文件。在C源文件相同的文件夹中创建一个`rustffi.h`文件，并包含以下内容：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This header file declares the function signature, which denotes that this function
    does not return any value or take any input parameter.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此头文件声明了函数签名，表示此函数不返回任何值也不接受任何输入参数。
- en: 'Build the C binary with the following command, from the root folder of the
    project:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从项目的根目录构建C二进制文件：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set the `LD_LIBRARY_PATH` environment variable, which in Linux specifies the
    paths in which the libraries will be searched:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`LD_LIBRARY_PATH`环境变量，在Linux中指定库将被搜索的路径：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the executable with the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行可执行文件：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see the following message displayed on your terminal:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端上看到以下消息：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you have reached this far, congratulations!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，恭喜你！
- en: You have written a shared library in Rust that contains a function with a C-compatible
    API. You have then invoked this Rust library from a C program. This is FFI in
    action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用Rust编写了一个包含具有C兼容API的函数的共享库。然后，你从C程序中调用了这个Rust库。这就是FFI（Foreign Function
    Interface）的作用。
- en: Understanding the ABI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ABI
- en: This section provides a brief introduction to the ABI and a few related (advanced)
    features of Rust that deal with conditional compilation options, data layout conventions,
    and link options.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了ABI以及一些与Rust相关的（高级）特性，这些特性涉及条件编译选项、数据布局约定和链接选项。
- en: The **ABI** is a set of conventions and standards that compilers and linkers
    adhere to, for function-calling conventions, and for specifying data layouts (type,
    alignment, offset).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**ABI**是一组约定和标准，编译器和链接器遵循这些约定和标准，用于函数调用约定以及指定数据布局（类型、对齐、偏移）。'
- en: To understand the significance of the ABI, let's draw an analogy with APIs,
    which are a well-known concept in application programming. When a program wants
    to access an external component or library at the source-code level, it looks
    for the definition of the API exposed by that external component. The external
    component can be a library or an external service accessible over the network.
    The API specifies the name of the functions that can be called, the parameters
    (along with their names and data types) that need to be passed to invoke the function,
    and the type of value returned from the function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解ABI的重要性，让我们通过API进行类比，API是应用编程中众所周知的概念。当程序需要在源代码级别访问外部组件或库时，它会寻找外部组件暴露的API定义。外部组件可以是库或通过网络可访问的外部服务。API指定了可以调用的函数名称，需要传递给函数调用的参数（包括它们的名称和数据类型），以及函数返回值的类型。
- en: An ABI can be seen as the equivalent of an API but at the binary level. The
    compiler and linker need a way to specify how a calling program can locate the
    called function within a binary object file, and how to deal with the arguments
    and return values (types and order of arguments and return type). But unlike source
    code, in the case of the binaries produced, details such as the length of integers,
    padding rules, and whether the function parameters are stored on the stack or
    registers vary by platform architecture (for example, x86, x64, AArch32) and operating
    system (for example, Linux and Windows). A 64-bit operating system can have different
    ABIs for executing 32-bit and 64-bit binaries. A Windows-based program will not
    know how to access a library built on Linux, as they use different ABIs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ABI可以看作是API在二进制层面的等价物。编译器和链接器需要一种方式来指定调用程序如何在二进制对象文件中定位被调用函数，以及如何处理参数和返回值（参数的类型和顺序以及返回类型）。但与源代码不同，在生成的二进制文件的情况下，诸如整数长度、填充规则以及函数参数是存储在栈上还是寄存器中等细节会因平台架构（例如，x86、x64、AArch32）和操作系统（例如，Linux和Windows）而异。64位操作系统可以为执行32位和64位二进制文件具有不同的ABI。基于Windows的程序将不知道如何访问在Linux上构建的库，因为它们使用不同的ABI。
- en: 'While the study of ABIs is a specialized topic in itself, it is sufficient
    to understand the significance of ABIs and see what features Rust provides to
    specify ABI-related parameters while writing code. We''ll cover the following
    – *conditional compilation options*, *data layout conventions*, and *link options*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ABIs的研究本身就是一个专业化的主题，但了解ABIs的重要性以及Rust在编写代码时提供哪些功能来指定与ABI相关的参数就足够了。我们将涵盖以下内容
    – *条件编译选项*、*数据布局约定*和*链接选项*：
- en: '`cfg` macro. The following are examples of `cfg` options:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cfg`宏。以下是一些`cfg`选项的示例：'
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These annotations are attached to a function declaration as shown in this example:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些注释被附加到函数声明中，如下例所示：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: More details about the various conditional compilation options can be found
    at [https://doc.rust-lang.org/reference/conditional-compilation.html](https://doc.rust-lang.org/reference/conditional-compilation.html).
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于各种条件编译选项的详细信息可以在[https://doc.rust-lang.org/reference/conditional-compilation.html](https://doc.rust-lang.org/reference/conditional-compilation.html)找到。
- en: '`#[repr(Rust)]`. But if there is data that needs to pass through an FFI boundary,
    the accepted standard is to use the data layout of C (annotated as `#[repr(C)]`
    ). In this layout, the order, size, and alignment of fields are as it is done
    in C programs. This is important to ensure the compatibility of data across the
    FFI boundary.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[repr(Rust)]`。但如果需要通过FFI边界传递数据，则接受的标准是使用C的数据布局（注释为`#[repr(C)]`）。在这个布局中，字段顺序、大小和对齐方式与C程序中的方式相同。这对于确保数据在FFI边界上的兼容性非常重要。'
- en: Rust guarantees that if the `#[repr(C)]` attribute is applied to a struct, the
    layout of the struct will be compatible with the platform's representation in
    C. There are automated tools, such as `cbindgen`, that can help generate the C
    data layout from Rust programs.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rust保证，如果将`#[repr(C)]`属性应用于结构体，则该结构体的布局将与平台在C中的表示兼容。有一些自动化工具，如`cbindgen`，可以帮助从Rust程序生成C数据布局。
- en: '`link` annotation. Take the following example:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`注释。以下是一个示例：'
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `#[link(...)]` attribute is used to instruct the linker to link against
    `my_library` in order to resolve the symbols. It instructs the Rust compiler how
    to link to native libraries. This annotation can also be used to specify the kind
    of library to link to (*static* or *dynamic*). The following annotation tells
    `rustc` to link to a *static* library with the name `my_other_library`:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#[link(...)]`属性用于指示链接器链接到`my_library`以解析符号。它指导Rust编译器如何链接到本地库。此注释还可以用于指定要链接的库的类型（*静态*或*动态*）。以下注释告诉`rustc`链接到名为`my_other_library`的*静态*库：'
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this section, we've seen what an ABI is and its significance. We've also
    looked at how to specify instructions to the compiler and linker through various
    annotations in code, for aspects such as the target platform, operating system,
    data layout, and link instructions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了ABI是什么以及它的意义。我们还探讨了如何通过代码中的各种注释来指定对编译器和链接器的指令，例如目标平台、操作系统、数据布局和链接指令。
- en: 'This concludes this section. The intent of this section was only to introduce
    a few advanced topics related to the ABI, FFI, and associated instructions to
    the compiler and linker. For more details, refer to the following link: [https://doc.rust-lang.org/nomicon/](https://doc.rust-lang.org/nomicon/).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本节。本节的目的是仅介绍与ABI、FFI和相关指令有关的一些高级主题。更多详情，请参阅以下链接：[https://doc.rust-lang.org/nomicon/](https://doc.rust-lang.org/nomicon/)。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the basics of unsafe Rust and understood the key
    differences between safe and unsafe Rust. We saw how unsafe Rust enables us to
    perform operations that would not be allowed in safe Rust, such as dereferencing
    raw pointers, accessing or mutating static variables, working with unions, implementing
    unsafe traits, and calling external functions. We also looked at what a foreign
    function interface is, and how to write one in Rust. We wrote an example of invoking
    a C function from Rust. Also, in the example project, we wrote a Rust shared library
    and invoked it from a C program. We saw guidelines for how to write safe FFIs
    in Rust. We took a look at the ABI and annotations that can be used to specify
    conditional compilation, data layout, and link options.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们回顾了不安全Rust的基础知识，并了解了安全Rust和不安全Rust之间的关键区别。我们看到了不安全Rust如何使我们能够执行在安全Rust中不被允许的操作，例如取消引用原始指针、访问或修改静态变量、与联合体一起工作、实现不安全特质以及调用外部函数。我们还探讨了什么是外函数接口，以及如何在Rust中编写一个。我们编写了一个从Rust调用C函数的示例。此外，在示例项目中，我们编写了一个Rust共享库，并从C程序中调用它。我们看到了如何在Rust中编写安全的FFI的指南。我们还查看了一些可以用来指定条件编译、数据布局和链接选项的ABI和注解。
- en: With this, we conclude this chapter, and also this book.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们结束了这一章，也结束了这本书。
- en: I thank you for joining me on this journey into the world of system programming
    with Rust, and wish you the very best with exploring the topic further.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我感谢您与我一起踏上探索Rust系统编程世界的旅程，并祝愿您在进一步探索这个主题时一切顺利。
