- en: '*Chapter 10*: Working with Device I/O'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101), *Working with
    Files and Directories in Rust*, we covered the details of how to perform file
    I/O operations (such as reading and writing to files) using the Rust Standard
    Library. In Unix-like operating systems, a file is an abstraction that is used
    to work not only with regular disk files (which are used to store data) but also
    with several types of devices that are connected to a machine. In this chapter,
    we will look at the features of the Rust Standard Library that enable us to perform
    reads and writes to any type of device (also called device I/O) in Rust. Device
    I/O is an essential aspect of system programming to monitor and control various
    types of devices attached to a computer, such as keyboards, USB cameras, printers,
    and sound cards. You may be curious to know what support Rust provides to a system
    programmer to handle all these different types of devices. We'll answer this question
    as we go through the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review the basics of I/O management in Unix/Linux using
    the Rust Standard Library, including handling errors, and then write a program
    to detect and print details of connected USB devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover these topics in the following order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding device I/O fundamentals in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing buffered reads and writes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with standard input and output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining and iterators over I/O
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors and returning values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting details of connected USB devices (project)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to work with standard
    readers and writers, which constitute the foundation of any I/O operation. You'll
    also learn how to optimize system calls through the use of buffered reads and
    writes. We'll cover reading and writing to standard I/O streams of a process and
    handling errors from I/O operations, as well as learning ways to iterate over
    I/O. These concepts will be reinforced through an example project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify that `rustup`, `rustc`, and `cargo` have been installed correctly with
    the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter10/usb).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: For running and testing the project in this book, you must have the native libusb
    library installed where it can be found by `pkg-config`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The project in this book has been tested on macOS Catalina 10.15.6.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For instructions on building and testing on Windows, refer: [https://github.com/dcuddeback/libusb-rs/issues/20](https://github.com/dcuddeback/libusb-rs/issues/20)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'For general instructions on environmental setup of `libusb` crate, refer to:
    [https://github.com/dcuddeback/libusb-rs](https://github.com/dcuddeback/libusb-rs)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Understanding device I/O fundamentals in Linux
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we saw how to schedule work on CPUs using **processes
    and threads**, and how to manage **memory** by controlling the memory layout of
    a program. In addition to the CPU and memory, the operating system also manages
    the system's hardware devices. Examples of hardware devices include keyboards,
    mice, hard disks, video adapters, audio cards, network adapters, scanners, cameras,
    and other USB devices. But the peculiarities of these physical hardware devices
    are hidden from the user programs by the operating system, using software modules
    called **device drivers**. Device drivers are indispensable software components
    for doing device I/O. Let's take a closer look at them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用**进程和线程**来在CPU上调度工作，以及如何通过控制程序的内存布局来管理**内存**。除了CPU和内存，操作系统还管理系统的硬件设备。硬件设备的例子包括键盘、鼠标、硬盘、视频适配器、音频卡、网络适配器、扫描仪、摄像头以及其他USB设备。但是，这些物理硬件设备的特殊性被操作系统通过称为**设备驱动程序**的软件模块隐藏起来。设备驱动程序是进行设备I/O不可或缺的软件组件。让我们更深入地了解一下它们。
- en: What are device drivers?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是设备驱动程序？
- en: '**Device drivers** are shared libraries loaded into the kernel that contain
    functions to perform low-level hardware control. They communicate with the devices
    through the computer bus or communication subsystem to which the device is connected.
    They are specific to each device type (for example, a mouse or network adaptor)
    or class of devices (for example, IDE or SCSI disk controllers). They are also
    specific to an operating system (for example, a device driver for Windows doesn''t
    work on Linux even for the same device type).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备驱动程序**是加载到内核中的共享库，其中包含执行低级硬件控制的功能。它们通过连接到设备的计算机总线或通信子系统与设备进行通信。它们针对每种设备类型（例如，鼠标或网络适配器）或设备类（例如，IDE或SCSI磁盘控制器）特定。它们也针对特定的操作系统（例如，Windows的设备驱动程序在Linux上即使对于相同的设备类型也无法工作）。'
- en: Device drivers handle the peculiarities of the devices (or device classes) for
    which they are written. For example, a device driver to control a hard disk receives
    requests to read or write some file data identified by a **block number**. The
    device driver translates the block number into track, sector, and cylinder numbers
    on the disk. It also initializes the device, checks whether the device is in use,
    validates input parameters to its function calls, determines the commands to be
    issued, and issues them to the device. It handles the interrupts from the device
    and communicates them back to the calling program. The device driver further implements
    the specific hardware protocols that the device supports, such as **SCSI/ATA/SATA**
    for disk access or **UART** for serial port communications. Device drivers thus
    abstract away a lot of the hardware-specific details of controlling devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序处理它们所编写的设备（或设备类）的特殊性。例如，用于控制硬盘的设备驱动程序接收读取或写入由**块号**标识的某些文件数据的请求。设备驱动程序将块号转换为磁盘上的磁道、扇区和柱面号。它还初始化设备，检查设备是否在使用中，验证其函数调用输入参数的有效性，确定要发出的命令，并将它们发送到设备。它处理来自设备的中断，并将它们传达给调用程序。设备驱动程序还实现了设备支持的特定硬件协议，例如用于磁盘访问的**SCSI/ATA/SATA**或用于串行端口通信的**UART**。因此，设备驱动程序抽象出了控制设备的大量硬件特定细节。
- en: 'The operating system (specifically the kernel) accepts system calls from the
    user programs for device access and control, and then uses the respective device
    driver to physically access and control the device. *Figure 10.1* illustrates
    how user space programs (for example, Rust programs that use the standard library
    to talk to the operating system kernel) use system calls to manage and control
    various types of devices:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（特别是内核）接受用户程序对设备访问和控制的系统调用，然后使用相应的设备驱动程序物理访问和控制设备。*图10.1*说明了用户空间程序（例如，使用标准库与操作系统内核通信的Rust程序）如何使用系统调用来管理和控制各种类型的设备：
- en: '![Figure 10.1 – Device I/O in Linux](img/Figure_10.1_B16405.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Linux中的设备I/O](img/Figure_10.1_B16405.jpg)'
- en: Figure 10.1 – Device I/O in Linux
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Linux中的设备I/O
- en: In [*Chapter 6*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101), *Working with
    Files and Directories in Rust*, we saw that Linux/Unix has the philosophy that
    *everything is a file*, characterized by the universality of I/O. The same system
    calls, such as `open()`, `close()`, `read()`, and `write()`, can be applied to
    all types of I/O whether it's a regular file (used to store text or binary data),
    a directory, device files, or network connections. What this means is that programmers
    of user space programs can write code to communicate with and control devices
    without worrying about the protocol and hardware specifics of the devices, thanks
    to the abstraction layers provided by the kernel (system calls) and device drivers.
    Furthermore, the Rust Standard Library adds another layer of abstraction to provide
    a device-independent software layer, which Rust programs can use for device I/O.
    This is the primary focus of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16405_06_Final_NM_ePUB.xhtml#_idTextAnchor101)“在Rust中处理文件和目录”，我们了解到Linux/Unix有“一切皆文件”的哲学，这体现在I/O的通用性上。相同的系统调用，如`open()`、`close()`、`read()`和`write()`，可以应用于所有类型的I/O，无论是常规文件（用于存储文本或二进制数据）、目录、设备文件还是网络连接。这意味着用户空间程序的程序员可以编写代码与设备通信和控制设备，而无需担心设备的协议和硬件细节，这得益于内核（系统调用）和设备驱动程序提供的抽象层。此外，Rust标准库添加了另一层抽象，以提供设备无关的软件层，Rust程序可以使用它进行设备I/O。这是本章的主要关注点。
- en: Types of devices
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备类型
- en: 'In Unix/Linux, devices are broadly classified into three types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix/Linux中，设备被广泛分为三种类型：
- en: '**Character devices** send or receive data as a serial stream of bytes. Examples
    are terminals, keyboards, mice, printers, and sound cards. Unlike regular files,
    data cannot be accessed at random but only sequentially.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备**以字节序列的形式发送或接收数据。例如，终端、键盘、鼠标、打印机和声卡。与常规文件不同，数据不能随机访问，只能按顺序访问。'
- en: '**Block devices** store information in fixed-size blocks and allow random access
    to these blocks. Filesystems, hard disks, tape drives, and USB cameras are examples
    of block devices. A filesystem is mounted on a block device.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**以固定大小的块存储信息，并允许随机访问这些块。文件系统、硬盘、磁带驱动器和USB摄像头是块设备的例子。文件系统安装在块设备上。'
- en: '**Network devices** are similar to character devices as data is read serially,
    but there are some differences. Data is sent in variable-length packets using
    a network protocol, which the operating system and the user program have to deal
    with. A network adaptor is usually a hardware device (with some exceptions, such
    as the loopback interface, which is a software interface) that interfaces to a
    network (such as **Ethernet** or **Wi-Fi**).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络设备**与字符设备类似，因为数据是按顺序读取的，但也有一些区别。数据使用网络协议以可变长度的数据包发送，操作系统和用户程序必须处理这些协议。网络适配器通常是一个硬件设备（有些例外，如环回接口，它是一个软件接口），它连接到网络（如**以太网**或**Wi-Fi**）。'
- en: A hardware device is identified by its *type* (block or character) and a *device
    number*. The device number in turn is split into a major and minor device number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件设备通过其*类型*（块或字符）和*设备号*来识别。设备号反过来又分为主设备号和次设备号。
- en: When a new hardware is connected, the kernel needs a device driver that is compatible
    with the device and can operate the device controller hardware. A device driver,
    as discussed earlier, is essentially a shared library of low-level, hardware-handling
    functions that can operate in a privileged manner as part of the kernel. Without
    device drivers, the kernel does not know how to operate the device. When a program
    attempts to connect to a device, the kernel looks up associated information in
    its tables and transfers control to the device driver. There are separate tables
    for *block* and *character* devices. The device driver performs the required task
    on the device and returns control back to the operating system kernel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接新的硬件时，内核需要与设备兼容的设备驱动程序，并且可以操作设备控制器硬件。正如之前讨论的，设备驱动程序本质上是一个低级、硬件处理函数的共享库，可以作为内核的一部分以特权方式运行。没有设备驱动程序，内核不知道如何操作设备。当程序尝试连接到设备时，内核在其表中查找相关信息的条目，并将控制权转交给设备驱动程序。对于**块**和**字符**设备，有单独的表。设备驱动程序在设备上执行所需的任务，并将控制权返回给操作系统内核。
- en: As an example, let's look at a web server sending a page to a web browser. The
    data is structured as an **HTTP response message** with the **web page (HTML)**
    sent as part of its **data payload**. The data itself is stored in the kernel
    in a buffer (data structure), which is then passed to the **TCP layer**, then
    to the **IP layer**, on to the **Ethernet device driver**, then to the **Ethernet
    adaptor**, and onward to the **network**. The Ethernet device driver does not
    know anything about connections and only handles data packets. Similarly, when
    data needs to be stored to a file on the disk, the data is stored in a buffer,
    which is passed on to the **filesystem device driver** and then onward to the
    **disk controller**, which then saves it to the disk (for example, hard disk,
    SSD, and so on). Essentially, the *kernel* relies on a *device driver* to interface
    with the device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一个网页服务器向网页浏览器发送页面。数据结构为一个**HTTP响应消息**，其中作为其**数据负载**一部分发送的**网页（HTML）**。数据本身存储在内核中的缓冲区（数据结构）中，然后传递给**TCP层**，接着是**IP层**，然后是**以太网设备驱动程序**，然后是**以太网适配器**，最后到达**网络**。以太网设备驱动程序不了解任何连接，只处理数据包。同样，当需要将数据存储到磁盘上的文件时，数据会存储在缓冲区中，然后传递给**文件系统设备驱动程序**，然后传递给**磁盘控制器**，然后将其保存到磁盘（例如，硬盘、SSD等）。本质上，*内核*依赖于*设备驱动程序*与设备进行接口。
- en: Device drivers are usually part of the kernel (**kernel device driver**), but
    there are also **user space device drivers**, which abstract out the details of
    kernel access. Later in this chapter, we will be using one such user space device
    driver to detect USB devices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序通常是内核的一部分（**内核设备驱动程序**），但也有一些**用户空间设备驱动程序**，它们抽象化了内核访问的细节。在本章的后面部分，我们将使用这样一个用户空间设备驱动程序来检测USB设备。
- en: We've discussed the basics of device I/O, including device drivers and types
    of devices in Unix-like systems, in this section. Starting from the next section,
    we'll focus on how to do device-independent I/O using features from the Rust Standard
    Library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了设备I/O的基本知识，包括Unix-like系统中的设备驱动程序和设备类型。从下一节开始，我们将关注如何使用Rust标准库中的功能进行设备无关的I/O。
- en: Doing buffered reads and writes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行缓冲读取和写入
- en: Reads and writes are the fundamental operations performed on I/O types such
    as files and streams and are very crucial for working with many types of system
    resources. In this section, we'll discuss different ways to do *reads* and *writes*
    to I/O in Rust. We'll first cover the core traits – `Read` and `Write` – which
    allow Rust programs to perform read and write operations on objects that implement
    these traits (which are also called **readers** and **writers**). Then, we'll
    see how to do *buffered reads* and *buffered writes*, which are more efficient
    for certain types of read and write operations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入是执行在文件和流等I/O类型上的基本操作，对于与许多类型的系统资源一起工作非常重要。在本节中，我们将讨论在Rust中进行不同方式的*读取*和*写入*。我们将首先介绍核心特质——`Read`和`Write`——这些特质允许Rust程序在实现这些特质的对象上执行读取和写入操作（这些也被称为**读取器**和**写入器**）。然后，我们将看到如何进行*缓冲读取*和*缓冲写入*，这对于某些类型的读取和写入操作更有效。
- en: Let's start with the basic `Read` and `Write` traits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的`Read`和`Write`特质开始。
- en: In line with the *everything-is-a-file* philosophy, the Rust Standard Library
    provides two traits – `Read` and `Write` – which provide a general interface for
    reading and writing inputs and outputs. This trait is implemented for different
    types of I/O, such as files, `TcpStream`, standard input, and standard output
    streams of processes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据哲学“一切皆文件”，Rust标准库提供了两个特质——`Read`和`Write`——它们提供了读取和写入输入和输出的通用接口。这个特质为不同类型的I/O实现了，例如文件、`TcpStream`、标准输入和标准输出流。
- en: 'An example of using the `Read` trait is shown in the following code. Here,
    we are opening a `records.txt` file with the `open()` function in the `std::fs::File`
    module (which we learned earlier). We''re then bringing the `Read` trait from
    the `std::io` module into scope, and using the `read()` method of this trait to
    read bytes from a file. The same `read()` method can also be used to read from
    any other entity implementing the `Read` trait, such as a **network socket** or
    a **standard input** stream:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用`Read`特质的示例。在这里，我们使用`std::fs::File`模块中的`open()`函数（我们之前学过）打开一个`records.txt`文件。然后，我们将`std::io`模块中的`Read`特质引入作用域，并使用这个特质的`read()`方法从文件中读取字节。相同的`read()`方法也可以用于从实现`Read`特质的任何其他实体中读取，例如**网络套接字**或**标准输入**流：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a file called `records.txt` in the project root and run the program with
    `cargo run`. You can optionally print out the value of the buffer, which will
    display the raw bytes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`Read` and `Write` are byte-based interfaces, which can get inefficient as
    they involve continual system calls to the operating system. To overcome this,
    Rust also provides two structs to enable doing buffered reads and writes – `BufReader`
    and `BufWriter`, which have a built-in buffer and reduce the number of calls to
    the operating system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example can be rewritten as shown here, to use `BufReader`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code changes (from the previous version) have been highlighted. `BufReader`
    uses the `BufRead` trait, which is brought into scope. Instead of reading directly
    from the file handle, we create a `BufReader` instance and read a line into this
    struct. The `BufReader` methods internally optimize calls to the operating system.
    Run the program and verify that the value from the file is printed correctly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`BufWriter` similarly buffers writes to the disk, thus minimizing system calls.
    It can be used in a similar manner as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code shown, we're creating a new file to write into, and are also creating
    a new `BufWriter` instance. We then write a value from the buffer into the `BufWriter`
    instance. Run the program and verify that the specified string value has been
    written to a file with the name `file.txt` in the project root directory. Note
    that here, in addition to `BufWriter`, we also have to bring the `Write` trait
    into scope as this contains the `write()` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Note when to use and when not to use `BufReader` and `BufWriter`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '`BufReader` and `BufWriter` speed up programs that make small and frequent
    reads or writes to a disk. If the reads or writes only occasionally involve large-sized
    data, they do not offer any benefit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufReader` and `BufWriter` do not help while reading from or writing to in-memory
    data structures.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we saw how to do both unbuffered and buffered reads and writes.
    In the next section, we'll learn how to work with standard inputs and outputs
    of a process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Working with standard input and output
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Linux/Unix, **streams** are communication channels between a process and
    its environment. By default, three standard streams are created for every running
    process: **standard input**, **standard output**, and **standard error**. A stream
    is a communication channel that has two ends. One end is connected to the process
    and the other end to another system resource. For example, a standard input can
    be used by a process to read characters or text from a keyboard or another process.
    Similarly, a standard output stream can be used by a process to send some characters
    to the terminal or to a file. In many modern programs, the standard error of a
    process is connected to a log file, which makes analyzing and debugging errors
    easier.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library provides methods to interact with standard input and
    output streams. The `Stdin` struct in the `std::io` module represents the handle
    to the input stream of a process. This handle implements the `Read` trait, which
    we covered in the previous section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust标准库提供了与标准输入和输出流交互的方法。`std::io`模块中的`Stdin`结构体表示进程输入流的句柄。此句柄实现了我们在上一节中提到的`Read`特质。
- en: 'The code example here shows how to interact with the standard input and standard
    output streams of a process. In the code shown, we are reading a line from the
    standard input into a buffer. We''re then writing back the contents of the buffer
    to the standard output of the process. Note that here, the word *process* refers
    to the running program that you have written. You are essentially *reading from*
    and *writing to* the *standard input* and *standard output*, respectively, of
    the running program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何与进程的标准输入和标准输出流进行交互。在显示的代码中，我们从标准输入读取一行到缓冲区。然后，我们将缓冲区的内容写回进程的标准输出。请注意，在这里，单词*process*指的是您所编写的正在运行的程序。您本质上是从*标准输入*和*标准输出*分别*读取*和*写入*的：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program with `cargo run`, enter some text, and hit the *Enter* key.
    You'll see the text echoed back on the terminal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cargo run`运行程序，输入一些文本，然后按*Enter*键。您将在终端上看到文本被回显。
- en: '`Stdin`, which is a handle to the input stream of a process, is a shared reference
    to a global buffer of input data. Likewise, `Stdout`, which is the output stream
    of a process, is a shared reference to a global data buffer. Since `Stdin` and
    `Stdout` are references to shared data, to ensure exclusive use of these data
    buffers, the handles can be locked. For example, the `StdinLock` struct in the
    `std::io` module represents a locked reference to the `Stdin` handle. Likewise,
    the `StdoutLock` struct in the `std::io` module represents a locked reference
    to the `Stdout` handle. Examples of how to use the locked reference are shown
    in the code example here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stdin`，它是进程输入流的句柄，是对全局输入数据缓冲区的共享引用。同样，`Stdout`，它是进程的输出流，是对全局数据缓冲区的共享引用。由于`Stdin`和`Stdout`是共享数据的引用，为了确保这些数据缓冲区的独占使用，句柄可以被锁定。例如，`std::io`模块中的`StdinLock`结构体代表对`Stdin`句柄的锁定引用。同样，`std::io`模块中的`StdoutLock`结构体代表对`Stdout`句柄的锁定引用。以下代码示例展示了如何使用锁定引用的示例：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the code shown, the standard input and output stream handles are locked before
    reading and writing to them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，在读取和写入之前，将标准输入和输出流句柄锁定。
- en: 'We can similarly write to the *standard error* stream. A code example is shown
    here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地向*标准错误*流写入。以下是一个代码示例：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code shown, we're constructing a handle to the standard error stream
    using the `stderr()` function. Then, we're locking this handle and then writing
    some text to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码中，我们使用`stderr()`函数构建标准错误流的句柄。然后，我们锁定此句柄并向其写入一些文本。
- en: In this section, we've seen how to interact with the standard input, standard
    output, and standard error streams of a process using the Rust Standard Library.
    Recall that in the previous chapter on managing concurrency, we saw how, from
    a parent process, we can read from and write to the standard input and output
    streams of the child process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用Rust标准库与进程的标准输入、标准输出和标准错误流进行交互。回想一下，在前一章关于管理并发的内容中，我们看到了如何从父进程读取和写入子进程的标准输入和输出流。
- en: In the next section, let's look at a couple of functional programming constructs
    that can be used for I/O in Rust.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看一些可以在Rust中进行I/O的功能编程结构。
- en: Chaining and iterators over I/O
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O的链式操作和迭代器
- en: In this section, we'll look at how to use iterators and chaining with the `std::io`
    module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用迭代器和链式操作与`std::io`模块一起使用。
- en: 'Many of the data structures provided by the `std::io` module have built-in
    `while` and `for` loops. Here is an example of using the `lines()` iterator with
    the `BufReader` struct, which is a part of the `std::io` module. This program
    reads lines from the *standard input* stream in a loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::io`模块提供的许多数据结构都具有内置的`while`和`for`循环。以下是一个使用`BufReader`结构体和`lines()`迭代器的示例，`BufReader`是`std::io`模块的一部分。这个程序在循环中从*标准输入*流中读取行：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the code shown, we have created a handle to the standard input stream and
    passed it to a `BufReader` struct. This struct implements the `BufRead` trait,
    which has a `lines()` method that returns an *iterator* over the lines of the
    reader. This helps us to type inputs on the terminal *line by line* and have it
    read by our running program. The text entered on the terminal is echoed back to
    the terminal. Execute `cargo run`, and type some text, and then hit the *Enter*
    key. Repeat this step as many times as you'd like. Exit from the program with
    *Ctrl* + *C*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the iterator can be used to read line by line from a *file* (instead
    of from standard input, which we saw in the previous example). A code snippet
    is shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a file called `file.txt` in the project root directory. Enter a few lines
    of text in this file. Then, run the program using `cargo run`. You'll see the
    file contents printed out to the terminal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve so far seen how to use iterators from the `std::io` module. Let''s now
    look at another concept: **chaining**.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Read` trait in the `std::io` module has a `chain()` method, which allows
    us to chain multiple `BufReader` together into one handle. Here is an example
    of how to create a single **chained handle** combining two files, and how to read
    from this handle:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The statement using the `chain()` method has been highlighted in the code. The
    rest of the code is fairly self-explanatory, as it is similar to what we've seen
    in previous examples. Ensure to create two files, `file1.txt` and `file2.txt`,
    under the project root folder and enter a few lines of text in each. Run the program
    with `cargo run`. You'll see the data from both files printed out line by line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've seen how to use iterators and how to chain readers together.
    In the next section, let's take a look at error handling for I/O operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and returning values
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about the built-in error handling support in the
    `std::io` module. Handling recoverable errors in an appropriate manner makes Rust
    programs more robust.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In the code examples we've seen so far, we've used the `unwrap()` function to
    extract the return value from the `std::io` module methods and associated functions,
    such as `Read`, `Write`, `BufReader`, and `BufWriter`. However, this is not the
    correct way to handle errors. The `std::io` module has a specialized `Result`
    type that is returned from any function or method in this module that may produce
    an error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the previous example (of chaining readers) using the `io::Result`
    type as the return value from the function. This allows us to use the `?` operator
    to directly pass errors back from the `main()` function, instead of using the
    `unwrap()` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Code related to error handling has been highlighted. Run the program with `cargo
    run`, this time making sure that neither `file1.txt` nor `file3.txt` exists in
    the project root folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You'll see the error message printed to the terminal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到错误信息打印到终端。
- en: 'In the code we''ve just seen, we''re just propagating the error received from
    the operating system while making the calls. Let''s now try to handle the errors
    in a more active manner. The code example here shows custom error handling for
    the same code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才看到的代码中，我们只是在调用操作系统时传播接收到的错误。现在让我们尝试以更积极的方式处理错误。下面的代码示例显示了相同代码的自定义错误处理：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll notice that we've created a new function that returns `std::io::Result`
    to the `main()` function. We're handling errors in various operations, such as
    reading from a file and reading from the chained readers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们创建了一个新的函数，该函数将`std::io::Result`返回给`main()`函数。我们在各种操作中处理错误，例如从文件读取和从链式读取器读取。
- en: First, run the program with `cargo run`, ensuring that both `file1.txt` and
    `file2.txt` exist. You'll see the contents from both files printed to the terminal.
    Rerun the program by removing one of these files. You should see the custom error
    message from our code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`cargo run`运行程序，确保`file1.txt`和`file2.txt`都存在。你将看到两个文件的内容都打印到终端。通过移除其中一个文件来重新运行程序。你应该看到我们代码中的自定义错误消息。
- en: With this, we conclude the section on handling errors. Let's now move on to
    the last section of the chapter, where we will go through a project to detect
    and display details of USB devices connected to a computer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了关于错误处理的章节。现在让我们继续到本章的最后一节，我们将通过一个项目来检测和显示连接到计算机的USB设备的详细信息。
- en: Getting details of connected USB devices (project)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取连接的USB设备的详细信息（项目）
- en: In this section, we will demonstrate an example of working with devices in Rust.
    The example chosen is to display details of all connected USB devices of a computer.
    We'll be using `libusb`, a C library that helps to interact with USB devices.
    The `libusb` crate in Rust is a safe wrapper around the C `libusb` library. Let's
    first look at the design.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示在Rust中与设备一起工作的示例。所选的示例是显示计算机上所有连接的USB设备的详细信息。我们将使用`libusb`，这是一个C库，有助于与USB设备交互。Rust中的`libusb`包是C
    `libusb`库的安全包装。让我们首先看看设计。
- en: Designing the project
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计项目
- en: 'Here is how this would work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是如何工作的：
- en: When a USB device is plugged into a computer, the electrical signals on the
    computer bus trigger the **USB controller** (hardware device) on the computer.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当USB设备插入到计算机中时，计算机总线上的电信号会触发计算机上的**USB控制器**（硬件设备）。
- en: The USB controller raises an interrupt on the CPU, which then executes the interrupt
    handler registered for that interrupt in the kernel.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB控制器在CPU上引发中断，然后执行内核中注册的该中断的处理程序。
- en: When a call is made from the Rust program through the Rust `libusb` wrapper
    crate, the call is routed to the `libusb` C library, which in turn makes a system
    call on the kernel to read the device file corresponding to the USB device. We've
    seen earlier in this chapter how Unix/Linux enables standard `read()` and `write()`,
    for I/O.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从Rust程序通过Rust `libusb`包装器包发起调用时，该调用被路由到`libusb` C库，然后该库反过来在内核上执行系统调用来读取对应USB设备的设备文件。我们在本章前面已经看到Unix/Linux如何启用标准的`read()`和`write()`来进行I/O。
- en: When the system call returns from the kernel, the `libusb` library returns the
    value from the syscall to our Rust program.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统调用从内核返回时，`libusb`库将syscall的值返回给我们的Rust程序。
- en: 'We''re using the `libusb` library because writing a USB device driver from
    scratch requires implementing the USB protocol specifications, and writing device
    drivers is the subject of a separate book in itself. Let''s look at the design
    of our program:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`libusb`库，因为从头开始编写USB设备驱动程序需要实现USB协议规范，而编写设备驱动程序本身就是另一本书的主题。让我们看看我们程序的设计：
- en: '![Figure 10.2 – Design of the USB detector project](img/Figure_10.2_B16405.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – USB检测器项目设计](img/Figure_10.2_B16405.jpg)'
- en: Figure 10.2 – Design of the USB detector project
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – USB检测器项目设计
- en: '*Figure 10.2* shows the structs and functions in the program. Here is a description
    of the data structures:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.2* 展示了程序中的结构和函数。以下是数据结构的描述：'
- en: '`USBList`: List of USB devices detected.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBList`：检测到的USB设备列表。'
- en: '`USBDetails`: This contains the list of USB details that we want to retrieve
    through this program for each USB device.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBDetails`：这包含我们希望通过此程序检索的USB设备详细信息列表。'
- en: '`USBError`: Custom error handling.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USBError`：自定义错误处理。'
- en: 'These are the functions that we will write:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要编写的函数：
- en: '`get_device_information()`: Function to retrieve the required device details
    given a device reference and device handle.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_to_file()`: Function to write device details to an output file.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main()`: This is the entry point to the program. It instantiates a new `libusb::Context`,
    retrieves a list of attached devices, and iterates through the list to call `get_device_information()`
    for each device. The retrieved details are printed to the terminal and also written
    to the file using the `write_to_file()` function.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now begin to write the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Writing data structures and utility functions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll write the data structures for storing the USB device
    list and USB details and for custom error handling. We''ll also write a few utility
    functions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s add the `libusb` crate to `Cargo.toml`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll now look at the code in parts. Add all the code for this project in `usb/src/main.rs`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the module imports:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're importing the `libusb` modules and a few modules from the Rust Standard
    Library. `fs::File` and `io::Write` are for writing to an output file, `result::Result`
    is the return value from the functions, and `time::Duration` is for working with
    the `libusb` library.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s look at the data structures now:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`USBError` is for custom error handling, `USBList` is to store a list of the
    USB devices detected, and `USBDetails` is to capture the list of details for each
    USB device.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s implement the `Display` trait for the `USBList` struct so that custom
    formatting can be done to print the contents of the struct:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll implement `From` traits for the `USBError` struct so that errors
    from the `libusb` crate and from the Rust Standard Library are automatically converted
    into the `USBError` type when we use the `?` operator:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s next look at the function to write the details retrieved for all the
    attached devices to an output file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now move on to the `main()` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Writing the main() function
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll write the `main()` function, which sets up the device
    context, gets a list of connected USB devices, and then iterates through the list
    of devices to retrieve the details of each device. We''ll also write a function
    to print out the device details:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the `main()` function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `main()` function, we're first creating a new `libusb Context` that can
    return the list of connected devices. We are then iterating through the device
    list obtained from the `Context` struct, and calling the `get_device_information()`
    function for each USB device. The details are finally also printed out to an output
    file by calling the `write_to_file()` function that we saw earlier.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To wrap up the code, let''s write the function to get the device details:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This concludes the code. Make sure to plug in a USB device (such as a thumb
    drive) to the computer. Run the code with `cargo run`. You should see the list
    of attached USB devices printed to the terminal, and also written to the output
    `usb_details.txt` file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this example, we have demonstrated how to do file I/O using both
    an external crate (for retrieving USB device details) and the standard library
    (for writing to an output file). We've unified error handling using a common error
    handling struct, and automated conversions of error types to this custom error
    type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The Rust crates ecosystem (`crates.io`) has similar crates to interact with
    other types of devices and filesystems. You can experiment with them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on writing a program to retrieve USB details.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the foundational concepts of device management
    in Unix/Linux. We looked at how to do buffered reads and writes using the `std::io`
    module. We then learned how to interact with the standard input, standard output,
    and standard error streams of a process. We also saw how to chain readers together
    and use iterators for reading from devices. We then looked at the error handling
    features with the `std::io` module. We concluded with a project to detect the
    list of connected USB devices and printed out the details of each USB device both
    to the terminal and to an output file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library provides a clean layer of abstraction for doing I/O
    operations on any type of device. This encourages the Rust ecosystem to implement
    these standard interfaces for any type of device, enabling Rust system programmers
    to interact with different devices in a uniform manner. Continuing on the topic
    of I/O, in the next chapter, we will learn how to do network I/O operations using
    the Rust Standard Library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
