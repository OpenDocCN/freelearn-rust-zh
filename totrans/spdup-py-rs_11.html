<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-205"><em class="italic"><a id="_idTextAnchor204"/>Chapter 11</em>: Best Practices for Integrating Rust</h1>&#13;
			<p>In <a href="B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182"><em class="italic">Chapter 10</em></a>, <em class="italic">Injecting Rust into a Python Flask App</em>, we managed to fuse our Rust code with a Python web application. In this final chapter, we will wrap up what we have covered in the book with best practices. These practices are not essential to fuse Rust with Python; however, they will help us in avoiding pitfalls when building bigger packages in Rust. When it comes to best practices, we can Google search the topic <em class="italic">SOLID principles</em>, which will give us loads of free information on how to keep code generally clean. But instead of regurgitating these principles, we will cover concepts that are specific to using Rust and Python together. We will learn how to keep the Rust/Python implementation as simple as possible if the requirements are not too demanding. We will also understand what Python and Rust excel in when it comes to computational tasks and Python interfaces. We then investigate traits in Rust and how they can help us organize and structure our structs. Finally, we look into keeping it simple when we want data parallelism with the Rayon crate.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Keeping our Rust implementation simple by piping data to and from Rust</li>&#13;
				<li>Giving the interface a native feel with objects</li>&#13;
				<li>Using traits as opposed to objects</li>&#13;
				<li>Keeping data-parallelism simple with Rayon</li>&#13;
			</ul>&#13;
			<p>Covering these topics will enable us to avoid pitfalls when building bigger packages that are more complex. We will also be able to build Rust solutions for smaller projects faster as we will learn that we do not have to rely on Python setup tools and installation with <code>pip</code>.</p>&#13;
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Technical requirements</h1>&#13;
			<p>The code and data for this chapter can be found at the following link: </p>&#13;
			<p><a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven</a></p>&#13;
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Keeping our Rust implementation simple by piping data to and from Rust</h1>&#13;
			<p>We have covered everything we need to integrate Rust into our Python system. We can build Rust <a id="_idIndexMarker740"/>packages that can be installed using <code>pip</code> and use them in Docker when integrating with a web application. However, reaching for a setup tool can be too much effort if the problem being solved is small and simple. For instance, if in a situation we were merely opening a <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) file full of numbers in Python, calculating the Fibonacci numbers, and then writing <a id="_idIndexMarker741"/>them in another file, then it would make sense to just write the program in Rust. However, we do not start building a Rust package with Python setup tools if we have a more complicated Python standalone script that just needs a simple speedup with Rust—it is still just a standalone script. Instead, we pipe data. This means we pass data from a Python script to a Rust standalone binary and back to a Python script for computing Fibonacci numbers, as shown here:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_11.01_B17720.jpg" alt="" width="1330" height="206"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 11.1 – Process of a basic pipeline</p>&#13;
			<p>To achieve the same speed as the Rust Fibonacci calculation package without having to use any setup tools, we must carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Build a Python script that formulates the numbers for calculation. </li>&#13;
				<li>Build a Rust file that accepts the numbers, calculates the Fibonacci numbers, and returns the calculated numbers. </li>&#13;
				<li>Build another Python script that accepts the calculated numbers and prints them out.</li>&#13;
			</ol>&#13;
			<p>With this, we will be able to have a simple pipeline. While each file is isolated and we can build in any order, it makes sense to start with <em class="italic">Step 1</em>. </p>&#13;
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Building a Python script that formulates the numbers for calculation</h2>&#13;
			<p>For this <a id="_idIndexMarker742"/>example, we will just hardcode the input numbers that we are passing into our pipeline, but nothing is stopping you from reading your data from files or taking in numbers <a id="_idIndexMarker743"/>from command-line arguments. In our <code>input.py</code> file, we can write to <code>stdout</code> with the following code:</p>&#13;
			<pre>import sys</pre>&#13;
			<pre>sys.stdout.write("5\n")</pre>&#13;
			<pre>sys.stdout.write("6\n")</pre>&#13;
			<pre>sys.stdout.write("7\n")</pre>&#13;
			<pre>sys.stdout.write("8\n")</pre>&#13;
			<pre>sys.stdout.write("9\n")</pre>&#13;
			<pre>sys.stdout.write("10\n")</pre>&#13;
			<p>With this, if we run this script with the Python interpreter, we get the following output:</p>&#13;
			<pre>$ python input.py</pre>&#13;
			<pre>5</pre>&#13;
			<pre>6</pre>&#13;
			<pre>7</pre>&#13;
			<pre>8</pre>&#13;
			<pre>9</pre>&#13;
			<pre>10</pre>&#13;
			<p>With this, we can now move on to the next step. </p>&#13;
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>Building a Rust file that accepts the numbers, calculates the Fibonacci numbers, and returns the calculated numbers </h2>&#13;
			<p>For <a id="_idIndexMarker744"/>our Rust <a id="_idIndexMarker745"/>file, we must have everything <a id="_idIndexMarker746"/>contained in the file to keep it as simple as possible. We can span it over multiple files if needed, but <a id="_idIndexMarker747"/>for a simple calculation, keeping it all in one file is good enough. In our <code>fib.rs</code> file, we initially import <a id="_idIndexMarker748"/>what we need and define our <a id="_idIndexMarker749"/>Fibonacci function with the following code:</p>&#13;
			<pre>use std::io;</pre>&#13;
			<pre>use std::io::prelude::*;</pre>&#13;
			<pre>pub fn fibonacci_reccursive(n: i32) -&gt; u64 {</pre>&#13;
			<pre>    match n {</pre>&#13;
			<pre>         1 | 2 =&gt; 1,</pre>&#13;
			<pre>         _     =&gt; fibonacci_reccursive(n - 1) + </pre>&#13;
			<pre>                  fibonacci_reccursive(n - 2)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that there is nothing new; we are merely going to use <code>std::io</code> to get the numbers piped into the file, and then calculate the Fibonacci number, sending it to the next file in the pipeline with the following <code>main</code> function:</p>&#13;
			<pre>fn main() {</pre>&#13;
			<pre>    let stdin = io::stdin();</pre>&#13;
			<pre>    let stdout = std::io::stdout();</pre>&#13;
			<pre>    let mut writer = stdout.lock();</pre>&#13;
			<pre>    for line in stdin.lock().lines() {</pre>&#13;
			<pre>        let input_int: i32 = line.unwrap().parse::&lt;i32&gt;() \</pre>&#13;
			<pre>          .unwrap();</pre>&#13;
			<pre>        let fib_number = fibonacci_reccursive(input_int);</pre>&#13;
			<pre>        writeln!(writer, "{}", fib_number);</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we <a id="_idIndexMarker750"/>can see <a id="_idIndexMarker751"/>that we define <code>stdin</code> to <a id="_idIndexMarker752"/>receive the numbers sent to the Rust program, and <code>stdout</code> to send out the calculated Fibonacci <a id="_idIndexMarker753"/>numbers. We then loop through the lines <a id="_idIndexMarker754"/>sent into the Rust program and <a id="_idIndexMarker755"/>then parse each line at an integer. We then calculate the Fibonacci number and then send it using the macro that we imported with the <code>io</code> prelude. With this, we can now compile our Rust file with the following command:</p>&#13;
			<pre>rustc fib.rs</pre>&#13;
			<p>This will compile our Rust file. We can now run both files, piping the data from the Python file to the compiled Rust code with the following command:</p>&#13;
			<pre>$ python input.py | ./fib </pre>&#13;
			<pre>5</pre>&#13;
			<pre>8</pre>&#13;
			<pre>13</pre>&#13;
			<pre>21</pre>&#13;
			<pre>34</pre>&#13;
			<pre>55</pre>&#13;
			<p>Here, we can see that the numbers from the <code>python input.py</code> command get piped into <a id="_idIndexMarker756"/>the Rust code returning the <a id="_idIndexMarker757"/>calculated <a id="_idIndexMarker758"/>Fibonacci numbers. With <a id="_idIndexMarker759"/>this, we can now move on to the final step, where we get the calculated Fibonacci <a id="_idIndexMarker760"/>numbers from the Rust code and print them <a id="_idIndexMarker761"/>out.</p>&#13;
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Building another Python script that accepts the calculated numbers and prints them out</h2>&#13;
			<p>Our <code>output.py</code> file <a id="_idIndexMarker762"/>is very straightforward. It <a id="_idIndexMarker763"/>takes the following form:</p>&#13;
			<pre>import sys</pre>&#13;
			<pre>for i in sys.stdin.readlines():</pre>&#13;
			<pre>    try:</pre>&#13;
			<pre>        processed_number = int(i)</pre>&#13;
			<pre>        print(f"receiving: {processed_number}")</pre>&#13;
			<pre>    except ValueError:</pre>&#13;
			<pre>        pass</pre>&#13;
			<p>We <a id="_idIndexMarker764"/>have a <code>try</code> block because the start and the end of the data passed into the last Python script <a id="_idIndexMarker765"/>will have empty lines, and they will fail when we try to convert them into integers. We then print out the data with <code>"receiving: {processed_number}"</code> added to the last script to make it clear that it is the <code>output.py</code> file printing out the numbers. This gives us the printout, as follows:</p>&#13;
			<pre>$ python input.py | ./fib | python output.py</pre>&#13;
			<pre>receiving: 5</pre>&#13;
			<pre>receiving: 8</pre>&#13;
			<pre>receiving: 13</pre>&#13;
			<pre>receiving: 21</pre>&#13;
			<pre>receiving: 34</pre>&#13;
			<pre>receiving: 55</pre>&#13;
			<p>We can time how long it takes for the pipeline to run using the <code>time</code> command. If we compare <a id="_idIndexMarker766"/>this to pure Python with <a id="_idIndexMarker767"/>the example numbers that <a id="_idIndexMarker768"/>we have <a id="_idIndexMarker769"/>used, pure Python will be faster. However, we know that Rust is much faster than pure Python code. Because the <code>pure_python.py</code> file:</p>&#13;
			<pre>def recur_fib(n: int) -&gt; int:</pre>&#13;
			<pre>    if n &lt;= 2:</pre>&#13;
			<pre>        return 1</pre>&#13;
			<pre>    else:</pre>&#13;
			<pre>        return (recur_fib(n - 1) +</pre>&#13;
			<pre>                recur_fib(n - 2))</pre>&#13;
			<pre>for i in [5, 6, 7, 8, 9, 10, 15, 20, 25, 30]:</pre>&#13;
			<pre>    print(recur_fib(i))</pre>&#13;
			<p>This gives us the following printout:</p>&#13;
			<pre>$ time python pure_python.py </pre>&#13;
			<pre>5</pre>&#13;
			<pre>8</pre>&#13;
			<pre>13</pre>&#13;
			<pre>21</pre>&#13;
			<pre>34</pre>&#13;
			<pre>55</pre>&#13;
			<pre>610</pre>&#13;
			<pre>6765</pre>&#13;
			<pre>75025</pre>&#13;
			<pre>832040</pre>&#13;
			<pre>real  0m0.315s</pre>&#13;
			<pre>user  0m0.240s</pre>&#13;
			<pre>sys  0m0.027s</pre>&#13;
			<p>Adding <a id="_idIndexMarker770"/>the <a id="_idIndexMarker771"/>same numbers <a id="_idIndexMarker772"/>to the pipeline gives us the <a id="_idIndexMarker773"/>following printout:</p>&#13;
			<pre>$ time python input.py | ./fib | python output.py</pre>&#13;
			<pre>receiving: 5</pre>&#13;
			<pre>receiving: 8</pre>&#13;
			<pre>receiving: 13</pre>&#13;
			<pre>receiving: 21</pre>&#13;
			<pre>receiving: 34</pre>&#13;
			<pre>receiving: 55</pre>&#13;
			<pre>receiving: 610</pre>&#13;
			<pre>receiving: 6765</pre>&#13;
			<pre>receiving: 75025</pre>&#13;
			<pre>receiving: 832040</pre>&#13;
			<pre>real  0m0.054s</pre>&#13;
			<pre>user  0m0.050s</pre>&#13;
			<pre>sys  0m0.025s</pre>&#13;
			<p>Here, we <a id="_idIndexMarker774"/>can see that our pipeline <a id="_idIndexMarker775"/>is much faster. The gap between <a id="_idIndexMarker776"/>Rust and <a id="_idIndexMarker777"/>pure Python will just get larger as the numbers increase and become more numerous. We can see here that this is a lot easier with fewer moving parts. If our program is simple, then we keep the construction and use of Rust simple.</p>&#13;
			<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Giving the interface a native feel with objects</h1>&#13;
			<p>Python is an object-oriented language. When we are building our Rust packages, we need to keep <a id="_idIndexMarker778"/>the friction of adoption low. The adoption of Rust packages would be better if we keep our interfaces as objects. Most Python packages have object interfaces. Calculations are done with inputs, and the Python object has a range of functions and attributes that give us the results of those calculations. While we did cover creating classes in Rust with <code>pyo3</code> macros in <a href="B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Python Objects in Rust</em>, in the<em class="italic"> Constructing our custom Python objects in Rust</em> section, it is advised that we understand the pros and cons of doing this. We remember that classes written in Rust are faster. However, the freedom of inheritance and metaclassing with pure Python is useful. As a result, it is best to leave the construction and organization of the object interface in pure Python. Any calculations that need to be done can be done in Rust. To demonstrate this, we can use the simple <a id="_idIndexMarker779"/>physics example of a particle's <strong class="bold">two-dimensional</strong> (<strong class="bold">2D</strong>) trajectory, as seen in the following screenshot:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_11.02_B17720.jpg" alt="Figure 11.2 – Simple 2D physics trajectory&#13;&#10;" width="605" height="356"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 11.2 – Simple 2D physics trajectory</p>&#13;
			<p>Here, we can see that the initial velocity is denoted as <em class="italic">V0</em>. The projection on the <em class="italic">x</em> axis is denoted by <em class="italic">Vx</em>, and the projection on the <em class="italic">y</em> axis is denoted by <em class="italic">Vy</em>. The dashed line is the particle at <a id="_idIndexMarker780"/>every point in time. Time here is another dimension. Our equations for each position in time and the endpoint in time (when it hits the ground) are defined as follows:</p>&#13;
			<p class="figure-caption"><img src="img/B17720_11_001.png" alt="" width="419" height="108"/></p>&#13;
			<p class="figure-caption"><img src="img/B17720_11_002.png" alt="" width="259" height="57"/></p>&#13;
			<p class="figure-caption"><img src="img/B17720_11_003.png" alt="" width="284" height="144"/></p>&#13;
			<p>Here, <em class="italic">g</em> is the constant for gravity. We also want to know the position of the particle at a certain point in time. We do this by calculating the last point in time, then looping through all the time points between zero and the last point in time, calculating the <code>x</code> and <code>y</code> coordinates. All we would need is the initial velocity in <code>x</code> and <code>y</code>. The loop through with the position calculations would all be done in Rust. The dictionary where all the keys are all the times and all the values are tuples of <code>x</code> and <code>y</code> is housed in the Python object. We could write one function that processes all the times and returns a dictionary in Rust called <code>calculate_coordinates</code>. Using it in our Python class would look like this:</p>&#13;
			<pre>from rust_package import calculate_coordinates</pre>&#13;
			<pre>class Particle:</pre>&#13;
			<pre>    def __init__(self, v_x, v_y):</pre>&#13;
			<pre>        self.co_dict = calculate_coordinates(v_x, v_y)</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    def get_position(self, time) -&gt; tuple:</pre>&#13;
			<pre>        return self.co_dict[time]</pre>&#13;
			<pre>    @property</pre>&#13;
			<pre>    def times(self):</pre>&#13;
			<pre>        return list(self.co_dict.keys())</pre>&#13;
			<p>The user <a id="_idIndexMarker781"/>would just have to import the <code>Particle</code> object, initialize it with the initial velocity in the <code>x</code> and <code>y</code> coordinates, and then input times to get the coordinates. To plot all the positions for a particle, we would use our class with the following code:</p>&#13;
			<pre>from . . . import Particle</pre>&#13;
			<pre>particle = Particle(20, 30)</pre>&#13;
			<pre>x_positions = []</pre>&#13;
			<pre>y_positions = []</pre>&#13;
			<pre>for t in particle.times:</pre>&#13;
			<pre>    x, y = particle.get_position(t)</pre>&#13;
			<pre>    x_positions.append(x)</pre>&#13;
			<pre>    y_positions.append(y)</pre>&#13;
			<p>This is intuitive to Python. We have kept all our number crunching in Rust to get that speed, but we have managed to keep all of our interfaces, including accessing times and positions in Python. As a result, a developer using this package would not know that it is written in Rust—they would just appreciate that it is fast. We can drive home the benefits of keeping the formation and access to data 100% in Python while doing all the calculations in Rust with metaclassing. </p>&#13;
			<p>In our particle system, we could load a lot of data for the initial velocities of particles. As a result, our system would calculate the trajectories for a range of particles that we load. However, if we load two particles with the same initial velocities, they will both have the same trajectories. Considering this, it would not make sense for us to calculate the trajectory <a id="_idIndexMarker782"/>for both particles. To avoid this, we do not need to store anything in a file or database for reference; we just need to implement a flyweight design pattern. This is where we check the parameters passed into the object. If they are the same as the previous instance, we just return the previous instance. The flyweight pattern is defined with the following code:</p>&#13;
			<pre>class FlyWeight(type):</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    _instances = {}</pre>&#13;
			<pre>    def __call__(cls, *args, **kwargs):</pre>&#13;
			<pre>        key = str(args[0]) + str(args[1])</pre>&#13;
			<pre>        if key not in cls._instances:</pre>&#13;
			<pre>            cls._instances[key] = super( \</pre>&#13;
			<pre>                FlyWeight, cls).__call__(*args, **kwargs)</pre>&#13;
			<pre>        return cls._instances[key]</pre>&#13;
			<p>Here, we can see that we combine the initial velocities to define a key, and then check to see if there is already an instance with these velocities. If there is, we return the instance from our <code>_instances</code> dictionary. If not, we create a new instance and insert it into our <code>_instances</code> dictionary. Our particles will then take the form of the following code:</p>&#13;
			<pre>class Particle(metaclass=FlyWeight):</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    def __init__(self, v_x, v_y):</pre>&#13;
			<pre>        self.co_dict = calculate_coordinates(v_x, v_y)</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    def get_position(self, time) -&gt; tuple:</pre>&#13;
			<pre>        return self.co_dict[time]</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    @property</pre>&#13;
			<pre>    def times(self):</pre>&#13;
			<pre>        return list(self.co_dict.keys())</pre>&#13;
			<p>Here, our particles <a id="_idIndexMarker783"/>will now adhere to the flyweight pattern. We can test this with the following code:</p>&#13;
			<pre>test = Particle(4, 6)</pre>&#13;
			<pre>test_two = Particle(3, 8)</pre>&#13;
			<pre>test_three = Particle(4, 6)</pre>&#13;
			<pre>print(id(test))</pre>&#13;
			<pre>print(id(test_three))</pre>&#13;
			<pre>print(id(test_two))</pre>&#13;
			<p>Running this will give us the following printout:</p>&#13;
			<pre>140579826787152</pre>&#13;
			<pre>140579826787152</pre>&#13;
			<pre>140579826787280</pre>&#13;
			<p>Here, we can see that the two particles that have the same initial velocities have the same memory address, so it works. </p>&#13;
			<p>We can initialize these particles anywhere and this design pattern will apply, ensuring that we do <a id="_idIndexMarker784"/>not perform duplicate calculations. Considering that we are writing Python extensions in Rust, the flyweight pattern really shows us how much control we get with how the interface is called, used, and displayed. Even though we have built our interfaces in Python, this does not mean that we do not have to structure our Rust code. This brings us on to the next section, in which we discuss how to lean into traits as opposed to objects when it comes to structuring our Rust code. </p>&#13;
			<p>Using traits as opposed to objects</p>&#13;
			<p>As a <a id="_idIndexMarker785"/>Python developer, it is tempting to build structs <a id="_idIndexMarker786"/>that inherit via the composition of other structs. <strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) is well supported in Python; however, there are many reasons why Rust is favored, and one of them is traits. As seen in the following screenshot, traits enable us to separate data from behavior:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_11.03_B17720.jpg" alt="Figure 11.3 – Difference between traits and objects&#13;&#10;" width="1093" height="460"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 11.3 – Difference between traits and objects</p>&#13;
			<p>This gives us a lot of flexibility as the data and behavior are decoupled, enabling us to slot behavior in and out of structs as we need. Structs can have a portfolio of traits without giving us disadvantages arising from multiple inheritance. To demonstrate this, we are going to create a basic doctor, patient, nurse program so that we can see how different structs can have different traits, allowing them to move through functions. We are going to see how traits affect the way we lay out code over multiple files. Our program will have the following layout:</p>&#13;
			<pre>├── Cargo.toml</pre>&#13;
			<pre>├── src</pre>&#13;
			<pre>│   ├── actions.rs</pre>&#13;
			<pre>│   ├── main.rs</pre>&#13;
			<pre>│   ├── objects.rs</pre>&#13;
			<pre>│   ├── people.rs</pre>&#13;
			<pre>│   └── traits.rs</pre>&#13;
			<p>With this structure, the flow of our code will take the following form:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_11.04_B17720.jpg" alt="" width="898" height="609"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 11.4 – Code flow of a simple trait-based program</p>&#13;
			<p>With this, we <a id="_idIndexMarker787"/>can see that our code is decoupled. Our traits go into all the other files to define the behavior of those files. To build this program, we must carry out the following steps:</p>&#13;
			<ul>&#13;
				<li>Defining traits—building traits for our structs </li>&#13;
				<li>Defining struct behavior with traits</li>&#13;
				<li>Passing traits through functions</li>&#13;
				<li>Storing structs with common traits </li>&#13;
				<li>Running our program in the <code>main.rs</code> file.</li>&#13;
			</ul>&#13;
			<p>With this, we can start by defining our traits in the first subsection.</p>&#13;
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Defining traits </h2>&#13;
			<p>Before we <a id="_idIndexMarker788"/>start defining traits, we must conceptualize the types of people in our program that we are defining behavior for. They are laid out as follows:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Patient</strong>: This person does not have any clinical skills, but actions are performed on them.</li>&#13;
				<li><strong class="bold">Nurse</strong>: This person has clinical skills but cannot prescribe or diagnose.</li>&#13;
				<li><strong class="bold">Nurse practitioner</strong>: This person has clinical skills and can prescribe but cannot diagnose. </li>&#13;
				<li><strong class="bold">Advanced nurse practitioner</strong>: This person has clinical skills and can prescribe and diagnose. </li>&#13;
				<li><strong class="bold">Doctor</strong>: This person has clinical skills and can prescribe and diagnose.</li>&#13;
			</ul>&#13;
			<p>What we can <a id="_idIndexMarker789"/>see here is that they are all humans. Therefore, they are all able to speak and introduce themselves. So, in our <code>traits.rs</code> file, we can create a <code>Speak</code> trait with the following code:</p>&#13;
			<pre>pub trait Speak {</pre>&#13;
			<pre>    fn introduce(&amp;self) -&gt; ();</pre>&#13;
			<pre>}</pre>&#13;
			<p>If a struct implements this trait, it will have to create its own <code>introduce</code> function with the same return and input parameters. We can also see that everyone apart from the patient has clinical skills. To accommodate this, we can implement a clinical skills trait with the following code:</p>&#13;
			<pre>pub trait ClinicalSkills {</pre>&#13;
			<pre>    fn can_prescribe(&amp;self) -&gt; bool {        </pre>&#13;
			<pre>        return false</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    fn can_diagnose(&amp;self) -&gt; bool {</pre>&#13;
			<pre>        return false</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    fn can_administer_medication(&amp;self) -&gt; bool {</pre>&#13;
			<pre>        return true</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that we have defined the most common attributes for each clinician. Only two people—the doctor and the advanced nurse practitioner—can diagnose and prescribe. However, all of them can administer medication. We can implement this trait for all clinicians and then overwrite specifics. We must note that because the doctor and advanced nurse <a id="_idIndexMarker790"/>practitioner have the same possibilities in terms of diagnosing and prescribing, we can create another trait for this to prevent repeating ourselves, and a trait for the patient with the following code:</p>&#13;
			<pre>pub trait AdvancedMedical {}</pre>&#13;
			<pre>pub trait PatientRole {</pre>&#13;
			<pre>    fn get_name(&amp;self) -&gt; String;</pre>&#13;
			<pre>}</pre>&#13;
			<p>We have now defined all the traits that we need. We can start using them to define our people in the next subsection. </p>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>Defining struct behavior with traits </h2>&#13;
			<p>Before we <a id="_idIndexMarker791"/>define any structs, we must import our traits <a id="_idIndexMarker792"/>into our <code>people.rs</code> file with the following code:</p>&#13;
			<pre>use super::traits;</pre>&#13;
			<pre>use traits::{Speak, ClinicalSkills, AdvancedMedical, \</pre>&#13;
			<pre>  PatientRole};</pre>&#13;
			<p>We now have all our traits, so we can define our people in the program with the following code:</p>&#13;
			<pre>pub struct Patient {</pre>&#13;
			<pre>    pub name: String</pre>&#13;
			<pre>}</pre>&#13;
			<pre>pub struct Nurse {</pre>&#13;
			<pre>    pub name: String</pre>&#13;
			<pre>}</pre>&#13;
			<pre>pub struct NursePractitioner {</pre>&#13;
			<pre>    pub name: String</pre>&#13;
			<pre>}</pre>&#13;
			<pre>pub struct AdvancedNursePractitioner {</pre>&#13;
			<pre>    pub name: String</pre>&#13;
			<pre>}</pre>&#13;
			<pre>pub struct Doctor {</pre>&#13;
			<pre>    pub name: String</pre>&#13;
			<pre>}</pre>&#13;
			<p>Sadly, there is some repetition here. This is also going to happen with our <code>Speak</code> trait; however, it is <a id="_idIndexMarker793"/>important to keep these structs separate <a id="_idIndexMarker794"/>as we will slot traits into them later, so we need them to be decoupled. We can implement our <code>Speak</code> trait for each person with the following code:</p>&#13;
			<pre>impl Speak for Patient {</pre>&#13;
			<pre>    fn introduce(&amp;self) {</pre>&#13;
			<pre>        println!("hello I'm a Patient and my name is {}", \</pre>&#13;
			<pre>            self.name);</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>impl Speak for Nurse {</pre>&#13;
			<pre>    fn introduce(&amp;self) {</pre>&#13;
			<pre>        println!("hello I'm a Nurse and my name is {}", \</pre>&#13;
			<pre>            self.name);</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>impl Speak for NursePractitioner {</pre>&#13;
			<pre>    fn introduce(&amp;self) {</pre>&#13;
			<pre>        println!("hello I'm a Practitioner and my name is \</pre>&#13;
			<pre>            {}", self.name);</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>We can continue this pattern and implement <code>Speak</code> traits for all the people structs. Now this <a id="_idIndexMarker795"/>is done, we can implement our clinical skills <a id="_idIndexMarker796"/>and patient role traits for our people with the following code:</p>&#13;
			<pre>impl PatientRole for Patient {</pre>&#13;
			<pre>    fn get_name(&amp;self) -&gt; String {</pre>&#13;
			<pre>        return self.name.clone()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>impl ClinicalSkills for Nurse {}</pre>&#13;
			<pre>impl ClinicalSkills for NursePractitioner {</pre>&#13;
			<pre>    fn can_prescribe(&amp;self) -&gt; bool {</pre>&#13;
			<pre>        return true</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that our people structs have the following traits:</p>&#13;
			<ul>&#13;
				<li>The <code>Patient</code> struct has the standard <code>PatientRole</code> trait.</li>&#13;
				<li>The <code>Nurse</code> struct has the standard <code>ClinicalSkills</code> trait. </li>&#13;
				<li>The <code>NursePractitioner</code> struct has the standard <code>ClinicialSkills</code> trait with the <code>can_prescribe</code> function overwritten to return <code>true</code>.</li>&#13;
			</ul>&#13;
			<p>Now that <a id="_idIndexMarker797"/>we have our clinical skills applied to our standard <a id="_idIndexMarker798"/>clinicians, we can now apply our advanced traits with the following code:</p>&#13;
			<pre>impl AdvancedMedical for AdvancedNursePractitioner {}</pre>&#13;
			<pre>impl AdvancedMedical for Doctor {}</pre>&#13;
			<pre>impl&lt;T&gt; ClinicalSkills for T where T: AdvancedMedical {</pre>&#13;
			<pre>    fn can_prescribe(&amp;self) -&gt; bool {</pre>&#13;
			<pre>        return true</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    fn can_diagnose(&amp;self) -&gt; bool {</pre>&#13;
			<pre>        return true</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we apply the <code>AdvancedMedical</code> trait to our <code>Doctor</code> and <code>AdvancedNursePractitioner</code> structs. However, we know that these structs are also clinicians. We need them to have clinical skills. Therefore, we implement <code>ClinicalSkills</code> for the <code>AdvancedMedical</code> trait. We then overwrite the <code>can_prescribe</code> and <code>can_diagnose</code> functions to <code>true</code>. Therefore, doctors and advanced nurse practitioners have both <code>ClinicalSkills</code> and <code>AdvancedMedical</code> traits and can diagnose and prescribe. With this, our people structs are ready to be passed into functions. We will do this in the next subsection. </p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Passing traits through functions </h2>&#13;
			<p>To perform actions such as updating a database or sending data to a server, we are going to <a id="_idIndexMarker799"/>pass our people structs through functions <a id="_idIndexMarker800"/>where clinicians can act on patients. To do this, we must import our traits in our <code>actions.rs</code> file with the following code:</p>&#13;
			<pre>use super::traits;</pre>&#13;
			<pre>use traits::{ClinicalSkills, AdvancedMedical, PatientRole};</pre>&#13;
			<p>Our first action is to admit a patient. This can be done by anyone with clinical skills. Considering this, we can define this action with the following code:</p>&#13;
			<pre>pub fn admit_patient&lt;Y: ClinicalSkills&gt;(</pre>&#13;
			<pre>    patient: &amp;Box&lt;dyn PatientRole&gt;, _clinician: &amp;Y) {</pre>&#13;
			<pre>    println!("{} is being admitted", patient.get_name());</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that our clinician being passed in is anything with a <code>ClinicalSkills</code> trait, which means all our clinician structs. However, it must be noted that we are also passing in <code>&amp;Box&lt;dyn PatientRole&gt;</code> for the patient. This is because we will be using a patient list when passing in patients. We can have multiple patients assigned to a clinician. We will explore why we are using <code>&amp;Box&lt;dyn PatientRole&gt;</code> in the next subsection when we define our patient list struct. The next action is to diagnose a patient, which is defined with the following code:</p>&#13;
			<pre>pub fn diagnose_patient&lt;Y: AdvancedMedical&gt;(</pre>&#13;
			<pre>    patient: &amp;Box&lt;dyn PatientRole&gt;, _clinician: &amp;Y) {</pre>&#13;
			<pre>    println!("{} is being diagnosed", patient.get_name());</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, it makes sense to have the <code>AdvancedMedical</code> trait to diagnose. If we try to pass in a <code>Nurse</code> or <code>NursePractitioner</code> struct, the program will fail to compile due to mismatching traits. We can then have a prescribe medication action, which takes the form of the following code:</p>&#13;
			<pre>pub fn prescribe_meds&lt;Y: ClinicalSkills&gt;(</pre>&#13;
			<pre>    patient: &amp;Box&lt;dyn PatientRole&gt;, clinician: &amp;Y) {</pre>&#13;
			<pre>    if clinician.can_prescribe() {</pre>&#13;
			<pre>        println!("{} is being prescribed medication", \</pre>&#13;
			<pre>          patient.get_name());</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        panic!("clinician cannot prescribe medication");</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that the <code>ClinicalSkills</code> trait is accepted but the code will throw an error if the clinician cannot prescribe. This is because our <code>NursePractitioner</code> struct can <a id="_idIndexMarker801"/>prescribe. We could also make a third intermediate <a id="_idIndexMarker802"/>trait and apply it to doctor, advanced, and normal nurse practitioners. However, this is just one check as opposed to implementing a new trait for all three clinician structs. Our last action is that of administering medication and discharging the patient, which can be done by all our clinician structs; therefore, it takes the following form:</p>&#13;
			<pre>pub fn administer_meds&lt;Y: ClinicalSkills&gt;(</pre>&#13;
			<pre>    patient: &amp;Box&lt;dyn PatientRole&gt;, _clinician: &amp;Y) {</pre>&#13;
			<pre>    println!("{} is having meds administered", \</pre>&#13;
			<pre>      patient.get_name());</pre>&#13;
			<pre>}</pre>&#13;
			<pre>pub fn discharge_patient&lt;Y: ClinicalSkills&gt;(</pre>&#13;
			<pre>    patient: &amp;Box&lt;dyn PatientRole&gt;, _clinician: &amp;Y) {</pre>&#13;
			<pre>    println!("{} is being discharged", patient.get_name());</pre>&#13;
			<pre>}</pre>&#13;
			<p>We can now pass our people structs through a range of actions, with our compiler refusing to compile if we pass through the wrong person struct into the function. In the next subsection, we will be storing structs with traits in a patient list.</p>&#13;
			<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>Storing structs with common traits </h2>&#13;
			<p>When it comes to a patient list, it is tempting to just store patient structs in a vector. However, this <a id="_idIndexMarker803"/>does not give us much flexibility. For instance, let's <a id="_idIndexMarker804"/>say that our system is deployed, and one of the nurses in the hospital is sick and must be admitted. We could allow this by implementing the <code>PatientRole</code> trait to the <code>Nurse</code> struct without having to rewrite anything else. We might also need to expand the different types of patients, adding more structs such as <code>ShortStayPatient</code>, or <code>CriticallySickPatient</code>. Because of this, we store our patients with the <code>PatientRole</code> trait in our <code>objects.rs</code> file with the following code:</p>&#13;
			<pre>use super::traits;</pre>&#13;
			<pre>use traits::PatientRole;</pre>&#13;
			<pre>pub struct PatientList {</pre>&#13;
			<pre>    pub patients: Vec&lt;Box&lt;dyn PatientRole&gt;&gt;</pre>&#13;
			<pre>}</pre>&#13;
			<p>We must wrap our structs in a box because we do not know the size at compile time. Different structs of different sizes can implement the same trait. A <code>Box</code> is a pointer on the heap memory. Because we know the size of pointers, we know the size of memory being added to the vector at compile time. The <code>dyn</code> keyword is used to define that it is a trait that we are referring to. Managing to access the struct directly in the <code>patients</code> vector is not going to happen, as again, we do not know the size of the struct. Therefore, we access the data of the struct via the <code>get_name</code> function in the <code>PatientRole</code> trait in our action functions. Traits are also pointers. We can still build functions such as constructors for our struct. However, when it comes to our <code>Patient</code> struct being passed through an action function that we created, our <code>PatientRole</code> trait acts as an interface between our <code>Patient</code> struct and our <code>admit_function</code> function. We now have everything we need, so we can move on to our next subsection to put it all together and run it in our <code>main.rs</code> file. </p>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Running our traits in the main file </h2>&#13;
			<p>Running all <a id="_idIndexMarker805"/>our code together is straightforward and safe. Here's what we need to do:</p>&#13;
			<ol>&#13;
				<li value="1">First, we import all we need in our <code>main.rs</code> file with the following code:<pre>mod traits;
mod objects;
mod people;
mod actions;
use people::{Patient, Nurse, Doctor};
use objects::PatientList;
use actions::{admit_patient, diagnose_patient, \
  prescribe_meds, administer_meds, discharge_patient};</pre></li>&#13;
				<li>In our <code>main</code> function, we can now define the two nurses and doctors for our clinic for the day with the following code:<pre>fn main() {
    let doctor = Doctor{name: String::from("Torath")};
    let doctor_two = Doctor{name: \
      String::from("Sergio")};
    let nurse = Nurse{name: String::from("Maxwell")};
    let nurse_two = Nurse{name: \
      String::from("Nathan")};
}</pre></li>&#13;
				<li>We then get our patient list, and it turns out that the four horsemen have turned up for their treatment, as seen in the following code snippet:<pre>    let patient_list = PatientList {
        patients: vec![
            Box::new(Patient{name: \
              String::from("pestilence")}),
            Box::new(Patient{name: \
              String::from("war")}),
            Box::new(Patient{name: \
              String::from("famine")}),
            Box::new(Patient{name: \
              String::from("death")})
        ]
    };</pre></li>&#13;
				<li>We then <a id="_idIndexMarker806"/>loop through our patients, getting our doctors and nurses to care for them with the following code:<pre>    for i in patient_list.patients {
        admit_patient(&amp;i, &amp;nurse);
        diagnose_patient(&amp;i, &amp;doctor);
        prescribe_meds(&amp;i, &amp;doctor_two);
        administer_meds(&amp;i, &amp;nurse_two);
        discharge_patient(&amp;i, &amp;nurse);
    }</pre></li>&#13;
			</ol>&#13;
			<p>This is the end of our <code>main</code> function. Running it would give us the following printout:</p>&#13;
			<pre>conquest is being admitted</pre>&#13;
			<pre>conquest is being diagnosed</pre>&#13;
			<pre>conquest is being prescribed medication</pre>&#13;
			<pre>conquest is having meds administered</pre>&#13;
			<pre>conquest is being discharged</pre>&#13;
			<pre>war is being admitted</pre>&#13;
			<pre>. . .</pre>&#13;
			<pre>famine is being admitted</pre>&#13;
			<pre>. . .</pre>&#13;
			<pre>death is being admitted</pre>&#13;
			<pre>. . .</pre>&#13;
			<p>With this, we have finished our exercise in using traits in Rust. Hopefully, with this, you see the flexibility and decoupling we get when we use traits. However, we must remember that this approach cannot be supported if we were to build an interface with our Python system. If we were to build an interface, this could be done with the following pseudocode:</p>&#13;
			<pre>#[pyclass]</pre>&#13;
			<pre>pub struct NurseClass {</pre>&#13;
			<pre>    #[pyo3(get, set)]</pre>&#13;
			<pre>    pub name: String,</pre>&#13;
			<pre>    #[pyo3(get, set)]</pre>&#13;
			<pre>    pub admin: bool,</pre>&#13;
			<pre>    #[pyo3(get, set)]</pre>&#13;
			<pre>    pub prescribe: bool,</pre>&#13;
			<pre>    #[pyo3(get, set)]</pre>&#13;
			<pre>    pub diagnose: bool,</pre>&#13;
			<pre>}</pre>&#13;
			<pre>#[pymethods]</pre>&#13;
			<pre>impl NurseClass {</pre>&#13;
			<pre>    #[new]</pre>&#13;
			<pre>    fn new(name: String, admin: bool, prescribe: bool,</pre>&#13;
			<pre>           diagnose: bool)      Self {</pre>&#13;
			<pre>        return Nurse{name, admin, prescribe}</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    fn introduce(&amp;self)      Vec&lt;Vec&lt;u64&gt;&gt; {</pre>&#13;
			<pre>        println!("hello I'm a Nurse and my name is {}", </pre>&#13;
			<pre>                 self.name);</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we can see that we swapped the functions in the <code>ClinicalSkills</code> trait for attributes. We would be able to pass our <code>NurseClass</code> struct with traits into a function which calls the <code>ClinicalSkills</code> functions. The results from the <code>ClinicalSkills</code> functions can then be passed into the constructor for our <code>NurseClass</code> struct. Our <code>NurseClass</code> struct can then be passed out to our Python system. </p>&#13;
			<p>OOP has its merits and should be used when coding in Python. However, Rust has given us a new approach that is flexible and decoupled. It may take a while to get your head around traits, however, they are worth it. It's advised that you keep working with traits in your Rust code to get the advantages of using traits.</p>&#13;
			<h1 id="_idParaDest-217"><a id="_idTextAnchor216"/>Keeping data-parallelism simple with Rayon</h1>&#13;
			<p>In <a href="B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Concurrency </em>we processed our Fibonacci numbers in parallel. While it was interesting to look into concurrency, when we are building our own applications, we should lean on <a id="_idIndexMarker807"/>other crates to reduce the complexity of our application. This is where the <code>rayon</code> crate comes in. This will enable us to loop through numbers to be calculated <a id="_idIndexMarker808"/>and process them in parallel. In order to do this, we initially have to define the crate in the <code>Cargo.toml</code> file as seen here:</p>&#13;
			<pre>[dependencies]</pre>&#13;
			<pre>rayon = "1.5.1"</pre>&#13;
			<pre>With this, we import this crate in our <code>main.rs</code> file with the </pre>&#13;
			<pre>following code:</pre>&#13;
			<pre>extern crate rayon;</pre>&#13;
			<pre>use rayon::prelude::*;</pre>&#13;
			<p>Then, if we do not import the macros with <code>use rayon::prelude::*;</code> our compiler will refuse to compile when we try and turn a standard vector into a parallel iterator. With these macros, we can execute parallel Fibonacci calculations with the following code:</p>&#13;
			<pre>pub fn fibonacci_reccursive(n: i32) -&gt; u64 {</pre>&#13;
			<pre>      match n {</pre>&#13;
			<pre>            1 | 2 =&gt; 1,</pre>&#13;
			<pre>      _     =&gt; fibonacci_reccursive(n - 1) +</pre>&#13;
			<pre>                   fibonacci_reccursive(n - 2)</pre>&#13;
			<pre>      }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>fn main() {</pre>&#13;
			<pre>    let numbers: Vec&lt;u64&gt; = vec![6, 7, 8, 9, 10].into_par_iter(</pre>&#13;
			<pre>    ).map(</pre>&#13;
			<pre>        |x| fibonacci_reccursive(x)</pre>&#13;
			<pre>    ).collect();</pre>&#13;
			<pre>    println!("{:?}", numbers);</pre>&#13;
			<pre>}</pre>&#13;
			<p>With this code, we can see that we define a standard Fibonacci number function. We then get a vector of input numbers and convert it into a parallel iterator with the <code>into_par_iter</code> function. We then map our Fibonacci function to this parallel iterator. After this, we collect the results. Therefore, printing <code>numbers</code> will give us <code>[8, 13, 21, 34, 55]</code>. And that's it! We have coded parallel code, and we have kept it simple with the <code>rayon</code> crate. However, we must remember that there is a cost to set up this parallelization. If we were only going to use the numbers in the example, a normal loop would be faster. However, if the numbers and size of the array increase, the benefits of <code>rayon</code> start to show. For instance, if we were to have a vector of numbers to be calculated ranging from 6 to 33, we will get the time difference as seen in the following figure:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_11.05_B17720.jpg" alt="Figure 11.5 – Time taken for a loop 6 -&gt; 33 Fib numbers to be taken in microseconds &#13;&#10;" width="545" height="334"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 11.5 – Time taken for a loop 6 -&gt; 33 Fib numbers to be taken in microseconds </p>&#13;
			<p class="figure-caption">[left = Rayon right = normal loop]</p>&#13;
			<p>With this, we <a id="_idIndexMarker809"/>have a simple approach to parallelizing our calculation<a id="_idTextAnchor217"/>s <a id="_idIndexMarker810"/>which will keep our complexity and mistakes down.</p>&#13;
			<p>Summary</p>&#13;
			<p>In this chapter, we went over best practices for implementing Rust in our Python systems. We initially started by keeping it simple. We saw that we could leverage the speed of Rust without any setup tools or installing a package thanks to piping data to and from our Rust binary with Python. This is a useful technique to have and is not just limited to Python and Rust. In fact, you can pipe data between any language.</p>&#13;
			<p>If you are writing a basic program, then data piping should be the first thing you should do. This way, you reduce the number of moving parts and speed up development. A simple Bash script could compile the Rust file and run the process. However, as the program complexity increases, you can go for setup tools and import your Rust code directly into your Python code, utilizing what you covered in this book. </p>&#13;
			<p>We then moved on to the importance of leveraging Python's object support with a metaclass to lean on Python for our interfaces without Rust packages. Python is a mature language that is very expressive. It makes sense to use the best of Python and the best of Rust when building our packages by using Python for the interfaces and Rust for the calculations. We finally covered how to utilize traits as opposed to forcing Rust to have an object-orientated approach with inheritance via composition. The result is more decoupling and flexibility. Finally, we kept our parallel processing code simple with third-party crates which will increase our productivity and reduce the complexity of our code, and in turn, reduce mistakes. </p>&#13;
			<p>We have now come to the end of the book. There is always more to learn; however, you now have a full tool belt. You not only have a handle on the fastest memory-safe language that is cutting-edge, but you can also fuse it with the widely used Python language in an efficient way, installing it with <code>pip</code>. Not only can you do this for Python scripts, but you can also wrap up Rust extensions in Docker, enabling you to use Rust in Python web applications. Therefore, you do not have to wait for your company and projects to rewrite and adopt Rust. Instead, you can plug Rust into an already established project tomorrow. I am nothing short of excited about what you will do with this in the future.</p>&#13;
			<h1 id="_idParaDest-218"><a id="_idTextAnchor218"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">Mastering Object-Oriented Python</em> by <em class="italic">Steven Lott</em> (2019) (<em class="italic">Packt Publishing</em>)</li>&#13;
				<li><em class="italic">Mastering Rust</em> by <em class="italic">Rahul Sharma</em>, <em class="italic">Vesa Kaihlavirta</em> (2018) (<em class="italic">Packt Publishing</em>) </li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>