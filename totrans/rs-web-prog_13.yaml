- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Best Practices for a Clean Web App Repository
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁 Web 应用仓库的最佳实践
- en: Throughout this book, we have been building out our application piece by piece
    and adding automation scripts and tools to help us with testing and deploying
    our application. However, although this path is useful for learning tools and
    concepts, the structure of our projects in previous chapters has not been optimal
    for running a project for production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在逐步构建我们的应用程序，并添加自动化脚本和工具来帮助我们测试和部署应用程序。然而，尽管这条路径对学习工具和概念很有用，但前几章中我们项目的结构并不适用于生产环境。
- en: In this chapter, we will create a new repository, lift our Rust code into that
    repository, and then structure the code for clean database migrations, tests,
    and optimized Docker builds for our application so that it can be deployed smoothly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的仓库，将我们的 Rust 代码提升到该仓库中，然后为我们的应用程序构建清洁的数据库迁移、测试和优化的 Docker 构建，以便可以顺利部署。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The general layout of a clean repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁仓库的一般布局
- en: Getting our configuration from environment variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从环境变量获取我们的配置
- en: Setting up a local development database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置本地开发数据库
- en: Managing variables in Postman tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Postman 测试中管理变量
- en: Building distroless tiny server Docker images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建distroless微型服务器 Docker 镜像
- en: Building a clean test pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建清洁的测试管道
- en: Building continuous integration with GitHub Actions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 构建持续集成
- en: By the end of this chapter, you will be able to structure a repository with
    scripts, Docker builds, and tests that will make development smooth and easy to
    add new features. You will also be able to build **distroless** Docker images
    for the application, making them secure and dropping the size of our server images
    from 1.5 GB to 45 MB!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够构建一个包含脚本、Docker 构建和测试的仓库结构，这将使开发变得顺畅，并易于添加新功能。你还将能够为应用程序构建**distroless**
    Docker 镜像，使它们更安全，并将我们的服务器镜像大小从 1.5 GB 降低到 45 MB！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be referencing parts of the code defined in [*Chapter
    9*](B18722_09.xhtml#_idTextAnchor182), *Testing Our Application Endpoints and
    Components*. This can be found at the following URL: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将参考在[*第 9 章*](B18722_09.xhtml#_idTextAnchor182)中定义的代码部分，*测试我们的应用程序端点和组件*。这可以在以下
    URL 中找到：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter09)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter13](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter13).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter13](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter13)找到。
- en: The general layout of a clean repository
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁仓库的一般布局
- en: 'When it comes to a clean layout, we must have directories in the repository
    that have a single focus, just like our isolated code, which is modularized. In
    the clean approach taken in this chapter, our repository will have the following
    layout:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到清洁布局时，我们必须在仓库中有单一焦点的目录，就像我们模块化的独立代码一样。在本章采用的清洁方法中，我们的仓库将具有以下布局：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These files and directories have the following responsibilities:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件和目录有以下职责：
- en: '`Cargo.toml`: Defines the requirements for the Rust build.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cargo.toml`: 定义 Rust 构建的需求。'
- en: '`README.md`: Renders on a GitHub page when visited, telling the reader what
    the project is about and how to interact with the project.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`: 访问时在 GitHub 页面上渲染，告诉读者项目的内容以及如何与项目交互。'
- en: '`.dockerignore`: Tells the Docker build what to ignore when copying directories
    and files into the Docker image.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dockerignore`: 告诉 Docker 构建在复制目录和文件到 Docker 镜像时忽略什么。'
- en: '`.gitignore`: Tells git what to ignore when committing code to the git repository.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`: 告诉 git 在提交代码到 git 仓库时忽略什么。'
- en: '`.github`: A directory that houses GitHub Actions workflows.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.github`: 一个存放 GitHub Actions 工作流程的目录。'
- en: '`builds`: A directory that houses different builds for Docker, depending on
    the chip architecture.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builds`: 一个目录，根据芯片架构存放不同的 Docker 构建。'
- en: '`database`: A directory that houses all scripts and Docker builds required
    to handle database migrations.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database`: 一个存放处理数据库迁移所需的所有脚本和 Docker 构建的目录。'
- en: '`docker-compose.yml`: Defines the containers needed to run a development build.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`: 定义了运行开发构建所需的容器。'
- en: '`scripts`: A directory that houses all the Bash scripts needed to run dev servers
    or tests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`: 一个存放运行开发服务器或测试所需的Bash脚本的目录。'
- en: '`src`: A directory that houses all the Rust code to build the server.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 一个存放构建服务器所需所有Rust代码的目录。'
- en: '`tests`: A directory that houses a `docker-compose` configuration and a Postman
    collection to enable a fully integrated test. We must remember that unit tests
    are coded within the `src` directory and are conditionally compiled when the `test`
    command in Cargo is executed. In standard and release builds, the unit tests are
    excluded.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`: 一个存放`docker-compose`配置和Postman集合的目录，以实现完全集成的测试。我们必须记住，单元测试是在`src`目录中编写的，并且在执行Cargo中的`test`命令时条件编译。在标准构建和发布构建中，单元测试被排除。'
- en: Now that we know what our repository structure is like, we can add some rules
    and files to ensure that our builds and git commits behave in exactly the right
    way. It is good to do this at the very start of a project to avoid accidentally
    adding unwanted code to the git history or Docker builds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们的仓库结构是什么样的，我们可以添加一些规则和文件来确保我们的构建和git提交以完全正确的方式进行。在项目开始时就做这件事是个好主意，以避免意外地将不想要的代码添加到git历史或Docker构建中。
- en: 'First, we will start with the `.gitignore` file, which has the following rules
    defined:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`.gitignore`文件开始，该文件定义了以下规则：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see that we avoid anything in the `target` directory, which gets
    filled up with a lot of files when performing Rust builds and tests. These files
    add nothing to the project’s development and will balloon the size of your project
    very quickly. If you like to use JetBrains or are using a Mac, I have added `.idea`
    and `.DS_Store` as these files can sneak into repositories; they are not required
    for running any of the web application’s code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们避开了`target`目录中的任何内容，当执行Rust构建和测试时，这个目录会被填满很多文件。这些文件对项目的开发没有任何贡献，并且会迅速增加你项目的大小。如果你喜欢使用JetBrains或者使用Mac，我已经添加了`.idea`和`.DS_Store`，因为这些文件可能会悄悄地进入仓库；它们不是运行任何Web应用程序代码所必需的。
- en: 'Now, let’s look at our `.dockerignore` file, which has the following rules:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`.dockerignore`文件，它有以下规则：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These rules should make sense. We do not want to add our build files, scripts,
    database migrations, or GitHub workflows to our Docker builds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则应该是有意义的。我们不希望将我们的构建文件、脚本、数据库迁移或GitHub工作流程添加到我们的Docker构建中。
- en: 'We have now defined all our rules for the repository. Before we move on to
    the next section, we might as well define the general layout of our application.
    Here, we can lift the source Rust code from the existing to-do application into
    our new repository with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了所有关于仓库的规则。在我们进入下一节之前，我们不妨定义一下我们应用程序的一般布局。在这里，我们可以使用以下命令将现有的待办事项应用程序的源Rust代码从现有仓库提升到我们的新仓库：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you created an `src` directory in the clean app repository before running
    the preceding command, you must delete the `src` directory in the clean app repository;
    otherwise, you will end up with two `src` directories, where the copied `src`
    is inside the existing `src`. Our `Cargo.tml` file has the same dependencies as
    our existing web application; however, we can change its name with the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在运行前面的命令之前在干净的app仓库中创建了一个`src`目录，你必须删除干净app仓库中的`src`目录；否则，你将有两个`src`目录，其中复制的`src`位于现有的`src`内部。我们的`Cargo.toml`文件与现有的Web应用程序有相同的依赖项；然而，我们可以使用以下代码更改其名称：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s check if lifting our code works with the following `test` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下`test`命令是否可以提升我们的代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should give us the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This output shows that our code compiles and that our `Cargo.tml` file is properly
    defined. Now that we have confirmed that our unit tests have passed, we have some
    assurance that our code is working. However, how we define our configuration will
    give us some hurdles when we are deploying applications to the cloud. In the next
    section, we will smooth out our deployments by using environment variables to
    configure our web applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示我们的代码已编译，并且我们的`Cargo.toml`文件定义正确。现在我们已经确认了我们的单元测试已经通过，这让我们有了一些保证，我们的代码正在工作。然而，我们如何定义我们的配置，在将应用程序部署到云时，会给我们带来一些障碍。在下一节中，我们将通过使用环境变量来配置我们的Web应用程序，来简化我们的部署。
- en: Getting our configuration from environment variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从环境变量获取我们的配置
- en: 'So far, we have been loading configuration variables from YML files. This has
    a few issues. First, we must move these files around where our deployment is.
    Also, files do not work efficiently with orchestration tools such as Kubernetes.
    Kubernetes uses ConfigMaps, which essentially define environment variables for
    each container they are running. Environment variables also work well with tools
    such as Secret Manager and AWS credentials. We can also directly overwrite the
    environment variables in `docker-compose`. With all these advantages in mind,
    we will switch our configuration values from files to environment variables. To
    map where we have implemented configuration variables from a file, all we must
    do is delete our `src/config.rs` file and the module declaration of that `config`
    module in the `main.rs` file. Then, we can run the `cargo test` command again
    to get the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在从YML文件中加载配置变量。这有几个问题。首先，我们必须将这些文件移动到我们的部署位置。此外，文件与Kubernetes等编排工具不高效。Kubernetes使用ConfigMaps，这实际上为它们运行的每个容器定义了环境变量。环境变量也与Secret
    Manager和AWS凭证等工具很好地协同工作。我们还可以直接在`docker-compose`中直接覆盖环境变量。考虑到所有这些优势，我们将把配置值从文件切换到环境变量。为了映射我们从文件中实现了配置变量的位置，我们只需要删除我们的`src/config.rs`文件和`main.rs`文件中该`config`模块的模块声明。然后，我们可以再次运行`cargo
    test`命令以获得以下输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we used `config` in the `jwt`, `database`, and `counter` modules. This
    makes sense because we must connect to external structures when using these modules.
    To fix the breaking imports, all we must do is replace the config references with
    environment variable references. To demonstrate this, we can use the `src/counter.rs`
    file. First, we must delete the following lines of code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`jwt`、`database`和`counter`模块中使用了`config`。这是有意义的，因为我们使用这些模块时必须连接到外部结构。为了修复破坏性的导入，我们只需要将配置引用替换为环境变量引用。为了演示这一点，我们可以使用`src/counter.rs`文件。首先，我们必须删除以下代码行：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we must replace the preceding lines of code with the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须用以下代码替换前面的代码行：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can follow this format for the `JWT` and `database` modules as well. In
    the `JWT` module, there is one variable that is not a string and has to be converted
    into an integer, which is `expire minutes`. This can be done with the following
    line of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按照这种格式为`JWT`和`database`模块进行操作。在`JWT`模块中，有一个不是字符串的变量，必须将其转换为整数，即`expire
    minutes`。这可以通过以下代码行完成：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we run the `cargo test` command now, we will get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`cargo test`命令，我们将得到以下输出：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our tests ran, so we know that compiling the code worked. However, some of
    the JWT tests are failing. If we scroll further down the log, we will see the
    following error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行了，所以我们知道编译代码是成功的。然而，一些JWT测试失败了。如果我们继续向下滚动日志，我们将看到以下错误：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is telling us that our environment variables are not present. Considering
    that this is failing in the `JWT` module, we can be sure that it will also fail
    in the `database` and `counter` modules. Therefore, before we run or test our
    application, we need to define these environment variables. We can build a test
    pipeline for our application with environment variables by building a `scripts/run_unit_tests.sh`
    script with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们我们的环境变量不存在。考虑到这个问题出现在`JWT`模块中，我们可以确信它也会在`database`和`counter`模块中失败。因此，在我们运行或测试我们的应用程序之前，我们需要定义这些环境变量。我们可以通过构建一个包含以下代码的`scripts/run_unit_tests.sh`脚本来为我们的应用程序构建一个带有环境变量的测试管道：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we navigate to the root directory, export the environment variables, and
    then run the `test` command. Running the preceding script results in all the unit
    tests passing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导航到根目录，导出环境变量，然后运行`test`命令。运行前面的脚本会导致所有单元测试通过。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'While I like putting as much as possible in the Bash script as it acts like
    documentation for other developers to see all the moving parts, there are other
    approaches. For instance, you may find that the approach outlined previously is
    clunky as this approach deviates from running the standard `cargo test` command.
    Other approaches include the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我喜欢尽可能多地将内容放入Bash脚本中，因为它像文档一样让其他开发者看到所有移动的部分，但还有其他方法。例如，你可能会发现前面概述的方法很笨拙，因为这个方法与运行标准的`cargo
    test`命令不同。其他方法包括以下：
- en: '- Manually injecting variables into the test'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '- 手动将变量注入到测试中'
- en: '- Using the `dotenv` crate to load environment variables from a file (https://github.com/dotenv-rs/dotenv)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '- 使用`dotenv`crate从文件中加载环境变量（https://github.com/dotenv-rs/dotenv）'
- en: '- Having sensible defaults for environment variables'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为环境变量设置合理的默认值'
- en: 'How would you create the script that runs the dev server? This would be a good
    time for you to try and write the script yourself. If you have attempted writing
    the script yourself, your `scripts/run_dev_server.sh` script should look something
    like the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何创建运行开发服务器的脚本？这可能是一个尝试自己编写脚本的绝佳时机。如果你已经尝试编写了脚本，你的 `scripts/run_dev_server.sh`
    脚本应该看起来像以下代码：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, if we try and run the preceding script, it will crash because we cannot
    connect to the Redis database. We need to define our dev services in the `docker-compose.yml`
    file with the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试运行前面的脚本，它将会崩溃，因为我们无法连接到 Redis 数据库。我们需要在 `docker-compose.yml` 文件中定义我们的开发服务，以下代码：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that our dev services have been defined, we can spin up our `docker-compose`
    and run our `run_dev_server.sh` script, resulting in our dev server running. However,
    if we try and perform any requests, the server will crash. This is because we
    have not performed migrations on the database. In the next section, we will perform
    migrations on our dev database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了开发服务，我们可以启动 `docker-compose` 并运行 `run_dev_server.sh` 脚本，从而使开发服务器运行。然而，如果我们尝试执行任何请求，服务器将会崩溃。这是因为我们没有在数据库上执行迁移。在下一节中，我们将对开发数据库执行迁移。
- en: Setting up a local development database
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地开发数据库
- en: 'When it comes to migrations, there is the advantage of decoupling the programming
    language that we are using from the migrations. In the past, I have had to switch
    servers from one language to another and simply wished that the migration’s implementation
    was not coupled with the language. This is also a deployment issue. For instance,
    in Kubernetes, deploying a new server or an update might require a migration to
    be run. Ideally, you want to run the migration automatically through what we call
    *init Pods*. This is a container that is spun up and executed before the main
    server is deployed. This init Pod can perform a database migration command. However,
    if the init Pod requires something such as Rust to be present to execute the migration,
    this can greatly increase the size of the init pod. Therefore, I built an open
    source Bash tool that is only dependent on the `psql` and `wget` libraries. It
    can create new migrations and roll the database up and down versions. However,
    it must be stressed that this tool is not for every use. To quote the documentation
    of the migrations tool I wrote ([https://github.com/yellow-bird-consult/build_tools/tree/develop#use-yb-database-migrations-if-you-have-the-following)](https://github.com/yellow-bird-consult/build_tools/tree/develop#use-yb-database-migrations-if-you-have-the-following)),
    you should choose to use the migrations tool for projects if you have the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到迁移时，有一个优势是将我们使用的编程语言与迁移解耦。在过去，我不得不从一种语言切换到另一种语言，并希望迁移的实现没有与语言耦合。这也是一个部署问题。例如，在
    Kubernetes 中，部署新的服务器或更新可能需要运行迁移。理想情况下，你希望通过我们所说的 *init Pods* 自动运行迁移。这是一个在主服务器部署之前启动并执行的容器。这个
    init Pod 可以执行数据库迁移命令。然而，如果 init Pod 需要像 Rust 这样的东西来执行迁移，这可能会大大增加 init Pod 的大小。因此，我构建了一个仅依赖于
    `psql` 和 `wget` 库的开源 Bash 工具。它可以创建新的迁移并使数据库升级或降级。然而，必须强调的是，这个工具并不适用于所有用途。引用我编写的迁移工具的文档（[https://github.com/yellow-bird-consult/build_tools/tree/develop#use-yb-database-migrations-if-you-have-the-following](https://github.com/yellow-bird-consult/build_tools/tree/develop#use-yb-database-migrations-if-you-have-the-following)），如果你有以下情况，你应该选择在项目中使用迁移工具：
- en: '**A light throughput of migrations**: Migrations are not timestamped; they
    are simply numbered. The design of the tool is simple to keep track of what’s
    going on. Light applications in microservices are an ideal environment.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级的迁移吞吐量**：迁移没有时间戳；它们只是简单地编号。工具的设计简单，便于跟踪正在发生的事情。在微服务中的轻量级应用是一个理想的环境。'
- en: '**Well-tested code**: There are no guardrails. If there is an error in part
    of your SQL script, your database will be scarred with a partly run migration.
    You should have testing regimes with Docker databases before implementing migrations
    on a live production database.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经过充分测试的代码**：没有防护措施。如果你的 SQL 脚本中存在错误，你的数据库将会被部分运行的迁移所损害。在实施数据库生产环境的迁移之前，你应该在
    Docker 数据库上设置测试环境。'
- en: '**You plan on writing your own SQL**: Because this tool is completely decoupled
    from any programming language, you have to write your own SQL scripts for each
    migration. This is not as daunting as you might think and gives you more control.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你打算自己编写SQL**：因为这个工具完全与任何编程语言解耦，你必须为每个迁移编写自己的SQL脚本。这并不像你想象的那么可怕，并且给你更多的控制权。'
- en: '**You want complete control**: SQL migrations and the simple implementation
    are essentially defined in a single Bash script. This simple implementation gives
    you 100% control. Nothing is stopping you from opening up your database in a GUI
    and directly altering the version number or manually running particular sections
    of the migration.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你想要完全控制**：SQL迁移和简单的实现实际上是在一个Bash脚本中定义的。这种简单的实现给你100%的控制权。没有任何东西阻止你打开你的数据库在GUI中并直接更改版本号或手动运行迁移的特定部分。'
- en: 'Now that we know what we are getting ourselves in for, we can navigate to the
    `database` directory and install the migration tool with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了我们将要面对什么，我们可以导航到`database`目录并使用以下命令安装迁移工具：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This installs a couple of Bash scripts in your home directory. You may have
    to refresh your terminal to get the command alias. Not all operating systems will
    support the command alias. If your command alias does work, we can create a new
    set of migrations by using the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的家目录中安装几个Bash脚本。你可能需要刷新你的终端来获取命令别名。并非所有操作系统都支持命令别名。如果你的命令别名有效，我们可以使用以下命令创建一组新的迁移：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, if the alias does not work, you can run all your commands through
    the Bash script as each Bash script is 100% self-contained. All we must do is
    pass the same arguments in with the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果别名不起作用，你可以通过Bash脚本来运行所有命令，因为每个Bash脚本都是100%自包含的。我们只需使用以下命令传递相同的参数：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `init` command, we get the following structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`init`命令，我们得到以下结构：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the same as the Diesel migrations tool but with just plain numbers.
    We have two migrations from our to-do application, so we can create them with
    the following commands:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这与柴油迁移工具相同，但只是用纯数字表示。我们有两个来自待办应用的迁移，因此我们可以使用以下命令来创建它们：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have done this, we can create our migration files. The `database_management/1/up.sql`
    file creates the `to_do` table with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这个操作，我们就可以创建我们的迁移文件。`database_management/1/up.sql`文件使用以下代码创建`to_do`表：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `database_management/1/down.sql` file drops the `to_do` table with the
    following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`database_management/1/down.sql`文件使用以下代码删除`to_do`表：'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `database_management/2/up.sql` file creates the `user` table and links
    all existing items to a placeholder user with the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`database_management/2/up.sql`文件使用以下代码创建`user`表并将所有现有项目链接到一个占位符用户：'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `database_management/2/down.sql` file drops the `users` table with the
    following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`database_management/2/down.sql`文件使用以下代码删除`users`表：'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our migrations are now ready. However, we need to connect to our database to
    get information and perform migrations. We can spin up our `docker-compose` to
    get the dev database up and running. Once this is done, we must define our database
    URL in the environment variables. The migration tool looks for the URL in environment
    variables. However, if there is a `.env` file in the current working directory,
    the migration tool will also load all the variables in this file. In our `database_management/.env`
    file, we can define the database URL with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了迁移。然而，我们需要连接到我们的数据库以获取信息和执行迁移。我们可以启动我们的`docker-compose`来启动开发数据库并使其运行。一旦完成，我们必须在环境变量中定义我们的数据库URL。迁移工具会在环境变量中查找URL。然而，如果当前工作目录中有一个`.env`文件，迁移工具也会加载这个文件中的所有变量。在我们的`database_management/.env`文件中，我们可以使用以下代码定义数据库URL：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that our database is running and we have our URL defined, we can get what
    migration level the database is currently at with the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库正在运行，并且我们已经定义了URL，我们可以使用以下命令获取数据库当前的迁移级别：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Right now, we should get a `-1`. This means that there is no migrations versioning
    table at all on the database. If there is, but no migrations have been performed
    on the database, the version will be `0`. If there are any migrations, then the
    response will be the migration number that it is currently at. We can use the
    following `db` commands when using the build tool to perform commands on the database:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应该得到一个`-1`。这意味着数据库上根本没有任何迁移版本表。如果有，但数据库上没有执行任何迁移，版本将是`0`。如果有任何迁移，则响应将是当前所在的迁移编号。当使用构建工具执行数据库上的命令时，我们可以使用以下`db`命令：
- en: '`set`: Creates a migrations version table if there is not one'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`: 如果没有迁移版本表，则创建一个迁移版本表'
- en: '`up`: Goes up one migration version by applying the `up.sql` script'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`: 通过应用`up.sql`脚本向上迁移一个版本'
- en: '`down`: Goes down one migration version by applying the `down.sql` script'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`: 通过应用`down.sql`脚本向下迁移一个版本'
- en: '`new`: Creates a new migration folder if you are on the latest version'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`: 如果你在最新版本上，则创建一个新的迁移文件夹'
- en: '`rollup`: Creates a new migrations version table if there is not one and then
    loops up all the versions in the `database_management` directory, starting from
    the current version of the database'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rollup`: 如果没有迁移版本表，则创建一个新的迁移版本表，然后从数据库的当前版本开始循环`database_management`目录中的所有版本'
- en: 'We will run the `rollup` command with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令运行`rollup`命令：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will perform migrations on the database. If you run the `get` command,
    you will see that the version of the database is now `2`. Our database is now
    ready to be queried by our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在数据库上执行迁移。如果你运行`get`命令，你会看到数据库的版本现在是`2`。我们的数据库现在已准备好被我们的应用程序查询。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Migrations can also be achieved using the `sqlx-cli` crate, which can be found
    at the following link: https://crates.io/crates/sqlx-cli.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移也可以使用`sqlx-cli` crate来实现，该crate可以在以下链接找到：https://crates.io/crates/sqlx-cli。
- en: However, Cargo is needed to install `sqlx-cli`, which will complicate the creation
    of init Pods for executing these migrations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要Cargo来安装`sqlx-cli`，这将使执行这些迁移的init Pods创建变得复杂。
- en: Instead of randomly making requests, in the next section, we will refine our
    Postman tests so that we can run a series of requests and check that our application
    runs in the way that we want it to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于随机地发出请求，在下一节中，我们将细化我们的Postman测试，以便我们可以运行一系列请求并检查我们的应用程序是否以我们想要的方式运行。
- en: Managing variables in Postman tests
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Postman测试中管理变量
- en: 'In [*Chapter 9*](B18722_09.xhtml#_idTextAnchor182), *Testing Our Application
    Endpoints and Components*, we built a Postman collection. However, it was a bit
    ropey as we had to rely on Python to load the new token into the Newman collection.
    While this was important to use as using Python as glue code between processes
    is a useful skill, our old version of readying a Newman collection with Python
    is not the cleanest approach. At the start of our collection, we will add two
    new requests. The first one will create a user with the following parameters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18722_09.xhtml#_idTextAnchor182)中，*测试我们的应用程序端点和组件*，我们构建了一个Postman集合。然而，它有点粗糙，因为我们不得不依赖Python将新令牌加载到Newman集合中。虽然使用Python作为进程之间的粘合代码是一项有用的技能，但我们的旧版本使用Python准备Newman集合并不是最干净的方法。在我们的集合开始时，我们将添加两个新的请求。第一个请求将创建一个用户，以下是一些参数：
- en: '![Figure 13.1 – Create user Postman request](img/Figure_13.1_B18722.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 创建用户Postman请求](img/Figure_13.1_B18722.jpg)'
- en: Figure 13.1 – Create user Postman request
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 创建用户Postman请求
- en: 'With the create user request, we get the following JavaScript in the **Tests**
    tab in Postman:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用创建用户请求，我们在Postman的**测试**选项卡中得到了以下JavaScript：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this, the first request of our collection will create the user and throw
    an error if the request was not successful. Then, we can create the second request
    for our collection, which consists of logging in, with the following parameters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们的集合的第一个请求将创建用户，如果请求未成功，将抛出一个错误。然后，我们可以为我们的集合创建第二个请求，该请求是登录，以下是一些参数：
- en: '![Figure 13.2 – Login Postman request](img/Figure_13.2_B18722.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 登录Postman请求](img/Figure_13.2_B18722.jpg)'
- en: Figure 13.2 – Login Postman request
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 登录Postman请求
- en: 'With this request, we must check the response and set a collection variable
    as the token that we just got from the login by running the following JavaScript
    in the **Tests** tab in Postman:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个请求，我们必须检查响应并将集合变量设置为令牌，这是通过在Postman的**测试**选项卡中运行以下JavaScript来完成的：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have set our collection variable, we will be able to reference our
    token throughout the rest of the collection. To do this, we must update the authorization
    for the entire collection so that our new token value will propagate through all
    our requests. To access the authorization settings, click on the header of a `create`
    request to get the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了我们的收集变量，我们就能在整个收集过程中引用我们的令牌。为此，我们必须更新整个收集的授权，以确保我们的新令牌值能传播到所有我们的请求中。要访问授权设置，请点击一个`create`请求的头部以获取以下内容：
- en: '![Figure 13.3 – Header of the request](img/Figure_13.3_B18722.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 请求头部](img/Figure_13.3_B18722.jpg)'
- en: Figure 13.3 – Header of the request
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 请求头部
- en: 'On the right-hand side of the previous screenshot, we can see that there is
    a **Go to authorization** button. If we click on this, we get the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图的右侧，我们可以看到一个**转到授权**按钮。如果我们点击这个按钮，我们会得到以下内容：
- en: '![Figure 13.4 – Configuring authorization](img/Figure_13.4_B18722.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 配置授权](img/Figure_13.4_B18722.jpg)'
- en: Figure 13.4 – Configuring authorization
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 配置授权
- en: We can see that the value has been changed to `{{login_token}}`. If we save
    this and then export the collection JSON file to the `tests` directory in our
    repository, the value that belongs to `{{login_token}}` will be inserted into
    the collection JSON file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到值已经更改为`{{login_token}}`。如果我们保存并然后导出收集 JSON 文件到我们仓库中的`tests`目录，属于`{{login_token}}`的值将被插入到收集
    JSON 文件中。
- en: We now have a Postman collection that updates itself with a fresh token after
    the login request without having to rely on Python to glue processes together.
    This is much cleaner; however, we want to ensure that the rest of our testing
    pipeline mimics as much of a production setting as possible. In the next section,
    we will build Docker images that contain our application that are a fraction of
    the size of what our server images were in previous chapters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 Postman 收集，在登录请求后无需依赖 Python 将流程粘合在一起，它会自动更新一个新令牌。这要干净得多；然而，我们想要确保我们的测试管道的其余部分尽可能地模仿生产设置。在下一节中，我们将构建包含我们的应用程序的
    Docker 镜像，其大小是之前章节中服务器镜像大小的几分之一。
- en: Building distroless tiny server Docker images
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建无依赖的微型服务器 Docker 镜像
- en: In previous chapters, our server Docker images were roughly around 1.5 GB. This
    is pretty big and not ideal when we want to distribute our Rust images on servers
    or to other developers. Note that there is a shell that we can access in the Docker
    container when the image is running. This is useful in development but not great
    in production because if anyone manages to gain access to the Docker container,
    they will be able to look around and run commands in the Docker container. If
    the permissions on the server are not locked down, the hacker could even start
    running commands on the cluster that you have. I have seen cryptojacking happen
    through this method, where a hacker spun up a load of mining Pods at the expense
    of the owner of the AWS account.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们的服务器 Docker 镜像大约在 1.5 GB 左右。这相当大，当我们想要在服务器或其他开发者上分发我们的 Rust 镜像时并不理想。请注意，当镜像运行时，我们可以在
    Docker 容器中访问一个 shell。这在开发中很有用，但在生产中并不理想，因为如果有人设法访问 Docker 容器，他们就能在其中四处查看并运行命令。如果服务器的权限没有锁定，黑客甚至可以在你的集群上开始运行命令。我见过通过这种方法发生的加密劫持，其中黑客利用
    AWS 账户所有者的成本启动了大量挖矿 Pods。
- en: We are going to solve these problems by using distroless images. These distroless
    images are tiny in size and do not have shells. So, if someone manages to gain
    access to our server, they will not be able to do anything because there are no
    shells. We will be able to drop the size of our image from 1.5 GB to 45 MB! This
    is something we want. However, before we start building our distroless images,
    we must know that distroless images have close to nothing on them. This means
    that if we compile our application and stuff it into a distroless image, it will
    not work. For instance, if we make a connection to a database, we need the `libpq`
    library in our distroless image. As the distroless image does not contain the
    library, the image will not be able to run because our static binary will not
    be able to locate the `libpq` library.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用distroless镜像来解决这些问题。这些distroless镜像体积小巧，没有shell。因此，如果有人设法访问我们的服务器，他们将无法做任何事情，因为没有shell。我们将能够将我们的镜像大小从1.5
    GB减少到45 MB！这是我们想要的。然而，在我们开始构建我们的distroless镜像之前，我们必须知道distroless镜像上几乎没有东西。这意味着如果我们编译我们的应用程序并将其放入distroless镜像中，它将无法工作。例如，如果我们连接到数据库，我们需要在distroless镜像中包含`libpq`库。由于distroless镜像不包含库，镜像将无法运行，因为我们的静态二进制文件将无法定位到`libpq`库。
- en: 'We know that our 1.5 GB image runs because it contains everything and the kitchen
    sink. We can use our 1.5 GB to inspect what dependencies the static binary has
    in the image. We can do this by moving to our `deployment` directory where we
    wrote code to deploy our application on AWS and spinning up `docker-compose` there.
    Once this is running, we can inspect our containers with the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的1.5 GB镜像可以运行，因为它包含了所有东西，甚至厨房用具。我们可以使用我们的1.5 GB来检查静态二进制文件在镜像中包含的依赖项。我们可以通过移动到我们的`deployment`目录来实现，我们在那里编写了代码来部署我们的应用程序到AWS，并在那里启动`docker-compose`。一旦这个运行起来，我们可以使用以下命令来检查我们的容器：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will give us the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Your IDs will be different, but we will use these IDs to SSH into our Rust
    app by using the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您的ID将不同，但我们将使用这些ID通过以下命令SSH进入我们的Rust应用程序：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This opens an interactive shell so that we can navigate the Docker container.
    Here, we must remember that the static binary – that is, the Rust server – is
    called `web_app` and that this is in the root directory, so we do not need to
    go anywhere within the container. We can list the dependencies by using the following
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个交互式shell，以便我们可以导航Docker容器。在这里，我们必须记住，静态二进制文件——即Rust服务器——被称为`web_app`，并且它位于根目录中，所以我们不需要在容器内任何地方移动。我们可以使用以下命令列出依赖项：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will give us the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are 29 dependencies in total. On the left of the list, there is the name
    of the library. On the right of the list, there is the path to where the library
    is. We can see that the database `libpq` library is needed alongside other libraries.
    Your paths may look different. This is because I am running this image on a MacBook
    M1, which has an ARM chip architecture. If you do not have this, then you will
    have `x86_64-linux-gnu` in your path as opposed to `aarch64-linux-gnu`. This is
    fine – we will supply both Docker files in the GitHub repository online.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有29个依赖项。在列表的左侧是库的名称。在列表的右侧是库的路径。我们可以看到，数据库`libpq`库需要与其他库一起使用。您的路径可能不同。这是因为我在运行这个镜像的MacBook
    M1上，它有一个ARM芯片架构。如果您没有这个，那么您的路径将是`x86_64-linux-gnu`而不是`aarch64-linux-gnu`。这是可以的——我们将在GitHub在线仓库中提供两个Docker文件。
- en: 'In our Docker build, we must copy these libraries into our distroless image.
    In our `clean_web_app/builds` directory, we must create two files: `aarch64_build`
    and `x86_64_build`. Both these files are essentially the same Dockerfiles but
    with different references to libraries. At the time of writing, I wish that there
    was a smarter way to achieve builds with different chips in one Docker file; however,
    Docker builds are terrible at passing variables throughout the build as each step
    is isolated, and conditional logic is limited at best. It is easier to just have
    two different files. Also, if the builds change in the future, then the two different
    chip builds are decoupled. In our `clean_web_app/builds/arch_build` file, we must
    get the Rust image, install the database library, copy over the code of the application
    to be compiled, and define what type of build we are doing:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Docker构建过程中，我们必须将这些库复制到我们的distroless镜像中。在我们的`clean_web_app/builds`目录中，我们必须创建两个文件：`aarch64_build`和`x86_64_build`。这两个文件本质上都是相同的Dockerfile，但库的引用不同。在撰写本文时，我希望有一种更智能的方法可以在一个Dockerfile中实现不同芯片的构建；然而，Docker构建在传递变量方面非常糟糕，因为每个步骤都是隔离的，并且条件逻辑最多只能有限地使用。直接使用两个不同的文件会更简单。此外，如果构建在未来发生变化，那么两个不同芯片的构建将是解耦的。在我们的`clean_web_app/builds/arch_build`文件中，我们必须获取Rust镜像，安装数据库库，复制要编译的应用程序代码，并定义我们正在进行的构建类型：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can see that the environment is set to `"PRODUCTION"` by default. If there
    is an accident and the environment is not defined, it should be `"PRODUCTION"`
    by default. Accidentally taking longer to compile on a test build is much better
    than accidentally deploying a non-production server into production. Then, we
    compile using the release flag if it is production and switch the static binary
    into the release directory if it is not compiled using the release flag:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，环境默认设置为`"PRODUCTION"`。如果发生意外且环境未定义，则默认应为`"PRODUCTION"`。在测试构建中意外花费更长的时间编译要好于意外将非生产服务器部署到生产环境中。然后，如果它是生产环境，我们使用发布标志进行编译，如果不是使用发布标志编译，则将静态二进制文件切换到发布目录：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At this point, our application has been compiled. Everything we have covered
    is independent of what type of chip we are using, so the `x86_64_build` file will
    contain the same code that we have just laid out in the `aarch64_build` file.
    For both build files, we can also get our distroless image with the following
    code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序已经编译完成。我们涵盖的所有内容都与我们所使用的芯片类型无关，因此`x86_64_build`文件将包含我们在`aarch64_build`文件中刚刚展示的相同代码。对于这两个构建文件，我们也可以使用以下代码获取我们的distroless镜像：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, this is where the build scripts differ. In the ARM chip build, we must
    copy the libraries needed from the previous Rust image into our distroless image,
    like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是构建脚本不同的地方。在ARM芯片构建中，我们必须从之前的Rust镜像中复制所需的库到我们的distroless镜像中，如下所示：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Including them all would simply provide needless bloat for the book and again,
    these files are available in this book’s GitHub repository. What we must note,
    however, is that the directory for the first part of each copy is the directory
    listed when we explored the Docker image of our large application. The second
    part is the same path; however, if there is a `/usr/lib/` at the start of the
    path, it is shortened to `/lib/`. There is no shell or users in the distroless
    image.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们全部包含在内将仅仅为本书提供无用的膨胀，而且，这些文件都可在本书的GitHub仓库中找到。然而，我们必须注意，每个复制的第一部分的目录是我们探索我们大型应用程序Docker镜像时列出的目录。第二部分是相同的路径；然而，如果路径开头有`/usr/lib/`，则缩短为`/lib/`。distroless镜像中没有shell或用户。
- en: 'Once all the libraries have been copied over, we must copy the static binary
    of our web application into the root of our image, expose the port, and define
    the entry point, which is the static binary, with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有库都已复制，我们必须将我们的Web应用程序的静态二进制文件复制到镜像的根目录，暴露端口，并使用以下代码定义入口点，即静态二进制文件：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With this, our distroless image is done. Right now, both builds are stored away,
    and we will get them out depending on the chip type in a bash script to be built.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们的distroless镜像就完成了。目前，两个构建都已存储起来，我们将根据芯片类型在构建的bash脚本中获取它们。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We don’t have to build our distroless application manually. Instead, we can
    use Apko via the following link: [https://github.com/chainguard-dev/apko](https://github.com/chainguard-dev/apko).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必手动构建我们的distroless应用程序。相反，我们可以通过以下链接使用Apko：[https://github.com/chainguard-dev/apko](https://github.com/chainguard-dev/apko)。
- en: 'You can copy your chosen build to the root directory of the repository under
    the `Dockerfile` filename. Then, run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你选择的构建复制到存储库根目录下的 `Dockerfile` 文件名下。然后运行以下命令：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you list your Docker images, you will see that this image is 46.5 MB! This
    is a massive reduction from 1.5 GB. In the next section, we will include these
    build files in a test pipeline.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你列出你的 Docker 镜像时，你会看到这个镜像大小为 46.5 MB！这比 1.5 GB 减少了大量。在下一节中，我们将将这些构建文件包含在测试管道中。
- en: Building a clean test pipeline
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个干净的测试管道
- en: 'When it comes to testing our application, we want to package it in the Docker
    image that we wish to deploy onto the servers, run migrations on the database
    as we would on the servers, and run a series of Postman requests and tests to
    mimic a user making a series of requests. This can be orchestrated with one Bash
    script in the `scripts/run_full_release_test.sh` file. First, we must find out
    what chip we are running on with the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试我们的应用程序时，我们希望将其打包到我们希望部署到服务器上的 Docker 镜像中，就像在服务器上一样在数据库上运行迁移，并运行一系列 Postman
    请求和测试来模拟用户发起一系列请求。这可以通过 `scripts/run_full_release_test.sh` 文件中的一个 Bash 脚本来编排。首先，我们必须使用以下代码找出我们正在运行的芯片：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we pull the correct build depending on the type of chip. Depending on
    the computer you are using, this might be different. I am using a Mac M1, so when
    I call the `uname -m` command in the terminal, I get an `arm64` output. If you
    are not using an arch or ARM chip, you do not need the conditional logic. Instead,
    you just need to pull the `x86_64_build` file. Then, we must move to the `tests`
    directory and build our `docker-compose` with the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据芯片类型拉取正确的构建。根据你使用的计算机，这可能会不同。我使用的是 Mac M1，所以当我在终端中调用 `uname -m` 命令时，我得到一个
    `arm64` 输出。如果你不是使用 arch 或 ARM 芯片，你不需要条件逻辑。相反，你只需要拉取 `x86_64_build` 文件。然后，我们必须移动到
    `tests` 目录，并使用以下代码构建我们的 `docker-compose`：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We are now ready to run our tests and clean up the images with the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试，并使用以下代码清理镜像：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Before we run this, however, we need to build our `docker-compose` in our `tests`
    directory. Our `tests/docker-compose.yml` file has the following outline:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此代码之前，我们需要在我们的 `tests` 目录中构建我们的 `docker-compose`。我们的 `tests/docker-compose.yml`
    文件具有以下结构：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First, we will focus on the test server. Seeing as we are running a test, we
    need to point to the build, pass a `NOT PRODUCTION` argument into the build, define
    the environment variables for the server to utilize, and then wait for the Redis
    database to be operational before spinning it up. We can do this with the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将关注测试服务器。鉴于我们正在运行测试，我们需要指向构建，将 `NOT PRODUCTION` 参数传递给构建，定义服务器要使用的环境变量，然后在启动之前等待
    Redis 数据库处于运行状态。我们可以用以下代码来完成：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we can see, `docker-compose` is a powerful tool. A few tags can result in
    some complex orchestration. Then, we can move to our database and Redis containers
    with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`docker-compose` 是一个强大的工具。几个标签就可以实现一些复杂的编排。然后，我们可以使用以下代码移动到我们的数据库和 Redis
    容器：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These databases are nothing new. However, in the last service, we create an
    init container that spins up briefly just to run the migrations on the server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库没有什么新意。然而，在最后一个服务中，我们创建了一个短暂的 init 容器，只是为了在服务器上运行迁移：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, there must be a Docker build in the `database` directory for
    our init container to make a database migration before closing. This means that
    our init container must have `psql` installed, our migrations tool, and the `rollup`
    command as the entry point. Initially, we install what we need in our `database/Dockerfile`
    file with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在我们的 init 容器进行数据库迁移并关闭之前，必须在 `database` 目录中进行 Docker 构建。这意味着我们的 init 容器必须安装
    `psql`，我们的迁移工具，以及 `rollup` 命令作为入口点。最初，我们在 `database/Dockerfile` 文件中使用以下代码安装我们需要的：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we can see that we get the `psql` library from the `postgres` Docker
    image. Then, we install `wget` and use this to install our migrations build tool.
    Finally, we copy the `database.sh` Bash script from the home directory into the
    root directory of the image so that we do not have to worry about aliases. Once
    we have configured our installments, we must copy the migrations SQL files from
    the current directory into the root directory of the image and define the migration
    command as the entry point:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们从 `postgres` Docker 镜像中获取了 `psql` 库。然后，我们安装 `wget` 并使用它来安装我们的迁移构建工具。最后，我们将
    `database.sh` Bash 脚本从主目录复制到镜像的根目录，这样我们就不必担心别名问题。一旦我们配置了安装，我们必须将迁移 SQL 文件从当前目录复制到镜像的根目录，并将迁移命令定义为入口点：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will work fine; however, we do have to define a `database/.dockerignore`
    file with the following content to avoid the environment variable being passed
    into the image:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正常工作；然而，我们必须定义一个包含以下内容的 `database/.dockerignore` 文件，以避免环境变量被传递到镜像中：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we do not stop this environment variable from being copied into the image,
    then whatever variables we pass into the init container through `docker-compose`
    could get overwritten.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不阻止这个环境变量被复制到镜像中，那么我们通过 `docker-compose` 传递到初始化容器的任何变量都可能被覆盖。
- en: 'We now have everything we need in place, so all we must do is run our `scripts/run_full_release.sh`
    script. This will produce a lengthy printout of building the images, spinning
    up `docker-compose`, and running the API tests via Newman. The last output should
    look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了所有需要的东西，所以我们只需要运行我们的 `scripts/run_full_release.sh` 脚本。这将产生一个关于构建镜像、启动
    `docker-compose` 和通过 Newman 运行 API 测试的详细输出。最后的输出应该看起来像这样：
- en: '![](img/Figure_13.5_B18722.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5_B18722](img/Figure_13.5_B18722.jpg)'
- en: Figure 13.5 – Result of a full test run
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 完整测试运行的结果
- en: We can see that all the tests ran and passed. Our distroless build works and
    our init container for the database also makes the migrations. Nothing is stopping
    us from putting this infrastructure on AWS, with the difference of pointing to
    images on Docker Hub as opposed to local builds. Considering how small our distroless
    server is, pulling the image from Docker Hub and spinning it up will be very quick.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有测试都已运行并通过。我们的 distroless 构建工作正常，我们的数据库初始化容器也进行了迁移。没有什么能阻止我们将这个基础设施部署到
    AWS，区别在于指向 Docker Hub 上的镜像而不是本地构建。考虑到我们的 distroless 服务器很小，从 Docker Hub 拉取镜像并启动它将会非常快。
- en: We’ve now got all the ingredients to build continuous integration for our GitHub
    repository to ensure that tests are run when we create pull requests. In the next
    and final section, we will configure continuous integration through **GitHub Actions**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了构建 GitHub 仓库持续集成的所有成分，以确保在创建拉取请求时运行测试。在下一节和最后一节中，我们将通过 **GitHub Actions**
    配置持续集成。
- en: Building continuous integration with GitHub Actions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 构建持续集成
- en: When it comes to ensuring that code quality is maintained, it can be handy to
    have a continuous integration pipeline that will run every time a pull request
    is done. We can do this with GitHub Actions. It must be noted that with GitHub
    Actions, you get several free minutes every month; then, you must pay for the
    minutes you go over. So, be careful and keep an eye on how much time you’re spending
    using GitHub Actions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到确保代码质量得到维护时，拥有一个每次拉取请求完成时都会运行的持续集成管道会很有用。我们可以通过 GitHub Actions 来实现这一点。必须注意的是，使用
    GitHub Actions，你每个月可以获得几分钟的免费时间；然后，你必须为超出部分付费。所以，要小心，并留意你使用 GitHub Actions 的时间。
- en: GitHub Actions gives us flexibility when it comes to implementing tasks. We
    can run workflows when a pull request is merged or made and when an issue is created
    and much more. We can also be selective about the type of branches we use. In
    this example, we will merely focus on a pull request on any branch to run unit
    tests and then full integration tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 在执行任务时提供了灵活性。我们可以在合并或创建拉取请求以及创建问题时运行工作流程，还有更多。我们还可以选择使用分支的类型。在这个例子中，我们将仅关注任何分支上的拉取请求以运行单元测试和完整的集成测试。
- en: 'To build a workflow called `tests`, we need to create a file called `.github/workflows/run-tests.yml`.
    In this file, we will define the general outline of the unit and integration tests
    with the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个名为 `tests` 的工作流程，我们需要创建一个名为 `.github/workflows/run-tests.yml` 的文件。在这个文件中，我们将使用以下代码定义单元和集成测试的一般概述：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we have defined the name of the workflow and the conditions that the workflow
    is triggered on pull requests for all branches. Then, we define two jobs – one
    to run unit tests and the other to run integration tests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了工作流程的名称和触发工作流程的条件，即所有分支的拉取请求。然后，我们定义了两个作业——一个用于运行单元测试，另一个用于运行集成测试。
- en: 'Each job has steps. We can also define dependencies for our steps. We can define
    our unit test job with the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作业都有步骤。我们也可以为我们的步骤定义依赖关系。我们可以使用以下代码定义我们的单元测试作业：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we used the `checkout` action. If we do not use the `checkout` action,
    we will not be able to access any of the files in the GitHub repository. Then,
    we export the environment variables that are needed for the unit tests to run,
    and then we run the unit tests using Cargo. Also, note that we define a timeout.
    Defining a timeout is important just in case something ends up in a loop and you
    do not burn all your minutes in one job.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `checkout` 动作。如果我们不使用 `checkout` 动作，我们将无法访问 GitHub 代码库中的任何文件。然后，我们导出单元测试运行所需的环境变量，然后使用
    Cargo 运行单元测试。此外，请注意，我们定义了一个超时。定义超时很重要，以防万一某些操作陷入循环，你不会在一个作业中浪费所有时间。
- en: 'Now, let’s move on to our integration test job:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到我们的集成测试作业：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we move into the `tests` directory, get the server build Docker file,
    spin up `docker-compose`, and then use the `newman` action to run the Newman tests.
    If we make a pull request, the actions will be shown on the pull request. If we
    click on the GitHub Actions button, we can access the status and results, as shown
    in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进入 `tests` 目录，获取服务器构建 Docker 文件，启动 `docker-compose`，然后使用 `newman` 动作运行
    Newman 测试。如果我们发起一个拉取请求，动作将显示在拉取请求中。如果我们点击 GitHub Actions 按钮，我们可以访问状态和结果，如下面的截图所示：
- en: '![Figure 13.6 – GitHub Actions options](img/Figure_13.6_B18722.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – GitHub Actions 选项](img/Figure_13.6_B18722.jpg)'
- en: Figure 13.6 – GitHub Actions options
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – GitHub Actions 选项
- en: 'Then, we can click on the test to see the steps of the job, as shown in the
    following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以点击测试来查看作业的步骤，如下面的截图所示：
- en: '![Figure 13.7 – GitHub Actions job view](img/Figure_13.7_B18722.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – GitHub Actions 作业视图](img/Figure_13.7_B18722.jpg)'
- en: Figure 13.7 – GitHub Actions job view
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – GitHub Actions 作业视图
- en: 'Now, if we click on a step in the job, it will expand. We will see that our
    Newman tests work:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击作业中的某个步骤，它将展开。我们将看到我们的 Newman 测试是有效的：
- en: '![Figure 13.8 – Newman step result](img/Figure_13.8_B18722.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – Newman 步骤结果](img/Figure_13.8_B18722.jpg)'
- en: Figure 13.8 – Newman step result
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – Newman 步骤结果
- en: As we can see, our continuous integration works! We have now come to the end
    of this chapter as our repository is clean and functional.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的持续集成工作正常！现在，随着我们的代码库既干净又实用，我们已经完成了这一章。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have finally made it to the end of structuring a web application in Rust
    and building the infrastructure around the application to make ongoing development
    of new features safe and easy to integrate. We have structured our repository
    into one that’s clean and easy to use where directories have individual purposes.
    Like in well-structured code, our well-structured repository can enable us to
    slot tests and scripts in and out of the repository easily. Then, we used pure
    bash to manage migrations for our database without any code dependencies so that
    we can use our migrations on any application, regardless of the language being
    used. Then, we built init containers to automate database migrations, which will
    work even when deployed on a server or cluster. We also refined the Docker builds
    for our server, making them more secure and reducing the size from 1.5 GB to 45
    MB. After, we integrated our builds and tests into an automated pipeline that
    is fired when new code is merged into the GitHub repository.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了在 Rust 中构建一个 Web 应用程序的结构，并围绕应用程序构建基础设施，以便于新功能的持续开发和轻松集成。我们已经将我们的代码库结构化成一个干净且易于使用的版本，其中目录具有各自的功能。就像在结构良好的代码中一样，我们的结构良好的代码库可以让我们轻松地将测试和脚本添加到代码库中，也可以轻松移除。然后，我们使用纯
    bash 来管理数据库迁移，没有任何代码依赖，这样我们就可以在任何应用程序上使用我们的迁移，无论使用的是哪种语言。接着，我们构建了初始化容器来自动化数据库迁移，即使部署在服务器或集群上也能工作。我们还优化了服务器的
    Docker 构建，使其更加安全，并将大小从 1.5 GB 减少到 45 MB。之后，我们将构建和测试集成到一个自动化的管道中，当新代码合并到 GitHub
    代码库时，该管道会被触发。
- en: This brings a natural end to building a web application and deploying it on
    a server. In the following chapters, we will dive deeper into web programming
    with Rust, looking at lower-level frameworks so that we can build custom protocols
    over TCP sockets. This will enable you to build lower-level applications for web
    servers or even local processes. In the next chapter, we will explore the Tokio
    framework, a building block of async programs such as TCP servers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然地结束了构建 Web 应用程序并将其部署到服务器上的过程。在接下来的章节中，我们将更深入地探讨使用 Rust 进行 Web 编程，查看底层框架，以便我们可以在
    TCP 套接字上构建自定义协议。这将使您能够构建用于 Web 服务器或甚至本地进程的底层应用程序。在下一章中，我们将探讨 Tokio 框架，它是异步程序（如
    TCP 服务器）的构建块。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Database migrations documentation and repository: [https://github.com/yellow-bird-consult/build_tools](https://github.com/yellow-bird-consult/build_tools)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库迁移文档和仓库：[https://github.com/yellow-bird-consult/build_tools](https://github.com/yellow-bird-consult/build_tools)
- en: 'GitHub Actions documentation: [https://docs.github.com/en/actions/guides](https://docs.github.com/en/actions/guides)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 文档：[https://docs.github.com/en/actions/guides](https://docs.github.com/en/actions/guides)
- en: Questions
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The bash migrations tool uses incremental single-digit integers to denote migrations.
    What is the big downside to this?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: bash 迁移工具使用增量单个数字整数来表示迁移。这种方法的重大缺点是什么？
- en: Why are distroless servers more secure?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么无发行版服务器更安全？
- en: How did we remove the need for Python when running our Newman tests that required
    a fresh token?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是如何在运行需要刷新令牌的新曼测试时移除对 Python 的需求的？
- en: What are the advantages of using environment variables for configuration values?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环境变量作为配置值的优点是什么？
- en: Answers
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Using incremental single-digit integers exposes the migrations to clashes. So,
    if one developer writes migrations on one branch while another developer writes
    migrations on a different branch, there will be a conflict of migrations when
    they both merge. GitHub should pick this up, but it’s important to keep the traffic
    of migrations low, plan out database alterations properly, and keep the services
    using the migrations small. If this is a concern for you, however, please use
    a different migrations tool that is heavier but has more guardrails.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用增量单个数字整数会使迁移容易发生冲突。因此，如果一个开发者在一个分支上编写迁移，而另一个开发者同时在另一个分支上编写迁移，当他们合并时，将会有迁移冲突。GitHub
    应该能够处理这个问题，但重要的是要尽量减少迁移流量，合理规划数据库变更，并保持使用迁移的服务规模较小。然而，如果您对此有顾虑，请使用其他更重但具有更多安全措施的迁移工具。
- en: Distroless servers do not have shells. This means that if a hacker manages to
    access our server container, they cannot run any commands or inspect the contents
    of the container.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无发行版服务器没有外壳。这意味着如果黑客设法访问我们的服务器容器，他们无法运行任何命令或检查容器的内容。
- en: In the login request, we get the token that is returned from the server in the
    test script and assign it to a collection variable that can be accessed by other
    requests, removing the reliance on Python.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录请求中，我们在测试脚本中获取服务器返回的令牌，并将其分配给一个可以被其他请求访问的集合变量，从而消除了对 Python 的依赖。
- en: Environment variables are simply easier to implement when deploying our application
    to the cloud. For instance, Kubernetes’s ConfigMaps use environment variables
    to pass variables into Docker containers. It is also easier to implement services
    such as Secrets Manager on AWS by using environment variables.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将应用程序部署到云端时，环境变量更容易实现。例如，Kubernetes 的 ConfigMaps 使用环境变量将变量传递到 Docker 容器中。通过使用环境变量，在
    AWS 上实现 Secrets Manager 等服务也更为简便。
- en: Part 6:Exploring Protocol Programming and Async Concepts with Low-Level Network
    Applications
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 部分：使用底层网络应用程序探索协议编程和异步概念
- en: Web programming has evolved to more than just simple applications that interact
    with databases. In this part, we cover more advanced concepts with async Rust
    by covering the basics of async Rust, Tokio, and Hyper. With Tokio and Hyper,
    we leverage async Rust and the actor model to implement async designs such as
    passing messages between actors in different threads, queuing tasks in Redis to
    be consumed by multiple workers, and processing byte streams with Tokio framing
    and TCP ports. By the end of this part, you will be able to implement more complex
    event-processing solutions on your server to handle more complex problems. You
    will also have practical knowledge of how to implement async Rust, which is an
    up-and-coming field.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程已经发展到了不仅仅是与数据库交互的简单应用。在本部分，我们通过介绍异步Rust的基础知识、Tokio和Hyper，来涵盖更高级的概念。通过Tokio和Hyper，我们利用异步Rust和actor模型来实现异步设计，例如在不同线程之间传递actor的消息、在Redis中排队任务以便多个工作者消费，以及使用Tokio的帧和TCP端口处理字节流。在本部分结束时，你将能够在你的服务器上实现更复杂的事件处理解决方案来处理更复杂的问题。你还将具备如何实现异步Rust的实际知识，这是一个新兴领域。
- en: 'This part includes the following chapters:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 14*](B18722_14.xhtml#_idTextAnchor279), *Exploring the Tokio Framework*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18722_14.xhtml#_idTextAnchor279)，*探索Tokio框架*'
- en: '[*Chapter 15*](B18722_15.xhtml#_idTextAnchor291), *Accepting TCP Traffic with
    Tokio*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18722_15.xhtml#_idTextAnchor291)，*使用Tokio接受TCP流量*'
- en: '[*Chapter 16*](B18722_16.xhtml#_idTextAnchor306), *Building Protocols on Top
    of TCP*'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B18722_16.xhtml#_idTextAnchor306)，*在TCP之上构建协议*'
- en: '[*Chapter 17*](B18722_17.xhtml#_idTextAnchor323), *Implementing Actors and
    Async with the Hyper Framework*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B18722_17.xhtml#_idTextAnchor323)，*使用Hyper框架实现Actors和异步*'
- en: '[*Chapter 18*](B18722_18.xhtml#_idTextAnchor335), *Queuing Tasks with Redis*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B18722_18.xhtml#_idTextAnchor335)，*使用Redis排队任务*'
