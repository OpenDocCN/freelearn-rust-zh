<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing and Debugging Rust Microservices</h1>
                </header>
            
            <article>
                
<p>Microservices, like any other application, can have bugs. You can make a mistake when writing new code, or by adding extra features to an application. In this chapter, we will explore the available tools to test and debug your microservices.</p>
<p>We will start by creating unit and integration tests for an application. We will also examine the testing capabilities of the <kbd>actix</kbd> crate.</p>
<p>After this, we will study debugging with the LLDB Debugger, and also examine logging as a debugging technique, since not every bug can be caught with a traditional debugger. Furthermore, if you use a product in production, you can't attach a debugger to it.</p>
<p>We will cover the following topics in this chapter: </p>
<ul>
<li>
<p>Testing microservices</p>
</li>
<li>
<p>Debugging microservices</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>For the testing examples of this chapter, you need some extra software besides Rust compiler (which, of course, you'll need too). You will need to install Docker and Docker Compose to bootstrap the application from <a href="http://Packing%20Servers%20to%20Containers">Chapter 15</a>, <em><span>Packing Servers to</span> C<span>ontainers</span></em>. We will use this application to run integration tests.</p>
<p>You will also need to install<span> the </span>Postman tool, which we will use to test APIs manually, along with the LLDB debugger, which we'll learn how to use for debugging microservices. <span>Also, Jaeger will need to be installed, but you can also use the all-in-one image running in Docker for this. </span>Finally, we will use<span> the</span> OpenTracing API for distributed tracing. </p>
<p>The examples of this chapter are provided with sources on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter13.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing microservices</h1>
                </header>
            
            <article>
                
<p>Rust is an almost perfect tool for creating reliable applications. The compiler is so strict and never misses any potential memory access error or data race, but still there are many ways to make a mistake in the code. In other words, Rust helps you a lot, but it is not omnipotent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>Microservices can <span>also </span>have bugs, so you have to be armed to handle all possible bugs. The first line of defense is unit testing.</p>
<p>Unit testing involves using HTTP clients to send an isolated request to a server or a request handler. In a unit test, you should check only one function. It's necessary to cover the majority of the code that helps to keep the same behavior of a function that can be reimplemented or improved with tests.</p>
<p>Also, you can write a test before writing any piece of code. It's called <strong>Test-Driven Development</strong> (<strong>TDD</strong>), but this approach is suitable for projects that have a good specification, because if you haven't decided on the solution, you will have to rewrite tests multiple times. In other words, TDD is not suitable for projects in which bugs are not critical, but where high-speed development is required.</p>
<p>Writing unit tests for traditional crates is simple, but for microservices, you have a lot of issues with emulating the environment in which a microservice will work in production. To emulate an environment, you can use mocking services that create HTTP servers with predefined responses for specified requests. Do you remember, in <a href="5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml">Chapter 11,</a> <em>Involving Concurrency with Actors and Actix Crate</em>, when we created a routing microservice that we can't test, because we have to run a lot of microservices manually? In this section, we will create a unit test for that very routing microservice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mocking</h1>
                </header>
            
            <article>
                
<p>Let's create a <kbd>mock</kbd> server that emulates responses for requests to three paths to a routing microservice: <kbd>/signin</kbd>, <kbd>/signup</kbd>, and <kbd>/comments</kbd>. There is the <kbd>mockito</kbd> crate that provides a server for emulating HTTP responses. We will use the example from <a href="5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml">Chapter 11</a>, <em>Involving Concurrency with Actors and the Actix Crate</em>. Copy it and add these extra dependencies:</p>
<pre>mockito = "0.15"<br/>reqwest = "0.9"</pre>
<p>We need the <kbd>mockito</kbd> crate to start a server with mocks, and the <kbd>reqwest</kbd> crate to make HTTP requests to our Actix server instance.</p>
<p>Create a <kbd>tests</kbd> module with the <kbd>#[cfg(test)]</kbd> attribute that will be compiled for testing only, and import the following types that we will use for testing:</p>
<pre>use crate::{start, Comment, LinksMap, UserForm, UserId};<br/>use lazy_static::lazy_static;<br/>use mockito::{mock, Mock};<br/>use reqwest::Client;<br/>use serde::{Deserialize, Serialize};<br/>use std::sync::Mutex;<br/>use std::time::Duration;<br/>use std::thread;</pre>
<p>We use types of router microservices to prepare requests; namely, <kbd>Comment</kbd>, <kbd>UserForm</kbd>, and <kbd>UserId</kbd>. Also, we added<span> the</span> <kbd>LinksMap</kbd> struct to configure URLs to mocks:</p>
<pre>#[derive(Clone)]<br/>struct LinksMap {<br/>    signup: String,<br/>    signin: String,<br/>    new_comment: String,<br/>    comments: String,<br/>}</pre>
<p>Add this struct to <kbd>State</kbd> and use it with handlers to get<span> the</span> URLs of microservices:</p>
<pre>#[derive(Clone)]<br/>struct State {<br/>    counter: RefCell&lt;i64&gt;,<br/>    links: LinksMap,<br/>}</pre>
<p>Also, we imported<span> the</span> <kbd>lazy_static!</kbd> macro that we need to initialize a <kbd>Mutex</kbd>, which we will use to check that the Actix Server started once. Rust also has<span> the</span> <kbd>Once</kbd> type, which can also be used, but we need to wait a certain interval before letting the services perform requests, and the <kbd>is_completed</kbd> method of <kbd>Once</kbd> type is unstable. To create mocks, we will use<span> the</span> <kbd>mock</kbd> function of the <kbd>mockito</kbd> crate and a <kbd>Mock</kbd> type that represents a handler of a specific request.</p>
<p>Create a function to add mocks, as follows:</p>
<pre>fn add_mock&lt;T&gt;(method: &amp;str, path: &amp;str, result: T) -&gt; Mock<br/>where<br/>    T: Serialize,<br/>{<br/>    mock(method, path)<br/>        .with_status(200)<br/>        .with_header("Content-Type", "application/json")<br/>        .with_body(serde_json::to_string(&amp;result).unwrap())<br/>        .create()<br/>}</pre>
<p>The <kbd>add_mock</kbd> function expects an HTTP method and path to emulated resource. Also, it takes a value returned as a response in JSON format.</p>
<p>We call the <kbd>mock</kbd> function to create a <kbd>Mock</kbd> instance and tune it with the following methods:</p>
<ul>
<li><kbd>with_status</kbd> sets the status code of a response</li>
<li><kbd>with_header</kbd> sets a specific value for a header</li>
<li><kbd>with_body</kbd> sets the body of a response</li>
</ul>
<p>Finally, we call the <kbd>crate</kbd> method, which tries to start a <kbd>mock</kbd> server and attach our created <kbd>Mock</kbd> to it. Now, we can start a router microservice instance and prepare all the necessary mocks to emulate other microservices that the router expects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting a server for testing</h1>
                </header>
            
            <article>
                
<p>We will start a server instance in a separate thread, because Rust runs tests in multiple threads, and we won't create a server instance with a unique port for every test run to show how you can use a shared instance, because integration tests often need to reuse the same application instance. Create a shared flag that we will use to detect routers that have already started:</p>
<pre>lazy_static! {<br/>    static ref STARTED: Mutex&lt;bool&gt; = Mutex::new(false);<br/>}</pre>
<p>Now, we will use this <kbd>Mutex</kbd> to create a function to start a server. Look at the following <kbd>setup</kbd> function implementation:</p>
<pre>fn setup() {<br/>    let mut started = STARTED.lock().unwrap();<br/>    if !*started {<br/>        thread::spawn(|| {<br/>            let url = mockito::server_url();<br/>            let _signup = add_mock("POST", "/signup", ());<br/>            let _signin = add_mock("POST", "/signin", UserId { id: "user-id".into() });<br/>            let _new_comment = add_mock("POST", "/new_comment", ());<br/>            let comment = Comment {<br/>                id: None,<br/>                text: "comment".into(),<br/>                uid: "user-id".into(),<br/>            };<br/>            let _comments = add_mock("GET", "/comments", vec![comment]);<br/>            let links = LinksMap {<br/>                signup: mock_url(&amp;url, "/signup"),<br/>                signin: mock_url(&amp;url, "/signin"),<br/>                new_comment: mock_url(&amp;url, "/new_comment"),<br/>                comments: mock_url(&amp;url, "/comments"),<br/>            };<br/>            start(links);<br/>        });<br/>        thread::sleep(Duration::from_secs(5));<br/>        *started = true;<br/>    }<br/>}</pre>
<p>The preceding function locks a <kbd>Mutex</kbd> to get the value of the flag. If it equals <kbd>false</kbd>, we spawn a new thread with a server instance and mocks, and wait 5 seconds before we set the flag to <kbd>true</kbd> and release the <kbd>Mutex</kbd>.</p>
<p>In the spawned thread, we get a URL or <kbd>mock</kbd> server. It automatically starts that server if it wasn't started already. After this, we use the <kbd>add_mock</kbd> method to add all mocks to emulate other microservices.</p>
<div class="mce-root packt_infobox">The <kbd>mockito</kbd> crate requires you <span>to</span><span> </span><span>have added all the mocks in the same thread in which the <kbd>mock</kbd> server started.</span></div>
<p>Also, we keep all crated mocks in local variables. If any of them are dropped, then that mocking handler will be lost. You can <span>also</span> use the <kbd>std::mem::forget</kbd> method to ensure that the mock will be never dropped, but it's more accurate to leave the local variable.</p>
<p>We will employ <kbd>LinksMap</kbd> using the URL of the <kbd>mock</kbd> server and paths, both of which are concatenated with the following function:</p>
<pre>fn mock_url(base: &amp;str, path: &amp;str) -&gt; String {<br/>    format!("{}{}", base, path)<br/>}</pre>
<p>Finally, we called the <kbd>start</kbd> function, which is actually a modified <kbd>main</kbd> function:</p>
<pre>fn start(links: LinksMap) {<br/>    let sys = actix::System::new("router");<br/>    let state = State {<br/>        counter: RefCell::default(),<br/>        links,<br/>    };<br/>    server::new(move || {<br/>        App::with_state(state.clone())<br/>            // App resources attached here<br/>    }).workers(1).bind("127.0.0.1:8080").unwrap().start();<br/>    sys.run();<br/>}</pre>
<p>The difference between this and the <kbd>main</kbd> function of the router microservice of <a href="5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml">Chapter 11</a>, <em>Involving Concurrency with Actors and Actix Crate</em>, is that it expects the <kbd>LinksMap</kbd> value to add it to <kbd>State</kbd>. Now, we can create methods to perform testing requests to a server that resends them to mocks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making requests</h1>
                </header>
            
            <article>
                
<p>To make <kbd>GET</kbd> requests, we will use the <kbd>test_get</kbd> function, which creates a <kbd>Client</kbd> of<span> the</span> <kbd>reqwest</kbd> crate, sets a path, executes a <kbd>send</kbd> request, and deserializes<span> the </span>response from JSON:</p>
<pre>fn test_get&lt;T&gt;(path: &amp;str) -&gt; T<br/>where<br/>    T: for &lt;'de&gt; Deserialize&lt;'de&gt;,<br/>{<br/>    let client =  Client::new();<br/>    let data = client.get(&amp;test_url(path))<br/>        .send()<br/>        .unwrap()<br/>        .text()<br/>        .unwrap();<br/>    serde_json::from_str(&amp;data).unwrap()<br/>}</pre>
<p>If you are familiar with the <kbd>reqwest</kbd> crate, you may ask why we get text values, since <kbd>Client</kbd> has<span> the</span> <kbd>json</kbd> method that deserializes JSON? If we do that, we can't see the original value if we have deserialization issues, but using the original text of a response, we can log it for investigation.</p>
<p>To generate URLs, we use the following function:</p>
<pre>fn test_url(path: &amp;str) -&gt; String {<br/>    format!("http://127.0.0.1:8080/api{}", path)<br/>}</pre>
<p>This adds<span> the</span> address of a server to which we bind it, but for large projects, it's better to use dynamic addresses, especially if you want to use a fresh server instance in every test.</p>
<p>For <kbd>POST</kbd> requests, we will use similar method, but we won't deserialize the result because we don't need it and will check the status of a response only:</p>
<pre>fn test_post&lt;T&gt;(path: &amp;str, data: &amp;T)<br/>where<br/>    T: Serialize,<br/>{<br/>    setup();<br/>    let client =  Client::new();<br/>    let resp = client.post(&amp;test_url(path))<br/>        .form(data)<br/>        .send()<br/>        .unwrap();<br/>    let status = resp.status();<br/>    assert!(status.is_success());<br/>}</pre>
<p>We have all the necessary functions to implement unit tests for every handler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing tests</h1>
                </header>
            
            <article>
                
<p>With the utilities we've created so far in this chapter, the unit tests look pretty compact. To test the handler of the <kbd>/signup</kbd> path that expects <kbd>UserForm</kbd>, we will add a <kbd>test_signup_with_client</kbd> function with the <kbd>#[test]</kbd> <span>attribute:</span></p>
<pre>#[test]<br/>fn test_signup_with_client() {<br/>    let user = UserForm {<br/>        email: "abc@example.com".into(),<br/>        password: "abc".into(),<br/>    };<br/>    test_post("/signup", &amp;user);<br/>}</pre>
<p>When we run the <kbd>cargo test</kbd> command, this function will be called and<span> the</span> <kbd>test_post</kbd> call, in turn, will bootstrap a server with a <kbd>mock</kbd> server as well.</p>
<p>To test a handler of the <kbd>/signin</kbd> path, we will use the following function:</p>
<pre>#[test]<br/>fn test_signin_with_client() {<br/>    let user = UserForm {<br/>        email: "abc@example.com".into(),<br/>        password: "abc".into(),<br/>    };<br/>    test_post("/signin", &amp;user);<br/>}</pre>
<p>This test uses the same input values with a <kbd>POST</kbd> request.</p>
<p>To fetch a list of comments, it's enough to call the <kbd>test_get</kbd> function with<span> the</span> <kbd>/comments</kbd> path:</p>
<pre>#[test]<br/>fn test_list_with_client() {<br/>    let _: Vec&lt;Comment&gt; = test_get("/comments");<br/>}</pre>
<p>Now, we can start these tests to check<span> the</span> router microservice that forwards requests to a <kbd>mock</kbd> server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our tests</h1>
                </header>
            
            <article>
                
<p>To run the unit test, run Cargo's <kbd>test</kbd> command in the folder of this project. It will start three tests and you will see, in the Terminal, the output of the command:</p>
<pre>running 3 tests<br/>test tests::test_list_with_client ... ok<br/>test tests::test_signup_with_client ... ok<br/>test tests::test_signin_with_client ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>All of the tests have passed, but let's check what happens if we change something in the implementation. Let's remove a <kbd>Mock</kbd> for the <kbd>/signin</kbd> path. The test will print that one test has failed:</p>
<pre>running 3 tests<br/>test tests::test_list_with_client ... ok<br/>test tests::test_signin_with_client ... FAILED<br/>test tests::test_signup_with_client ... ok<br/><br/>failures:<br/>---- tests::test_signin_with_client stdout ----<br/>thread 'tests::test_signin_with_client' panicked at 'assertion failed: status.is_success()', src/lib.rs:291:9<br/>note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.<br/><br/>failures:<br/>    tests::test_signin_with_client<br/><br/>test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>As expected, the <kbd>tests::test_signin_with_client</kbd> test failed, because it can't get a response from the <kbd>/signin</kbd> request. Unit testing will help you ensure the behavior of a handler won't be changed, even if you rewrite the implementation from scratch.</p>
<p>We covered a microservice with a unit test using predefined methods to simplify bootstrapping a server and to send HTTP requests to it. If you want to test complex interaction with an application, you should implement integration tests, which we will cover now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integration testing</h1>
                </header>
            
            <article>
                
<p>Unit testing can't guarantee that the whole application works, because it tests only a small piece of implementation. By contrast, integration tests are more complex and they help to ensure your whole application works properly. We combined some microservices that we created for this book into one application. Let's create integration tests to check the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting an application instance</h1>
                </header>
            
            <article>
                
<p>Before we write the first line of a testing code, we have to start an application with Docker. It's complex and you will learn how to make it in <a href="80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml">Chapter 15</a>, <em><span>Packing Servers to Containers</span></em>, but for now, open the code samples folder of that chapter and start a project from the Docker Compose script. However, you will also have to prepare an image for building microservices. Enter these two commands into a Terminal:</p>
<pre>docker build -t rust:nightly nightly<br/>docker-compose -f docker-compose.test.yml up</pre>
<p>The project already contains a special Compose file, <kbd>docker-compose.test.yml</kbd>, that opens the ports of the containers to make it possible to connect to them from our local Rust application.</p>
<p>It takes time to start, but when the application has started, you will see the log in a Terminal window. Then, we can write some integration tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article>
                
<p>You might be surprised, but for integration testing, we don't need a lot of dependencies, because we will use an HTTP client and the <kbd>serde</kbd> family of crates to serialize requests and deserialize responses:</p>
<pre>cookie = "0.11"<br/>rand = "0.6"<br/>reqwest = "0.9"<br/>serde = "1.0"<br/>serde_derive = "1.0"<br/>serde_json = "1.0"<br/>uuid = { version = "0.5", features = ["serde", "v4"] }</pre>
<p>Also, we need<span> the</span> <kbd>uuid</kbd> crate to generate unique values, and<span> the</span> <kbd>cookie</kbd> crate to support cookies in our HTTP requests, because integration tests have to keep the session to make a sequence of meaningful requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utils</h1>
                </header>
            
            <article>
                
<p>Like we did for unit tests, we'll add some utility function to avoid creating HTTP clients for every test. We will use predefined methods to health-check and to send <kbd>POST</kbd> and <kbd>GET</kbd> requests to microservices included in the application. Create a <kbd>utils.rs</kbd> file and import<span> the</span> necessary types:</p>
<pre>use cookie::{Cookie, CookieJar};<br/>use rand::{Rng, thread_rng};<br/>use rand::distributions::Alphanumeric;<br/>pub use reqwest::{self, Client, Method, RedirectPolicy, StatusCode};<br/>use reqwest::header::{COOKIE, SET_COOKIE};<br/>use serde::Deserialize;<br/>use std::collections::HashMap;<br/>use std::iter;<br/>use std::time::Duration;<br/>use std::thread;</pre>
<p>We will use a <kbd>Client</kbd> instance from the <kbd>reqwest</kbd> crate, just as we did for the unit test, but we'll need to import extra types: <kbd>Method</kbd> to set different HTTP methods exactly; <kbd>RedirectPolicy</kbd> to control redirects, since the router microservice will redirect us to other pages; and <kbd>Client</kbd>, which will perform those redirects, but we want to turn off this behavior. <kbd>StatusCode</kbd> is used to check returned HTTP status codes.</p>
<p>We imported<span> the</span> <kbd>COOKIE</kbd> and <kbd>SET_COOKIE</kbd> headers to set the values of those headers for requests, and get their values from the responses. But the values of those headers are formal and we need to parse them. To simplify this, we will use<span> the</span> <kbd>Cookie</kbd> and <kbd>CookieJar</kbd> types of the cookie crate, since<span> the</span> <kbd>reqwest</kbd> crate doesn't support cookies now.</p>
<p>Also, we use<span> the</span> <kbd>rand</kbd> crate and the imported <kbd>Alphanumeric</kbd> distribution from it to generate unique logins for testing, because we will interact with a working application and simply <span>can't </span>restart it now.</p>
<p>Our application contains four microservices with the following addresses, all of which are available from the Docker containers of our application:</p>
<pre>const USERS: &amp;str = "http://localhost:8001";<br/>const MAILER: &amp;str = "http://localhost:8002";<br/>const CONTENT: &amp;str = "http://localhost:8003";<br/>const ROUTER: &amp;str = "http://localhost:8000";</pre>
<p>We declared addresses as constant, so that we have a single place to update them if necessary:</p>
<pre>pub fn url(url: &amp;str, path: &amp;str) -&gt; String {<br/>    url.to_owned() + path<br/>}</pre>
<p>Also, we need a function to generate random strings that consist of alphanumeric characters:</p>
<pre>pub fn rand_str() -&gt; String {<br/>    let mut rng = thread_rng();<br/>    iter::repeat(())<br/>            .map(|()| rng.sample(Alphanumeric))<br/>            .take(7)<br/>            .collect()<br/>}</pre>
<p>The preceding code uses a random number generator that's initialized for the current thread, and an iterator that generates random values, to take 7 characters and join them into <kbd>String</kbd> values.</p>
<p>Since integration tests work with live systems, we need a function to sleep the current thread:</p>
<pre>pub fn wait(s: u64) {<br/>    thread::sleep(Duration::from_secs(s));<br/>}</pre>
<p>This function is a short alias for <span>the</span> <kbd>thread::sleep</kbd> call.</p>
<p>But it's not all about utilities—we also need a universal client to send requests to all working microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The integration testing client</h1>
                </header>
            
            <article>
                
<p>Add the following struct to your <kbd>utils.rs</kbd> source file:</p>
<pre>pub struct WebApi {<br/>    client: Client,<br/>    url: String,<br/>    jar: CookieJar,<br/>}</pre>
<p>It has three fields—an HTTP <kbd>Client</kbd>; a base <kbd>url</kbd>, which is used to construct full URLs with added paths; and a <kbd>CookieJar</kbd> instance to keep cookie values between requests.</p>
<p>The constructor of this struct takes a URL and builds a <kbd>Client</kbd> instance with redirects disabled:</p>
<pre>impl WebApi {<br/>    fn new(url: &amp;str) -&gt; Self {<br/>        let client = Client::builder()<br/>            .redirect(RedirectPolicy::none())<br/>            .build()<br/>            .unwrap();<br/>        Self {<br/>            client,<br/>            url: url.into(),<br/>            jar: CookieJar::new(),<br/>        }<br/>    }<br/>}</pre>
<p>We can add shortcuts to create instances of <kbd>WebApi</kbd> for the specific microservice of our application:</p>
<pre>pub fn users() -&gt; Self { WebApi::new(USERS) }<br/>pub fn mailer() -&gt; Self { WebApi::new(MAILER) }<br/>pub fn content() -&gt; Self { WebApi::new(CONTENT) }<br/>pub fn router() -&gt; Self { WebApi::new(ROUTER) }</pre>
<p>We will check that every microservice is alive. To do this, we need a method for <kbd>WebApi</kbd> that sends <kbd>GET</kbd> requests to a specified path and checks the response:</p>
<pre>pub fn healthcheck(&amp;mut self, path: &amp;str, content: &amp;str) {<br/>    let url = url(&amp;self.url, path);<br/>    let mut resp = reqwest::get(&amp;url).unwrap();<br/>    assert_eq!(resp.status(), StatusCode::OK);<br/>    let text = resp.text().unwrap();<br/>    assert_eq!(text, content);<br/>}</pre>
<p>Every microservice of our application has a special path to get the name of microservice, which we will use for health-checking.</p>
<p>To send requests to microservices, we will use the following function:</p>
<pre>pub fn request&lt;'a, I, J&gt;(&amp;mut self, method: Method, path: &amp;'a str, values: I) -&gt; J<br/>where<br/>    I: IntoIterator&lt;Item = (&amp;'a str, &amp;'a str)&gt;,<br/>    J: for &lt;'de&gt; Deserialize&lt;'de&gt;,<br/>{<br/>    let url = url(&amp;self.url, path);<br/>    let params = values.into_iter().collect::&lt;HashMap&lt;_, _&gt;&gt;();<br/>    let mut resp = self.client.request(method, &amp;url)<br/>        .form(&amp;params)<br/>        .send()<br/>        .unwrap();<br/><br/>    let status = resp.status().to_owned();<br/><br/>    let text = resp<br/>        .text()<br/>        .unwrap();<br/><br/>    if status != StatusCode::OK {<br/>        panic!("Bad response [{}] of '{}': {}", resp.status(), path, text);<br/>    }<br/><br/>    let value = serde_json::from_str(&amp;text);<br/>    match value {<br/>        Ok(value) =&gt; value,<br/>        Err(err) =&gt; {<br/>            panic!("Can't convert '{}': {}", text, err);<br/>        },<br/>    }<br/>}</pre>
<p>It's a useful function that sends a request in JSON format and receives a response in JSON format, which it deserializes into the necessary native struct. The implementation of this method is not crazy. It expects a HTTP method, path, and values that will be used as form parameters in a request.</p>
<p>We use a textual response to print values if the microservice returns an HTTP status other than <kbd>OK</kbd>. If a response is successful, we will deserialize the body from JSON format to the necessary output type.</p>
<p>Since the whole application won't return internal service information to us, we need a method that creates a request and checks the status code of a response, but also stores cookies to have a chance to sign up and sign in to our application. Create<span> the</span> <kbd>check_status</kbd> method for the <kbd>WebApi</kbd> struct implementation:</p>
<pre>pub fn check_status&lt;'a, I&gt;(&amp;mut self, method: Method, path: &amp;'a str, values: I, status: StatusCode)<br/>where<br/>    I: IntoIterator&lt;Item = (&amp;'a str, &amp;'a str)&gt;,<br/>{<br/>    let url = url(&amp;self.url, path);<br/>    let params = values.into_iter().collect::&lt;HashMap&lt;_, _&gt;&gt;();<br/>    let cookies = self.jar.iter()<br/>        .map(|kv| format!("{}={}", kv.name(), kv.value()))<br/>        .collect::&lt;Vec&lt;_&gt;&gt;()<br/>        .join(";");<br/>    let resp = self.client.request(method, &amp;url)<br/>        .header(COOKIE, cookies)<br/>        .form(&amp;params)<br/>        .send()<br/>        .unwrap();<br/>    if let Some(value) = resp.headers().get(SET_COOKIE) {<br/>        let raw_cookie = value.to_str().unwrap().to_owned();<br/>        let cookie = Cookie::parse(raw_cookie).unwrap();<br/>        self.jar.add(cookie);<br/>    }<br/>    assert_eq!(status, resp.status());<br/>}</pre>
<p>The preceding implementation also uses values to make a request with a form, but it also prepares cookies and sends them with<span> the</span> <kbd>Cookie</kbd>  header after the function expects a response from a server. If a response contains a <kbd>SetCookie</kbd> header, we use it to update our <kbd>CookieJar</kbd>. With such simple manipulations, we take a method that can keep the connection session.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types</h1>
                </header>
            
            <article>
                
<p>Before we start implementing tests, we need to add some types that we need to interact with microservices. Create a <kbd>types.rs</kbd> source file with types:</p>
<pre>use serde_derive::Deserialize;<br/>use uuid::Uuid;</pre>
<p>Now, add a <kbd>UserId</kbd> struct that will be used to parse raw responses from the <kbd>users</kbd> microservices (yes, we will also test it directly):</p>
<pre>#[derive(Deserialize)]<br/>pub struct UserId {<br/>    id: Uuid,<br/>}</pre>
<p>Also, add a <kbd>Comment</kbd> struct that we will use to post new comments to our content microservice:</p>
<pre>#[derive(Deserialize)]<br/>pub struct Comment {<br/>    pub id: i32,<br/>    pub uid: String,<br/>    pub text: String,<br/>}</pre>
<p>Now, we can write tests for every microservice separately, and after that, create a test for complex interaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Users</h1>
                </header>
            
            <article>
                
<p>We will start the <kbd>users</kbd> microservice test coverage. Create a <kbd>users.rs</kbd> file and import the created modules into it with the necessary types:</p>
<pre>mod types;<br/>mod utils;<br/><br/>use self::types::UserId;<br/>use self::utils::{Method, WebApi};</pre>
<p>At first, we have to check that the microservice is alive. Add<span> the</span> <kbd>users_healthcheck</kbd> method:</p>
<pre>#[test]<br/>fn users_healthcheck() {<br/>    let mut api = WebApi::users();<br/>    api.healthcheck("/", "Users Microservice");<br/>}</pre>
<p>It creates an instance of<span> the</span> <kbd>WebApi</kbd> struct using<span> the</span> <kbd>users</kbd> method that already configures it for interaction with the users microservice. We use<span> the</span> <kbd>healthcheck</kbd> method to check the root path of a service that has to return<span> the</span> <kbd>"Users Microservice"</kbd> string.</p>
<p>The main purpose of<span> the</span> <kbd>users</kbd> microservice is a new users' registration, and<span> the</span> authorization of registered users. Create a <kbd>check_signup_and_signin</kbd> function that will generate a new user, register it by sending a request to the <kbd>/signup</kbd> path, and then try to log in using the <kbd>/signin</kbd> path:</p>
<pre>#[test]<br/>fn check_signup_and_signin() {<br/>    let mut api = WebApi::users();<br/>    let username = utils::rand_str() + "@example.com";<br/>    let password = utils::rand_str();<br/>    let params = vec![<br/>        ("email", username.as_ref()),<br/>        ("password", password.as_ref()),<br/>    ];<br/>    let _: () = api.request(Method::POST, "/signup", params);<br/><br/>    let params = vec![<br/>        ("email", username.as_ref()),<br/>        ("password", password.as_ref()),<br/>    ];<br/>    let _: UserId = api.request(Method::POST, "/signin", params);<br/>}</pre>
<p>We created a new <kbd>WebApi</kbd> instance that has targeted to our <kbd>users</kbd> microservice. The values of the <kbd>username</kbd> and <kbd>password</kbd> are generated by<span> the </span><kbd>rand_str</kbd> function call of<span> the</span> <kbd>utils</kbd> module that we created earlier. After this, we prepare parameters to emulate sending an HTML form to a server with a <kbd>POST</kbd> request. The first request registers a new user; the second request tries to authorize it with the same form parameters.</p>
<p>Since the users microservice is used internally by<span> the</span> router microservice, it returns a raw <kbd>UserId</kbd> struct. We will parse it, but won't use it, because we have already checked that<span> the</span> microservice works, as it won't return users' IDs for bad credentials.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content</h1>
                </header>
            
            <article>
                
<p>The next microservice we need to test is a content microservice that allows users to post comments. Create a <kbd>content.rs</kbd> file and import<span> the</span> <kbd>types</kbd> and <kbd>utils</kbd> modules with<span> the</span> necessary types:</p>
<pre>mod types;<br/>mod utils;<br/><br/>use self::utils::{Method, WebApi};<br/>use self::types::Comment;</pre>
<p>We also will check that the service is available in<span> the</span> <kbd>content_healthcheck</kbd> test:</p>
<pre>#[test]<br/>fn content_healthcheck() {<br/>    let mut api = WebApi::content();<br/>    api.healthcheck("/", "Content Microservice");<br/>}</pre>
<p>This service is necessary for users to be able to add a new comment, and is loose-coupled (it doesn't need to check that the user exists, because it is protected from non-existent users by router microservices). We will generate a new ID of the user and send a request to post a new comment:</p>
<pre>#[test]<br/>fn add_comment() {<br/>    let mut api = WebApi::content();<br/>    let uuid = uuid::Uuid::new_v4().to_string();<br/>    let comment = utils::rand_str();<br/>    let params = vec![<br/>        ("uid", uuid.as_ref()),<br/>        ("text", comment.as_ref()),<br/>    ];<br/>    let _: () = api.request(Method::POST, "/new_comment", params);<br/><br/>    let comments: Vec&lt;Comment&gt; = api.request(Method::GET, "/list", vec![]);<br/>    assert!(comments.into_iter().any(|Comment { text, ..}| { text == comment }))<br/>}</pre>
<p>We prepared a form to create a new comment and sent a <kbd>POST</kbd> request to<span> the</span> <kbd>/new_comment</kbd> path. After that, we take a list of comments and check that there is a comment with generated text in a list. This means that the comment was added and that<span> the</span> content microservice works properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mailer</h1>
                </header>
            
            <article>
                
<p>Our application also has a mailer microservice that sends notifications to users. It needs<span> the</span> <kbd>utils</kbd> module for testing only:</p>
<pre>mod utils;<br/><br/>use self::utils::{Method, WebApi};</pre>
<p>Put the <span>preceding </span>code into a new <kbd>mailer.rs</kbd> file and add a <kbd>healthcheck</kbd> to test that a microservice instance is alive:</p>
<pre>#[test]<br/>fn mails_healthcheck() {<br/>    let mut api = WebApi::mailer();<br/>    api.healthcheck("/", "Mailer Microservice");<br/>}</pre>
<p class="mce-root"/>
<p>The Mailer microservice also doesn't need to know users to notify them. It only requires an email address and some content. This microservice will send confirmation codes to a user, so let's simulate this behavior in our <kbd>send_mail</kbd> test:</p>
<pre>#[test]<br/>fn send_mail() {<br/>    let mut api = WebApi::mailer();<br/>    let email = utils::rand_str() + "@example.com";<br/>    let code = utils::rand_str();<br/>    let params = vec![<br/>        ("to", email.as_ref()),<br/>        ("code", code.as_ref()),<br/>    ];<br/>    let sent: bool = api.request(Method::POST, "/send", params);<br/>    assert!(sent);<br/>}</pre>
<p>We created a <kbd>WebApi</kbd> instance with<span> the</span> <kbd>mailer</kbd> function call to target a client to the Mailer microservice. After that, we generated a new email and code, and put them into a form. The microservice returns a Boolean value, indicating that the email was sent. We use it with the <kbd>asser!</kbd> macro to check that it worked correctly.</p>
<p>We have covered all of the microservices of the application with tests, and now we can add a full integration test that checks a complex interaction with the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Router</h1>
                </header>
            
            <article>
                
<p>Create a <kbd>router.rs</kbd> file and add the following modules and types:</p>
<pre>mod types;<br/>mod utils;<br/><br/>use self::utils::{Method, StatusCode, WebApi};<br/>use self::types::Comment;</pre>
<p>Since the router microservice also serves static files by the root path that we used for the other microservice, to check that they are alive, we will use a special <kbd>/healthcheck</kbd> path that returns the name of that microservice:</p>
<pre>#[test]<br/>fn router_healthcheck() {<br/>    let mut api = WebApi::router();<br/>    api.healthcheck("/healthcheck", "Router Microservice");<br/>}</pre>
<p>The complete test is implemented in<span> the</span> <kbd>check_router_full</kbd> test. Look at the following code:</p>
<pre>#[test]<br/>fn check_router_full() {<br/>    let mut api = WebApi::router();<br/>    let username = utils::rand_str() + "@example.com";<br/>    let password = utils::rand_str();<br/>    let params = vec![<br/>        ("email", username.as_ref()),<br/>        ("password", password.as_ref()),<br/>    ];<br/>    api.check_status(Method::POST, "/api/signup", params, StatusCode::FOUND);<br/><br/>    let params = vec![<br/>        ("email", username.as_ref()),<br/>        ("password", password.as_ref()),<br/>    ];<br/>    api.check_status(Method::POST, "/api/signin", params, StatusCode::FOUND);<br/><br/>    let comment = utils::rand_str();<br/>    let params = vec![<br/>        ("text", comment.as_ref()),<br/>    ];<br/>    api.check_status(Method::POST, "/api/new_comment", params, StatusCode::FOUND);<br/><br/>    let comments: Vec&lt;Comment&gt; = api.request(Method::GET, "/api/comments", vec![]);<br/>    assert!(comments.into_iter().any(|Comment { text, ..}| { text == comment }))<br/>}</pre>
<p>It creates a new <kbd>WebApi</kbd> instance that's targeted at the router microservice. After this, it creates random credentials for a user and calls<span> the</span> router's method in <kbd>/api</kbd> scope. But in this case, we use<span> the</span> <kbd>check_status</kbd> method, because<span> the</span> router microservice creates and keeps session IDs internally and returns cookies to identify us.</p>
<p>We sent requests to <kbd>/api/signup</kbd> and <kbd>/api/signin</kbd> to register a user account and to authorize it. After this, we called the <kbd>/api/new_comment</kbd> method of the application API to post a new comment by user of the current session. Finally, we check in the open <kbd>/api/comments</kbd> endpoint that our comment exits.</p>
<p>We covered the basic functionality of applications with this integration test, but for large applications, <span>you can also check records in databases, cached values, and</span> uploaded <span>files to ensure that the application works as you expected. If your microservice works incorrectly and you can't find a reason, you can try to debug it with the instruments that we will learn about in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging microservices</h1>
                </header>
            
            <article>
                
<p>If your program does go wrong, you need debugging tools to fix that, which we will explore in this section. Debugging not only means interactive debugging using a debugger—a special tool that helps you to execute program step by step—you can also use logging to trace all activities of the code. To understand the cause of the error, you can use the following tools:</p>
<ul>
<li><strong>curl</strong>: a command-line tool that we already used to send HTTP requests</li>
<li><strong>Postman:</strong> a GUI tool for testing REST APIs</li>
<li><strong>mitmproxy: </strong> a proxy to trace all requests passing through it</li>
<li><strong>LLDB:</strong> a traditional command-line debugger</li>
<li><strong>VS Code:</strong> an editor with good LLDB integration</li>
</ul>
<p>Let's explore all of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">curl</h1>
                </header>
            
            <article>
                
<p>The most commonly used tool to perform HTTP requests is <kbd>curl</kbd>. It's a command-line tool with a boatload of parameters. Some of the most useful ones are as follows:</p>
<ul>
<li><kbd>--request &lt;METHOD&gt;</kbd> (or <kbd>-X</kbd>) sets the HTTP method to use</li>
<li><kbd>--header "Header: Value"</kbd> (or -<kbd>H</kbd>) sets an extra header to the request</li>
<li><kbd>--data &lt;data&gt;</kbd> (of <kbd>-d</kbd>) sets a body to a request, and uses <kbd>@filename</kbd> as a data value to attach the contents of a file</li>
<li><kbd>--form "field=value"</kbd> (or <kbd>-F</kbd>) sets a field of a form</li>
<li><kbd>--cookie &lt;file&gt;</kbd> (or <kbd>-b</kbd>) sets a file with cookies to send</li>
<li><kbd>--cookie-jar &lt;file&gt;</kbd> (or <kbd>-c</kbd>) sets a file with cookies to store</li>
</ul>
<p>For example, if you want to send a request with a JSON file, use the following command:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d @file.json http://localhost:8080/upload</pre>
<p>Or, to send a form, use the following command:</p>
<pre>curl -X POST -F login=user -F password=secret http://localhost:8080/register</pre>
<p>If you want to keep cookies between calls, use the same file to read and write cookie values with the following code: <kbd>-b session.file -c session.file</kbd>.</p>
<p>If you prefer to use GUI tools, you can consider using Postman.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Postman</h1>
                </header>
            
            <article>
                
<p>Postman is a popular extension for browsers that is also available as a desktop application. You can get it from here: <a href="https://www.getpostman.com/">https://www.getpostman.com/</a>. The coolest features of Postman include that you can group requests and use configurable variables in requests.</p>
<p>For example, let's send a sign-in request to our application that we started with Docker Compose. Install Postman and create a new workspace called <strong>Rust Microservices</strong><em>.</em> Enter the URL of an application, set<span> the</span> method to <kbd>POST</kbd>, and add the body as <kbd>x-www-form-unlencoded</kbd>, with two parameters, <kbd>email</kbd> and <kbd>password</kbd> (the user has to have been created with <em>/signup</em> before). Click <span>the</span> <span class="packt_screen">Send</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/55cab771-6424-4a77-a030-58fee59d9829.png"/></p>
<p>As you can see, the microservices returned a response with cookies, which contain an <kbd>auth-example</kbd> named value.</p>
<p>But what about if we want to use a browser to perform all activities, but explore sent request and responses later? We can start a tracing proxy. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">mitmproxy</h1>
                </header>
            
            <article>
                
<p>mitmproxy is a good proxy that logs all request and responses, and can work as a transparent proxy, as a SOCKS5 proxy, or as a reverse proxy. This tool is useful when you want to interact with the running application with a browser, but want to record all request and responses of the interaction session. You can get this tool from here: <a href="https://mitmproxy.org/">https://mitmproxy.org/</a>.</p>
<p>Install a proxy and start it by forwarding it to the server's ports:</p>
<pre>mitmweb --mode reverse:http://localhost:7000 --web-port 7777 --listen-port 7780</pre>
<p>As you may already know by talking parameters, we used reverse-proxy mode. It used the <kbd>7777</kbd> port to provide access to the mitmproxy UI and port <kbd>7780</kbd> to connect to our application through proxy. In other words, the proxy redirects all requests from port <kbd>7780</kbd> to port <kbd>7000</kbd> of our application.</p>
<p>Open <kbd>127.0.0.1:7777</kbd> in a browser, and <kbd>127.0.0.1:7780</kbd> in a separate tab, and try to interact with the application. The mitmproxy web app will show you a flow of request and the responses the browser made:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/39e16a9a-812e-4c0b-8623-d15309aa7c43.png"/></p>
<p>Like with Postman, we also can explore<span> the</span> headers of the <kbd>/signin</kbd> response, and see <span>the </span>cookie header with<span> the</span> <kbd>auth-example</kbd> value set.</p>
<p>Sometimes, you might see incorrect behavior in your application, but can't find a bug in<span> the</span> code. For these cases, you may consider trying debuggers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LLDB</h1>
                </header>
            
            <article>
                
<p>Rust has good support for two debuggers—GDB and LLDB. We will try the second here. <span>LLDB is a modern command-line debugger. It's a part of</span><span> the</span><span> LLVM project. </span></p>
<p>Let's try to look inside our working router microservice. Move to<span> the</span> directory with<span> the</span> microservice and compile it with<span> the</span> <kbd>cargo build</kbd> command. However, you have to be sure you don't set the <kbd>--release</kbd> flag, because it removes all debugging information. If you don't use cargo and want to add debugging information directly using <kbd>rustc</kbd>, add the <kbd>-g -C debuginfo=2</kbd> arguments to keep debugging symbols in the output file. After the building is finished, use a command to start a debugger with scripts to support the Rust programming language:</p>
<pre>rust-lldb ./target/debug/router-microservice</pre>
<p>This command is already installed if you used the <kbd>rustup</kbd> installation tool to install Rust. You will have <span>also</span><span> </span><span>installed LLDB debugger on your machine. When the debugger starts, it will print something like this:</span></p>
<pre>(lldb) command script import "/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/etc/lldb_rust_formatters.py"<br/>(lldb) type summary add --no-value --python-function lldb_rust_formatters.print_val -x ".*" --category Rust<br/>(lldb) type category enable Rust<br/>(lldb) target create "./target/debug/router-microservice"<br/>Current executable set to './target/debug/router-microservice' (x86_64).<br/>(lldb) </pre>
<p>It will prompt for your input.</p>
<p>Let's set a breakpoint to the <kbd>comments</kbd> handler. You can do that with the following command:</p>
<pre>breakpoint set --name comments</pre>
<p>It will print that your breakpoint was set:</p>
<pre>Breakpoint 1: where = router-microservice`router_microservice::comments::h50a827d1180e4955 + 7 at main.rs:152, address = 0x00000000001d3c77</pre>
<p>Now, we can start the microservice with this command:</p>
<pre><strong>run</strong></pre>
<p>It will inform you that the process has launched:</p>
<pre>Process 10143 launched: '/home/user/sources/Chapter15/deploy/microservices/router/target/debug/router-microservice'</pre>
<p>Now, if you try to open the <kbd>http://localhost:8080/comments</kbd> URL in a browser, then the debugger will interrupt the execution of the handler in the breakpoint you set, and the debugger will show you<span> the</span> position of the line of code where it has interrupted:</p>
<pre>   151     fn comments(req: HttpRequest&lt;State&gt;) -&gt; FutureResponse&lt;HttpResponse&gt; {<br/>-&gt; 152         debug!("/api/comments called");<br/>   153         let url = format!("{}/list", req.state().content());<br/>   154         let fut = get_req(&amp;url)<br/>   155             .map(|data| {</pre>
<p>At this point, you can explore the running microservices. For example, you can get to know which alive threads exists with the following command:</p>
<pre>thread list</pre>
<p>It will show you <span>the </span>main thread and arbiter threads of actix:</p>
<pre>  thread #3: tid = 10147, 0x00007ffff7e939d7 libc.so.6`.annobin_epoll_wait.c + 87, name = 'actix-web accep'<br/>  thread #4: tid = 10148, 0x00007ffff7f88b4d libpthread.so.0`__lll_lock_wait + 29, name = 'arbiter:77596ed'<br/>  thread #5: tid = 10149, 0x00007ffff7f8573c libpthread.so.0`__pthread_cond_wait + 508, name = 'arbiter:77596ed'</pre>
<p>To see the variables that are available for the current context, you can use<span> the</span> <kbd>frame variable</kbd> command. To move execution to the next line of code, use<span> the</span> <kbd>next</kbd> command. To continue execution, use<span> the</span> <kbd>continue</kbd> command.</p>
<p>Using this tool, you can go through buggy handlers step by step and find<span> the</span> reason for<span> the</span> problem. Many developers prefer GUI debuggers and we'll also try one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Studio Code</h1>
                </header>
            
            <article>
                
<p>Visual Studio Code is a convenient editor for developers with a lot of extensions, including for<span> the</span> Rust language and<span> the</span> LLDB debugger support. Let's try to use it.</p>
<p>First, you have to download and install Visual Studio Code from here: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. After this, you need to install two extensions—<kbd>rust-lang.rust</kbd> and <kbd>vadimcn.vscode-lldb</kbd>. The first adds Rust support while the second integrates VS Code with LLDB.</p>
<p>The integration with Rust is based on the <strong>Rust Language Server</strong> (<strong>RLS</strong>) project that, which provides information about Rust code for IDEs.</p>
<p>Open the router microservice project with <em>File &gt; Add Folder To A Workspace...</em> and choose the folder with a project. When it's open, set a breakpoint—set a cursor to the desired line and choose <em>Debug &gt; Toggle Breakpoint</em> command. Now, we can start debugging with the <em>Debug | Start Debugging</em> command. On the first run, it takes some time to prepare LLDB, but when debugger starts, it prints some information to the <em>Output</em> tab.</p>
<p>Open a browser and try to open the <kbd>http://localhost:8080/comments</kbd> URL that activates the breakpoint of our <kbd>comments</kbd> handler:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/757b550d-b32b-46d2-be75-9ff8c5a62197.png"/></p>
<p>Use<span> the</span> bar at the top to move<span> the</span> execution pointer to<span> the</span> next line. With a GUI debugger, you can explore variables and<span> the</span> call stack. It's simple and useful. But not every case can be fixed with debugger, because there's types of bugs (called <strong>Heisenbugs</strong>) that disappear at the moment of debugging or studying them. The only thing that can help with that is logging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structural logging</h1>
                </header>
            
            <article>
                
<p>I believe the logging is<span> the</span> silver bullet of debugging, because it works everywhere—on tests, on production servers, in cloud infrastructure. Also, you don't have to reproduce<span> the</span> activity that produces bugs – you can take<span> the</span> logs of a working application and read them to detect problems. Sometimes, you will have bugs that you can't reproduce, and logs can help to fix them.</p>
<p>We already studied the basics of logging in <a href="751f86d9-59ce-4966-beb8-cd743b521373.xhtml">Chapter 3,</a> <em><span>Logging and Configuring Microservices</span></em>. We used<span> the</span> simple <kbd>env_logger</kbd> and <kbd>log</kbd> crates, but for large applications, it may not be enough, because you will need to collect all logs for analyzing, and it's simpler to parse logs from a formal format like JSON. There are structural logging crates for this case. Let's explore a tiny example of using structural logging with<span> the</span> <kbd>slog</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example</h1>
                </header>
            
            <article>
                
<p>We will crate a tiny application that writes logs to a file and to a console. Create a new crate and add the following dependencies:</p>
<pre>slog = "2.4"<br/>slog-async = "2.3"<br/>slog-json = "2.3"<br/>slog-term = "2.4"</pre>
<p>We need <kbd>slog</kbd> as<span> the</span> main logging crate for the application. The <kbd>slog-async</kbd> crate helps to move log processing to a separate thread. <kbd>slog-json</kbd> provides a logger that writes records in JSON format. <kbd>slog-term</kbd> provides formats to write messages to a Terminal.</p>
<p>We will import the following types:</p>
<pre>use slog::{crit, debug, error, Drain, Duplicate, Level, LevelFilter};<br/>use slog_async::Async;<br/>use slog_term::{CompactFormat, PlainDecorator};<br/>use slog_json::Json;<br/>use std::fs::OpenOptions;<br/>use std::sync::Mutex;</pre>
<p class="CDPAlignLeft CDPAlign">From the main <kbd>slog</kbd> crate, we will use the <kbd>crit</kbd>, <kbd>debug</kbd>, and <kbd>error</kbd> macros, which are an alternative to the logging macro of<span> the</span> <kbd>log</kbd> crate. <kbd>Drain</kbd> is<span> the</span> main trait that provides logging functionality. Ultimately, we must create a <kbd>Drain</kbd> instance to log something. <kbd>Duplicate</kbd> is a kind of <kbd>Drain</kbd> that duplicates records to two <kbd>Drain</kbd> instances. <kbd>Level</kbd> and <kbd>LevelFilter</kbd> allow us to filter records by desired level.</p>
<p class="CDPAlignLeft CDPAlign">From<span> the</span> <kbd>slog-async</kbd> crate, we will use<span> the</span> <kbd>Async</kbd> type, which is a <kbd>Drain</kbd> that moves records processing to a separate thread. <kbd>PlainDecorator</kbd>, which is imported from<span> the</span> <kbd>slog-term</kbd> crate, prints logs without any coloring. Also, we imported<span> the</span> <kbd>CompactFormat</kbd> type, which is a <kbd>Drain</kbd> that writes records in a short format.From<span> the</span> <kbd>slog-json</kbd> crate, we imported the <kbd>Json</kbd> form of <kbd>Drain</kbd> that writes logs in JSON format.</p>
<p>Please note that the <kbd>Drain</kbd> trait has a default implementation for <kbd>Mutex</kbd> values that contains a value that has already implemented the <kbd>Drain</kbd> trait. It allows us to wrap any <kbd>Drain</kbd> with a <kbd>Mutex</kbd> to make it safe for use in multiple threads. The <kbd>OpenOptions</kbd> type is imported to open a file for writing and truncate the contents of it.</p>
<p>Now, we can add<span> the</span> <kbd>main</kbd> function with sample logging:</p>
<pre>fn main() {<br/>   let log_path = "app.log";<br/>   let file = OpenOptions::new()<br/>      .create(true)<br/>      .write(true)<br/>      .truncate(true)<br/>      .open(log_path)<br/>      .unwrap();<br/><br/>    let drain = Mutex::new(Json::default(file)).fuse();<br/>    let file_drain = LevelFilter::new(drain, Level::Error);<br/><br/>    let decorator = PlainDecorator::new(std::io::stderr());<br/>    let err_drain = CompactFormat::new(decorator).build().fuse();<br/><br/>    let drain_pair = Duplicate::new(file_drain, err_drain).fuse();<br/>    let drain = Async::new(drain_pair).build().fuse();<br/><br/>    let log = slog::Logger::root(drain, slog::o!(<br/>        "version" =&gt; env!("CARGO_PKG_VERSION"),<br/>        "host" =&gt; "localhost",<br/>        "port" =&gt; 8080,<br/>    ));<br/>    debug!(log, "started");<br/>    debug!(log, "{} workers", 2;);<br/>    debug!(log, "request"; "from" =&gt; "example.com");<br/>    error!(log, "worker failed"; "worker_id" =&gt; 1);<br/>    crit!(log, "server can't continue to work");<br/>}</pre>
<p class="mce-root"/>
<p>This function opens a file and creates two <kbd>Drain</kbd> instances. The first is a <kbd>Json</kbd> wrapped with a <kbd>Mutex</kbd>, because <kbd>Json</kbd> is not a thread-safe type. We also wrap it with <kbd>LevelFilter</kbd> to filter messages at a level lower than <kbd>Error</kbd>.</p>
<p>After this, we used <kbd>PlainDecorator</kbd> to write logs to<span> the</span> <kbd>stderr</kbd> stream. It implements the <kbd>Decorator</kbd> trait, which can be used as a stream for creating <kbd>Drain</kbd> instances. We wrap it with <kbd>CompactFormat</kbd> and now we have two <kbd>Drain</kbd> instances that we will combine.</p>
<p>We use <kbd>Duplicate</kbd> to duplicate records to<span> the</span> two created <kbd>Drain</kbd> instances, but we also wrap it with <kbd>Async</kbd> to move logs that are processing to a separate thread. Now, we can create a <kbd>Logger</kbd> instance and fill it with basic information about the application.</p>
<p>We use<span> the</span> <kbd>root</kbd> method to create the root logger. This method can also get a map of values, which will be added to records. We used<span> the</span> <kbd>o!</kbd> macro to create a map. After this, we added calls of different macros to show you how to use a structural logger.</p>
<p>Any logging macro expects some arguments—a reference to a <kbd>Logger</kbd> instance, a message, optional parameters to fill a message, or a key-value map with extra parameters that can be extracted later from logs for analysis.</p>
<p>The demo application is ready and we can start to test it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and testing</h1>
                </header>
            
            <article>
                
<p>Build this application with <kbd>cargo build</kbd>, or with the following command, if you want to play with the code:</p>
<pre><strong>cargo watch --ignore *.log -x run</strong></pre>
<p>We use<span> the</span> <kbd>cargo-watch</kbd> tool, but ignore log files, because these will be created when the application is run. After<span> the</span> application has started, you will the following records in the Terminal:</p>
<pre>version: 0.1.0<br/> host: localhost<br/>  port: 8080<br/>   Jan 20 18:13:53.061 DEBG started<br/>   Jan 20 18:13:53.062 DEBG 2 workers<br/>   Jan 20 18:13:53.062 DEBG request, from: example.com<br/>   Jan 20 18:13:53.062 ERRO worker failed, worker_id: 1<br/>   Jan 20 18:13:53.063 CRIT server can't continue to work</pre>
<p>As you can see, no records with the <kbd>Debug</kbd> level were filtered in the Terminal output. As you may remember, we duplicated logging into two <kbd>Drain</kbd> instances. The first writes errors to the <kbd>app.log</kbd> file, and if you open this file, you can see the filtered records that don't contain records with a <kbd>Debug</kbd> level:</p>
<pre>{"msg":"worker failed","level":"ERRO","ts":"2019-01-20T18:13:53.061797633+03:00","port":8080,"host":"localhost","version":"0.1.0","worker_id":1}<br/>{"msg":"server can't continue to work","level":"CRIT","ts":"2019-01-20T18:13:53.062762204+03:00","port":8080,"host":"localhost","version":"0.1.0"}</pre>
<p>There are only records with the level above or equal to <kbd>Error</kbd>.</p>
<p>In <a href="751f86d9-59ce-4966-beb8-cd743b521373.xhtml">Chapter 3</a>, <em>Logging and Configuring Microservice,</em> in<span> the</span> example with<span> the</span> <kbd>env_logger</kbd> crate, we used environment variables to configure a logger. <kbd>slog</kbd> also provides this feature with the <kbd>slog_envlogger</kbd> crate.</p>
<p>Logging is an awesome tool that's used to trace every action of a single microservice, but if your application consists of multiple microservices, it can be hard to understand why some error happened, because it is affected by multiple factors. To find and repair this hardest type of bug, there is distributed tracing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distributed tracing</h1>
                </header>
            
            <article>
                
<p>Distributed tracing helps to collect information about related parts of an application as a <strong>distributed acyclic graph</strong> (<strong>DAG</strong>). You can use collected information to analyze a path of any activity in a distributed application.</p>
<p>There is an open standard—OpenTracing, which is supported by multiple products, including Jaeger. The most minimal unit of tracing is called a <strong>span</strong>. Spans can have relationships with other spans to construct a report with tracing paths. In this section, we'll write a tiny application that will send some spans to a Jaeger instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting Jaeger</h1>
                </header>
            
            <article>
                
<p>First, we need a working Jaeger instance that you can start as a Docker container from the official Docker image that contains all of the parts of the application in one. It's even called <strong>jaegertracing/all-in-one</strong>:</p>
<pre><strong>$ docker run --rm --name jaeger \</strong><br/><strong>  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \</strong><br/><strong>  -p 5775:5775/udp \</strong><br/><strong>  -p 6831:6831/udp \</strong><br/><strong>  -p 6832:6832/udp \</strong><br/><strong>  -p 5778:5778 \</strong><br/><strong>  -p 16686:16686 \</strong><br/><strong>  -p 14268:14268 \</strong><br/><strong>  -p 9411:9411 \</strong><br/><strong>  jaegertracing/all-in-one:1.8</strong></pre>
<p>Open all the necessary ports, and access the web UI of Jaeger at <a href="http://localhost:16686">http://localhost:16686</a>.</p>
<p>Now, we can write an application to interact with this instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating spans</h1>
                </header>
            
            <article>
                
<p>We will use two crates to make a test example—<kbd>rustracing</kbd> and <kbd>rustracing_jaeger</kbd>. Create a new crate and add it to <span>the </span><kbd>[dependencies]</kbd> section of <kbd>Cargo.toml</kbd>:<span> </span></p>
<pre>rustracing = "0.1"<br/>rustracing_jaeger = "0.1"</pre>
<p>Add the following dependencies to<span> the</span> <kbd>main.rs</kbd> source file:</p>
<pre>use rustracing::sampler::AllSampler;<br/>use rustracing::tag::Tag;<br/>use rustracing_jaeger::Tracer;<br/>use rustracing_jaeger::reporter::JaegerCompactReporter;<br/>use std::time::Duration;<br/>use std::thread;</pre>
<p><kbd>AppSampler</kbd> implements<span> the</span> <kbd>Sampler</kbd> trait that is used to decide whether every new trace will be sampled or not. Consider samplers as filters of loggers, but smart ones that can limit the amount of traces per second or use other conditions. <kbd>Tag</kbd> is used to set extra data for spans. <kbd>Tracer</kbd> is<span> the</span> main object that's used for creating spans. The <kbd>JaegerCompactReporter</kbd> type is used to group spans and send them to the Jaeger instance.</p>
<p>Also, we need a function to sleep the current thread for milliseconds:</p>
<pre>fn wait(ms: u64) {<br/>    thread::sleep(Duration::from_millis(ms));<br/>}</pre>
<p>Now, you can add<span> the</span> <kbd>main</kbd> function, and add the first part<span> </span>of <span>the</span><span> </span>example to it:</p>
<pre>let (tracer1, span_rx1) = Tracer::new(AllSampler);<br/>let (tracer2, span_rx2) = Tracer::new(AllSampler);<br/>thread::spawn(move || {<br/>    loop {<br/>        {<br/>            let req_span = tracer1<br/>                .span("incoming request")<br/>                .start();<br/>            wait(50);<br/>            {<br/>                let db_span = tracer2<br/>                    .span("database query")<br/>                    .child_of(&amp;req_span)<br/>                    .tag(Tag::new("query", "SELECT column FROM table;"))<br/>                    .start();<br/>                wait(100);<br/>                let _resp_span = tracer2<br/>                    .span("generating response")<br/>                    .follows_from(&amp;db_span)<br/>                    .tag(Tag::new("user_id", "1234"))<br/>                    .start();<br/>                wait(10);<br/>            }<br/>        }<br/>        wait(150);<br/>    }<br/>});</pre>
<p>In this code, we did a major part of<span> the </span>tracing routine. First, we created two <kbd>Tracer</kbd> instances that will pass all values by <kbd>AllSampler</kbd>. After this, we used <kbd>spawn</kbd> to create a new thread and created a loop that generated spans. You have to remember that<span> the</span> <kbd>rustracing</kbd> crate uses a <kbd>Drop</kbd> trait implementation to send a span value to a <kbd>Reciever</kbd> that was also created with<span> the</span> <kbd>Tracer::new</kbd> method call, and we have to drop values (we used<span> the</span> scoping rules of Rust to do dropping automatically).</p>
<p>We used<span> the</span> <kbd>Tracer</kbd> instance stored in<span> the</span> <kbd>tracer1</kbd> variable to create a span with<span> the</span> <kbd>span</kbd> method call. It expects a name for<span> the</span> span and created a <kbd>StartSpanOptions</kbd> struct that can be used to configure a future <kbd>Span</kbd> value. For configuring, we can use<span> th</span>e <kbd>child_of</kbd> method to set a parent, or<span> the</span> <kbd>follows_from</kbd> method to set a reference to the previous <kbd>Span</kbd>. Also, we can set extra information with<span> the</span> <kbd>tag</kbd> method call and provide a key-value pair called <kbd>Tag</kbd>, just as we did in structural logging before. After configuring, we have to call the <kbd>start</kbd> method of the <kbd>StartSpanOptions</kbd> instance to create a <kbd>Span</kbd> instance with a set span starting time. Using scopes and tracer, we emulated two parts of an application: the first that processes a request, and the second that performs a database query and generates a response, where the first is a parent of the latter.</p>
<p>Now, we have to use <kbd>SpanReciever</kbd> instances to collect all dropped <kbd>Span</kbd> values.<span> (They've actually been sent to </span><kbd>Reciever</kbd><span>.)</span> Also, we create two <kbd>JaegerCompactReporter</kbd> instances with names and add spans to reports using the <kbd>report</kbd> method call in the loop:</p>
<pre>let reporter1 = JaegerCompactReporter::new("router").unwrap();<br/>let reporter2 = JaegerCompactReporter::new("dbaccess").unwrap();<br/>loop {<br/>    if let Ok(span) = span_rx1.try_recv() {<br/>        reporter1.report(&amp;[span]).unwrap();<br/>    }<br/>    if let Ok(span) = span_rx2.try_recv() {<br/>        reporter2.report(&amp;[span]).unwrap();<br/>    }<br/>    thread::yield_now();<br/>}</pre>
<p>Now, we can compile and run this tracing example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compile and run</h1>
                </header>
            
            <article>
                
<p>To start this example, you can use the <kbd>cargo run</kbd> command. When the example starts, it will continuously produce spans and send them to <span>the </span>running Jaeger instance. You will need to wait for a short interval and interrupt the application, otherwise it will generate too many spans.</p>
<p>Open the web UI of Jaeger in a browser. Choose <kbd>router</kbd> in<span> the</span> <span class="packt_screen">Service</span> field, and click the <span class="packt_screen">Find Traces</span> button to find the corresponding spans. You will see recent traces, and if you click on one of them, you will see the details of the tracing:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec2371cb-427a-44ac-bb8c-8cb950ef4d0f.png"/></p>
<p class="CDPAlignLeft CDPAlign">As you can see, distributed tracing registered activities of our application, and we can use it as a tool for logging<span> the</span> distributed activities of microservices that are included in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed a lot of topics on testing and debugging microservices. First, we considered unit and integration tests, and also saw some examples of using these in Rust. After this, we explored tools that help us with debugging microservices, including curl and Postman, to send requests manually; mitmproxy to trace all incoming requests and outgoing responses of a microservice; LLDB to explore the running code of a microservice; and Visual Studio Code as a GUI frontend for the LLDB Debugger.</p>
<p>Lastly, we discussed two techniques that used for the largest applications, where you can't simply <span>debug</span>: structural logging and distributed tracing using OpenTracing API.</p>
<p>In the next chapter, you'll learn about some techniques with which you can optimize Rust microservices.</p>


            </article>

            
        </section>
    </body></html>