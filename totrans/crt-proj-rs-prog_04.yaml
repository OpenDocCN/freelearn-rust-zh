- en: Creating a Full Server-Side Web App
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to build a REST web service using the Actix
    web framework. A REST web service must be used by a client app in order for it
    to be useful to us.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to build a very small but complete web app using
    the Actix web framework. We will use HTML code to be formatted in a web browser,
    JavaScript code to be executed in the same web browser, and the Tera crate to
    perform HTML templating. This is useful for embedding dynamic data inside HTML
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a classical web app is and what its HTML templates are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Tera template engine with Rust and Actix web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Actix web to handle requests of web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling authentication and authorization in web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To best understand this chapter, you will need to have read the previous chapter.
    In addition, basic knowledge of HTML and JavaScript is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found in the `Chapter04` folder of
    the repository at [https://github.com/PacktPublishing/Rust-2018-Projects](https://github.com/PacktPublishing/Rust-2018-Projects).
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone knows what a web page or a website is, and everyone knows that some
    web pages are quite static, while others have more dynamic behavior. The definition
    of a web app, however, is more subtle and controversial.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with an operational definition of a web app; that is, looking
    at the appearance and behavior of web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, a web app is a website that has the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: It appears as one or more web pages in a web browser. On these pages, the user
    can interact with the page by pressing keys on a keyboard, clicking with a mouse,
    tapping on a touchscreen, or using another input device. For some user interactions,
    these web pages send requests to a server and receive data from that site as a
    response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a *static* web page, the data received is always the same for
    the same request; but for a web app, the data received depends on the current
    state of the server, which can change with time. Upon receipt of the data, the
    web page shows other HTML code, either as a new full page or as a portion of the
    current page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classic web apps receive HTML code from the server only, so all the browser
    must do is display the HTML code when it arrives. Modern apps more often receive
    raw data from the server and use JavaScript code within the browser to create
    the HTML code that displays the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we are going to develop a rather classical web app, as our app receives
    mainly HTML code from the server. Some JavaScript code will be used to improve
    the structure of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the behavior of a web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user navigates to a website by using the address bar of the browser or
    by clicking on a link in a page, the browser sends an HTTP `GET` request, with
    the URI specified in the address field or in the link element, such as `http://hostname.domainname:8080/dir/file?arg1=value1&arg2=value2`.
  prefs: []
  type: TYPE_NORMAL
- en: This address is commonly named **Uniform Resource Locator** (**URL**) or **Uniform
    Resource Identifier **(**URI**). The difference between these two acronyms is
    that a URI is something that uniquely identifies a resource without necessarily
    specifying *where* it can be found; a URL, however, specifies exactly *where* a
    resource can be found. In doing this, it also identifies the resource because
    there can be only one resource in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: So, every URL is also a URI, but an address can be a URI without being a URL.
    For example, an address that specifies the pathname of a file is a URL (and also
    a URI) because it specifies the path to the file. However, an address specifying
    a filter condition on files is a URI, but not a URL because it does not explicitly specify
    which file satisfies that condition.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of an address (such as `http://hostname.domainname:8080`), up
    to the (optional) port number, is needed to route the request to the server process
    that should handle it. This server must be running on the host computer and it
    must be waiting for incoming requests addressed at that port; or, as it is usually
    said, it must be listening on that port.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent portion of the URI (such as `/dir/file`) is the so-called **path**,
    which always starts with a slash and ends at the first question mark character
    or at the end of the URI. The possible subsequent part (such as `?arg1=value1&arg2=value2`)
    is the so-called **query**, which has one or more fields separated by an ampersand.
    Any field of the query has a name, followed by an equals sign, followed by a value.
  prefs: []
  type: TYPE_NORMAL
- en: When a request is made, the server should reply by sending an HTTP response,
    which contains the HTML page to display in the browser as its body.
  prefs: []
  type: TYPE_NORMAL
- en: After the display of the initial page, any further interaction usually happens
    when the user operates on the page by using the keyboard, the mouse, or other
    input devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the effect of any user actions on a page can be classified in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No code**: Some user actions are handled only by the browser, with no invoked application
    code. For example, when hovering the mouse over a widget, the mouse cursor shape
    changes; when typing in a text widget, the text inside that widget changes; and
    when clicking on a checkbox, the box is selected or deselected. Usually, this
    behavior is not controlled by the application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frontend only**: Some user actions (such as the pressing of a key) trigger
    the execution of the client-side JavaScript code associated with these actions,
    but no client-server communication is performed and so no server-side code is
    invoked as a consequence of these user actions. Typically, any push button is
    associated (using the `onclick` attribute of the button element) to JavaScript
    code that is executed any time the user clicks that button. This code could, for
    example, enable or disable other widgets or copy data from a widget to another
    widget of the same page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend only**: Some user actions trigger client-server communication without
    using any JavaScript code. There are only two examples of these actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on a `submit` input element inside an HTML `form` element
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on an `a` HTML element, better known as a **link**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-stack**: Some user actions trigger the execution of the client-side
    JavaScript code associated with that action. This JavaScript code sends one or
    more requests to the backend process and receives the responses sent as replies
    to these requests. The backend process receives the requests and responds properly
    to them. So, both the client-side application code and server-side application code
    is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's examine the advantages and disadvantages of these four cases. The
    *no code *case is the default one. If the basic behavior of the browser is good
    enough, there is no need to customize it. Some behavior customization can be performed
    using HTML or CSS.
  prefs: []
  type: TYPE_NORMAL
- en: The *frontend only* and the *full-stack* cases require JavaScript to be supported
    and enabled in the browser. This was once a problem because some people or platforms
    couldn't or wouldn't support it. Nowadays, something that wishes to be called
    a **web app**, and not simply a web page or website, cannot do so without the
    use of some kind of client-side processing.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend only case does not interact with the server, and so it may be useful
    and is recommended for any processes that do not need to send data outside of
    the current computer or do not need to receive data from another computer. For
    example, a calculator can be implemented in JavaScript with no communication with
    a server. However, most web apps need this communication.
  prefs: []
  type: TYPE_NORMAL
- en: The backend only case was the original type of web communication available before
    JavaScript was invented. It is quite limited, though.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a link is useful for websites that are meant to be hypertext,
    not apps. Remember that **HT **in HTML and in HTTP stands for **Hypertext**. That
    was the original purpose of the web, but nowadays, web apps are meant to be general-purpose
    applications, not just hypertexts.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a form containing a submit button also limits the interaction
    to a rigid protocol—some fields are filled in and a button is pressed to send
    all of the data to the server. The server processes the request and sends back
    a new page that replaces the current page. In many cases, this can be done, but
    it is not a very pleasant experience for the user.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth case is called full-stack because, for these apps, there are both
    application frontend code and application backend code. As the frontend code needs
    the backend code to work properly, it can be seen as stacked on it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that *any* web interaction must have some machine code running on the
    frontend and some machine code running on the backend. On the frontend, there
    can be the web browser, the `curl` utility, or some other kind of HTTP client.
    On the backend, there can be a web server, such as **Internet Information Services**
    (**IIS**), Apache, or NGINX, or an application that acts as an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: So, for any web app, there is client-server communication using the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The term *full-stack* means that, in addition to system software, there is also
    some application software running on the frontend (acting as an HTTP client) and
    some application software running on the backend (acting as an HTTP server).
  prefs: []
  type: TYPE_NORMAL
- en: In a typical full-stack application running on a browser, there are no links
    or forms, just the typical widgets of a GUI. Usually, these widgets are fixed
    text, editable fields, drop-down lists, check buttons, and push buttons. When
    the user presses any push button, a request is sent to the server, possibly using
    the values contained in the widgets, and when the server sends back an HTML page,
    that page is used to replace the current page or a portion of it.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample web app that we are going to build has the purpose of managing a
    list of people contained in a database. It is an extremely simple database as
    it only has one table with two columns—one for a numeric ID and one for a name.
    To keep the project simple, the database is actually a vector of struct objects kept
    in memory; but of course, in a real-world application, it would be stored in a
    **Database Management System** (**DBMS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The project will be built in steps, creating four projects that are progressively
    more complex, that can be downloaded from the GitHub repository linked in the
    *Technical requirements* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `templ` project is a collection of code snippets that shows how to use the
    Tera template engine for the projects of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list` project is a simple list of records about people that can be filtered
    by name. These records are actually contained in the database code and cannot
    be changed by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `crud` project contains the features to add, change, and delete people.
    They are the so-called **Create, Retrieve, Update****, and** **Delete** (**CRUD**)
    basic functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `auth` project adds a login page and ensures that only authorized users
    can read or change the database. The list of users and their privileges cannot
    be changed, however.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templ` project, which does not use the Actix web framework, can be compiled
    in 1 to 3 minutes the first time, and in a few seconds after any changes to the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the other projects will take around 3 to 9 minutes to compile the first
    time, then 8 to 20 seconds after any changes.
  prefs: []
  type: TYPE_NORMAL
- en: When you run any of the preceding projects (except the first one), all you will
    see is `Listening at address 127.0.0.1:8080` printed on the console. To view anything
    more, you will need a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Tera template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting to develop our web app, we will examine the concept of a **template
    engine**—in particular, the Tera crate, one of the many template engines available
    for Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Template engines can have several applications, but they are mostly used for
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical problem in web development is knowing how to generate HTML code containing
    some constants parts written by hand and some dynamic parts generated by application
    code. In general, there are two ways to obtain this kind of effect:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a programming language source file that contains a lot of statements
    that print strings to create the desired HTML page. These `print` statements mix
    string literals (that is, strings enclosed in quotation marks) and variables formatted
    as strings. This is what you'd do in Rust if you didn't have a template engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You write an HTML file containing the desired constant HTML elements and the
    desired constant text, but it also contains some statements enclosed in specific
    markers. The evaluation of these statements generates the variable parts of the
    HTML file. This is what you'd do in PHP, JSP, ASP, and ASP.NET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is also a compromise, which is to write both application code
    files and HTML code containing statements to evaluate. You can then choose the
    best tool for the job. This is the paradigm used by template engines.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have some Rust code files and some HTML files that must cooperate
    with one another. The tool to make the two worlds communicate is a template engine.
    The HTML files with embedded statements are named **templates** and the Rust application
    code calls the template engine functions to manipulate these templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the code in the `templ` example project. The first statement
    creates an instance of the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second statement loads one simple template into the engine by calling the `add_raw_template`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the name that will be used to refer to this template and
    the second argument is the template itself. It is a normal reference to a string
    slice, but it contains the `{{id}}` placeholder. This symbol qualifies it as a
    **Tera** **expression**. In particular, this expression contains just a Tera variable,
    but it could contain a more complex expression.
  prefs: []
  type: TYPE_NORMAL
- en: A constant expression is also allowed, such as `{{3+5}}`, even if there is no
    point in using constant expressions. A template can contain several expressions
    or none at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `add_raw_template` function is fallible, so `unwrap` is called
    on its result. This function, before adding the template received as an argument,
    analyzes it to see whether it is well-formed. For example, if it read `"Identifier:
    {{id}."` (with a missing brace), it would generate an error, and so the call to
    `unwrap` would panic.'
  prefs: []
  type: TYPE_NORMAL
- en: When you have a Tera template, you can **render** it; that is, generate a string
    that replaces the expressions with some specified strings, in a similar way to
    how a macro processor does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate an expression, the Tera engine has to first replace all of the
    variables used in it with their current value. To do that, a collection of Tera
    variables—each one associated with its current value—must be created. This collection
    is named a context. A context is created and populated by the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first one creates a mutable context and the second one inserts a key-value
    association into it. Here, the value is a reference to a number, but other types
    are also allowed as values.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in a real-world example, the value would be a Rust variable, not
    a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method gets a template named `"id_template"` in the `tera_engine`
    object and applies the substitutions specified by the `numeric_id` context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can fail if the specified template is not found, if variables in the template
    have not been substituted, or if an evaluation has failed for some other reason.
    If the result is okay, `unwrap` gets the string. Therefore, it should print the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three Rust statements in the example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'They do the same thing, but with a literal string, showing that the same template
    variable can be replaced with both a number and a string. The printed line should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It adds a new template to the engine containing the `{{person.id}}` expression.
    This Tera dot notation has the same function as the Rust dot notation—it allows
    us to access a field of a struct. Of course, it only works if the `person` variable
    is replaced by an object with an `id` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a `Person` struct is defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The struct has an `id` field but also derives the `Serialize` trait. This is
    a requirement for any object that must be passed to a Tera template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement to define the `person` variable in the context is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the printed string will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is a more complex template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The template is one-line long, but it has been split into three lines in Rust
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `{{person.id}}` expression, there are three markers of another
    kind; they are **Tera statements**. Tera statements differ from Tera expressions
    because they are enclosed by the `{%` and `%}` signs, instead of double braces.
    While Tera expressions are similar to C preprocessor macros (that is, `#define`),
    Tera statements are similar to the conditional compilation directives of the C
    preprocessor (that is, `#if`, `#else`, and `#endif`).
  prefs: []
  type: TYPE_NORMAL
- en: The expression after the `if` statement is evaluated by the `render` function.
    If the expression is not defined or its value is either `false`, `0`, an empty
    string, or an empty collection, the expression is considered false. The text part—up
    to the `{%else%}` statement—is then discarded. Otherwise, the part after that
    statement, up to the `{%endif%}` statement, is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template is rendered with two different contexts—one in which the `person`
    variable is defined and the other in which no variable is defined. The two printed lines
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the `id` value of the person is printed; in the second case,
    the `No person` text is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, another complex template is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the template contains two other kinds of statements—`{%for p in persons%}`
    and `{%endfor%}`. They enclose a loop where the newly created `p` variable iterates
    over the `persons` collection, which must belong to the context used by `render`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This adds a Tera variable named `persons` to the `three_persons` Tera context.
    This variable is a vector containing three people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `persons` variable can be iterated, it is possible to evaluate
    the template, thereby obtaining the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that any `Id` object is in a distinct line because the template contains
    a new-line character (through the `\n` escape sequence); otherwise, they would
    have been printed in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used templates in string literals. This becomes difficult for
    long templates, though. Therefore, templates are usually loaded from separate
    files. This is advisable because the **Integrated Development Environment** (**IDE**)
    can help the developer (if it knows which language it is processing) and so it
    is better to keep HTML code in files with a `.html` suffix, CSS code in files
    with a `.css` suffix, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statement loads a Tera template from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `add_template_file` function is the path of the template
    file, relative to the root of the project. It is good practice to put all the
    template files in a separate folder or in its subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument allows us to specify the name of the new template. If the
    value of that argument is `None`, the name of the new template is the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will have similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, let's talk about a convenient feature that can be used to load all of
    the templates with a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of loading the templates one at a time, where they are needed, it is
    possible to load all of the templates at once and store them in a global dictionary.
    This makes them available to the entire module. To do so, it is convenient to
    use the `lazy_static` macro, described in [Chapter 1](91f1fe5a-241f-48e3-b16d-5110dcccd597.xhtml), *Rust
    2018 – Productivity!*, to write outside of any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This statement defines the `TERA` static variable as a global template engine.
    It will be initialized automatically when some Rust code of your app uses it first.
    This initialization will search all of the files in the specified subtree of folders
    and will load them, giving each of them the name of the file itself and omitting
    the name of its folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last feature of the Tera engine to be presented in this section is the
    `include` statement. The last line of the `templ_names.txt` file is the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It will load the contents of the specified file and will expand it inline, replacing
    the statement itself. It is similar to the `#include` directive of the C preprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: A simple list of persons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can examine the `list` project. If you run the server in a console
    and you access the `localhost:8080` address from a web browser, you will see the
    following page in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25e04587-5149-4f67-8d6b-5c9b5ace7d9a.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a heading, a label, a text field, a push button, and a table containing
    a list of three people.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing you can do on this page is type something into the text field
    and then click on the button to apply the typed text as a filter. For example,
    if you type `l` (that is, a lowercase *L*), only the Hamlet and Othello lines
    will appear as they are the only two people whose name contains this letter. If
    the filter is `x`, the result will be the No persons text as none of the three
    people has a name containing this letter. The page will look as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f2dd2b-1014-4dc7-924a-76d853a01643.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before explaining how it all works, let''s see the dependencies of this project;
    that is, the external crates used by it. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actix-web`: This is the web framework, also used in [Chapter 3](febceb22-18dd-437f-bd27-9895aef47384.xhtml),
    *Creating a REST Web Service*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tera`: This is the Tera template engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serde` and `serde_derive`: These are the serialization crates used by the
    Tera engine to pass whole struct objects to a template context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazy_static`: This contains the macro to initialize the Tera engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a glimpse at the source code. For this project, the `src`
    folder contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.rs`: This is the whole server-side application, excluding the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db_access.rs`: This is the mock database with some mock data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`favicon.ico`: This is the icon that any website should have as it is automatically
    downloaded by the browser to display it in the browser tab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a `templates` folder, containing the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.html`: This is the Tera/HTML template of the whole web page with an empty
    body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persons.html`: This is the Tera/HTML template of a partial web page, containing
    only the body of our web app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.js`: This is the JavaScript code to be included in the HTML page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's examine the mechanics of this web app.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user navigates to the `http://localhost:8080/` URI, the browser sends a
    `GET` HTTP request (that has only a slash as its path) to our process, with no
    query and empty body, and it expects an HTML page to be displayed. As described
    in the previous chapter, the server—using the Actix web framework—can respond
    to the request if its `main` function contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a web app whose state is only a shared reference to a database
    connection (that is actually a mock database). This app accepts only one kind
    of request—those using the root path (`/`) and the `GET` method. These requests
    are routed to the `get_main` function. The function should return an HTTP response
    containing the initial HTML page to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the body of the `get_main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function does not use the request at all because it always returns the
    same result.
  prefs: []
  type: TYPE_NORMAL
- en: To return a successful response (that is, with status code `200`), the `HttpResponse::Ok()`
    function is called. To specify that the body of the response is HTML code, the `content_type("text/html")`
    method is called on the response. To specify the content of the body of the response,
    the `body` method is called on the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument of the `body` function must be a string containing the HTML code
    to display. It is possible to write all of that code here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for more complex pages, it is better to keep all the HTML code in
    a separate file, with the `.html` filename extension, and to load the contents
    of this file into a string to pass as an argument to the `body` function. This
    can be done using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This would work well if the `main.html` file was static; that is, it wouldn''t
    need to change at runtime. However, this solution would be too limiting for two
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We want our initial page to be a *dynamic* page. It should show the list of
    people that are in the database when the page is opened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want our initial page, and also all of the other possible pages, to be composed
    of several parts: metadata elements, JavaScript routines, styles, a page header,
    a page central part, and a page footer. All of these parts, except for the central
    part, are to be shared by all of the pages to avoid repeating them in source code.
    So, we need to keep these parts in separate files and then splice them together
    before the HTML page is sent to the browser. In addition, we want to keep JavaScript
    code in separate files with the `.js` file extension and style code in separate
    files with the `.css` file extension so that our IDE recognizes their language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solution to these problems is to use the Tera template engine, which we will
    see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The templates folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is best to put all deliverable application text files in the `templates`
    folder (or in some of its subfolders). So, this subtree should contain all the
    HTML, CSS, and JS files, even if, at the moment, they may contain no Tera statements
    or expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, non-textual files (such as pictures, audio, video, and many others),
    user-uploaded files, documents that are to be downloaded explicitly, and databases
    should be kept elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The loading of all template files happens at runtime, but usually only once
    in the process life. The fact that the loading happens at runtime implies that
    the `templates` subtree must be deployed and that to deploy a new or changed version
    of one of those files, a rebuild of the program is not required. The fact that
    this loading usually happens once in the process life implies that the template
    engine is quite fast at processing the templates after the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding body statement has the following argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This expression renders the template contained in the `main.html` file using
    a Tera context contained in the `context` Rust variable. This kind of variable
    has been initialized by the `tera::Context::new()` expression and so it is an
    empty context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML file is very small and it has two noteworthy snippets. The first one
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `include` Tera statement to incorporate the JavaScript code into
    the HTML page. Having it incorporated into the server means that no further HTTP
    requests will be needed to load it. The second snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This causes the invocation of the `getPage` JavaScript function as soon as the
    page is loaded. This function is defined in the `main.js` file and, as its name
    suggests, it causes the loading of the specified page.
  prefs: []
  type: TYPE_NORMAL
- en: So, when the user navigates to the root of the website, the server prepares
    an HTML page containing all the required JavaScript code, but almost no HTML code,
    and sends it to the browser. As soon as the browser has loaded the empty page,
    it requests another page, which will become the body of the first page.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound complicated, but you can look at it as the page being split into
    two parts—the metadata, the scripts, the styles, and possibly the page header
    and footer are the common parts, which do not change during the session. The central
    part (which here is the `body` element, but may also be an inner element) is the
    variable part, which changes with any click from the user.
  prefs: []
  type: TYPE_NORMAL
- en: By reloading only part of the page, the app has better performance and usability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the contents of the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an `XMLHttpRequest` object that, in spite of its name, does
    not use XML, but it is actually used to send an HTTP request. This object is set
    to process the response when it arrives by assigning an anonymous function to
    the `onreadystatechange` field. Then, the specified URI is opened with a `GET`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: When a response arrives, the code checks whether the message is complete (`readystate
    == 4`) and valid (`state == 200`). In this case, the text of the response that
    is assumed to be valid HTML is assigned as the content of the element that has
    `body` as its unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: The last file in the `templates` folder is the `persons.html` file. It is a
    partial HTML file—that is, a file containing HTML elements, but without the `<html>`
    element itself—and so its purpose is to be included in another HTML page. This
    small app has only one page and so it only has one partial HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some interesting parts of this file. The following is an element
    to let the user type in some text (a so-called **edit box**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Its initial value—that is, the text that is shown to the user when the page
    is opened—is a **Tera variable**. Rust code should assign a value to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the `Filter` push button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on it and the preceding edit box contains the word `Ham`, the `'/page/persons?partial_name=Ham'` argument is
    passed to the JavaScript `getPage` functions. So, the function sends the `GET`
    request to the backend and replaces the body of the page with whatever is returned
    by the backend, so long as it is a complete and valid response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the following Tera statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `persons` Tera variable is evaluated. According to the Rust program,
    the variable can only be a collection. If the variable is a non-empty collection,
    a table is inserted into the HTML page; if instead the variable is not defined
    or it is an empty collection, the `No persons.` text will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the HTML code defining the table, there is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is an iteration over the items contained in `persons` (which we know is
    non-empty).
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, the `p` variable will contain the data of a specific person.
    This variable is used in two expressions. The first one shows the value of the
    `id` field of the variable. The second one shows the value of its `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: The other Rust handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have only seen the routing and handling of the root of the site—the `/` path.
    This happens when the user opens the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four other requests that can be sent by the browser to this app:'
  prefs: []
  type: TYPE_NORMAL
- en: When the root path is accessed, the page loaded by this request automatically
    sends—using JavaScript code—another request to load the body of the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user presses the Filter button, the frontend should send the text contained
    in the edit box to the backend, and then the backend should respond by sending
    back the list of the people satisfying this filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser automatically requests the `favicon.ico` app icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other requests should be treated as errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, the first and second of these requests can be handled in the same
    way, because the initial state can be generated by a filter where an empty string
    is specified. So, three different kinds of requests remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To route these requests, the following code is inserted into the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first route redirects any `GET` requests to the `/page/persons` path to
    the `get_page_persons` function. These requests come when the user clicks on the
    Filter button, but also indirectly when the `/` path is requested.
  prefs: []
  type: TYPE_NORMAL
- en: The second route redirects any `GET` requests to the `/favicon.ico` path to
    the `get_favicon` function. These requests come from the browser when it receives
    a complete HTML page, not a partial page.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `default_resource` redirects any other requests to the `invalid_resource` function.
    These requests cannot come with proper use of the app, but may come under specific
    conditions or when the user types an unexpected path into the address bar of the
    browser. For example, this request occurs if you type in `http://127.0.0.1:8080/abc`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the handler's functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_page_persons` function has two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`web::Query<Filter>` is used to pass the optional filter condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web::Data<Mutex<AppState>>` is used to pass the database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameter of the `Query` type is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This specifies the possible arguments of the *query*, which is the part of the
    URI following the question mark. Here, there is only one argument and it is optional
    as it is typical of HTTP queries. A possible query is `?partial_name=Jo`, but
    also an empty string is a valid query in this case.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to receive the `Filter` structure from the request, it must implement
    the `Deserialize` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `get_page_persons` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first statement gets the query from the request. If the `partial_name` field is
    defined, it is extracted; otherwise, an empty string is generated.
  prefs: []
  type: TYPE_NORMAL
- en: The second statement extracts the connection to the database from the shared
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The third statement uses this connection to get an iterator on the people satisfying
    the criteria. See the subsection, *Implementing the database* in the section *Building
    a stateful server* in the previous chapter. See the previous chapter to understand
    these two lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, an empty Tera context is created and two Tera variables are added to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`partial_name` is used to keep the typed characters that otherwise would disappear
    when the page is reloaded in the edit box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persons` is the vector containing the people collected from the database.
    To make this possible, the `Person` type must implement the `Serialize` trait.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the Tera engine can render the `persons.html` template using the *context*,
    because all the variables used in the template have been defined. The result of
    this rendering is passed as the body of the successful HTTP response. When the
    JavaScript code inside the browser receives that HTML code, it will use it to
    replace the contents of the body of the current page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the body of the `get_favicon` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is simply a successful HTTP response whose content is of the `image` HTTP
    type and the `x-icon` subtype, and whose body is a slice of bytes containing the
    icon. This binary object is constructed at compile time from the bytes contained
    in the `favicon.ico` file. The content of this file is embedded in the executable
    program, so it is not required to deploy this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the body of the `invalid_resource` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is a failing response (as `NotFound` generates the `404` status code),
    which should contain a complete HTML page. For simplicity, a straightforward message
    has been returned.
  prefs: []
  type: TYPE_NORMAL
- en: We have now looked at a very simple web app. Many of the concepts seen in this
    section will be used in the following sections, where the database will be modified
    by user actions.
  prefs: []
  type: TYPE_NORMAL
- en: A CRUD application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web app shown in the previous section allowed us to view filtered data
    in a single page. If you now run the project in the `crud` folder, you will see
    a much more rich and useful web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2174b90a-27d2-4afc-8af0-d4a17da515cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The Id edit box and the Find button to its right are used to open a page that
    allows you to view or edit the data of a person with a specific ID.
  prefs: []
  type: TYPE_NORMAL
- en: The Name portion edit box and the Filter button to its right are for filtering
    the table below it, in a similar way as in the `list` project.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there are two buttons—one for deleting data and one for adding data.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, there is the filtered table of the people. In this app, the initial
    state of the database is an empty list of people and so no HTML table is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create some people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Add New Person push button. You will see the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f38e5c37-ec8c-4ca4-82ef-a000de08ecf4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the page used to create a person and insert them into the database.
    The Id field is disabled because its value will be generated automatically. To
    insert a person, type in a name for them—for example, Juliet—and click on the
    Insert button. The main page will appear again, but with a small table containing
    only Juliet, preceded by 1 as its ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you repeat these steps, inserting Romeo and Julius, you''ll have the results
    shown in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67aef1c7-8686-4cb0-9e13-b4c569d27af0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The push buttons near any listed person allow us to open a page related to
    that person. For example, if the button near Julius is clicked, the following
    page will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e7382e0-36d8-46e4-8dea-787cb4ee178b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This page is very similar to the page used to insert people, but with the following
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The Id field now contains a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Name field now contains an initial value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of the Insert button, now there is an Update button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you change the Julius value to Julius Caesar and click on Update, you will
    see the updated list on the main page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to open the page relating to a single person is to type the ID
    of that person into the Id field and then click on the Find button. If you click
    on this button when that field is empty or when it contains a value that no person
    has as its ID, a red error message appears on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f13d161-e9c9-4df8-a61e-6486c50bf70c.png)'
  prefs: []
  type: TYPE_IMG
- en: The final feature of this app allows us to delete records. To do that, click
    on the checkboxes to the left of the lines of the people you want to delete, and
    then click on the Delete Selected Persons button. The list is immediately updated.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the database is stored in the memory of the backend process. You
    will see the same list of people if you close the browser and reopen it or if
    you open another browser. You can even open the page from another computer, as
    long as you insert the appropriate name or IP address of the computer where the
    backend process is running. However, if you terminate the backend process by pressing
    the *Ctrl* + *C* key combination (or in any other way) and then re-run it, all
    of the browsers will display no people when the page is reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to look at what makes this project different from the one described
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the `main.js` file is much larger because it contains three additional
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sendCommand`: This is quite a generic routine used to send HTTP requests to
    a server and to process the received response asynchronously. It accepts five
    arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method` is the HTTP command to use, such as `GET`, `PUT`, `POST`, or `DELETE`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri` is the path and possible query to send to the server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body` is the possible body of the request, used to send data larger than 2
    KB.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success` is a reference to a function that will be called after receiving
    a successful response (`status == 200`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failure` is a reference to a function that will be called after receiving
    any failure response (`status != 200`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is used to access a REST service as it allows any HTTP method,
    but it doesn't automatically change the current HTML page. Instead, the `getPage`
    function can only use the `GET` method, but it replaces the current HTML page
    with the HTML code received.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`delete_selected_persons`: This scans the items whose checkboxes are selected
    and sends a `DELETE` command to the server with the `/persons?id_list=` URI followed
    by a comma-separated list of the IDs of the selected items. The server should
    delete these records and return a successful state. If the deletion is successful,
    this JavaScript function reloads the main page with no filter; otherwise, an error
    message is shown in a message box and the current page is not changed. It should
    be called when the Delete Selected Persons button is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`savePerson`: This receives an HTTP method, which can be `POST` (to insert)
    or `PUT` (to update). It sends a command to the server, using the method received
    as an argument, and a URI that depends on the method. For a `POST` request, the
    URI is `/one_person?name=NAME`, while for a `PUT` request, the URI is `/one_person?id=ID&name=NAME`,
    wherein `ID` and `NAME` are actually the values of the `id` and `name` fields
    of the record to create or update. This function should be called with a `POST`
    argument when the Insert button is clicked and with a `PUT` argument when the
    Update button is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's check the HTML code of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, many HTML elements have been added to the `persons.html` file to
    create the additional widgets.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the `<label class="error">{{id_error}}</label>` element, used
    to display error messages caused by the Find button. To correctly process this
    element, the `id_error` Tera variable needs to be defined in the current Tera
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the following element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When the Find button is clicked, a page is requested at the `/page/edit_person/` URI, followed
    by the typed ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there are two push buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first one simply delegates all the work to the `delete_selected_persons` function,
    while the second one gets the page at the `/page/new_person` URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, two columns are added to the HTML table containing the list of people.
    They are found on the left side of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first column is the checkbox to select the record to delete and the second
    one is the Edit button. The value of the HTML `id` attribute of the checkbox element
    is the `{{p.id}}` Tera expression, which will be replaced by the ID of the record
    of the current line. So, this attribute can be used to prepare the request to
    send it to the server to delete the selected items.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit button will get the page at the `/page/edit_person/` URI, followed
    by the ID of the current record.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there is another HTML partial file, `one_person.html`. This is
    the page used both to insert a new person and to view/edit an existing person.
    Its first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For both of the `input` elements, the `value` attribute is set to a Tera expression;
    for the first one, it is the `person_id` Tera variable and for the second, it
    is the `person_name` Tera variable. When inserting a person, these variables will
    be empty and when editing a person, these variables will contain the current values
    of the database fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This page must show the Insert button when it has been opened for inserting
    a person, and the Update button when it has been opened for viewing or editing
    a person. So, the `inserting` Tera variable is used. Its value will be `true`
    when in insert mode and `false` when in edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Cancel button opens the `/page/persons` page, with no filtering.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to know about the `templates` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `src` folder, both the `db_access.rs` and the `main.rs` files have many
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The db_access.rs changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `persons` vector is initially empty because users can insert records into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_person_by_id`: This searches the vector for a person with a specified
    ID. It returns the person if found or `None`, otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_by_id`: This searches the vector for a person with the specified ID;
    if found, it is removed from the vector and `true` is returned. Otherwise, `false`
    is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert_person`: A `Person` object is received as an argument to insert into
    the database. However, before inserting it into the vector, its `id` field is
    overwritten by a unique ID value. This value is an integer larger than the largest
    ID present in the vector if the vector is not empty, or `1`, otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_person`: This searches the vector for a person that has the specified
    ID; if found, this person is replaced by the specified person and `true` is returned.
    Otherwise, `false` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing web-specific is contained in these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The main.rs changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the `main` function, there are many kinds of requests to the route. The
    new routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first route is used to delete the selected people.
  prefs: []
  type: TYPE_NORMAL
- en: The second route is used to get the page to allow the user to insert a new person—that
    is, the `one_person.html` page—in insert mode.
  prefs: []
  type: TYPE_NORMAL
- en: The third route is used to get the page to allow the user to view or edit a
    new person—that is, the `one_person.html` page—in edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: For the fourth resource, there are two possible routes. Actually, this resource
    can be accessed using the `POST` method or the `PUT` method. The first method
    is used to insert a new record into the database. The second method is used to
    update the specified record using the specified data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the handlers. With respect to the previous project, some of them
    are new, some are old but have been changed, and some are unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new handlers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delete_persons` is used to delete the selected people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_page_new_person` is used to get the page to create a new person.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_page_edit_person` is used to get the page to edit an existing person.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert_person` is used to insert a new person into the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_person` is used to update an existing person in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changed handlers are `get_page_persons` and `invalid_resource`. The unmodified
    handlers are `get_main` and `get_favicon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These handlers can be grouped into three logical kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: The ones whose job it is to generate HTML code to replace part of a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ones whose job it is to return non-HTML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ones that do some work and then return status information regarding the
    job that has been done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML-returning functions are `get_main`, `get_page_persons`, `get_page_new_person`, `get_page_edit_person`,
    and `invalid_resource`. `get_favicon` is the only data-returning function; the
    other three are data-manipulating functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is logically possible to have a single handler that first does some work
    and then returns the HTML page to be shown. However, it is better to separate
    these logically different features into two distinct functions—first, the function
    that manipulates data is executed, and then the function that returns the HTML
    code is run. This separation can happen on the backend or on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, it is the frontend that does the separation. First, JavaScript
    code sends a request to manipulate data (for example, to insert a record in the
    database) and then, if the operation was successful, some other JavaScript code
    requests the HTML code to show up next in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative architecture is to have the following sequence of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: The user performs an action on the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That action causes a JavaScript routine to be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That routine sends a request from the browser to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server routes that request to a backend handler function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The backend handler first calls a routine to manipulate data and then waits
    for its completion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the backend routine is successful, the backend calls another routine to generate
    and return the next HTML page to the browser. If the backend routine fails, the
    backend generates and returns another HTML page to the browser, describing the
    failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JavaScript routine receives the HTML page and displays it to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's look at the body of the `get_page_edit_person` function one piece
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the purpose of this routine is to generate the HTML code of a
    web page to edit the name of a person. The current name of the person to edit
    is to be found in the database and the constant HTML code is to be found in the
    `one_person.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first five statements define and initialize as many local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first statement gets the `id` variable from the path as a string. For this
    function, the routing was `/page/edit_person/{id}`, and so the `id` variable is
    available to be extracted.
  prefs: []
  type: TYPE_NORMAL
- en: The second statement gets and locks the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: The third statement creates an empty Tera context.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth statement tries to parse the `id` Rust variable into an integer.
    If the conversion is successful, the condition of the `if` statement is satisfied
    and so the next statement is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth statement searches the database for a person identified by this ID by
    calling the `get_person_by_id` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the required information is available, the Tera context can be filled
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the purpose of these variables is:'
  prefs: []
  type: TYPE_NORMAL
- en: The `person_id` Tera variable allows us to show the current (disabled) ID of
    the person on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `person_name` Tera variable allows us to show the current (editable) name of
    the person on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inserting` Tera variable allows us (through a conditional Tera statement)
    to set the page as an edit page, instead of as an insert page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can call the `render` Tera method with this context to get the HTML
    page and send the resulting page as the HTML body of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have considered the cases where every statement was successful. In
    cases where the typed ID is not a number or it does not exist in the database,
    the function carries out the following code. This happens when the user types
    a wrong number in the Id field of the main page and then clicks on Find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The last line shows that the template we will use is `persons.html`, so we are
    going to the main page. The Tera variables of that template are `id_error`, `partial_name`,
    and `persons`. We want a specific error message in the first variable, nothing
    as the `filter` condition, and a list of all the people. This can be obtained
    by filtering all the people whose name contains an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses the Update button, the `update_person` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function has the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is a query using a type defined by the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this query allows two optional keywords: `id` and `name`. The first keyword
    must be an integer number. Here are some valid queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?id=35&name=Jo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?id=-2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?name=Jo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are invalid queries for that structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?id=x&name=Jo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?id=2.4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the first part of the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first statement gets and locks the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: A count of the records to update is defined by the second statement. This routine
    can update only one record, and so this count will be `0` or `1` only.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `id` variable is extracted from the query, if present and valid, or
    otherwise, `0` is considered as a substitute.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that because the type of the query variable defines which fields are
    defined (whether they are optional or required and what is their type), the Actix
    web framework can perform a strict parsing of the URI query. If the URI query
    is not valid, the handler is not invoked and the `default_service` routine will
    be chosen. On the other side, in the handler, we can be sure that the query is
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the body of the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: First, the `name` variable is extracted from the query, or an empty string is
    considered if that variable is not contained in the query. This name is cloned
    as the database operations take ownership of their arguments and we cannot yield
    the ownership of a field of the query.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `update_person` method of the database connection is called. This
    method receives a new `Person` object constructed with the `id` and `name` values
    that were just extracted. If this method returns `true`, the count of the processed record
    is set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the count of the processed record is returned as a response.
  prefs: []
  type: TYPE_NORMAL
- en: The other routines are conceptually similar to the one described here.
  prefs: []
  type: TYPE_NORMAL
- en: Handling an application with authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the features of the previous apps were accessible to everyone that could
    create an HTTP connection with our server. Usually, a web app should behave differently
    depending on who is currently using it. Typically, some users are authorized to
    carry out some important operations, such as adding or updating records, while
    other users are authorized only to read these records. Sometimes, user-specific
    data must be recorded.
  prefs: []
  type: TYPE_NORMAL
- en: This opens up the vast world of authentication, authorization, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a simplified scenario. There are two users whose profiles are
    wired-in to the mock database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`joe`, whose password is `xjoe`, can *only read* the database of people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`susan`, whose password is `xsusan`, can *read and write* the database of people—that
    is, she can do what the app in the previous section allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application starts with a login page. If the user does not insert an existing
    username and its matching password, they cannot access the other pages. Even if the
    username and password are valid, the widgets that the user is not authorized for
    are disabled.
  prefs: []
  type: TYPE_NORMAL
- en: For these situations, some applications create a server-side user session. This
    may be appropriate to use when there are a limited number of users, but it may
    overload the server if there are many users. Here, we'll show a solution without server-side
    sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `auth` project and access the site from a browser, you will
    see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a209eca-a7bc-4860-a7bf-5cf1efe3bb59.png)'
  prefs: []
  type: TYPE_IMG
- en: It shows that there is no current users and two fields allow us to type in a
    username and password. If you type `foo` into the User name field and then click
    on Log in, the red User "foo" not found. message will appear. If you type in `susan` and
    then click on Log in, the message will be Invalid password for user "susan".
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, if you type in the correct password for that user, `xsusan`, the following
    page will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73a1f6eb-efe0-4ed7-b2d7-ba40187e9a47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the same main page as the `crud` project, with an added line of widgets:
    the name of the current user shown in blue and a button to change it. If you click
    on the Change User button, you go back to the login page. Also, the page to view,
    edit, or insert a person has the same widgets just under the page heading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If on the login page you insert `joe` as the username and `xjoe` as the password,
    the following page will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d2829e0-7823-4a0f-835c-7353bddc0ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: This has the same widgets that appeared for `susan`, but the Delete Selected
    Persons button and the Add New Person button now are disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how `joe` sees the people, first, you need to log in as `susan`, insert
    some people, and then change the user to `joe`, because `joe` cannot insert people.
    If you do this and then you click on the Edit button of a person, you will see
    the following page, where the Name field is read-only and the Update button is
    disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/579cb170-8a21-4c31-8c0e-b5a68968c7ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with understanding the nitty-gritty of the application we just did.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project adds some code with respect to the `crud` project.
  prefs: []
  type: TYPE_NORMAL
- en: The first difference is in the `Cargo.toml` file, where the `actix-web-httpauth
    = "0.1"` dependency has been added. This crate handles the encoding of the username
    and password in the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `main.html` page, instead of opening the `/page/persons` URI, opens `/page/login` to
    show the login page, initially. So, this project adds a new TERA template for
    the login page. This is the `login.html` partial HTML page, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Its noteworthy points are underlined: the `{{error_message}}` Tera variable,
    the call to `login()` when the Log in button is clicked, and three elements whose
    IDs are `current_user`, `username`, and `password`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `persons.html` and `one_person.html` templates have the following
    section just below the heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will show the current user, or `---`, followed by the Change User button.
    Clicking on this will load the `/page/login` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app contains four buttons that must be disabled for unauthorized users—two
    in the `persons.html` template and two in the `one_person.html` template. They
    now contain the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It assumes that the `can_write` Tera variable is defined as `true`, or any non-null
    value, if—and only if—the current user has the authorization to modify the content
    of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an edit box element in the `one_person.html` template that must
    be made read-only for users that are not authorized to change that data; so, it
    contains the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You should be aware that these checks are not an ultimate security guard. The
    checks of authorization in frontend software can always be bypassed, and so the
    ultimate security guards are those performed by the DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is good to always carry out an early check to make that the user
    experience is more intuitive and the error messages are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an attribute of an entity shouldn't be modifiable by the current
    user, this constraint can be specified in a solid way using the DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user interface allows this kind of change, the user could try
    to change this value and they will be disappointed when they find out that this
    change is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when a forbidden change is attempted, an error message is issued
    by the DBMS. The message is probably not internationalized and makes reference
    to DBMS concepts such as tables, columns, rows, and the names of objects that
    are unfamiliar to the user. So, this message can be obscure for the user.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `main.js` file has the following additions with respect to the `crud` project.
  prefs: []
  type: TYPE_NORMAL
- en: The `username` and `password` global variables have been added and initialized
    as empty strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement has been added to both the `sendCommand` function and
    the `getPage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This sets the `Authorization` header for the HTTP request that is about to be
    sent. The format of that header is standard HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getPage` function, after the statement that assigns the HTML code that
    is received to the current body, the following three lines are inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: They set the content of the element whose `id` attribute has `current_user` as
    its value if the current page contains such an element. This content is the value
    of the `username` global JavaScript variable if it is defined and not empty, or
    `---`, otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another addition is the definition of the new `login` function. Its body is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This gets the values of the `username` and `password` elements of the page and
    saves them to the global variables with the same names, and then opens the main
    page. Of course, this should only be called in the `login.html` page as other
    pages are not likely to have a `password` element.
  prefs: []
  type: TYPE_NORMAL
- en: The mock database code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mock database has one more table: `users`. So, the type of its elements
    must be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Any user has a username, a password, and a set of privileges. A **privilege**
    has a custom type, which is defined in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are only two possible privileges: to be able to read the database
    or to be able to write the database. A real-world system would have more granularity.'
  prefs: []
  type: TYPE_NORMAL
- en: The `DbConnection` struct now also contains the `users` field, which is a vector
    of `Users`. Its content (the records about `joe` and `susan`) is specified inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This searches the `users` vector for a user with the specified username. If
    it is found, it is returned; otherwise, `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `main` function has just two small changes. The first change is to call `data(Config::default().realm("PersonsApp"))` on
    the `App` object. This invocation is required to get the authentication context
    from the HTTP requests. It specifies the context using the `realm` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change is the addition of the following routing rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This path is used to open the login page. It is used by the main page as the
    entry point of the app and by the two Change User buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_page_login` function is the only new handler. It just calls the `get_page_login_with_message` function, which
    has a string argument, to be shown as an error message. When this function is
    called by `get_page_login`, an empty string is specified as an argument because
    no error has happened yet on this page. However, this function is called in six other places,
    where various error messages are specified. The purpose of this function is to
    go to the login page and display the message received as an argument in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'The login page is obviously accessible to every user, as the favicon resource
    is, but all of the other handlers have been modified to ensure that only authorized
    users can access those resources. The bodies of the handlers that manipulate data
    have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First, the `check_credentials` function checks whether the credentials specified
    by the `auth` argument identify a user that has the `CanWrite` privilege. Only
    users allowed to write should manipulate the data. For them, the function returns
    as `Ok` and so they can change the database and return the result of these changes
    in a plaintext format.
  prefs: []
  type: TYPE_NORMAL
- en: Users that are not allowed to write are redirected to the login page, which
    shows the error message returned by `check_credentials`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the bodies of the handlers that get HTML pages have the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, as is typical, any user that can read the data can also access the web
    page. In this case, the `check_credentials` function is successful and it returns
    the complete set of privileges of that user. Matching these results with the `Ok(privileges)` pattern causes
    the privileges of that user to be used to initialize the `privileges` Rust variable.
  prefs: []
  type: TYPE_NORMAL
- en: If the user has the `CanWrite` privilege, that information is passed to the
    `can_write` Tera variable as a `true` value and to `false`, otherwise. In this
    way, the page can enable or disable the HTML widgets in accordance with the user's
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's look at the `check_credentials` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its arguments, there is `auth: BasicAuth`. Thanks to the `actix_web_httpauth` crate
    and to the call to `data` in the main function, this argument allows access to
    the authorization HTTP header for basic authentication. The objects of the `BasicAuth` type
    have the `user_id` and `password` methods, which return the optional credential
    specified by the HTTP client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are invoked with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This code gets the user from the database through their username and checks
    that the stored password matches the password coming from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite basic. A real-world system would store an encrypted password;
    it would encrypt the specified password using the same one-way encryption and
    it would compare the encrypted strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the routine discriminates between the different kinds of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request does not contain credentials, or the credentials exist but
    the specified user does not exist in the user's table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user exists, but the stored password is different from that specified in
    the received credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The credentials are valid, but that user hasn't got the required privileges
    (for example, they only have the `CanRead` access but `CanWrite` is required).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have now covered a simple authenticated web app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use the Tera template engine to create
    text strings or files (not just in HTML format) containing variable parts, conditional
    sections, repeated sections, and sections included from another file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we saw how Actix web—together with HTML code, JavaScript code, CSS styles,
    and the Tera template engine—can be used to create a complete web app with CRUD
    capabilities, authentication (to prove who is the current user), and authorization
    (to forbid some operations to the current user).
  prefs: []
  type: TYPE_NORMAL
- en: This project showed us how to create a single application that performs both
    client-side code and server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create a client-side web app using WebAssembly
    technology and the Yew framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the possible strategies for creating HTML code containing variable
    parts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the syntax to embed a Tera expression into a text file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the syntax to embed a Tera statement into a text file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are the values of variables in a Tera rendering operation specified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the requests to a web server be classified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why may it be useful to split a web page into parts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should HTML templates and JavaScript files be deployed separately or are they
    linked into the executable program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which JavaScript object can be used to send HTTP requests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where should the current username be stored when the server does not store user
    sessions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are credentials extracted from an HTTP request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional information regarding Tera can be found at [https://tera.netlify.app/](https://tera.netlify.app/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information regarding Actix web can be found at [https://actix.rs/docs/](https://actix.rs/docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of web development libraries and frameworks can be found at [https://www.arewewebyet.org/](https://www.arewewebyet.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
