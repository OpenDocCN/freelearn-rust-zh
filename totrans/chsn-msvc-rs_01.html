<html><head></head><body>
        

                            
                    <h1 class="header-title">Introduction to Microservices</h1>
                
            
            
                
<p class="mce-root">This chapter will introduce you to the basics of microservices, including what a microservice is and how to break a monolithic server down into microservices. It will be useful if you are not familiar with the concept of microservices or if you have never implemented them using the Rust programming language.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What are microservices?</li>
<li>How to transform a traditional server architecture into microservices</li>
<li>The importance of Rust in microservices development</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter hasn't got any special technical requirements, but now is a good time to install or update your Rust compiler. You can get this from Rust's official website: <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a> . I recommend that you use the <kbd>rustup</kbd> tool, which you can download from <a href="https://rustup.rs/">https://rustup.rs/</a>.</p>
<p>If you have previously installed the compiler, you need to update it to the latest version using the following command:</p>
<pre><strong>rustup update</strong></pre>
<p>You can get the examples for this book from the GitHub page: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What are microservices?</h1>
                
            
            
                
<p>Modern users interact with microservices every day; not directly, but by using web applications. Microservices are a flexible software development technique that help to implement applications as a collection of independent services with weak relations.</p>
<p>In this section, we'll learn about why microservices are a good thing and why we need them. Microservices follow the REST architecture, which provides rules about using consistent HTTP methods. We will also look at how microservices can be deployed to the user, which is one of their main advantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why we need microservices</h1>
                
            
            
                
<p>Microservices are a modern software development approach that refers to the splitting of software into a suite of small services that are easier to develop, debug, deploy, and maintain. Microservices are tiny, independent servers that act as single business functions. For example, if you have an e-commerce suite that works as a monolith, you could split it into small servers that have limited responsibility and carry out the same tasks. One microservice could handle user authorization, the other could handle the users' shopping carts, and the remaining services could handle features such as search functionality, social-media integration, or recommendations.</p>
<p>Microservices can either interact with a database or be connected to other microservices. To interact with a database, microservices can use different protocols. These might include HTTP or REST, Thrift, ZMQ, AMQP for the messaging communication style, WebSockets for streaming data, and even the old-fashioned <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) to integrate them with the existing infrastructure. We will use HTTP and REST in this book, because this is the most flexible way to provide and interact with the web API. We'll explain this choice later.</p>
<p>Microservices have the following advantages over monolithic servers:</p>
<ul>
<li>You can use different programming languages</li>
<li>The code base of a single server is smaller</li>
<li>They have an independent DevOps process to build and deploy activities</li>
<li>They can be scaled depending on their implementation</li>
<li>If one microservice fails, the rest will continue to work</li>
<li>They work well within containers</li>
<li>Increased isolation between elements leads to better security</li>
<li>They are suitable for projects involving the Internet of Things</li>
<li>They are in line with the DevOps philosophy</li>
<li>They can be outsourced</li>
<li>They can be orchestrated after development</li>
<li>They are reusable</li>
</ul>
<p>There are, however, a few drawbacks of microservices. These include the following:</p>
<ul>
<li>Too many microservices overload the development process</li>
<li>You have to design interaction protocols</li>
<li>They can be expensive for small teams</li>
</ul>
<p class="mce-root">A microservices architecture is a modern approach that can help you achieve the goal of having loosely coupling elements. This is where the servers are independent from one another, helping you to release and scale your application faster than a monolithic approach, in which you put all your eggs in one basket.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to deploy a microservice</h1>
                
            
            
                
<p>Since a microservice is a small but complete web server, you have to deploy it as a complete server. But since it has a narrow scope of features, it's also simpler to configure. Containers can help you pack your binaries into an image of the operating system with the necessary dependencies to simplify deployment.</p>
<p>This differs from the case with monoliths, in which you have a system administrator who installs and configures the server. Microservices need a new role to carry out this function—DevOps. DevOps is not just a job role, but a whole software engineering culture in which developers become system administrators and vice versa. DevOps engineers are responsible for packing and delivering the software to the end user or market. Unlike system administrators, DevOps engineers work with clouds and clusters and often don't touch any hardware except their own laptop.</p>
<p>DevOps uses a lot of automation and carries the application through various stages of the delivery process: building, testing, packaging, releasing, or deployment, and the monitoring of the working system. This helps to reduce the time it takes both to market a particular software and to release new versions of it. It's impossible to use a lot of automation for monolithic servers, because they are too complex and fragile. Even if you want to pack a monolith to a container, you have to deliver it as a large bundle and run the risk that any part of the application could fail. In this section, we'll have a brief look at containers and continuous integration. We will go into detail about these topics in <a href="80b8c3ec-d291-40df-a7a7-b9e9f0a64a99.xhtml">Chapter 15</a>, <em>Packing Servers to Containers</em>, and <a href="02047e73-9d47-4f12-ae3c-99d5c77daf51.xhtml">Chapter 16</a>, <em>DevOps of Rust Microservices – Continuous Integration and Delivery</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Docker</h1>
                
            
            
                
<p>When we refer to containers, we almost always mean Docker containers (<a href="https://www.docker.com/">https://www.docker.com/</a>). Docker is the most popular software tool for running programs in containers, which are isolated environments.</p>
<p>Containerization is a kind of virtualization where the scope of the application's resources is limited. This means the application works at its maximum performance level. This is different from full virtualization, where you have to run the full operating system with the corresponding overhead and run your application inside that isolated operating system.</p>
<p>Docker has become popular for a variety of reasons. One of these reasons is that it has a registry—the place where you can upload and download images of containers with applications. The public registry is Docker Hub (<a href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a>), but you can have a private registry for a private or permissioned software.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous Integration</h1>
                
            
            
                
<p><strong>Continuous Integration</strong> (<strong>CI</strong>) is the practice of keeping a master copy of the software and using tests and merging processes to expand the features of the application. The process of CI is integrated with the <strong>Source Code Management</strong> (<strong>SCM</strong>) process. When the source code is updated (for example, in Git), the CI tool checks it and starts the tests. If all tests pass, developers can merge the changes to the master branch.</p>
<p>CI doesn't guarantee that the application will work, because tests can be wrong, but it removes the need to run tests from developers on an automated system. This gives you the great benefit of being able to test all your upcoming changes together to detect conflicts between changes. Another advantage is that the CI system can pack your solution in a container, so the only thing that you have to do is deliver the container to a production cloud. The deployment of containers is also simple to automate. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to split a traditional server into multiple microservices</h1>
                
            
            
                
<p>Around 10 years ago, developers used to use the Apache web server with a scripting programming language to create web applications, rendering the views on the server-side. This meant that there was no need to split applications into pieces and it was simpler to keep the code together. With the emergence of <strong>Single-Page Applications</strong> (<strong>SPAs</strong>), we only needed server-side rendering for special cases and applications were divided into two parts: frontend and backend. Another tendency was that servers changed processing method from synchronous (where every client interaction lives in a separate thread) to asynchronous (where one thread processes many clients simultaneously using non-blocking, input-output operations). This trend promotes the better performance of single server units, meaning they can serve thousands of clients. This means that we don't need special hardware, proprietary software, or a special toolchain or compiler to write a tiny server with great performance.</p>
<p>The invasion of microservices happened when scripting programming languages become popular. By this, we are not only referring to languages for server-side scripting, but general-purpose high-level programming languages such as Python or Ruby. The adoption of JavaScript for backend needs, which had previously always been asynchronous, was particularly influential.</p>
<p>If writing your own server wasn't hard enough, you could create a separate server for special cases and use them directly from the frontend application. This would not require rendering procedures on the server. This section has provided a short description of the evolution from monolithic servers to microservices. We are now going to examine how to break a monolithic server into small pieces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reasons to avoid monoliths</h1>
                
            
            
                
<p>If you already have a single server that includes all backend features, you have a monolithic service, even if you start two or more instances of this service. A monolithic service has a few disadvantages—it is impossible to scale vertically, it is impossible to update and deploy one feature without interrupting all the running instances, and if the server fails, it affects all features. Let's discuss these disadvantages a little further. This might help you to convince your manager to break your service down into microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Impossible to scale vertically</h1>
                
            
            
                
<p>There are two common approaches to scaling an application:</p>
<ul>
<li><strong>Horizontally</strong>: Where you start a new instance of application</li>
<li><strong>Vertically</strong>: Where you improve an independent application layer that has a bottleneck</li>
</ul>
<p>The simplest way to scale a backend is to start another instance of the server. This will solve the issue, but in many cases it is a waste of hardware resources. For example, imagine you have a bottleneck in an application that collects or logs statistics. This might only use 15% of your CPU, because logging might include multiple IO operations but no intensive CPU operations. However, to scale this auxiliary function, you will have to pay for the whole instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Impossible to update and deploy only one feature</h1>
                
            
            
                
<p>If your backend works as a monolith, you can't update only a small part of it. Every time you add or change a feature, you have to stop, update, and start the service again, which causes interruptions.</p>
<p>When you have a microservice and you have find a bug, you can stop and update only this microservice without affecting the others. As I mentioned before, it can also be useful to split a product into separate development teams.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The failure of one server affects all features</h1>
                
            
            
                
<p>Another reason to avoid monoliths is that every server crash also crashes all of the features, which causes the application to stop working completely, even though not every feature is needed for it to work. If your application can't load new user interface themes, the error is not critical, as long as you don't work in the fashion or design industry, and your application should still be able to provide the vital functions to users. If you split your monolith into independent microservices, you will reduce the impact of crashes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Breaking a monolithic service into pieces</h1>
                
            
            
                
<p>Let's look an example of an e-commerce monolith server that provides the following features:</p>
<ul>
<li><strong>User registration</strong></li>
<li><strong>Product catalog</strong></li>
<li><strong>Shopping cart</strong></li>
<li><strong>Payment integration</strong></li>
<li><strong>E-mail notifications</strong></li>
<li><strong>Statistics collecting</strong></li>
</ul>
<p>Old-fashioned servers developed years ago would include all of these features together. Even if you split it into separate application modules, they would still work on the same server. You can see an example structure of a monolithic service here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/89a92a8e-cb97-474c-afbd-4b055ef7c647.png" style="width:33.67em;height:21.75em;"/></p>
<p>In reality, the real server contains more modules than this, but we have separated them into logical groups based on the tasks they perform. This is a good starting point to breaking your monolith into multiple, loosely coupled microservices. In this example, we can break it further into the pieces represented in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3ba5553e-806f-4099-b53a-2e5f0a37791b.png" style="width:36.67em;height:18.25em;"/></p>
<p>As you can see, we use a <strong>balancer</strong> to route requests to microservices. You can actually connect to microservices directly from the frontend application.</p>
<p>Shown in the preceding diagram is the potential communication that occurs between services. For simple cases, you can use direct connections. If the interaction is more complex, you can use message queues. However, you should avoid using a shared state such as a central database and interacting through records, because this can cause a bottleneck for the whole application. We will discuss how to scale microservices in <a href="98204850-538d-4a2b-9a77-23f85e716400.xhtml">Chapter 12</a>, <em>Scalable Microservices Architecture.</em> For now, we will explore REST API, which will be partially implemented in a few examples throughout this book. We will also discuss why Rust is a great choice for implementing microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Definition of a REST API</h1>
                
            
            
                
<p>Let's define the APIs that we will use in our microservice infrastructure using the REST methodology. In this example, our microservices will have minimal APIs for demonstration purposes; real microservices might not be quite so "micro". Let's explore the REST specifications of the microservices of our application. We will start by looking at a microservice for user registration and go through every part of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">User registration microservice</h1>
                
            
            
                
<p>The first service is responsible for the registration of users. It has to contain methods to add, update, or delete users. We can cover all needs with the standard REST approach. We will use a combination of methods and paths to provide this user registration functionality:</p>
<ul>
<li class="mce-root"><kbd>POST</kbd> request to <kbd>/user/</kbd> creates a new user and returns its <kbd>id</kbd></li>
<li><kbd>GET</kbd> request to <kbd>/user/id</kbd>  returns information related to a user with <kbd>id</kbd></li>
<li><kbd>PUT</kbd> request to <kbd>/user/id</kbd>  applies changes to a user with <kbd>id</kbd></li>
<li><kbd>DELETE</kbd> request to <kbd>/user/id</kbd>  removes a user with <kbd>id</kbd></li>
</ul>
<p>This service can use the <strong>E-mail notifications</strong> microservice and call its methods to notify the user about registration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">E-mail notifications microservice</h1>
                
            
            
                
<p>The <strong>E-mail notifications</strong> microservice can be extremely simple and contains only a single method:</p>
<ul>
<li>The <kbd>POST</kbd> request to <kbd>/send_email/</kbd>  sends an email to any address</li>
</ul>
<p>This server can also count the sent emails to prevent spam or check that the email exists in the user's database by requesting it from the <strong>User registration</strong> microservice. This is done to prevent malicious use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Product catalog  microservice</h1>
                
            
            
                
<p>The <strong>Product catalog</strong> microservice tracks the available products and needs only weak relations with other microservices, except for the <strong>Shopping cart</strong>. This microservice can contain the following methods:</p>
<ul>
<li class="mce-root"><kbd>POST</kbd> request to <kbd>/product/</kbd> creates a new product and returns its <kbd>id</kbd></li>
<li><kbd>GET</kbd> request to <kbd>/product/id</kbd>  returns information about the product with <kbd>id</kbd></li>
<li><kbd>PUT</kbd> request to <kbd>/product/id</kbd>  updates information about the product with <kbd>id</kbd></li>
<li><kbd>DELETE</kbd> request to <kbd>/product/id</kbd>  marks the product with <kbd>id</kbd> as deleted</li>
<li><kbd>GET</kbd> request to <kbd>/products/</kbd> returns a list of all products (can be paginated by extra parameters)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Shopping cart microservice</h1>
                
            
            
                
<p>The <strong>Shopping cart</strong> microservice is closely integrated with the <strong>User registration</strong> and <strong>Product catalog</strong> microservices. It holds pending purchases and prepares invoices. It contains the following methods:</p>
<ul>
<li class="mce-root"><kbd>POST</kbd> request to <kbd>/user/uid/cart/</kbd>, which puts a product in the cart and returns the <kbd>id</kbd> of item in the user's cart with the <kbd>uid</kbd></li>
<li class="mce-root"><kbd>GET</kbd> request to <kbd>/user/uid/cart/id</kbd>, which returns information about the item with <kbd>id</kbd></li>
<li class="mce-root"><kbd>PUT</kbd> request to <kbd>/user/uid/cart/id</kbd>, which updates information about the item with <kbd>id</kbd> (alters the quantity of items)</li>
<li class="mce-root"><kbd>GET</kbd> request to <kbd>/user/uid/cart/</kbd>, which returns a list of all the items in the cart</li>
</ul>
<p>As you can see, we don't add an extra "s" to the <kbd>/cart/</kbd> URL and we use the same path for creating items and to get a list, because the first handler reacts to the <kbd>POST</kbd> method, the second processes requests with the <kbd>GET</kbd> method, and so on. We also use the user's ID in the path. We can implement the nested REST functions in two ways:</p>
<ul>
<li>Use session information to get the user's <kbd>id</kbd>. In this case, the paths contain a single object, such as <kbd>/cart/id</kbd> . We can keep the user's <kbd>id</kbd> in session cookies, but this is not reliable.</li>
<li>We can add the <kbd>id</kbd> of a user to a path explicitly.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Payment Integration microservice</h1>
                
            
            
                
<p>In our example, this microservice will be a third-party service, which contains the following methods:</p>
<ul>
<li><kbd>POST</kbd> request to <kbd>/invoices</kbd>  creates a new invoice and returns its <kbd>id</kbd></li>
<li><kbd>POST</kbd> request to <kbd>/invoices/id/pay</kbd>  pays for the invoice</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Statistics collecting microservice</h1>
                
            
            
                
<p>This service collects usage statistics and logs a user's actions to later improve the application. This service exports API calls to collect the data and contains some internal APIs to read the data:</p>
<ul>
<li class="mce-root"><kbd>POST</kbd> request to <kbd>/log</kbd>  logs a user's actions (the <kbd>id</kbd> of a user is set in the body of the request)<strong><br/></strong></li>
<li><kbd>GET</kbd> request to <kbd>/log?from=?&amp;to=?</kbd>  works only from the internal network and returns the collected data for the period specified</li>
</ul>
<p>This microservice doesn't conform clearly to the REST principles. It's useful for microservices that provide a full set of methods to add, modify, and remove the data, but for other services, it is excessively restrictive. You don't have follow a clear REST structure for all of your services, but it may be useful for some tools that expect it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transformation to microservices</h1>
                
            
            
                
<p>If you already have a working application, you might transform it into a set of microservices, but you have to keep the application running at the highest rate and prevent any interruptions.</p>
<p>To do this, you can create microservices step by step, starting from the least important task. In our example, it's better to start from email activities and logging. This practice helps you to create a DevOps process from scratch and join it with the maintenance process of your app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reusing existing microservices</h1>
                
            
            
                
<p>If your application is a monolith server, you don't need to turn all modules into microservices, because you can use existing third-party services and shrink the bulk of the code that needs rewriting. These services can help with many things, including storage, payments, logging, and transactional notifications that tell you whether an event has been delivered or not.</p>
<p>I recommend that you create and maintain services that determine your competitive advantage yourself and then use third-party services for other tasks. This can significantly shrink your expenses and the time to market.</p>
<p>In any case, remember the product that you are delivering and don't waste time on unnecessary units of your application. The microservices approach helps you to achieve this simply, unlike the tiresome coding of monoliths, which requires you to deal with numerous secondary tasks. Hopefully, you are now fully aware of the reasons why microservices can be useful. In the next section, we will look at why Rust is a promising tool for creating microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why Rust is a great tool for creating microservices</h1>
                
            
            
                
<p>If you have chosen to read this book, you probably already know that Rust is an up-to-date, powerful, and reliable language. However, choosing it to implement microservices is not an obvious decision, because Rust is a system programming language that is often assigned to low-level software such as drivers or OS kernels. This is because you tend to have to write a lot of glue code or get into detailed algorithms with low-level concepts, such as pointers in system programming languages. This is not the case with Rust. As a Rust programmer, you've surely already seen how it can be used to create high-level abstractions with flexible language capabilities. In this section, we'll discuss the strengths of Rust: its strict and explicit nature, its high performance, and its great package system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Explicit versus implicit</h1>
                
            
            
                
<p>Up until recently, there hasn't been a well-established approach to using Rust for writing asynchronous network applications. Previously, developers tended to use two styles: either explicit control structures to handle asynchronous operations or implicit context switching. The explicit nature of Rust meant that the first approach outgrew the second. Implicit context switching is used in concurrent programming languages such as Go, but this model does not suit Rust for a variety of reasons. First of all, it has design limitations and it's hard or even impossible to share implicit contexts between threads. This is because the standard Rust library uses thread-local data for some functions and the program can't change the thread environment safely. Another reason is that an approach with context switching has overheads and therefore doesn't follow the zero-cost abstractions philosophy because you would have a background runtime. Some modern libraries such as <kbd>actix</kbd> provide a high-level approach similar to automatic context switching, but actually use explicit control structures for handling asynchronous operations.</p>
<p>Network programming in Rust has evolved over time. When Rust was released, developers could only use the standard library. This method was particularly verbose and not suitable for writing high-performance servers. This was because the standard library didn't contain any good asynchronous abstractions. Also, event <kbd>hyper</kbd>, a good crate for creating HTTP servers and clients, processed requests in separate threads and could therefore only have a certain number of simultaneous connections.</p>
<p>The <kbd>mio</kbd> crate was introduced to provide a clear asynchronous approach to make high-performance servers. It contained functions to interact with asynchronous features of the operating system, such as epoll or kqueue<em><strong>,</strong></em> but it was still verbose, which made it hard to write modular applications.</p>
<p>The next abstraction layer over <kbd>mio</kbd> was a <kbd>futures</kbd> and <kbd>tokio</kbd> pair of crates. The <kbd>futures</kbd> crate contained abstractions for implementing delayed operations (like the defers concept in Twisted, if you're familiar with Python). It also contained types for assembling stream processors, which are reactive and work like a finite state machine.</p>
<p>Using the <kbd>futures</kbd> crate was a powerful way to implement high-performance and high-accuracy network software. However, it was a middleware crate, which made it hard to solve everyday tasks. It was a good base for rewriting crates such as <kbd>hyper</kbd>, because these can use explicit asynchronous abstractions with full control.</p>
<p>The highest level of abstraction today are crates that use <kbd>futures</kbd>, <kbd>tokio</kbd>, and <kbd>hyper</kbd> crates, such as <kbd>rocket</kbd> or <kbd>actix-web</kbd>. Now, <kbd>rocket</kbd> includes high-level elements to construct a web server with the minimal amount of lines. <kbd>actix-web</kbd> works as a set of actors when your software is broken down into small entities that interact with one another. There are many other useful crates, but we will start with hyper as a basis for developing web servers from scratch. Using this crate, we will be between low-level crates, such as futures, and high-level crates, such as <kbd>rocket</kbd>. This will allow us to understand both in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Minimal amount of runtime errors</h1>
                
            
            
                
<p>There are many languages suitable for creating microservices, but not every language has a reliable design to keep you from making mistakes. Most interpreted dynamic languages let you write flexible code that decides on the fly which field of the object to get and which function to call. You can often even override the rules of function calling by adding meta-information to objects. This is vital in meta-programming or in cases where your data drives the behavior of the runtime.</p>
<p>The dynamic approach, however, has significant drawbacks for the software, which requires reliability rather than flexibility. This is because any inaccuracy in the code causes the application to crash. The first time you try to use Rust, you may feel that it lacks flexibility. This is not true, however; the difference is in the approach you use to achieve flexibility. With Rust, all your rules must be strict. If you create enough abstractions to cover all of the cases your application might face, you will get the flexibility you want.</p>
<p class="mce-root"/>
<p>Rust rookies who come from the JavaScript or the Python world might notice that they have to declare every case of serialization/deserialization of data, whereas with dynamic languages, you can simply unpack any input data to the free-form object and explore the content later. You actually have to check all cases of inconsistency during runtime and try and work out what consequences could be caused if you change one field and remove another. With Rust, the compiler checks everything, including the type, the existence, and the corresponding format. The most important thing here is the type, because you can't compile a program that uses incompatible types. With other languages, this sometimes leads to strange compilation errors such as a case where you have two types for the same crate but the types are incompatible because they were declared in different versions of the same crate. Only Rust protects you from shooting yourself in the foot in this way. In fact, different versions can have different rules of serialization/deserialization for a type, even if both declarations have the same data layout. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Great performance</h1>
                
            
            
                
<p>Rust is a system programming language. This means your code is compiled into native binary instructions for the processor and runs without unwanted overhead, unlike interpreters such as JavaScript or Python.</p>
<p>Rust also doesn't use a garbage collector and you can control all allocations of memory and the size of buffers to prevent overflow.</p>
<p>Another reason why Rust is so fast for microservices is that it has zero-cost abstractions, which means that most abstractions in the language weigh nothing. They turn into effective code during compilation without any runtime overhead. For network programming, this means that your code will be effective after compilation, that is, once you have added meaningful constructions in the source code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Minimal dependencies burden</h1>
                
            
            
                
<p>Rust programs are compiled into a single binary without unwanted dependencies. It needs libc or another dynamic library if you want to use OpenSSL or similar irreplaceable dependencies, but all Rust crates are compiled statically into your code.</p>
<p>You may think that the compiled binaries are quite large to be used as microservices. The word microservice, however, refers to the narrow logic scope, rather than the size. Even so, statically linked programs remain tiny for modern computers.</p>
<p>What benefits does this give you? You will avoid having to worry about dependencies. Each Rust microservice uses its own set of dependencies compiled into a single binary. You can even keep microservices with obsolete features and dependencies besides new microservices. In addition, Rust, in contrast with the Go programming language, has strict rules for dependencies. This means that the project resists breaking, even if someone forces an update of the repository with the dependency you need.</p>
<p>How does Rust compare to Java? Java has microframeworks for building microservices, but you have to carry all dependencies with them. You can put these in a fat <strong>Java ARchive</strong> (<strong>JAR</strong>), which is a kind of compiled code distribution in Java, but you still need <strong>Java Virtual Machine</strong> (<strong>JVM</strong>). Don't forget, too, that Java will load every dependency with a class loader. Also, Java bytecode is interpreted and it takes quite a while for the <strong>Just-In-Time</strong> (<strong>JIT</strong>) compilation to finish to accelerate the code. With Rust, bootstrapping dependencies don't take a long time because they are attached to the code during compilation and your code will work with the highest speed from the start since it was already compiled into native code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have mastered the basics of microservices. Simply put, a microservice is a compact web server that handles specific tasks. For example, microservices can be responsible for user authentication or for email notifications. They make running units reusable. This means you don't need to recompile or restart units if they don't require any updates. This approach is simpler and more reliable in deployment and maintenance.</p>
<p>We have also discussed how to split a monolithic web server that contains all of its business logic in a single unit into smaller pieces and join them together through communication, in line with the ideology of loose coupling. To split a monolithic server, you should separate it into domains that are classified by what tasks the servers carry out.</p>
<p>In the last section of this chapter, we've looked at why Rust is a good choice for developing microservices. We touched on dependencies management, the performance of Rust, its explicit nature, and its toolchain. It's now time to dive deep into coding and write a minimal microservice with Rust.</p>
<p>In the next chapter we will start to writing microservices with Rust using <kbd>hyper</kbd> crate that provides all necessary features to write compact asynchronous HTTP server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>You have learned about the basics of microservices in this chapter, which will serve as a point for you to start writing microservices on Rust throughout this book. If you want to learn more about topics discussed in this chapter, please consult the following list:</p>
<ul>
<li><em>Microservices - a definition of this new architectural term</em>, 2014, Martin Fowler, available at <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>. This article introduces the concept of microservices.</li>
<li><kbd>mio</kbd>, available at <a href="https://github.com/carllerche/mio">https://github.com/carllerche/mio</a>. This is a crate that is widely used by other crates for asynchronous operations in Rust. We won't use it directly, but it is useful to know how it works.</li>
<li><em>Network Programming with Rust</em>, <em>2018</em>, Abhishek Chanda, available at <a href="https://www.packtpub.com/application-development/network-programming-rust">https://www.packtpub.com/application-development/network-programming-rust</a>. This book explains more about network addresses, protocols and sockets, and how to use them all with Rust.</li>
</ul>


            

            
        
    </body></html>