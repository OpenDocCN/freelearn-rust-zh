["```rs\nuse libc::c_int;\n\n#[link(name = \"motor1\")]\nextern {\n   pub fn motor1_adjust_motor(target_force: c_int) -> c_int;\n}\n\n#[link(name = \"motor2\")]\nextern {\n   pub fn motor2_adjust_motor(target_force: c_int) -> c_int;\n}\n\n#[link(name = \"motor3\")]\nextern {\n   pub fn motor3_adjust_motor(target_force: c_int) -> c_int;\n}\n```", "```rs\n#[derive(Clone,Serialize,Deserialize,Debug)]\npub enum MotorInput\n{\n   Motor1 { target_force: f64 },\n   Motor2 { target_force: f64 },\n   Motor3 { target_force: f64 },\n}\n\npub trait MotorDriver\n{\n   fn adjust_motor(&self, input: MotorInput);\n}\n\nstruct Motor1;\nimpl MotorDriver for Motor1 { ... }\n\n//Motor 2\n\n//Motor 3\n```", "```rs\npub trait MotorController\n{\n   fn adjust_motor(&self, f: f64);\n   fn max_force(&self) -> f64;\n}\n\npub struct MotorController1\n{\n   motor: Motor1\n}\n\nimpl MotorController for MotorController1 { ... }\n\n//Motor Controller 2 ...\n\n//Motor Controller 3 ...\n```", "```rs\npub trait Building\n{\n   fn get_elevator_driver(&self) -> Box<ElevatorDriver>;\n   fn get_motor_controller(&self) -> Box<MotorController>;\n   fn get_floor_heights(&self) -> Vec<f64>;\n   fn get_carriage_weight(&self) -> f64;\n   fn clone(&self) -> Box<Building>;\n   fn serialize(&self) -> u64;\n}\n```", "```rs\npub fn deserialize(n: u64) -> Box<Building>\n{\n   if n==1 {\n      Box::new(Building1)\n   } else if n==2 {\n      Box::new(Building2)\n   } else {\n      Box::new(Building3)\n   }\n}\n```", "```rs\npub fn getCarriageFloor(floorHeights: Vec<f64>, height: f64) -> u64\n{\n   let mut c = 0.0;\n   for (fi, fht) in floorHeights.iter().enumerate() {\n      c += fht;\n      if height <= c {\n         return (fi as u64)\n      }\n   }\n   (floorHeights.len()-1) as u64\n}\n\npub fn getCumulativeFloorHeight(heights: Vec<f64>, floor: u64) -> f64\n{\n   heights.iter().take(floor as usize).sum()\n}\n```", "```rs\npub struct Building1;\nimpl Building for Building1 { ... }\n\n//Building 2\n\n//Building 3\n```", "```rs\npub trait MotionController\n{\n   fn init(&mut self, esp: Box<Building>, est: ElevatorState);\n   fn adjust(&mut self, est: &ElevatorState, dst: u64) -> f64;\n}\n\npub struct SmoothMotionController\n{\n   pub esp: Box<Building>,\n   pub timestamp: f64\n}\n\nimpl MotionController for SmoothMotionController\n{\n   ...\n}\n```", "```rs\nuse std::collections::VecDeque;\n\npub struct FloorRequests\n{\n   pub requests: VecDeque<u64>\n}\n\npub trait RequestQueue\n{\n   fn add_request(&mut self, req: u64);\n   fn add_requests(&mut self, reqs: &Vec<u64>);\n   fn pop_request(&mut self) -> Option<u64>;\n}\n\nimpl RequestQueue for FloorRequests\n{\n   fn add_request(&mut self, req: u64)\n   {\n      self.requests.push_back(req);\n   }\n   fn add_requests(&mut self, reqs: &Vec<u64>)\n   {\n      for req in reqs\n      {\n         self.requests.push_back(*req);\n      }\n   }\n   fn pop_request(&mut self) -> Option<u64>\n   {\n      self.requests.pop_front()\n   }\n}\n```", "```rs\nuse libc::c_int;\n\n#[link(name = \"elevator1\")]\nextern {\n   pub fn elevator1_poll_floor_request() -> c_int;\n}\n\n#[link(name = \"elevator2\")]\nextern {\n   pub fn elevator2_poll_floor_request() -> c_int;\n}\n\n#[link(name = \"elevator3\")]\nextern {\n   pub fn elevator3_poll_floor_request() -> c_int;\n}\n\npub trait ElevatorDriver\n{\n   fn poll_floor_request(&self) -> Option<u64>;\n}\n\npub struct ElevatorDriver1;\nimpl ElevatorDriver for ElevatorDriver1\n{\n   fn poll_floor_request(&self) -> Option<u64>\n   {\n      unsafe {\n         let req = elevator1_poll_floor_request();\n         if req > 0 {\n            Some(req as u64)\n         } else {\n            None\n         }\n      }\n   }\n}\n\n//Elevator Driver 2\n\n//Elevator Driver 3\n```", "```rs\n#[derive(Clone,Debug,Serialize,Deserialize)]\npub struct ElevatorState {\n   pub timestamp: f64,\n   pub location: f64,\n   pub velocity: f64,\n   pub acceleration: f64,\n   pub motor_input: f64\n}\n\npub const MAX_JERK: f64 = 0.2;\npub const MAX_ACCELERATION: f64 = 2.0;\npub const MAX_VELOCITY: f64 = 5.0;\n\npub fn simulate_elevator(esp: Box<Building>, est: ElevatorState, floor_requests: &mut Box<RequestQueue>,\n                         mc: &mut Box<MotionController>, dr: &mut Box<DataRecorder>)\n{\n   //immutable input becomes mutable local state\n   let mut esp = esp.clone();\n   let mut est = est.clone();\n\n   //initialize MotorController and DataController\n   mc.init(esp.clone(), est.clone());\n   dr.init(esp.clone(), est.clone());\n\n   //5\\. Loop while there are remaining floor requests\n   let original_ts = Instant::now();\n   thread::sleep(time::Duration::from_millis(1));\n   let mut next_floor = floor_requests.pop_request();\n   while let Some(dst) = next_floor\n   {\n      //5.1\\. Update location, velocity, and acceleration\n      let now = Instant::now();\n      let ts = now.duration_since(original_ts)\n                  .as_fractional_secs();\n      let dt = ts - est.timestamp;\n      est.timestamp = ts;\n\n      est.location = est.location + est.velocity * dt;\n      est.velocity = est.velocity + est.acceleration * dt;\n      est.acceleration = {\n         let F = est.motor_input;\n         let m = esp.get_carriage_weight();\n         -9.8 + F/m\n      };\n\n      //5.2\\. If next floor request in queue is satisfied, then remove from queue\n      if (est.location - getCumulativeFloorHeight(esp.get_floor_heights(), dst)).abs() < 0.01 &&\n         est.velocity.abs() < 0.01\n      {\n         est.velocity = 0.0;\n         next_floor = floor_requests.pop_request();\n      }\n\n      //5.4\\. Print realtime statistics\n      dr.poll(est.clone(), dst);\n\n      //5.3\\. Adjust motor control to process next floor request\n      est.motor_input = mc.poll(est.clone(), dst);\n\n      thread::sleep(time::Duration::from_millis(1));\n   }\n}\n```", "```rs\npub trait DataRecorder\n{\n   fn init(&mut self, esp: Box<Building>, est: ElevatorState);\n   fn record(&mut self, est: ElevatorState, dst: u64);\n   fn summary(&mut self);\n}\n\n```", "```rs\nstruct SimpleDataRecorder<W: Write>\n{\n   esp: Box<Building>,\n   termwidth: u64,\n   termheight: u64,\n   stdout: raw::RawTerminal<W>,\n   log: File,\n   record_location: Vec<f64>,\n   record_velocity: Vec<f64>,\n   record_acceleration: Vec<f64>,\n   record_force: Vec<f64>,\n}\n```", "```rs\npub fn newSimpleDataRecorder(esp: Box<Building>) -> Box<DataRecorder>\n{\n   let termsize = termion::terminal_size().ok();\n   Box::new(SimpleDataRecorder {\n      esp: esp.clone(),\n      termwidth: termsize.map(|(w,_)| w-2).expect(\"termwidth\") as u64,\n      termheight: termsize.map(|(_,h)| h-2).expect(\"termheight\") as u64,\n      stdout: io::stdout().into_raw_mode().unwrap(),\n      log: File::create(\"simulation.log\").expect(\"log file\"),\n      record_location: Vec::new(),\n      record_velocity: Vec::new(),\n      record_acceleration: Vec::new(),\n      record_force: Vec::new()\n   })\n}\n```", "```rs\nimpl<W: Write> DataRecorder for SimpleDataRecorder<W>\n{\n   fn init(&mut self, esp: Box<Building>, est: ElevatorState)\n   {\n      ...\n   }\n   fn record(&mut self, est: ElevatorState, dst: u64)\n      ...\n   }\n   fn summary(&mut self)\n   {\n      ...\n   }\n}\n```", "```rs\nfn variable_summary<W: Write>(stdout: &mut raw::RawTerminal<W>, vname: String, data: &Vec<f64>) {\n   let (avg, dev) = variable_summary_stats(data);\n   variable_summary_print(stdout, vname, avg, dev);\n}\n\nfn variable_summary_stats(data: &Vec<f64>) -> (f64, f64)\n{\n   //calculate statistics\n   let N = data.len();\n   let sum = data.iter().sum::<f64>();\n   let avg = sum / (N as f64);\n   let dev = (\n       data.clone().into_iter()\n       .map(|v| (v - avg).powi(2))\n       .sum::<f64>()\n       / (N as f64)\n   ).sqrt();\n   (avg, dev)\n}\n\nfn variable_summary_print<W: Write>(stdout: &mut raw::RawTerminal<W>, vname: String, avg: f64, dev: f64)\n{\n   //print formatted output\n   writeln!(stdout, \"Average of {:25}{:.6}\", vname, avg);\n   writeln!(stdout, \"Standard deviation of {:14}{:.6}\", vname, dev);\n   writeln!(stdout, \"\");\n}\n```", "```rs\n//1\\. Store location, velocity, and acceleration state\n//2\\. Store motor input target force\nlet mut est = ElevatorState {\n   timestamp: 0.0,\n   location: 0.0,\n   velocity: 0.0,\n   acceleration: 0.0,\n   motor_input: 0.0\n};\n```", "```rs\n//3\\. Store input building description and floor requests\nlet mut esp: Box<Building> = Box::new(Building1);\nlet mut floor_requests: Box<RequestQueue> = Box::new(FloorRequests {\n   requests: Vec::new()\n});\n```", "```rs\n//4\\. Parse input and store as building description and floor requests\nmatch env::args().nth(1) {\n   Some(ref fp) if *fp == \"-\".to_string()  => {\n      ...\n   },\n   None => {\n      ...\n   },\n   Some(fp) => {\n      ...\n   }\n}\n```", "```rs\nlet mut dr: Box<DataRecorder> = newSimpleDataRecorder(esp.clone());\nlet mut mc: Box<MotionController> = Box::new(SmoothMotionController {\n  timestamp: 0.0,\n  esp: esp.clone()\n});\n```", "```rs\nsimulate_elevator(esp, est, &mut floor_requests, &mut mc, &mut dr);\n```", "```rs\ndr.summary();\n```", "```rs\n#[derive(Clone)]\nstruct Trip {\n   dst: u64,\n   up: f64,\n   down: f64\n}\n```", "```rs\nlet simlog = File::open(\"simulation.log\").expect(\"read simulation log\");\nlet mut simlog = BufReader::new(&simlog);\nlet mut jerk = 0.0;\nlet mut prev_est: Option<ElevatorState> = None;\nlet mut dst_timing: Vec<Trip> = Vec::new();\nlet mut start_location = 0.0;\n```", "```rs\nlet mut first_line = String::new();\nlet len = simlog.read_line(&mut first_line).unwrap();\nlet spec: u64 = serde_json::from_str(&first_line).unwrap();\nlet esp: Box<Building> = buildings::deserialize(spec);\n\nfor line in simlog.lines() {\n   let l = line.unwrap();\n   //Check elevator state records\n}\n```", "```rs\nlet (est, dst): (ElevatorState,u64) = serde_json::from_str(&l).unwrap();\nlet dl = dst_timing.len();\nif dst_timing.len()==0 || dst_timing[dl-1].dst != dst {\n   dst_timing.push(Trip { dst:dst, up:0.0, down:0.0 });\n}\n\nif let Some(prev_est) = prev_est {\n   let dt = est.timestamp - prev_est.timestamp;\n   if est.velocity > 0.0 {\n      dst_timing[dl-1].up += dt;\n   } else {\n      dst_timing[dl-1].down += dt;\n   }\n   let da = (est.acceleration - prev_est.acceleration).abs();\n   jerk = (jerk * (1.0 - dt)) + (da * dt);\n   if jerk.abs() > 0.22 {\n      panic!(\"jerk is outside of acceptable limits: {} {:?}\", jerk, est)\n   }\n} else {\n   start_location = est.location;\n}\n\nif est.acceleration.abs() > 2.2 {\n   panic!(\"acceleration is outside of acceptable limits: {:?}\", est)\n}\n\nif est.velocity.abs() > 5.5 {\n   panic!(\"velocity is outside of acceptable limits: {:?}\", est)\n}\n\nprev_est = Some(est);\n```", "```rs\n//elevator should not backup\nlet mut total_time = 0.0;\nlet mut total_direct = 0.0;\nfor trip in dst_timing.clone()\n{\n   total_time += (trip.up + trip.down);\n   if trip.up > trip.down {\n      total_direct += trip.up;\n   } else {\n      total_direct += trip.down;\n   }\n}\n\nif (total_direct / total_time) < 0.9 {\n   panic!(\"elevator back up is too common: {}\", total_direct / total_time)\n}\n```", "```rs\nlet mut trip_start_location = start_location;\nlet mut theoretical_time = 0.0;\nlet floor_heights = esp.get_floor_heights();\nfor trip in dst_timing.clone()\n{\n   let next_floor = getCumulativeFloorHeight(floor_heights.clone(), trip.dst);\n   let d = (trip_start_location - next_floor).abs();\n   theoretical_time += (\n      2.0*(MAX_ACCELERATION / MAX_JERK) +\n      2.0*(MAX_JERK / MAX_ACCELERATION) +\n      d / MAX_VELOCITY\n   );\n   trip_start_location = next_floor;\n}\n\nif total_time > (theoretical_time * 1.2) {\n   panic!(\"elevator moves to slow {} {}\", total_time, theoretical_time * 1.2)\n}\n```", "```rs\n//1\\. Store location, velocity, and acceleration state\n//2\\. Store motor input target force\nlet mut est = ElevatorState {\n   timestamp: 0.0,\n   location: 0.0,\n   velocity: 0.0,\n   acceleration: 0.0,\n   motor_input: 0.0\n};\n```", "```rs\nlet mut mc: Box<MotionController> = Box::new(SmoothMotionController {\n   timestamp: 0.0,\n   esp: esp.clone()\n});\nmc.init(esp.clone(), est.clone());\n```", "```rs\n//5\\. Loop continuously checking for new floor requests\nlet original_ts = Instant::now();\nthread::sleep(time::Duration::from_millis(1));\nlet mut next_floor = floor_requests.pop_request();\nwhile true\n{\n   if let Some(dst) = next_floor {\n      //process floor request\n   }\n```", "```rs\n\n   //check for dynamic floor requests\n   if let Some(dst) = esp.get_elevator_driver().poll_floor_request()\n   {\n      floor_requests.add_request(dst);\n   }\n}\n```", "```rs\n//5.1\\. Update location, velocity, and acceleration\nlet now = Instant::now();\nlet ts = now.duration_since(original_ts)\n            .as_fractional_secs();\nlet dt = ts - est.timestamp;\nest.timestamp = ts;\n\nest.location = est.location + est.velocity * dt;\nest.velocity = est.velocity + est.acceleration * dt;\nest.acceleration = {\n   let F = est.motor_input;\n   let m = esp.get_carriage_weight();\n   -9.8 + F/m\n};\n```", "```rs\n//5.2\\. If next floor request in queue is satisfied, then remove from queue\nif (est.location - getCumulativeFloorHeight(esp.get_floor_heights(), dst)).abs() < 0.01 && est.velocity.abs() < 0.01\n{\n   est.velocity = 0.0;\n   next_floor = floor_requests.pop_request();\n}\n```", "```rs\n//5.3\\. Adjust motor control to process next floor request\nest.motor_input = mc.poll(est.clone(), dst);\n\n//Adjust motor\nesp.get_motor_controller().adjust_motor(est.motor_input);\n```"]