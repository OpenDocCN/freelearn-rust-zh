["```rs\nfn do_send(tx: mpsc::Sender<Msg>) -> impl Future<Item = (), Error = ()> {\n    future::lazy(|| {\n      tx.send(Msg::Event).wait(); // The program will be blocked here\n    })\n}\n```", "```rs\nstruct WorkerRequest {\n    buffer: Vec<u8>,\n    width: u16,\n    height: u16,\n    tx: oneshot::Sender<WorkerResponse>,\n}\n```", "```rs\ntype WorkerResponse = Result<Vec<u8>, Error>;\n```", "```rs\nfn start_worker() -> mpsc::Sender<WorkerRequest> {\n    let (tx, rx) = mpsc::channel::<WorkerRequest>(1);\n    thread::spawn(move || {\n        let requests = rx.wait();\n        for req in requests {\n            if let Ok(req) = req {\n                let resp = convert(req.buffer, req.width, req.height).map_err(other);\n                req.tx.send(resp).ok();\n            }\n        }\n    });\n    tx\n}\n```", "```rs\nfn convert(data: Vec<u8>, width: u16, height: u16) -> ImageResult<Vec<u8>> {\n    let format = image::guess_format(&data)?;\n    let img = image::load_from_memory(&data)?;\n    let scaled = img.resize(width as u32, height as u32, FilterType::Lanczos3);\n    let mut result = Vec::new();\n    scaled.write_to(&mut result, format)?;\n    Ok(result)\n}\n```", "```rs\nfn main() {\n    let addr = ([127, 0, 0, 1], 8080).into();\n    let builder = Server::bind(&addr);\n    let tx = start_worker();\n    let server = builder.serve(move || {\n        let tx = tx.clone();\n        service_fn(move |req| microservice_handler(tx.clone(), req))\n    });\n    let server = server.map_err(drop);\n    hyper::rt::run(server);\n}\n```", "```rs\nfn microservice_handler(tx: mpsc::Sender<WorkerRequest>, req: Request<Body>)\n    -> Box<Future<Item=Response<Body>, Error=Error> + Send>\n{\n    match (req.method(), req.uri().path().to_owned().as_ref()) {\n        (&Method::GET, \"/\") => {\n            Box::new(future::ok(Response::new(INDEX.into())))\n        },\n        (&Method::POST, \"/resize\") => {\n            let (width, height) = {\n                // Extracting parameters here\n            };\n            let body = ; // It's a Future for generating a body of the Response\n            Box::new(body)\n        },\n        _ => {\n            response_with_code(StatusCode::NOT_FOUND)\n        },\n    }\n}\n```", "```rs\nlet (width, height) = {\n    let uri = req.uri().query().unwrap_or(\"\");\n    let query = queryst::parse(uri).unwrap_or(Value::Null);\n    let w = to_number(&query[\"width\"], 180);\n    let h = to_number(&query[\"height\"], 180);\n    (w, h)\n};\n```", "```rs\nfn to_number(value: &Value, default: u16) -> u16 {\n    value.as_str()\n        .and_then(|x| x.parse::<u16>().ok())\n        .unwrap_or(default)\n}\n```", "```rs\nlet body = req.into_body()\n    .map_err(other)\n    .concat2()\n    .map(|chunk| chunk.to_vec())\n    .and_then(move |buffer| {\n        let (resp_tx, resp_rx) = oneshot::channel();\n        let resp_rx = resp_rx.map_err(other);\n        let request = WorkerRequest { buffer, width, height, tx: resp_tx };\n        tx.send(request)\n            .map_err(other)\n            .and_then(move |_| resp_rx)\n            .and_then(|x| x)\n    })\n    .map(|resp|  Response::new(resp.into()));\n```", "```rs\ncurl --request POST \\\n --data-binary \"@../../media/image.jpg\" \\\n --output \"files/resized.jpg\" \\\n \"http://localhost:8080/resize?width=100&height=100\"\n```", "```rs\nfutures-cpupool = \"0.1\"\n```", "```rs\nuse futures_cpupool::CpuPool;\n```", "```rs\nfn main() {\n    let addr = ([127, 0, 0, 1], 8080).into();\n    let pool = CpuPool::new(4);\n    let builder = Server::bind(&addr);\n    let server = builder.serve(move || {\n        let pool = pool.clone();\n        service_fn(move |req| microservice_handler(pool.clone(), req))\n    });\n    let server = server.map_err(drop);\n    hyper::rt::run(server);\n}\n```", "```rs\nfn microservice_handler(pool: CpuPool, req: Request<Body>)\n     -> Box<Future<Item=Response<Body>, Error=Error> + Send>\n```", "```rs\nlet body = req.into_body()\n    .map_err(other)\n    .concat2()\n    .map(|chunk| chunk.to_vec())\n    .and_then(move |buffer| {\n        let task = future::lazy(move || convert(&buffer, width, height));\n        pool.spawn(task).map_err(other)\n    })\n    .map(|resp| Response::new(resp.into()));\n```", "```rs\npub fn blocking<F, T>(f: F) -> Poll<T, BlockingError> where F: FnOnce() -> T \n```", "```rs\nfn main() {\n    let addr = ([127, 0, 0, 1], 8080).into();\n    let builder = Server::bind(&addr);\n    let server = builder.serve(|| service_fn(|req| microservice_handler(req)));\n    let server = server.map_err(drop);\n    hyper::rt::run(server);\n}\n```", "```rs\nlet body = req.into_body()\n    .map_err(other)\n    .concat2()\n    .map(|chunk| chunk.to_vec())\n        .and_then(move |buffer| {\n            future::poll_fn(move || {\n                let buffer = &buffer;\n                blocking(move || {\n                    convert(buffer, width, height).unwrap()\n                })\n            })\n            .map_err(other)\n        })\n        .map(|resp| Response::new(resp.into()));\n```", "```rs\nimpl Write for File {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        ::would_block(|| self.std().write(buf))\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        ::would_block(|| self.std().flush())\n    }\n}\n```", "```rs\nfn would_block<F, T>(f: F) -> io::Result<T>\nwhere F: FnOnce() -> io::Result<T>,\n{\n    match tokio_threadpool::blocking(f) {\n        Ok(Ready(Ok(v))) => Ok(v),\n        Ok(Ready(Err(err))) => {\n            debug_assert_ne!(err.kind(), WouldBlock);\n            Err(err)\n        }\n        Ok(NotReady) => Err(WouldBlock.into()),\n        Err(_) => Err(blocking_err()),\n    }\n}\n```", "```rs\nactix = \"0.7\"\nfailure = \"0.1\"\nsyslog = \"4.0\"\n```", "```rs\nuse actix::{Actor, Context, Handler, Message};\nuse std::collections::HashMap;\n\ntype Value = u64;\n```", "```rs\npub struct CountActor {\n    counter: HashMap<String, Value>,\n}\n\nimpl CountActor {\n    pub fn new() -> Self {\n        Self {\n            counter: HashMap::new(),\n        }\n    }\n}\n```", "```rs\nimpl Actor for CountActor {\n    type Context = Context<Self>;\n}\n```", "```rs\npub struct Count(pub String);\n\nimpl Message for Count {\n    type Result = Value;\n}\n```", "```rs\nimpl Handler<Count> for CountActor {\n    type Result = Value;\n\n    fn handle(&mut self, Count(path): Count, _: &mut Context<Self>) -> Self::Result {\n        let value = self.counter.entry(path).or_default();\n        *value = *value + 1;\n        *value\n    }\n}\n```", "```rs\nuse actix::{Actor, Context, Handler, Message};\nuse syslog::{Facility, Formatter3164, Logger, LoggerBackend};\n```", "```rs\npub struct LogActor {\n    writer: Logger<LoggerBackend, String, Formatter3164>,\n}\n```", "```rs\nimpl LogActor {\n     pub fn new() -> Self {\n         let formatter = Formatter3164 {\n             facility: Facility::LOG_USER,\n             hostname: None,\n             process: \"rust-microservice\".into(),\n             pid: 0,\n         };\n         let writer = syslog::unix(formatter).unwrap();\n         Self {\n             writer,\n         }\n     }\n }\n```", "```rs\nimpl Actor for LogActor {\n    type Context = Context<Self>;\n}\n```", "```rs\npub struct Log(pub String);\n\nimpl Message for Log {\n    type Result = ();\n}\n```", "```rs\nimpl Handler<Log> for LogActor {\n     type Result = ();\n\n     fn handle(&mut self, Log(mesg): Log, _: &mut Context<Self>) -> Self::Result {\n         self.writer.info(mesg).ok();\n     }\n }\n```", "```rs\nuse actix::{Actor, Handler, Message, SyncContext};\nuse image::{ImageResult, FilterType};\n\ntype Buffer = Vec<u8>;\n```", "```rs\npub struct ResizeActor;\n\nimpl Actor for ResizeActor {\n    type Context = SyncContext<Self>;\n}\n```", "```rs\npub struct Resize {\n    pub buffer: Buffer,\n    pub width: u16,\n    pub height: u16,\n}\n\nimpl Message for Resize {\n    type Result = ImageResult<Buffer>;\n}\n```", "```rs\nimpl Handler<Resize> for ResizeActor {\n     type Result = ImageResult<Buffer>;\n\n     fn handle(&mut self, data: Resize, _: &mut SyncContext<Self>) -> Self::Result {\n         let format = image::guess_format(&data.buffer)?;\n         let img = image::load_from_memory(&data.buffer)?;\n         let scaled = img.resize(data.width as u32, data.height as u32, FilterType::Lanczos3);\n         let mut result = Vec::new();\n         scaled.write_to(&mut result, format)?;\n         Ok(result)\n     }\n }\n```", "```rs\npub mod count;\npub mod log;\npub mod resize;\n```", "```rs\nuse actix::{Actor, Addr};\nuse actix::sync::SyncArbiter;\n```", "```rs\nmod actors;\n\nuse self::actors::{\n    count::{Count, CountActor},\n    log::{Log, LogActor},\n    resize::{Resize, ResizeActor},\n};\n```", "```rs\n#[derive(Clone)]\nstruct State {\n    resize: Addr<ResizeActor>,\n    count: Addr<CountActor>,\n    log: Addr<LogActor>,\n}\n```", "```rs\nfn main() {\n    actix::run(|| {\n        let resize = SyncArbiter::start(2, || ResizeActor);\n        let count = CountActor::new().start();\n        let log = LogActor::new().start();\n\n        let state = State { resize, count, log };\n\n        let addr = ([127, 0, 0, 1], 8080).into();\n        let builder = Server::bind(&addr);\n        let server = builder.serve(move || {\n            let state = state.clone();\n            service_fn(move |req| microservice_handler(&state, req))\n        });\n        server.map_err(drop)\n    });\n}\n```", "```rs\nfn count_up(state: &State, path: &str) -> impl Future<Item=(), Error=Error> {\n    let path = path.to_string();\n    let log = state.log.clone();\n    state.count.send(Count(path.clone()))\n        .and_then(move |value| {\n            let message = format!(\"total requests for '{}' is {}\", path, value);\n            log.send(Log(message))\n        })\n        .map_err(|err| other(err.compat()))\n}\n```", "```rs\nfn microservice_handler(state: &State, req: Request<Body>)\n    -> Box<Future<Item=Response<Body>, Error=Error> + Send>\n{\n    match (req.method(), req.uri().path().to_owned().as_ref()) {\n        (&Method::GET, \"/\") => {\n            let fut = count_up(state, \"/\").map(|_| Response::new(INDEX.into()));\n            Box::new(fut)\n        },\n        (&Method::POST, \"/resize\") => {\n            let (width, height) = {\n                let uri = req.uri().query().unwrap_or(\"\");\n                let query = queryst::parse(uri).unwrap_or(Value::Null);\n                let w = to_number(&query[\"width\"], 180);\n                let h = to_number(&query[\"height\"], 180);\n                (w, h)\n            };\n            // Add an implementation here\n            Box::new(fut)\n        },\n        _ => {\n            response_with_code(StatusCode::NOT_FOUND)\n        },\n    }\n}\n```", "```rs\nlet resize = state.resize.clone();\nlet body = req.into_body()\n    .map_err(other)\n    .concat2()\n    .map(|chunk| {\n        chunk.to_vec()\n    })\n    .and_then(move |buffer| {\n        let msg = Resize {\n            buffer,\n            width,\n            height,\n        };\n        resize.send(msg)\n            .map_err(|err| other(err.compat()))\n            .and_then(|x| x.map_err(other))\n    })\n    .map(|resp| {\n        Response::new(resp.into())\n    });\nlet fut = count_up(state, \"/resize\").and_then(move |_| body);\n```", "```rs\njournalctl\n```", "```rs\nJan 11 19:48:53 localhost.localdomain rust-microservice[21466]: total requests for '/' = 1\nJan 11 19:48:55 localhost.localdomain rust-microservice[21466]: total requests for '/' = 2\nJan 11 19:48:55 localhost.localdomain rust-microservice[21466]: total requests for '/' = 3\nJan 11 19:48:56 localhost.localdomain rust-microservice[21466]: total requests for '/' = 4\nJan 11 19:48:56 localhost.localdomain rust-microservice[21466]: total requests for '/' = 5\nJan 11 19:49:16 localhost.localdomain rust-microservice[21466]: total requests for '/resize' = 1\n```"]