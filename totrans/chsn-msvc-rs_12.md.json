["```rs\ndocker run -it --rm --name test-rabbit -p 5672:5672 rabbitmq:3\n```", "```rs\ndocker exec -it test-rabbit rabbitmqctl\n```", "```rs\ndocker exec -it test-rabbit rabbitmqctl trace_on\n```", "```rs\ndocker exec -it test-rabbit rabbitmqctl list_exchanges\n```", "```rs\nListing exchanges for vhost / ...\namq.headers    headers\namq.direct    direct\namq.topic    topic\namq.rabbitmq.trace    topic\n    direct\namq.fanout    fanout\namq.match    headers\n```", "```rs\n[package]\nname = \"rabbit-actix\"\nversion = \"0.1.0\"\nedition = \"2018\"\n```", "```rs\n[dependencies]\nactix = \"0.7\"\nactix-web = \"0.7\"\naskama = \"0.7\"\nchrono = \"0.4\"\nenv_logger = \"0.6\"\nimage = \"0.21\"\nindexmap = \"1.0\"\nfailure = \"0.1\"\nfutures = \"0.1\"\nlog = \"0.4\"\nqueens-rock = \"0.1\"\nrmp-serde = \"0.13\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\ntokio = \"0.1\"\nuuid = \"0.7\"\n```", "```rs\n[dependencies.lapin]\nversion = \"0.15\"\npackage = \"lapin-futures\"\n```", "```rs\n[[bin]]\nname = \"rabbit-actix-server\"\npath = \"src/server.rs\"\ntest = false\n```", "```rs\n[[bin]]\nname = \"rabbit-actix-worker\"\npath = \"src/worker.rs\"\ntest = false\n```", "```rs\n[build-dependencies]\naskama = \"0.7\"\n```", "```rs\nfn main() {\n    askama::rerun_if_templates_changed();\n}\n```", "```rs\nuse super::{ensure_queue, spawn_client};\nuse actix::fut::wrap_future;\nuse actix::{Actor, Addr, AsyncContext, Context, Handler, Message, StreamHandler, SystemRunner};\nuse failure::{format_err, Error};\nuse futures::Future;\nuse lapin::channel::{BasicConsumeOptions, BasicProperties, BasicPublishOptions, Channel};\nuse lapin::error::Error as LapinError;\nuse lapin::message::Delivery;\nuse lapin::types::{FieldTable, ShortString};\nuse log::{debug, warn};\nuse serde::{Deserialize, Serialize};\nuse tokio::net::TcpStream;\nuse uuid::Uuid;\n\npub type TaskId = ShortString;\n```", "```rs\npub trait QueueHandler: 'static {\n     type Incoming: for<'de> Deserialize<'de>;\n     type Outgoing: Serialize;\n\n     fn incoming(&self) -> &str;\n     fn outgoing(&self) -> &str;\n     fn handle(\n         &self,\n         id: &TaskId,\n         incoming: Self::Incoming,\n     ) -> Result<Option<Self::Outgoing>, Error>;\n }\n```", "```rs\npub struct QueueActor<T: QueueHandler> {\n     channel: Channel<TcpStream>,\n     handler: T,\n }\n```", "```rs\nimpl<T: QueueHandler> Actor for QueueActor<T> {\n     type Context = Context<Self>;\n\n     fn started(&mut self, _: &mut Self::Context) {}\n }\n```", "```rs\nimpl<T: QueueHandler> QueueActor<T> {\n     pub fn new(handler: T, mut sys: &mut SystemRunner) -> Result<Addr<Self>, Error> {\n         let channel = spawn_client(&mut sys)?;\n         let chan = channel.clone();\n         let fut = ensure_queue(&chan, handler.outgoing());\n         sys.block_on(fut)?;\n         let fut = ensure_queue(&chan, handler.incoming()).and_then(move |queue| {\n             let opts = BasicConsumeOptions {\n                 ..Default::default()\n             };\n             let table = FieldTable::new();\n             let name = format!(\"{}-consumer\", queue.name());\n             chan.basic_consume(&queue, &name, opts, table)\n         });\n         let stream = sys.block_on(fut)?;\n         let addr = QueueActor::create(move |ctx| {\n             ctx.add_stream(stream);\n             Self { channel, handler }\n         });\n         Ok(addr)\n     }\n }\n```", "```rs\nimpl<T: QueueHandler> StreamHandler<Delivery, LapinError> for QueueActor<T> {\n     fn handle(&mut self, item: Delivery, ctx: &mut Context<Self>) {\n         debug!(\"Message received!\");\n         let fut = self\n             .channel\n             .basic_ack(item.delivery_tag, false)\n             .map_err(drop);\n         ctx.spawn(wrap_future(fut));\n         match self.process_message(item, ctx) {\n             Ok(pair) => {\n                 if let Some((corr_id, data)) = pair {\n                     self.send_message(corr_id, data, ctx);\n                 }\n             }\n             Err(err) => {\n                 warn!(\"Message processing error: {}\", err);\n             }\n         }\n     }\n }\n```", "```rs\npub struct SendMessage<T>(pub T);\n```", "```rs\nimpl<T> Message for SendMessage<T> {\n     type Result = TaskId;\n }\n```", "```rs\nimpl<T: QueueHandler> Handler<SendMessage<T::Outgoing>> for QueueActor<T> {\n     type Result = TaskId;\n\n     fn handle(&mut self, msg: SendMessage<T::Outgoing>, ctx: &mut Self::Context) -> Self::Result {\n         let corr_id = Uuid::new_v4().to_simple().to_string();\n         self.send_message(corr_id.clone(), msg.0, ctx);\n         corr_id\n     }\n }\n```", "```rs\nimpl<T: QueueHandler> QueueActor<T> {\n     fn process_message(\n         &self,\n         item: Delivery,\n         _: &mut Context<Self>,\n     ) -> Result<Option<(ShortString, T::Outgoing)>, Error> {\n         let corr_id = item\n             .properties\n             .correlation_id()\n             .to_owned()\n             .ok_or_else(|| format_err!(\"Message has no address for the response\"))?;\n         let incoming = serde_json::from_slice(&item.data)?;\n         let outgoing = self.handler.handle(&corr_id, incoming)?;\n         if let Some(outgoing) = outgoing {\n             Ok(Some((corr_id, outgoing)))\n         } else {\n             Ok(None)\n         }\n     }\n }\n```", "```rs\nimpl<T: QueueHandler> QueueActor<T> {\n     fn send_message(&self, corr_id: ShortString, outgoing: T::Outgoing, ctx: &mut Context<Self>) {\n         let data = serde_json::to_vec(&outgoing);\n         match data {\n             Ok(data) => {\n                 let opts = BasicPublishOptions::default();\n                 let props = BasicProperties::default().with_correlation_id(corr_id);\n                 debug!(\"Sending to: {}\", self.handler.outgoing());\n                 let fut = self\n                     .channel\n                     .basic_publish(\"\", self.handler.outgoing(), data, opts, props)\n                     .map(drop)\n                     .map_err(drop);\n                 ctx.spawn(wrap_future(fut));\n             }\n             Err(err) => {\n                 warn!(\"Can't encode an outgoing message: {}\", err);\n             }\n         }\n     }\n }\n```", "```rs\npub mod queue_actor;\n\nuse actix::{Message, SystemRunner};\nuse failure::Error;\nuse futures::Future;\nuse lapin::channel::{Channel, QueueDeclareOptions};\nuse lapin::client::{Client, ConnectionOptions};\nuse lapin::error::Error as LapinError;\nuse lapin::queue::Queue;\nuse lapin::types::FieldTable;\nuse serde_derive::{Deserialize, Serialize};\nuse tokio::net::TcpStream;\n```", "```rs\npub const REQUESTS: &str = \"requests\";\npub const RESPONSES: &str = \"responses\";\n```", "```rs\npub fn spawn_client(sys: &mut SystemRunner) -> Result<Channel<TcpStream>, Error> {\n    let addr = \"127.0.0.1:5672\".parse().unwrap();\n    let fut = TcpStream::connect(&addr)\n        .map_err(Error::from)\n        .and_then(|stream| {\n            let options = ConnectionOptions::default();\n            Client::connect(stream, options).from_err::<Error>()\n        });\n    let (client, heartbeat) = sys.block_on(fut)?;\n    actix::spawn(heartbeat.map_err(drop));\n    let channel = sys.block_on(client.create_channel())?;\n    Ok(channel)\n}\n```", "```rs\npub fn ensure_queue(\n    chan: &Channel<TcpStream>,\n    name: &str,\n) -> impl Future<Item = Queue, Error = LapinError> {\n    let opts = QueueDeclareOptions {\n        auto_delete: true,\n        ..Default::default()\n    };\n    let table = FieldTable::new();\n    chan.queue_declare(name, opts, table)\n}\n```", "```rs\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct QrRequest {\n    pub image: Vec<u8>,\n}\n```", "```rs\nimpl Message for QrRequest {\n    type Result = ();\n}\n```", "```rs\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub enum QrResponse {\n    Succeed(String),\n    Failed(String),\n}\n```", "```rs\nimpl From<Result<String, Error>> for QrResponse {\n    fn from(res: Result<String, Error>) -> Self {\n        match res {\n            Ok(data) => QrResponse::Succeed(data),\n            Err(err) => QrResponse::Failed(err.to_string()),\n        }\n    }\n}\n```", "```rs\nimpl Message for QrResponse {\n    type Result = ();\n}\n```", "```rs\nuse actix::System;\nuse failure::{format_err, Error};\nuse image::GenericImageView;\nuse log::debug;\nuse queens_rock::Scanner;\nuse rabbit_actix::queue_actor::{QueueActor, QueueHandler, TaskId};\nuse rabbit_actix::{QrRequest, QrResponse, REQUESTS, RESPONSES};\n```", "```rs\nstruct WokerHandler {}\n```", "```rs\nimpl QueueHandler for WokerHandler {\n    type Incoming = QrRequest;\n    type Outgoing = QrResponse;\n\n    fn incoming(&self) -> &str {\n        REQUESTS\n    }\n    fn outgoing(&self) -> &str {\n        RESPONSES\n    }\n    fn handle(\n        &self,\n        _: &TaskId,\n        incoming: Self::Incoming,\n    ) -> Result<Option<Self::Outgoing>, Error> {\n        debug!(\"In: {:?}\", incoming);\n        let outgoing = self.scan(&incoming.image).into();\n        debug!(\"Out: {:?}\", outgoing);\n        Ok(Some(outgoing))\n    }\n}\n```", "```rs\nimpl WokerHandler {\n    fn scan(&self, data: &[u8]) -> Result<String, Error> {\n        let image = image::load_from_memory(data)?;\n        let luma = image.to_luma().into_vec();\n        let scanner = Scanner::new(\n            luma.as_ref(),\n            image.width() as usize,\n            image.height() as usize,\n        );\n        scanner\n            .scan()\n            .extract(0)\n            .ok_or_else(|| format_err!(\"can't extract\"))\n            .and_then(|code| code.decode().map_err(|_| format_err!(\"can't decode\")))\n            .and_then(|data| {\n                data.try_string()\n                    .map_err(|_| format_err!(\"can't convert to a string\"))\n            })\n    }\n}\n```", "```rs\nfn main() -> Result<(), Error> {\n    env_logger::init();\n    let mut sys = System::new(\"rabbit-actix-worker\");\n    let _ = QueueActor::new(WokerHandler {}, &mut sys)?;\n    let _ = sys.run();\n    Ok(())\n}\n```", "```rs\nuse actix::{Addr, System};\nuse actix_web::dev::Payload;\nuse actix_web::error::MultipartError;\nuse actix_web::http::{self, header, StatusCode};\nuse actix_web::multipart::MultipartItem;\nuse actix_web::{\n    middleware, server, App, Error as WebError, HttpMessage, HttpRequest, HttpResponse,\n};\nuse askama::Template;\nuse chrono::{DateTime, Utc};\nuse failure::Error;\nuse futures::{future, Future, Stream};\nuse indexmap::IndexMap;\nuse log::debug;\nuse rabbit_actix::queue_actor::{QueueActor, QueueHandler, SendMessage, TaskId};\nuse rabbit_actix::{QrRequest, QrResponse, REQUESTS, RESPONSES};\nuse std::fmt;\nuse std::sync::{Arc, Mutex};\n```", "```rs\ntype SharedTasks = Arc<Mutex<IndexMap<String, Record>>>;\n```", "```rs\n#[derive(Clone)]\nstruct Record {\n    task_id: TaskId,\n    timestamp: DateTime<Utc>,\n    status: Status,\n}\n```", "```rs\n#[derive(Clone)]\nenum Status {\n    InProgress,\n    Done(QrResponse),\n}\n```", "```rs\nimpl fmt::Display for Status {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Status::InProgress => write!(f, \"in progress\"),\n            Status::Done(resp) => match resp {\n                QrResponse::Succeed(data) => write!(f, \"done: {}\", data),\n                QrResponse::Failed(err) => write!(f, \"failed: {}\", err),\n            },\n        }\n    }\n}\n```", "```rs\n#[derive(Clone)]\nstruct State {\n    tasks: SharedTasks,\n    addr: Addr<QueueActor<ServerHandler>>,\n}\n```", "```rs\nstruct ServerHandler {\n    tasks: SharedTasks,\n}\n```", "```rs\nimpl QueueHandler for ServerHandler {\n    type Incoming = QrResponse;\n    type Outgoing = QrRequest;\n\n    fn incoming(&self) -> &str {\n        RESPONSES\n    }\n    fn outgoing(&self) -> &str {\n        REQUESTS\n    }\n    fn handle(\n        &self,\n        id: &TaskId,\n        incoming: Self::Incoming,\n    ) -> Result<Option<Self::Outgoing>, Error> {\n        self.tasks.lock().unwrap().get_mut(id).map(move |rec| {\n            rec.status = Status::Done(incoming);\n        });\n        Ok(None)\n    }\n}\n```", "```rs\nfn index_handler(_: &HttpRequest<State>) -> HttpResponse {\n    HttpResponse::Ok().body(\"QR Parsing Microservice\")\n}\n```", "```rs\nfn tasks_handler(req: HttpRequest<State>) -> impl Future<Item = HttpResponse, Error = WebError> {\n    let tasks: Vec<_> = req\n        .state()\n        .tasks\n        .lock()\n        .unwrap()\n        .values()\n        .cloned()\n        .collect();\n    let tmpl = Tasks { tasks };\n    future::ok(HttpResponse::Ok().body(tmpl.render().unwrap()))\n}\n```", "```rs\n<table>\n    <thead>\n        <tr>\n            <th>Task ID</th>\n            <th>Timestamp</th>\n            <th>Status</th>\n        </tr>\n    </thead>\n    <tbody>\n        {% for task in tasks %}\n        <tr>\n            <td>{{ task.task_id }}</td>\n            <td>{{ task.timestamp }}</td>\n            <td>{{ task.status }}</td>\n        </tr>\n        {% endfor %}\n    </tbody>\n</table>\n```", "```rs\n#[derive(Template)]\n#[template(path = \"tasks.html\")]\nstruct Tasks {\n    tasks: Vec<Record>,\n}\n```", "```rs\nfn upload_handler(req: HttpRequest<State>) -> impl Future<Item = HttpResponse, Error = WebError> {\n    req.multipart()\n        .map(handle_multipart_item)\n        .flatten()\n        .into_future()\n        .and_then(|(bytes, stream)| {\n            if let Some(bytes) = bytes {\n                Ok(bytes)\n            } else {\n                Err((MultipartError::Incomplete, stream))\n            }\n        })\n        .map_err(|(err, _)| WebError::from(err))\n        .and_then(move |image| {\n            debug!(\"Image: {:?}\", image);\n            let request = QrRequest { image };\n            req.state()\n                .addr\n                .send(SendMessage(request))\n                .from_err()\n                .map(move |task_id| {\n                    let record = Record {\n                        task_id: task_id.clone(),\n                        timestamp: Utc::now(),\n                        status: Status::InProgress,\n                    };\n                    req.state().tasks.lock().unwrap().insert(task_id, record);\n                    req\n                })\n        })\n        .map(|req| {\n            HttpResponse::build_from(&req)\n                .status(StatusCode::FOUND)\n                .header(header::LOCATION, \"/tasks\")\n                .finish()\n        })\n}\n```", "```rs\npub fn handle_multipart_item(\n    item: MultipartItem<Payload>,\n) -> Box<Stream<Item = Vec<u8>, Error = MultipartError>> {\n    match item {\n        MultipartItem::Field(field) => {\n            Box::new(field.concat2().map(|bytes| bytes.to_vec()).into_stream())\n        }\n        MultipartItem::Nested(mp) => Box::new(mp.map(handle_multipart_item).flatten()),\n    }\n}\n```", "```rs\nfn main() -> Result<(), Error> {\n    env_logger::init();\n    let mut sys = System::new(\"rabbit-actix-server\");\n    let tasks = Arc::new(Mutex::new(IndexMap::new()));\n    let addr = QueueActor::new(\n        ServerHandler {\n            tasks: tasks.clone(),\n        },\n        &mut sys,\n    )?;\n\n    let state = State {\n        tasks: tasks.clone(),\n        addr,\n    };\n    server::new(move || {\n        App::with_state(state.clone())\n            .middleware(middleware::Logger::default())\n            .resource(\"/\", |r| r.f(index_handler))\n            .resource(\"/task\", |r| {\n                r.method(http::Method::POST).with_async(upload_handler);\n            })\n            .resource(\"/tasks\", |r| r.method(http::Method::GET).with_async(tasks_handler))\n    })\n    .bind(\"127.0.0.1:8080\")\n    .unwrap()\n    .start();\n\n    let _ = sys.run();\n    Ok(())\n}\n```", "```rs\nRUST_LOG=rabbit_actix_server=debug ./target/debug/rabbit-actix-server\n```", "```rs\nRUST_LOG=rabbit_actix_worker=debug ./target/debug/rabbit-actix-worker\n```", "```rs\ndocker exec -it test-rabbit rabbitmqctl list_queues\n```", "```rs\nTimeout: 60.0 seconds ...\nListing queues for vhost / ...\nresponses    0\nrequests    0\n```", "```rs\ndocker exec -it test-rabbit rabbitmqctl list_consumers\n```", "```rs\nListing consumers on vhost / ...\nresponses  <rabbit@f137a225a709.3.697.0>  responses-consumer   true    0    []\nrequests   <rabbit@f137a225a709.3.717.0>  requests-consumer    true    0    []\n```"]