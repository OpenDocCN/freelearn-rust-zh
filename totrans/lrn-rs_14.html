<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Foreign Function Interfaces</h1>
                
            
            <article>
                
<p class="calibre1">Given that Rust is a language primarily designed to work on servers and most libraries sitting on a server aren't written in Rust (yet!), it makes sense that Rust applications should be able to utilize libraries written in other languages. In this chapter, we will be examining how to do this.</p>
<p class="calibre1">Specifically, we will cover the following:</p>
<ul class="calibre12">
<li class="calibre13">Learning how we can utilize other libraries</li>
<li class="calibre13">Understanding the pitfalls of using code written in another language</li>
<li class="calibre13">Ensuring, as far as is practicable, that our code will remain safe</li>
</ul>
<p class="calibre1">As with previous chapters, the source code will be available for you to examine. You will also find a small library written in C to compile for Windows, macOS, and Linux. The library doesn't do very much but gives you an understanding of how the system works. Other libraries (such as <kbd class="calibre10">ImageMagick</kbd>) work in exactly the same way.</p>
<p class="calibre1">Let's make a start!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing our simple library</h1>
                
            
            <article>
                
<p class="calibre1">Libraries come in three flavors: <kbd class="calibre10">.dll</kbd> (dynamic linkable library) for Windows, <kbd class="calibre10">.so</kbd> (shared object), and <kbd class="calibre10">.a</kbd>—<kbd class="calibre10">.a</kbd> and <kbd class="calibre10">.so</kbd> are typically found on Unix type systems (including macOS).</p>
<p class="calibre1">Our library is very simple; it acts as a calculation library—you pass in the values to the correct function and the result is returned. Not rocket science but enough to prove what we're going to do.</p>
<div class="packt_infobox">When using external libraries, we will need to use the<span class="chapterrefpackt"> </span><kbd class="calibre22">unsafe</kbd><span class="chapterrefpackt"> </span>directive. Rust cannot control what an external library delivers and therefore if we used standard code, the compiler will not allow compilation.<br class="calibre34"/>
<br class="calibre34"/>
<span class="chapterrefpackt">As developers, using external libraries must be handled with care.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The three-step program</h1>
                
            
            <article>
                
<p class="calibre1">There are essentially three steps to using a library within your Rust application:</p>
<ol class="calibre16">
<li value="1" class="calibre13">Including the dependency.</li>
<li value="2" class="calibre13">Writing code that uses the library.</li>
<li value="3" class="calibre13">Building your application to link to the library.</li>
</ol>
<p class="calibre1">The most difficult stage is the second as it requires writing code, call back code, and other such wrappers to use the library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Including the dependency</h1>
                
            
            <article>
                
<p class="calibre1">As with using any library not provided by <kbd class="calibre10">Prelude</kbd>, the compiler has to know of the existence of the library. As we did in <a href="part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3"><span>Chapter 8</span></a>, <em class="calibre9">The Rust Application Lifetime</em>, we let the compiler know to expect an external library by including in the <kbd class="calibre10">Cargo.toml</kbd> file, as follows:</p>
<pre class="calibre21">[dependency] 
libc = "0.2.0" </pre>
<p class="calibre1">The figure in quotes is the library version. This is useful to have in as it enables the compiled Rust application to only run against a particular version of the library, which guarantees the code required will be in the library. The downside is that in order to always ensure the library is available, the compiled binary will need to ship with that library. In this case (and this is the case for most external libraries), <kbd class="calibre10">libc</kbd> will need to be added.</p>
<p class="calibre1">We also need to include the following line to the source file where the functions will be called:</p>
<pre class="calibre21">extern crate libc; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the code</h1>
                
            
            <article>
                
<div class="packt_infobox">The code for this part is in <kbd class="calibre22">Chapter 14/firstexample</kbd>.</div>
<p class="calibre1">When we are dealing with code from outside our application, we need to be able to tell the compiler something akin to "<em class="calibre9">Hey look, build this code and just leave a hook to something that may or may not exist and that may or may not take these parameters but that will return something hopefully.</em>" It's like handing a blank check to a fraudster with your signature on and hoping they won't write something in and cash it!</p>
<p class="calibre1">In Rust, we do this by using the link directive and enclosing the function in an <kbd class="calibre10">extern</kbd> block. The code inside the <kbd class="calibre10">extern</kbd> calls the function held within the library. It must be the same as the name of the function within the library:</p>
<pre class="calibre21">[link(name="mathlib")] 
extern 
 { 
     fn add_two_int_numbers(a: i32, b: i32) -&gt; i32; 
} </pre>
<p class="calibre1">This code is then accessed using the following:</p>
<pre class="calibre21">fn main() 
 { 
    let ans = unsafe { add_two_int_numbers(10,20) }; 
    println!("10 + 20 = {}", ans); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What's the [link(name="")] for?</h1>
                
            
            <article>
                
<p class="calibre1">This is a directive that tells the compiler that the code is going to link to a library called whatever is inside the quotes. You don't need the likes of <kbd class="calibre10">mathlib.dll</kbd>,  <kbd class="calibre10">mathlib.so</kbd>, or  <kbd class="calibre10">mathlib.a</kbd> inside the quotes, just the name without the extension.</p>
<p class="calibre1">There are three different types of link (called models and defined in the <kbd class="calibre10">kind</kbd> parameter following the <span>name</span>) available: <em class="calibre9">dynamic</em>, <em class="calibre9">static,</em> and <em class="calibre9">framework</em> (though the latter is for macOS only). The following table gives a summary of what they are for. For the majority of the time, the <kbd class="calibre10">dynamic</kbd> type is used.</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Type</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Example</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Notes</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1">Dynamic</p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">[link(name="foo")]</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This is the default. The compiled binary creates <em class="calibre9">hooks</em> that will link into the platform installed form of the library.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1">Static</p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">[link(name="foo", kind="static")]</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">These are <kbd class="calibre10">.a</kbd> files. When the application is built, the binary is created, but the platform library file is not required to be distributed.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1">Framework</p>
</td>
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">[link(name="foo", kind="framework")]</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">macOS only. This will be the <kbd class="calibre10">.dylib</kbd> file and is treated the same as a dynamic library.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What's the big deal? That was simple enough!</h1>
                
            
            <article>
                
<p class="calibre1">While on the face of it, using an external library via FFI is not rocket science, it does come with a number of issues. Why do we need to annotate blocks with unsafe even when we are referring to known names in libraries?</p>
<p class="calibre1">As we have seen time and again with Rust, the compiler does an awful lot for the developer that you won't see in many other compilers. It ensures thread safety, that a particular operation can be achieved, the buffers don't overrun, that we don't leave memory unallocated or attempt to deallocate twice, and plenty of other things that ensure that, as far as possible, the code we have will run and remain rock-solid (in terms of reliability).</p>
<p class="calibre1">Unfortunately, with external libraries, all the compiler can do is to expect something from a linked library. Threads may be left hanging or be plain unsafe; there is no guarantee that if I passed in 6 and 0 for a similar division function, what is returned is a number and pretty much anything else can go wrong.</p>
<p class="calibre1">By using <kbd class="calibre10">unsafe</kbd>, we give the compiler a promise that when it links the code, what it links to will be bound correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's extend things a bit</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">extern</kbd> block can include as many (or as few) of the methods required from the library the Rust application is using.</p>
<div class="packt_tip">With each new function added to the <kbd class="calibre22">extern</kbd> block, it is always a good idea to test the function being included. This can be done as either unit tests or by adding the function to the <kbd class="calibre22">extern</kbd> block and then calling that function from within <kbd class="calibre22">main</kbd>.</div>
<p class="calibre1">We can also have multiple Rust source files that include the library functions.</p>
<p class="calibre1">For example, make the changes in the <kbd class="calibre10">Source1.rs</kbd> file:</p>
<pre class="calibre21"><span>//Source1.rs</span><br class="calibre2"/>[link(name="mylib")] 
extern  
{ 
    fn some_method(a: f32) → f32; 
    fn some_other_method(a: i32, b: f32, c: f64) → f64; 
} </pre>
<p class="calibre1">Now, make changes in the <kbd class="calibre10">Source2.rs</kbd> file:</p>
<pre class="calibre21">[link(name="mylib")] 
extern 
 { 
    fn some_other_method(a: i32, b: f32, c: f64) → f64; 
    fn some_text_method() → String; 
} </pre>
<p class="calibre1">As long as the link line is included, this won't cause an issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What happens if the types don't match?</h1>
                
            
            <article>
                
<p class="calibre1">There is no guarantee that when you build a library on a 32-bit platform, an <kbd class="calibre10">int</kbd> will have the same <kbd class="calibre10">size_t</kbd> as an <kbd class="calibre10">int</kbd> on a 64-bit platform. They usually will, but there is no guarantee. A simple example is this:</p>
<pre class="calibre21">sizeof(char) == 1 
sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long) </pre>
<p class="calibre1">Therefore, a short can be the same size as a long! More usually, though, <kbd class="calibre10">int</kbd> will be the platform word size (32 bits on a 32-bit processor, 64 bits on a 64-bit processor).</p>
<p class="calibre1">Values for floats are stricter and comply with the IEEE 754 standards.</p>
<p class="calibre1">There is not normally an issue if the Rust application is built on a 64-bit platform and the library is 32 bits. If it is the other way around, however,there is a chance that an overflow may occur. It is unlikely, but worth keeping in mind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Can we make things safer?</h1>
                
            
            <article>
                
<p class="calibre1">There is a strategy that we can take to try and make things slightly safer.</p>
<p class="calibre1">Consider our original <kbd class="calibre10">extern</kbd> code:</p>
<pre class="calibre21">[link(name="mathlib")] 
extern 
 { 
     fn add_two_int_numbers(a: i32, b: i32) -&gt; i32; 
} </pre>
<p class="calibre1">This code is calling a raw C API and, as discussed, any calls to this have to be marked as being <kbd class="calibre10">unsafe</kbd>. It is unsafe as the call is known as being <strong class="calibre8">low level</strong>.</p>
<p class="calibre1">In terms of programming languages, the lower the language, the closer it is to being a language understood by the processor (an assembler is considered the lowest language that is of any real use, short of poking raw binary into a memory location). Here we are exposing the library at its lowest level.</p>
<p class="calibre1">In order to make the call safer, we use something known as <strong class="calibre8">wrapping</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Wrappers</h1>
                
            
            <article>
                
<p class="calibre1">Wrappers are very common when using a library designed for another language. They work by exposing a higher-level function name that <em class="calibre9">hides</em> the true method working underneath. The exposed function name is commonly known as the library interface API. By only exposing the higher-level function name, Rust is able to keep the unsafe part away from the rest of the world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A practical example</h1>
                
            
            <article>
                
<p class="calibre1">One of the methods in the library takes a vector of <kbd class="calibre10">int</kbd> values to perform a mean, median, and mode calculation, which in turn returns an array of <kbd class="calibre10">float</kbd> values containing these values. However, we need to validate the values first (essentially, test the array is not empty) and that there are five or more values. This will return a boolean.</p>
<p class="calibre1">The unsafe version of the code would be:</p>
<pre class="calibre21">[link(name="mathlib")] 
extern 
 { 
     fn check_mean_mode_median(a: Vec&lt;i32&gt;) -&gt; bool; 
} </pre>
<p class="calibre1">We can create a wrapper for this quite simply:</p>
<pre class="calibre21">pub fn calc_mean_mode_median_check(a:Vec&lt;int32&gt;) -&gt; bool 
 { 
    unsafe 
 { 
        check_mean_mode_median(a) == 0; 
    } 
} </pre>
<p class="calibre1">We expose the safe function to the code and hide (wrap) the unsafe part. Once we have a value of true returned, we know the data is safe to have the calculation.</p>
<p class="calibre1">Now, this is a pretty pointless piece of code (it is simply a test to ensure we have the right number of parameters in the vector). Let's modify this wrapper so that we return a <kbd class="calibre10">Vec&lt;f32&gt;</kbd>, which will  contain <kbd class="calibre10">-999f</kbd>, <kbd class="calibre10">-999f</kbd>, or <kbd class="calibre10">-999f</kbd> if the check fails, or mean, median and mode of the values of the vector.</p>
<p class="calibre1">The issue though is that the original library is in C, so we need to get the results as an array and then put that into a vector.</p>
<p class="calibre1">The first part is making the first check:</p>
<pre class="calibre21">pub fn mean_mode_median(a: Vec&lt;int32&gt;) -&gt; Vec&lt;f32&gt; 
{ 
    // we can have this result outside of the unsafe as it is a guaranteed parameter 
    // it must be mutable as it is used to store the result if the result is returned 
    let mut result = vec![-999f32, -999f32, -999f32]; 
    unsafe 
 { 
        if check_mean_mode_median(a) != 0 
 { 
             return result; 
        } 
 else 
 { 
             let res = calc_mean_median_mode(a); 
              
result = res.to_vec(); 
             return result; 
       
        } 
    } 
} </pre>
<p class="calibre1">Not only do we now have a single call to the external library, but we also have guarantees the compiler needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing global variables</h1>
                
            
            <article>
                
<p class="calibre1">Quite frequently within a C library, there will be global variables that are used for such things as version details and build-specific code. Rust can access these in a similar way to other variables:</p>
<pre class="calibre21">extern crate libc; 
#[link(name = "mathlib")] 
extern { 
    static code_version: libc::c_int; 
} 
fn main() { 
    println!("You have mathlib version {} installed.", code_version as i32); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cleaning up after yourself</h1>
                
            
            <article>
                
<p class="calibre1">While the maths library is a very simple example, there may be times when you need to use a library that passes back a large block of data (such as you would expect if you created a wrapper to work with <kbd class="calibre10">ImageMagick</kbd>—a commonly used and extremely capable graphics library). When the library returns, the results are passed off to the Rust application, which you will need to deallocate manually.</p>
<p class="calibre1">To help you with this, Rust provides the <kbd class="calibre10">Drop</kbd> trait.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Drop it!</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">Drop</kbd> trait is a very simple trait:</p>
<pre class="calibre21">pub trait Drop  
{ 
    fn drop(&amp;mut self); 
} </pre>
<p class="calibre1">As with all traits, it requires an <kbd class="calibre10">impl</kbd> for it before the trait can be used:</p>
<pre class="calibre21">struct FreeMemory; 
impl Drop for FreeMemory 
{ 
     fn drop(&amp;mut self); 
} </pre>
<p class="calibre1">At this point, we call our <kbd class="calibre10">pub fn</kbd>, which returns a data block from <kbd class="calibre10">ImageMagick</kbd>. Once we have done what we need to do with that memory block, we have to free it. We stored the data in a variable called <kbd class="calibre10">graphics_block</kbd>. To free the block from <kbd class="calibre10">graphics_block</kbd>, we use:</p>
<pre class="calibre21">graphics_block  = FreeMemory; </pre>
<p class="calibre1">The memory is freed once <kbd class="calibre10">graphics_block</kbd> goes out of scope.</p>
<div class="packt_infobox"><span class="chapterrefpackt">It is worth pointing out that </span><kbd class="calibre22">panic!</kbd><span class="chapterrefpackt"> will call </span><kbd class="calibre22">drop</kbd><span class="chapterrefpackt"> as it unwinds the memory. If you therefore have a </span><kbd class="calibre22">panic!</kbd><span class="chapterrefpackt"> within a </span><kbd class="calibre22">drop</kbd><span class="chapterrefpackt">, chances are that it is going to abort.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Monitoring an external process within an FFI</h1>
                
            
            <article>
                
<p class="calibre1">During your time using a computer, you will have no doubt seen an image like the following:</p>
<div class="cdpaligncenter"><img class="image-border26" src="../images/00101.jpeg"/></div>
<p class="calibre1">These progress bars work in a similar way to each other. Say you have a process that has five equal sized portions or you're downloading a file from the internet. As the portion completes or an amount of code is downloaded, the bar and percentage are updated using a programming technique known as a <strong class="calibre8">callback</strong>.</p>
<p class="calibre1">How a callback is implemented depends on the language being used. For example, in an event-driven language, the process will either emit a signal or generate an event that the receiver listens for. When the signal/event is received, the user interface is updated.</p>
<p class="calibre1">Rust is no different; it is able to use a callback when using an FFI. Rust is capable of working with both synchronous and asynchronous callbacks. It is also possible to target a callback to a Rust object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Targeting synchronous callbacks</h1>
                
            
            <article>
                
<p class="calibre1">Synchronous callbacks are the simplest to target, as they are normally always on the same thread. Therefore, we don't have to deal with the code being more unsafe than usual, which is normally the case with asynchronous callbacks.</p>
<div class="packt_infobox">The code for this part is in <kbd class="calibre22">Chapter 14/synccallback</kbd>. Instructions for building on Linux, macOS, and Windows are included in the source examples.</div>
<p class="calibre1">Let's deal with the Rust side of the code first. Here, we have three parts:</p>
<ol class="calibre16">
<li value="1" class="calibre13">The function for the callback itself:</li>
</ol>
<pre class="calibre36">extern fn my_callback(percent: i32) 
 { 
     println!("Process is now {}% complete", percent); 
} </pre>
<ol start="2" class="calibre16">
<li value="2" class="calibre13">The calls to the external code:</li>
</ol>
<pre class="calibre36">[link(name="external_lib")] 
extern 
 { 
     fn register_callback(call: extern fn(i32)) -&gt; i32; 
     fn do_callback_trigger(); 
} </pre>
<ol start="3" class="calibre16">
<li value="3" class="calibre13">Fire off the code:</li>
</ol>
<pre class="calibre36">fn main() 
 { 
    unsafe 
 { 
         register_callback(my_callback); 
         do_callback_trigger(); 
    } 
} </pre>
<p class="calibre1"><kbd class="calibre10">register_callback(my_callback)</kbd> and <kbd class="calibre10">fn register_callback(call: extern fn(i32)) -&gt;→ i32;</kbd> may look strange at first glance. In a normal function call, the parameters within the braces are passed into the receiving function, which then does something with them.</p>
<p class="calibre1">Here, we are passing a function as the parameter, which we really can't do (or at least shouldn't). Callbacks though are different, as the function is by virtue of the <kbd class="calibre10">extern</kbd> modifier counted as a pointer that takes the returned value from the external library as its own parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Targeting a Rust object</h1>
                
            
            <article>
                
<p class="calibre1">In the last example, we had a callback that listened for a single <kbd class="calibre10">int</kbd>. What happens though if we want to listen out for a complex object from the external library (for example, a structure)? We can't return a structure, but we can have a Rust object that can be mapped to the callback.</p>
<p class="calibre1">It is a slightly more complex affair than for a synchronous callback:</p>
<ol class="calibre16">
<li value="1" class="calibre13">Create the structure that will map to the external structure we're interested in:</li>
</ol>
<pre class="calibre36">#[repr(C)] // this is a name used within the extern in (2) 
struct MyObject 
 { 
    a: i32, 
    // and anything else you want to get back from the library 
    // just make sure you add them into the call back 
} </pre>
<ol start="2" class="calibre16">
<li value="2" class="calibre13">Create the callback; <kbd class="calibre10">result</kbd> is a pointer to the mutable <kbd class="calibre10">myobject</kbd>:</li>
</ol>
<pre class="calibre36">extern "C" fn callback(result: *mut MyObject, a: i32)  
{ 
     unsafe 
     { 
          (*result).a = a; 
     } 
} </pre>
<ol start="3" class="calibre16">
<li value="3" class="calibre13">Create the <kbd class="calibre10">extern</kbd> functions to the library:</li>
</ol>
<pre class="calibre36">#[link(name="external_lib")] 
extern 
 { 
    fn register_callback(result: mut MyObject, cback: extern fn(mut MyObject, i32)); 
    fn start_callback(); 
} </pre>
<ol start="4" class="calibre16">
<li value="4" class="calibre13">Create the calling code:</li>
</ol>
<pre class="calibre36">fn main() 
 { 
    // we need to create an object for the callback 
    let mystruct = Box::new (MyObject{a: 5i32}); 
    unsafe { 
        register_callback(&amp;mut *mystruct, callback); 
        start_callback(); 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calling Rust from another language</h1>
                
            
            <article>
                
<p class="calibre1">Rust can also be called from a different language and it's a simple process. The only caveat is that the name used has to be unmangled. If you recall from <a href="part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 8</a>, <em class="calibre9">The Rust Application Lifetime</em>, when you use a generic, the compiler generates the necessary code to ensure the linker works. It does this by mangling the names to ensure that the correct code is compiled and called when the code needs it.</p>
<p class="calibre1">Unmangling is the opposite of this; it preserves the name of the function in use:</p>
<pre class="calibre21">#[no_mangle] 
pub extern fn hello_world() -&gt; *const u8 { 
    "Hello, world!\0".as_ptr() 
} </pre>
<p class="calibre1">This can then be called from within your own (non-Rust) application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dealing with the unknown</h1>
                
            
            <article>
                
<p class="calibre1">C developers don't always pass parameters between functions that have <em class="calibre9">strong</em> types; rather, they pass a <kbd class="calibre10">void*</kbd> type. This is then cast to be something solid within the receiving function. In a way, this is very similar to passing a generic type between functions.</p>
<p class="calibre1">These have to be dealt with in a different way if you want to access a function within a library that has a <kbd class="calibre10">void*</kbd> as a parameter type.</p>
<p class="calibre1">For example, the C functions may be:</p>
<pre class="calibre21">void output_data(void *data); 
void transformed_data(void *data); </pre>
<p class="calibre1">As we don't have anything in Rust the same as <kbd class="calibre10">void*</kbd>, we need to use a mutable pointer:</p>
<pre class="calibre21">extern crate libc; 
extern "C" 
 { 
    pub fn output_data(arg: *mut libc::c_void); 
    pub fn transformed_data(arg: *mut libc::c_void); 
} </pre>
<p class="calibre1">This will do the job.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">C structs</h1>
                
            
            <article>
                
<p class="calibre1">Earlier in this chapter, we used a <kbd class="calibre10">struct</kbd> as a parameter. In C, there is nothing to stop the developer passing a structure as a parameter:</p>
<pre class="calibre21">struct MyStruct; 
struct MyOtherStruct; 
void pass_struct(struct MyStruct *arg); 
void pass_struct2(struct MyOtherStruct *arg2); </pre>
<p class="calibre1"><kbd class="calibre10">MyStruct</kbd> and <kbd class="calibre10">MyOtherStruct</kbd> are known as opaque structs. The name is exposed, but the private parts aren't.</p>
<p class="calibre1">Handling a <kbd class="calibre10">struct</kbd> within Rust is not as simple as you'd first think, but then it's not that difficult either. The only difference is that we use an empty <kbd class="calibre10">enum</kbd> instead of a <kbd class="calibre10">struct</kbd> when interfacing with the C library. This creates our opaque type that stores the information from the C opaque type. As the <kbd class="calibre10">enum</kbd> is empty, we can't instantiate it and, more importantly, as <kbd class="calibre10">MyStruct</kbd> and <kbd class="calibre10">MyOtherStruct</kbd> aren't the same, we have type-safety and so can't get them mixed up:</p>
<pre class="calibre21">enum MyStruct {}; 
enum MyOtherStruct {}; 
extern "C" 
{ 
    pub fn pass_struct(arg: *mut MyStruct); 
    pub fn pass_struct2(arg: *mut MyOtherStruct); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1"/>
<p class="calibre1">We have covered something in this chapter that not only makes Rust an excellent choice for developing applications with, but by using libraries that aren't Rust ones, also makes it a flexible and powerful language. There are pitfalls (such as needing to use unsafe and having to be very careful with panic! code), but there are far more advantages than downfalls.</p>
<p class="calibre1">For the purposes of this text, <kbd class="calibre10">.dll</kbd> is purely for Windows. The .NET Framework also uses <kbd class="calibre10">.dll</kbd> files that, if they don't include anything Windows-specific, can also be used on macOS and Linux.</p>


            </article>

            
        </section>
    </body></html>