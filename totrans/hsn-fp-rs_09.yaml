- en: Performance, Debugging, and Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能、调试和元编程
- en: Writing fast efficient code can be something to be proud of. It also might be
    a waste of your employer's resources. In the performance section, we will explore
    how to tell the difference between the two and give best-practices, processes,
    and guidelines to keep your application slim.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写快速高效的代码可以是一件值得骄傲的事情。这也可能浪费你雇主资源。在性能部分，我们将探讨如何区分这两者，并给出最佳实践、流程和指南，以保持你的应用程序精简。
- en: In the debugging section, we offer tips to help find and resolve bugs faster.
    We also introduce the concept of defensive coding, which describes techniques
    and habits to prevent or isolate potential issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试部分，我们提供了一些技巧，帮助您更快地找到和解决错误。我们还介绍了防御性编码的概念，它描述了防止或隔离潜在问题的技术和习惯。
- en: In the metaprogramming section, we explain macros and other features that are
    similar to macros. Rust has a fairly sophisticated metaprogramming system that
    allows the user or libraries to extend the language with automatic code generation
    or custom syntax forms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在元编程部分，我们解释了宏和其他类似宏的功能。Rust有一个相当复杂的元编程系统，允许用户或库通过自动代码生成或自定义语法形式扩展语言。
- en: 'In this chapter, we will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Recognizing and applying good performant code practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和应用良好的性能代码实践
- en: Diagnosing and improving performance bottlenecks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断和改进性能瓶颈
- en: Recognizing and applying good defensive coding practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和应用良好的防御性编码实践
- en: Diagnosing and resolving software bugs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断和解决软件错误
- en: Recognizing and applying metaprogramming techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和应用元编程技术
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要Rust的最近版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is available on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节的`README.md`文件中都包含了具体的安装和构建说明。
- en: Writing faster code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写更快的代码
- en: Premature optimization is the root of all evil
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 过早的优化是万恶之源
- en: – Donald Knuth
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: – 唐纳德·克努特
- en: A good software design tends to create faster programs, while a bad software
    design tends to create slower programs. If you find yourself asking, "W*hy is
    my program slow?, then first ask yourself, Is my program disorderly?*"
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计往往能创建更快的程序，而糟糕的软件设计往往能创建更慢的程序。如果你发现自己正在问，“我的程序为什么这么慢？”，那么首先问问自己，“我的程序是否混乱？”
- en: In this section, we describe some performance tips. These are generally good
    habits when programming in Rust that will coincidentally lead to improved performance.
    If your program is slow, then first check to see whether you are violating one
    of these principles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了一些性能技巧。这些通常是Rust编程中的良好习惯，无意中会导致性能提升。如果你的程序运行缓慢，那么首先检查你是否违反了这些原则之一。
- en: Compiling with release mode
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以发布模式编译
- en: This is a really simple suggestion that you should know about if you are at
    all concerned about performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你应该知道的非常简单的建议，如果你对性能有任何关注的话。
- en: 'Rust normally compiles in debug mode, which is slow:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust通常以调试模式编译，这比较慢：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Rust optionally compiles in release mode, which is fast:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust可以选择以发布模式编译，这比较快：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a comparison using debug mode for a toy program:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个使用调试模式为玩具程序进行比较的示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the release mode:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为发布模式：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Release mode is 98% more efficient with regard to CPU usage for this example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发布模式在此示例中相对于CPU使用效率提高了98%。
- en: Doing less work
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做更少的工作
- en: Faster programs do less. All optimization is a process of searching for work
    that doesn't need to be done, and then not doing it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的程序做更少的工作。所有优化都是一个寻找不需要完成的工作的过程，然后不去做它。
- en: Similarly, the smallest programs fewer resources less. All space optimization
    is a process of searching for resources that don't need to be used, and then not
    using them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最小的程序使用更少的资源。所有空间优化都是一个寻找不需要使用的资源的过程，然后不使用它们。
- en: 'For example, don''t collect an iterator when you don''t need the result, consider
    the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你不需要结果时，不要收集迭代器，考虑以下示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Needlessly collecting the result of the iterator makes the code 27% slower compared
    to code that just drops the result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无需收集迭代器的结果会使代码比仅丢弃结果的代码慢 27%。
- en: 'Memory allocation is similar. Well-designed code preferring pure functions
    and avoiding side-effects will tend to minimize memory usage. In contrast, messy
    code can lead to old data hanging around. Rust memory safety does not extend to
    preventing memory leaks. Leaks are considered safe code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配类似。设计良好的代码倾向于使用纯函数并避免副作用，从而最小化内存使用。相反，混乱的代码可能导致旧数据滞留。Rust 的内存安全性并不包括防止内存泄漏。泄漏被视为安全代码：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `forget` function is seldom used. Similarly, memory leaks are permitted
    but sufficiently discouraged that they are somewhat uncommon. Rust memory management
    tends to be such that by the time you cause a memory leak you are probably waist-deep
    in other poor design decisions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`forget` 函数很少使用。同样，内存泄漏是被允许的，但被充分劝阻，以至于它们相对不常见。Rust 的内存管理往往是这样，当你造成内存泄漏时，你可能已经陷入了其他糟糕的设计决策中。'
- en: However, unsused memory is not uncommon. If you don't keep track of what variables
    you are actively using, then old variables will likely remain in scope. This is
    not the typical definition of a memory leak; however, unused data is a similar
    waste of resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，未使用的内存并不少见。如果你不跟踪你正在积极使用的变量，那么旧变量很可能会保留在作用域内。这并不是内存泄漏的典型定义；然而，未使用的数据是类似资源的浪费。
- en: Optimizing the code that needs it – profiling
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化需要优化的代码——分析
- en: Don't optimize code that doesn't need to be optimized. It's a waste of your
    time and probably poor software engineering. Save yourself the trouble and identify
    performance problems accurately before attempting to optimize the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不要优化那些不需要优化的代码。这是浪费时间，也可能是糟糕的软件工程。省去麻烦，在尝试优化程序之前，准确识别性能问题。
- en: For a code rarely executed, performance is not affected
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于很少执行的代码，性能不受影响
- en: 'It is very common that you will initialize some resource and use it multiple
    times. Optimizing `initialization` of resources may be misdirected. You should
    consider focusing on improving the work efficiency. This is done as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一些资源并多次使用它是非常常见的。优化资源的 `initialization` 可能是错误的。你应该考虑专注于提高 `work` 的效率。这可以通过以下方式完成：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Multiples of small numbers are also small numbers
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小数的倍数也是小数
- en: 'The reverse may also be true. Sometimes the low frequency of `work` is overwhelmed
    by frequent and expensive `initialization`. Knowing which problem you have will
    let you know where to start looking to improve:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也可能成立。有时 `work` 的低频率会被频繁且昂贵的 `initialization` 所淹没。了解你遇到的问题将帮助你确定从哪里开始寻找以改进：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Measuring first, to optimize it
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先测量，再优化
- en: There are a lot of options for profiling. Here are some that we recommend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分析有很多选项。以下是我们推荐的一些。
- en: The `flame` crate is one option to manually profile an application. Here we
    create the nested procedures `a`, `b`, and `c`. Each function creates a profiling
    context corresponding do that method. After running the profiler we will see proportionally
    how much time was spent for each call to each function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`flame` crate 是手动分析应用程序的一个选项。在这里，我们创建了嵌套过程 `a`、`b` 和 `c`。每个函数创建一个与该方法对应的分析上下文。在运行分析器后，我们将看到每个函数的每次调用所花费的时间比例。'
- en: 'Starting with function `a`, this procedure creates a new profiling context,
    sleeps for one second, then calls `b` three times:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数 `a` 开始，此过程创建一个新的分析上下文，休眠一秒钟，然后调用 `b` 三次：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Function `b` is nearly identical to `a`, and further calls into function `c`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `b` 几乎与 `a` 相同，并进一步调用函数 `c`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Function `c` profiles itself and sleeps, but does not call any further nested
    function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `c` 会自我分析并休眠，但不会调用任何更深层的嵌套函数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `main` entrypoint sets up the flame graph library and calls a three times,
    then saves the flamegraph to a file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 入口设置火焰图库并调用三次，然后保存火焰图到文件：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After running this program, the `flame-graph.html` file will contain a visualization
    of what program sections took what percentage of resources. The `flame` crate
    is easy to install, requires some manual code manipulation, but produces a cool-looking
    graph.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序后，`flame-graph.html` 文件将包含程序各部分占资源百分比的可视化。`flame` crate 容易安装，需要一些手动代码操作，但会产生一个看起来很酷的图表。
- en: '`cargo profiler` is a tool that extends `cargo` to do performance profiling
    without any code changes. Here is a random program that we will profile:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo profiler` 是一个工具，它扩展了 `cargo` 以进行性能分析，而无需任何代码更改。以下是一个我们将要分析的随机程序：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To profile the application we run the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析应用程序，我们运行以下命令：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will run the program and collect information regarding which functions
    were most used. This profiler also has another option to profile memory usage.
    The output will look like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行程序并收集有关哪些函数被最频繁使用的相关信息。这个分析器还有一个选项来分析内存使用情况。输出将如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This clearly shows us that the most time is spent in iterator and vector creation.
    Running this command may make the program execute much more slowly than normal,
    but it also saves writing any code before profiling.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，大部分时间都花在迭代器和向量的创建上。运行这个命令可能会使程序执行速度比正常情况下慢得多，但它也节省了在分析之前编写任何代码的时间。
- en: Putting the fridge next to the computer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将冰箱放在电脑旁边
- en: If you take a snack break while coding, then it would be convenient to have
    a fridge and microwave next to the computer. If you travel to the kitchen for
    a snack, then it will take a little longer to satisfy your appetite. If your kitchen
    is empty and you need to make a grocery run, then the break is even further extended.
    If your grocery store is empty and you need to drive to a farm to harvest vegetables,
    then your work environment is clearly not designed for snacking purposes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编程时想休息一下，那么在电脑旁边有一个冰箱和微波炉会非常方便。如果你去厨房吃零食，那么满足你的胃口需要更长的时间。如果你的厨房空了，你需要去购物，那么休息时间会更长。如果你的杂货店也空了，你需要开车去农场采摘蔬菜，那么你的工作环境显然不是为吃零食而设计的。
- en: This strange analogy illustrates the necessary trade-off between time and space.
    This relation is not quite a physical law for our purposes, but almost. The rule
    is that traveling, or communicating, over longer distances is directly proportional
    to time spent. More distance (d) in one direction also means an increase in available
    space of quadratic (d²) or cubic (d³) scale. In other words building the fridge
    farther away provides more space for a larger fridge.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的类比说明了时间和空间之间必要的权衡。这种关系对于我们来说几乎不是一条物理定律，但几乎是。规则是，在更长的距离上旅行或通信，与花费的时间成正比。在一个方向上更多的距离（d）也意味着可用空间以二次（d²）或三次（d³）的比例增加。换句话说，将冰箱建得更远，可以为更大的冰箱提供更多的空间。
- en: 'Bringing this story back to a technical context, here are some latency numbers
    that every programmer should know (~2012: [https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个故事带回到技术环境中，以下是一些程序员应该知道的延迟数字（~2012：[https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)）：
- en: '| **Request** | **Time** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | **时间** |'
- en: '| L1 cache reference | 0.5 ns |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| L1缓存引用 | 0.5 ns |'
- en: '| Branch mispredict | 5 ns |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 分支预测错误 | 5 ns |'
- en: '| L2 cache reference | 7 ns |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| L2缓存引用 | 7 ns |'
- en: '| Mutex lock/unlock | 25 ns |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 锁定/解锁互斥锁 | 25 ns |'
- en: '| Main memory reference | 100 ns |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 主内存引用 | 100 ns |'
- en: '| Compress 1 Kb with Zippy | 3000 ns |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 使用Zippy压缩1 Kb | 3000 ns |'
- en: '| Send 1 Kb over 1 Gbps network | 10000 ns |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 在1 Gbps网络上发送1 Kb | 10000 ns |'
- en: '| Read 4 Kb randomly from SSD | 150000 ns |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 从SSD随机读取4 Kb | 150000 ns |'
- en: '| Read 1 Mb sequentially from memory | 250000 ns |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 从内存中顺序读取1 Mb | 250000 ns |'
- en: '| Round trip within same datacenter | 500000 ns |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 同一数据中心内的往返 | 500000 ns |'
- en: '| Send packet CA &#124; Netherlands &#124; CA | 150000000 ns |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 发送数据包 CA &#124; 荷兰 &#124; CA | 150000000 ns |'
- en: Here, we can see in specific numbers that if you want a donut and some coffee
    then you could eat 300,000,000 donuts from the fridge next to your computer before
    taking your first bite from a Danish.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到具体的数字，如果你想吃甜甜圈和一些咖啡，那么在你从丹麦咬第一口之前，你可以在电脑旁边的冰箱里吃掉3亿个甜甜圈。
- en: Capping the Big O
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制大O
- en: Big *O* notation is a computer science term used to group functions with respect
    to how fast they grow as the input value gets larger. This term is most often
    used with respect to algorithm runtime or space requirement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大O记号是计算机科学中的一个术语，用于根据输入值增大时函数增长的速度来分组函数。这个术语最常用于算法的运行时间或空间需求。
- en: 'When using this term in software engineering, we are usually concerned with
    one of these four cases:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当在软件工程中使用这个术语时，我们通常关注以下四种情况之一：
- en: Constant
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数
- en: Logarithmic growth
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数增长
- en: Polynomial growth
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式增长
- en: Exponential growth
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数增长
- en: When we are concerned with application performance, it is good to consider the
    Big *O* efficiency of the logic you are using. Depending on which of the preceding
    four cases you are dealing with, the appropriate response to optimization strategies
    may change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们关注应用程序性能时，考虑你使用的逻辑的大O效率是好的。根据你处理的前四个案例中的哪一个，优化策略的适当反应可能会改变。
- en: Constanting no growth
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续无增长
- en: Constant time operations are the indivisible units of runtime performance. In
    the previous section, we provided a table of common operations and how long each
    one takes. These are, for our purposes as programmers, basically physical constants.
    You can't optimize the speed of light to make it go faster.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 常数时间操作是运行性能的不可分割的单位。在前一节中，我们提供了一个常见操作及其所需时间的表格。对我们程序员来说，这些都是基本物理常数。你不能优化光速使其更快。
- en: 'Not all constant time operations are irreducible, however. If you have a procedure
    that does a fixed number of operations on fixed-size data, then it will be constant
    time. That does not mean that the procedure is automatically efficient. When trying
    to optimize constant time procedures, ask yourself these two questions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有常数时间操作都是不可减少的。如果你有一个对固定大小数据进行固定数量操作的程序，那么它将是常数时间。这并不意味着该程序自动是高效的。在尝试优化常数时间程序时，问问自己这两个问题：
- en: Can any of the work be avoided?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何工作可以避免？
- en: Is the fridge too far from the computer?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冰箱离电脑太远了吗？
- en: 'Here is a program consisting of emphasizing constant time operations:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个强调常数时间操作的程序：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, let''s profile this program:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们分析这个程序：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We see that the heavy memory allocation is fairly expensive. As for the memory
    access and floating point calculation, it is seemingly overwhelmed by the expense
    of the loop that executes them multiple times. Unless there is a clear culprit
    for poor performance in a constant time procedure, then optimizing this code may
    not be straightforward.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，大量的内存分配相当昂贵。至于内存访问和浮点运算，它们似乎被多次执行的循环的开销所压倒。除非在常数时间过程中有明显的性能不佳的原因，否则优化此代码可能并不简单。
- en: Logarithmic growth
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数增长
- en: Logarithmic algorithms are the pride of computer science. If your *O*(*n*) for
    *n*=5 code could have been written with an *O*(*log n*) algorithm, then surely
    at least one person will point this out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对数算法是计算机科学的骄傲。如果你的代码对于n=5的O(n)复杂度可以用O(log n)算法编写，那么至少会有一个人指出这一点。
- en: A binary search is O(*log n*). A sort is typically *O*(*n log n*). Everything
    with a log in it is better. This fondness is not misplaced. Logarithmic growth
    has an amazing property—growth slows down as the input value increases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索是O(log n)。排序通常是O(n log n)。任何包含对数的都是更好的。这种喜爱并非没有道理。对数增长有一个惊人的特性——随着输入值的增加，增长速度会减慢。
- en: 'Here is a program emphasizing logarithmic growth. We initialize a vector with
    random numbers having size of 1000 or 10000\. Then we use the builtin library
    to sort and perform 100 binary search operations. First let''s capture the time
    for sort and search for the 1000 case:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个强调对数增长的程序。我们初始化一个大小为1000或10000的随机数向量。然后我们使用内置库进行排序并执行100次二分搜索操作。首先让我们捕捉1000个案例的排序和搜索时间：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we profile the 10000 case:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们分析10000个案例：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After running this and examining the flamegraphs, we can see that sorting for
    a vector that is 10 times larger takes barely 10 times as much time—`O(n log n)`.
    Search performance is hardly affected at all—`O(log n)`. So for practical uses,
    logarithmic growth is almost negligible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序并检查火焰图后，我们可以看到，对于10倍更大的向量进行排序所需的时间几乎只增加了10倍——`O(n log n)`。搜索性能几乎不受影响——`O(log
    n)`。因此，对于实际应用，对数增长几乎可以忽略不计。
- en: When trying to optimize logarithmic code, follow the same approach as for constant
    time optimization. Logarithmic complexity is usually not a good target for optimization,
    particularly considering that logarithmic complexity is a strong indicator of
    good algorithm design.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试优化对数代码时，遵循与常数时间优化相同的方法。对数复杂度通常不是优化的好目标，尤其是考虑到对数复杂度是良好算法设计的强烈指标。
- en: Polynomial growth
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式增长
- en: Most algorithms are polynomial.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算法都是多项式时间复杂度。
- en: 'If you have one `for` loop, then your complexity is *O*(*n*). This is shown
    in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个`for`循环，那么你的复杂度是*O(n*)。这在上面的代码中显示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you have two `for` loops, then your complexity is *O*(*n*²):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个`for`循环，那么你的复杂度是*O(n²*)：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Higher polynomials are somewhat less common. Sometimes code accidentally becomes
    a higher polynomial, which you should be careful about; otherwise, let's just
    consider both the previous cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶多项式相对较少见。有时代码意外地变成了高阶多项式，你应该小心对待；否则，让我们只考虑前两种情况。
- en: 'Linear complexity is very common. Any time you process the entirety of data
    in a collection, the complexity will be linear. The running time of a linear algorithm
    will be approximately the number of items (*n*) processed, multiplied by the time
    to process individual items (*c*). If you want to make a linear algorithm go faster,
    you need to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 线性复杂度非常常见。每次你处理集合中的所有数据时，复杂度将是线性的。线性算法的运行时间将大约是处理的项目数量（*n*）乘以处理单个项目的时间（*c*）。如果你想使线性算法更快，你需要：
- en: Reduce the number of items processed (n)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少处理的项目数量（n）
- en: Reduce the constant time associated with processing an item (*c*)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少处理一个项目（*c*）相关的常数时间
- en: 'If the time to process an item is not constant or approximately constant, then
    your overall time complexity is now recursively dependent on that processing time.
    This is shown with the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理一个项目的时间不是常数或近似常数，那么你的整体时间复杂度现在将递归地依赖于那个处理时间。以下代码展示了这一点：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Higher polynomial complexity is also common but may indicate that your algorithm
    is poorly designed. In the preceding description, we mentioned that the linear
    processing time can become dependent on the time to process individual items.
    If your program is designed carelessly, then it is very easy to string together
    three or four linear algorithms and unintentionally create an *O*(*n*⁴) monster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶多项式复杂度也很常见，但可能表明你的算法设计得不好。在前面的描述中，我们提到线性处理时间可能依赖于处理单个项目的时间。如果你的程序设计得草率，那么很容易将三个或四个线性算法串联起来，无意中创建一个*O*(*n*⁴)的怪物。
- en: 'Higher polynomials are proportionally slower. In the case of algorithms that
    naively require high polynomial calculations, it is often the case that the algorithm
    can be pruned to remove calculations that are redundant or entirely unnecessary.
    Consider the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶多项式按比例更慢。对于需要高阶多项式计算的算法，通常可以通过剪枝来移除冗余或完全不必要的数据计算。考虑以下代码：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you need to use higher polynomial algorithms, use a library! This stuff
    gets complicated fast and improving these algorithms is the main job of academic
    Computer Scientists. If you are performance-tuning a common algorithm and not
    expecting to publish your results, then you may likely be duplicating work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用高阶多项式算法时，使用库！这些内容很快就会变得复杂，改进这些算法是学术计算机科学家的主要工作。如果你正在对常见算法进行性能调优，并且不打算发表你的结果，那么你很可能会重复工作。
- en: Exponential growth
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数增长
- en: Exponential performance in engineering is almost always a bug or a dead end.
    This is the wall that separates algorithms that we use from algorithms that we
    would like to use but can't due to performance reasons.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程中，指数性能几乎总是错误或死胡同。这是我们将使用的算法与我们希望使用但无法因为性能原因使用的算法之间的墙。
- en: 'Exponential growth in programs is often accompanied by the term `bomb`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的指数增长经常伴随着术语“炸弹”：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This program is only *O*(2^n) and therefore barely even exponential!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序只有*O*(2^n)，因此几乎连指数增长都算不上！
- en: Referencing data is faster
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用数据更快
- en: There is a rule of thumb that referencing data is faster than copying data.
    Similarly, copying data is faster than cloning. This is not always true, but it
    is a good rule to consider when trying to improve program performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个经验法则，即引用数据比复制数据更快。同样，复制数据比克隆数据更快。这并不总是正确的，但当你试图提高程序性能时，这是一个值得考虑的好规则。
- en: 'Here is a function that alternatively uses data by reference, copied, intrinsic
    cloned, or custom cloned:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数，它交替使用通过引用、复制、内建克隆或自定义克隆的数据：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we declare array of `1024` elements. Then using the flamegraph profiling
    library we apply the above functions to measure the differences between reference,
    copy and clone performance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们声明了一个包含`1024`个元素的数组。然后使用火焰图分析库应用上述函数来测量引用、复制和克隆性能之间的差异：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Looking at the runtime of this application, we see that the referenced data
    uses only a small sliver of the resources compared to copying or cloning this
    data. The default clone and copy traits unsurprisingly give a similar performance.
    The custom clone is really slow. It does semantically the same thing as all the
    others, but it is not as optimized at a low level.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个应用程序的运行时间，我们看到与复制或克隆此数据相比，引用的数据只使用了很小的一部分资源。默认的克隆和复制特性不出所料给出了相似的性能。自定义克隆实际上非常慢。它在语义上与所有其他操作相同，但在底层优化方面并不一样。
- en: Preventing bugs with defensive coding
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过防御性编程防止错误
- en: You don’t need to fix bugs that never happen. Preventative medicine is good
    software engineering that will save you time in the long run.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要修复永远不会发生的错误。预防性医学是好的软件工程，从长远来看会为你节省时间。
- en: Using Option and Result instead of panic!
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Option 和 Result 而不是 panic!
- en: In many other languages, exception handling is performed through `try…catch`
    blocks. Rust does not automatically provide this functionality, instead it encourages
    the programmer to explicitly localize all error handling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他语言中，异常处理是通过 `try…catch` 块来执行的。Rust 并不自动提供这种功能，相反，它鼓励程序员显式地局部化所有的错误处理。
- en: In many Rust contexts, if you don’t want to deal with error handling, you always
    have the option to use `panic!`. This will immediately end the program and provide
    a short error message. Don't do this. Panicking is usually just a way of avoiding
    the responsibility of handling errors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 Rust 上下文中，如果你不想处理错误处理，你总是可以选择使用 `panic!`。这将立即结束程序并提供一个简短的错误消息。不要这样做。恐慌通常只是避免处理错误责任的一种方式。
- en: Instead, use either the `Option` or `Result` types to communicate error or exceptional
    conditions. `Option` indicates that no value is available. The `None` value of
    `Option` should indicate that there is no value but that everything is okay and
    expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用 `Option` 或 `Result` 类型来传达错误或异常情况。`Option` 表示没有值可用。`Option` 的 `None` 值应表示没有值，但一切正常且符合预期。
- en: The `Result` type is used to communicate whether or not there was an error in
    processing. `Result` types can be used in combination with the `?` syntax to propagate
    errors while avoiding introducing too much extra syntax. The `?` operation will
    return errors from the function, if any, and therefore the function must have
    a `Result` return type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 类型用于传达处理过程中是否出现错误。`Result` 类型可以与 `?` 语法结合使用，以传播错误同时避免引入过多的额外语法。`?`
    操作将返回函数中的错误（如果有），因此该函数必须有一个 `Result` 返回类型。'
- en: 'Here we create two functions that return `Option` or `Result` to handle exceptional
    circumstances. Note the use of the try `?` syntax when handling `Result` return
    values. This syntax will pass through `Ok` values or immediately return any `Err`
    from that function. For this reason, any function using ? must also return a compatible
    `Result` type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个函数，它们返回 `Option` 或 `Result` 来处理异常情况。注意处理 `Result` 返回值时使用 try `?`
    语法。这种语法将传递 `Ok` 值或立即返回该函数中的任何 `Err`。因此，任何使用 `?` 的函数也必须返回兼容的 `Result` 类型：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Result` types are very common when interacting with external resources such
    as files:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 类型在与外部资源（如文件）交互时非常常见：'
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using typesafe interfaces instead of stringly typed interfaces
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型安全的接口而不是字符串类型接口
- en: 'Enumerations in Rust are less error-prone than using numbers or strings. Whenever
    possible, write the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的枚举比使用数字或字符串更不容易出错。只要可能，编写以下代码：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, you can write a stringly enumeration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以编写一个字符串枚举：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is better to use the following enum type:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用以下枚举类型：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This way, functions accepting the enumeration will be typesafe:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，接受枚举类型的函数将会是类型安全的：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Enums also fit naturally with pattern matching for the same reason. Pattern
    matching against an enumeration does not require a final error case like the integer
    or string typed case would:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也自然地与模式匹配相结合，原因相同。对枚举进行模式匹配不需要像整数或字符串类型那样有一个最终的错误情况：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the heartbeat pattern for long running processes
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用心跳模式处理长时间运行的过程
- en: When you want to create a long running process, it is nice to be able to recover
    from program errors that crash or terminate the process. Perhaps the process runs
    out of stack space or encounters a `panic!` from some code path. For any number
    of reasons, a process might get terminated and will need to be restarted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想创建一个长时间运行的过程时，能够从程序错误中恢复，这些错误会导致进程崩溃或终止，这会很好。也许进程耗尽了栈空间，或者遇到了某些代码路径的`panic!`。由于任何数量的原因，一个进程可能会被终止，并需要重新启动。
- en: To accommodate this desire, there are many tools that will watch a program for
    you and restart it if it dies or stops responding to health checks. Here, we recommend
    a completely self-contained version of this pattern that is based on Rust concurrency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这种需求，有许多工具会为你监视程序，并在它死亡或停止对健康检查做出响应时重新启动它。在这里，我们推荐一个基于Rust并发的完全自包含的这种模式版本。
- en: 'The goal is to create a parent process that acts as a monitor and oversees
    one or more workers. The process tree should look something like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建一个充当监控器并监督一个或多个工作进程的父进程。进程树应该看起来像这样：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a child dies or stops responding to health checks, the parent should kill
    or otherwise clean up the process resources, then start a new process to replace
    it. Here is an example of this behavior, starting with a subprocess that sometimes
    dies:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个子进程死亡或停止对健康检查做出响应时，父进程应该终止或以其他方式清理进程资源，然后启动一个新的进程来替换它。以下是一个这种行为示例，从一个有时会死亡的子进程开始：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This worker process is highly unreliable and lives no longer than eight seconds.
    However, if we wrap it with a heartbeat monitor, then we can make it more reliable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作进程非常不可靠，其寿命不超过八秒。然而，如果我们用心跳监控器将其包装起来，那么我们可以使其更加可靠：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the running processes will get restarted if they die unexpectedly. Optionally,
    the parent can check the health status of each child process and restart unresponsive
    workers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果运行中的进程意外终止，它们将会被重新启动。可选地，父进程可以检查每个子进程的健康状态，并重新启动无响应的工作进程。
- en: Validating input and output
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入和输出
- en: Preconditions and postconditions are a great way to lock down program behavior
    and find bugs or invalid states before they get out of hand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 预设条件和后置条件是锁定程序行为并找到在失控之前可能出现的错误或无效状态的好方法。
- en: If you use macros to do this, then the preconditions and postconditions can
    optionally be run only in debug mode, and removed from production code. The built-in
    `debug_assert!` macro does this. However, using assertions for return values is
    not particularly elegant and, if you forget to check a branch with a return statement,
    then your postcondition won't be checked.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用宏来做这件事，那么预设条件和后置条件可以可选地仅在调试模式下运行，并从生产代码中删除。内置的`debug_assert!`宏就是这样做的。然而，使用断言作为返回值并不特别优雅，如果你忘记检查带有返回语句的分支，那么你的后置条件将不会被检查。
- en: '`debug_assert!` is not a good choice for the validation of anything dependent
    on external data or otherwise nondeterministic behavior. When you want to check
    preconditions or postconditions in production code, you should instead use `Result`
    or `Option` values to handle exceptional behavior.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug_assert!`不是验证任何依赖于外部数据或非确定性行为的任何内容的良好选择。当你想在生产代码中检查预设条件或后置条件时，你应该使用`Result`或`Option`值来处理异常行为。'
- en: 'Here are some examples of preconditions and postconditions in Rust:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Rust中预设条件和后置条件的示例：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that the user input is out of our control. The best option for validating
    user input is to return an `Error` condition if the input is invalid.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户输入超出了我们的控制。验证用户输入的最佳选项是在输入无效时返回一个`Error`条件。
- en: Finding and fixing bugs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找和修复错误
- en: Debugging tools are quite platform dependent. Here we will explain `lldb`, which
    is available, and macOS and other Unix-like systems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调试工具很大程度上依赖于平台。在这里，我们将解释`lldb`，它可用，并且适用于macOS和其他类Unix系统。
- en: 'To start debugging, you will need to compile the program with debugging symbols
    turned on. The normal `cargo debug build` is usually sufficient:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，你需要编译程序并开启调试符号。正常的`cargo debug build`通常足够：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the program has been compiled, start the debugger:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 程序编译完成后，启动调试器：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we reference the `debugs/deps/program_name-GITHASH` copy of the program.
    This is necessary for now just because of how lldb works.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引用了`debugs/deps/program_name-GITHASH`程序的副本。这现在是因为lldb的工作方式。
- en: 'After running `lldb`, you will see some information scroll past on startup.
    Then, you should be dropped into a LLDB Command Prompt:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`lldb`后，你将在启动时看到一些信息滚动过去。然后，你应该进入LLDB命令提示符：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, set a breakpoint. We will set a breakpoint to stop at function `a`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置一个断点。我们将设置一个断点在函数 `a` 处停止：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that our breakpoint is set, run the `r` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了断点，运行 `r` 命令：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After stopping at the breakpoint, LLDB will print some context for where the
    code is stopped at. Now we can inspect the program. Let''s print what variables
    are defined in this function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码停止点停止后，LLDB 将打印出代码停止处的上下文。现在我们可以检查程序了。让我们打印出在这个函数中定义了哪些变量：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can similarly print any variable in scope:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地打印作用域内的任何变量：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we want to continue the program, type `c` to continue:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要继续程序时，输入 `c` 以继续：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The program exits here because we did not set any more breakpoints. This method
    of debugging is nice because it allows you to inspect a running program without
    constantly adding `println!` statements and recompiling. If nothing else works,
    that is still an option though.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在这里退出，因为我们没有设置更多的断点。这种调试方法很棒，因为它允许你在不不断添加 `println!` 语句和重新编译的情况下检查运行中的程序。如果其他方法都不奏效，这仍然是一个可行的选择。
- en: Metaprogramming
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: Metaprogramming in Rust has two forms—macros and procedural macros. Both of
    these utilities accept an abstract syntax tree as new input and output symbols
    to be compiled. Procedural macros are very similar to normal macros but with fewer
    restrictions on how they work and how they are defined.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的元编程有两种形式——宏和过程宏。这两种实用工具都接受抽象语法树作为新的输入和输出符号进行编译。过程宏与正常宏非常相似，但它们在如何工作以及如何定义方面有更少的限制。
- en: 'Macros defined with the `macro_rules!` syntax are defined recursively by matching
    the input syntax to produce output. It is crucial to understand that macro matching
    happens *after* parsing. This means the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `macro_rules!` 语法定义的宏通过匹配输入语法来递归地定义输出。理解这一点至关重要：宏匹配发生在解析之后。这意味着以下内容：
- en: Macros must follow certain rules when creating new syntax forms
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏在创建新的语法形式时必须遵循某些规则
- en: The AST is decorated with information regarding each node's grammar category
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AST 被装饰了有关每个节点语法类别的信息
- en: 'Macros can match individual tokens, or a macro can match (and capture) an entire
    grammar category. The Rust grammar categories are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 宏可以匹配单个标记，或者宏可以匹配（并捕获）整个语法类别。Rust 的语法类别如下：
- en: '`tt`: This is a token tree (which is a token output from the lexer before parsing)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt`：这是一个标记树（这是在解析之前从词法分析器输出的标记）'
- en: '`ident`: This is an identifier'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ident`：这是一个标识符'
- en: '`expr`: This is an expression'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr`：这是一个表达式'
- en: '`ty`: This is a type'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ty`：这是一个类型'
- en: '`stmt`: This is a statement'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stmt`：这是一个语句'
- en: '`block`: These are the braces containing a block of statements'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`：这些是包含语句块的括号'
- en: '`item`: This is a top-level definition such as a function or a struct'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`：这是一个顶层定义，例如函数或结构体'
- en: '`pat`: This is the match part of a pattern match expression, also called the
    **left hand side**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pat`：这是模式匹配表达式的匹配部分，也称为**左侧**'
- en: '`path`: This is a path such as `std::fs::File`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是一个路径，例如 `std::fs::File`'
- en: '`meta`: This is a meta item that goes inside either `#[...]` or `#![...]` syntax
    forms'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：这是一个元项，可以放在 `#[...]` 或 `#![...]` 语法形式内部'
- en: 'Using these patterns we can create macros to match various groups of syntax
    expressions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模式，我们可以创建宏来匹配各种语法表达式组：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, let''s apply the macros to some different input:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们将这些宏应用到不同的输入上：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can see from the example, token trees are, for the most part, not restricted
    to normal Rust grammar, only to the Rust lexer. The lexer is aware of opening
    and closing `() [] {}` bracketed forms. This is why tokens are structured in a
    token tree rather than a token list. This also means that all tokens inside macro
    calls will be stored as token trees and not processed any further until the macro
    is invoked; as long as we create a syntax compatible with Rust token trees, then
    other syntax innovations should usually be permitted. This rule applies also to
    the other grammar categories: grammar categories are just a short hand to match
    certain pattern of tokens that happen to correspond to Rust syntax forms.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中我们可以看出，标记树在大多数情况下并不受正常 Rust 语法限制，只受 Rust 词法分析器的限制。词法分析器知道开闭括号 `() [] {}`
    的形式。这就是为什么标记是以标记树而不是标记列表的形式组织的。这也意味着宏调用内的所有标记都将作为标记树存储，并且不会进一步处理，直到宏被调用；只要我们创建与
    Rust 标记树兼容的语法，那么通常应该允许其他语法创新。这条规则也适用于其他语法类别：语法类别只是匹配某些标记模式的一种简写，这些模式恰好对应 Rust
    语法形式。
- en: Just matching single tokens or grammar categories probably won't be very useful
    for a macro. To make use of macros in a practical context, we will need to make
    use of macro grammar sequences and grammar alternative*s*. A grammar sequence
    is a request to match more than one token or grammar category in the same rule.
    A grammar alternative is a separate rule within the same macro that matches a
    different syntax. Grammar sequences and alternatives can also be combined in the
    same macro. Additionally, there is a special syntax form to match *many* tokens
    or grammar categories.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 仅匹配单个标记或语法类别可能对宏来说不太有用。为了在实用场景中使用宏，我们需要利用宏语法序列和语法替代项。语法序列是在同一规则中请求匹配多个标记或语法类别。语法替代项是在同一宏中的单独规则，它匹配不同的语法。语法序列和替代项也可以在同一宏中组合。此外，还有一个特殊的语法形式来匹配许多标记或语法类别。
- en: 'Here are corresponding examples to illustrate these patterns:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些相应的示例来展示这些模式：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you''ve paid attention to the generated code for all of these macros, you
    might have noticed that all production rules have created expressions. Macro input
    can be tokens, but output must be a contextually well-formed Rust syntax. For
    this reason, you cannot write `macro_rules!` as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了所有这些宏生成的代码，你可能会注意到所有生产规则都创建了表达式。宏输入可以是标记，但输出必须是上下文中良好形成的 Rust 语法。因此，你不能像下面这样编写
    `macro_rules!`：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The specific error from the compiler is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器产生的具体错误如下：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The key phrase here is `f!`, which is likely invalid in an expression context.
    Each pattern of `macro_rules!` output must be a well-formed expression. The preceding
    example will create well-formed Rust syntax in the end, but its intermediate results
    are fragmented expressions. This awkwardness is one of the several reasons to
    use procedural macros, which are much like `macro_rules!` but programmed directly
    in Rust rather than through the special `macro_rules!` syntax.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键短语是 `f!`，在表达式上下文中可能是不合法的。`macro_rules!` 的每个输出模式都必须是一个良好形成的表达式。前面的例子最终将创建良好的
    Rust 语法，但它的中间结果是碎片化的表达式。这种尴尬是使用过程宏的几个原因之一，过程宏与 `macro_rules!` 类似，但直接在 Rust 中编程，而不是通过特殊的
    `macro_rules!` 语法。
- en: Procedural macros are programmed in Rust, but are also used to compile Rust
    programs. How does that work? Procedural macros must be isolated into their own
    modules and compiled separately; they are basically a compiler plugin.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏是用 Rust 编程的，但也被用来编译 Rust 程序。这是怎么做到的？过程宏必须被隔离到它们自己的模块中并单独编译；它们基本上是一个编译器插件。
- en: 'To start our procedural macro, let''s create a new subproject:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的过程宏，让我们创建一个新的子项目：
- en: Make a `procmacro` directory inside the project root
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个 `procmacro` 目录
- en: 'Inside the `procmacro` directory, create a `Cargo.toml` file with the following
    contents:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `procmacro` 目录中，创建一个包含以下内容的 `Cargo.toml` 文件：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Inside the `procmacro` directory, create a `src/lib.rs` file with the following
    contents:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `procmacro` 目录中，创建一个包含以下内容的 `src/lib.rs` 文件：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This `f!` macro now implements the preceding semantics without any of the complaints.
    Using the macro looks like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `f!` 宏现在实现了前面的语义，没有任何抱怨。使用这个宏的示例如下：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The interface of a procedural macro is really simple. There is a `TokenStream`
    as input and a `TokenStream` as output. The `proc_macro` and `syn` crates also
    provide utilities to parse tokens or to easily create token streams using the
    `quote!` macro. To use procedural macros, there is some additional setup and boilerplate,
    but after getting past these hurdles the interface is fairly straightforward now.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏的接口非常简单。有一个 `TokenStream` 作为输入，还有一个 `TokenStream` 作为输出。`proc_macro` 和 `syn`
    包还提供了解析标记或使用 `quote!` 宏轻松创建标记流的实用工具。要使用过程宏，有一些额外的设置和样板代码，但过了这些障碍后，接口现在相当直接了。
- en: Additionally, there are many more detailed grammar categories available to procedural
    macros through the `syn` crate. There are 163 categories ([https://dtolnay.github.io/syn/syn/#macros](https://dtolnay.github.io/syn/syn/#macros))
    right now! These include the same vague syntax trees from recursive macros, but
    also very specific syntax forms. These categories correspond to the full Rust
    grammar, therefore permitting very expressive macro syntax without having to create
    your own parser.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过 `syn` crate，过程宏还有许多更详细的语法类别可供使用。目前有 163 个类别（[https://dtolnay.github.io/syn/syn/#macros](https://dtolnay.github.io/syn/syn/#macros)）！这些类别包括递归宏中的相同模糊的语法树，但也包括非常具体的语法形式。这些类别对应于完整的
    Rust 语法，因此允许在不创建自己的解析器的情况下，使用非常表达性的宏语法。
- en: 'Let''s make a procedural macro that uses some of these syntax categories. First
    we make a new procedural macro folder, just like preceding `procmacro`; this one
    we will name `procmacro2`. Now we define the AST that will hold all of the program
    information if the user input is valid:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用这些语法类别的过程宏。首先，我们创建一个新的过程宏文件夹，就像之前的 `procmacro` 一样；这个我们将命名为 `procmacro2`。现在我们定义将持有所有程序信息的
    AST（抽象语法树），如果用户输入有效的话：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `MiscSyntax` struct will contain all information gathered from our macro.
    That macro and its syntax is what we should define now:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`MiscSyntax` 结构将包含从我们的宏中收集的所有信息。我们现在应该定义这个宏及其语法：'
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `do_parse!` macro helps simplify the use of the parser combinators from
    the `syn` crate. The `id: expr >>` syntax corresponds to the monadic bind operation,
    and `expr >>` syntax is also a form of a monadic bind.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_parse!` 宏有助于简化 `syn` crate 中解析组合器的使用。`id: expr >>` 语法对应于单调绑定操作，而 `expr
    >>` 语法也是一种单调绑定。'
- en: 'Now we utilize these definitions to parse input, generate output, and expose
    the macro:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用这些定义来解析输入，生成输出，并暴露宏：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When using this macro, it really is a bunch of random syntax. This emphasizes
    how macros are not limited to valid Rust syntax, which looks like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这个宏时，它实际上是一堆随机的语法。这强调了宏并不局限于有效的 Rust 语法，它看起来如下：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Procedural macros are very powerful and helpful if Rust syntax becomes annoying
    for your purposes. For specific contexts it is possible to create very semantically
    dense code using macros that would otherwise require lots of boilerplate and copy-paste
    coding.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Rust 语法对您来说很烦人，过程宏非常强大且有用。在特定上下文中，可以使用宏创建非常语义密集的代码，否则这将需要大量的样板代码和复制粘贴编程。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced many applied and practical considerations for
    Rust programming. Performance and debugging are certainly not problems that are
    exclusive to Functional Programming. Here we tried to introduce tips that are
    generally applicable but also highly compatible with functional programming.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了 Rust 编程的许多应用和实践考虑因素。性能和调试当然不是仅限于函数式编程的问题。在这里，我们试图介绍一些普遍适用但高度兼容于函数式编程的技巧。
- en: Metaprogramming in Rust may be considered a functional feature by itself. Logic
    programming and thereby derived functionality are closely associated with functional
    programming principles. The recursive, context-free nature of macros also lends
    itself to a functional perspective.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，元编程可能被视为一种功能特性本身。逻辑编程及其由此派生的功能与函数式编程原则密切相关。宏的递归、上下文无关特性也使其适合于函数式视角。
- en: This is also the last chapter in the book. We hope you have enjoyed the book
    and we welcome any feedback. If you are looking for further reading, you might
    want to research some of the topics presented in the final three chapters of the
    book. There is an enormous amount of material available on these subjects and
    any path taken will surely further improve your understanding of Rust and functional programming.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是本书的最后一章。我们希望您喜欢这本书，并欢迎任何反馈。如果您正在寻找进一步阅读，您可能想研究一下书中最后三章中提出的某些主题。关于这些主题有大量的材料可用，并且任何选择的路径都将无疑进一步加深您对
    Rust 和函数式编程的理解。
- en: Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How is release mode different from debug mode?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布模式与调试模式有何不同？
- en: How long will an empty loop take to run?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个空的循环将运行多长时间？
- en: What is linear time in *Big O* notation?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *Big O* 表示法中，线性时间是什么意思？
- en: Name a function that grows faster than exponential growth.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请举一个比指数增长更快的函数的例子。
- en: What is faster, a disk read or a network read?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁盘读取和网络读取哪个更快？
- en: How would you return a `Result` with multiple error conditions?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何返回一个包含多个错误条件的 `Result`？
- en: What is a token tree?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是标记树？
- en: What is an abstract syntax tree?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象语法树是什么？
- en: Why do procedural macros need to be compiled separately?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么过程宏需要单独编译？
