["```rs\npub fn bubble_sort<T: PartialOrd + Clone>(collection: &[T]) -> Vec<T> {\n    let mut result: Vec<T> = collection.into();\n    for _ in 0..result.len() {\n        let mut swaps = 0;\n        for i in 1..result.len() {\n            if result[i - 1] > result[i] {\n                result.swap(i - 1, i);\n                swaps += 1;\n            }\n        }\n        if swaps == 0 {\n            break;\n        }\n    }\n    result\n}\n```", "```rs\npub fn shell_sort<T: PartialOrd + Clone>(collection: &[T]) -> Vec<T> {\n    let n = collection.len();\n    let mut gap = n / 2;\n    let mut result: Vec<T> = collection.into();\n\n    while gap > 0 {\n        for i in gap..n {\n            let temp = result[i].clone();\n\n            let mut j = i;\n            while j >= gap && result[j - gap] > temp {\n                result[j] = result[j - gap].clone();\n                j -= gap;\n            }\n            result[j] = temp;\n        }\n        gap /= 2;\n    }\n    result\n}\n```", "```rs\npub fn heap_sort<T: PartialOrd + Clone + Ord>(collection: &[T]) -> Vec<T> {\n    let mut heap = BinaryHeap::new();\n    for c in collection {\n        heap.push(c.clone());\n    }\n    heap.into_sorted_vec()\n}\n```", "```rs\n\npub fn merge_sort<T: PartialOrd + Clone + Debug>(collection: &[T]) -> Vec<T> {\n    if collection.len() > 1 {\n        let (l, r) = collection.split_at(collection.len() / 2);\n        let sorted_l = merge_sort(l);\n        let sorted_r = merge_sort(r);\n        let mut result: Vec<T> = collection.into();\n        let (mut i, mut j) = (0, 0);\n        let mut k = 0;\n        while i < sorted_l.len() && j < sorted_r.len() {\n            if sorted_l[i] <= sorted_r[j] {\n                result[k] = sorted_l[i].clone();\n                i += 1;\n            } else {\n                result[k] = sorted_r[j].clone();\n                j += 1;\n            }\n            k += 1;\n        }\n\n        while i < sorted_l.len() {\n            result[k] = sorted_l[i].clone();\n            k += 1;\n            i += 1;\n        }\n\n        while j < sorted_r.len() {\n            result[k] = sorted_r[j].clone();\n            k += 1;\n            j += 1;\n        }\n\n        result\n    } else {\n        collection.to_vec()\n    }\n}\n```", "```rs\nfn partition<T: PartialOrd + Clone + Debug>(\n    collection: &mut [T],\n    low: usize,\n    high: usize,\n) -> usize {\n    let pivot = collection[high].clone();\n    let (mut i, mut j) = (low as i64 - 1, high as i64 + 1);\n\n    loop {\n        'lower: loop {\n            i += 1;\n            if i > j || collection[i as usize] >= pivot {\n                break 'lower;\n            }\n        }\n\n        'upper: loop {\n            j -= 1;\n            if i > j || collection[j as usize] <= pivot {\n                break 'upper;\n            }\n        }\n\n        if i > j {\n            return j as usize;\n        }\n        collection.swap(i as usize, j as usize);\n    }\n}\n\nfn quick_sort_r<T: PartialOrd + Clone + Debug>(collection: &mut [T], low: usize, high: usize) {\n    if low < high {\n        let pivot = partition(collection, low, high);\n        quick_sort_r(collection, low, pivot);\n        quick_sort_r(collection, pivot + 1, high);\n    }\n}\n\npub fn quick_sort<T: PartialOrd + Clone + Debug>(collection: &[T]) -> Vec<T> {\n    let mut result = collection.to_vec();\n    quick_sort_r(&mut result, 0, collection.len() - 1);\n    result\n}\n```"]