<html><head></head><body>
        

                            
                    <h1 class="header-title">Using Experimental Nightly Features</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Iterating over an inclusive range</li>
<li>Returning abstract types</li>
<li>Composing functions</li>
<li>Filtering strings efficiently</li>
<li>Stepping through an iterator in regular intervals</li>
<li>Benchmarking your code</li>
<li>Using generators</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This final chapter leads us to the most important experimental features in Rust, provided on the newest <kbd>nightly</kbd> toolchain. As of the time of writing, this is <kbd>rustc 1.25.0-nightly</kbd>. If you are using <kbd>rustup</kbd> (<a href="https://rustup.rs/">https://rustup.rs/</a>), you can set it as your default toolchain like this:</p>
<pre><strong>rustup default nightly</strong></pre>
<p>These recipes will ensure that you stay ahead in your knowledge of Rust, and are ready to use them effectively once they are stabilized, or right now in your own unstable apps.</p>
<p>All of the recipes in this chapter have varying stability guarantees. Many will undergo drastic changes before they land in the <kbd>stable</kbd> toolchain, and others are nearly done. This means that some of the example code provided is expected not to work on your newest <kbd>nightly</kbd>. When this happens, you can find help in two places:</p>
<ul>
<li>If the feature is still experimental, it will have an entry in <em>The Unstable Book</em> (<a href="https://doc.rust-lang.org/unstable-book/">https://doc.rust-lang.org/unstable-book/</a>), and a link to the relevant GitHub issue and its surrounding discussion</li>
<li>If the feature has been stabilized, there is a good chance you will find it listed in the appendix of <em>The Rust Programming Language, Second Edition</em> (<a href="https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html">https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html</a>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over an inclusive range</h1>
                
            
            
                
<p>We begin the chapter with a small feature that can make your code a bit more readable. The inclusive range syntax (<kbd>..=</kbd>) will create a range up to a value <em>including</em> it. This helps you eliminate ugly instances of things like <kbd>n .. m+1</kbd> by rewriting them as <kbd>n ..= m</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a Rust project to work on during this chapter with <kbd>cargo new chapter-ten</kbd>.</li>
<li>Navigate into the newly-created <kbd>chapter-ten</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory.</li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library.</li>
<li>Inside the <kbd>src</kbd> folder, create a new folder called <kbd>bin</kbd>.</li>
<li>In the <kbd>src/bin</kbd> folder, create a file called <kbd>inclusive_range.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin inclusive_range</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(inclusive_range_syntax)]
2   
3   fn main() {
4     // Retrieve the entire alphabet in lower and uppercase:
5     let alphabet: Vec&lt;_&gt; = (b'A' .. b'z' + 1) // Start as u8
6       .map(|c| c as char)      // Convert all to chars
7       .filter(|c| c.is_alphabetic()) // Filter only alphabetic     <br/>        chars
8       .collect(); // Collect as Vec
9     println!("alphabet: {:?}", alphabet);
10  
11    // Do the same, but using the inclusive range syntax:
12    let alphabet: Vec&lt;_&gt; = (b'A' ..= b'z') // Start as u8
13      .map(|c| c as char)      // Convert all to chars
14      .filter(|c| c.is_alphabetic()) // Filter only alphabetic  <br/>         chars
15      .collect(); // Collect as Vec
16    println!("alphabet: {:?}", alphabet);
17  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this example, the code is the promised rewrite of a snippet in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml">Chapter 2</a>, <em>Working with Collections</em>; <em>Accessing collections as iterators</em>.</p>
<p>The traditional range syntax (<kbd>n .. m</kbd>) is exclusive, meaning that <kbd>0 .. 5</kbd> will only include the numbers 0, 1, 2, 3, and 4. This is good for uses cases where you count up to a length of something, but in our case, we want to iterate over the alphabet, including Z [5]. The inclusive range syntax (<kbd>n ..= m</kbd>) helps us by including the last element, so that <kbd>0 ..= 5</kbd> will yield 0, 1, 2, 3, 4, and 5.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Accessing collections as iterators</em> recipe in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning abstract types</h1>
                
            
            
                
<p class="mce-root">Remember when we used <kbd>Box</kbd> to create trait objects in order to hide the exact implementation returned, and instead only give guarantees about implemented traits? That required us to accept some overhead, as a <kbd>Box</kbd> allocates its resources on the heap; however, on the current <kbd>nightly</kbd>, things are different. You can use the <kbd>impl trait</kbd> syntax introduced in this recipe to return objects as their trait directly on the stack, all without boxes. At the moment, this only works for returned types, but the syntax is planned to be extended to most places where you could write a concrete type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>return_abstract.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo run --bin return_abstract</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(conservative_impl_trait)]
2   
3   trait Animal {
4     fn do_sound(&amp;self);
5   }
6   
7   struct Dog;
8   impl Animal for Dog {
9     fn do_sound(&amp;self) {
10      println!("Woof");
11    }
12  }
13  
14  fn main() {
15    // The caller doesn't know which exact object he gets
16    // He knows only that it implements the Animal trait
17    let animal = create_animal();
18    animal.do_sound();
19  
20    for word in caps_words_iter("do you feel lucky, punk‽") {
21      println!("{}", word);
22    }
23  
24    let multiplier = create_multiplier(23);
25    let result = multiplier(3);
26    println!("23 * 3 = {}", result);
27  }
28  
29  // The impl trait syntax allows us to use abstract return types
30  // This means that we don't specify which exact struct we return
31  // but which trait(s) it implements
32  fn create_animal() -&gt; impl Animal {
33    Dog {}
34  }
35  
36  // Any iterator can be returned as an abstract return type
37  fn caps_words_iter&lt;'a&gt;(text: &amp;'a str) -&gt; impl Iterator + 'a {
38    // Return an iterator over every word converted into ALL_CAPS
39    text.trim().split(' ').map(|word| word.to_uppercase())
40  }
41  
42  // Same goes for closures
43  fn create_multiplier(a: i32) -&gt; impl Fn(i32) -&gt; i32 {
44    move |b| a * b
45  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>If you've read <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <em>Advanced Data Structures</em>; <em>Boxing data</em>, this recipe doesn't need much explanation. By returning an <kbd>impl trait</kbd>, we tell the caller of a function to not care about the specific struct that is returned, and that its only guarantee about it is that it implements some trait. In this sense, abstract return types work like the trait objects discussed in the said recipe, with the added bonus of being way faster, as they don't have any overhead. This is useful for returning iterators [37] and closures [43], which we adapted from the recipe about boxes, but also to hide implementation details. Consider our function <kbd>create_animal</kbd>[32]. A caller will only care that it returns a struct that implements <kbd>Animal</kbd>, but not which exact animal. If a <kbd>Dog</kbd> [7] doesn't prove to be the right thing because of changing requirements, you can create a <kbd>Cat</kbd>, and return that one without touching the rest of the code, as it all just depends on <kbd>Animal</kbd>. This is a form of <em>dependency inversion</em> (<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>).</p>
<p>The <kbd>conservative</kbd> in <kbd>conservative_impl_trait</kbd> [1] tells us that this is just a part of a bigger feature. At the moment, you can only use it in return types of functions. In the future, you'll be able to use it in traits, constraints, and bindings as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Of all the recipes in this chapter, this one is probably the most stable, as it is being considered for immediate stabilization. The discussion can be found at <a href="https://github.com/rust-lang/rust/issues/34511">https://github.com/rust-lang/rust/issues/34511.</a></p>
<p><a href="https://github.com/rust-lang/rust/issues/34511"/></p>
<p>While you can use abstract return types for some forms of dependency inversion, you cannot use them for traditional Java-style factories that return different objects depending on a parameter. This is because abstract return types only hide the specific struct returned on the outside of the function, but still internally rely on a specific return value. Because of this, the following code will not compile:</p>
<pre style="padding-left: 30px">trait Animal {<br/>    fn do_sound(&amp;self);<br/>}<br/><br/>struct Dog;<br/>impl Animal for Dog {<br/>    fn do_sound(&amp;self) {<br/>        println!("Woof");<br/>    }<br/>}<br/>struct Cat;<br/>impl Animal for Cat {<br/>    fn do_sound(&amp;self) {<br/>        println!("Meow");<br/>    }<br/>}<br/><br/>enum AnimalType {<br/>    Dog,<br/>    Cat,<br/>}<br/><br/>fn create_animal(animal_type: AnimalType) -&gt; impl Animal {<br/>    match animal_type {<br/>        AnimalType::Cat =&gt; Cat {},<br/>        AnimalType::Dog =&gt; Dog {},<br/>    }<br/>}</pre>
<p>While the outside world doesn't know which animal is going to be returned by <kbd>create_animal</kbd>, the function itself needs a specific return type internally. Because the first possible return from our match is an instance of <kbd>Cat</kbd>, <kbd>create_animal</kbd> assumes that we are going to return no other type. We break that expectation in the next line by returning a <kbd>Dog</kbd>, so the compiler fails:</p>
<div><img src="img/9eeed4e9-fed8-46e6-bbf9-94318249d556.png" style="width:53.08em;height:18.42em;"/></div>
<p>If we want this factory to compile, we need to resort back to <kbd>Box</kbd> again:</p>
<pre style="padding-left: 30px">fn create_animal(animal_type: AnimalType) -&gt; Box&lt;Animal&gt; {<br/>    match animal_type {<br/>        AnimalType::Cat =&gt; Box::new(Cat {}),<br/>        AnimalType::Dog =&gt; Box::new(Dog {}),<br/>    }<br/>}</pre>
<p>By the way, this is also exactly what Java does under the hood.<br/>
<br/>
For most purposes, you won't need a factory such as the one presented here. It is considered more idiomatic to use generics with trait bounds.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Boxing data</em> recipe in <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <em>Advanced Data Structures</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Composing functions</h1>
                
            
            
                
<p class="mce-root">Because we have now learned how to return arbitrary closures with no overhead, we can combine that with macros that accept any number of parameters (<a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; <em>Accepting a variable number of arguments</em>) to create an easy way to chain actions as you would be used to in functional languages such as <em>Haskell</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>compose_functions.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo run --bin compose_functions</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(conservative_impl_trait)]
2   
3   // The compose! macro takes a variadic amount of closures and  <br/>    returns
4   // a closure that applies them all one after another
5   macro_rules! compose {
6     ( $last:expr ) =&gt; { $last };
7     ( $head:expr, $ ($tail:expr), +) =&gt; {
8       compose_two($head, compose!($ ($tail), +))
9     };
10  }
11  
12  // compose_two is a helper function used to
13  // compose only two closures into one
14  fn compose_two&lt;FunOne, FunTwo, Input, Intermediate, Output&gt;(
15    fun_one: FunOne,
16    fun_two: FunTwo,
17  ) -&gt; impl Fn(Input) -&gt; Output
18  where
19    FunOne: Fn(Input) -&gt; Intermediate,
20    FunTwo: Fn(Intermediate) -&gt; Output,
21  {
22    move |x| fun_two(fun_one(x))
23  }
24  
25  fn main() {
26    let add = |x| x + 2.0;
27    let multiply = |x| x * 3.0;
28    let divide = |x| x / 4.0;
29    // itermediate(x) returns ((x + 2) * 3) / 4
30    let intermediate = compose!(add, multiply, divide);
31  
32    let subtract = |x| x - 5.0;
33    // finally(x) returns (((x + 2) * 3) / 4) - 5
34    let finally = compose!(intermediate, subtract);
35  
36    println!("(((10 + 2) * 3) / 4) - 5 is: {}", finally(10.0));
37  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>By the usage of <kbd>compose!</kbd> in main [30 and 34], you should see clearly what it does: it takes as many closures as you want, and combines them into a new closure that runs them one by one. This is really useful for runtime user-driven functionality composition.</p>
<p>The macro is implemented similarly to the standard macro for variable arguments from <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; <em>Accepting a variable number of arguments</em>, with its edge case being a single closure [6]. When encountering more, it will recursively go through them and combine them in pairs by calling the helper function <kbd>compose_two</kbd> [14]. Usually, type parameters are written as a single character, but we are using full words for them in this recipe for readability reasons, as there are quite a number of types involved. The type constraints used should illustrate how the types are used pretty well [18 to 20]:</p>
<pre style="padding-left: 30px">where<br/>    FunOne: Fn(Input) -&gt; Intermediate,<br/>    FunTwo: Fn(Intermediate) -&gt; Output,</pre>
<p><kbd>FunOne</kbd> is a closure that takes an <kbd>Input</kbd>, turns it into an <kbd>Intermediate</kbd>, and passes it to <kbd>FunTwo</kbd>, which returns an <kbd>Output</kbd>. As you can see from the implementation, the only thing we do is call <kbd>fun_one</kbd> on a value, and then call <kbd>fun_two</kbd> on its returned value [22]:</p>
<pre style="padding-left: 30px">move |x| fun_two(fun_one(x))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Accepting a variable number of arguments</em> recipe in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Filtering strings efficiently</h1>
                
            
            
                
<p class="mce-root">While you can filter characters out of a <kbd>String</kbd> on the stable channel already, this requires creating a new <kbd>String</kbd> with the filtered characters. On <kbd>nightly</kbd>, you can do this in place of the same <kbd>String</kbd>, helping you a lot with performance if you need to perform this kind of action many, many times, or on very large strings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>retain_string.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo run --bin retain_string</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(string_retain)]
2   
3   fn main() {
4     let mut some_text = "H_el_l__o_ ___Wo_r__l_d_".to_string();
5     println!("Original text: {}", some_text);
6     // retain() removes all chars that don't fulfill a
7     // predicate in place, making it very efficient
8     some_text.retain(|c| c != '_');
9     println!("Text without underscores: {}", some_text);
10    some_text.retain(char::is_lowercase);
11    println!("Text with only lowercase letters: {}", some_text);
12  
13    // Before retain, you had to filter the string as an iterator <br/>      over chars
14    // This will however create a new String, generating overhead
15    let filtered: String = "H_el_l__o_ ___Wo_r__l_d_"
16      .chars()
17      .filter(|c| *c != '_')
18      .collect();
19    println!("Text filtered by an iterator: {}", filtered);
20  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">In <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em>; <em>Using a Vector</em>, we learned about <kbd>Vec::retain</kbd>, which filters a vector in place. On the <kbd>nightly</kbd> toolchain, this functionality has arrived in <kbd>String</kbd> and works the same way, as if a <kbd>String</kbd> was a <kbd>Vec&lt;char&gt;—</kbd>which, if you think about it, it really is.</p>
<p>The functionality of filtering a <kbd>String</kbd> was always there, but it required going over the string as an <kbd>Iterator</kbd> and creating a new <kbd>String</kbd> with the filtered characters; or worse yet, converting a <kbd>String</kbd> to a newly-created <kbd>Vec&lt;char&gt;</kbd>, using <kbd>retain</kbd> on it, and then converting the chars back into another newly-created <kbd>String</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Using a vector</em> recipe in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Stepping through an iterator in regular intervals</h1>
                
            
            
                
<p class="mce-root">Have you ever wanted to step through data by only looking at every nth item? On stable Rust, the best solution to this problem is using the third-party crate <kbd>itertools</kbd> (<a href="https://crates.io/crates/itertools">https://crates.io/crates/itertools</a>), which brings you a whole lot of iterator goodies, or allows you to code the functionality yourself; however, you have a built-in <kbd>step_by</kbd> method doing exactly this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>iterator_step_by.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo run --bin iterator_step_by</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(iterator_step_by)]
2   
3   fn main() {
4     // step_by() will start on the first element of an iterator,
5     // but then skips a certain number of elements on every  <br/>      iteration
6     let even_numbers: Vec&lt;_&gt; = (0..100).step_by(2).collect();
7     println!("The first one hundred even numbers: {:?}",  <br/>      even_numbers);
8   
9     // step_by() will always start at the beginning.
10    // If you need to skip the first few elements as well, use  <br/>      skip()
11    let some_data = ["Andrei", "Romania", "Giuseppe", "Italy",  <br/>      "Susan", "Britain"];
12    let countries: Vec&lt;_&gt; =  <br/>      some_data.iter().skip(1).step_by(2).collect();
13    println!("Countries in the data: {:?}", countries);
14  
15    let grouped_stream = "Aaron 182cm 70kg Alice 160cm 90kg Bob <br/>      197cm 83kg";
16    let weights: Vec&lt;_&gt; = grouped_stream
17      .split_whitespace()
18      .skip(2)
19      .step_by(3)
20      .collect();
21    println!("The weights of the people are: {:?}", weights);
22  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">This recipe shines when you are being handed an unstructured data stream that follows a certain pattern. For example, sometimes some old APIs that don't use JSON, or other programs you might want to interact with, hand you streams of data that are grouped by position, like the data we stored in <kbd>grouped_stream</kbd>[15], which follows the following pattern:</p>
<pre style="padding-left: 30px">person0 height0 weight0 person1 height1 weight1 person2 height2 weight2</pre>
<p><kbd>step_by</kbd> lets us parse this structure very easily. It works by handing you current element, and then skipping a certain amount of elements on every iteration. In our example, we parse <kbd>grouped_stream</kbd> by first creating an iterator over every substring that is not whitespace with <kbd>split_whitespace</kbd> [17], then, because we are only interested in the weights, <kbd>skip</kbd> the first two elements (<kbd>"Aaron"</kbd> and <kbd>"182cm"</kbd>), which places our iterator at <kbd>"70kg"</kbd>. We then tell the iterator to only look at every third element from now on with <kbd>step_by(3)</kbd> [19], resulting in us iterating over <kbd>"70kg"</kbd>, <kbd>"90kg"</kbd>, and <kbd>"83kg"</kbd>. Finally, we <kbd>collect</kbd> the elements into a vector [20].</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Using a string</em> and <em>Accessing collections as iterators</em> recipes in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benchmarking your code</h1>
                
            
            
                
<p class="mce-root">The Rust project has developed a testing crate for the compiler itself. Because it includes some quite useful features, most importantly a benchmarker, it is accessible on nightly builds as the built-in <kbd>test</kbd> crate. Because it gets shipped with every nightly build, you don't need to add it to your <kbd>Cargo.toml</kbd> to use it.</p>
<p class="mce-root">The <kbd>test</kbd> crate is marked unstable because of its tight coupling to the compiler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>benchmarking.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo bench</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(test)]
2   // The test crate was primarily designed for
3   // the Rust compiler itself, so it has no stability guaranteed
4   extern crate test;
5   
6   pub fn slow_fibonacci_recursive(n: u32) -&gt; u32 {
7     match n {
8       0 =&gt; 0,
9       1 =&gt; 1,
10      _ =&gt; slow_fibonacci_recursive(n - 1) +  <br/>        slow_fibonacci_recursive(n - 2),
11    }
12  }
13  
14  pub fn fibonacci_imperative(n: u32) -&gt; u32 {
15    match n {
16      0 =&gt; 0,
17      1 =&gt; 1,
18      _ =&gt; {
19        let mut penultimate;
20        let mut last = 1;
21        let mut fib = 0;
22        for _ in 0..n {
23          penultimate = last;
24          last = fib;
25          fib = penultimate + last;
26        }
27        fib
28      }
29    }
30  }
31  
32  pub fn memoized_fibonacci_recursive(n: u32) -&gt; u32 {
33    fn inner(n: u32, penultimate: u32, last: u32) -&gt; u32 {
34      match n {
35        0 =&gt; penultimate,
36        1 =&gt; last,
37        _ =&gt; inner(n - 1, last, penultimate + last),
38      }
39    }
40    inner(n, 0, 1)
41  }
42  
43  pub fn fast_fibonacci_recursive(n: u32) -&gt; u32 {
44    fn inner(n: u32, penultimate: u32, last: u32) -&gt; u32 {
45      match n {
46        0 =&gt; last,
47        _ =&gt; inner(n - 1, last, penultimate + last),
48      }
49    }
50    match n {
51      0 =&gt; 0,
52      _ =&gt; inner(n - 1, 0, 1),
53    }
54  }</pre>
<ol start="4">
<li>Running benchmarks:</li>
</ol>
<pre style="padding-left: 60px">56  #[cfg(test)]
57  mod tests {
58    use super::*;
59    use test::Bencher;
60  
61    // Functions annotated with the bench attribute will
62    // undergo a performance evaluation when running "cargo bench"
63    #[bench]
64    fn bench_slow_fibonacci_recursive(b: &amp;mut Bencher) {
65      b.iter(|| {
66        // test::block_box is "black box" for the compiler and   <br/>          LLVM
67        // Telling them to not optimize a variable away
68        let n = test::black_box(20);
69        slow_fibonacci_recursive(n)
70      });
71    }
72  
73    #[bench]
74    fn bench_fibonacci_imperative(b: &amp;mut Bencher) {
75      b.iter(|| {
76        let n = test::black_box(20);
77        fibonacci_imperative(n)
78      });
79    }
80  
81    #[bench]
82    fn bench_memoized_fibonacci_recursive(b: &amp;mut Bencher) {
83      b.iter(|| {
84        let n = test::black_box(20);
85        memoized_fibonacci_recursive(n)
86      });
87    }
88  
89    #[bench]
90    fn bench_fast_fibonacci_recursive(b: &amp;mut Bencher) {
91      b.iter(|| {
92        let n = test::black_box(20);
93        fast_fibonacci_recursive(n)
94      });
95    }
96  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The bread and butter of the <kbd>test</kbd> crate is the <kbd>Bencher</kbd> struct [59]. An instance of it is passed automatically to every function annotated with the <kbd>#[bench]</kbd> attribute [63] when running <kbd>cargo bench</kbd>. Its <kbd>iter</kbd> method takes a closure [65], and runs it multiple times to determine how long one iteration of it takes. While doing this, it also discards time measurements that are far off the others to eliminate one-off extremes.</p>
<p>Another useful part of the <kbd>test</kbd> crate is its <kbd>black_box</kbd> struct [68], which wraps any value and tells the compiler and LLVM to not optimize it away, no matter what. If we didn't use it in our benchmarks, they might get optimized away and result in a rather optimistic and unhelpful measurement of 0 ns/iter, or zero nanoseconds per execution of the closure.</p>
<p>We can use the tools at our disposal to test out some theories. Remember the recursive <strong>Fibonacci</strong> implementation discussed in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em>; <em>Running two operations together</em>? Well, it is repeated here as <kbd>slow_fibonacci_recursive</kbd>[6].</p>
<p>This implementation is slow because both calls to <kbd>slow_fibonacci_recursive(n - 1)</kbd> and  <kbd>slow_fibonacci_recursive(n - 2)</kbd> need to recalculate <em>all</em> values individually. Worse yet, every call also splits up into a call to <kbd>slow_fibonacci_recursive(n - 1)</kbd> and  <kbd>slow_fibonacci_recursive(n - 2)</kbd> once more, recalculating everything again and again! In terms of <em>Big O</em>, this is an efficiency of <img class="fm-editor-equation" src="img/f67731c7-d87b-4a16-aa3c-756bc09bec79.png" style="width:3.25em;height:1.17em;"/> (proof at <a href="https://stackoverflow.com/a/360773/5903309">https://stackoverflow.com/a/360773/5903309</a>). In comparison, the imperative algorithm, <kbd>fibonacci_imperative</kbd> [14] is a simple loop, so it's at <img class="fm-editor-equation" src="img/2dafef58-b819-4df9-bb92-6dcbb8defb4e.png" style="width:2.08em;height:1.17em;"/>. By this theory, it should be <em>a lot</em> faster than the slow, recursive one. Running <kbd>cargo bench</kbd> lets us verify these assertions easily:</p>
<div><img src="img/10c2847a-9095-4c00-bdb2-1c84cd3364e1.png"/></div>
<p>What a difference! On my computer, the slow, recursive implementation is more than 7,000 times slower than the imperative one! Surely, we can do better.</p>
<p><strong>StackOverflow</strong> user <strong>Boiethios</strong> helpfully provided us with <kbd>memoized_fibonacci_recursive</kbd> at <a href="https://stackoverflow.com/a/49052806/5903309">https://stackoverflow.com/a/49052806/5903309</a>. As the name suggests, this implementation uses a concept known as <em>memoization</em>. This means that the algorithm has some way of passing around already-calculated values. An easy way of doing this would be to pass around a <kbd>HashMap</kbd> with all calculated values, but that would again bring its own overhead, as it operates on the heap. Instead, we go for the route of <em>accumulators</em>. This means that we just pass the relevant values directly as parameters, which in our case are <kbd>penultimate</kbd>, which represents the Fibonacci of <kbd>n-2</kbd>, and <kbd>last</kbd>, which represents the Fibonacci of <kbd>n-1</kbd>. If you want to read more about these functional concepts, check out <a href="http://www.idryman.org/blog/2012/04/14/recursion-best-practices/">http://www.idryman.org/blog/2012/04/14/recursion-best-practices/</a>.</p>
<p>Checking the benchmarks, we can see that we managed to improve the algorithm quite a bit with <kbd>memoized_fibonacci_recursive</kbd>. But it's still a bit slower than <kbd>fibonacci_imperative</kbd>. One of many possible ways to further improve the algorithm is by extracting the <kbd>n == 1</kbd> match that would be checked in every recursive call outside, as demonstrated in <kbd>fast_fibonacci_recursive</kbd> [43], which clocks in at a great three nanoseconds per iteration!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Our implementation also employs another optimization: <em>tail call</em> <em>optimization</em>, or <em>TCO</em> for short. In oversimplified terms, TCO happens when the compiler is able to rewrite a recursive algorithm into an imperative one. More generally, TCO is when the compiler can compile a recursive call into a form that doesn't add a new stack frame per call, and as a consequence, can't cause a stack overflow (not the website, but the error). For a good discussion on the topic, see <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">https://stackoverflow.com/questions/310974/what-is-tail-call-optimization</a>.</p>
<p>Although Rust doesn't support TCO per se (see the RFC at <a href="https://github.com/rust-lang/rfcs/issues/271">https://github.com/rust-lang/rfcs/issues/271</a>), the lower-level LLVM does. It requires the last call of a function to be a call to itself. The last line of <kbd>inner</kbd> [40] is a call to <kbd>inner</kbd>, so it's eligible for TCO.</p>
<p>This is somewhat hard to guarantee in bigger Rust algorithms, though, as objects implementing the <kbd>Drop</kbd> trait will inject a call to <kbd>drop()</kbd> at the end of a function, removing any possibility of TCO.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Running two operations together</em> recipe in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using generators</h1>
                
            
            
                
<p class="mce-root">The biggest concept that is still not quite usable yet in Rust is <em>easy async</em>. One reason for that is a lack of compiler support for certain things, which is being worked on right now. One important part of the road to async is <em>generators</em>, which are implemented similarly to how they're used in C# or Python.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</li>
<li>In the <kbd>bin</kbd> folder, create a file called <kbd>generator.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin generator</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   #![feature(generators, generator_trait,  <br/>    conservative_impl_trait)]
2   
3   fn main() {
4     // A closure that uses the keyword "yield" is called a <br/>      generator
5     // Yielding a value "remembers" where you left off
6     // when calling .resume() on the generator
7     let mut generator = || {
8       yield 1;
9       yield 2;
10    };
11    if let GeneratorState::Yielded(value) = generator.resume() {
12      println!("The generator yielded: {}", value);
13    }
14    if let GeneratorState::Yielded(value) = generator.resume() {
15      println!("The generator yielded: {}", value);
16    }
17    // When there is nothing left to yield,
18    // a generator will automatically return an empty tuple
19    if let GeneratorState::Complete(value) = generator.resume() {
20      println!("The generator completed with: {:?}", value);
21    }
22  
23    // At the moment, you can return a different type
24    // than you yield, although this feature is considered for  <br/>      removal
25    let mut generator = || {
26      yield 100;
27      yield 200;
28      yield 300;
29      "I'm a string"
30    };
31    loop {
32      match generator.resume() {
33        GeneratorState::Yielded(value) =&gt; println!("The generator   <br/>          yielded: {}", value),
34        GeneratorState::Complete(value) =&gt; {
35          println!("The generator completed with: {}", value);
36          break;
37        }
38      }
39    }
40  
41    // Generators are great for implementing iterators.
42    // Eventually, all Rust iterators are going to be rewritten <br/>      with generators
43    let fib: Vec&lt;_&gt; = fibonacci().take(10).collect();
44    println!("First 10 numbers of the fibonacci sequence: {:?}", <br/>      fib);
45  }
46  
47  // As of the time of writing, a generator does not have a
48  // direct conversion to an iterator yet, so we need a wrapper:
49  use std::ops::{Generator, GeneratorState};
50  struct GeneratorIterator(T);
51  impl Iterator for GeneratorIterator
52  where
53    T: Generator,
54  {
55    type Item = T::Yield;
56    fn next(&amp;mut self) -&gt; Option {
57      match self.0.resume() {
58        GeneratorState::Yielded(value) =&gt; Some(value),
59        GeneratorState::Complete(_) =&gt; None,
60      }
61    }
62  }
63  
64  fn fibonacci() -&gt; impl Iterator {
65    // Using our wrapper
66    GeneratorIterator(move || {
67      let mut curr = 0;
68      let mut next = 1;
69      loop {
70        yield curr;
71        let old = curr;
72        curr = next;
73        next += old;
74      }
75    })
76  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A <kbd>Generator</kbd> is currently defined as any closure that uses the new <kbd>yield</kbd> keyword. When it is executed with <kbd>.resume()</kbd> [11], it will run until it hits a <kbd>yield</kbd>. If run again, the generator will continue where it left off until it reaches another <kbd>yield</kbd> or encounters a <kbd>return</kbd>. If there are no more yields left in the generator, it will simply return an empty tuple, behaving as if encountering <kbd>return ();</kbd>.</p>
<p>Because there are two scenarios of what a generator does (<kbd>yield</kbd> vs <kbd>return</kbd>), you have to check the result of <kbd>.resume()</kbd> every time you use it, as it could be <kbd>GeneratorState::Yielded</kbd> or <kbd>GeneratorState::Complete</kbd>.</p>
<p>At the time of writing, you can <kbd>return</kbd> a different type than you <kbd>yield</kbd>. The situation around this is somewhat unclear, as the reason for this quirk is the aforementioned convention to <kbd>return ();</kbd> when running out of yields. Maybe the final version of generators in Rust will not rely on this behavior, and only allow returning the same type as yielding. You can find the discussion about this and more at <a href="https://github.com/rust-lang/rust/issues/43122">https://github.com/rust-lang/rust/issues/43122</a>.</p>
<p>Besides async, another big use case for generators is iterators. So much so that the Rust standard library iterators are planned to eventually be rewritten with generators. At the moment, the exact way of how this transition should happen has not been figured out, so there is no generic implementation of <kbd>Iterator for Generator</kbd>. To work around this, you can create a little wrapper type like we did with <kbd>GeneratorIterator</kbd>[50], which implements <kbd>Iterator</kbd> for its wrapped <kbd>Generator</kbd>.</p>
<p>We illustrate how to use it by rewriting the Fibonacci iterator from <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em>; <em>Creating an own iterator,</em> with a generator in the <kbd>fibonacci</kbd> function [64]. The implementation looks pretty clean, doesn't it? As a reminder, here is how we wrote the original implementation using the <kbd>Iterator</kbd> trait directly, which not only needed a function, but also a <kbd>struct</kbd> and a trait implementation:</p>
<pre style="padding-left: 30px">fn fibonacci() -&gt; Fibonacci {<br/>    Fibonacci { curr: 0, next: 1 }<br/>}<br/>struct Fibonacci {<br/>    curr: u32,<br/>    next: u32,<br/>}<br/>impl Iterator for Fibonacci {<br/>    type Item = u32;<br/>    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {<br/>        let old = self.curr;<br/>        self.curr = self.next;<br/>        self.next += old;<br/>        Some(old)<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Creating an own iterator</em> recipe in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    </body></html>