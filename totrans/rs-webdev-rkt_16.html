<html><head></head><body>
		<div><h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor139"/>Chapter 13</em>: Launching a Rocket Application</h1>
			<p>After development and testing, an important part of development is preparing the application to serve its intended users. In this chapter, we are going to learn some techniques to generate a production-ready binary. After we generate the binary, we are going to learn about configuring the application behind a general-purpose web server. And finally, we will learn how to generate Docker images for a Rocket application.</p>
			<p>After learning the information in this chapter, you will be able to optimize binaries using Rust compiler flags and Cargo configurations. You will also learn techniques to prepare your applications to serve their intended users.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Optimizing production binaries</li>
				<li>Setting up the Apache HTTP Server with a Rocket application</li>
				<li>Generating Docker images for a Rocket application</li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>In this chapter, we are going to serve HTTP requests using the Apache HTTP Server (<a href="https://httpd.apache.org/">https://httpd.apache.org/</a>). If you have a Unix-based operating system, you can usually find the Apache HTTP Server in your operating system package manager. If you have a Windows operating system, there are recommended downloads at the following link: <a href="https://httpd.apache.org/docs/2.4/platform/windows.html">https://httpd.apache.org/docs/2.4/platform/windows.html</a>.</p>
			<p>You also need to generate a TLS (Transport Layer Security) certificate using OpenSSL. If you have a Unix-based operating system, you can usually find the OpenSSL binary using the distribution's package manager. If you have a Windows operating system, you can find the recommended binary at the following link: <a href="https://wiki.openssl.org/index.php/Binaries">https://wiki.openssl.org/index.php/Binaries</a>.</p>
			<p>For generating Docker images, you can use Docker Desktop from the following link: <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>.</p>
			<p>You can find the source code of this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13</a></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Optimizing production binaries</h1>
			<p>After we create the <a id="_idIndexMarker679"/>application, we want to prepare the application to accept a real connection. In software development, there's a production environment, also called a release environment or deployment environment. The production environment contains the configuration of the system and software to make it available to the intended customer. In <a href="B16825_02_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Our First Rocket Web Application</em>, we learned that we can tell the Rust compiler to build release binary when compiling the Rust application. We can use <code>cargo build</code> or <code>cargo run</code> with the extra <code>--release</code> flag.</p>
			<p>To refresh, Cargo will read the configuration in <code>Cargo.toml</code> in the <code>[profile.release]</code> section. There are some compilation optimizations we can do to improve the resulting image: </p>
			<ol>
				<li>The first one is the number of <code>codegen-units</code> of compilation. Rust compilation can take significant time, and to solve this, the compiler may try to split it into parts and compile them in parallel. But, compiling binaries or libraries in parallel might omit some optimization. By default, the number of <code>codegen-units</code> is <code>3</code>. We can sacrifice the compilation speed and make <code>codegen-units</code> into <code>1</code> to optimize the resulting binary further. For example, in <code>Cargo.toml</code>, we can have the following:<pre>[profile.release]
codegen-units = 1</pre></li>
			</ol>
			<p><code>codegen</code> backend, LLVM, can perform various LTOs to produce output with optimized code. To enable LTO, we can set <code>lto = yes</code> or <code>lto = "fat"</code>. The following is an example of <code>lto</code> in <code>Cargo.toml</code>:</p>
			<pre>[profile.release]
lto = "fat"</pre>
			<p>Set the optimization level. We can set optimization levels from <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>, with the default value being <code>0</code> (no optimization) up to <code>3</code> (all optimization) as in the following:</p>
			<pre>[profile.release]
opt-level = 3</pre>
			<p>Besides optimization level <code>0</code> to <code>3</code>, we can also also set <code>"s"</code> and <code>"z"</code>, with <code>"s"</code> for binary size optimization and <code>"z"</code> for binary size optimization and turn of loop vectorization.</p>
			<p>Disable <code>panic</code> unwinding. We can set <code>panic</code> to not show the stack trace. The result is a more optimized binary. Set the following in <code>Cargo.toml</code> to disable stack unwinding:</p>
			<pre>[profile.release]
panic = "abort"</pre>
			<ol>
				<li value="2">The second optimization is compiling the correct architecture. CPU producers will always create a new <a id="_idIndexMarker681"/>CPU with better optimization or instruction sets that can improve the performance of an application. For example, the SSE (Streaming SIMD Extensions) instruction set was introduced by Intel with the release of Intel Pentium III. </li>
			</ol>
			<p>By default, the Rust compiler will produce binary with a reasonable amount of CPU support. But, this means newer instruction sets or optimizations are not used when compiling a library or a binary. We can tell the Rust compiler to produce a binary that supports newer optimizations or instruction sets of the target machine. </p>
			<p>To see the list of the target architecture supported by the Rust compiler, we can use this command:</p>
			<pre><strong class="bold">rustc --print target-cpus</strong></pre>
			<p>For example, if we know the target machine is AMD Ryzen, which supports <em class="italic">znver3</em> architecture, we can compile the Rust program as follows:</p>
			<pre><strong class="bold">RUSTFLAGS='-C target-cpu=znver -C codegen-units=1' cargo build –release</strong></pre>
			<p>The reason we use the <code>RUSTFLAGS</code> environment variable is that <code>target-cpu</code> is not a recognized option in <code>Cargo.toml</code>. Cargo will also use any other <code>rustc</code> option <a id="_idIndexMarker682"/>set in the <code>RUSTFLAGS</code> environment variable.</p>
			<p>Now we <a id="_idIndexMarker683"/>know how to compile a Rust <a id="_idIndexMarker684"/>application for a production environment, let's learn about deploying a Rocket application behind a web server.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor142"/>Setting up the Apache HTTP Server with a Rocket application</h1>
			<p>We know that Rocket has TLS support in its configuration, so we can set the TCP port to <code>443</code>, the default HTTPS connection port. In some cases, it might be acceptable to run web applications directly, for example, when we want to serve content for microservices. </p>
			<p>One of the reasons why we don't want to run the Rocket application directly is because of this warning in the Rocket guide:</p>
			<p class="author-quote">Rocket's built-in TLS implements only TLS 1.2 and 1.3. It may not be suitable for production use.</p>
			<p>The TLS library used by the Rocket framework might not be suitable for production use for various reasons, such as security reasons or it is not yet audited.</p>
			<p>There are other reasons why we do not want to serve content directly from Rocket aside from the TLS library problem. One example is when we want to serve multiple applications from a single computer. We might want to serve PHP applications from the same machine too.</p>
			<p>One of the techniques people use when serving a Rust application is putting it behind a general-purpose web server that can do a reverse proxy:</p>
			<div><div><img src="img/Figure_13.1_B16825.jpg" alt="Figure 13.1 ‒ General purpose web server performing a reverse proxy on a Rocket application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 ‒ General purpose web server performing a reverse proxy on a Rocket application</p>
			<p>One of the most used reverse proxy applications is the Apache HTTP Server. The Apache HTTP Server also has other features besides the reverse proxy, including serving static files and compressing files to serve requests faster.</p>
			<p>Let's try <a id="_idIndexMarker685"/>serving<a id="_idIndexMarker686"/> our application using the Apache HTTP Server and configuring the server to act as a reverse proxy by following these steps:</p>
			<ol>
				<li value="1">Download the Apache HTTP Server for your operating system or from <a href="https://httpd.apache.org/">https://httpd.apache.org/</a>. </li>
				<li>Try starting the application using the following command line:<pre><strong class="bold">sudo apachectl -k start</strong></pre></li>
				<li>The Apache HTTP Server's default port is <code>8080</code>. Check that Apache is running by using the cURL command:<pre><strong class="bold">curl http://127.0.0.1:8080/</strong></pre></li>
				<li>The Apache HTTP Server's functionalities can be extended by modules, and several modules are installed alongside it. We want to enable several modules to enable HTTP requests to our application using a reverse proxy. Find <code>httpd.conf</code>, the configuration file for your operating system. In some Linux distributions, the configuration might be in <code>/etc/httpd/httpd.conf</code>. In other distributions or operating systems, the file location might be in <code>/usr/local/etc/httpd/httpd.conf</code>.</li>
			</ol>
			<p>Edit the <code>httpd.conf</code> file<a id="_idIndexMarker687"/> and <a id="_idIndexMarker688"/>remove the comment to enable the required modules:</p>
			<pre>LoadModule log_config_module libexec/apache2/mod_log_config.so
LoadModule vhost_alias_module libexec/apache2/mod_vhost_alias.so
LoadModule socache_shmcb_module libexec/apache2/mod_socache_shmcb.so
LoadModule ssl_module libexec/apache2/mod_ssl.so
LoadModule xml2enc_module libexec/apache2/mod_xml2enc.so
LoadModule proxy_html_module libexec/apache2/mod_proxy_html.so
LoadModule proxy_module libexec/apache2/mod_proxy.so
LoadModule proxy_connect_module libexec/apache2/mod_proxy_connect.so
LoadModule proxy_http_module libexec/apache2/mod_proxy_http.so</pre>
			<ol>
				<li value="5">In the same <code>httpd.conf</code> file, find these lines and uncomment these lines as well: <pre>Include /usr/local/etc/httpd/extra/httpd-vhosts.conf
Include /usr/local/etc/httpd/extra/httpd-ssl.conf
Include /usr/local/etc/httpd/extra/proxy-html.conf</pre></li>
				<li>We need a server name. In a real server, we can acquire a domain by buying the rights to it from a domain registrar and pointing the <code>ourapplication.example.net</code>. Edit <code>/etc/hosts</code> and some test domains as follows:<pre>127.0.0.1 ourapplication.example.net</pre></li>
				<li>Install <code>openssl</code> for your operating system. After that, generate a certificate for <code>ourapplication.example.net</code> using the <code>openssl</code> command line, as <a id="_idIndexMarker689"/>in <a id="_idIndexMarker690"/>the following: <pre><strong class="bold">openssl req -x509 -out ourapplication.example.com.crt -keyout ourapplication.example.com.key \</strong>
<strong class="bold">  -newkey rsa:2048 -nodes -sha256 \</strong>
<strong class="bold">  -subj '/CN=ourapplication.example.com' -extensions </strong>
<strong class="bold">  EXT -config &lt;( \</strong>
<strong class="bold">   printf "[dn]\nCN=ourapplication.example</strong>
<strong class="bold">  .com\n[req]\ndistinguished_name = dn\n[EXT]\</strong>
<strong class="bold">  nsubjectAltName=DNS:ourapplication.</strong>
<strong class="bold">  example.com\nkeyUsage=digitalSignature\</strong>
<strong class="bold">  nextendedKeyUsage=serverAuth")</strong></pre></li>
			</ol>
			<p>The command line will generate two files, <code>ourapplication.example.com.crt</code> and <code>ourapplication.example.com.key</code>. </p>
			<ol>
				<li value="8">Generate a PEM file, a file format that contains certificate as follows:<pre>openssl rsa -in ourapplication.example.com.key -text &gt; ourapplication.example.com.private.pem
openssl x509 -inform PEM -in ourapplication.example.com.crt &gt; ourapplication.example.com.public.pem </pre></li>
				<li>Edit <code>httpd-vhosts.conf</code>. The file might be in <code>/usr/local/etc/httpd/extra/</code>, depending on your operating system configuration. Add a new virtual host. We want the virtual host to point to our Rocket application <a id="_idIndexMarker691"/>at <code>http://127.0.0.1:8000</code>. Add the <a id="_idIndexMarker692"/>following lines:<pre>&lt;VirtualHost *:443&gt;
    ServerName ourapplication.example.com
    SSLEngine On
    SSLCertificateFile /usr/local/etc/httpd/
    ourapplication.example.com.public.pem
    SSLCertificateKeyFile /usr/local/etc/httpd/
    ourapplication.example.com.private.pem
    SSLProxyEngine On
    ProxyRequests Off
    ProxyVia Off
    &lt;Proxy *&gt;
         Require all granted
    &lt;/Proxy&gt;
    ProxyPass "/" "http://127.0.0.1:8000/"
    ProxyPassReverse "/" "http://127.0.0.1:8000/"
&lt;/VirtualHost&gt;</pre></li>
				<li>Check whether the configuration is correct by running the following command:<pre>sudo apachectl configtest</pre></li>
				<li>Restart and open <a href="https://ourapplication.example.com">https://ourapplication.example.com</a> in your web browser. The web browser might complain because the root certificate is unknown. We can add our generated certificate so it's accepted in our browser. For example, in Firefox, we can go to <strong class="bold">Preferences</strong> | <strong class="bold">Privacy &amp; Security</strong> | <strong class="bold">View Certificates</strong>. After that, choose <strong class="bold">Servers Tab</strong> and click <strong class="bold">Add Exception</strong>. Then, ensure that <strong class="bold">Permanently store this exception</strong> is checked. Finally, click on <strong class="bold">Confirm Security Exception</strong> to store the security exception. If everything goes well, we can use the <a id="_idIndexMarker693"/>example domain in <a id="_idIndexMarker694"/>the browser, as in the following figure:</li>
			</ol>
			<div><div><img src="img/Figure_13.2_B16825.jpg" alt="Figure 13.2 ‒ Using a domain and TLS certificate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 ‒ Using a domain and TLS certificate</p>
			<p>Now that we have deployed the Rocket application behind a reverse proxy, we can use the same principle with a real server. Set up the Apache HTTP Server or NGINX as a reverse proxy and run the Rocket application behind the reverse proxy.</p>
			<p>To run the Rocket application automatically when the operating system starts, we can set up some kind of service for the operating system. If we are running a Linux distribution with systemd as a service manager, for example, we can create a <code>systemd</code> service file and run the application automatically.</p>
			<p>In the next section, we are going to learn a different way to deploy an application. We are going to <a id="_idIndexMarker695"/>use<a id="_idIndexMarker696"/> Docker to package and create a Docker container for our Rocket application.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor143"/>Generating Docker images for a Rocket application</h1>
			<p>Containerization<a id="_idIndexMarker697"/> has been a popular choice<a id="_idIndexMarker698"/> to ship production applications for a while. One of the most popular applications for containerization is Docker. In this section, we are going to learn how to set up Docker to run our Rocket application. To use the <code>docker</code> command line, please install Docker Desktop from <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>.</p>
			<p>Follow these steps to create and run a Docker image of the Rocket application:</p>
			<ol>
				<li value="1">In the root folder of the application, create a Dockerfile.</li>
				<li>There are some base images we can use to build and run the application. We are going to use Rust's official Docker image from <a href="https://hub.docker.com/_/rust">https://hub.docker.com/_/rust</a>. For the Linux distribution, we are going to use <em class="italic">Alpine base</em> because it's one of the smallest base images for Docker.</li>
			</ol>
			<p>In the Dockerfile, add the first line:</p>
			<pre>FROM rust:alpine as prepare-stage</pre>
			<ol>
				<li value="3">Set the working directory. Append this line to the Dockerfile:<pre>WORKDIR /app</pre></li>
				<li>We can use Cargo to install the dependencies, but there is another way to quickly compile the application. We can vendorize the dependencies and use the vendor dependencies to build the application. Run this command on the root folder of the application source code:<pre><strong class="bold">cargo vendor</strong></pre></li>
				<li>We want to override the source of the dependencies from the internet to the vendor folder. Create a <code>.cargo</code> folder in the root application folder, and create <code>config.toml</code> inside the <code>.cargo</code> folder.</li>
			</ol>
			<p>Append these lines to the <code>.cargo/config.toml</code> file:</p>
			<pre>[source.crates-io]
replace-with = "vendored-sources"
[source.vendored-sources]
directory = "vendor"</pre>
			<ol>
				<li value="6">We want to add the required files to build the application as a Docker image. We don't need <code>Rocket.toml</code>, templates, or static files to build the application. Append these lines to the Dockerfile:<pre>COPY src src
COPY Cargo.toml Cargo.toml
COPY .cargo .cargo
COPY vendor vendor</pre></li>
				<li>Add the <a id="_idIndexMarker699"/>instructions<a id="_idIndexMarker700"/> to build the image. We want to use another stage and install the dependencies to build the image. Add the following lines:<pre>FROM prepare-stage as build-stage
RUN apk add --no-cache musl-dev
RUN cargo build --release</pre></li>
				<li>Try building the application by running the following command:<pre><strong class="bold">docker build .</strong></pre></li>
				<li>After testing, add a new part to run the application in the Dockerfile. We want to open port <code>8000</code>. We also want to add a default time zone and configure the user to run the application. Append the following lines: <pre>FROM rust:alpine
EXPOSE 8000
ENV TZ=Asia/Tokyo \
    USER=staff
RUN addgroup -S $USER \
    &amp;&amp; adduser -S -g $USER $USER</pre></li>
				<li>We want the image to have the latest libraries. Append the following lines to the Dockerfile:<pre>RUN apk update \
    &amp;&amp; apk add --no-cache ca-certificates tzdata \
    &amp;&amp; rm -rf /var/cache/apk/*</pre></li>
				<li>Set the working directory. Append the following line to the Dockerfile:<pre>WORKDIR /app</pre></li>
				<li>Set <code>Rocket.toml</code> to<a id="_idIndexMarker701"/> run <a id="_idIndexMarker702"/>from <code>0.0.0.0</code>. We want to tell the application to use the host's running database. In Docker, we can reference the host machine using a special domain, host.docker.internal. Edit <code>Rocket.toml</code> as follows:<pre>[default.databases.main_connection]
url = "postgres://username:passwordR@host.docker.internal:5432/rocket"
[release]
address = "0.0.0.0"</pre></li>
				<li>Copy the resulting binary, <code>Rocket.toml</code>, assets, and templates to the final image. Append the following lines to the Dockerfile:<pre>COPY --from=build-stage /app/target/release/our_application our_application
COPY Rocket.toml Rocket.toml
COPY static static
COPY src/views src/views</pre></li>
				<li>Add the folder to store the log file:<pre>RUN mkdir logs</pre></li>
				<li>Add changing permission to <code>$USER</code> as follows:<pre>RUN chown -R $USER:$USER /app</pre></li>
				<li>Finally, run<a id="_idIndexMarker703"/> the<a id="_idIndexMarker704"/> entry point to the application to the Dockerfile:<pre>USER $USER
CMD ["./our_application"]</pre></li>
				<li>Build the image and create a tag for it using this command:<pre><strong class="bold">docker build -t our_application .</strong></pre></li>
				<li>After building the Docker image, it's time to run it. Use the following command line:<pre><strong class="bold">docker run --add-host host.docker.internal:host-gateway -dp 8000:8000 our_application</strong></pre></li>
			</ol>
			<p>After everything is done, we should see the Docker container is running and showing the <code>our_application</code> output:</p>
			<div><div><img src="img/Figure_13.3_B16825.jpg" alt="Figure 13.3 ‒ Docker Desktop showing the running container and our_application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 ‒ Docker Desktop showing the running container and our_application</p>
			<p>Deploying a Rocket application using Docker is just like deploying other applications. We need to copy the source, build, and run the resulting image. There are some actions that we can perform<a id="_idIndexMarker705"/> to ensure proper deployment, such <a id="_idIndexMarker706"/>as vendoring the libraries and opening the correct ports to ensure requests can be made to the running container and applications running inside the container.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Summary</h1>
			<p>In this chapter, we have learned about production-ready compilation options. We can use them to ensure the resulting binary is as optimized as possible. We also learned about setting up a general-purpose HTTP server to work in conjunction with a Rocket application. And finally, we learned to create and run Docker images for the Rocket application.</p>
			<p>After learning these techniques, we expanded them to set up the Rocket application to serve its intended users.</p>
			<p>In the next chapter, we are going to learn about using Rust to create a frontend WebAssembly application in conjunction with a Rocket application.</p>
		</div>
	</body></html>