["```rs\n[dependencies]\nrand = {version = \"0.7\", features = [\"small_rng\"]}\nrand_distr = \"0.2\"\nrand_pcg = \"0.2\"\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use rand::prelude::*;\n    use rand::SeedableRng;\n    use rand_distr::{Bernoulli, Distribution, Normal, Uniform};\n}\n```", "```rs\n    #[test]\n    fn test_rngs() {\n        let mut rng: StdRng = SeedableRng::from_seed([42;32]);\n        assert_eq!(rng.gen::<u8>(), 152);\n\n        let mut small_rng = SmallRng::from_rng(&mut rng).unwrap();\n        assert_eq!(small_rng.gen::<u8>(), 174);\n\n        let mut pcg = rand_pcg::Pcg32::from_rng(&mut rng).unwrap();\n        assert_eq!(pcg.gen::<u8>(), 135);\n    }\n```", "```rs\n    #[test]\n    fn test_sequences() {\n        let mut rng: StdRng = SeedableRng::from_seed([42;32]);\n\n        let emoji = \"ABCDEF\".chars();\n        let chosen_one = emoji.clone().choose(&mut rng).unwrap();\n        assert_eq!(chosen_one, 'B');\n\n        let chosen = emoji.choose_multiple(&mut rng, 3);\n        assert_eq!(chosen, ['F', 'B', 'E']);\n\n        let mut three_wise_monkeys = vec!['1', '2', '3'];\n        three_wise_monkeys.shuffle(&mut rng);\n        three_wise_monkeys.shuffle(&mut rng);\n        assert_eq!(three_wise_monkeys, ['1', '3', '2']);\n\n        let mut three_wise_monkeys = vec!['1', '2', '3'];\n        let partial = three_wise_monkeys.partial_shuffle(&mut rng, 2); \n        assert_eq!(partial.0, ['3', '2']);\n    }\n```", "```rs\n    const SAMPLES: usize = 10_000;\n\n    #[test]\n    fn test_distributions() {\n        let mut rng: StdRng = SeedableRng::from_seed([42;32]);\n\n        let uniform = Uniform::new_inclusive(1, 100);\n        let total_uniform: u32 = uniform.sample_iter(&mut rng)\n                                        .take(SAMPLES).sum();\n        assert!((50.0 - (total_uniform as f32 / (\n                 SAMPLES as f32)).round()).abs() <= 2.0);\n\n        let bernoulli = Bernoulli::new(0.8).unwrap();\n        let total_bernoulli: usize = bernoulli\n            .sample_iter(&mut rng)\n            .take(SAMPLES)\n            .filter(|s| *s)\n            .count();\n\n        assert_eq!(\n            ((total_bernoulli as f32 / SAMPLES as f32) * 10.0)\n                .round()\n                .trunc(),\n            8.0\n        );\n\n        let normal = Normal::new(2.0, 0.5).unwrap();\n        let total_normal: f32 = normal.sample_iter(&mut rng)\n                                      .take(SAMPLES).sum();\n        assert_eq!((total_normal / (SAMPLES as f32)).round(), 2.0);\n    }\n```", "```rs\n$ cargo test\n Compiling random-numbers v0.1.0 (Rust-Cookbook/Chapter10/random-numbers)\n Finished dev [unoptimized + debuginfo] target(s) in 0.56s\n     Running target/debug/deps/random_numbers-df3e1bbb371b7353\n\nrunning 3 tests\ntest tests::test_sequences ... ok\ntest tests::test_rngs ... ok\ntest tests::test_distributions ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests random-numbers\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nuse std::fs::{self, File};\nuse std::io::{self, BufRead, BufReader, BufWriter, Read, Seek, Write};\nuse std::path::Path;\n\nconst TEST_FILE_NAME: &str = \"lorem.txt\";\n```", "```rs\nfn read() -> io::Result<()> {\n    let path = Path::new(TEST_FILE_NAME);\n\n    let input = File::open(path)?;\n    let buffered = BufReader::new(input);\n\n    let words: Vec<usize> = buffered\n        .lines()\n        .map(|line| line.unwrap().split_ascii_whitespace().count())\n        .collect();\n    let avg_word_count = words.iter().sum::<usize>() as f32 / \n     words.len() as f32;\n    println!(\n        \"{}: Average words per line: {:.2}\",\n        path.to_string_lossy(),\n        avg_word_count\n    );\n\n    let mut input = File::open(path)?;\n    let mut input_buffer = String::new();\n    input.read_to_string(&mut input_buffer)?;\n\n    // ... or ...\n\n    let lorem = fs::read_to_string(path)?;\n    println!(\n        \"{}: Length in characters : {}\",\n        path.to_string_lossy(),\n        lorem.len()\n    );\n    // reset file pointer to the beginning\n    input.seek(io::SeekFrom::Start(0))?; \n    println!(\n        \"{}: Length in bytes: {}\",\n        path.to_string_lossy(),\n        input.bytes().count()\n    );\n    Ok(())\n}\n```", "```rs\nfn write() -> io::Result<()> {\n    let mut path = Path::new(\".\").to_path_buf();\n\n    path.push(\"hello.txt\");\n\n    let mut file = File::create(path)?;\n    println!(\"Opened {:?}\", file.metadata()?);\n\n    file.write_all(b\"Hello\")?;\n\n    let mut buffered = BufWriter::new(file);\n    write!(buffered, \" World!\")?;\n    write!(buffered, \"\\n{: >width$}\", width=0x5ff)?;\n    Ok(())\n}\n```", "```rs\nfn main() -> io::Result<()> {\n    println!(\"===== READ =====\");\n    read()?;\n    println!();\n    println!(\"===== WRITE ====\");\n    write()?;\n    Ok(())\n}\n```", "```rs\n$ cargo run\n   Compiling file-stuff v0.1.0 (Rust-Cookbook/Chapter10/file-stuff)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.84s\n     Running `target/debug/file-stuff`\n===== READ =====\nlorem.txt: Average words per line: 42.33\nlorem.txt: Length in characters : 57076\nlorem.txt: Length in bytes: 57076\n\n===== WRITE ====\nOpened Metadata { file_type: FileType(FileType { mode: 33188 }), is_dir: false, is_file: true, permissions: Permissions(FilePermissions { mode: 33188 }), modified: Ok(SystemTime { tv_sec: 1567003873, tv_nsec: 941523976 }), accessed: Ok(SystemTime { tv_sec: 1566569294, tv_nsec: 260780071 }), created: Err(Custom { kind: Other, error: \"creation time is not available on this platform currently\" }) }\n```", "```rs\nMetadata { \n  file_type: FileType(FileType { \n    mode: 33188 \n  }), \n  is_dir: false, \n  is_file: true, \n  permissions: Permissions(FilePermissions { \n    mode: 33188 \n  }), \n  modified: Ok(SystemTime { \n    tv_sec: 1567003873, \n    tv_nsec: 941523976 \n  }), \n  accessed: Ok(SystemTime { \n    tv_sec: 1566569294, \n    tv_nsec: 260780071 \n  }), \n  created: Err(Custom { \n    kind: Other, \n    error: \"creation time is not available on this platform currently\" \n  }) \n}\n```", "```rs\n[dependencies]\nserde = \"1\"\nserde_json =\"1\"\ntoml = \"0.5\"\nserde-pickle = \"0.5\"\nserde_derive = \"1\"\n```", "```rs\n#[macro_use]\nextern crate serde_json;\n\n#[cfg(test)]\nmod tests {\n    use serde_json::Value;\n    use serde_pickle as pickle;\n    use std::fs::File;\n    use toml;\n\n    #[test]\n    fn test_dynamic_json() {\n        let j = r#\"{\n            \"userid\": 103609,\n            \"verified\": true,\n            \"friendly_name\": \"Jason\",\n            \"access_privileges\": [\n              \"user\",\n              \"admin\"\n            ]\n        }\"#;\n\n        let parsed: Value = serde_json::from_str(j).unwrap();\n        let expected = json!({\n          \"userid\": 103609,\n          \"verified\": true,\n          \"friendly_name\": \"Jason\",\n          \"access_privileges\": [\n            \"user\",\n            \"admin\"\n          ]\n        });\n        assert_eq!(parsed, expected);\n\n        assert_eq!(parsed[\"userid\"], 103609);\n        assert_eq!(parsed[\"verified\"], true);\n        assert_eq!(parsed[\"friendly_name\"], \"Jason\");\n        assert_eq!(parsed[\"access_privileges\"][0], \"user\");\n        assert_eq!(parsed[\"access_privileges\"][1], \"admin\");\n        assert_eq!(parsed[\"access_privileges\"][2], Value::Null);\n        assert_eq!(parsed[\"not-available\"], Value::Null);\n    }\n}\n```", "```rs\n    #[test]\n    fn test_dynamic_toml() {\n        let t = r#\"\n            [[user]]\n            userid = 103609\n            verified = true\n            friendly_name = \"Jason\"\n            access_privileges = [ \"user\", \"admin\" ]\n        \"#;\n\n        let parsed: Value = toml::de::from_str(t).unwrap();\n\n        let expected = json!({\n            \"user\": [\n                {\n                    \"userid\": 103609,\n                    \"verified\": true,\n                    \"friendly_name\": \"Jason\",\n                    \"access_privileges\": [\n                        \"user\",\n                        \"admin\"\n                    ]\n                }\n\n            ]\n        });\n        assert_eq!(parsed, expected);\n\n        let first_user = &parsed[\"user\"][0];\n        assert_eq!(first_user[\"userid\"], 103609);\n        assert_eq!(first_user[\"verified\"], true);\n        assert_eq!(first_user[\"friendly_name\"], \"Jason\");\n        assert_eq!(first_user[\"access_privileges\"][0], \"user\");\n        assert_eq!(first_user[\"access_privileges\"][1], \"admin\");\n        assert_eq!(first_user[\"access_privileges\"][2], Value::Null);\n        assert_eq!(first_user[\"not-available\"], Value::Null);\n    }\n```", "```rs\nimport pickle \nimport json\n\ndef main():\n    val = json.loads(\"\"\"{\n            \"userid\": 103609,\n            \"verified\": true,\n            \"friendly_name\": \"Jason\",\n            \"access_privileges\": [\n              \"user\",\n              \"admin\"\n            ]\n        }\"\"\") # load the json string as dictionary\n\n    # open \"user.pkl\" to write binary data (= wb)\n    with open(\"user.pkl\", \"wb\") as out:\n        pickle.dump(val, out) # write the dictionary\n\nif __name__ == '__main__':\n    main()\n```", "```rs\n    #[test]\n    fn test_dynamic_pickle() {\n        let parsed: Value = { \n            let data = File::open(\"user.pkl\")\n                       .expect(\"Did you run create_pickle.py?\");\n            pickle::from_reader(&data).unwrap()\n        };\n\n        let expected = json!({\n          \"userid\": 103609,\n          \"verified\": true,\n          \"friendly_name\": \"Jason\",\n          \"access_privileges\": [\n            \"user\",\n            \"admin\"\n          ]\n        });\n        assert_eq!(parsed, expected);\n\n        assert_eq!(parsed[\"userid\"], 103609);\n        assert_eq!(parsed[\"verified\"], true);\n        assert_eq!(parsed[\"friendly_name\"], \"Jason\");\n        assert_eq!(parsed[\"access_privileges\"][0], \"user\");\n        assert_eq!(parsed[\"access_privileges\"][1], \"admin\");\n        assert_eq!(parsed[\"access_privileges\"][2], Value::Null);\n        assert_eq!(parsed[\"not-available\"], Value::Null);\n    }\n```", "```rs\n$ cargo test\n Compiling dynamic-json v0.1.0 (Rust-Cookbook/Chapter10/dynamic-data)\nwarning: unused `#[macro_use]` import\n --> src/lib.rs:1:1\n |\n1 | #[macro_use]\n | ^^^^^^^^^^^^\n |\n = note: #[warn(unused_imports)] on by default\n\n Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n Running target/debug/deps/dynamic_json-cf635db43dafddb0\n\nrunning 3 tests\ntest tests::test_dynamic_json ... ok\ntest tests::test_dynamic_pickle ... ok\ntest tests::test_dynamic_toml ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n Doc-tests dynamic-json\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n[dependencies]\nregex = \"1\"\n```", "```rs\n#[cfg(test)]\nmod tests {\n\n    use regex::Regex;\n    use std::cell::RefCell;\n    use std::collections::HashMap;\n}\n```", "```rs\n    #[test]\n    fn simple_parsing() {\n        let re = Regex::new(r\"(?P<y>\\d{4})-(\n                           ?P<m>\\d{2})-(?P<d>\\d{2})\").unwrap();\n\n        assert!(re.is_match(\"1999-12-01\"));\n        let date = re.captures(\"2019-02-27\").unwrap();\n\n        assert_eq!(\"2019\", &date[\"y\"]);\n        assert_eq!(\"02\", &date[\"m\"]);\n        assert_eq!(\"27\", &date[\"d\"]);\n\n        let fun_dates: Vec<(i32, i32, i32)> = (1..12)\n                  .map(|i| (2000 + i, i, i * 2)).collect();\n\n        let multiple_dates: String = fun_dates\n            .iter()\n            .map(|d| format!(\"{}-{:02}-{:02} \", d.0, d.1, d.2))\n            .collect();\n\n        for (match_, expected) in re.captures_iter(\n             &multiple_dates).zip(fun_dates.iter()) {\n            assert_eq!(match_.get(1).unwrap().as_str(), \n                       expected.0.to_string());\n            assert_eq!(\n                match_.get(2).unwrap().as_str(),\n                format!(\"{:02}\", expected.1)\n            );\n            assert_eq!(\n                match_.get(3).unwrap().as_str(),\n                format!(\"{:02}\", expected.2)\n            );\n        }\n    }\n```", "```rs\n    #[test]\n    fn reshuffle_groups() {\n        let re = Regex::new(r\"(?P<y>\\d{4})-(\n                 ?P<m>\\d{2})-(?P<d>\\d{2})\").unwrap();\n\n        let fun_dates: Vec<(i32, i32, i32)> = (1..12)\n             .map(|i| (2000 + i, i, i * 2)).collect();\n\n        let multiple_dates: String = fun_dates\n            .iter()\n            .map(|d| format!(\"{}-{:02}-{:02} \", d.0, d.1, d.2))\n            .collect();\n\n        let european_format = re.replace_all(\n                              &multiple_dates, \"$d.$m.$y\");\n\n        assert_eq!(european_format.trim(), \"02.01.2001 04.02.2002 \n                   06.03.2003 08.04.2004 10.05.2005 \n                   12.06.2006 14.07.2007 16.08.2008 \n                   18.09.2009 20.10.2010 22.11.2011\");\n    }\n```", "```rs\n\n    #[test]\n    fn count_groups() {\n        let counter: HashMap<String, i32> = HashMap::new();\n\n        let phone_numbers = \"+49 (1234) 45665\n        +43(0)1234/45665 43\n        +1 314-CALL-ME\n        +44 1234 45665\n        +49 (1234) 44444\n        +44 12344 55538\";\n\n        let re = Regex::new(r\"(\\+[\\d]{1,4})\").unwrap();\n\n        let prefixes = re\n            .captures_iter(&phone_numbers)\n            .map(|match_| match_.get(1))\n            .filter(|m| m.is_some())\n            .fold(RefCell::new(counter), |c, prefix| {\n                {\n                    let mut counter_dict = c.borrow_mut();\n                    let prefix = prefix.unwrap().as_str().to_string();\n                    let count = counter_dict.get(&prefix)\n                                .unwrap_or(&0) + 1;\n                    counter_dict.insert(prefix, count);\n                }\n                c\n            });\n\n        let prefixes = prefixes.into_inner();\n        assert_eq!(prefixes.get(\"+49\"), Some(&2));\n        assert_eq!(prefixes.get(\"+1\"), Some(&1));\n        assert_eq!(prefixes.get(\"+44\"), Some(&2));\n        assert_eq!(prefixes.get(\"+43\"), Some(&1));\n    }\n```", "```rs\n$ cargo test\n Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n Running target/debug/deps/regex-46c0a096a2a4a140\n\nrunning 3 tests\ntest tests::count_groups ... ok\ntest tests::simple_parsing ... ok\ntest tests::reshuffle_groups ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n Doc-tests regex\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n[dependencies]\nglob = \"0.3.0\"\n```", "```rs\nuse glob;\nuse std::error::Error;\nuse std::io;\nuse std::path::{Path, PathBuf};\n\ntype GenericError = Box<dyn Error + Send + Sync + 'static>;\n```", "```rs\nfn walk(dir: &Path, cb: &dyn Fn(&PathBuf), recurse: bool) -> io::Result<()> {\n    for entry in dir.read_dir()? {\n        let entry = entry?;\n        let path = entry.path();\n        if recurse && path.is_dir() {\n            walk(&path, cb, true)?;\n        }\n        cb(&path);\n    }\n    Ok(())\n}\n```", "```rs\nfn walk_glob(pattern: &str, cb: &dyn Fn(&PathBuf)) -> Result<(), GenericError> {\n    for entry in glob::glob(pattern)? {\n        cb(&entry?);\n    }\n    Ok(())\n}\n```", "```rs\nfn main() -> Result<(), GenericError> {\n    let path = Path::new(\"./src\");\n    println!(\"Listing '{}'\", path.display());\n    println!(\"===\");\n    walk(path, &|d| println!(\" {}\", d.display()), true)?;\n    println!();\n\n    let glob_pattern = \"../**/*.rs\";\n    println!(\"Listing by glob filter: {}\", glob_pattern);\n    println!(\"===\");\n    walk_glob(glob_pattern, &|d| println!(\" {}\", d.display()))?;\n    println!();\n\n    let glob_pattern = \"Cargo.*\";\n    println!(\"Listing by glob filter: {}\", glob_pattern);\n    println!(\"===\");\n    walk_glob(glob_pattern, &|d| println!(\" {}\", d.display()))?;\n    Ok(())\n}\n```", "```rs\n$ cargo run\n   Compiling filesystem v0.1.0 (Rust-Cookbook/Chapter10/filesystem)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n     Running `target/debug/filesystem`\nListing './src'\n===\n  ./src/main.rs\n\nListing by glob filter: ../**/*.rs\n===\n  ../command-line-args/src/main.rs\n  ../dynamic-data/src/lib.rs\n  ../file-stuff/src/main.rs\n  ../filesystem/src/main.rs\n  ../logging/src/main.rs\n  ../pipes/src/main.rs\n  ../random-numbers/src/lib.rs\n  ../regex/src/lib.rs\n  ../rusty-ml/src/main.rs\n  ../sub-processes/src/main.rs\n  ../web-requests/src/main.rs\n\nListing by glob filter: Cargo.*\n===\n  Cargo.lock\n  Cargo.toml\n```", "```rs\n[package]\nname = \"list\"\nversion = \"1.0.0\"\nauthors = [\"Claus Matzinger <claus.matzinger+kb@gmail.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nclap = {version= \"2.33\", features = [\"suggestions\", \"color\"]}\n```", "```rs\nuse clap::{App, Arg, SubCommand};\nuse std::fs::DirEntry;\nuse std::path::Path;\n\nuse std::io;\n```", "```rs\nstruct Exclusion(String);\n\nimpl Exclusion {\n    pub fn is_excluded(&self, path: &Path) -> bool {\n        path.file_name()\n            .map_or(false, |f| f.to_string_lossy().find(&self.0).is_some())\n    }\n}\n```", "```rs\nfn walk(\n    dir: &Path,\n    exclusion: &Option<Exclusion>,\n    cb: &dyn Fn(&DirEntry),\n    recurse: bool,\n) -> io::Result<()> {\n    for entry in dir.read_dir()? {\n        let entry = entry?;\n        let path = entry.path();\n        if !exclusion.as_ref().map_or(false, \n                 |e| e.is_excluded(&path)) {\n            if recurse && path.is_dir() {\n                walk(&path, exclusion, cb, true)?;\n            }\n            cb(&entry);\n        }\n    }\n    Ok(())\n}\n```", "```rs\nfn print_if_file(entry: &DirEntry) {\n    let path = entry.path();\n    if !path.is_dir() {\n        println!(\"{}\", path.to_string_lossy())\n    }\n}\nfn print_if_dir(entry: &DirEntry) {\n    let path = entry.path();\n    if path.is_dir() {\n        println!(\"{}\", path.to_string_lossy())\n    }\n}\n```", "```rs\nfn main() -> io::Result<()> {\n    let matches = App::new(\"list\")\n        .version(\"1.0\")\n        .author(\"Claus M - claus.matzinger+kb@gmail.com\")\n        .about(\"\")\n        .arg(\n            Arg::with_name(\"exclude\")\n                .short(\"e\")\n                .long(\"exclude\")\n                .value_name(\"NAME\")\n                .help(\"Exclude directories/files with this name\")\n                .takes_value(true),\n        )\n        .arg(\n            Arg::with_name(\"recursive\")\n                .short(\"r\")\n                .long(\"recursive\")\n                .help(\"Recursively descend into subdirectories\"),\n        )\n```", "```rs\n        .subcommand(\n            SubCommand::with_name(\"files\")\n                .about(\"Lists files only\")\n                .arg(\n                    Arg::with_name(\"PATH\")\n                        .help(\"The path to start looking\")\n                        .required(true)\n                        .index(1),\n                ),\n        )\n        .subcommand(\n            SubCommand::with_name(\"dirs\")\n                .about(\"Lists directories only\")\n                .arg(\n                    Arg::with_name(\"PATH\")\n                        .help(\"The path to start looking\")\n                        .required(true)\n                        .index(1),\n                ),\n        )\n        .get_matches();\n```", "```rs\n    let recurse = matches.is_present(\"recursive\");\n    let exclusions = matches.value_of(\"exclude\")\n                     .map(|e| Exclusion(e.into()));\n```", "```rs\n    match matches.subcommand() {\n        (\"files\", Some(subcmd)) => {\n            let path = Path::new(subcmd.value_of(\"PATH\").unwrap());\n            walk(path, &exclusions, &print_if_file, recurse)?;\n        }\n        (\"dirs\", Some(subcmd)) => {\n            let path = Path::new(subcmd.value_of(\"PATH\").unwrap());\n            walk(path, &exclusions, &print_if_dir, recurse)?;\n        }\n        _ => {}\n    }\n    Ok(())\n}\n```", "```rs\n$ cargo run\n Compiling list v1.0.0 (Rust-Cookbook/Chapter10/command-line-args)\n Finished dev [unoptimized + debuginfo] target(s) in 0.68s\n Running `target/debug/list`\n```", "```rs\n$ cargo run -- help\n    Finished dev [unoptimized + debuginfo] target(s) in 0.03s\n     Running `target/debug/list help`\nlist 1.0\nClaus M - claus.matzinger+kb@gmail.com\n\nUSAGE:\n    list [FLAGS] [OPTIONS] [SUBCOMMAND]\n\nFLAGS:\n    -h, --help Prints help information\n    -r, --recursive Recursively descend into subdirectories\n    -V, --version Prints version information\n\nOPTIONS:\n    -e, --exclude <NAME> Exclude directories/files with this name\n\nSUBCOMMANDS:\n    dirs Lists directories only\n    files Lists files only\n    help Prints this message or the help of the given subcommand(s)\n```", "```rs\n$ cargo run -- dirs \n Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n Running `target/debug/list dirs`\nerror: The following required arguments were not provided:\n <PATH>\n\nUSAGE:\n list dirs <PATH>\n\nFor more information try --help\n```", "```rs\n$ cargo run -- -e \"src\" -r dirs \".\"\n    Finished dev [unoptimized + debuginfo] target(s) in 0.03s\n     Running `target/debug/list -e src -r dirs .`\n./target/debug/native\n./target/debug/deps\n./target/debug/examples\n./target/debug/build/libc-f4756c111c76f0ce/out\n./target/debug/build/libc-f4756c111c76f0ce\n./target/debug/build/libc-dd900fc422222982\n./target/debug/build/bitflags-92aba5107334e3f1\n./target/debug/build/bitflags-cc659c8d16362a89/out\n./target/debug/build/bitflags-cc659c8d16362a89\n./target/debug/build\n./target/debug/.fingerprint/textwrap-a949503c1b2651be\n./target/debug/.fingerprint/vec_map-bffb157312ad2f55\n./target/debug/.fingerprint/bitflags-20c9ba1238fdf359\n./target/debug/.fingerprint/strsim-13cb32b0738f6106\n./target/debug/.fingerprint/libc-63efda3965f75b56\n./target/debug/.fingerprint/clap-062d4c7aff8b8ade\n./target/debug/.fingerprint/unicode-width-62c92f6253cf0187\n./target/debug/.fingerprint/libc-f4756c111c76f0ce\n./target/debug/.fingerprint/libc-dd900fc422222982\n./target/debug/.fingerprint/list-701fd8634a8008ef\n./target/debug/.fingerprint/ansi_term-bceb12a766693d6c\n./target/debug/.fingerprint/bitflags-92aba5107334e3f1\n./target/debug/.fingerprint/bitflags-cc659c8d16362a89\n./target/debug/.fingerprint/command-line-args-0ef71f7e17d44dc7\n./target/debug/.fingerprint/atty-585c8c7510af9f9a\n./target/debug/.fingerprint\n./target/debug/incremental/command_line_args-1s3xsytlc6x5x/s-ffbsjpqyuz-19aig85-4az1dq8f8e3e\n./target/debug/incremental/command_line_args-1s3xsytlc6x5x\n./target/debug/incremental/list-oieloyeggsml/s-ffjle2dbdm-1w5ez6c-13wi8atbsq2wt\n./target/debug/incremental/list-oieloyeggsml\n./target/debug/incremental\n./target/debug\n./target\n```", "```rs\nyear,make,model\n1997,Ford,E350\n1926,Bugatti,Type 35\n1971,Volkswagen,Beetle\n1992,Gurgel,Supermini\n```", "```rs\n[dependencies]\ncsv = \"1.1\"\nserde_json = \"1\"\n```", "```rs\nuse csv;\nuse serde_json as json;\nuse std::io;\n```", "```rs\nfn to_json(headers: &csv::StringRecord, current_row: csv::StringRecord) -> io::Result<json::Value> {\n    let row: json::Map<String, json::Value> = headers\n        .into_iter()\n        .zip(current_row.into_iter())\n        .map(|(key, value)| (key.to_string(), json::Value::String(value.into())))\n        .collect();\n    Ok(json::Value::Object(row))\n}\n```", "```rs\nfn main() -> io::Result<()> {\n    let mut rdr = csv::ReaderBuilder::new()\n        .trim(csv::Trim::All)\n        .has_headers(false)\n        .delimiter(b',')\n        .from_reader(io::stdin());\n\n    let header_rec = rdr\n        .records()\n        .take(1)\n        .next()\n        .expect(\"The first line does not seem to be a valid CSV\")?;\n\n    for result in rdr.records() {\n        if let Ok(json_rec) = to_json(&header_rec, result?) {\n            println!(\"{}\", json_rec.to_string());\n        }\n    }\n    Ok(())\n}\n```", "```rs\n$ cat cars.csv | cargo run\n   Compiling pipes v0.1.0 (Rust-Cookbook/Chapter10/pipes)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.46s\n     Running `target/debug/pipes`\n{\"make\":\"Ford\",\"model\":\"E350\",\"year\":\"1997\"}\n{\"make\":\"Bugatti\",\"model\":\"Type 35\",\"year\":\"1926\"}\n{\"make\":\"Volkswagen\",\"model\":\"Beetle\",\"year\":\"1971\"}\n{\"make\":\"Gurgel\",\"model\":\"Supermini\",\"year\":\"1992\"}\n```", "```rs\n[dependencies]\nsurf = \"1.0\"\nreqwest = \"0.9\"\nserde = \"1\"\nserde_json = \"1\"\nruntime = \"0.3.0-alpha.6\"\n```", "```rs\n#[macro_use]\nextern crate serde_json;\n\nuse surf::Exception;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct MyGetParams {\n    a: u64,\n    b: String,\n}\n```", "```rs\nasync fn test_surf() -> Result<(), Exception> {\n    println!(\"> surf ...\");\n\n    let client = surf::Client::new();\n    let mut res = client\n        .get(\"https://blog.x5ff.xyz/other/cookbook2018\")\n        .await?;\n\n    assert_eq!(200, res.status());\n    assert_eq!(\"Rust is awesome\\n\", res.body_string().await?);\n```", "```rs\n    let form_values = vec![\n        (\"custname\", \"Rusty Crabbington\"),\n        (\"comments\", \"Thank you\"),\n        (\"custemail\", \"rusty@nope.com\"),\n        (\"custtel\", \"+1 234 33456\"),\n        (\"delivery\", \"25th floor below ground, no elevator. sorry\"),\n    ];\n\n    let res_forms: serde_json::Value = client\n        .post(\"https://httpbin.org/post\")\n        .body_form(&form_values)?\n        .recv_json()\n        .await?;\n\n    for (name, value) in form_values.iter() {\n        assert_eq!(res_forms[\"form\"][name], *value);\n    }\n```", "```rs\n    let json_payload = json!({\n        \"book\": \"Rust 2018 Cookbook\",\n        \"blog\": \"https://blog.x5ff.xyz\",\n    });\n\n    let res_json: serde_json::Value = client\n        .put(\"https://httpbin.org/anything\")\n        .body_json(&json_payload)?\n        .recv_json()\n        .await?;\n\n    assert_eq!(res_json[\"json\"], json_payload);\n```", "```rs\n    let query_params = MyGetParams {\n        a: 0x5ff,\n        b: \"https://blog.x5ff.xyz\".into(),\n    };\n    let res_query: serde_json::Value = client\n        .get(\"https://httpbin.org/get\")\n        .set_query(&query_params)?\n        .recv_json()\n        .await?;\n\n    assert_eq!(res_query[\"args\"][\"a\"], query_params.a.to_string());\n    assert_eq!(res_query[\"args\"][\"b\"], query_params.b);\n    println!(\"> surf successful!\");\n    Ok(())\n}\n```", "```rs\nfn test_reqwest() -> Result<(), Exception> {\n    println!(\"> reqwest ...\");\n\n    let client = reqwest::Client::new();\n\n    let mut res = client\n        .get(\"https://blog.x5ff.xyz/other/cookbook2018\")\n        .send()?;\n\n    assert_eq!(200, res.status());\n    assert_eq!(\"Rust is awesome\\n\", res.text()?);\n```", "```rs\n    let form_values = vec![\n        (\"custname\", \"Rusty Crabbington\"),\n        (\"comments\", \"Thank you\"),\n        (\"custemail\", \"rusty@nope.com\"),\n        (\"custtel\", \"+1 234 33456\"),\n        (\"delivery\", \"25th floor below ground, no elevator. sorry\"),\n    ];\n\n    let res_forms: serde_json::Value = client\n        .post(\"https://httpbin.org/post\")\n        .form(&form_values)\n        .send()?\n        .json()?;\n\n    for (name, value) in form_values.iter() {\n        assert_eq!(res_forms[\"form\"][name], *value);\n    }\n```", "```rs\n    let json_payload = json!({\n        \"book\": \"Rust 2018 Cookbook\",\n        \"blog\": \"https://blog.x5ff.xyz\",\n    });\n\n    let res_json: serde_json::Value = client\n        .put(\"https://httpbin.org/anything\")\n        .json(&json_payload)\n        .send()?\n        .json()?;\n\n    assert_eq!(res_json[\"json\"], json_payload);\n```", "```rs\n    let query_params = MyGetParams {\n        a: 0x5ff,\n        b: \"https://blog.x5ff.xyz\".into(),\n    };\n\n    let res_query: serde_json::Value = client\n        .get(\"https://httpbin.org/get\")\n        .query(&query_params)\n        .send()?\n        .json()?;\n\n    assert_eq!(res_query[\"args\"][\"a\"], query_params.a.to_string());\n    assert_eq!(res_query[\"args\"][\"b\"], query_params.b);\n\n    println!(\"> reqwest successful!\");\n    Ok(())\n}\n```", "```rs\n#[runtime::main]\nasync fn main() -> Result<(), Exception> {\n    println!(\"Running some tests\");\n    test_reqwest()?;\n    test_surf().await?;\n    Ok(())\n}\n```", "```rs\n$ cargo +nightly run\n Finished dev [unoptimized + debuginfo] target(s) in 0.10s\n Running `target/debug/web-requests`\nRunning some tests\n> reqwest ...\n> reqwest successful!\n> surf ...\n> surf successful!\n```", "```rs\nrusty-ml\n├── Cargo.toml\n├── fashion-mnist\n│   ├── ...\n│   ├── data\n│   │   ├── fashion\n│   │   │   ├── t10k-images-idx3-ubyte\n│   │   │   ├── t10k-labels-idx1-ubyte\n│   │   │   ├── train-images-idx3-ubyte\n│   │   │   └── train-labels-idx1-ubyte\n│   │   └── mnist\n│   │   └── README.md\n|   └── ...\n├── models\n└── src\n    └── main.rs\n```", "```rs\n[dependencies]\ntch = \"0.1\"\nfailure =\"0.1\"\n```", "```rs\nuse std::io::{Error, ErrorKind};\nuse std::path::Path;\nuse std::time::Instant;\nuse tch::{nn, nn::ModuleT, nn::OptimizerConfig, Device, Tensor};\n```", "```rs\n#[derive(Debug)]\nstruct ConvNet {\n    conv1: nn::Conv2D,\n    conv2: nn::Conv2D,\n    fc1: nn::Linear,\n    fc2: nn::Linear,\n}\n\nimpl ConvNet {\n    fn new(vs: &nn::Path, labels: i64) -> ConvNet {\n        ConvNet {\n            conv1: nn::conv2d(vs, 1, 32, 5, Default::default()),\n            conv2: nn::conv2d(vs, 32, 64, 5, Default::default()),\n            fc1: nn::linear(vs, 1024, 512, Default::default()),\n            fc2: nn::linear(vs, 512, labels, Default::default()),\n        }\n    }\n}\n```", "```rs\nimpl nn::ModuleT for ConvNet {\n    fn forward_t(&self, xs: &Tensor, train: bool) -> Tensor {\n        xs.view([-1, 1, 28, 28])\n            .apply(&self.conv1)\n            .relu()\n            .max_pool2d_default(2)\n            .apply(&self.conv2)\n            .relu()\n            .max_pool2d_default(2)\n            .view([-1, 1024]) // flatten\n            .apply(&self.fc1)\n            .relu()\n            .dropout_(0.5, train)\n            .apply(&self.fc2)\n    }\n}\n```", "```rs\nfn train_from_scratch(learning_rate: f64, batch_size: i64, epochs: usize) -> failure::Fallible<()> {\n    let data_path = Path::new(\"fashion-mnist/data/fashion\");\n    let model_path = Path::new(\"models/best.ot\");\n\n    if !data_path.exists() {\n        println!(\n            \"Data not found at '{}'. Did you run '\n             git submodule update --init'?\",\n            data_path.to_string_lossy()\n        );\n        return Err(Error::from(ErrorKind::NotFound).into());\n    }\n\n    println!(\"Loading data from '{}'\", data_path.to_string_lossy());\n    let m = tch::vision::mnist::load_dir(data_path)?;\n```", "```rs\n    let vs = nn::VarStore::new(Device::cuda_if_available());\n    let net = ConvNet::new(&vs.root(), 10);\n    let opt = nn::Adam::default().build(&vs, learning_rate)?;\n\n    println!(\n        \"Starting training, saving model to '{}'\",\n        model_path.to_string_lossy()\n    );\n```", "```rs\n    let mut min_loss = ::std::f32::INFINITY;\n    for epoch in 1..=epochs {\n        let start = Instant::now();\n\n        let mut losses = vec![];\n\n        // Batched training, otherwise we would run out of memory\n        for (image_batch, label_batch) in m.train_iter(\n             batch_size).shuffle().to_device(vs.device())\n        {\n            let loss = net\n                .forward_t(&image_batch, true)\n                .cross_entropy_for_logits(&label_batch);\n            opt.backward_step(&loss);\n\n            losses.push(f32::from(loss));\n        }\n        let total_loss = losses.iter().sum::<f32>() / \n                         (losses.len() as f32);\n```", "```rs\n         // Predict the test set without using batches\n        let test_accuracy = net\n            .forward_t(&m.test_images, false)\n            .accuracy_for_logits(&m.test_labels);\n```", "```rs\n        // Checkpoint\n        if total_loss <= min_loss {\n            vs.save(model_path)?;\n            min_loss = total_loss;\n        }\n\n        // Output for the user\n        println!(\n            \"{:4} | train loss: {:7.4} | test acc: {:5.2}% \n             | duration: {}s\",\n            epoch,\n            &total_loss,\n            100\\. * f64::from(&test_accuracy),\n            start.elapsed().as_secs()\n        );\n    }\n    println!(\n        \"Done! The best model was saved to '{}'\",\n        model_path.to_string_lossy()\n    );\n    Ok(())\n}\n```", "```rs\nfn predict_from_best() -> failure::Fallible<()> {\n    let data_path = Path::new(\"fashion-mnist/data/fashion\");\n    let model_weights_path = Path::new(\"models/best.ot\");\n\n    let m = tch::vision::mnist::load_dir(data_path)?;\n    let mut vs = nn::VarStore::new(Device::cuda_if_available());\n    let net = ConvNet::new(&vs.root(), 10);\n\n    // restore weights\n    println!(\n        \"Loading model weights from '{}'\",\n        model_weights_path.to_string_lossy()\n    );\n    vs.load(model_weights_path)?;\n```", "```rs\n    println!(\"Probabilities and predictions \n              for 10 random images in the test set\");\n    for (image_batch, label_batch) in m.test_iter(1)\n         .shuffle().to_device(vs.device()).take(10) {\n        let raw_tensor = net\n            .forward_t(&image_batch, false)\n            .softmax(-1)\n            .view(m.labels);\n        let predicted_index: Vec<i64> = \n            raw_tensor.argmax(0, false).into();\n        let probabilities: Vec<f64> = raw_tensor.into();\n\n        print!(\"[ \");\n        for p in probabilities {\n            print!(\"{:.4} \", p);\n        }\n        let label: Vec<i64> = label_batch.into();\n        println!(\"] predicted {}, was {}\", \n                  predicted_index[0], label[0]);\n    }\n    Ok(())\n}\n```", "```rs\n fn main() -> failure::Fallible<()> {\n    train_from_scratch(1e-2, 1024, 5)?;\n    predict_from_best()?;\n    Ok(())\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.19s\n     Running `target/debug/rusty-ml`\nLoading data from 'fashion-mnist/data/fashion'\nStarting training, saving model to 'models/best.ot'\n   1 | train loss: 1.1559 | test acc: 82.87% | duration: 29s\n   2 | train loss: 0.4132 | test acc: 86.70% | duration: 32s\n   3 | train loss: 0.3383 | test acc: 88.41% | duration: 32s\n   4 | train loss: 0.3072 | test acc: 89.16% | duration: 29s\n   5 | train loss: 0.2869 | test acc: 89.36% | duration: 28s\nDone! The best model was saved to 'models/best.ot'\nLoading model weights from 'models/best.ot'\nProbabilities and predictions for 10 random images in the test set\n[ 0.0000 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 ] predicted 1, was 1\n[ 0.5659 0.0001 0.0254 0.0013 0.0005 0.0000 0.4062 0.0000 0.0005 0.0000 ] predicted 0, was 0\n[ 0.0003 0.0000 0.9699 0.0000 0.0005 0.0000 0.0292 0.0000 0.0000 0.0000 ] predicted 2, was 2\n[ 0.0000 1.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 ] predicted 1, was 1\n[ 0.6974 0.0000 0.0008 0.0001 0.0000 0.0000 0.3017 0.0000 0.0000 0.0000 ] predicted 0, was 0\n[ 0.0333 0.0028 0.1053 0.7098 0.0420 0.0002 0.1021 0.0007 0.0038 0.0001 ] predicted 3, was 2\n[ 0.0110 0.0146 0.0014 0.9669 0.0006 0.0000 0.0038 0.0003 0.0012 0.0000 ] predicted 3, was 3\n[ 0.0003 0.0001 0.0355 0.0014 0.9487 0.0001 0.0136 0.0001 0.0004 0.0000 ] predicted 4, was 4\n[ 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 1.0000 0.0000 0.0000 ] predicted 7, was 7\n[ 0.0104 0.0091 0.0037 0.8320 0.0915 0.0001 0.0505 0.0002 0.0026 0.0000 ] predicted 3, was 3\n```", "```rs\n[dependencies]\nlog = \"0.4\"\nlog4rs = \"0.8.3\"\ntime = \"0.1\"\n```", "```rs\nuse log::{debug, error, info, trace, warn};\n```", "```rs\nfn log_some_stuff() {\n    let a = 100;\n\n    trace!(\"TRACE: Called log_some_stuff()\");\n    debug!(\"DEBUG: a = {} \", a);\n    info!(\"INFO: The weather is fine\");\n    warn!(\"WARNING, stuff is breaking down\");\n    warn!(target: \"special-target\", \"WARNING, stuff is breaking down\");\n    error!(\"ERROR: stopping ...\");\n}\n```", "```rs\nconst USE_CUSTOM: bool = false;\n\nfn main() {\n    if USE_CUSTOM { \n    log::set_logger(&LOGGER)\n        .map(|()| log::set_max_level(log::LevelFilter::Trace))\n        .unwrap();\n    } else {\n        log4rs::init_file(\"log4rs.yml\", Default::default()).unwrap();\n    }\n    log_some_stuff();\n}\n```", "```rs\nrefresh_rate: 30 seconds\n\nappenders:\n  stdout:\n    kind: console\n\n  outfile:\n    kind: file\n    path: \"outfile.log\"\n    encoder:\n      pattern: \"{d} - {m}{n}\"\n\nroot:\n  level: trace\n  appenders:\n    - stdout\n\nloggers:\n  special-target:\n    level: info\n    appenders:\n      - outfile\n```", "```rs\nmod custom {\n    pub use log::Level;\n    use log::{Metadata, Record};\n\n    pub struct EmojiLogger {\n        pub level: Level,\n    }\n```", "```rs\n    impl log::Log for EmojiLogger {\n\n        fn flush(&self) {}        \n\n        fn enabled(&self, metadata: &Metadata) -> bool {\n            metadata.level() <= self.level\n        }\n\n        fn log(&self, record: &Record) {\n            if self.enabled(record.metadata()) {\n                let level = match record.level() {\n                    Level::Warn => \"WARNING-SIGN\",\n                    Level::Info => \"INFO-SIGN\",\n                    Level::Debug => \"CATERPILLAR\",\n                    Level::Trace => \"LIGHTBULB\",\n                    Level::Error => \"NUCLEAR\",\n                };\n                let utc = time::now_utc();\n                println!(\"{} | [{}] | {:<5}\", \n                         utc.rfc3339(), record.target(), level);\n                println!(\"{:21} {}\", \"\", record.args());\n            }\n        }\n    }\n}\n```", "```rs\nstatic LOGGER: custom::EmojiLogger = custom::EmojiLogger {\n    level: log::Level::Trace,\n};\n```", "```rs\n$ cargo run\n Finished dev [unoptimized + debuginfo] target(s) in 0.04s\n     Running `target/debug/logging`\n2019-09-01T12:42:18.056681073+02:00 TRACE logging - TRACE: Called log_some_stuff()\n2019-09-01T12:42:18.056764247+02:00 DEBUG logging - DEBUG: a = 100 \n2019-09-01T12:42:18.056791639+02:00 INFO logging - INFO: The weather is fine\n2019-09-01T12:42:18.056816420+02:00 WARN logging - WARNING, stuff is breaking down\n2019-09-01T12:42:18.056881011+02:00 ERROR logging - ERROR: stopping ...\n```", "```rs\n2019-09-01T12:45:25.256922311+02:00 - WARNING, stuff is breaking down\n```", "```rs\n$ cargo run\n   Compiling logging v0.1.0 (Rust-Cookbook/Chapter10/logging)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.94s\n     Running `target/debug/logging`\n2019-09-01T10:46:43Z | [logging] | LIGHTBULB \n                      TRACE: Called log_some_stuff()\n2019-09-01T10:46:43Z | [logging] | CATERPILLAR \n                      DEBUG: a = 100 \n2019-09-01T10:46:43Z | [logging] | INFO-SIGN \n                      INFO: The weather is fine\n2019-09-01T10:46:43Z | [logging] | WARNING-SIGN \n                      WARNING, stuff is breaking down\n2019-09-01T10:46:43Z | [special-target] | WARNING-SIGN \n                      WARNING, stuff is breaking down\n2019-09-01T10:46:43Z | [logging] | NUCLEAR \n                      ERROR: stopping ...\n```", "```rs\nwarn!(target: \"special-target\", \"WARNING, stuff is breaking down\");\n```", "```rs\nuse std::error::Error;\nuse std::io::Write;\nuse std::process::{Command, Stdio};\n```", "```rs\nfn main() -> Result<(), Box<dyn Error + Send + Sync + 'static>> {\n    let mut ls_child = Command::new(\"ls\");\n    if !cfg!(target_os = \"windows\") {\n        ls_child.args(&[\"-alh\"]);\n    }\n    println!(\"{}\", ls_child.status()?);\n    ls_child.current_dir(\"src/\");\n    println!(\"{}\", ls_child.status()?);\n```", "```rs\n    let env_child = Command::new(\"env\")\n        .env(\"CANARY\", \"0x5ff\")\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    let env_output = &env_child.wait_with_output()?;\n    let canary = String::from_utf8_lossy(&env_output.stdout)\n    .split_ascii_whitespace()\n    .filter(|line| *line == \"CANARY=0x5ff\")\n    .count();\n\n    // found it!\n    assert_eq!(canary, 1);    \n```", "```rs\n    let mut rev_child = Command::new(\"rev\")\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .spawn()?;\n\n    {\n        rev_child\n            .stdin\n            .as_mut()\n            .expect(\"Could not open stdin\")\n            .write_all(b\"0x5ff\")?;\n    }\n\n    let output = rev_child.wait_with_output()?;\n    assert_eq!(String::from_utf8_lossy(&output.stdout), \"ff5x0\");\n\n    Ok(())\n}\n\n```", "```rs\n$ cargo run\n   Compiling sub-processes v0.1.0 (Rust-Cookbook/Chapter10/sub-processes)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.44s\n     Running `target/debug/sub-processes`\ntotal 24K\ndrwxr-xr-x. 4 cm cm 4.0K Aug 26 09:21 .\ndrwxr-xr-x. 13 cm cm 4.0K Aug 11 23:27 ..\n-rw-r--r--. 1 cm cm 145 Aug 26 09:21 Cargo.lock\n-rw-r--r--. 1 cm cm 243 Jul 26 10:23 Cargo.toml\ndrwxr-xr-x. 2 cm cm 4.0K Jul 26 10:23 src\ndrwxr-xr-x. 3 cm cm 4.0K Aug 26 09:21 target\nexit code: 0\ntotal 12K\ndrwxr-xr-x. 2 cm cm 4.0K Jul 26 10:23 .\ndrwxr-xr-x. 4 cm cm 4.0K Aug 26 09:21 ..\n-rw-r--r--. 1 cm cm 1.1K Aug 31 11:49 main.rs\nexit code: 0\n```"]