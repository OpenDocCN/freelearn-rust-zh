<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor093"/>Chapter 4</em>: Managing Animations with State Machines</h1>
			<p>In the last chapter, we created a minimal game <em class="italic">engine</em>, allowing for moving our main character around and playing a simple animation, but it's far from full-featured. There's no world to navigate, the only animation that plays is running, and <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) doesn't respond to any physics. At this point, if we wanted to retitle our game, it would be called <em class="italic">Red Hat Boy and the Empty Void</em>.</p>
			<p>While that might be a fun title, it wouldn't make for a fun game. Ultimately, we'll want RHB to chase his dog through a forest with platforms to jump on and slide under, and to do that we'll need to make sure he slides, jumps, and runs. We'll also need to make sure that he looks, acts, and behaves differently when he does those things. </p>
			<p>In this chapter, we're going to introduce a common game development pattern to manage all that, the state machine, implemented in <strong class="bold">Rust</strong>. Rust gives us powerful constructs for state machines but also unique challenges due to its ownership model, so we'll dive into that and why we'll use it instead of deceptively simple <strong class="source-inline">if</strong> statements.</p>
			<p>We're going to cover the following topics:</p>
			<ul>
				<li>Introducing state machines</li>
				<li>Managing animation</li>
				<li>Adding states to walk the dog</li>
				<li><strong class="source-inline">Idle</strong>, <strong class="source-inline">Running</strong>, <strong class="source-inline">Sliding</strong>, and <strong class="source-inline">Jumping</strong> animations</li>
			</ul>
			<p>By the end of the chapter, you will be able to use state machines to cleanly transition between animations while always playing the correct one.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>There are no new crates or other technical requirements in this chapter. The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/35sk3TC">https://bit.ly/35sk3TC</a></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor095"/>Introducing state machines</h1>
			<p>Games, web applications, heck, even cryptocurrency miners, have to manage the <em class="italic">state</em> of the system. After all, if the system isn't doing something right now, if it doesn't have a current state, then it's not <a id="_idIndexMarker245"/>running, is it? The state is also fractal. In our game, we have a state of <strong class="source-inline">playing</strong>, and another one of <strong class="source-inline">game over</strong>. Once we add menu items, we'll have even more states. Meanwhile, our RHB also has states: he's running, sliding, jumping, dying, and dead. Let's say unconscious, that's less dark.</p>
			<p>The point is our game is doing a lot of things and is maintaining a large game state with a lot of mini-states inside it. As the application moves from one state to another, the rules of the system change. For example, when RHB is running, the <em class="italic">spacebar</em> might make him jump, but when he's jumping, hitting the <em class="italic">spacebar</em> doesn't do anything. The rule is you can't jump when you're already jumping. One way you can maintain that state is through a large structure with a bunch of values or Booleans, such as <strong class="source-inline">jumping = true</strong>, and in a Rust program, you might store that in an enumerated type like this:</p>
			<p class="source-code">enum RedHatBoyState {</p>
			<p class="source-code">    Jumping,</p>
			<p class="source-code">    Running,</p>
			<p class="source-code">    Sliding,</p>
			<p class="source-code">}</p>
			<p>This works reasonably well in small programs but for larger programs, there are two things that you'll want to manage. The first, which I've already hinted at, is that there may be rules about going between states. Maybe you can't go right from <strong class="source-inline">Jumping</strong> to <strong class="source-inline">Sliding</strong>, but an <strong class="source-inline">enum</strong> doesn't prevent that. The second is that, in addition to the rules being different for each state, frequently things happen on the <em class="italic">transitions</em> between states, things such as <a id="_idIndexMarker246"/>playing a sound effect or updating a score; for that, you need a state machine.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor096"/>Defining a state machine</h2>
			<p>Perhaps the most confusing thing <a id="_idIndexMarker247"/>about state machines is the naming, as there are state machines, finite state machines, the state pattern, and more, all of which frequently get used interchangeably by programmers. So, for the sake of clarity, let's define them this way:</p>
			<ul>
				<li><strong class="bold">State machines</strong>: A model of the state <a id="_idIndexMarker248"/>of a system, represented by a list of states and the transitions between them</li>
				<li><strong class="bold">State pattern</strong>: One way to implement <a id="_idIndexMarker249"/>state machines, which we will <em class="italic">not</em> be using in our application, although our implementation will bear a resemblance to it<p class="callout-heading">Important Note</p><p class="callout">The Rust Programming Language has an implementation of the traditional state pattern, using a <strong class="source-inline">trait</strong> object, which you can find here: <a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html">https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html</a>. It's quite good but is not idiomatic Rust, and we won't be using it.</p></li>
			</ul>
			<p>The state machine both helps us keep a mental model of the system in our heads and prevents us from making foolish mistakes in code, such as playing the running animation while RHB is jumping. The drawback, of course, is that you need to understand state machines, so let's get that covered. We'll use RHB as our example. RHB can be <strong class="bold">Running</strong>, <strong class="bold">Idle</strong>, <strong class="bold">Jumping</strong>, <strong class="bold">Sliding</strong>, <strong class="bold">Falling</strong>, or <strong class="bold">KnockedOut</strong>. We can use a state <strong class="bold">transition table</strong> to list those:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="" src="image/Table_4.1.jpg"/>
				</div>
			</div>
			<p>The transition table only has three columns for now, which are a start state, the event that causes a transition, and the state it transitions to. Events differ from transitions in that events are what happens to the system to <em class="italic">cause</em> a transition, but transitions are what happens <em class="italic">during</em> the state change.</p>
			<p>It's a subtle difference, and sometimes it gets used interchangeably because the names will frequently be the same. Let's work <a id="_idIndexMarker250"/>through a state transition to clarify this. RHB starts in the <strong class="source-inline">Idle</strong> state, where he stands in place with an <strong class="bold">Idle </strong>animation. To start running, he gets an event; let's call it <strong class="source-inline">run</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="" src="image/Table_4.2.jpg"/>
				</div>
			</div>
			<p>When moving to <strong class="source-inline">Running</strong>, we actually do something on the transition. Specifically, we start moving to the right; we increase the velocity in <strong class="source-inline">x</strong>. You can name this transition in the table:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="" src="image/Table_4.3.jpg"/>
				</div>
			</div>
			<p>While this is correct, often we don't bother naming the transitions and the events because they become redundant. While we could continue adding to this table, we can also model a state machine <a id="_idIndexMarker251"/>with several types of diagrams. I'm partial to simple circles and lines, where the circles are the states and the lines are the transitions.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 4.1 – A state machine diagram&#13;&#10;" src="image/Figure_4.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – A state machine diagram</p>
			<p>This diagram is a fleshed-out version of the previous table, with all of the entries completed. It starts at the <strong class="bold">Idle</strong> state and transitions to the <strong class="bold">Running</strong> state via the <strong class="bold">Run</strong> event. From there, it can go in several directions. If the player <em class="italic">slides</em>, it can go into the <strong class="bold">Sliding</strong> state; if the player <em class="italic">jumps</em>, it can go into the <strong class="bold">Jumping</strong> state. Both of those eventually return to the <strong class="bold">Running</strong> state when sliding or jumping is over. <strong class="bold">Running</strong>, <strong class="bold">Sliding</strong>, and <strong class="bold">Jumping</strong> can all transition into the <strong class="bold">Falling</strong> state when they crash into something.</p>
			<p>This does result in a lot of transitions across the middle of the diagram. Finally, the <strong class="bold">Falling</strong> state transitions into the <strong class="bold">KnockedOut</strong> state when <strong class="bold">Falling</strong> is over, via the <strong class="bold">End</strong> event. If you're familiar with this type of diagram, you might point out that I could have used a <em class="italic">superstate</em> to contain <strong class="bold">Running</strong>, <strong class="bold">Jumping</strong>, and <strong class="bold">Sliding</strong> and used one event to transition all of those to <strong class="bold">Falling</strong>. You'd be right, but we won't need to concern ourselves with that for our implementation.</p>
			<p>You might be asking, what's the benefit of all this? Does this really fit the <em class="italic">minimal architecture</em> that we covered in the last chapter? Answering the second question first, the answer is, uh…maybe? I find that state machines help me keep code together that belongs together, rather than sprinkling <strong class="source-inline">match</strong> statements throughout my code base as I might have to when using a simple <strong class="source-inline">enum</strong>. That doesn't mean we won't have those <strong class="source-inline">match</strong> statements; they'll just be in one place.</p>
			<p>I also find it fits my mental model of how code works well, and it helps prevent errors because you simply <em class="italic">can't</em> perform an <a id="_idIndexMarker252"/>action that's invalid because it's not available for that given state. Frankly, the state machine exists whether or not we model it, and it's cleaner if we can also model it in code rather than having it emerge accidentally. So, those are the benefits, and that's why I think it fits in our minimal architecture. Now it's time to implement it.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor097"/>Implementing with types</h2>
			<p>The <strong class="bold">Object-Oriented</strong> (<strong class="bold">OO</strong>) state<a id="_idIndexMarker253"/> pattern is typically implemented as a variation on the strategy pattern, where you swap <a id="_idIndexMarker254"/>out different objects that all implement the same state interface at runtime based on the various transitions. The diagram looks something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 4.2 – State pattern" src="image/Figure_4.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – State pattern</p>
			<p>In the OO version of the pattern, <strong class="bold">Context</strong> has a reference to a <strong class="bold">State</strong> interface, and different states implement that interface. Frequently, the events, such as <strong class="bold">handle</strong>, take a reference to <strong class="bold">Context</strong> itself, in <a id="_idIndexMarker255"/>order to have side effects on the transitions. This design works reasonably well, but in Rust, we have two features that we'll use that differentiate it from the traditional pattern. The first is <strong class="source-inline">enum</strong>, which we can use to enumerate the states in a clearer fashion than traditional objects. The<a id="_idIndexMarker256"/> second is <strong class="bold">generic types</strong>, which we'll use to model each state as a <strong class="bold">typestate</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The original state machine implementation I wrote was largely based on this excellent article by Ana Hobden, a.k.a. Hoverbear, at <a href="https://hoverbear.org/blog/rust-state-machine-pattern/">https://hoverbear.org/blog/rust-state-machine-pattern/</a>. While this book no longer uses that pattern, I encourage you to read it for an alternative approach.</p>
			<h3>The typestate pattern</h3>
			<p><strong class="bold">Typestate</strong> is a fancy name for embedding the state of an object in its type. The way it works is that you have <a id="_idIndexMarker257"/>a generic structure with one generic parameter representing the state. Then, each state will have methods that can return new states. So, instead of each state having common methods, as they do, as shown in <em class="italic">Figure 4.2</em>, each state has its own methods that return the new state. The states in <em class="italic">Figure 4.2</em> might look something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 4.3 – Typestate pattern" src="image/Figure_4.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Typestate pattern</p>
			<p>In this diagram, <strong class="source-inline">State&lt;GenericStateOne&gt;</strong> has a <strong class="source-inline">next</strong> method, which consumes <strong class="source-inline">self</strong> and returns <strong class="source-inline">State&lt;GenericStateTwo&gt;</strong>. Meanwhile, <strong class="source-inline">State&lt;GenericStateTwo&gt;</strong> only has an <strong class="source-inline">update</strong> method, which takes a mutably borrowed <strong class="source-inline">self</strong>. The implications of this are that the compiler will catch you if you try to call <strong class="source-inline">next</strong> on <strong class="source-inline">State&lt;GenericStateTwo&gt;</strong>. In the traditional OO pattern, all states must handle all the same methods because they share an interface, so this kind of defense isn't possible. Often, this means implementing methods you don't actually care about, and either returning an error state or <strong class="source-inline">Self</strong>, and then debugging at runtime. </p>
			<p>In addition, we can use the <strong class="source-inline">mod</strong> keyword and Rust's rules about privacy to make it impossible to create any state in an <a id="_idIndexMarker258"/>invalid state. We can make it impossible to move from <strong class="source-inline">GenericStateOne</strong> to <strong class="source-inline">GenericStateTwo</strong> without calling <strong class="source-inline">next</strong> by keeping the internals of <strong class="source-inline">State</strong> private so you can't just construct it. This is <a id="_idIndexMarker259"/>called <strong class="bold">making illegal states unrepresentable</strong>, and it's a great way to make sure you don't make mistakes in your programs.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">I tracked down the <em class="italic">making illegal states unrepresentable</em> phrasing to Yaron Minsky (<a href="https://blog.janestreet.com/effective-ml-revisited/">https://blog.janestreet.com/effective-ml-revisited/</a>); however, it's quite likely the practice and phrasing are older than that.</p>
			<p>Typestates are intimidating because they are both a new concept and new jargon, so don't worry if you feel a little confused.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There's a lot of great information on typestates in Rust. There's an excellent talk by Will Crichton from Strange Loop (https://youtu.be/bnnacleqg6k?t=2015), as well as blogs at <a href="https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm">https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm</a> and <a href="http://cliffle.com/blog/rust-typestate/">http://cliffle.com/blog/rust-typestate/</a>.</p>
			<p>If you want to forget all about generics and type theory for a minute, they can be summarized as follows:</p>
			<ul>
				<li>Each state of the object is represented by a separate struct.</li>
				<li>You can only advance from one state to another by methods on that struct.</li>
				<li>You can guarantee you can only create valid states using privacy rules.</li>
			</ul>
			<p>The rest are just details.</p>
			<p>Finally, we're going to need an <strong class="source-inline">enum</strong> to <em class="italic">hold</em> our typestate. Each state is generic, so to continue in our preceding example, any struct that will interact with our state machine will need to hold <em class="italic">either</em> <strong class="source-inline">State&lt;GenericStateOne&gt;</strong> or <strong class="source-inline">State&lt;GenericStateTwo&gt;</strong>. In order to do that, we would either need to make the containing <strong class="source-inline">struct</strong> generic as well, and then create new versions of the containing <strong class="source-inline">struct</strong> every time the state changes, or wrap the generic object in an <strong class="source-inline">enum</strong>. </p>
			<p>We'll use an <strong class="source-inline">enum</strong> because it <a id="_idIndexMarker260"/>prevents the generic nature of the typestate from propagating throughout the program, allowing the typestate to be an implementation detail. We're going to write the kind of state machine that Rust is very good at. Let's get to it.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor098"/>Managing animation</h1>
			<p>We'll create our state machine to manage the different animations. Specifically, when RHB isn't moving, he's <strong class="source-inline">Idle</strong>, but <a id="_idIndexMarker261"/>when he's moving, he's <strong class="source-inline">Running</strong>. When he jumps, he's <strong class="source-inline">Jumping</strong>. You get the idea.</p>
			<p>Those different RHB states correspond to the different animations managed using a state machine. We'll first create the RHB with a state machine and then integrate it into our current application. We'll implement this <em class="italic">top-down</em>, starting with a struct that represents RHB <a id="_idIndexMarker262"/>and letting the compiler errors drive further development. This is sometimes called <strong class="bold">Compiler-Driven Development</strong> although it's <a id="_idIndexMarker263"/>not a formalized approach such as <strong class="bold">Test-Driven Development</strong>. It can work extremely well in a language with a robust type system and great compiler errors, such as Rust. Let's start with how we'll represent RHB.</p>
			<p>The <strong class="source-inline">RedHatBoy</strong> struct will contain the state machine, the sprite sheet, and the image because eventually, it will draw itself:</p>
			<p class="source-code">struct RedHatBoy {</p>
			<p class="source-code">    state_machine: RedHatBoyStateMachine,</p>
			<p class="source-code">    sprite_sheet: Sheet,</p>
			<p class="source-code">    image: HtmlImageElement,</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">All of this code belongs in the <strong class="source-inline">game</strong> module. That means you can put it in the <strong class="source-inline">game.rs</strong> file or if you so choose, put it in a separate file and bring it into the <strong class="source-inline">game</strong> module with the <strong class="source-inline">mod</strong> keyword. I'll leave that up to you.</p>
			<p>Of course, this won't work because you haven't created the state machine yet. You do have the <strong class="source-inline">Sheet</strong> structure from <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>. Let's create <strong class="source-inline">RedHatBoyStateMachine</strong>:</p>
			<p class="source-code">#[derive(Copy, Clone)]</p>
			<p class="source-code">enum RedHatBoyStateMachine {</p>
			<p class="source-code">    Idle(RedHatBoyState&lt;Idle&gt;),</p>
			<p class="source-code">    Running(RedHatBoyState&lt;Running&gt;),</p>
			<p class="source-code">}</p>
			<p>Seeing the <strong class="source-inline">enum</strong> we discussed earlier, it might still be unclear why we're using it when we'll be creating all of these typestate structures. <strong class="source-inline">RedHatBoyState</strong>, which doesn't exist yet, is a generic type that <a id="_idIndexMarker264"/>contains another type, where those types represent the various states. So, why the redundant <strong class="source-inline">enum</strong>? Because we want to be able to switch easily between the states without using the heap or dynamic dispatch. Let's imagine we defined the <strong class="source-inline">RedHatBoy</strong> struct in the following way:</p>
			<p class="source-code">struct RedHatBoy {</p>
			<p class="source-code">    state: RedHatBoyState&lt;Idle&gt;,</p>
			<p class="source-code">    sprite_sheet: Sheet,</p>
			<p class="source-code">}</p>
			<p>Now the state is fixed to a state. We could, of course, define things in the following way:</p>
			<p class="source-code">struct RedHatBoy&lt;T&gt; {</p>
			<p class="source-code">    state: RedHatBoyState&lt;T&gt;,</p>
			<p class="source-code">    sprite_sheet: Sheet,</p>
			<p class="source-code">}</p>
			<p>But of course, now <strong class="source-inline">RedHatBoy</strong> has to also be a generic type. You can make this work without the <strong class="source-inline">enum</strong> using <strong class="source-inline">Box&lt;dyn State&gt;</strong>, but that's not very ergonomic and it would require implementing the same methods on every state, so we'll stick with the <strong class="source-inline">enum</strong>. I have to acknowledge that I don't like the stutter in the types such as <strong class="source-inline">*Idle*(RedHatBoyState&lt;*Idle*&gt;)</strong>, but we'll see that the <strong class="source-inline">enum</strong> wrapper becomes extremely useful as we implement the state machine. Make sure that the <strong class="source-inline">enum</strong> is <strong class="source-inline">Copy,Clone</strong> as well, for reasons you'll see shortly.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're interested, <em class="italic">The Rust Programming Language</em> has a chapter that describes how to implement a state pattern in a traditional OO way. Interestingly, they eventually abandon it in favor of using an <strong class="source-inline">enum</strong>. You can find that here: <a href="https://bit.ly/3hBsVd4">https://bit.ly/3hBsVd4</a>.</p>
			<p>Of course, this code still doesn't <a id="_idIndexMarker265"/>compile, because we haven't created either of those states or the <strong class="source-inline">RedHatBoyState</strong> <strong class="source-inline">x</strong>. This is what I meant by Compiler-Driven Development. We can start by creating <strong class="source-inline">RedHatBoyState</strong>:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    use crate::engine::Point;</p>
			<p class="source-code">    #[derive(Copy, Clone)]</p>
			<p class="source-code">    pub struct RedHatBoyState&lt;S&gt; {</p>
			<p class="source-code">        context: RedHatBoyContext,</p>
			<p class="source-code">        _state: S,</p>
			<p class="source-code">    }</p>
			<p class="source-code">    #[derive(Copy, Clone)]</p>
			<p class="source-code">    pub struct RedHatBoyContext {</p>
			<p class="source-code">        frame: u8,</p>
			<p class="source-code">        position: Point,</p>
			<p class="source-code">        velocity: Point,</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>All the code relating to the individual states will go in its own module, <strong class="source-inline">red_hat_boy_states</strong>, so that we can only make public the methods required by the rest of the <strong class="source-inline">game</strong> module. This will make it impossible to accidentally create a state without using the methods provided, and therefore, impossible to accidentally make an invalid transition. The only way to transition from <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> to <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> is going to be through the methods on <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong>. It's important that both <strong class="source-inline">RedHatBoyState</strong> and <strong class="source-inline">RedHatBoyContext</strong> are public but their members are private, so we can use them as intended.</p>
			<p>Inside the new module, <strong class="source-inline">RedHatBoyState</strong> is a simple generic type that contains <strong class="source-inline">_state</strong>, which is never read, hence the underscore, and <strong class="source-inline">RedHatBoyContext</strong>. Now, <strong class="source-inline">RedHatBoyContext</strong> is a structure with data that's common to all the states. In this case, that's the frame being <a id="_idIndexMarker266"/>rendered, the position, and the velocity. We'll need it so that the state transitions can modify the state of RHB. Putting all of this in the <strong class="source-inline">red_hat_boy_states</strong> module means that we haven't changed the compiler error message. We need to import that module into the <strong class="source-inline">game</strong> module with <strong class="source-inline">use self::red_hat_boy_states::*;</strong>, which you can add anywhere in the <strong class="source-inline">game</strong> module. This gets us partway there, but if we look at the following compiler output, we're still not finished:</p>
			<p class="source-code">error[E0412]: cannot find type 'Idle' in this scope</p>
			<p class="source-code">  --&gt; src/game.rs:19:25</p>
			<p class="source-code">   |</p>
			<p class="source-code">19 |     Idle(RedHatBoyState&lt;Idle&gt;),</p>
			<p class="source-code">   |                                    ^^^^ not found in </p>
			<p class="source-code">   this scope</p>
			<p>There's also a corresponding <strong class="source-inline">enum</strong> variant for <strong class="source-inline">Running(RedHatBoyState&lt;Running&gt;)</strong>. Both <strong class="source-inline">Idle</strong> and <strong class="source-inline">Running</strong> don't exist. We can create both of <a id="_idIndexMarker267"/>these easily, with empty structures inside the <strong class="source-inline">red_hat_boy_states</strong> module. Note that both of these must also be <strong class="source-inline">Clone</strong>:</p>
			<p class="source-code">#[derive(Copy, Clone)]</p>
			<p class="source-code">struct Idle;</p>
			<p class="source-code">#[derive(Copy, Clone)]</p>
			<p class="source-code">struct Running;</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor099"/>Transitioning between states</h2>
			<p>Congratulations! You've created two states for RHB. This achieves…nothing. There's a bit missing. For <a id="_idIndexMarker268"/>starters, we can't <a id="_idIndexMarker269"/>transition from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>, and those states don't actually do anything when they aren't transitioning. Let's take care of a transition right now. We'll add a method on <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> to go from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context,</p>
			<p class="source-code">                _state: Running {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>This is the transition from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>, and the <strong class="source-inline">run</strong> method is where the magic happens. This is just a function that takes a <strong class="source-inline">RedHatBoy&lt;Idle&gt;</strong> state and converts it to a <strong class="source-inline">RedHatBoy&lt;Running&gt;</strong> state, and for now, doesn't change any <strong class="source-inline">RedHatBoyContext</strong> data. You might wonder then, what magic?</p>
			<p>This means that to transition from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>, you can use <strong class="source-inline">run</strong>, but it also means you can't transition from <strong class="source-inline">Running</strong> back into <strong class="source-inline">Idle</strong>, and that makes sense because the game doesn't allow that behavior. The function also takes <strong class="source-inline">mut self</strong>, so that when it's called, it consumes the current state. This means that if you want to somehow keep <strong class="source-inline">Idle</strong> around after transitioning to <strong class="source-inline">Running</strong>, you have to clone it, and if you do that, you probably really meant to do it. </p>
			<p>You also can't create the <strong class="source-inline">Running</strong> state directly, because its data members are private, which means you can't just create that state by mistake. You can't create the <strong class="source-inline">Idle</strong> state either, and that's a <a id="_idIndexMarker270"/>problem because it's the start state. We'll address that<a id="_idIndexMarker271"/> in a moment, but first, let's dive into how we'll interact with the states through our state machine.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor100"/>Managing the state machine</h2>
			<p>Initially, we <a id="_idIndexMarker272"/>might be <a id="_idIndexMarker273"/>tempted to implement our state machine by adding methods on the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong>, as follows:</p>
			<p class="source-code">#[derive(Copy, Clone)]</p>
			<p class="source-code">enum RedHatBoyStateMachine {</p>
			<p class="source-code">    Idle(RedHatBoyState&lt;Idle&gt;),</p>
			<p class="source-code">    Running(RedHatBoyState&lt;Running&gt;),</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn run(self) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Idle(state) =&gt; </p>
			<p class="source-code">             RedHatBoyStateMachine::Running(state.run()),</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This isn't terrible, but it means that every method on our state machine will likely need to match the current variant of the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong>. Then, it would return the new variant based on either the transition or <strong class="source-inline">self</strong> when the transition isn't currently valid. In other words, while the compiler will error if we call <strong class="source-inline">run</strong> on the <strong class="source-inline">Running</strong> state, it won't error if we call <strong class="source-inline">run</strong> on <strong class="source-inline">RedHatBoyStateMachine</strong> when the current variant is <strong class="source-inline">Running</strong>. This kind of error, where we call <strong class="source-inline">run</strong> by mistake on the wrong state, is exactly what we're trying to get away from with our typestates. We'd go to all the trouble of writing these typestates only to immediately throw away one of the benefits in every method on the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong>.</p>
			<p>Unfortunately, we can't completely get away from that problem, because we are using an <strong class="source-inline">enum</strong> to contain our states. There's no way to implement methods on variants of an <strong class="source-inline">enum</strong> as we can with generic structures, and if we're going to wrap the state in an <strong class="source-inline">enum</strong>, we'll have <a id="_idIndexMarker274"/>to match on the variant. What we can do is <em class="italic">reduce</em> the <a id="_idIndexMarker275"/>surface area of that kind of error by reducing the number of methods that operate in the states. Specifically, instead of calling <strong class="source-inline">run</strong> on the <strong class="source-inline">enum</strong>, we'll create a <strong class="source-inline">transition</strong> function that takes <strong class="source-inline">Event</strong>. That is going to look like the following code:</p>
			<p class="source-code">#[derive(Copy, Clone)]</p>
			<p class="source-code">enum RedHatBoyStateMachine {</p>
			<p class="source-code">    Idle(RedHatBoyState&lt;Idle&gt;),</p>
			<p class="source-code">    Running(RedHatBoyState&lt;Running&gt;),</p>
			<p class="source-code">}</p>
			<p class="source-code">pub enum Event {</p>
			<p class="source-code">    Run,</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            (RedHatBoyStateMachine::Idle(state), </p>
			<p class="source-code">             Event::Run) =&gt; {</p>
			<p class="source-code">                RedHatBoyStateMachine::Running(state.run())</p>
			<p class="source-code">            }</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've solved the problem caused by the <strong class="source-inline">enum</strong> with another <strong class="source-inline">enum</strong>! This is very <em class="italic">Rusty</em> of us. In this case, we've created an <strong class="source-inline">enum</strong> named <strong class="source-inline">Event</strong> to represent every event that could happen to our machine and replaced the method named <strong class="source-inline">run</strong> with a method named <strong class="source-inline">transition</strong>.</p>
			<p>So, instead of many small methods for run, jump, and similar, we will have one method named <strong class="source-inline">transition</strong> and a bunch of <strong class="source-inline">Event</strong> variants. How does this improve things? Because there is only one <strong class="source-inline">match</strong> statement that we have to update when we want to add a transition, instead <a id="_idIndexMarker276"/>of potentially adding multiple <a id="_idIndexMarker277"/>little <strong class="source-inline">match</strong> statements. Keep in mind that this function takes <strong class="source-inline">mut</strong> <strong class="source-inline">self</strong>, which means calling <strong class="source-inline">transition</strong> will consume <strong class="source-inline">self</strong> and return a new <strong class="source-inline">RedHatBoyStateMachine</strong> just as the <strong class="source-inline">run</strong> method does on <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor101"/>Using Into for clean code</h2>
			<p>We can actually <a id="_idIndexMarker278"/>improve the ergonomics of this method <a id="_idIndexMarker279"/>using the <strong class="source-inline">From</strong> trait. If you're unfamiliar, the <strong class="source-inline">From</strong> trait is a Rust feature that lets us define how to convert from one type to another. Implementing the <strong class="source-inline">From</strong> trait on your type will also implement the <strong class="source-inline">Into</strong> trait, which will provide an <strong class="source-inline">into</strong> method that will make it easy to convert from one type to another.</p>
			<p>We know that if we have <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong>, it will convert into the <strong class="source-inline">RedHatBoyStateMachine::Running</strong> variant, and if we write the conversion by implementing the <strong class="source-inline">From</strong> trait, we will be able to replace that wrapping with a call to <strong class="source-inline">into</strong>. That was a lot of words for a little bit of code, so the following is what the implementation of the <strong class="source-inline">From</strong> trait looks like:</p>
			<p class="source-code">impl From&lt;RedHatBoyState&lt;Running&gt;&gt; for RedHatBoyStateMachine {</p>
			<p class="source-code">    fn from(state: RedHatBoyState&lt;Running&gt;) -&gt; Self {</p>
			<p class="source-code">        RedHatBoyStateMachine::Running(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This can be placed right under the implementation of <strong class="source-inline">RedHatBoyStateMachine</strong>. It defines how to convert from <strong class="source-inline">RedHatBoy&lt;Running&gt;</strong> to <strong class="source-inline">RedHatBoyStateMachine</strong>, and it's the same small amount of code we wrote in the <strong class="source-inline">transition</strong> method. Because we have this now, we can make that method a little more succinct, as shown here:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            (RedHatBoyStateMachine::Idle(state), </p>
			<p class="source-code">             Event::Run) =&gt; <strong class="bold">state.run().into()</strong>,</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>Replacing calls like <strong class="source-inline">RedHatBoyStateMachine::Idle::Running(state.run)</strong> with <strong class="source-inline">into</strong> isn't just prettier and more concise; it also means that if <strong class="source-inline">run</strong> changes to return a different state, the <strong class="source-inline">transition</strong> method can stay the same, as long as a <strong class="source-inline">From</strong> trait has been written to go from the state to the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong>. It's a nice little change that makes our code more flexible.</p>
			<p>It's a little odd that the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong> is what we call our state machine because we don't normally associate <a id="_idIndexMarker280"/>enumerated types with behavior, but this <a id="_idIndexMarker281"/>method is why we call it a machine. We use <strong class="source-inline">enum</strong> to hold the various generic states, and we use the ability to add methods to an <strong class="source-inline">enum</strong> to make it a lot more ergonomic to use. The various states know how to transition from one state to another, and the machine knows when to do the transitions.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor102"/>Integrating the state machine</h2>
			<p>Now that we've built a <a id="_idIndexMarker282"/>state machine, albeit one with two states, we need to actually use it for <a id="_idIndexMarker283"/>something. Recall our current game, let RHB run throughout a meaningless void. We're going to want to change it so that RHB starts in the left corner and begins running when the user hits the <em class="italic">right arrow key</em>. In other words, they will transition from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>. When that happens, we'll also want to make sure we're showing the appropriate animation.</p>
			<p>We'll start by putting <strong class="source-inline">RedHatBoy</strong> in the <strong class="source-inline">WalkTheDog</strong> game:</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">    image: Option&lt;HtmlImageElement&gt;,</p>
			<p class="source-code">    sheet: Option&lt;Sheet&gt;,</p>
			<p class="source-code">    frame: u8,</p>
			<p class="source-code">    position: Point,</p>
			<p class="source-code">    rhb: Option&lt;RedHatBoy&gt;,</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog {</p>
			<p class="source-code">            image: None,</p>
			<p class="source-code">            sheet: None,</p>
			<p class="source-code">            frame: 0,</p>
			<p class="source-code">            position: Point { x: 0, y: 0 },</p>
			<p class="source-code">            rhb: None,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>RHB will need to be an <strong class="source-inline">Option</strong> for now because <strong class="source-inline">RedHatBoy</strong> contains a sprite sheet. Since the <a id="_idIndexMarker284"/>sprite <a id="_idIndexMarker285"/>sheet isn't available until the image is loaded in <strong class="source-inline">initialize</strong>, we have to make <strong class="source-inline">rhb</strong> an <strong class="source-inline">Option</strong> type. We'll want to initialize the machine in the <strong class="source-inline">initialize</strong> function, and for that purpose, we'll want to create a convenient <strong class="source-inline">new</strong> method for the <strong class="source-inline">Idle</strong> state:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    use crate::engine::Point;</p>
			<p class="source-code">    const FLOOR: i16 = 475;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        pub fn new() -&gt; Self {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: RedHatBoyContext {</p>
			<p class="source-code">                    frame: 0,</p>
			<p class="source-code">                    position: Point { x: 0, y: FLOOR },</p>
			<p class="source-code">                    velocity: Point { x: 0, y: 0 },</p>
			<p class="source-code">                },</p>
			<p class="source-code">                _state: Idle {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p>Because <strong class="source-inline">Idle</strong> is the initial state, it's the only state that will get a <strong class="source-inline">new</strong> function, as mentioned earlier. We've also introduced a constant called <strong class="source-inline">FLOOR</strong> that marks the bottom of the screen, where RHB will land when he jumps.</p>
			<p>I'll show it here as if it's defined right at the top of the <strong class="source-inline">red_hat_boy_states</strong> module. Now, in <strong class="source-inline">Game</strong> <strong class="source-inline">initialize</strong>, we still have a compiler error because we haven't set up <strong class="source-inline">RedHatBoy</strong> in the game. We can do that right after we've loaded the sprite sheet, and we'll<a id="_idIndexMarker286"/> keep <a id="_idIndexMarker287"/>two copies of the sprite sheet around; not because we want two copies, but because we'll delete all the old code when we've successfully replaced it with the new code. You can see the changes here:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        let sheet<strong class="bold">: Option&lt;Sheet&gt;</strong> = browser::fetch_json(</p>
			<p class="source-code">         "rhb.json").await?.into_serde()?;</p>
			<p class="source-code">        let image = Some(engine::load_image(</p>
			<p class="source-code">         "rhb.png").await?);</p>
			<p class="source-code">        Ok(Box::new(WalkTheDog {</p>
			<p class="source-code">            <strong class="bold">image: image.clone(),</strong></p>
			<p class="source-code">            <strong class="bold">sheet: sheet.clone(),</strong></p>
			<p class="source-code">            frame: self.frame,</p>
			<p class="source-code">            position: self.position,</p>
			<p class="source-code">           <strong class="bold"> rhb: Some(RedHatBoy::new(</strong></p>
			<p class="source-code"><strong class="bold">                sheet.clone().ok_or_else(|| anyhow!</strong></p>
			<p class="source-code"><strong class="bold">                    ("No Sheet Present"))?,</strong></p>
			<p class="source-code"><strong class="bold">                image.clone().ok_or_else(|| anyhow!</strong></p>
			<p class="source-code"><strong class="bold">                    ("No Image Present"))?,</strong></p>
			<p class="source-code"><strong class="bold">            )),</strong></p>
			<p class="source-code">        }))</p>
			<p class="source-code">    }</p>
			<p class="source-code">...</p>
			<p>We had to change a surprising amount of code here, because of Rust's borrowing rules. Our intent is to <strong class="source-inline">clone</strong> <strong class="source-inline">sheet</strong> and <strong class="source-inline">image</strong> and send those into the <strong class="source-inline">RedHatBoy::new</strong> method. However, if we do that, we also need to clone <strong class="source-inline">image</strong> and <strong class="source-inline">sheet</strong> when setting the fields for <strong class="source-inline">image</strong> and <strong class="source-inline">sheet</strong> on <strong class="source-inline">WalkTheDogStruct</strong>. Why? Because the <strong class="source-inline">image: image</strong> line is a move, and can't be accessed after that. That's the borrow after move error. Instead we clone <strong class="source-inline">image</strong> and sheet and move the cloned instances into WalkTheDog. Then when creating the RedHatBoy we clone them again.</p>
			<p>The same goes for <strong class="source-inline">sheet</strong>. We also have to explicitly call out the type of <strong class="source-inline">sheet</strong> when we assign it in the first <a id="_idIndexMarker288"/>place because the compiler can't infer <a id="_idIndexMarker289"/>the type anymore. Fortunately, this is an intermediate step; we are working past the compiler errors and will eventually reduce this code to what we actually need. We can't yet because we've replaced one compiler error with two!</p>
			<p>Before, the <strong class="source-inline">rhb</strong> field wasn't filled in when we created <strong class="source-inline">WalkTheDog</strong>, so that didn't compile. In order to set the <strong class="source-inline">rhb</strong> field to something, we are presuming a <strong class="source-inline">RedHatBoy::new</strong> method exists, but it doesn't, so that doesn't compile. We are also passing the soon-to-exist constructor clones of <strong class="source-inline">sheet</strong> and <strong class="source-inline">image</strong>. The <strong class="source-inline">Sheet</strong> type doesn't support <strong class="source-inline">clone</strong> yet, so that doesn't compile either. We'll need to fix both of these compiler errors to move forward.</p>
			<p>Before we continue, I want to note how we use the <strong class="source-inline">ok_or_else</strong> construct on each <strong class="source-inline">clone</strong> call, and then the <strong class="source-inline">?</strong> operator. <strong class="source-inline">RedHatBoy</strong> doesn't need to hold <strong class="source-inline">Option&lt;Sheet&gt;</strong> or <strong class="source-inline">Option&lt;HtmlImageElement&gt;</strong>, so its constructor will take <strong class="source-inline">Sheet</strong> and <strong class="source-inline">HtmlImageElement</strong>. Calling <strong class="source-inline">ok_or_else</strong> will convert <strong class="source-inline">Option</strong> into <strong class="source-inline">Result</strong>, and <strong class="source-inline">?</strong> will return from the <strong class="source-inline">initialize</strong> method with <strong class="source-inline">Error</strong> if the value isn't present. This prevents the rest of the code from having to continually validate that the <strong class="source-inline">Option</strong> type is present, so the code will be a little bit cleaner. The <strong class="source-inline">Option</strong> type is great, but at any time you can replace working with an <strong class="source-inline">Option</strong> type with the actual value it's wrapping.</p>
			<p>The easiest of the two compiler errors to fix is the fact that <strong class="source-inline">sheet</strong> doesn't implement <strong class="source-inline">clone</strong>. Many in the Rust community derive <strong class="source-inline">Clone</strong> on any public type, and while I won't be following that <a id="_idIndexMarker290"/>practice in this book, there's no reason not to add<a id="_idIndexMarker291"/> it to <strong class="source-inline">Sheet</strong> and the types it references, as shown here. Remember, <strong class="source-inline">Sheet</strong> is in the <strong class="source-inline">engine</strong> module:</p>
			<p class="source-code">#[derive(Deserialize, <strong class="bold">Clone</strong>)]</p>
			<p class="source-code">pub struct SheetRect {</p>
			<p class="source-code">    pub x: i16,</p>
			<p class="source-code">    pub y: i16,</p>
			<p class="source-code">    pub w: i16,</p>
			<p class="source-code">    pub h: i16,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Deserialize, <strong class="bold">Clone</strong>)]</p>
			<p class="source-code">pub struct Cell {</p>
			<p class="source-code">    pub frame: SheetRect,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Deserialize, <strong class="bold">Clone</strong>)]</p>
			<p class="source-code">pub struct Sheet {</p>
			<p class="source-code">    pub frames: HashMap&lt;String, Cell&gt;,</p>
			<p class="source-code">}</p>
			<p>Now, we're down to one compiler error, <strong class="source-inline">RedHatBoy</strong> doesn't have a <strong class="source-inline">new</strong> function, so let's create an <strong class="source-inline">impl</strong> block for the <strong class="source-inline">RedHatBoy</strong> struct and define that, as shown here:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    fn new(sheet: Sheet, image: HtmlImageElement) -&gt; Self {</p>
			<p class="source-code">        RedHatBoy {</p>
			<p class="source-code">            state_machine: RedHatBoyStateMachine::Idle(</p>
			<p class="source-code">             RedHatBoyState::new()),</p>
			<p class="source-code">            sprite_sheet: sheet,</p>
			<p class="source-code">            image,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This creates a new <strong class="source-inline">RedHatBoy</strong> with <a id="_idIndexMarker292"/>a state machine in the <strong class="source-inline">Idle</strong> state. We've <a id="_idIndexMarker293"/>also loaded <strong class="source-inline">sprite_sheet</strong> and <strong class="source-inline">image</strong> in the <strong class="source-inline">initialize</strong> function and passed them to this constructor. Congratulations! Our code compiles!</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor103"/>Drawing RedHatBoy</h2>
			<p>Unfortunately, this <a id="_idIndexMarker294"/>still doesn't<a id="_idIndexMarker295"/> do much. <strong class="source-inline">RedHatBoy</strong> is never drawn! The interface we want is to say <strong class="source-inline">self.rhb.draw()</strong> and see RHB drawing the idle animation. We also want to call the <strong class="source-inline">run</strong> function when we push the <em class="italic">right arrow</em> and see RHB run.</p>
			<p>Let's start by implementing <strong class="source-inline">draw</strong> on <strong class="source-inline">RedHatBoy</strong>. We'll create a draw function that will mimic the draw function in <strong class="source-inline">WalkTheDog</strong> only using the shared <strong class="source-inline">RedHatBoyContext</strong> that's in <strong class="source-inline">RedHatBoyState</strong>. That<a id="_idIndexMarker296"/> code is as follows, written as part of <a id="_idIndexMarker297"/>the <strong class="source-inline">impl RedHatBoy</strong> block:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        let frame_name = format!(</p>
			<p class="source-code">            "{} ({}).png",</p>
			<p class="source-code">            self.state_machine.frame_name(),</p>
			<p class="source-code">            (self.state_machine.context().frame / 3) + 1</p>
			<p class="source-code">        );</p>
			<p class="source-code">        let sprite = self</p>
			<p class="source-code">            .sprite_sheet</p>
			<p class="source-code">            .frames</p>
			<p class="source-code">            .get(&amp;frame_name)</p>
			<p class="source-code">            .expect("Cell not found");</p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">            &amp;self.image,</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: sprite.frame.x.into(),</p>
			<p class="source-code">                y: sprite.frame.y.into(),</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: self.state_machine.context()</p>
			<p class="source-code">                 .position.x.into(),</p>
			<p class="source-code">                y: self.state_machine.context()</p>
			<p class="source-code">                 .position.y.into(),</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is nearly identical to the code that exists in the <strong class="source-inline">draw</strong> function already for our happily running RHB. Instead of always using the <strong class="bold">Run</strong> animation, now we're dynamically choosing the animation based on the state of the system, via the <strong class="source-inline">frame_name</strong> function, which doesn't exist yet.</p>
			<p>We're also getting <strong class="source-inline">position</strong> and <strong class="source-inline">frame</strong> off <strong class="source-inline">context()</strong>, another function that doesn't exist<a id="_idIndexMarker298"/> yet. Again, we'll let the compiler guide us to create both<a id="_idIndexMarker299"/> of these functions; Compiler-Driven Development strikes again! The <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong> needs to provide a way to return <strong class="source-inline">RedHatBoyContext</strong> and <strong class="source-inline">frame_name</strong>. We can add those implementations, as follows:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn frame_name(&amp;self) -&gt;&amp;str {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Idle(state) =&gt; </p>
			<p class="source-code">             state.frame_name(),</p>
			<p class="source-code">            RedHatBoyStateMachine::Running(state) =&gt; </p>
			<p class="source-code">             state.frame_name(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn context(&amp;self) -&gt;&amp;RedHatBoyContext {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Idle(state) </p>
			<p class="source-code">             =&gt;&amp;state.context(),</p>
			<p class="source-code">            RedHatBoyStateMachine::Running(state) </p>
			<p class="source-code">             =&gt;&amp;state.context(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I admit I don't love either of these methods and did consider creating a trait that the various states would implement as an alternative. After some thought, I decided this was simpler, and because the Rust compiler will fail if you don't match every single <strong class="source-inline">enum</strong> variant, I'm willing to accept these duplicate <em class="italic">case</em> statements.</p>
			<p>The <strong class="source-inline">frame_name</strong> and <strong class="source-inline">context</strong> methods both delegate to the currently active <strong class="source-inline">state</strong> to get the data that's required. In the case of <strong class="source-inline">frame_name</strong>, this will be a method that returns the name of the animation in <strong class="source-inline">rhb.json</strong> for a given state as defined on each state. The <strong class="source-inline">context</strong> method is particularly odd because we always return the same field for every single state and always will, as that data is shared across all the <a id="_idIndexMarker300"/>states. That's <a id="_idIndexMarker301"/>going to require a generic implementation, which we'll write in a moment. An exercise for you would be to simplify these functions with a macro, but we won't do that here.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You might have noticed that the line <strong class="source-inline">self.state_machine.context().position.x</strong> violates the <strong class="bold">Law of Demeter</strong> and<a id="_idIndexMarker302"/> objects to it. The Law of Demeter is a style guideline for OO code that states that you should <em class="italic">only talk to your immediate friends</em>, and in this case, <strong class="source-inline">self</strong> should only talk to <strong class="source-inline">state_machine</strong> (its friend) but instead, it talks to <strong class="source-inline">position</strong> via <strong class="source-inline">context</strong>. This couples <strong class="source-inline">RedHatBoy</strong> to the internal structure of <strong class="source-inline">RedHatBoyContext</strong> in a way that could be avoided by adding getters for <strong class="source-inline">position_x</strong> and <strong class="source-inline">position_y</strong> on <strong class="source-inline">state machine</strong>, which would delegate to <strong class="source-inline">context</strong>, which would, in turn, delegate to <strong class="source-inline">position</strong>. The Law of Demeter is a great guideline when setting values, and you should almost always follow it for mutable data, but in this case the data is immutable. We can't change the context through this getter, and the downsides of violating the Law of Demeter are not as relevant. I don't feel it's necessary to create more delegating functions just to avoid violating an arbitrary guideline, but if it becomes a problem, we can always change it. For more information <a id="_idIndexMarker303"/>on this, go to <a href="https://wiki.c2.com/?LawOfDemeter">https://wiki.c2.com/?LawOfDemeter</a>.</p>
			<p>Following the compiler again, we've moved the errors from the <strong class="source-inline">draw</strong> method on <strong class="source-inline">RedHatBoy</strong> into <strong class="source-inline">RedHatBoyStateMachine</strong> because none of the states have methods for <strong class="source-inline">frame_name</strong> or <strong class="source-inline">context</strong>. Out of these two methods, <strong class="source-inline">frame_name</strong> is more straightforward, so we'll implement it first. It's a getter of the name of<a id="_idIndexMarker304"/> the<a id="_idIndexMarker305"/> frame in the <strong class="source-inline">rhb.json</strong> file, and it's different for every state, so we'll put that method on every state, as shown here:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    use crate::engine::Point;</p>
			<p class="source-code">    const FLOOR: i16 = 475;</p>
			<p class="source-code">    <strong class="bold">const IDLE_FRAME_NAME: &amp;str = "Idle";</strong></p>
			<p class="source-code">    <strong class="bold">const RUN_FRAME_NAME: &amp;str = "Run";</strong></p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        <strong class="bold">pub fn frame_name(&amp;self) -&gt; &amp;str {</strong></p>
			<p class="source-code">            <strong class="bold">IDLE_FRAME_NAME</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        <strong class="bold">pub fn frame_name(&amp;self) -&gt; &amp;str {</strong></p>
			<p class="source-code">            <strong class="bold">RUN_FRAME_NAME</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've added two constants, <strong class="source-inline">IDLE_FRAME_NAME</strong> and <strong class="source-inline">RUN_FRAME_NAME</strong>, which correspond to the names of the frames for the <strong class="source-inline">Idle</strong> and <strong class="source-inline">Run</strong> sections of our sprite sheets, respectively. We then created a new method, <strong class="source-inline">frame_name</strong>, on <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> as well as an entirely new implementation for <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong>, which also has a <strong class="source-inline">frame_name</strong> method.</p>
			<p>It's worth thinking about whether we could use a trait object (<a href="https://bit.ly/3JSyoI9">https://bit.ly/3JSyoI9</a>) instead of our <strong class="source-inline">enum</strong> for <strong class="source-inline">RedHatBoyStateMachine</strong>, and it probably is possible. I've experimented with it and didn't come to a satisfying solution, but I would encourage you to give it a shot. You'll learn a lot more from this book if you experiment with the code on your own. </p>
			<p>Now that we've handled the <strong class="source-inline">frame_name</strong> method, we'll want to add a <strong class="source-inline">context</strong> method. That <a id="_idIndexMarker306"/>method <a id="_idIndexMarker307"/>is going to do the same thing for every state, return the context, and we can write it generically for all of them, as shown here:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    #[derive(Copy, Clone)]</p>
			<p class="source-code">    pub struct RedHatBoyState&lt;S&gt; {</p>
			<p class="source-code">        context: RedHatBoyContext,</p>
			<p class="source-code">        _state: S,</p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">impl&lt;S&gt; RedHatBoyState&lt;S&gt; {</strong></p>
			<p class="source-code">        <strong class="bold">pub fn context(&amp;self) -&gt; &amp;RedHatBoyContext {</strong></p>
			<p class="source-code">            <strong class="bold">&amp;self.context</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">...</p>
			<p>This is a pretty cool feature of Rust. Since we have a generic struct, we can write methods on the generic type, and it will apply to all the types. Finally, there is one more compiler <a id="_idIndexMarker308"/>error, in the <strong class="source-inline">draw</strong> function where we reference the frame<a id="_idIndexMarker309"/> or position fields on context. These fields are private, but as long as <strong class="source-inline">RedHatBoyContext</strong> is an immutable type, we can each make of those public, as follows:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    #[derive(Copy, Clone)]</p>
			<p class="source-code">    pub struct RedHatBoyContext {</p>
			<p class="source-code">        <strong class="bold">pub </strong>frame: u8,</p>
			<p class="source-code">        <strong class="bold">pub </strong>position: Point,</p>
			<p class="source-code">        <strong class="bold">pub </strong>velocity: Point,</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p>Finally, we need to call that method on <strong class="source-inline">RedHatBoy</strong> in the <strong class="source-inline">WalkTheDog#draw</strong> function. You can add that in this, admittedly awkward, one-liner right at the end of the <strong class="source-inline">draw</strong> function:</p>
			<p class="source-code">fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    self.rhb.as_ref().unwrap().draw(renderer);</p>
			<p>If you've<a id="_idIndexMarker310"/> followed <a id="_idIndexMarker311"/>along successfully, you should see the following screen:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 4.4 – RHBs&#13;&#10;" src="image/Figure_4.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – RHBs</p>
			<p>At the top we have our old, endlessly running RHB, and at the bottom our new RHB just standing still. The new version has fewer features; we've gone backward, but why? This prepared us for what we're going to do next, moving him around and changing animations. Speaking of animations, the <strong class="source-inline">Idle</strong> version of RHB isn't doing anything yet, because <strong class="source-inline">frame</strong> never changes. When RHB is idle, he stand<a id="_idTextAnchor104"/>s while breathing slowly, so let's get that started, shall we?</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor105"/>Updating RHB</h2>
			<p>Our <strong class="source-inline">RedHatBoy</strong> struct is<a id="_idIndexMarker312"/> going to have an <strong class="source-inline">update</strong> function, which<a id="_idIndexMarker313"/> will, in turn, delegate to an <strong class="source-inline">update</strong> function on the state machine. It's a new method because every state is going to need to update, in order to advance the animation. We'll call <strong class="source-inline">update</strong> on <strong class="source-inline">RedHatBoy</strong> from <strong class="source-inline">update</strong> on <strong class="source-inline">WalkTheDog</strong>. That's a lot of updates, but it's really just delegation:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">....</p>
			<p class="source-code">        if self.frame &lt; 23 {</p>
			<p class="source-code">            self.frame += 1;</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            self.frame = 0;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        <strong class="bold">self.rhb.as_mut().unwrap().update();</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">fn update(&amp;mut self) {</strong></p>
			<p class="source-code">        <strong class="bold">self.state_machine = self.state_machine.update();</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">fn update(self) -&gt; Self {</strong></p>
			<p class="source-code">        <strong class="bold">match self {</strong></p>
			<p class="source-code">            <strong class="bold">RedHatBoyStateMachine::Idle(mut state) =&gt; {</strong></p>
			<p class="source-code">                <strong class="bold">if state.context.frame &lt; 29 {</strong></p>
			<p class="source-code">                    <strong class="bold">state.context.frame += 1;</strong></p>
			<p class="source-code">                <strong class="bold">} else {</strong></p>
			<p class="source-code">                    <strong class="bold">state.context.frame = 0;</strong></p>
			<p class="source-code">                <strong class="bold">}</strong></p>
			<p class="source-code">                <strong class="bold">RedHatBoyStateMachine::Idle(state)</strong></p>
			<p class="source-code">            <strong class="bold">}</strong></p>
			<p class="source-code">            <strong class="bold">RedHatBoyStateMachine::Running(_) =&gt; self,</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">update</strong> function on <strong class="source-inline">WalkTheDog</strong>, we've only added one new line, at the end of the <strong class="source-inline">update</strong> function:</p>
			<p class="source-code">self.rhb.as_mut().unwrap().update();</p>
			<p>It's funky because <a id="_idIndexMarker314"/>of the fact that <strong class="source-inline">rhb</strong> is <strong class="source-inline">Option</strong>, and we'll fix that in a little<a id="_idIndexMarker315"/> bit. We've added another small function to the <strong class="source-inline">RedHatBoy</strong> <strong class="source-inline">struct</strong> <strong class="source-inline">update</strong> that simply updates <strong class="source-inline">state_machine</strong> via the state machine's <strong class="source-inline">update</strong> function. This one line, and others like it, are why the state machine needs to be <strong class="source-inline">Copy</strong>. If it's not, then because <strong class="source-inline">update</strong> consumes <strong class="source-inline">self</strong> via the parameter of <strong class="source-inline">mut self</strong>, you'd have to use something like <strong class="source-inline">Option</strong> to move <strong class="source-inline">self</strong> into <strong class="source-inline">update</strong>, and then reset it again. By making everything <strong class="source-inline">Copy</strong>, you get a much more ergonomic <strong class="source-inline">update</strong> function.</p>
			<p>Finally, the meat of the behavior is in the <strong class="source-inline">RedHatBoyStateMachine#update</strong> function. Here, we match on <strong class="source-inline">self</strong> and update the current frame on a mutable <strong class="source-inline">state</strong> parameter, and then return a new <strong class="source-inline">Idle</strong> state with a moved <strong class="source-inline">context</strong> with an updated frame. Unfortunately, this code doesn't compile; <strong class="source-inline">context</strong> isn't a public data member so you can't assign it. For now, we'll go ahead and make <strong class="source-inline">context</strong> public, but this should bother you. Remember that Law of Demeter guideline I mentioned earlier. It's one thing to get an immutable data value, another thing entirely to set a mutable value. This is the kind of coupling that could cause real problems down the line. We're <em class="italic">not</em> going to fix it right now, so go ahead and make <strong class="source-inline">context</strong> public, but we will be keeping a very close eye on this code.</p>
			<p>At this point, if you look at <strong class="source-inline">update</strong> for <strong class="source-inline">WalkTheDog</strong> and <strong class="source-inline">update</strong> for <strong class="source-inline">RedHatBoyStateMachine</strong>, you'll see similarities. One is updating the running RHB in the upper<a id="_idIndexMarker316"/> left<a id="_idIndexMarker317"/> corner, and one is updating the idle RHB in the lower left. The time has come to begin combining these two objects. Let's go ahead and do that.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Adding the Running state</h2>
			<p>One thing to keep in <a id="_idIndexMarker318"/>mind about states is that they exist whether you implement a state machine or not. While we <a id="_idIndexMarker319"/>haven't implemented anything in <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong>, the <strong class="source-inline">Running</strong> state currently exists in <strong class="source-inline">WalkTheDog</strong>; RHB is running all around the void right now! We just need to move the details into our state machine, so that we as programmers can actually see the states and what they do as one coherent unit. Plus, then we'll stop having a sad and lonely boy who is running in place in the left-hand corner of the screen.</p>
			<p>We can do that quickly by just modifying <strong class="source-inline">update</strong> in <strong class="source-inline">RedHatBoyStateMachine</strong> to match the version in <strong class="source-inline">Idle</strong>, with the different frame count for the run animation. That's shown as follows:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(self) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            RedHatBoyStateMachine::Running(mut state) =&gt; {</p>
			<p class="source-code">                if state.context.frame &lt; 23 {</p>
			<p class="source-code">                    state.context.frame += 1;</p>
			<p class="source-code">                } else {</p>
			<p class="source-code">                    state.context.frame = 0;</p>
			<p class="source-code">                }</p>
			<p class="source-code">                RedHatBoyStateMachine::Running(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, the state machine is theoretically capable of drawing the run animation, but we haven't written anything to cause that transition. The other thing missing is potentially more subtle. The <strong class="source-inline">Running</strong> animation has <strong class="source-inline">23</strong> frames, and the <strong class="source-inline">Idle</strong> animation has <strong class="source-inline">29</strong>. If we were to transform from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong> with the frame count at <strong class="source-inline">24</strong>, the game would crash.</p>
			<p>Finally, I think we<a id="_idIndexMarker320"/> can all <a id="_idIndexMarker321"/>agree that the kind of duplication that we have here can be improved. The only difference between the two functions is the frame count. So, we have a few things to do:</p>
			<ol>
				<li>Refactor the duplicated code.</li>
			</ol>
			<p>The code that updates <strong class="source-inline">context.frame</strong> suffers from a code smell called <strong class="bold">Feature Envy</strong> (<a href="https://bit.ly/3ytptHA">https://bit.ly/3ytptHA</a>) because the <strong class="source-inline">update</strong> function is operating over and <a id="_idIndexMarker322"/>over again on <strong class="source-inline">context</strong>. Why not move that function to <strong class="source-inline">RedHatBoyContext</strong>? That's shown here:</p>
			<p class="source-code">const IDLE_FRAMES: u8 = 29;</p>
			<p class="source-code">const RUNNING_FRAMES: u8 = 23;</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn update(self) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Idle(mut state) =&gt; {</p>
			<p class="source-code">                state.context = </p>
			<p class="source-code">                 state.context.update(IDLE_FRAMES);</p>
			<p class="source-code">                RedHatBoyStateMachine::Idle(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">            RedHatBoyStateMachine::Running(mut state) </p>
			<p class="source-code">             =&gt; {</p>
			<p class="source-code">                state.context = state.context.update(</p>
			<p class="source-code">                 RUNNING_FRAMES);</p>
			<p class="source-code">                RedHatBoyStateMachine::Running(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        pub fn update(mut self, frame_count: u8) -&gt; </p>
			<p class="source-code">         Self {</p>
			<p class="source-code">            if self.frame &lt; frame_count {</p>
			<p class="source-code">                self.frame += 1;</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                self.frame = 0;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            self</p>
			<p class="source-code">        }</p>
			<p class="source-code">    } </p>
			<p><strong class="source-inline">RedHatBoyContext</strong> now has an <strong class="source-inline">update</strong> function that increments the frame, looping it back to <strong class="source-inline">0</strong> when the total frame count is reached. Note how it works the same way as <a id="_idIndexMarker323"/>our transitions, consuming <strong class="source-inline">self</strong>, and returning<a id="_idIndexMarker324"/> a new <strong class="source-inline">RedHatBoyContext</strong>, although in reality, it's the same <strong class="source-inline">instance</strong> the entire time. This gives us the same kind of <em class="italic">functional</em> interface that we're using elsewhere. The total frame count changes with each state, so we pass that in as a parameter, using constants for clarity.</p>
			<ol>
				<li value="2">Fix the Law of Demeter violation.</li>
			</ol>
			<p>Looking at the two arms of each <strong class="source-inline">match</strong> statement, they are nearly identical, both mutating <strong class="source-inline">context</strong> in the way we didn't like earlier. Now is a good time to address it, which we can do by making the field private on <strong class="source-inline">RedHatBoyState&lt;S&gt;</strong> again, and creating new methods on the respective <strong class="source-inline">RedHatBoy</strong> state implementations, as shown here:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    const IDLE_FRAMES: u8 = 29;</p>
			<p class="source-code">    const RUNNING_FRAMES: u8 = 23;</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        ....</p>
			<p class="source-code">        pub fn update(&amp;mut self) {</p>
			<p class="source-code">            self.context = self.context.update(</p>
			<p class="source-code">             IDLE_FRAMES);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">         ...</p>
			<p class="source-code">         pub fn update(&amp;mut self) {</p>
			<p class="source-code">            self.context = self.context.update(</p>
			<p class="source-code">             RUNNING_FRAMES);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There! That's better. <strong class="source-inline">context</strong> is no longer inappropriately public, and each individual state handles its own updating. The only difference between them is the constant they use, and it's fitting to have that bundled with the implementation itself. Speaking of which, make sure you move the <strong class="source-inline">RUNNING_FRAMES</strong> and <strong class="source-inline">IDLE_FRAMES</strong> constants into the <strong class="source-inline">red_hat_boy_states</strong> module.</p>
			<p>We'll need <a id="_idIndexMarker325"/>to <a id="_idIndexMarker326"/>modify the <strong class="source-inline">update</strong> method on <strong class="source-inline">RedHatBoyStateMachine</strong> to call this new method on each of the states:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    fn update(self) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Idle(mut state) =&gt; </p>
			<p class="source-code">            {</p>
			<p class="source-code">                state.update();</p>
			<p class="source-code">                RedHatBoyStateMachine::Idle(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">            RedHatBoyStateMachine::Running(mut state) </p>
			<p class="source-code">             =&gt; {</p>
			<p class="source-code">                state.update();</p>
			<p class="source-code">                RedHatBoyStateMachine::Running(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Each of the <a id="_idIndexMarker327"/>arms<a id="_idIndexMarker328"/> in update now updates the state, and then returns the state. There's some duplication here that's a little suspicious; we'll take another look at that shortly. </p>
			<ol>
				<li value="3">Move RHB on every <strong class="source-inline">update</strong>.</li>
			</ol>
			<p>If RHB is going to run in the running state, it needs to respect the velocity. In other words, update animates the frame, but it doesn't move, so let's add that to the <strong class="source-inline">RedHatBoyContext</strong> <strong class="source-inline">update</strong> method:</p>
			<p class="source-code">fn update(mut self, frame_count: u8) -&gt; Self {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    self.position.x += self.velocity.x;</p>
			<p class="source-code">    self.position.y += self.velocity.y;</p>
			<p class="source-code">    self</p>
			<p class="source-code">}</p>
			<p>Of course, RHB won't move yet because we aren't changing the velocity. That will come soon.</p>
			<ol>
				<li value="4">Ensure that the frame count resets to <strong class="source-inline">0</strong> when transitioning between states.</li>
			</ol>
			<p>There are two <a id="_idIndexMarker329"/>categories of changes on the game object that can<a id="_idIndexMarker330"/> happen in our state machine. There are changes that happen when the state doesn't change. That's what <strong class="source-inline">update</strong> is and right now those are written in <strong class="source-inline">RedHatBoyStateMachine</strong>. There are also changes that happen on a transition, and those happen in the transition functions that are defined as methods of the type classes.</p>
			<p>We already transitioned from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong> via the <strong class="source-inline">run</strong> method, and we can make sure to reset the frame rate on the transition. That's a small change you can see here:</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        fn reset_frame(mut self) -&gt; Self {</p>
			<p class="source-code">            self.frame = 0;</p>
			<p class="source-code">            self</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        ....</p>
			<p class="source-code">        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context<strong class="bold">.reset_frame()</strong>,</p>
			<p class="source-code">                _state: Running {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p><strong class="source-inline">RedHatBoyContext</strong> has grown a function called <strong class="source-inline">reset_frame</strong>, which resets its frame <a id="_idIndexMarker331"/>count to <strong class="source-inline">0</strong> and returns itself. By returning itself, we<a id="_idIndexMarker332"/> can chain calls together, which will come in handy shortly. The <strong class="source-inline">run</strong> method has also evolved to call <strong class="source-inline">reset_frame()</strong> on <strong class="source-inline">RedHatBoyContext</strong> and use that new version of <strong class="source-inline">context</strong> in the new <strong class="source-inline">RedHatBoyState</strong> struct.</p>
			<ol>
				<li value="5">Start Running on transition.</li>
			</ol>
			<p>Now that we have prevented crashes by restarting animations on transitions, let's start running forward on a transition. This is going to be very short:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">....</p>
			<p class="source-code">const RUNNING_SPEED: i16 = 3;</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoyContext {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">        fn run_right(mut self) -&gt; Self {</p>
			<p class="source-code">            self.velocity.x += RUNNING_SPEED;</p>
			<p class="source-code">            self</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context.reset_frame()</p>
			<p class="source-code">                 <strong class="bold">.run_right()</strong>,</p>
			<p class="source-code">                _state: Running {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>We've sprouted another method on <strong class="source-inline">RedHatBoyContext</strong> called <strong class="source-inline">run_right</strong>, which <a id="_idIndexMarker333"/>simply adds forward speed to the velocity. Meanwhile, we've<a id="_idIndexMarker334"/> chained a call (see!) to <strong class="source-inline">run_right</strong> in the transition. Don't forget to add the <strong class="source-inline">RUNNING_SPEED</strong> constant to the module.</p>
			<ol>
				<li value="6">Start Running on the <em class="italic">right</em> arrow.</li>
			</ol>
			<p>Finally, we actually need to call this event when the <strong class="source-inline">ArrowRight</strong> button is pressed. At this point, we can follow along with where we're doing this in the <strong class="source-inline">WalkTheDog</strong> implementation:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">        velocity.x += 3;</p>
			<p class="source-code">        <strong class="bold">self.rhb.as_mut().unwrap().run_right();</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn run_right(&amp;mut self) {</p>
			<p class="source-code">        self.state = self.state.transition(</p>
			<p class="source-code">         Event::Run);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This will now start <a id="_idIndexMarker335"/>our RHB running, so much so that he'll run<a id="_idIndexMarker336"/> right off the screen!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 4.5 – This could be a problem" src="image/Figure_4.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – This could be a problem</p>
			<p>At this point, we could re-establish <em class="italic">moonwalking</em>, to bring RHB back on screen, but that doesn't really serve the purpose of the game. You can either create an event that resets horizontal velocity every update, just like the current code does, or you could track when a key goes up to remove some velocity. The second one feels better but will cause us to write a few events and possibly a transition from <strong class="source-inline">Running</strong> to <strong class="source-inline">Idle</strong>. No, we'll go to a third approach: ignore it and hit refresh! We don't need to move backward in our actual game, nor stop, so we won't. Let's not spend any more time writing code, that we'll just delete anyway. Speaking of that.</p>
			<ol>
				<li value="7">Delete the original code.</li>
			</ol>
			<p>Now that the new and improved RHB is moving, it's time to get rid of all the references in <strong class="source-inline">WalkTheDog</strong> to the sheet, the element, the frame…basically anything that isn't the <strong class="source-inline">RedHatBoy</strong> <strong class="source-inline">struct</strong>:</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">   rhb: Option&lt;RedHatBoy&gt;,</p>
			<p class="source-code">}</p>
			<p>Rather than boring you with endless deletes, I'll simply say you can delete all the fields that aren't <strong class="source-inline">rhb</strong> and follow the compiler errors to delete the rest of the code. When you're done, <strong class="source-inline">WalkTheDog</strong> becomes very short, as it should be. As for the arrow keys, you only need to worry about the <strong class="source-inline">ArrowRight</strong> key, and moving to the right.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As I said, we won't be restoring moving backward, up, or down here, but you could certainly consider restoring the walking backward functionality by extending the state machine. Doing so will help you internalize the lesson here and save you the trouble of refreshing all the time.</p>
			<p>So, now RHB<a id="_idIndexMarker337"/> can run <a id="_idIndexMarker338"/>across the screen, but that's not much fun. Let's add sliding.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor107"/>Transitioning to sliding</h2>
			<p>Transitioning<a id="_idIndexMarker339"/> from running to sliding will involve adding a <a id="_idIndexMarker340"/>new state for sliding, so that we see the sliding action, but also checking for when a slide is complete and transitioning back into the running state. This will mean sliding will have its own variation on the <strong class="source-inline">update</strong> function. We can start by adding sliding on the <em class="italic">down</em> arrow and treating it all just like running. We'll go through this quickly because most of it is familiar. Let's start by adding sliding on the <em class="italic">down</em> arrow in the <strong class="source-inline">update</strong> method of <strong class="source-inline">WalkTheDog</strong>:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        if keystate.is_pressed("ArrowDown") {</p>
			<p class="source-code">            self.rhb.as_mut().unwrap().slide();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>It's time to follow<a id="_idIndexMarker341"/> the compiler. RedHatBoy doesn't have <a id="_idIndexMarker342"/>a <strong class="source-inline">slide</strong> method, so let's add that, as shown here:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn slide(&amp;mut self) {</p>
			<p class="source-code">        self.state_machine = self.state_machine.transition(</p>
			<p class="source-code">         Event::Slide);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Transitioning via <strong class="source-inline">Event::Slide</strong> doesn't exist. There's no <strong class="source-inline">Event::Slide</strong> at all, so let's add those next:</p>
			<p class="source-code">enum Event {</p>
			<p class="source-code">    ....</p>
			<p class="source-code">    Slide,</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            (RedHatBoyStateMachine::Running(state), </p>
			<p class="source-code">             Event::Slide) =&gt; state.slide().into(),</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>There's nothing new in the preceding code block. When RHB is <strong class="source-inline">Running</strong>, it can transition to <strong class="source-inline">Sliding</strong> via the <strong class="source-inline">Event::Slide</strong> event and the <strong class="source-inline">slide</strong> method, which doesn't exist on the <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> typestate. This is all very similar to how we went from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>. </p>
			<p>To continue <a id="_idIndexMarker343"/>with<a id="_idIndexMarker344"/> the compiler, we need to add a <strong class="source-inline">slide</strong> method to the <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> typestate, as in the following:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn slide(self) -&gt; RedHatBoyState&lt;Sliding&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context.reset_frame(),</p>
			<p class="source-code">                _state: Sliding {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>The <strong class="source-inline">slide</strong> method on <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> converts the state into <strong class="source-inline">RedHatBoyState&lt;Sliding&gt;</strong>, only calling <strong class="source-inline">reset_frame</strong> on <strong class="source-inline">context</strong> to make sure the sliding<a id="_idIndexMarker345"/> animation starts playing at frame <strong class="source-inline">0</strong>. We also <a id="_idIndexMarker346"/>call <strong class="source-inline">into</strong> on the <strong class="source-inline">slide </strong>method, which needs to convert <strong class="source-inline">RedHatBoyState&lt;Sliding&gt;</strong> into a <strong class="source-inline">RedHatBoyStateMachine</strong> variant. That means we need to create the variant and create a <strong class="source-inline">From</strong> implementation for it, as shown here:</p>
			<p class="source-code">enum RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    Sliding(RedHatBoyState&lt;Sliding&gt;),</p>
			<p class="source-code">}</p>
			<p class="source-code">impl From&lt;RedHatBoyState&lt;Sliding&gt;&gt; for RedHatBoyStateMachine {</p>
			<p class="source-code">    fn from(state: RedHatBoyState&lt;Sliding&gt;) -&gt; Self {</p>
			<p class="source-code">        RedHatBoyStateMachine::Sliding(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>At this point, you'll see errors on the <strong class="source-inline">frame_name</strong>, <strong class="source-inline">context</strong>, and <strong class="source-inline">update</strong> methods of <strong class="source-inline">RedHatBoyStateMachine</strong> because their corresponding <strong class="source-inline">match</strong> calls don't have cases for the new <strong class="source-inline">Sliding</strong> variant. We can fix that by adding <a id="_idIndexMarker347"/>cases to those <strong class="source-inline">match </strong>statements, which will <a id="_idIndexMarker348"/>mimic the other cases:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...   </p>
			<p class="source-code">    fn frame_name(&amp;self) -&gt; &amp;str {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            RedHatBoyStateMachine::Sliding(state) =&gt; </p>
			<p class="source-code">             state.frame_name(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn context(&amp;self) -&gt;&amp;RedHatBoyContext{</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            RedHatBoyStateMachine::Sliding(state) </p>
			<p class="source-code">             =&gt; &amp;state.context(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn update(self) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            RedHatBoyStateMachine::Sliding(mut state) =&gt; {</p>
			<p class="source-code">                state.update();</p>
			<p class="source-code">                RedHatBoyStateMachine::Sliding(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Once again, we've replaced one compiler error with another. There is no <strong class="source-inline">Sliding</strong> state, and it doesn't have the methods we assumed it would. We<a id="_idIndexMarker349"/> can fix that by filling it in, adding some<a id="_idIndexMarker350"/> constants for good measure:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    const SLIDING_FRAMES: u8 = 14;</p>
			<p class="source-code">    const SLIDING_FRAME_NAME: &amp;str = "Slide";</p>
			<p class="source-code">    ...</p>
			<p class="source-code">   #[derive(Copy, Clone)]</p>
			<p class="source-code">    struct Sliding;</p>
			<p class="source-code">    impl RedHatBoyState&lt;Sliding&gt; {</p>
			<p class="source-code">        pub fn frame_name(&amp;self) -&gt; &amp;str {</p>
			<p class="source-code">            SLIDING_FRAME_NAME</p>
			<p class="source-code">        }</p>
			<p class="source-code">        pub fn update(&amp;mut self) {</p>
			<p class="source-code">            self.context = self.context.update(</p>
			<p class="source-code">             SLIDING_FRAMES);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you look through this code, you'll see it's very similar to our already existing running code. If you followed along, you'll see RHB start skidding across the floor until he goes past the right edge of the screen:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 4.6 – Safe&#13;&#10;" src="image/Figure_4.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Safe</p>
			<p>Stopping RHB from sliding is a little different than what we've done before. What we need to do is identify when the slide animation is complete, then transition right back into running without any user input. We'll start by checking whether the animation is done in the <strong class="source-inline">update</strong> method <a id="_idIndexMarker351"/>of the <strong class="source-inline">enum</strong>, which represents our <a id="_idIndexMarker352"/>machine, and then create a new transition from sliding back into running. We can do that by modifying the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">update</strong> method to check after updating in the sliding branch, as follows:</p>
			<p class="source-code">fn update(self) -&gt; Self {</p>
			<p class="source-code">    match self {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        RedHatBoyStateMachine::Sliding(mut state) =&gt; {</p>
			<p class="source-code">            state.update(SLIDING_FRAMES);</p>
			<p class="source-code">            if state.context().frame &gt;= SLIDING_FRAMES {</p>
			<p class="source-code">                RedHatBoyStateMachine::Running(</p>
			<p class="source-code">                 state.stand())</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                RedHatBoyStateMachine::Sliding(state)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This doesn't compile yet, because stand isn't defined yet and because <strong class="source-inline">SLIDING_FRAMES</strong> is in the <strong class="source-inline">red_hat_boy_states</strong> module. You might think that we can make <strong class="source-inline">SLIDING_FRAMES</strong> public and define a <strong class="source-inline">stand</strong> method, or we could move <strong class="source-inline">SLIDING_FRAMES</strong> into the <strong class="source-inline">game</strong> module. These will both work but I think it's time to look a little more holistically at our <strong class="source-inline">update</strong> method. </p>
			<p>Every arm of the <strong class="source-inline">match</strong> statement updates the current state and then returns a new state. In the case of <strong class="source-inline">Running</strong> and <strong class="source-inline">Idle</strong>, it was always the same state, but in the case of <strong class="source-inline">Sliding</strong>, sometimes it's the <strong class="source-inline">Running</strong> state. It turns out <strong class="source-inline">update</strong> is a<a id="_idIndexMarker353"/> transition, just one that sometimes transitions <a id="_idIndexMarker354"/>to the state it started from. In a state diagram, it looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 4.7 – Sliding to Running" src="image/Figure_4.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Sliding to Running</p>
			<p>If we wanted to be strict about it, we could say that <strong class="bold">Sliding</strong> transitions to an <strong class="source-inline">Updating</strong> state when it gets an <strong class="bold">Update</strong> event, then it can transition back to <strong class="bold">Sliding</strong> or <strong class="bold">Running</strong>. This is a case where the state exists, at least conceptually, but we don't actually have to create it in our code. </p>
			<p><strong class="source-inline">update</strong> on the <strong class="source-inline">Sliding</strong> state is really best modeled as a transition because it's a method that ultimately returns a state. Come to think of it, that's exactly what the other arms in the <strong class="source-inline">update</strong> method are too! Yes, they don't ever transition to another state, but each branch calls <strong class="source-inline">update</strong> and then returns a state. So, before we add <strong class="source-inline">Sliding</strong> to the <strong class="source-inline">update</strong> method, let's refactor to make <strong class="source-inline">update</strong> a transition for both of the other states. </p>
			<p>Since we're using Compiler-Driven Development, we'll change the <strong class="source-inline">update</strong> method to work as if <strong class="source-inline">update</strong> is already a transition:</p>
			<p class="source-code">pub enum Event {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">Update,</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            (RedHatBoyStateMachine::Idle(state), </p>
			<p class="source-code">             Event::Run) =&gt; state.run().into(),</p>
			<p class="source-code">            (RedHatBoyStateMachine::Running(state), </p>
			<p class="source-code">             Event::Slide) =&gt; state.slide().into(),</p>
			<p class="source-code">            <strong class="bold">(RedHatBoyStateMachine::Idle(state), </strong></p>
			<p class="source-code"><strong class="bold">             Event::Update) =&gt; state.update().into(),</strong></p>
			<p class="source-code"><strong class="bold">            (RedHatBoyStateMachine::Running(state), </strong></p>
			<p class="source-code"><strong class="bold">             Event::Update) =&gt; state.update().into(),</strong></p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(self) -&gt; Self {</p>
			<p class="source-code">        self.transition(Event::Update)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>With these changes, we've turned <strong class="source-inline">Update</strong> into <strong class="source-inline">Event</strong> and added two more arms to <strong class="source-inline">match</strong> in the <strong class="source-inline">transition</strong> method. Both of those arms work the same way as the other transitions: they call a method on the typestate and then convert the state into the <strong class="source-inline">RedHatBoyStateMachine enum</strong> with the <strong class="source-inline">From</strong> trait. The compiler error you get now might be a little strange; it looks like this:</p>
			<p class="source-code">error[E0277]: the trait bound 'RedHatBoyStateMachine: From&lt;()&gt;' is not satisfied</p>
			<p class="source-code">   --&gt; src/game.rs:155:83</p>
			<p class="source-code">    |</p>
			<p class="source-code">155 |             (RedHatBoyStateMachine::Idle(state), Event::Update) =&gt; state.update().into(),</p>
			<p class="source-code">    |                                                                                  ^^^^ the trait 'From&lt;()&gt;' is not implemented for 'RedHatBoyStateMachine'</p>
			<p>You may <a id="_idIndexMarker355"/>have <a id="_idIndexMarker356"/>expected that the error would say something about the <strong class="source-inline">update</strong> method not returning anything, but remember all Rust functions return something; they just return <strong class="source-inline">Unit</strong> when they don't return anything else. So, this error is telling you there's no way to convert from the <strong class="source-inline">()</strong>, or <strong class="source-inline">Unit</strong>, to a value of the <strong class="source-inline">RedHatBoyStateMachine </strong>type. That's not what we want to fix; we want to make both of the <strong class="source-inline">update</strong> calls on the states return new states. Those changes are next:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn update(<strong class="bold">mut self</strong>) -&gt; <strong class="bold">Self </strong>{</p>
			<p class="source-code">            self.context = self.context.update(</p>
			<p class="source-code">             IDLE_FRAMES);</p>
			<p class="source-code">            <strong class="bold">self</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn update(<strong class="bold">mut self</strong>) -&gt; <strong class="bold">Self</strong> {</p>
			<p class="source-code">        self.context = self.context.update(RUNNING_FRAMES);</p>
			<p class="source-code">        <strong class="bold">self</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p>The changes are small but important. The <strong class="source-inline">update</strong> method for <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> and <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> both return <strong class="source-inline">Self</strong> now, because even though the state doesn't change, these are still typestate methods that <a id="_idIndexMarker357"/>return a new state. They <a id="_idIndexMarker358"/>also take <strong class="source-inline">mut self</strong> now instead of <strong class="source-inline">&amp;mut self</strong>. You can't return <strong class="source-inline">self</strong> if you mutably borrow it, so this method stopped compiling. More importantly, this means these methods don't make unnecessary copies. They take ownership of <strong class="source-inline">self</strong> when called, and then return it. So, if you're worried about an optimization problem because of extra copies, you don't have to be.</p>
			<p>Now, we're down to one compiler error, which we've seen before:</p>
			<p class="source-code">the trait 'From&lt;red_hat_boy_states::RedHatBoyState&lt;red_hat_boy_states::Idle&gt;&gt;' is not implemented for 'RedHatBoyStateMachine'</p>
			<p>We didn't implement a conversion from the <strong class="source-inline">Idle</strong> state back to the <strong class="source-inline">RedHatBoyStateMachine enum</strong>. That's similar to the other ones we wrote, implementing <strong class="source-inline">From&lt;RedHatBoyState&lt;Idle&gt;&gt;</strong>, as shown here:</p>
			<p class="source-code">impl From&lt;RedHatBoyState&lt;Idle&gt;&gt; for RedHatBoyStateMachine {</p>
			<p class="source-code">    fn from(state: RedHatBoyState&lt;Idle&gt;) -&gt; Self {</p>
			<p class="source-code">        RedHatBoyStateMachine::Idle(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Remember that these implementations of the <strong class="source-inline">From</strong> trait are not in the <strong class="source-inline">red_hat_boy_states</strong> module. The <strong class="source-inline">red_hat_boy_states</strong> module knows about the individual states but does not know about <strong class="source-inline">RedHatBoyStateMachine</strong>. That's not its job.</p>
			<p>Now that we've<a id="_idIndexMarker359"/> refactored the code, our little RHB doesn't slide<a id="_idIndexMarker360"/> anymore. Instead, he kind of sits down because the <strong class="source-inline">Sliding</strong> state doesn't handle the <strong class="source-inline">Update</strong> event. Let's fix that now.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor108"/>Transitioning to sliding and back again</h2>
			<p>Part of the reason <a id="_idIndexMarker361"/>we used the typestate pattern for our individual states is so that we get compiler errors when we make a mistake. For instance, if we call <strong class="source-inline">run</strong> when we are in the <strong class="source-inline">Running</strong> state, it won't even compile because there is no such method. There is one place this doesn't hold, the <strong class="source-inline">transition</strong> method on the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong>. If you call <strong class="source-inline">transition</strong> with a <strong class="source-inline">RedHatBoyStateMachine</strong> variant and an <strong class="source-inline">Event</strong> variant pair that don't have a match, it returns <strong class="source-inline">Self</strong>.</p>
			<p>That's why our RHB is sitting down. He transitions to <strong class="source-inline">Sliding</strong> and then stops updating, staying in the same state forever. We'll fix that by adding the match for the <strong class="source-inline">Update</strong> event and then, you guessed it, follow the compiler to implement the sliding animation.</p>
			<p>This starts by adding the match to the transition method, as shown here:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            (RedHatBoyStateMachine::Sliding(state), </p>
			<p class="source-code">             Event::Update) =&gt; state.update().into(),</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>This match is just like the others; we match on <strong class="source-inline">Sliding</strong> and <strong class="source-inline">Update</strong> and call <strong class="source-inline">update</strong>. Just like before, we'll get an error:</p>
			<p class="source-code">the trait 'From&lt;()&gt;' is not implemented for 'RedHatBoyStateMachine'</p>
			<p>The <strong class="source-inline">Sliding</strong> state still has an update method that doesn't return a state. That's not going to work with our current setup, but it's not as simple as making the <strong class="source-inline">update</strong> method return <strong class="source-inline">Self</strong>, as on the other two states.</p>
			<p>Remember, there are two possible states that can come from the <strong class="source-inline">update</strong> method on <strong class="source-inline">Sliding</strong>: <strong class="source-inline">Sliding</strong> and <strong class="source-inline">Running</strong>. How is that going to work with our current setup? What we'll need to do is have <strong class="source-inline">update</strong> return an <strong class="source-inline">SlidingEndState</strong> <strong class="source-inline">enum</strong> that can be either <strong class="source-inline">Sliding</strong> or <strong class="source-inline">Running</strong>, and then <a id="_idIndexMarker362"/>we'll implement a <strong class="source-inline">From</strong> trait that will convert that into the appropriate variant of <strong class="source-inline">RedHatBoyStateMachine</strong>. That's odd to explain, so let's see it in action. We can modify the <strong class="source-inline">update</strong> method on <strong class="source-inline">RedHatBoyState&lt;Sliding&gt;</strong> to work like the one we proposed at the beginning of this section:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyState&lt;Sliding&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn update(mut self) -&gt; SlidingEndState {</p>
			<p class="source-code">            self.context = self.context.update(</p>
			<p class="source-code">             SLIDING_FRAMES);</p>
			<p class="source-code">            if self.context.frame &gt;= SLIDING_FRAMES {</p>
			<p class="source-code">                SlidingEndState::Complete(self.stand())</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                SlidingEndState::Sliding(self)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've taken the code that we originally considered putting in the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">update</strong> method and moved it into the <strong class="source-inline">update</strong> method of <strong class="source-inline">RedHatBoyState&lt;Sliding&gt;</strong>. This makes sense conceptually; the state should know how it behaves. On every update, we<a id="_idIndexMarker363"/> update <strong class="source-inline">context</strong>, and then check whether the animation is complete, with <strong class="source-inline">if self.context.frame &gt;= SLIDING_FRAMES</strong>. If the animation is complete, we return one variant of this new <strong class="source-inline">enum</strong> that doesn't exist yet: <strong class="source-inline">SlidingState</strong>. The <strong class="source-inline">SlidingState</strong> variant can either be <strong class="source-inline">Complete</strong> or <strong class="source-inline">Sliding</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It's definitely a little strange that the <strong class="source-inline">update</strong> method doesn't return another state here, and probably means we aren't using a <em class="italic">pure</em> typestate method. An alternative might have been to return the next <strong class="source-inline">Event</strong> from <strong class="source-inline">update</strong> and send that back into a call to the <strong class="source-inline">transition</strong> method on <strong class="source-inline">RedHatBoyStateMachine</strong>. That implementation ends up looking very strange because states are returning <strong class="source-inline">Events</strong> that are only used by <strong class="source-inline">RedHatBoyStateMachine</strong> and are otherwise unreferenced in the <strong class="source-inline">red_hat_boy_states</strong> module. Regardless of whether the strange return value of <strong class="source-inline">update</strong> makes you uncomfortable, I would encourage you to try other approaches. Maybe yours is better than mine!</p>
			<p>Following the compiler yet again, we have two obvious problems: there is no <strong class="source-inline">stand</strong> method and there is no <strong class="source-inline">SlidingEndState</strong> <strong class="source-inline">enum</strong>. We can handle both of these right here, next to the code we just wrote, as shown:</p>
			<p class="source-code">impl RedHatBoyState&lt;Sliding&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn stand(self) -&gt; RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            context: self.context.reset_frame(),</p>
			<p class="source-code">            _state: Running,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">pub enum SlidingEndState {</p>
			<p class="source-code">    Complete(RedHatBoyState&lt;Running&gt;),</p>
			<p class="source-code">    Sliding(RedHatBoyState&lt;Sliding&gt;),</p>
			<p class="source-code">}</p>
			<p>The only side effect of the transition to <strong class="source-inline">Running</strong> is that we call <strong class="source-inline">reset_frame</strong> again on <strong class="source-inline">context</strong>. Remember this has to be done on every transition, otherwise, the program can try to<a id="_idIndexMarker364"/> animate the new state with <strong class="source-inline">frame</strong>, which isn't valid and will crash. So, we'll reset the frame back to <strong class="source-inline">0</strong> on every transition.</p>
			<p>This leaves us with a compiler error to fix once again. This time, it's the following:</p>
			<p class="source-code">the trait 'From&lt;SlidingEndState&gt;' is not implemented for 'RedHatBoyStateMachine'</p>
			<p>Pay close attention to that source trait. It's not coming from one of the states but from the intermediate <strong class="source-inline">SlidingEndState</strong>. We'll solve it the same way as before, with a <strong class="source-inline">From</strong> trait, but we'll need to use a <strong class="source-inline">match</strong> statement to pull it out of the <strong class="source-inline">enum</strong>:</p>
			<p class="source-code">impl From&lt;SlidingEndState&gt; for RedHatBoyStateMachine {</p>
			<p class="source-code">    fn from(end_state: SlidingEndState) -&gt; Self {</p>
			<p class="source-code">        match end_state {</p>
			<p class="source-code">            SlidingEndState::Complete(running_state) =&gt; </p>
			<p class="source-code">             running_state.into(),</p>
			<p class="source-code">            SlidingEndState::Sliding(sliding_state) =&gt; </p>
			<p class="source-code">             sliding_state.into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we match on <strong class="source-inline">end_state</strong> to get the actual <strong class="source-inline">State</strong> out of <strong class="source-inline">enum</strong>, and then call <strong class="source-inline">into</strong> on that state again to get to <strong class="source-inline">RedHatBoyStateMachine</strong>. A little boilerplate, but it makes it easier to do the conversion. </p>
			<p>And now we have it! Run the game now and you'll see RHB take a short slide and pop back up again to the running state. Now that we've added three animations, it's time to deal with these ugly lines in the <strong class="source-inline">WalkTheDog</strong> implementation: <strong class="source-inline">self.rhb.as_mut().unwrap().slide()</strong>.</p>
			<p>We treat <strong class="source-inline">rhb</strong> as an <strong class="source-inline">Option</strong> type, not because it's ever really going to be <strong class="source-inline">None</strong>, but because we don't<a id="_idIndexMarker365"/> have it yet before the <strong class="source-inline">WalkTheDog</strong> <strong class="source-inline">struct</strong> is initialized. After <strong class="source-inline">WalkTheDog</strong> is initialized, <strong class="source-inline">rhb</strong> can never be <strong class="source-inline">None</strong> again because the state of<a id="_idTextAnchor109"/> the system has changed. Fortunately, we now have a tool for dealing with that, the good old state machine!</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor110"/>Every little thing I think I see</h2>
			<p><strong class="source-inline">WalkTheDog</strong> can<a id="_idIndexMarker366"/> be in two states, <strong class="source-inline">Loading</strong> or <strong class="source-inline">Loaded</strong>, after it's initialized. Fortunately, we accounted <a id="_idIndexMarker367"/>for this when we wrote our <strong class="source-inline">GameLoop</strong>. Remember that <strong class="source-inline">GameLoop</strong> returns <strong class="source-inline">Result&lt;Game&gt;</strong> from <strong class="source-inline">initialize</strong>; we're just currently always returning <strong class="source-inline">Ok(WalkTheDog)</strong>. What if we made <strong class="source-inline">WalkTheDog</strong> an <strong class="source-inline">enum</strong> and returned a different state of our game instead? That would mean <strong class="source-inline">WalkTheDog</strong> would be a state machine, with two states, and <strong class="source-inline">initialize</strong> would become the transition! That's exactly what we're going to do. Modify <strong class="source-inline">WalkTheDog</strong> so it is no longer a <strong class="source-inline">struct</strong> but an <strong class="source-inline">enum</strong>, as shown here:</p>
			<p class="source-code">pub enum WalkTheDog {</p>
			<p class="source-code">    Loading,</p>
			<p class="source-code">    Loaded(RedHatBoy),</p>
			<p class="source-code">}</p>
			<p>This is great; now everything is broken! Whoops! We'll need to adjust the <strong class="source-inline">WalkTheDog</strong> implementation to account for the two variants. First, we'll change the <strong class="source-inline">initialize</strong> function on <strong class="source-inline">WalkTheDog</strong>:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                let json = browser::fetch_json(</p>
			<p class="source-code">                 "rhb.json").await?;</p>
			<p class="source-code">                let rhb = RedHatBoy::new(</p>
			<p class="source-code">                    json.into_serde::&lt;Sheet&gt;()?,</p>
			<p class="source-code">                    engine::load_image("rhb.png").await?,</p>
			<p class="source-code">                );</p>
			<p class="source-code">                Ok(Box::new(WalkTheDog::Loaded(rhb)))</p>
			<p class="source-code">            }</p>
			<p class="source-code">            WalkTheDog::Loaded(_) =&gt; Err(anyhow!</p>
			<p class="source-code">                ("Error: Game is already initialized!")),</p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p>Remember in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, where we made this function return <strong class="source-inline">Game</strong>? This was why! In order to ensure <strong class="source-inline">initialize</strong> is only called once, <strong class="source-inline">initialize</strong> has to <a id="_idIndexMarker368"/>match <strong class="source-inline">self</strong> on its variants, and if we call <strong class="source-inline">initialize</strong> twice, we'll <a id="_idIndexMarker369"/>return an error via <strong class="source-inline">anyhow!</strong>. Otherwise, everything inside the <strong class="source-inline">Loading</strong> branch is the same as before, except we return <strong class="source-inline">WalkTheDog::Loaded</strong> instead of <strong class="source-inline">WalkTheDog</strong>. This does cause a compiler warning, which will become an error in future versions of Rust because <strong class="source-inline">RedHatBoy</strong> isn't public but is exposed in a public type. To get rid of that warning, you'll need to make <strong class="source-inline">RedHatBoy</strong> public, and that's fine; go ahead and do that. We also <a id="_idIndexMarker370"/>need to change the <strong class="source-inline">new</strong> constructor to reflect the <a id="_idIndexMarker371"/>new type, as shown here:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog::Loading</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">WalkTheDog</strong> <strong class="source-inline">enum</strong> starts in <strong class="source-inline">Loading</strong>, nothing fancy there. The <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong> functions now both need to reflect the changing states; you can see those changes here:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(rhb) = self {</p>
			<p class="source-code">            if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">                rhb.run_right();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            if keystate.is_pressed("ArrowDown") {</p>
			<p class="source-code">                rhb.slide();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            rhb.update();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        if let WalkTheDog::Loaded(rhb) = self {</p>
			<p class="source-code">            rhb.draw(renderer);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>You could argue this isn't really a change on the <strong class="source-inline">Option</strong> type, as we still need to check the state of <strong class="source-inline">Game</strong> each time we operate on <strong class="source-inline">rhb</strong>, and that's true, but I think this more clearly reveals the intent <a id="_idIndexMarker372"/>of the system. It also has the benefit of getting rid of<a id="_idIndexMarker373"/> the <strong class="source-inline">as_ref</strong>, <strong class="source-inline">as_mut</strong> code, which is often confusing. Now that we've cleaned up that code, let's add one more animation to RHB. Let's see this boy jump!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor111"/>Transitioning to jumping</h2>
			<p>Going through<a id="_idIndexMarker374"/> each and every change yet again for the jump is redundant. Instead, I can recommend you make the following change:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(rhb) = self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            if keystate.is_pressed("Space") {</p>
			<p class="source-code">                rhb.jump();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn jump(&amp;mut self) {</p>
			<p class="source-code">        self.state_machine = self.state_machine.transition(</p>
			<p class="source-code">         Event::Jump);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>You should be able to follow the compiler errors all the way through, creating a transition from <strong class="source-inline">Running</strong> to <strong class="source-inline">Jumping</strong>. You can also look up the constant values you need directly out of <strong class="source-inline">rhb.json</strong>. The number of frames is the number of images in <strong class="source-inline">Jump</strong> in the <a id="_idIndexMarker375"/>animation multiplied by <strong class="source-inline">3</strong>, and subtracting <strong class="source-inline">1</strong>, and the name of the animation is <strong class="source-inline">Jump</strong>. Make sure you handle the <strong class="source-inline">update</strong> event in the transition method for <strong class="source-inline">Jumping</strong>.</p>
			<p>Do all that and you see RHB skidding across the ground, doing a kind of dance:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 4.8 – That's...not jumping" src="image/Figure_4.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – That's...not jumping</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you get stuck, the answers to this are available at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/</a>. However, I strongly recommend trying to do this without checking first. Look at what we did for the first three transitions and try to understand what we did. Even if you get stuck, the time spent practicing is valuable here.</p>
			<p>If you've correctly implemented the code for transitioning to the jumping state, our RHB will play his jumping animation, forever, while skidding across the ground. We've seen this before with the slide state, so it's time to figure out what's different about jumping. Of course, we know exactly what's different about jumping – you go up! Well, at least a little.</p>
			<p>There are three things we need to do. First, we give RHB vertical velocity when he jumps; second, we need to add gravity so that RHB will actually come down <a id="_idIndexMarker376"/>when he jumps. And finally, we need to transition running when we land, using our ever-durable state machine:</p>
			<ol>
				<li value="1">Going up on <strong class="source-inline">Jump</strong>.</li>
			</ol>
			<p>Take a moment and think, where does this belong? Should it go in the <strong class="source-inline">update</strong> function, the <strong class="source-inline">jump</strong> event, or maybe in the <strong class="source-inline">enum</strong> implementation? No, this is a transition change because it happens on <strong class="source-inline">jump</strong>, and it belongs in the <strong class="source-inline">jump</strong> method on the <strong class="source-inline">Running</strong> type class. You should already have a transition from running to jumping, so let's update that function to add vertical velocity:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    const JUMP_SPEED: i16 = -25;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn jump(self) -&gt; RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context.set_vertical_</p>
			<p class="source-code">                 velocity(JUMP_SPEED).reset_frame(),</p>
			<p class="source-code">                _state: Jumping {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        fn set_vertical_velocity(mut self, y: i16) -&gt; </p>
			<p class="source-code">         Self {</p>
			<p class="source-code">            self.velocity.y = y;</p>
			<p class="source-code">            self</p>
			<p class="source-code">        }</p>
			<p>Remember in our 2D coordinate system, <strong class="source-inline">y</strong> is <strong class="source-inline">0</strong> at the top, so we need a negative velocity to go up. It also resets the frame so that the jump <a id="_idIndexMarker377"/>animation starts at frame <strong class="source-inline">0</strong>. The implementation in <strong class="source-inline">RedHatBoyContext</strong> is using the same pattern of accepting <strong class="source-inline">mut self</strong> and returning a new <strong class="source-inline">RedHatBoyContext</strong>. Now, if you let the app refresh, RHB will take off like Superman!</p>
			<ol>
				<li value="2">Adding gravity.</li>
			</ol>
			<p>In order to have a natural jump, we'll apply gravity on every update. We'll do this <em class="italic">regardless of state</em> because later, we'll need to have RHB fall off of platforms and cliffs, and we don't want to have to constantly pick and choose when we're applying gravity. This will go in the <strong class="source-inline">update</strong> function of <strong class="source-inline">RedHatBoyContext</strong>, right at the top:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">...</p>
			<p class="source-code">const GRAVITY: i16 = 1;</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        fn update(mut self, frame_count: u8) -&gt; Self {</p>
			<p class="source-code">             <strong class="bold">self.velocity.y += GRAVITY;</strong></p>
			<p>If you refresh the page right now, you'll get a blink-and-you'll-miss-it problem, and you'll probably be greeted with a blank screen. The<a id="_idIndexMarker378"/> screen isn't really blank; RHB just fell right through the ground!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 4.9 – Tell my family I love them" src="image/Figure_4.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Tell my family I love them</p>
			<p>We'll need to address<a id="_idIndexMarker379"/> this with our first case of <strong class="bold">collision resolution</strong>.</p>
			<ol>
				<li value="3">Landing on the ground.</li>
			</ol>
			<p>This is a bit of a spoiler for the next chapter, but collision detection happens in two steps. The first is detection, finding places where things collide, and the second is resolution, where you do something about the collision. Since there isn't anything to collide with in RHB's empty void, we can just do a simple check in the same <strong class="source-inline">update</strong> function to see whether his new position is past the floor and update the position back to the floor. Keep in mind, you do this <em class="italic">after</em> you update to a new position:</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        pub fn update(mut self, frame_count: u8) -&gt; </p>
			<p class="source-code">        Self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            self.position.x += self.velocity.x;</p>
			<p class="source-code">            self.position.y += self.velocity.y;</p>
			<p class="source-code">            <strong class="bold">if self.position.y &gt; FLOOR {</strong></p>
			<p class="source-code">                <strong class="bold">self.position.y = FLOOR;</strong></p>
			<p class="source-code">            <strong class="bold">}</strong></p>
			<p>This may feel redundant, but we can't know gravity pulled RHB past the ground without actually calculating where he ends up, and we don't draw the in-between state, so the performance cost is minimal. This change prevents RHB from falling through the ground and causes a nice jumping <a id="_idIndexMarker380"/>arc, but he keeps performing the jumping animation for eternity. We need to change the state from <strong class="source-inline">Jumping</strong> back to <strong class="source-inline">Running</strong>, and we need to make that decision in <strong class="source-inline">RedHatBoyStateMachine</strong> because it's a conditional state change based on a condition just like the one that transitioned from <strong class="source-inline">Sliding</strong> to <strong class="source-inline">Running</strong>.</p>
			<p>That's a change to the state machine, much like the one we did for <strong class="source-inline">Sliding</strong>, as seen here:</p>
			<p class="source-code">impl RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn update(mut self) -&gt; JumpingEndState {</p>
			<p class="source-code">        self.context = self.context.update(</p>
			<p class="source-code">         JUMPING_FRAMES);</p>
			<p class="source-code">        if self.context.position.y &gt;= FLOOR {</p>
			<p class="source-code">            JumpingEndState::Complete(self.land())</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            JumpingEndState::Jumping(self)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>So, if the position is on the floor, we need to transition to <strong class="source-inline">Running</strong> via the <strong class="source-inline">stand</strong> method, only we can't! We never wrote a transition from <strong class="source-inline">Sliding</strong> to <strong class="source-inline">Running</strong>, just the other way around. We also never wrote a <strong class="source-inline">JumpingEndState</strong> enum, or a way to convert out of it via <strong class="source-inline">From</strong>. So, right now, you should see several compiler errors about all of that, the first being the following:</p>
			<p class="source-code"><strong class="bold">error[E0599]: no method named 'land' found for struct 'red_hat_boy_states::RedHatBoyState' in the current scope</strong></p>
			<p class="source-code"><strong class="bold">   --&gt; src/game.rs:413:48</strong></p>
			<p class="source-code"><strong class="bold">    |</strong></p>
			<p class="source-code"><strong class="bold">258 |     pub struct RedHatBoyState&lt;S&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    |     ---------------------------- method 'land' not found for this</strong></p>
			<p>There's the compiler error, but there's no <strong class="source-inline">land</strong> method. So, go write it. <em class="italic">I'm serious: go write it yourself. I'm not going to reproduce it here</em>. You can go ahead and <a id="_idIndexMarker381"/>follow along with the previous methods we wrote and implement them. You can do it; I believe in you. When you do, you'll have a clean animation from <strong class="source-inline">Idle</strong> to <strong class="source-inline">Running</strong>, then <strong class="source-inline">Jumping</strong>, and back to <strong class="source-inline">Running</strong> again. Then, you'll wander off the screen because we don't have a full scene yet, but we're getting there!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you get stumped, you can always check the source code for thi<a id="_idTextAnchor112"/>s chapter in the repository at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/</a>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor113"/>Summary</h1>
			<p>This chapter covered one topic, but one of the most important topics in game development. State machines are everywhere in games, which we saw when we implemented a small one to manage the <strong class="source-inline">Loaded</strong> and <strong class="source-inline">Loading</strong> states of the <strong class="source-inline">WalkTheDog</strong> <strong class="source-inline">enum</strong> itself. They are a particularly nice way to implement animation states that must correspond with what the player is doing, and Rust has great ways to implement this pattern. We used two: the simple one for <strong class="source-inline">WalkTheDog</strong>, and the much more complex <strong class="source-inline">RedHatBoyStateMachine</strong> that uses the typestate pattern. The typestate pattern is a commonly used pattern in Rust, both inside and outside of game development, so you can expect to see it in many Rust projects.</p>
			<p>We also used the compiler to drive development, over and over again. It's an incredibly useful technique, where you can start with what you want the code to look like and use the compiler's error messages to help you fill in the rest of the implementation. The code becomes like a paint by numbers picture, where you use higher-level code to draw the lines and the compiler error messages tell you how to fill them in. Rust has very good compiler error messages, getting better with every release, and it will pay huge dividends for you to pay close attention to them.</p>
			<p>Now that our RHB can run and jump, how about he runs and jumps on something? We'll put him in a scene and have him jump on it in the next chapter.</p>
		</div>
		<div>
			<div id="_idContainer042">
			</div>
		</div>
	</body></html>