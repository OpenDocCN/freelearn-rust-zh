<html><head></head><body>
		<div><h1 id="_idParaDest-58"><em class="italic"><a id="_idTextAnchor093"/>Chapter 4</em>: Managing Animations with State Machines</h1>
			<p>In the last chapter, we created a minimal game <em class="italic">engine</em>, allowing for moving our main character around and playing a simple animation, but it's far from full-featured. There's no world to navigate, the only animation that plays is running, and <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) doesn't respond to any physics. At this point, if we wanted to retitle our game, it would be called <em class="italic">Red Hat Boy and the Empty Void</em>.</p>
			<p>While that might be a fun title, it wouldn't make for a fun game. Ultimately, we'll want RHB to chase his dog through a forest with platforms to jump on and slide under, and to do that we'll need to make sure he slides, jumps, and runs. We'll also need to make sure that he looks, acts, and behaves differently when he does those things. </p>
			<p>In this chapter, we're going to introduce a common game development pattern to manage all that, the state machine, implemented in <code>if</code> statements.</p>
			<p>We're going to cover the following topics:</p>
			<ul>
				<li>Introducing state machines</li>
				<li>Managing animation</li>
				<li>Adding states to walk the dog</li>
				<li><code>Idle</code>, <code>Running</code>, <code>Sliding</code>, and <code>Jumping</code> animations</li>
			</ul>
			<p>By the end of the chapter, you will be able to use state machines to cleanly transition between animations while always playing the correct one.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>There are no new crates or other technical requirements in this chapter. The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_4</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/35sk3TC">https://bit.ly/35sk3TC</a></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor095"/>Introducing state machines</h1>
			<p>Games, web applications, heck, even cryptocurrency miners, have to manage the <em class="italic">state</em> of the system. After all, if the system isn't doing something right now, if it doesn't have a current state, then it's not <a id="_idIndexMarker245"/>running, is it? The state is also fractal. In our game, we have a state of <code>playing</code>, and another one of <code>game over</code>. Once we add menu items, we'll have even more states. Meanwhile, our RHB also has states: he's running, sliding, jumping, dying, and dead. Let's say unconscious, that's less dark.</p>
			<p>The point is our game is doing a lot of things and is maintaining a large game state with a lot of mini-states inside it. As the application moves from one state to another, the rules of the system change. For example, when RHB is running, the <em class="italic">spacebar</em> might make him jump, but when he's jumping, hitting the <em class="italic">spacebar</em> doesn't do anything. The rule is you can't jump when you're already jumping. One way you can maintain that state is through a large structure with a bunch of values or Booleans, such as <code>jumping = true</code>, and in a Rust program, you might store that in an enumerated type like this:</p>
			<pre>enum RedHatBoyState {
    Jumping,
    Running,
    Sliding,
}</pre>
			<p>This works reasonably well in small programs but for larger programs, there are two things that you'll want to manage. The first, which I've already hinted at, is that there may be rules about going between states. Maybe you can't go right from <code>Jumping</code> to <code>Sliding</code>, but an <code>enum</code> doesn't prevent that. The second is that, in addition to the rules being different for each state, frequently things happen on the <em class="italic">transitions</em> between states, things such as <a id="_idIndexMarker246"/>playing a sound effect or updating a score; for that, you need a state machine.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor096"/>Defining a state machine</h2>
			<p>Perhaps the most confusing thing <a id="_idIndexMarker247"/>about state machines is the naming, as there are state machines, finite state machines, the state pattern, and more, all of which frequently get used interchangeably by programmers. So, for the sake of clarity, let's define them this way:</p>
			<ul>
				<li><strong class="bold">State machines</strong>: A model of the state <a id="_idIndexMarker248"/>of a system, represented by a list of states and the transitions between them</li>
				<li><code>trait</code> object, which you can find here: <a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html">https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html</a>. It's quite good but is not idiomatic Rust, and we won't be using it.</p></li>
			</ul>
			<p>The state machine both helps us keep a mental model of the system in our heads and prevents us from making foolish mistakes in code, such as playing the running animation while RHB is jumping. The drawback, of course, is that you need to understand state machines, so let's get that covered. We'll use RHB as our example. RHB can be <strong class="bold">Running</strong>, <strong class="bold">Idle</strong>, <strong class="bold">Jumping</strong>, <strong class="bold">Sliding</strong>, <strong class="bold">Falling</strong>, or <strong class="bold">KnockedOut</strong>. We can use a state <strong class="bold">transition table</strong> to list those:</p>
			<div><div><img alt="" src="img/Table_4.1.jpg"/>
				</div>
			</div>
			<p>The transition table only has three columns for now, which are a start state, the event that causes a transition, and the state it transitions to. Events differ from transitions in that events are what happens to the system to <em class="italic">cause</em> a transition, but transitions are what happens <em class="italic">during</em> the state change.</p>
			<p>It's a subtle difference, and sometimes it gets used interchangeably because the names will frequently be the same. Let's work <a id="_idIndexMarker250"/>through a state transition to clarify this. RHB starts in the <code>Idle</code> state, where he stands in place with an <code>run</code>:</p>
			<div><div><img alt="" src="img/Table_4.2.jpg"/>
				</div>
			</div>
			<p>When moving to <code>Running</code>, we actually do something on the transition. Specifically, we start moving to the right; we increase the velocity in <code>x</code>. You can name this transition in the table:</p>
			<div><div><img alt="" src="img/Table_4.3.jpg"/>
				</div>
			</div>
			<p>While this is correct, often we don't bother naming the transitions and the events because they become redundant. While we could continue adding to this table, we can also model a state machine <a id="_idIndexMarker251"/>with several types of diagrams. I'm partial to simple circles and lines, where the circles are the states and the lines are the transitions.</p>
			<div><div><img alt="Figure 4.1 – A state machine diagram&#13;&#10;" src="img/Figure_4.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – A state machine diagram</p>
			<p>This diagram is a fleshed-out version of the previous table, with all of the entries completed. It starts at the <strong class="bold">Idle</strong> state and transitions to the <strong class="bold">Running</strong> state via the <strong class="bold">Run</strong> event. From there, it can go in several directions. If the player <em class="italic">slides</em>, it can go into the <strong class="bold">Sliding</strong> state; if the player <em class="italic">jumps</em>, it can go into the <strong class="bold">Jumping</strong> state. Both of those eventually return to the <strong class="bold">Running</strong> state when sliding or jumping is over. <strong class="bold">Running</strong>, <strong class="bold">Sliding</strong>, and <strong class="bold">Jumping</strong> can all transition into the <strong class="bold">Falling</strong> state when they crash into something.</p>
			<p>This does result in a lot of transitions across the middle of the diagram. Finally, the <strong class="bold">Falling</strong> state transitions into the <strong class="bold">KnockedOut</strong> state when <strong class="bold">Falling</strong> is over, via the <strong class="bold">End</strong> event. If you're familiar with this type of diagram, you might point out that I could have used a <em class="italic">superstate</em> to contain <strong class="bold">Running</strong>, <strong class="bold">Jumping</strong>, and <strong class="bold">Sliding</strong> and used one event to transition all of those to <strong class="bold">Falling</strong>. You'd be right, but we won't need to concern ourselves with that for our implementation.</p>
			<p>You might be asking, what's the benefit of all this? Does this really fit the <em class="italic">minimal architecture</em> that we covered in the last chapter? Answering the second question first, the answer is, uh…maybe? I find that state machines help me keep code together that belongs together, rather than sprinkling <code>match</code> statements throughout my code base as I might have to when using a simple <code>enum</code>. That doesn't mean we won't have those <code>match</code> statements; they'll just be in one place.</p>
			<p>I also find it fits my mental model of how code works well, and it helps prevent errors because you simply <em class="italic">can't</em> perform an <a id="_idIndexMarker252"/>action that's invalid because it's not available for that given state. Frankly, the state machine exists whether or not we model it, and it's cleaner if we can also model it in code rather than having it emerge accidentally. So, those are the benefits, and that's why I think it fits in our minimal architecture. Now it's time to implement it.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor097"/>Implementing with types</h2>
			<p>The <strong class="bold">Object-Oriented</strong> (<strong class="bold">OO</strong>) state<a id="_idIndexMarker253"/> pattern is typically implemented as a variation on the strategy pattern, where you swap <a id="_idIndexMarker254"/>out different objects that all implement the same state interface at runtime based on the various transitions. The diagram looks something like this:</p>
			<div><div><img alt="Figure 4.2 – State pattern" src="img/Figure_4.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – State pattern</p>
			<p>In the OO version of the pattern, <code>enum</code>, which we can use to enumerate the states in a clearer fashion than traditional objects. The<a id="_idIndexMarker256"/> second is <strong class="bold">generic types</strong>, which we'll use to model each state as a <strong class="bold">typestate</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The original state machine implementation I wrote was largely based on this excellent article by Ana Hobden, a.k.a. Hoverbear, at <a href="https://hoverbear.org/blog/rust-state-machine-pattern/">https://hoverbear.org/blog/rust-state-machine-pattern/</a>. While this book no longer uses that pattern, I encourage you to read it for an alternative approach.</p>
			<h3>The typestate pattern</h3>
			<p><strong class="bold">Typestate</strong> is a fancy name for embedding the state of an object in its type. The way it works is that you have <a id="_idIndexMarker257"/>a generic structure with one generic parameter representing the state. Then, each state will have methods that can return new states. So, instead of each state having common methods, as they do, as shown in <em class="italic">Figure 4.2</em>, each state has its own methods that return the new state. The states in <em class="italic">Figure 4.2</em> might look something like this:</p>
			<div><div><img alt="Figure 4.3 – Typestate pattern" src="img/Figure_4.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Typestate pattern</p>
			<p>In this diagram, <code>State&lt;GenericStateOne&gt;</code> has a <code>next</code> method, which consumes <code>self</code> and returns <code>State&lt;GenericStateTwo&gt;</code>. Meanwhile, <code>State&lt;GenericStateTwo&gt;</code> only has an <code>update</code> method, which takes a mutably borrowed <code>self</code>. The implications of this are that the compiler will catch you if you try to call <code>next</code> on <code>State&lt;GenericStateTwo&gt;</code>. In the traditional OO pattern, all states must handle all the same methods because they share an interface, so this kind of defense isn't possible. Often, this means implementing methods you don't actually care about, and either returning an error state or <code>Self</code>, and then debugging at runtime. </p>
			<p>In addition, we can use the <code>mod</code> keyword and Rust's rules about privacy to make it impossible to create any state in an <a id="_idIndexMarker258"/>invalid state. We can make it impossible to move from <code>GenericStateOne</code> to <code>GenericStateTwo</code> without calling <code>next</code> by keeping the internals of <code>State</code> private so you can't just construct it. This is <a id="_idIndexMarker259"/>called <strong class="bold">making illegal states unrepresentable</strong>, and it's a great way to make sure you don't make mistakes in your programs.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">I tracked down the <em class="italic">making illegal states unrepresentable</em> phrasing to Yaron Minsky (<a href="https://blog.janestreet.com/effective-ml-revisited/">https://blog.janestreet.com/effective-ml-revisited/</a>); however, it's quite likely the practice and phrasing are older than that.</p>
			<p>Typestates are intimidating because they are both a new concept and new jargon, so don't worry if you feel a little confused.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There's a lot of great information on typestates in Rust. There's an excellent talk by Will Crichton from Strange Loop (https://youtu.be/bnnacleqg6k?t=2015), as well as blogs at <a href="https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm">https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.htm</a> and <a href="http://cliffle.com/blog/rust-typestate/">http://cliffle.com/blog/rust-typestate/</a>.</p>
			<p>If you want to forget all about generics and type theory for a minute, they can be summarized as follows:</p>
			<ul>
				<li>Each state of the object is represented by a separate struct.</li>
				<li>You can only advance from one state to another by methods on that struct.</li>
				<li>You can guarantee you can only create valid states using privacy rules.</li>
			</ul>
			<p>The rest are just details.</p>
			<p>Finally, we're going to need an <code>enum</code> to <em class="italic">hold</em> our typestate. Each state is generic, so to continue in our preceding example, any struct that will interact with our state machine will need to hold <em class="italic">either</em> <code>State&lt;GenericStateOne&gt;</code> or <code>State&lt;GenericStateTwo&gt;</code>. In order to do that, we would either need to make the containing <code>struct</code> generic as well, and then create new versions of the containing <code>struct</code> every time the state changes, or wrap the generic object in an <code>enum</code>. </p>
			<p>We'll use an <code>enum</code> because it <a id="_idIndexMarker260"/>prevents the generic nature of the typestate from propagating throughout the program, allowing the typestate to be an implementation detail. We're going to write the kind of state machine that Rust is very good at. Let's get to it.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor098"/>Managing animation</h1>
			<p>We'll create our state machine to manage the different animations. Specifically, when RHB isn't moving, he's <code>Idle</code>, but <a id="_idIndexMarker261"/>when he's moving, he's <code>Running</code>. When he jumps, he's <code>Jumping</code>. You get the idea.</p>
			<p>Those different RHB states correspond to the different animations managed using a state machine. We'll first create the RHB with a state machine and then integrate it into our current application. We'll implement this <em class="italic">top-down</em>, starting with a struct that represents RHB <a id="_idIndexMarker262"/>and letting the compiler errors drive further development. This is sometimes called <strong class="bold">Compiler-Driven Development</strong> although it's <a id="_idIndexMarker263"/>not a formalized approach such as <strong class="bold">Test-Driven Development</strong>. It can work extremely well in a language with a robust type system and great compiler errors, such as Rust. Let's start with how we'll represent RHB.</p>
			<p>The <code>RedHatBoy</code> struct will contain the state machine, the sprite sheet, and the image because eventually, it will draw itself:</p>
			<pre>struct RedHatBoy {
    state_machine: RedHatBoyStateMachine,
    sprite_sheet: Sheet,
    image: HtmlImageElement,
}</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">All of this code belongs in the <code>game</code> module. That means you can put it in the <code>game.rs</code> file or if you so choose, put it in a separate file and bring it into the <code>game</code> module with the <code>mod</code> keyword. I'll leave that up to you.</p>
			<p>Of course, this won't work because you haven't created the state machine yet. You do have the <code>Sheet</code> structure from <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>. Let's create <code>RedHatBoyStateMachine</code>:</p>
			<pre>#[derive(Copy, Clone)]
enum RedHatBoyStateMachine {
    Idle(RedHatBoyState&lt;Idle&gt;),
    Running(RedHatBoyState&lt;Running&gt;),
}</pre>
			<p>Seeing the <code>enum</code> we discussed earlier, it might still be unclear why we're using it when we'll be creating all of these typestate structures. <code>RedHatBoyState</code>, which doesn't exist yet, is a generic type that <a id="_idIndexMarker264"/>contains another type, where those types represent the various states. So, why the redundant <code>enum</code>? Because we want to be able to switch easily between the states without using the heap or dynamic dispatch. Let's imagine we defined the <code>RedHatBoy</code> struct in the following way:</p>
			<pre>struct RedHatBoy {
    state: RedHatBoyState&lt;Idle&gt;,
    sprite_sheet: Sheet,
}</pre>
			<p>Now the state is fixed to a state. We could, of course, define things in the following way:</p>
			<pre>struct RedHatBoy&lt;T&gt; {
    state: RedHatBoyState&lt;T&gt;,
    sprite_sheet: Sheet,
}</pre>
			<p>But of course, now <code>RedHatBoy</code> has to also be a generic type. You can make this work without the <code>enum</code> using <code>Box&lt;dyn State&gt;</code>, but that's not very ergonomic and it would require implementing the same methods on every state, so we'll stick with the <code>enum</code>. I have to acknowledge that I don't like the stutter in the types such as <code>*Idle*(RedHatBoyState&lt;*Idle*&gt;)</code>, but we'll see that the <code>enum</code> wrapper becomes extremely useful as we implement the state machine. Make sure that the <code>enum</code> is <code>Copy,Clone</code> as well, for reasons you'll see shortly.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you're interested, <em class="italic">The Rust Programming Language</em> has a chapter that describes how to implement a state pattern in a traditional OO way. Interestingly, they eventually abandon it in favor of using an <code>enum</code>. You can find that here: <a href="https://bit.ly/3hBsVd4">https://bit.ly/3hBsVd4</a>.</p>
			<p>Of course, this code still doesn't <a id="_idIndexMarker265"/>compile, because we haven't created either of those states or the <code>RedHatBoyState</code> <code>x</code>. This is what I meant by Compiler-Driven Development. We can start by creating <code>RedHatBoyState</code>:</p>
			<pre>mod red_hat_boy_states {
    use crate::engine::Point;
    #[derive(Copy, Clone)]
    pub struct RedHatBoyState&lt;S&gt; {
        context: RedHatBoyContext,
        _state: S,
    }
    #[derive(Copy, Clone)]
    pub struct RedHatBoyContext {
        frame: u8,
        position: Point,
        velocity: Point,
    }
}</pre>
			<p>All the code relating to the individual states will go in its own module, <code>red_hat_boy_states</code>, so that we can only make public the methods required by the rest of the <code>game</code> module. This will make it impossible to accidentally create a state without using the methods provided, and therefore, impossible to accidentally make an invalid transition. The only way to transition from <code>RedHatBoyState&lt;Idle&gt;</code> to <code>RedHatBoyState&lt;Running&gt;</code> is going to be through the methods on <code>RedHatBoyState&lt;Idle&gt;</code>. It's important that both <code>RedHatBoyState</code> and <code>RedHatBoyContext</code> are public but their members are private, so we can use them as intended.</p>
			<p>Inside the new module, <code>RedHatBoyState</code> is a simple generic type that contains <code>_state</code>, which is never read, hence the underscore, and <code>RedHatBoyContext</code>. Now, <code>RedHatBoyContext</code> is a structure with data that's common to all the states. In this case, that's the frame being <a id="_idIndexMarker266"/>rendered, the position, and the velocity. We'll need it so that the state transitions can modify the state of RHB. Putting all of this in the <code>red_hat_boy_states</code> module means that we haven't changed the compiler error message. We need to import that module into the <code>game</code> module with <code>use self::red_hat_boy_states::*;</code>, which you can add anywhere in the <code>game</code> module. This gets us partway there, but if we look at the following compiler output, we're still not finished:</p>
			<pre>error[E0412]: cannot find type 'Idle' in this scope
  --&gt; src/game.rs:19:25
   |
19 |     Idle(RedHatBoyState&lt;Idle&gt;),
   |                                    ^^^^ not found in 
   this scope</pre>
			<p>There's also a corresponding <code>enum</code> variant for <code>Running(RedHatBoyState&lt;Running&gt;)</code>. Both <code>Idle</code> and <code>Running</code> don't exist. We can create both of <a id="_idIndexMarker267"/>these easily, with empty structures inside the <code>red_hat_boy_states</code> module. Note that both of these must also be <code>Clone</code>:</p>
			<pre>#[derive(Copy, Clone)]
struct Idle;
#[derive(Copy, Clone)]
struct Running;</pre>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor099"/>Transitioning between states</h2>
			<p>Congratulations! You've created two states for RHB. This achieves…nothing. There's a bit missing. For <a id="_idIndexMarker268"/>starters, we can't <a id="_idIndexMarker269"/>transition from <code>Idle</code> to <code>Running</code>, and those states don't actually do anything when they aren't transitioning. Let's take care of a transition right now. We'll add a method on <code>RedHatBoyState&lt;Idle&gt;</code> to go from <code>Idle</code> to <code>Running</code>:</p>
			<pre>mod red_hat_boy_states {
    ....
    impl RedHatBoyState&lt;Idle&gt; {
        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {
            RedHatBoyState {
                context: self.context,
                _state: Running {},
            }
        }
    }</pre>
			<p>This is the transition from <code>Idle</code> to <code>Running</code>, and the <code>run</code> method is where the magic happens. This is just a function that takes a <code>RedHatBoy&lt;Idle&gt;</code> state and converts it to a <code>RedHatBoy&lt;Running&gt;</code> state, and for now, doesn't change any <code>RedHatBoyContext</code> data. You might wonder then, what magic?</p>
			<p>This means that to transition from <code>Idle</code> to <code>Running</code>, you can use <code>run</code>, but it also means you can't transition from <code>Running</code> back into <code>Idle</code>, and that makes sense because the game doesn't allow that behavior. The function also takes <code>mut self</code>, so that when it's called, it consumes the current state. This means that if you want to somehow keep <code>Idle</code> around after transitioning to <code>Running</code>, you have to clone it, and if you do that, you probably really meant to do it. </p>
			<p>You also can't create the <code>Running</code> state directly, because its data members are private, which means you can't just create that state by mistake. You can't create the <code>Idle</code> state either, and that's a <a id="_idIndexMarker270"/>problem because it's the start state. We'll address that<a id="_idIndexMarker271"/> in a moment, but first, let's dive into how we'll interact with the states through our state machine.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor100"/>Managing the state machine</h2>
			<p>Initially, we <a id="_idIndexMarker272"/>might be <a id="_idIndexMarker273"/>tempted to implement our state machine by adding methods on the <code>RedHatBoyStateMachine</code> <code>enum</code>, as follows:</p>
			<pre>#[derive(Copy, Clone)]
enum RedHatBoyStateMachine {
    Idle(RedHatBoyState&lt;Idle&gt;),
    Running(RedHatBoyState&lt;Running&gt;),
}
impl RedHatBoyStateMachine {
    fn run(self) -&gt; Self {
        match self {
            RedHatBoyStateMachine::Idle(state) =&gt; 
             RedHatBoyStateMachine::Running(state.run()),
            _ =&gt; self,
        }
    }
}</pre>
			<p>This isn't terrible, but it means that every method on our state machine will likely need to match the current variant of the <code>RedHatBoyStateMachine</code> <code>enum</code>. Then, it would return the new variant based on either the transition or <code>self</code> when the transition isn't currently valid. In other words, while the compiler will error if we call <code>run</code> on the <code>Running</code> state, it won't error if we call <code>run</code> on <code>RedHatBoyStateMachine</code> when the current variant is <code>Running</code>. This kind of error, where we call <code>run</code> by mistake on the wrong state, is exactly what we're trying to get away from with our typestates. We'd go to all the trouble of writing these typestates only to immediately throw away one of the benefits in every method on the <code>RedHatBoyStateMachine</code> <code>enum</code>.</p>
			<p>Unfortunately, we can't completely get away from that problem, because we are using an <code>enum</code> to contain our states. There's no way to implement methods on variants of an <code>enum</code> as we can with generic structures, and if we're going to wrap the state in an <code>enum</code>, we'll have <a id="_idIndexMarker274"/>to match on the variant. What we can do is <em class="italic">reduce</em> the <a id="_idIndexMarker275"/>surface area of that kind of error by reducing the number of methods that operate in the states. Specifically, instead of calling <code>run</code> on the <code>enum</code>, we'll create a <code>transition</code> function that takes <code>Event</code>. That is going to look like the following code:</p>
			<pre>#[derive(Copy, Clone)]
enum RedHatBoyStateMachine {
    Idle(RedHatBoyState&lt;Idle&gt;),
    Running(RedHatBoyState&lt;Running&gt;),
}
pub enum Event {
    Run,
}
impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            (RedHatBoyStateMachine::Idle(state), 
             Event::Run) =&gt; {
                RedHatBoyStateMachine::Running(state.run())
            }
            _ =&gt; self,
        }
    }
}</pre>
			<p>We've solved the problem caused by the <code>enum</code> with another <code>enum</code>! This is very <em class="italic">Rusty</em> of us. In this case, we've created an <code>enum</code> named <code>Event</code> to represent every event that could happen to our machine and replaced the method named <code>run</code> with a method named <code>transition</code>.</p>
			<p>So, instead of many small methods for run, jump, and similar, we will have one method named <code>transition</code> and a bunch of <code>Event</code> variants. How does this improve things? Because there is only one <code>match</code> statement that we have to update when we want to add a transition, instead <a id="_idIndexMarker276"/>of potentially adding multiple <a id="_idIndexMarker277"/>little <code>match</code> statements. Keep in mind that this function takes <code>mut</code> <code>self</code>, which means calling <code>transition</code> will consume <code>self</code> and return a new <code>RedHatBoyStateMachine</code> just as the <code>run</code> method does on <code>RedHatBoyState&lt;Idle&gt;</code>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor101"/>Using Into for clean code</h2>
			<p>We can actually <a id="_idIndexMarker278"/>improve the ergonomics of this method <a id="_idIndexMarker279"/>using the <code>From</code> trait. If you're unfamiliar, the <code>From</code> trait is a Rust feature that lets us define how to convert from one type to another. Implementing the <code>From</code> trait on your type will also implement the <code>Into</code> trait, which will provide an <code>into</code> method that will make it easy to convert from one type to another.</p>
			<p>We know that if we have <code>RedHatBoyState&lt;Running&gt;</code>, it will convert into the <code>RedHatBoyStateMachine::Running</code> variant, and if we write the conversion by implementing the <code>From</code> trait, we will be able to replace that wrapping with a call to <code>into</code>. That was a lot of words for a little bit of code, so the following is what the implementation of the <code>From</code> trait looks like:</p>
			<pre>impl From&lt;RedHatBoyState&lt;Running&gt;&gt; for RedHatBoyStateMachine {
    fn from(state: RedHatBoyState&lt;Running&gt;) -&gt; Self {
        RedHatBoyStateMachine::Running(state)
    }
}</pre>
			<p>This can be placed right under the implementation of <code>RedHatBoyStateMachine</code>. It defines how to convert from <code>RedHatBoy&lt;Running&gt;</code> to <code>RedHatBoyStateMachine</code>, and it's the same small amount of code we wrote in the <code>transition</code> method. Because we have this now, we can make that method a little more succinct, as shown here:</p>
			<pre>impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            (RedHatBoyStateMachine::Idle(state), 
             Event::Run) =&gt; <strong class="bold">state.run().into()</strong>,
            _ =&gt; self,
        }
    }
    ...</pre>
			<p>Replacing calls like <code>RedHatBoyStateMachine::Idle::Running(state.run)</code> with <code>into</code> isn't just prettier and more concise; it also means that if <code>run</code> changes to return a different state, the <code>transition</code> method can stay the same, as long as a <code>From</code> trait has been written to go from the state to the <code>RedHatBoyStateMachine</code> <code>enum</code>. It's a nice little change that makes our code more flexible.</p>
			<p>It's a little odd that the <code>RedHatBoyStateMachine</code> <code>enum</code> is what we call our state machine because we don't normally associate <a id="_idIndexMarker280"/>enumerated types with behavior, but this <a id="_idIndexMarker281"/>method is why we call it a machine. We use <code>enum</code> to hold the various generic states, and we use the ability to add methods to an <code>enum</code> to make it a lot more ergonomic to use. The various states know how to transition from one state to another, and the machine knows when to do the transitions.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor102"/>Integrating the state machine</h2>
			<p>Now that we've built a <a id="_idIndexMarker282"/>state machine, albeit one with two states, we need to actually use it for <a id="_idIndexMarker283"/>something. Recall our current game, let RHB run throughout a meaningless void. We're going to want to change it so that RHB starts in the left corner and begins running when the user hits the <em class="italic">right arrow key</em>. In other words, they will transition from <code>Idle</code> to <code>Running</code>. When that happens, we'll also want to make sure we're showing the appropriate animation.</p>
			<p>We'll start by putting <code>RedHatBoy</code> in the <code>WalkTheDog</code> game:</p>
			<pre>pub struct WalkTheDog {
    image: Option&lt;HtmlImageElement&gt;,
    sheet: Option&lt;Sheet&gt;,
    frame: u8,
    position: Point,
    rhb: Option&lt;RedHatBoy&gt;,
}
...
impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog {
            image: None,
            sheet: None,
            frame: 0,
            position: Point { x: 0, y: 0 },
            rhb: None,
        }
    }
}</pre>
			<p>RHB will need to be an <code>Option</code> for now because <code>RedHatBoy</code> contains a sprite sheet. Since the <a id="_idIndexMarker284"/>sprite <a id="_idIndexMarker285"/>sheet isn't available until the image is loaded in <code>initialize</code>, we have to make <code>rhb</code> an <code>Option</code> type. We'll want to initialize the machine in the <code>initialize</code> function, and for that purpose, we'll want to create a convenient <code>new</code> method for the <code>Idle</code> state:</p>
			<pre>mod red_hat_boy_states {
    use crate::engine::Point;
    const FLOOR: i16 = 475;
    ...
    impl RedHatBoyState&lt;Idle&gt; {
        pub fn new() -&gt; Self {
            RedHatBoyState {
                context: RedHatBoyContext {
                    frame: 0,
                    position: Point { x: 0, y: FLOOR },
                    velocity: Point { x: 0, y: 0 },
                },
                _state: Idle {},
            }
        }
        ...</pre>
			<p>Because <code>Idle</code> is the initial state, it's the only state that will get a <code>new</code> function, as mentioned earlier. We've also introduced a constant called <code>FLOOR</code> that marks the bottom of the screen, where RHB will land when he jumps.</p>
			<p>I'll show it here as if it's defined right at the top of the <code>red_hat_boy_states</code> module. Now, in <code>Game</code> <code>initialize</code>, we still have a compiler error because we haven't set up <code>RedHatBoy</code> in the game. We can do that right after we've loaded the sprite sheet, and we'll<a id="_idIndexMarker286"/> keep <a id="_idIndexMarker287"/>two copies of the sprite sheet around; not because we want two copies, but because we'll delete all the old code when we've successfully replaced it with the new code. You can see the changes here:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        let sheet<strong class="bold">: Option&lt;Sheet&gt;</strong> = browser::fetch_json(
         "rhb.json").await?.into_serde()?;
        let image = Some(engine::load_image(
         "rhb.png").await?);
        Ok(Box::new(WalkTheDog {
            <strong class="bold">image: image.clone(),</strong>
            <strong class="bold">sheet: sheet.clone(),</strong>
            frame: self.frame,
            position: self.position,
           <strong class="bold"> rhb: Some(RedHatBoy::new(</strong>
<strong class="bold">                sheet.clone().ok_or_else(|| anyhow!</strong>
<strong class="bold">                    ("No Sheet Present"))?,</strong>
<strong class="bold">                image.clone().ok_or_else(|| anyhow!</strong>
<strong class="bold">                    ("No Image Present"))?,</strong>
<strong class="bold">            )),</strong>
        }))
    }
...</pre>
			<p>We had to change a surprising amount of code here, because of Rust's borrowing rules. Our intent is to <code>clone</code> <code>sheet</code> and <code>image</code> and send those into the <code>RedHatBoy::new</code> method. However, if we do that, we also need to clone <code>image</code> and <code>sheet</code> when setting the fields for <code>image</code> and <code>sheet</code> on <code>WalkTheDogStruct</code>. Why? Because the <code>image: image</code> line is a move, and can't be accessed after that. That's the borrow after move error. Instead we clone <code>image</code> and sheet and move the cloned instances into WalkTheDog. Then when creating the RedHatBoy we clone them again.</p>
			<p>The same goes for <code>sheet</code>. We also have to explicitly call out the type of <code>sheet</code> when we assign it in the first <a id="_idIndexMarker288"/>place because the compiler can't infer <a id="_idIndexMarker289"/>the type anymore. Fortunately, this is an intermediate step; we are working past the compiler errors and will eventually reduce this code to what we actually need. We can't yet because we've replaced one compiler error with two!</p>
			<p>Before, the <code>rhb</code> field wasn't filled in when we created <code>WalkTheDog</code>, so that didn't compile. In order to set the <code>rhb</code> field to something, we are presuming a <code>RedHatBoy::new</code> method exists, but it doesn't, so that doesn't compile. We are also passing the soon-to-exist constructor clones of <code>sheet</code> and <code>image</code>. The <code>Sheet</code> type doesn't support <code>clone</code> yet, so that doesn't compile either. We'll need to fix both of these compiler errors to move forward.</p>
			<p>Before we continue, I want to note how we use the <code>ok_or_else</code> construct on each <code>clone</code> call, and then the <code>?</code> operator. <code>RedHatBoy</code> doesn't need to hold <code>Option&lt;Sheet&gt;</code> or <code>Option&lt;HtmlImageElement&gt;</code>, so its constructor will take <code>Sheet</code> and <code>HtmlImageElement</code>. Calling <code>ok_or_else</code> will convert <code>Option</code> into <code>Result</code>, and <code>?</code> will return from the <code>initialize</code> method with <code>Error</code> if the value isn't present. This prevents the rest of the code from having to continually validate that the <code>Option</code> type is present, so the code will be a little bit cleaner. The <code>Option</code> type is great, but at any time you can replace working with an <code>Option</code> type with the actual value it's wrapping.</p>
			<p>The easiest of the two compiler errors to fix is the fact that <code>sheet</code> doesn't implement <code>clone</code>. Many in the Rust community derive <code>Clone</code> on any public type, and while I won't be following that <a id="_idIndexMarker290"/>practice in this book, there's no reason not to add<a id="_idIndexMarker291"/> it to <code>Sheet</code> and the types it references, as shown here. Remember, <code>Sheet</code> is in the <code>engine</code> module:</p>
			<pre>#[derive(Deserialize, <strong class="bold">Clone</strong>)]
pub struct SheetRect {
    pub x: i16,
    pub y: i16,
    pub w: i16,
    pub h: i16,
}
#[derive(Deserialize, <strong class="bold">Clone</strong>)]
pub struct Cell {
    pub frame: SheetRect,
}
#[derive(Deserialize, <strong class="bold">Clone</strong>)]
pub struct Sheet {
    pub frames: HashMap&lt;String, Cell&gt;,
}</pre>
			<p>Now, we're down to one compiler error, <code>RedHatBoy</code> doesn't have a <code>new</code> function, so let's create an <code>impl</code> block for the <code>RedHatBoy</code> struct and define that, as shown here:</p>
			<pre>impl RedHatBoy {
    fn new(sheet: Sheet, image: HtmlImageElement) -&gt; Self {
        RedHatBoy {
            state_machine: RedHatBoyStateMachine::Idle(
             RedHatBoyState::new()),
            sprite_sheet: sheet,
            image,
        }
    }
}</pre>
			<p>This creates a new <code>RedHatBoy</code> with <a id="_idIndexMarker292"/>a state machine in the <code>Idle</code> state. We've <a id="_idIndexMarker293"/>also loaded <code>sprite_sheet</code> and <code>image</code> in the <code>initialize</code> function and passed them to this constructor. Congratulations! Our code compiles!</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor103"/>Drawing RedHatBoy</h2>
			<p>Unfortunately, this <a id="_idIndexMarker294"/>still doesn't<a id="_idIndexMarker295"/> do much. <code>RedHatBoy</code> is never drawn! The interface we want is to say <code>self.rhb.draw()</code> and see RHB drawing the idle animation. We also want to call the <code>run</code> function when we push the <em class="italic">right arrow</em> and see RHB run.</p>
			<p>Let's start by implementing <code>draw</code> on <code>RedHatBoy</code>. We'll create a draw function that will mimic the draw function in <code>WalkTheDog</code> only using the shared <code>RedHatBoyContext</code> that's in <code>RedHatBoyState</code>. That<a id="_idIndexMarker296"/> code is as follows, written as part of <a id="_idIndexMarker297"/>the <code>impl RedHatBoy</code> block:</p>
			<pre>impl RedHatBoy {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        let frame_name = format!(
            "{} ({}).png",
            self.state_machine.frame_name(),
            (self.state_machine.context().frame / 3) + 1
        );
        let sprite = self
            .sprite_sheet
            .frames
            .get(&amp;frame_name)
            .expect("Cell not found");
        renderer.draw_image(
            &amp;self.image,
            &amp;Rect {
                x: sprite.frame.x.into(),
                y: sprite.frame.y.into(),
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
            &amp;Rect {
                x: self.state_machine.context()
                 .position.x.into(),
                y: self.state_machine.context()
                 .position.y.into(),
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
        );
    }
}</pre>
			<p>This is nearly identical to the code that exists in the <code>draw</code> function already for our happily running RHB. Instead of always using the <code>frame_name</code> function, which doesn't exist yet.</p>
			<p>We're also getting <code>position</code> and <code>frame</code> off <code>context()</code>, another function that doesn't exist<a id="_idIndexMarker298"/> yet. Again, we'll let the compiler guide us to create both<a id="_idIndexMarker299"/> of these functions; Compiler-Driven Development strikes again! The <code>RedHatBoyStateMachine</code> <code>enum</code> needs to provide a way to return <code>RedHatBoyContext</code> and <code>frame_name</code>. We can add those implementations, as follows:</p>
			<pre>impl RedHatBoyStateMachine {
    ...
    fn frame_name(&amp;self) -&gt;&amp;str {
        match self {
            RedHatBoyStateMachine::Idle(state) =&gt; 
             state.frame_name(),
            RedHatBoyStateMachine::Running(state) =&gt; 
             state.frame_name(),
        }
    }
    fn context(&amp;self) -&gt;&amp;RedHatBoyContext {
        match self {
            RedHatBoyStateMachine::Idle(state) 
             =&gt;&amp;state.context(),
            RedHatBoyStateMachine::Running(state) 
             =&gt;&amp;state.context(),
        }
    }
}</pre>
			<p>I admit I don't love either of these methods and did consider creating a trait that the various states would implement as an alternative. After some thought, I decided this was simpler, and because the Rust compiler will fail if you don't match every single <code>enum</code> variant, I'm willing to accept these duplicate <em class="italic">case</em> statements.</p>
			<p>The <code>frame_name</code> and <code>context</code> methods both delegate to the currently active <code>state</code> to get the data that's required. In the case of <code>frame_name</code>, this will be a method that returns the name of the animation in <code>rhb.json</code> for a given state as defined on each state. The <code>context</code> method is particularly odd because we always return the same field for every single state and always will, as that data is shared across all the <a id="_idIndexMarker300"/>states. That's <a id="_idIndexMarker301"/>going to require a generic implementation, which we'll write in a moment. An exercise for you would be to simplify these functions with a macro, but we won't do that here.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You might have noticed that the line <code>self.state_machine.context().position.x</code> violates the <code>self</code> should only talk to <code>state_machine</code> (its friend) but instead, it talks to <code>position</code> via <code>context</code>. This couples <code>RedHatBoy</code> to the internal structure of <code>RedHatBoyContext</code> in a way that could be avoided by adding getters for <code>position_x</code> and <code>position_y</code> on <code>state machine</code>, which would delegate to <code>context</code>, which would, in turn, delegate to <code>position</code>. The Law of Demeter is a great guideline when setting values, and you should almost always follow it for mutable data, but in this case the data is immutable. We can't change the context through this getter, and the downsides of violating the Law of Demeter are not as relevant. I don't feel it's necessary to create more delegating functions just to avoid violating an arbitrary guideline, but if it becomes a problem, we can always change it. For more information <a id="_idIndexMarker303"/>on this, go to <a href="https://wiki.c2.com/?LawOfDemeter">https://wiki.c2.com/?LawOfDemeter</a>.</p>
			<p>Following the compiler again, we've moved the errors from the <code>draw</code> method on <code>RedHatBoy</code> into <code>RedHatBoyStateMachine</code> because none of the states have methods for <code>frame_name</code> or <code>context</code>. Out of these two methods, <code>frame_name</code> is more straightforward, so we'll implement it first. It's a getter of the name of<a id="_idIndexMarker304"/> the<a id="_idIndexMarker305"/> frame in the <code>rhb.json</code> file, and it's different for every state, so we'll put that method on every state, as shown here:</p>
			<pre>mod red_hat_boy_states {
    use crate::engine::Point;
    const FLOOR: i16 = 475;
    <strong class="bold">const IDLE_FRAME_NAME: &amp;str = "Idle";</strong>
    <strong class="bold">const RUN_FRAME_NAME: &amp;str = "Run";</strong>
    impl RedHatBoyState&lt;Idle&gt; {
        ...
        <strong class="bold">pub fn frame_name(&amp;self) -&gt; &amp;str {</strong>
            <strong class="bold">IDLE_FRAME_NAME</strong>
        <strong class="bold">}</strong>
    }
    ...
    impl RedHatBoyState&lt;Running&gt; {
        <strong class="bold">pub fn frame_name(&amp;self) -&gt; &amp;str {</strong>
            <strong class="bold">RUN_FRAME_NAME</strong>
        <strong class="bold">}</strong>
    }
}</pre>
			<p>We've added two constants, <code>IDLE_FRAME_NAME</code> and <code>RUN_FRAME_NAME</code>, which correspond to the names of the frames for the <code>Idle</code> and <code>Run</code> sections of our sprite sheets, respectively. We then created a new method, <code>frame_name</code>, on <code>RedHatBoyState&lt;Idle&gt;</code> as well as an entirely new implementation for <code>RedHatBoyState&lt;Running&gt;</code>, which also has a <code>frame_name</code> method.</p>
			<p>It's worth thinking about whether we could use a trait object (<a href="https://bit.ly/3JSyoI9">https://bit.ly/3JSyoI9</a>) instead of our <code>enum</code> for <code>RedHatBoyStateMachine</code>, and it probably is possible. I've experimented with it and didn't come to a satisfying solution, but I would encourage you to give it a shot. You'll learn a lot more from this book if you experiment with the code on your own. </p>
			<p>Now that we've handled the <code>frame_name</code> method, we'll want to add a <code>context</code> method. That <a id="_idIndexMarker306"/>method <a id="_idIndexMarker307"/>is going to do the same thing for every state, return the context, and we can write it generically for all of them, as shown here:</p>
			<pre>mod red_hat_boy_states {
    ....
    #[derive(Copy, Clone)]
    pub struct RedHatBoyState&lt;S&gt; {
        context: RedHatBoyContext,
        _state: S,
    }
    <strong class="bold">impl&lt;S&gt; RedHatBoyState&lt;S&gt; {</strong>
        <strong class="bold">pub fn context(&amp;self) -&gt; &amp;RedHatBoyContext {</strong>
            <strong class="bold">&amp;self.context</strong>
        <strong class="bold">}</strong>
<strong class="bold">}</strong>
...</pre>
			<p>This is a pretty cool feature of Rust. Since we have a generic struct, we can write methods on the generic type, and it will apply to all the types. Finally, there is one more compiler <a id="_idIndexMarker308"/>error, in the <code>draw</code> function where we reference the frame<a id="_idIndexMarker309"/> or position fields on context. These fields are private, but as long as <code>RedHatBoyContext</code> is an immutable type, we can each make of those public, as follows:</p>
			<pre>mod red_hat_boy_states {
    ...
    #[derive(Copy, Clone)]
    pub struct RedHatBoyContext {
        <strong class="bold">pub </strong>frame: u8,
        <strong class="bold">pub </strong>position: Point,
        <strong class="bold">pub </strong>velocity: Point,
        }
        ...</pre>
			<p>Finally, we need to call that method on <code>RedHatBoy</code> in the <code>WalkTheDog#draw</code> function. You can add that in this, admittedly awkward, one-liner right at the end of the <code>draw</code> function:</p>
			<pre>fn draw(&amp;self, renderer: &amp;Renderer) {
    ...
    self.rhb.as_ref().unwrap().draw(renderer);</pre>
			<p>If you've<a id="_idIndexMarker310"/> followed <a id="_idIndexMarker311"/>along successfully, you should see the following screen:</p>
			<div><div><img alt="Figure 4.4 – RHBs&#13;&#10;" src="img/Figure_4.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – RHBs</p>
			<p>At the top we have our old, endlessly running RHB, and at the bottom our new RHB just standing still. The new version has fewer features; we've gone backward, but why? This prepared us for what we're going to do next, moving him around and changing animations. Speaking of animations, the <code>Idle</code> version of RHB isn't doing anything yet, because <code>frame</code> never changes. When RHB is idle, he stand<a id="_idTextAnchor104"/>s while breathing slowly, so let's get that started, shall we?</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor105"/>Updating RHB</h2>
			<p>Our <code>RedHatBoy</code> struct is<a id="_idIndexMarker312"/> going to have an <code>update</code> function, which<a id="_idIndexMarker313"/> will, in turn, delegate to an <code>update</code> function on the state machine. It's a new method because every state is going to need to update, in order to advance the animation. We'll call <code>update</code> on <code>RedHatBoy</code> from <code>update</code> on <code>WalkTheDog</code>. That's a lot of updates, but it's really just delegation:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
....
        if self.frame &lt; 23 {
            self.frame += 1;
        } else {
            self.frame = 0;
        }
        <strong class="bold">self.rhb.as_mut().unwrap().update();</strong>
    }
}
impl RedHatBoy {
    ...
    <strong class="bold">fn update(&amp;mut self) {</strong>
        <strong class="bold">self.state_machine = self.state_machine.update();</strong>
    <strong class="bold">}</strong>
}
impl RedHatBoyStateMachine {
    ...
    <strong class="bold">fn update(self) -&gt; Self {</strong>
        <strong class="bold">match self {</strong>
            <strong class="bold">RedHatBoyStateMachine::Idle(mut state) =&gt; {</strong>
                <strong class="bold">if state.context.frame &lt; 29 {</strong>
                    <strong class="bold">state.context.frame += 1;</strong>
                <strong class="bold">} else {</strong>
                    <strong class="bold">state.context.frame = 0;</strong>
                <strong class="bold">}</strong>
                <strong class="bold">RedHatBoyStateMachine::Idle(state)</strong>
            <strong class="bold">}</strong>
            <strong class="bold">RedHatBoyStateMachine::Running(_) =&gt; self,</strong>
        }
    }
}</pre>
			<p>In the <code>update</code> function on <code>WalkTheDog</code>, we've only added one new line, at the end of the <code>update</code> function:</p>
			<pre>self.rhb.as_mut().unwrap().update();</pre>
			<p>It's funky because <a id="_idIndexMarker314"/>of the fact that <code>rhb</code> is <code>Option</code>, and we'll fix that in a little<a id="_idIndexMarker315"/> bit. We've added another small function to the <code>RedHatBoy</code> <code>struct</code> <code>update</code> that simply updates <code>state_machine</code> via the state machine's <code>update</code> function. This one line, and others like it, are why the state machine needs to be <code>Copy</code>. If it's not, then because <code>update</code> consumes <code>self</code> via the parameter of <code>mut self</code>, you'd have to use something like <code>Option</code> to move <code>self</code> into <code>update</code>, and then reset it again. By making everything <code>Copy</code>, you get a much more ergonomic <code>update</code> function.</p>
			<p>Finally, the meat of the behavior is in the <code>RedHatBoyStateMachine#update</code> function. Here, we match on <code>self</code> and update the current frame on a mutable <code>state</code> parameter, and then return a new <code>Idle</code> state with a moved <code>context</code> with an updated frame. Unfortunately, this code doesn't compile; <code>context</code> isn't a public data member so you can't assign it. For now, we'll go ahead and make <code>context</code> public, but this should bother you. Remember that Law of Demeter guideline I mentioned earlier. It's one thing to get an immutable data value, another thing entirely to set a mutable value. This is the kind of coupling that could cause real problems down the line. We're <em class="italic">not</em> going to fix it right now, so go ahead and make <code>context</code> public, but we will be keeping a very close eye on this code.</p>
			<p>At this point, if you look at <code>update</code> for <code>WalkTheDog</code> and <code>update</code> for <code>RedHatBoyStateMachine</code>, you'll see similarities. One is updating the running RHB in the upper<a id="_idIndexMarker316"/> left<a id="_idIndexMarker317"/> corner, and one is updating the idle RHB in the lower left. The time has come to begin combining these two objects. Let's go ahead and do that.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Adding the Running state</h2>
			<p>One thing to keep in <a id="_idIndexMarker318"/>mind about states is that they exist whether you implement a state machine or not. While we <a id="_idIndexMarker319"/>haven't implemented anything in <code>RedHatBoyState&lt;Running&gt;</code>, the <code>Running</code> state currently exists in <code>WalkTheDog</code>; RHB is running all around the void right now! We just need to move the details into our state machine, so that we as programmers can actually see the states and what they do as one coherent unit. Plus, then we'll stop having a sad and lonely boy who is running in place in the left-hand corner of the screen.</p>
			<p>We can do that quickly by just modifying <code>update</code> in <code>RedHatBoyStateMachine</code> to match the version in <code>Idle</code>, with the different frame count for the run animation. That's shown as follows:</p>
			<pre>impl RedHatBoyStateMachine {
    ...
    fn update(self) -&gt; Self {
        match self {
            ...
            RedHatBoyStateMachine::Running(mut state) =&gt; {
                if state.context.frame &lt; 23 {
                    state.context.frame += 1;
                } else {
                    state.context.frame = 0;
                }
                RedHatBoyStateMachine::Running(state)
            }
        }
    }
}</pre>
			<p>Now, the state machine is theoretically capable of drawing the run animation, but we haven't written anything to cause that transition. The other thing missing is potentially more subtle. The <code>Running</code> animation has <code>23</code> frames, and the <code>Idle</code> animation has <code>29</code>. If we were to transform from <code>Idle</code> to <code>Running</code> with the frame count at <code>24</code>, the game would crash.</p>
			<p>Finally, I think we<a id="_idIndexMarker320"/> can all <a id="_idIndexMarker321"/>agree that the kind of duplication that we have here can be improved. The only difference between the two functions is the frame count. So, we have a few things to do:</p>
			<ol>
				<li>Refactor the duplicated code.</li>
			</ol>
			<p>The code that updates <code>context.frame</code> suffers from a code smell called <code>update</code> function is operating over and <a id="_idIndexMarker322"/>over again on <code>context</code>. Why not move that function to <code>RedHatBoyContext</code>? That's shown here:</p>
			<pre>const IDLE_FRAMES: u8 = 29;
const RUNNING_FRAMES: u8 = 23;
...
impl RedHatBoyStateMachine {
    fn update(self) -&gt; Self {
        match self {
            RedHatBoyStateMachine::Idle(mut state) =&gt; {
                state.context = 
                 state.context.update(IDLE_FRAMES);
                RedHatBoyStateMachine::Idle(state)
            }
            RedHatBoyStateMachine::Running(mut state) 
             =&gt; {
                state.context = state.context.update(
                 RUNNING_FRAMES);
                RedHatBoyStateMachine::Running(state)
            }
        }
    }
}
mod red_hat_boy_states {
    ...
    impl RedHatBoyContext {
        pub fn update(mut self, frame_count: u8) -&gt; 
         Self {
            if self.frame &lt; frame_count {
                self.frame += 1;
            } else {
                self.frame = 0;
            }
            self
        }
    } </pre>
			<p><code>RedHatBoyContext</code> now has an <code>update</code> function that increments the frame, looping it back to <code>0</code> when the total frame count is reached. Note how it works the same way as <a id="_idIndexMarker323"/>our transitions, consuming <code>self</code>, and returning<a id="_idIndexMarker324"/> a new <code>RedHatBoyContext</code>, although in reality, it's the same <code>instance</code> the entire time. This gives us the same kind of <em class="italic">functional</em> interface that we're using elsewhere. The total frame count changes with each state, so we pass that in as a parameter, using constants for clarity.</p>
			<ol>
				<li value="2">Fix the Law of Demeter violation.</li>
			</ol>
			<p>Looking at the two arms of each <code>match</code> statement, they are nearly identical, both mutating <code>context</code> in the way we didn't like earlier. Now is a good time to address it, which we can do by making the field private on <code>RedHatBoyState&lt;S&gt;</code> again, and creating new methods on the respective <code>RedHatBoy</code> state implementations, as shown here:</p>
			<pre>mod red_hat_boy_states {
    ...
    const IDLE_FRAMES: u8 = 29;
    const RUNNING_FRAMES: u8 = 23;
    ....
    impl RedHatBoyState&lt;Idle&gt; {
        ....
        pub fn update(&amp;mut self) {
            self.context = self.context.update(
             IDLE_FRAMES);
        }
    }
    impl RedHatBoyState&lt;Running&gt; {
         ...
         pub fn update(&amp;mut self) {
            self.context = self.context.update(
             RUNNING_FRAMES);
        }
    }
}</pre>
			<p>There! That's better. <code>context</code> is no longer inappropriately public, and each individual state handles its own updating. The only difference between them is the constant they use, and it's fitting to have that bundled with the implementation itself. Speaking of which, make sure you move the <code>RUNNING_FRAMES</code> and <code>IDLE_FRAMES</code> constants into the <code>red_hat_boy_states</code> module.</p>
			<p>We'll need <a id="_idIndexMarker325"/>to <a id="_idIndexMarker326"/>modify the <code>update</code> method on <code>RedHatBoyStateMachine</code> to call this new method on each of the states:</p>
			<pre>impl RedHatBoyStateMachine {
    ....
    fn update(self) -&gt; Self {
        match self {
            RedHatBoyStateMachine::Idle(mut state) =&gt; 
            {
                state.update();
                RedHatBoyStateMachine::Idle(state)
            }
            RedHatBoyStateMachine::Running(mut state) 
             =&gt; {
                state.update();
                RedHatBoyStateMachine::Running(state)
            }
        }
    }
}</pre>
			<p>Each of the <a id="_idIndexMarker327"/>arms<a id="_idIndexMarker328"/> in update now updates the state, and then returns the state. There's some duplication here that's a little suspicious; we'll take another look at that shortly. </p>
			<ol>
				<li value="3">Move RHB on every <code>update</code>.</li>
			</ol>
			<p>If RHB is going to run in the running state, it needs to respect the velocity. In other words, update animates the frame, but it doesn't move, so let's add that to the <code>RedHatBoyContext</code> <code>update</code> method:</p>
			<pre>fn update(mut self, frame_count: u8) -&gt; Self {
    ...
    self.position.x += self.velocity.x;
    self.position.y += self.velocity.y;
    self
}</pre>
			<p>Of course, RHB won't move yet because we aren't changing the velocity. That will come soon.</p>
			<ol>
				<li value="4">Ensure that the frame count resets to <code>0</code> when transitioning between states.</li>
			</ol>
			<p>There are two <a id="_idIndexMarker329"/>categories of changes on the game object that can<a id="_idIndexMarker330"/> happen in our state machine. There are changes that happen when the state doesn't change. That's what <code>update</code> is and right now those are written in <code>RedHatBoyStateMachine</code>. There are also changes that happen on a transition, and those happen in the transition functions that are defined as methods of the type classes.</p>
			<p>We already transitioned from <code>Idle</code> to <code>Running</code> via the <code>run</code> method, and we can make sure to reset the frame rate on the transition. That's a small change you can see here:</p>
			<pre>    impl RedHatBoyContext {
        ...
        fn reset_frame(mut self) -&gt; Self {
            self.frame = 0;
            self
        }
    }
    impl RedHatBoyState&lt;Idle&gt; {
        ....
        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {
            RedHatBoyState {
                context: self.context<strong class="bold">.reset_frame()</strong>,
                _state: Running {},
            }
        }
    }</pre>
			<p><code>RedHatBoyContext</code> has grown a function called <code>reset_frame</code>, which resets its frame <a id="_idIndexMarker331"/>count to <code>0</code> and returns itself. By returning itself, we<a id="_idIndexMarker332"/> can chain calls together, which will come in handy shortly. The <code>run</code> method has also evolved to call <code>reset_frame()</code> on <code>RedHatBoyContext</code> and use that new version of <code>context</code> in the new <code>RedHatBoyState</code> struct.</p>
			<ol>
				<li value="5">Start Running on transition.</li>
			</ol>
			<p>Now that we have prevented crashes by restarting animations on transitions, let's start running forward on a transition. This is going to be very short:</p>
			<pre>mod red_hat_boy_states {
....
const RUNNING_SPEED: i16 = 3;
...
impl RedHatBoyContext {
    ...
        fn run_right(mut self) -&gt; Self {
            self.velocity.x += RUNNING_SPEED;
            self
        }
    }
    impl RedHatBoyState&lt;Idle&gt; {
        pub fn run(self) -&gt; RedHatBoyState&lt;Running&gt; {
            RedHatBoyState {
                context: self.context.reset_frame()
                 <strong class="bold">.run_right()</strong>,
                _state: Running {},
            }
        }
    }</pre>
			<p>We've sprouted another method on <code>RedHatBoyContext</code> called <code>run_right</code>, which <a id="_idIndexMarker333"/>simply adds forward speed to the velocity. Meanwhile, we've<a id="_idIndexMarker334"/> chained a call (see!) to <code>run_right</code> in the transition. Don't forget to add the <code>RUNNING_SPEED</code> constant to the module.</p>
			<ol>
				<li value="6">Start Running on the <em class="italic">right</em> arrow.</li>
			</ol>
			<p>Finally, we actually need to call this event when the <code>ArrowRight</code> button is pressed. At this point, we can follow along with where we're doing this in the <code>WalkTheDog</code> implementation:</p>
			<pre>impl Game for WalkTheDog {
    ...
    if keystate.is_pressed("ArrowRight") {
        velocity.x += 3;
        <strong class="bold">self.rhb.as_mut().unwrap().run_right();</strong>
    }
}
impl RedHatBoy {
    ...
    fn run_right(&amp;mut self) {
        self.state = self.state.transition(
         Event::Run);
    }
}</pre>
			<p>This will now start <a id="_idIndexMarker335"/>our RHB running, so much so that he'll run<a id="_idIndexMarker336"/> right off the screen!</p>
			<div><div><img alt="Figure 4.5 – This could be a problem" src="img/Figure_4.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – This could be a problem</p>
			<p>At this point, we could re-establish <em class="italic">moonwalking</em>, to bring RHB back on screen, but that doesn't really serve the purpose of the game. You can either create an event that resets horizontal velocity every update, just like the current code does, or you could track when a key goes up to remove some velocity. The second one feels better but will cause us to write a few events and possibly a transition from <code>Running</code> to <code>Idle</code>. No, we'll go to a third approach: ignore it and hit refresh! We don't need to move backward in our actual game, nor stop, so we won't. Let's not spend any more time writing code, that we'll just delete anyway. Speaking of that.</p>
			<ol>
				<li value="7">Delete the original code.</li>
			</ol>
			<p>Now that the new and improved RHB is moving, it's time to get rid of all the references in <code>WalkTheDog</code> to the sheet, the element, the frame…basically anything that isn't the <code>RedHatBoy</code> <code>struct</code>:</p>
			<pre>pub struct WalkTheDog {
   rhb: Option&lt;RedHatBoy&gt;,
}</pre>
			<p>Rather than boring you with endless deletes, I'll simply say you can delete all the fields that aren't <code>rhb</code> and follow the compiler errors to delete the rest of the code. When you're done, <code>WalkTheDog</code> becomes very short, as it should be. As for the arrow keys, you only need to worry about the <code>ArrowRight</code> key, and moving to the right.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As I said, we won't be restoring moving backward, up, or down here, but you could certainly consider restoring the walking backward functionality by extending the state machine. Doing so will help you internalize the lesson here and save you the trouble of refreshing all the time.</p>
			<p>So, now RHB<a id="_idIndexMarker337"/> can run <a id="_idIndexMarker338"/>across the screen, but that's not much fun. Let's add sliding.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor107"/>Transitioning to sliding</h2>
			<p>Transitioning<a id="_idIndexMarker339"/> from running to sliding will involve adding a <a id="_idIndexMarker340"/>new state for sliding, so that we see the sliding action, but also checking for when a slide is complete and transitioning back into the running state. This will mean sliding will have its own variation on the <code>update</code> function. We can start by adding sliding on the <em class="italic">down</em> arrow and treating it all just like running. We'll go through this quickly because most of it is familiar. Let's start by adding sliding on the <em class="italic">down</em> arrow in the <code>update</code> method of <code>WalkTheDog</code>:</p>
			<pre>impl Game for WalkTheDog {
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        ...
        if keystate.is_pressed("ArrowDown") {
            self.rhb.as_mut().unwrap().slide();
        }
    }
}</pre>
			<p>It's time to follow<a id="_idIndexMarker341"/> the compiler. RedHatBoy doesn't have <a id="_idIndexMarker342"/>a <code>slide</code> method, so let's add that, as shown here:</p>
			<pre>impl RedHatBoy {
    ...
    fn slide(&amp;mut self) {
        self.state_machine = self.state_machine.transition(
         Event::Slide);
    }
}</pre>
			<p>Transitioning via <code>Event::Slide</code> doesn't exist. There's no <code>Event::Slide</code> at all, so let's add those next:</p>
			<pre>enum Event {
    ....
    Slide,
}
impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            ...
            (RedHatBoyStateMachine::Running(state), 
             Event::Slide) =&gt; state.slide().into(),
            _ =&gt; self,
        }
    }
    ...</pre>
			<p>There's nothing new in the preceding code block. When RHB is <code>Running</code>, it can transition to <code>Sliding</code> via the <code>Event::Slide</code> event and the <code>slide</code> method, which doesn't exist on the <code>RedHatBoyState&lt;Running&gt;</code> typestate. This is all very similar to how we went from <code>Idle</code> to <code>Running</code>. </p>
			<p>To continue <a id="_idIndexMarker343"/>with<a id="_idIndexMarker344"/> the compiler, we need to add a <code>slide</code> method to the <code>RedHatBoyState&lt;Running&gt;</code> typestate, as in the following:</p>
			<pre>mod red_hat_boy_states {
    ...
    impl RedHatBoyState&lt;Running&gt; {
        ...
        pub fn slide(self) -&gt; RedHatBoyState&lt;Sliding&gt; {
            RedHatBoyState {
                context: self.context.reset_frame(),
                _state: Sliding {},
            }
        }
    }</pre>
			<p>The <code>slide</code> method on <code>RedHatBoyState&lt;Running&gt;</code> converts the state into <code>RedHatBoyState&lt;Sliding&gt;</code>, only calling <code>reset_frame</code> on <code>context</code> to make sure the sliding<a id="_idIndexMarker345"/> animation starts playing at frame <code>0</code>. We also <a id="_idIndexMarker346"/>call <code>into</code> on the <code>slide </code>method, which needs to convert <code>RedHatBoyState&lt;Sliding&gt;</code> into a <code>RedHatBoyStateMachine</code> variant. That means we need to create the variant and create a <code>From</code> implementation for it, as shown here:</p>
			<pre>enum RedHatBoyStateMachine {
    ...
    Sliding(RedHatBoyState&lt;Sliding&gt;),
}
impl From&lt;RedHatBoyState&lt;Sliding&gt;&gt; for RedHatBoyStateMachine {
    fn from(state: RedHatBoyState&lt;Sliding&gt;) -&gt; Self {
        RedHatBoyStateMachine::Sliding(state)
    }
}</pre>
			<p>At this point, you'll see errors on the <code>frame_name</code>, <code>context</code>, and <code>update</code> methods of <code>RedHatBoyStateMachine</code> because their corresponding <code>match</code> calls don't have cases for the new <code>Sliding</code> variant. We can fix that by adding <a id="_idIndexMarker347"/>cases to those <code>match </code>statements, which will <a id="_idIndexMarker348"/>mimic the other cases:</p>
			<pre>impl RedHatBoyStateMachine {
    ...   
    fn frame_name(&amp;self) -&gt; &amp;str {
        match self {
            ...
            RedHatBoyStateMachine::Sliding(state) =&gt; 
             state.frame_name(),
        }
    }
    fn context(&amp;self) -&gt;&amp;RedHatBoyContext{
        match self {
            ...
            RedHatBoyStateMachine::Sliding(state) 
             =&gt; &amp;state.context(),
        }
    }
    fn update(self) -&gt; Self {
        match self {
            RedHatBoyStateMachine::Sliding(mut state) =&gt; {
                state.update();
                RedHatBoyStateMachine::Sliding(state)
            }
        }
    }
}</pre>
			<p>Once again, we've replaced one compiler error with another. There is no <code>Sliding</code> state, and it doesn't have the methods we assumed it would. We<a id="_idIndexMarker349"/> can fix that by filling it in, adding some<a id="_idIndexMarker350"/> constants for good measure:</p>
			<pre>mod red_hat_boy_states {
    const SLIDING_FRAMES: u8 = 14;
    const SLIDING_FRAME_NAME: &amp;str = "Slide";
    ...
   #[derive(Copy, Clone)]
    struct Sliding;
    impl RedHatBoyState&lt;Sliding&gt; {
        pub fn frame_name(&amp;self) -&gt; &amp;str {
            SLIDING_FRAME_NAME
        }
        pub fn update(&amp;mut self) {
            self.context = self.context.update(
             SLIDING_FRAMES);
        }
    }
}</pre>
			<p>If you look through this code, you'll see it's very similar to our already existing running code. If you followed along, you'll see RHB start skidding across the floor until he goes past the right edge of the screen:</p>
			<div><div><img alt="Figure 4.6 – Safe&#13;&#10;" src="img/Figure_4.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Safe</p>
			<p>Stopping RHB from sliding is a little different than what we've done before. What we need to do is identify when the slide animation is complete, then transition right back into running without any user input. We'll start by checking whether the animation is done in the <code>update</code> method <a id="_idIndexMarker351"/>of the <code>enum</code>, which represents our <a id="_idIndexMarker352"/>machine, and then create a new transition from sliding back into running. We can do that by modifying the <code>RedHatBoyStateMachine</code> <code>update</code> method to check after updating in the sliding branch, as follows:</p>
			<pre>fn update(self) -&gt; Self {
    match self {
        ...
        RedHatBoyStateMachine::Sliding(mut state) =&gt; {
            state.update(SLIDING_FRAMES);
            if state.context().frame &gt;= SLIDING_FRAMES {
                RedHatBoyStateMachine::Running(
                 state.stand())
            } else {
                RedHatBoyStateMachine::Sliding(state)
            }
        }
    }
}</pre>
			<p>This doesn't compile yet, because stand isn't defined yet and because <code>SLIDING_FRAMES</code> is in the <code>red_hat_boy_states</code> module. You might think that we can make <code>SLIDING_FRAMES</code> public and define a <code>stand</code> method, or we could move <code>SLIDING_FRAMES</code> into the <code>game</code> module. These will both work but I think it's time to look a little more holistically at our <code>update</code> method. </p>
			<p>Every arm of the <code>match</code> statement updates the current state and then returns a new state. In the case of <code>Running</code> and <code>Idle</code>, it was always the same state, but in the case of <code>Sliding</code>, sometimes it's the <code>Running</code> state. It turns out <code>update</code> is a<a id="_idIndexMarker353"/> transition, just one that sometimes transitions <a id="_idIndexMarker354"/>to the state it started from. In a state diagram, it looks like this:</p>
			<div><div><img alt="Figure 4.7 – Sliding to Running" src="img/Figure_4.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Sliding to Running</p>
			<p>If we wanted to be strict about it, we could say that <code>Updating</code> state when it gets an <strong class="bold">Update</strong> event, then it can transition back to <strong class="bold">Sliding</strong> or <strong class="bold">Running</strong>. This is a case where the state exists, at least conceptually, but we don't actually have to create it in our code. </p>
			<p><code>update</code> on the <code>Sliding</code> state is really best modeled as a transition because it's a method that ultimately returns a state. Come to think of it, that's exactly what the other arms in the <code>update</code> method are too! Yes, they don't ever transition to another state, but each branch calls <code>update</code> and then returns a state. So, before we add <code>Sliding</code> to the <code>update</code> method, let's refactor to make <code>update</code> a transition for both of the other states. </p>
			<p>Since we're using Compiler-Driven Development, we'll change the <code>update</code> method to work as if <code>update</code> is already a transition:</p>
			<pre>pub enum Event {
    ...
    <strong class="bold">Update,</strong>
}
impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            (RedHatBoyStateMachine::Idle(state), 
             Event::Run) =&gt; state.run().into(),
            (RedHatBoyStateMachine::Running(state), 
             Event::Slide) =&gt; state.slide().into(),
            <strong class="bold">(RedHatBoyStateMachine::Idle(state), </strong>
<strong class="bold">             Event::Update) =&gt; state.update().into(),</strong>
<strong class="bold">            (RedHatBoyStateMachine::Running(state), </strong>
<strong class="bold">             Event::Update) =&gt; state.update().into(),</strong>
            _ =&gt; self,
        }
    }
    ...
    fn update(self) -&gt; Self {
        self.transition(Event::Update)
    }
}</pre>
			<p>With these changes, we've turned <code>Update</code> into <code>Event</code> and added two more arms to <code>match</code> in the <code>transition</code> method. Both of those arms work the same way as the other transitions: they call a method on the typestate and then convert the state into the <code>RedHatBoyStateMachine enum</code> with the <code>From</code> trait. The compiler error you get now might be a little strange; it looks like this:</p>
			<pre>error[E0277]: the trait bound 'RedHatBoyStateMachine: From&lt;()&gt;' is not satisfied
   --&gt; src/game.rs:155:83
    |
155 |             (RedHatBoyStateMachine::Idle(state), Event::Update) =&gt; state.update().into(),
    |                                                                                  ^^^^ the trait 'From&lt;()&gt;' is not implemented for 'RedHatBoyStateMachine'</pre>
			<p>You may <a id="_idIndexMarker355"/>have <a id="_idIndexMarker356"/>expected that the error would say something about the <code>update</code> method not returning anything, but remember all Rust functions return something; they just return <code>Unit</code> when they don't return anything else. So, this error is telling you there's no way to convert from the <code>()</code>, or <code>Unit</code>, to a value of the <code>RedHatBoyStateMachine </code>type. That's not what we want to fix; we want to make both of the <code>update</code> calls on the states return new states. Those changes are next:</p>
			<pre>mod red_hat_boy_states {
    impl RedHatBoyState&lt;Idle&gt; {
        ...
        pub fn update(<strong class="bold">mut self</strong>) -&gt; <strong class="bold">Self </strong>{
            self.context = self.context.update(
             IDLE_FRAMES);
            <strong class="bold">self</strong>
        }
}
...
impl RedHatBoyState&lt;Running&gt; {
    ...
    pub fn update(<strong class="bold">mut self</strong>) -&gt; <strong class="bold">Self</strong> {
        self.context = self.context.update(RUNNING_FRAMES);
        <strong class="bold">self</strong>
    }
}
...</pre>
			<p>The changes are small but important. The <code>update</code> method for <code>RedHatBoyState&lt;Idle&gt;</code> and <code>RedHatBoyState&lt;Running&gt;</code> both return <code>Self</code> now, because even though the state doesn't change, these are still typestate methods that <a id="_idIndexMarker357"/>return a new state. They <a id="_idIndexMarker358"/>also take <code>mut self</code> now instead of <code>&amp;mut self</code>. You can't return <code>self</code> if you mutably borrow it, so this method stopped compiling. More importantly, this means these methods don't make unnecessary copies. They take ownership of <code>self</code> when called, and then return it. So, if you're worried about an optimization problem because of extra copies, you don't have to be.</p>
			<p>Now, we're down to one compiler error, which we've seen before:</p>
			<pre>the trait 'From&lt;red_hat_boy_states::RedHatBoyState&lt;red_hat_boy_states::Idle&gt;&gt;' is not implemented for 'RedHatBoyStateMachine'</pre>
			<p>We didn't implement a conversion from the <code>Idle</code> state back to the <code>RedHatBoyStateMachine enum</code>. That's similar to the other ones we wrote, implementing <code>From&lt;RedHatBoyState&lt;Idle&gt;&gt;</code>, as shown here:</p>
			<pre>impl From&lt;RedHatBoyState&lt;Idle&gt;&gt; for RedHatBoyStateMachine {
    fn from(state: RedHatBoyState&lt;Idle&gt;) -&gt; Self {
        RedHatBoyStateMachine::Idle(state)
    }
}</pre>
			<p>Remember that these implementations of the <code>From</code> trait are not in the <code>red_hat_boy_states</code> module. The <code>red_hat_boy_states</code> module knows about the individual states but does not know about <code>RedHatBoyStateMachine</code>. That's not its job.</p>
			<p>Now that we've<a id="_idIndexMarker359"/> refactored the code, our little RHB doesn't slide<a id="_idIndexMarker360"/> anymore. Instead, he kind of sits down because the <code>Sliding</code> state doesn't handle the <code>Update</code> event. Let's fix that now.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor108"/>Transitioning to sliding and back again</h2>
			<p>Part of the reason <a id="_idIndexMarker361"/>we used the typestate pattern for our individual states is so that we get compiler errors when we make a mistake. For instance, if we call <code>run</code> when we are in the <code>Running</code> state, it won't even compile because there is no such method. There is one place this doesn't hold, the <code>transition</code> method on the <code>RedHatBoyStateMachine</code> <code>enum</code>. If you call <code>transition</code> with a <code>RedHatBoyStateMachine</code> variant and an <code>Event</code> variant pair that don't have a match, it returns <code>Self</code>.</p>
			<p>That's why our RHB is sitting down. He transitions to <code>Sliding</code> and then stops updating, staying in the same state forever. We'll fix that by adding the match for the <code>Update</code> event and then, you guessed it, follow the compiler to implement the sliding animation.</p>
			<p>This starts by adding the match to the transition method, as shown here:</p>
			<pre>impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            ...
            (RedHatBoyStateMachine::Sliding(state), 
             Event::Update) =&gt; state.update().into(),
            _ =&gt; self,
        }
    }</pre>
			<p>This match is just like the others; we match on <code>Sliding</code> and <code>Update</code> and call <code>update</code>. Just like before, we'll get an error:</p>
			<pre>the trait 'From&lt;()&gt;' is not implemented for 'RedHatBoyStateMachine'</pre>
			<p>The <code>Sliding</code> state still has an update method that doesn't return a state. That's not going to work with our current setup, but it's not as simple as making the <code>update</code> method return <code>Self</code>, as on the other two states.</p>
			<p>Remember, there are two possible states that can come from the <code>update</code> method on <code>Sliding</code>: <code>Sliding</code> and <code>Running</code>. How is that going to work with our current setup? What we'll need to do is have <code>update</code> return an <code>SlidingEndState</code> <code>enum</code> that can be either <code>Sliding</code> or <code>Running</code>, and then <a id="_idIndexMarker362"/>we'll implement a <code>From</code> trait that will convert that into the appropriate variant of <code>RedHatBoyStateMachine</code>. That's odd to explain, so let's see it in action. We can modify the <code>update</code> method on <code>RedHatBoyState&lt;Sliding&gt;</code> to work like the one we proposed at the beginning of this section:</p>
			<pre>mod red_hat_boy_states {
    ...
    impl RedHatBoyState&lt;Sliding&gt; {
        ...
        pub fn update(mut self) -&gt; SlidingEndState {
            self.context = self.context.update(
             SLIDING_FRAMES);
            if self.context.frame &gt;= SLIDING_FRAMES {
                SlidingEndState::Complete(self.stand())
            } else {
                SlidingEndState::Sliding(self)
            }
        }
    }
}</pre>
			<p>We've taken the code that we originally considered putting in the <code>RedHatBoyStateMachine</code> <code>update</code> method and moved it into the <code>update</code> method of <code>RedHatBoyState&lt;Sliding&gt;</code>. This makes sense conceptually; the state should know how it behaves. On every update, we<a id="_idIndexMarker363"/> update <code>context</code>, and then check whether the animation is complete, with <code>if self.context.frame &gt;= SLIDING_FRAMES</code>. If the animation is complete, we return one variant of this new <code>enum</code> that doesn't exist yet: <code>SlidingState</code>. The <code>SlidingState</code> variant can either be <code>Complete</code> or <code>Sliding</code>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It's definitely a little strange that the <code>update</code> method doesn't return another state here, and probably means we aren't using a <em class="italic">pure</em> typestate method. An alternative might have been to return the next <code>Event</code> from <code>update</code> and send that back into a call to the <code>transition</code> method on <code>RedHatBoyStateMachine</code>. That implementation ends up looking very strange because states are returning <code>Events</code> that are only used by <code>RedHatBoyStateMachine</code> and are otherwise unreferenced in the <code>red_hat_boy_states</code> module. Regardless of whether the strange return value of <code>update</code> makes you uncomfortable, I would encourage you to try other approaches. Maybe yours is better than mine!</p>
			<p>Following the compiler yet again, we have two obvious problems: there is no <code>stand</code> method and there is no <code>SlidingEndState</code> <code>enum</code>. We can handle both of these right here, next to the code we just wrote, as shown:</p>
			<pre>impl RedHatBoyState&lt;Sliding&gt; {
    ...
    pub fn stand(self) -&gt; RedHatBoyState&lt;Running&gt; {
        RedHatBoyState {
            context: self.context.reset_frame(),
            _state: Running,
        }
    }
}
pub enum SlidingEndState {
    Complete(RedHatBoyState&lt;Running&gt;),
    Sliding(RedHatBoyState&lt;Sliding&gt;),
}</pre>
			<p>The only side effect of the transition to <code>Running</code> is that we call <code>reset_frame</code> again on <code>context</code>. Remember this has to be done on every transition, otherwise, the program can try to<a id="_idIndexMarker364"/> animate the new state with <code>frame</code>, which isn't valid and will crash. So, we'll reset the frame back to <code>0</code> on every transition.</p>
			<p>This leaves us with a compiler error to fix once again. This time, it's the following:</p>
			<pre>the trait 'From&lt;SlidingEndState&gt;' is not implemented for 'RedHatBoyStateMachine'</pre>
			<p>Pay close attention to that source trait. It's not coming from one of the states but from the intermediate <code>SlidingEndState</code>. We'll solve it the same way as before, with a <code>From</code> trait, but we'll need to use a <code>match</code> statement to pull it out of the <code>enum</code>:</p>
			<pre>impl From&lt;SlidingEndState&gt; for RedHatBoyStateMachine {
    fn from(end_state: SlidingEndState) -&gt; Self {
        match end_state {
            SlidingEndState::Complete(running_state) =&gt; 
             running_state.into(),
            SlidingEndState::Sliding(sliding_state) =&gt; 
             sliding_state.into(),
        }
    }
}</pre>
			<p>Here, we match on <code>end_state</code> to get the actual <code>State</code> out of <code>enum</code>, and then call <code>into</code> on that state again to get to <code>RedHatBoyStateMachine</code>. A little boilerplate, but it makes it easier to do the conversion. </p>
			<p>And now we have it! Run the game now and you'll see RHB take a short slide and pop back up again to the running state. Now that we've added three animations, it's time to deal with these ugly lines in the <code>WalkTheDog</code> implementation: <code>self.rhb.as_mut().unwrap().slide()</code>.</p>
			<p>We treat <code>rhb</code> as an <code>Option</code> type, not because it's ever really going to be <code>None</code>, but because we don't<a id="_idIndexMarker365"/> have it yet before the <code>WalkTheDog</code> <code>struct</code> is initialized. After <code>WalkTheDog</code> is initialized, <code>rhb</code> can never be <code>None</code> again because the state of<a id="_idTextAnchor109"/> the system has changed. Fortunately, we now have a tool for dealing with that, the good old state machine!</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor110"/>Every little thing I think I see</h2>
			<p><code>WalkTheDog</code> can<a id="_idIndexMarker366"/> be in two states, <code>Loading</code> or <code>Loaded</code>, after it's initialized. Fortunately, we accounted <a id="_idIndexMarker367"/>for this when we wrote our <code>GameLoop</code>. Remember that <code>GameLoop</code> returns <code>Result&lt;Game&gt;</code> from <code>initialize</code>; we're just currently always returning <code>Ok(WalkTheDog)</code>. What if we made <code>WalkTheDog</code> an <code>enum</code> and returned a different state of our game instead? That would mean <code>WalkTheDog</code> would be a state machine, with two states, and <code>initialize</code> would become the transition! That's exactly what we're going to do. Modify <code>WalkTheDog</code> so it is no longer a <code>struct</code> but an <code>enum</code>, as shown here:</p>
			<pre>pub enum WalkTheDog {
    Loading,
    Loaded(RedHatBoy),
}</pre>
			<p>This is great; now everything is broken! Whoops! We'll need to adjust the <code>WalkTheDog</code> implementation to account for the two variants. First, we'll change the <code>initialize</code> function on <code>WalkTheDog</code>:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                let json = browser::fetch_json(
                 "rhb.json").await?;
                let rhb = RedHatBoy::new(
                    json.into_serde::&lt;Sheet&gt;()?,
                    engine::load_image("rhb.png").await?,
                );
                Ok(Box::new(WalkTheDog::Loaded(rhb)))
            }
            WalkTheDog::Loaded(_) =&gt; Err(anyhow!
                ("Error: Game is already initialized!")),
        }
}
...</pre>
			<p>Remember in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, where we made this function return <code>Game</code>? This was why! In order to ensure <code>initialize</code> is only called once, <code>initialize</code> has to <a id="_idIndexMarker368"/>match <code>self</code> on its variants, and if we call <code>initialize</code> twice, we'll <a id="_idIndexMarker369"/>return an error via <code>anyhow!</code>. Otherwise, everything inside the <code>Loading</code> branch is the same as before, except we return <code>WalkTheDog::Loaded</code> instead of <code>WalkTheDog</code>. This does cause a compiler warning, which will become an error in future versions of Rust because <code>RedHatBoy</code> isn't public but is exposed in a public type. To get rid of that warning, you'll need to make <code>RedHatBoy</code> public, and that's fine; go ahead and do that. We also <a id="_idIndexMarker370"/>need to change the <code>new</code> constructor to reflect the <a id="_idIndexMarker371"/>new type, as shown here:</p>
			<pre>impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog::Loading
    }
}</pre>
			<p>The <code>WalkTheDog</code> <code>enum</code> starts in <code>Loading</code>, nothing fancy there. The <code>update</code> and <code>draw</code> functions now both need to reflect the changing states; you can see those changes here:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(rhb) = self {
            if keystate.is_pressed("ArrowRight") {
                rhb.run_right();
            }
            if keystate.is_pressed("ArrowDown") {
                rhb.slide();
            }
            rhb.update();
        }
    }
    fn draw(&amp;self, renderer: &amp;Renderer) {
        ...
        if let WalkTheDog::Loaded(rhb) = self {
            rhb.draw(renderer);
        }
    }
}</pre>
			<p>You could argue this isn't really a change on the <code>Option</code> type, as we still need to check the state of <code>Game</code> each time we operate on <code>rhb</code>, and that's true, but I think this more clearly reveals the intent <a id="_idIndexMarker372"/>of the system. It also has the benefit of getting rid of<a id="_idIndexMarker373"/> the <code>as_ref</code>, <code>as_mut</code> code, which is often confusing. Now that we've cleaned up that code, let's add one more animation to RHB. Let's see this boy jump!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor111"/>Transitioning to jumping</h2>
			<p>Going through<a id="_idIndexMarker374"/> each and every change yet again for the jump is redundant. Instead, I can recommend you make the following change:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(rhb) = self {
            ...
            if keystate.is_pressed("Space") {
                rhb.jump();
            }
        }
    }
}
impl RedHatBoy {
    ...
    fn jump(&amp;mut self) {
        self.state_machine = self.state_machine.transition(
         Event::Jump);
    }
}</pre>
			<p>You should be able to follow the compiler errors all the way through, creating a transition from <code>Running</code> to <code>Jumping</code>. You can also look up the constant values you need directly out of <code>rhb.json</code>. The number of frames is the number of images in <code>Jump</code> in the <a id="_idIndexMarker375"/>animation multiplied by <code>3</code>, and subtracting <code>1</code>, and the name of the animation is <code>Jump</code>. Make sure you handle the <code>update</code> event in the transition method for <code>Jumping</code>.</p>
			<p>Do all that and you see RHB skidding across the ground, doing a kind of dance:</p>
			<div><div><img alt="Figure 4.8 – That's...not jumping" src="img/Figure_4.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – That's...not jumping</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you get stuck, the answers to this are available at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/</a>. However, I strongly recommend trying to do this without checking first. Look at what we did for the first three transitions and try to understand what we did. Even if you get stuck, the time spent practicing is valuable here.</p>
			<p>If you've correctly implemented the code for transitioning to the jumping state, our RHB will play his jumping animation, forever, while skidding across the ground. We've seen this before with the slide state, so it's time to figure out what's different about jumping. Of course, we know exactly what's different about jumping – you go up! Well, at least a little.</p>
			<p>There are three things we need to do. First, we give RHB vertical velocity when he jumps; second, we need to add gravity so that RHB will actually come down <a id="_idIndexMarker376"/>when he jumps. And finally, we need to transition running when we land, using our ever-durable state machine:</p>
			<ol>
				<li value="1">Going up on <code>Jump</code>.</li>
			</ol>
			<p>Take a moment and think, where does this belong? Should it go in the <code>update</code> function, the <code>jump</code> event, or maybe in the <code>enum</code> implementation? No, this is a transition change because it happens on <code>jump</code>, and it belongs in the <code>jump</code> method on the <code>Running</code> type class. You should already have a transition from running to jumping, so let's update that function to add vertical velocity:</p>
			<pre>mod red_hat_boy_states {
    ...
    const JUMP_SPEED: i16 = -25;
    ...
    impl RedHatBoyState&lt;Running&gt; {
        ...
        pub fn jump(self) -&gt; RedHatBoyState&lt;Jumping&gt; {
            RedHatBoyState {
                context: self.context.set_vertical_
                 velocity(JUMP_SPEED).reset_frame(),
                _state: Jumping {},
            }
        }
        ...
    impl RedHatBoyContext {
        ...
        fn set_vertical_velocity(mut self, y: i16) -&gt; 
         Self {
            self.velocity.y = y;
            self
        }</pre>
			<p>Remember in our 2D coordinate system, <code>y</code> is <code>0</code> at the top, so we need a negative velocity to go up. It also resets the frame so that the jump <a id="_idIndexMarker377"/>animation starts at frame <code>0</code>. The implementation in <code>RedHatBoyContext</code> is using the same pattern of accepting <code>mut self</code> and returning a new <code>RedHatBoyContext</code>. Now, if you let the app refresh, RHB will take off like Superman!</p>
			<ol>
				<li value="2">Adding gravity.</li>
			</ol>
			<p>In order to have a natural jump, we'll apply gravity on every update. We'll do this <em class="italic">regardless of state</em> because later, we'll need to have RHB fall off of platforms and cliffs, and we don't want to have to constantly pick and choose when we're applying gravity. This will go in the <code>update</code> function of <code>RedHatBoyContext</code>, right at the top:</p>
			<pre>mod red_hat_boy_states {
...
const GRAVITY: i16 = 1;
    impl RedHatBoyContext {
        fn update(mut self, frame_count: u8) -&gt; Self {
             <strong class="bold">self.velocity.y += GRAVITY;</strong></pre>
			<p>If you refresh the page right now, you'll get a blink-and-you'll-miss-it problem, and you'll probably be greeted with a blank screen. The<a id="_idIndexMarker378"/> screen isn't really blank; RHB just fell right through the ground!</p>
			<div><div><img alt="Figure 4.9 – Tell my family I love them" src="img/Figure_4.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Tell my family I love them</p>
			<p>We'll need to address<a id="_idIndexMarker379"/> this with our first case of <strong class="bold">collision resolution</strong>.</p>
			<ol>
				<li value="3">Landing on the ground.</li>
			</ol>
			<p>This is a bit of a spoiler for the next chapter, but collision detection happens in two steps. The first is detection, finding places where things collide, and the second is resolution, where you do something about the collision. Since there isn't anything to collide with in RHB's empty void, we can just do a simple check in the same <code>update</code> function to see whether his new position is past the floor and update the position back to the floor. Keep in mind, you do this <em class="italic">after</em> you update to a new position:</p>
			<pre>    impl RedHatBoyContext {
        pub fn update(mut self, frame_count: u8) -&gt; 
        Self {
            ...
            self.position.x += self.velocity.x;
            self.position.y += self.velocity.y;
            <strong class="bold">if self.position.y &gt; FLOOR {</strong>
                <strong class="bold">self.position.y = FLOOR;</strong>
            <strong class="bold">}</strong></pre>
			<p>This may feel redundant, but we can't know gravity pulled RHB past the ground without actually calculating where he ends up, and we don't draw the in-between state, so the performance cost is minimal. This change prevents RHB from falling through the ground and causes a nice jumping <a id="_idIndexMarker380"/>arc, but he keeps performing the jumping animation for eternity. We need to change the state from <code>Jumping</code> back to <code>Running</code>, and we need to make that decision in <code>RedHatBoyStateMachine</code> because it's a conditional state change based on a condition just like the one that transitioned from <code>Sliding</code> to <code>Running</code>.</p>
			<p>That's a change to the state machine, much like the one we did for <code>Sliding</code>, as seen here:</p>
			<pre>impl RedHatBoyState&lt;Jumping&gt; {
    ...
    pub fn update(mut self) -&gt; JumpingEndState {
        self.context = self.context.update(
         JUMPING_FRAMES);
        if self.context.position.y &gt;= FLOOR {
            JumpingEndState::Complete(self.land())
        } else {
            JumpingEndState::Jumping(self)
        }
    }
}</pre>
			<p>So, if the position is on the floor, we need to transition to <code>Running</code> via the <code>stand</code> method, only we can't! We never wrote a transition from <code>Sliding</code> to <code>Running</code>, just the other way around. We also never wrote a <code>JumpingEndState</code> enum, or a way to convert out of it via <code>From</code>. So, right now, you should see several compiler errors about all of that, the first being the following:</p>
			<pre><strong class="bold">error[E0599]: no method named 'land' found for struct 'red_hat_boy_states::RedHatBoyState' in the current scope</strong>
<strong class="bold">   --&gt; src/game.rs:413:48</strong>
<strong class="bold">    |</strong>
<strong class="bold">258 |     pub struct RedHatBoyState&lt;S&gt; {</strong>
<strong class="bold">    |     ---------------------------- method 'land' not found for this</strong></pre>
			<p>There's the compiler error, but there's no <code>land</code> method. So, go write it. <em class="italic">I'm serious: go write it yourself. I'm not going to reproduce it here</em>. You can go ahead and <a id="_idIndexMarker381"/>follow along with the previous methods we wrote and implement them. You can do it; I believe in you. When you do, you'll have a clean animation from <code>Idle</code> to <code>Running</code>, then <code>Jumping</code>, and back to <code>Running</code> again. Then, you'll wander off the screen because we don't have a full scene yet, but we're getting there!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you get stumped, you can always check the source code for thi<a id="_idTextAnchor112"/>s chapter in the repository at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_4/</a>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor113"/>Summary</h1>
			<p>This chapter covered one topic, but one of the most important topics in game development. State machines are everywhere in games, which we saw when we implemented a small one to manage the <code>Loaded</code> and <code>Loading</code> states of the <code>WalkTheDog</code> <code>enum</code> itself. They are a particularly nice way to implement animation states that must correspond with what the player is doing, and Rust has great ways to implement this pattern. We used two: the simple one for <code>WalkTheDog</code>, and the much more complex <code>RedHatBoyStateMachine</code> that uses the typestate pattern. The typestate pattern is a commonly used pattern in Rust, both inside and outside of game development, so you can expect to see it in many Rust projects.</p>
			<p>We also used the compiler to drive development, over and over again. It's an incredibly useful technique, where you can start with what you want the code to look like and use the compiler's error messages to help you fill in the rest of the implementation. The code becomes like a paint by numbers picture, where you use higher-level code to draw the lines and the compiler error messages tell you how to fill them in. Rust has very good compiler error messages, getting better with every release, and it will pay huge dividends for you to pay close attention to them.</p>
			<p>Now that our RHB can run and jump, how about he runs and jumps on something? We'll put him in a scene and have him jump on it in the next chapter.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>