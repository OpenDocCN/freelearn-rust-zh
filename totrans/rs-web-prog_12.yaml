- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recreating Our Application in Rocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have built a fully functioning to-do application with the
    **Actix Web framework**. In this chapter, we will go through the core concepts
    so that there will be nothing holding us back if we decide to completely recreate
    the to-do application in **Rocket**. This framework might appeal to some developers
    because it does not need as much boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will fully utilize our isolated modular code to completely
    recreate our application in one chapter by copying over and plugging in our existing
    modules, views, database connection configuration, and test pipeline. Even if
    you are not interested in building web applications in Rocket, I still suggest
    you still complete this chapter because you will get to experience why it is important
    to perform well-decoupled testing and write well-structured code, as good tests
    and structure will enable you to switch web frameworks will little effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Rocket?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugging in our existing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning status with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning multiple statuses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering our views with Rocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugging in our existing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a fully working to-do application
    in Rocket with minimal coding. Not only will you understand the basics of configuring
    and running a Rocket server but you will also be able to port over modules, views,
    and tests from other code bases that have used Actix Web and plug them into your
    Rocket server, and vice versa. Not only is this a valuable skill but it also concretes
    the need for good-quality, isolated code. You will see firsthand how and why you
    should structure your code the way we have.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll build on the code built in [*Chapter 11*](B18722_11.xhtml#_idTextAnchor222),
    *Configuring HTTPS with NGINX on AWS*. This can be found at the following URL:
    [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter11/running_https_on_aws).'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: What is Rocket?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rocket is a Rust web framework, like Actix Web. It’s newer than Actix Web and
    has a lower user base at the time of writing. In the previous edition of this
    book, Rocket was running on nightly Rust, meaning that the releases were not stable.
    However, now, Rocket is running on stable Rust.
  prefs: []
  type: TYPE_NORMAL
- en: The framework does have some advantages, depending on your style of coding.
    Rocket is simpler to write, since it implements boilerplate code itself, so the
    developer does not have to write boilerplate themselves. Rocket also supports
    JSON parsing, forms, and type checking out of the box, which can all be implemented
    with just a few lines of code. Features such as logging are already implemented
    as soon as you start a Rocket server. If you want to just get an application off
    the ground with little effort, then Rocket is a good framework. However, it is
    not as established as Actix Web, meaning that as you get more advanced, you might
    find yourself envying some of the features and implementations Actix Web has.
    However, in all my years of web development, I have never come across a problem
    that has been severely held back by the choice of framework. It will mainly come
    down to preference. To really feel the difference, it makes sense to take Rocket
    for a spin. In the next section, we will create a basic server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to setting up a basic server in Rocket, we are going to start
    with everything defined in the `main.rs` file. First, start a new Cargo project
    and then define the Rocket dependency in the `Cargo.toml` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need for now in terms of dependencies. Now, we can move to our
    `src/main.rs` file to define the application. Initially, we need to import the
    Rocket crate and the macros associated with the Rocket crate with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a basic *hello world* view with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, we can deduce that the macro before the function defines
    the method and URL endpoint. The function is the logic that is executed when the
    call is made to the view, and whatever the function returns is what is returned
    to the user. To get a feel for how powerful the URL macro is, we can create two
    more views – one saying `hello` and the other saying `goodbye`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we can pass parameters from the URL into the function.
    Again, this code is clear and straightforward. There is nothing left for us to
    do, apart from attaching these views to the server and starting it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we must decorate the `main` function with a macro from
    Rocket, and we are attaching the views that we defined with no prefix. We can
    then run the `cargo run` command to launch the server. Once we have done the `run`
    command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the logging is comprehensive. It defines the port, address,
    and configuration of the server. It then defines the routes that have been attached,
    as well as fairings. With the preceding logging, we can see that the server is
    healthy, and we have the routes that we expected. Here, we can see that logging
    comes out of the box. We do not have to define anything, unlike in Actix Web.
    We also get a note stating what views are mounted and the URL that the server
    is listening on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call our *hello* view in the browser, which gives us the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The result of calling our hello view](img/Figure_12.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The result of calling our hello view
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this view also gives us the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From looking at the logs, it seems that we cannot ask any more of it. We now
    have a basic server up and running; however, this does not have all the functionality
    that we had in our previous application, built in Actix Web. Recoding all the
    features that we had would result in an excessively long chapter. In the next
    section, we will take advantage of our modular code and slot all our functionality
    into our Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging in our existing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we have been building isolated modules in their own files
    or directories that only concern themselves with one process. For instance, the
    database file only focuses on creating and managing database connections. The
    to-do module only focuses on constructing to-do items, and the JSON serialization
    module is entirely concerned with serializing data structures to and from JSON.
    With all this in mind, we will see how easily these modules can be copied into
    our application and used. Once we have done this, you will get to appreciate firsthand
    why isolated modules are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define our dependencies in the `Cargo.toml` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the crates that we have used in our previous modules. We can now
    copy over our old modules from the Actix Web application in the `web_app` directory
    to our Rocket application, with the following Bash commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is close to working; however, we do have some references to the
    Actix web framework. These can be deleted by deleting the trait implications.
    As we can see in the following diagram, isolated modules can be directly referenced,
    and the advanced integration can be implemented using traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – How our modules can interact with different frameworks](img/Figure_12.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – How our modules can interact with different frameworks
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have deleted the Actix Web trait implementations in the `src/database.rs`
    and `src/json_serialization/to_do_items.rs` files, we can define and import our
    modules in the `main.rs` file. The top of the `main.rs` file should look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the modules imported, we can recreate the `create` view with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the preceding code that it is like our Actix Web implementation
    because we are using our existing modules. The only difference is that we pass
    the `ToDoItems` struct into the `Json` function from the Rocket crate. We have
    not implemented authentication yet, so we are just passing the user ID value of
    `1` for now into all the operations that require a user ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `create` view is done, we can attach it to our server with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we do not have to build our own configuration functions. We
    can just line up the views in the array associated with the prefix, and the macro
    decorating the view functions defines the rest of the URL. We can now run our
    Rocket server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We must remember to spin up our `docker-compose` so the database is accessible
    and run migrations on the database using the `diesel` client. We can then create
    our first to-do item with a `post` request, using the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the `post` request, we will get the following response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it! Our application is functioning, and we did not have to
    recode our entire code base. I know I am repeating myself throughout this book,
    but the importance of well-structured, isolated code cannot be overstated. What
    we have done here is useful when refactoring systems. For instance, I have worked
    on microservices systems where we have had to rip functionality out of one server
    because the scope of it was getting too big and create another one. As you have
    seen here, isolated modules make such tasks a dream that can be completed in record
    time with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have integrated our existing modules in a basic sense, we can move
    on to advanced integration by implementing Rocket traits for our modules.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Rocket traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the logic that we have defined in our modules that we copied over can
    be directly referenced in our code. However, we do have to utilize the database
    connection and the JWT struct that had Actix Web trait implementations. If we
    are to copy over our views, we are going to have to implement Rocket traits for
    the database connection and JWT authentication because we pass them into our view
    functions in the Actix Web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the Rocket traits, we must copy over the JWT file with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then must declare the following dependency in the `Cargo.toml` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move on to the `src/jwt.rs` file for our Rocket trait implementation.
    First, we must import the following traits and structs at the top of the file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The core logic of the implementation of `FromRequest` will be the same because
    we are concerned with the decoding and authentication of our token. However, there
    will be some minor differences because we are implementing a trait from the Rocket
    framework, as opposed to an Actix Web crate. The main difference is that we must
    build our own `enum` that defines the possible outcomes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have picked the different possibilities here because the token might not
    be in the header, so it would be missing. Alternatively, the token might not be
    one of ours, so it could be invalid. And remember, we have a timestamp to force
    an expiry time. If the token has expired, it will have an expired status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is merely implementing the `FromRequest` trait. We do not have
    to touch our `JwToken` struct because the code is isolated and only concerned
    with the encoding and decoding of tokens. The outline of our trait implementation
    can be defined with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have decorated the implementation of the trait with
    an `async` trait macro. This is because requests happen in an async fashion. We
    also must define lifetime notation. This is because we must declare that the lifetime
    of the request will be the same as that of the trait implementation. We can see
    this with the `request` parameter in the `from_request` function. We can now lift
    the logic from our old Actix Web implementation into our `from_request` function
    with a few changes in the types we return. The lifted code should end up looking
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have wrapped our returns in the Rocket `Outcome`, which is
    not too surprising. We have also included our `enum` when decoding or accessing
    the token from the header has failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `JwToken` struct can now be plugged into our Rocket application, but we
    do have to remember to remove the old Actix implementation and all references
    to the Actix Web framework. We also must declare our `jwt` module in the `main.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our next step is to implement the `FromRequest` trait for our database connection.
    At this point, it is a good idea for you to try and implement the `FromRequest`
    trait for the database connection by yourself. There is nothing new that you must
    know to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: If you have tried to implement the `FromRequest` trait for the database connection
    yourself, then it should be like the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must import the required Rocket structs and traits in the `src/database.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then must define the outcomes. We either get the connection or we do not,
    so there is only one possible error for our `enum`, which takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then implement the `FromRequest` trait for the database connection with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should not be too much of a surprise; we have merely fused
    the existing logic of getting a database connection with the implementation of
    a `FromRequest` trait that was laid out in the `JwToken` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we have annotated our `FromRequest` implementation
    with `[rocket::async_trait]`. We use this because, at the time of writing, the
    stabilization for the `async` feature in Rust does not include support for `async`
    functions in traits. If we try and implement an `async` function in a trait without
    the annotation, we will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[rocket::async_trait]` annotation enables us to define `async` functions
    in a trait implementation. There are reasons why we cannot simply desugar the
    `async` function and have the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it will not work because we cannot return the `impl` trait in trait
    functions because this is not supported. For in-depth reading on why `async` functions
    in traits are hard, please visit the following blog post: [https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/](https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement our database connection in the `create` view in the `main.rs`
    file. Again, this is a good opportunity for you to try and implement the database
    connection using the `FromRequest` trait yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have attempted to utilize the Rocket `FromRequest` trait in the `create`
    view, your code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we run our application again and then hit the `create` endpoint, we will
    see that our implementation works! This is a revelation that our views with a
    few alterations can be copied and pasted over to our Rocket application from our
    Actix Web application. In the next section, we will integrate our existing views
    into our Rocket web application.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging in our existing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to our views, they are also isolated, and we can copy our views
    over to the Rocket application with a few minor changes to recycle the views that
    we built for our Actix Web application. We can copy the views with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this copy, it goes without saying now that we must go through and scrub
    the views of any mentions of the Actix Web framework, as we are not using it.
    Once we have cleaned our views of any mention of Actix Web, we can refactor our
    existing code so that it works with the Rocket framework. We will start with our
    `login` view, as this takes in a JSON body and returns JSON in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting and returning JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we change our view, we need to make sure that we have imported all we
    need in the `src/views/auth/login.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is not much that has changed apart from the `Json` struct
    coming from the Rocket crate. Implementing those Rocket traits really helped us
    sever a link in our code to the Actix framework and connect to the Rocket framework,
    without having to change how the structs that are implementing those traits are
    imported or used. With this in mind, the following outline of our login view should
    not be a shock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we reference our incoming JSON body and database connection
    in the same way as we did before in the Actix login view. The major difference
    is the macro that highlights what the data is and what format that incoming data
    takes. Inside the `login` view, we have the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the code that the only difference is instead of returning multiple
    different codes, we merely throw an error. This approach is not optimal. In previous
    builds, the Rocket framework used to implement a straightforward response builder,
    like in Actix. However, at the time of writing, Rocket has implemented a lot of
    breaking changes in its recent releases. Standard response builders simply do
    not work now, and convoluted implementations of traits are needed just to return
    a response with a code, body, and values in the header. Documentation and examples
    of this are also limited at the time of writing. Further reading on constructing
    more advanced responses is supplied in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `login` view is defined, we can move on to our `logout` view that
    returns raw HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Returning raw HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, our logout mechanism returns raw HTML that runs JavaScript in
    a browser to remove our token. When it comes to Rocket, returning raw HTML is
    simple. In our `src/views/auth/logout.rs` file, the entire code takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it is returning a string, just like in the previous Actix Web
    view, but this string is wrapped in a `RawHtml` struct. We can now start updating
    our to-do action views so that our users can manipulate to-do items, as discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Returning status with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have returned JSON and raw HTML. However, remember that our to-do
    applications return JSON with different statuses. To explore this concept, we
    can revisit our `create` view in the `src/views/to_do/create.rs` file, where we
    must return a created status with a JSON body. First, all our imports are the
    same as they were before, apart from the status and JSON structs from the Rocket
    framework with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With these imports, we can define the outline of our `create` view function
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our return value is the `Created` struct, containing the `Json`
    struct, which in turn contains the `ToDoItems` struct. We can also see that our
    JWT authentication is implemented in a view the same way because, again, we are
    implementing the Rocket traits. Our database logic is the same as the previous
    view, as seen with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the task is already not present in the database, we will insert our new
    to-do item. Once we have done this, we get the state of our system and return
    it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The empty string is the location. This can be left blank with no consequences.
    We then attach our body with the `body` function of the status. This is all that
    is needed to get our `create` view running as we want it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the other views for our to-do tasks, they will all be some
    variation of what we have done for the `create` view. All to-do views need to
    take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate using JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take in data from the JSON body and/or user data from the JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make some manipulation of the data in the database (apart from the `GET` view).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the state of the database for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After seeing what we have done with the `create` view, you should be able to
    work through all the other views to make them compatible with the Rocket framework.
    We have covered everything needed to make these changes. Spelling out these changes
    in the book will lead to needless repetitive steps being carried out, excessively
    bloating it. These changes are available on the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Once the to-do item views have been carried out, we can move on to the final
    view that’s needed, the creation of a user, where we must return different statuses
    depending on the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple statuses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to creating a user, we merely return a created status code or
    a conflict status code and nothing else. We do not need to return data because
    the person who has just created the user already knows the user details. In Rocket,
    we can return multiple different status codes with no body. We can explore this
    concept in the `src/views/to_do/create.rs` file, but first, we must ensure that
    we import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have everything we need, we can define the outline of the view
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is nothing new, apart from returning a single `Status`
    struct. Our database logic takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And we return a status out of two possible ones with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our views are complete. We can now move on to the next section to register our
    views with the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: Registering our views with Rocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to the `src/main.rs` file, we must ensure that our view functions
    are available to the `src/main.rs`. This means going through all the `mod.rs`
    files in each view module and declaring the functions that define these views
    as public. We can then move on to the `src/main.rs` file and ensure that the following
    is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `macro_use` declarations should not be a surprise; however, we import the
    Rocket structs to define our CORS policy. With these crates imported, we now must
    ensure that the following modules have been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These modules should all look familiar to you. We then must import our views
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need imported. Before declaring our views on the
    server, we need to define our CORS policy. This is achieved by declaring a struct
    with no fields. We then implement the `Fairing` trait for this struct, allowing
    traffic. Fairings essentially define middleware. Further information on fairings
    is provided in the *Further reading* section. Our CORS policy can be defined with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By this point in the book, we are now familiar with the concept of CORS and
    how to implement a Rocket trait. The preceding code needs no elaboration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have everything needed to mount our views to the server with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Again, there is no explanation needed. You may have noticed that we have started
    to simply show code with little to no explanation. This is good, as we have become
    familiar with the building blocks that we are using. Do not worry – we have come
    to the end of building the main Rocket application, as it will run and do everything
    we need. We could manually test this. However, this would take time and is error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we built our tests in Newman using Postman! In the next section, we
    will test all our endpoints with a few commands using the existing testing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging in our existing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we have used Newman in our testing pipeline, we do not have to worry
    about high coupling with our choice of web framework. First, we need to copy over
    our tests in the `scripts` directory with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before running it, we must add a `GET` method for our `login` view
    with the following outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to import this view into the `src/main.rs` file and declare it
    in the `auth` mounting for our server. We are now ready to run our full tests
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run our full pipeline and give the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Results from our full test pipeline](img/Figure_12.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Results from our full test pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that out of 64 checks, only 3 have failed. If we scroll further
    down, we can see that the errors occur only because we are returning different
    response codes for the `create` view, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Everything else, in terms of the logging in, authentication, migrations, and
    state of the data in the database between every step, has behaved just like we
    expected it to.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through the main concepts needed to replicate
    our to-do application. We built and ran a Rocket server. We then defined routes
    and established a database connection for our server. After that, we explored
    middleware and built authentication and data processing, using guards for our
    views. With this, we created a view that utilized everything we have covered in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: What we gained here was a deeper appreciation for the modular code that we have
    built throughout this book. Even though some of the concepts we revisited had
    not been touched since the start of this book, these modules were isolated, did
    one thing, and did what their labels proposed. Because of this, they can easily
    be copied over and utilized in a completely different framework. Our test pipeline
    also came in handy, instantly confirming that our Rocket application behaves in
    the same way our Actix Web application does. With this in mind, our Rocket application
    could be seamlessly integrated into our build and deployment pipelines instead
    of our Actix Web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the best practices for building a web application,
    resulting in a clean web application repository. Here, you will not only learn
    how to structure a web application repository in terms of testing and configuration
    but also how to package a web application in Docker as a distroless distribution,
    resulting in tiny Docker images that are roughly 50 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rocket documentation: [https://rocket.rs/](https://rocket.rs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fairings documentation: [https://rocket.rs/v0.4/guide/fairings/](https://rocket.rs/v0.4/guide/fairings/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rust Web Development with Rocket: A practical guide to starting your journey
    in Rust web development using the Rocket framework*, *Karuna Murti* (2022), *Packt
    Publishing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have witnessed firsthand the importance of isolating processes such as our
    test pipeline. Looking at the test pipeline, is there a dependency that could
    be removed to further decouple the pipeline so that it isn’t even dependent on
    us testing a Rust server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we attach and detach all functionality in our modules with frameworks
    such as Actix and Rocket?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we deploy our Rocket server on AWS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our test pipeline relies on Diesel to do the migrations. We could
    simply build our own SQL scripts, housed in directories that define our version
    with a version table in the database. This would completely decouple our testing
    pipeline from the server that we are testing. If the server has the same endpoints
    and access to a PostgreSQL database, it can be tested using our pipeline, no matter
    what language the server is coded in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the module is simple with a good interface, we can merely copy it over and
    import it where we want to use it. If the module relies on advanced functionality
    with the framework, we must delete the trait implementations for the framework
    and implement traits for the new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to note that our test pipeline ran the Rocket server without any alterations.
    This is because we are using the same config and using Cargo to build and run
    the application. We would merely just have to point our build to the Rocket application
    and copy over our Dockerfile to the Rocket application. Our build process would
    then build the Rocket application in Docker and deploy it to Docker Hub. Our deployment
    process would then pull the image from Docker Hub and deploy it. We know our endpoints
    are the same and behave in the same way, so integration should be painless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
