["```rs\nfutures = \"0.2.0-beta\"\nfutures-util = \"0.2.0-beta\"\n```", "```rs\n1   extern crate futures;\n2   \n3   use futures::prelude::*;\n4   use futures::task::Context;\n5   use futures::channel::oneshot;\n6   use futures::future::{FutureResult, lazy, ok};\n7   use futures::executor::{block_on, Executor, LocalPool, \n    ThreadPoolBuilder};\n8   \n9   use std::cell::Cell;\n10  use std::rc::Rc;\n11  use std::sync::mpsc;\n12  use std::thread;\n13  use std::time::Duration;\n```", "```rs\n15  #[derive(Clone, Copy, Debug)]\n16  enum Status {\n17    Loading,\n18    FetchingData,\n19    Loaded,\n20  }\n21  \n22  #[derive(Clone, Copy, Debug)]\n23  struct Container {\n24    name: &'static str,\n25    status: Status,\n26    ticks: u64,\n27  }\n28  \n29  impl Container {\n30    fn new(name: &'static str) -> Self {\n31      Container {\n32        name: name,\n33        status: Status::Loading,\n34        ticks: 3,\n35      }\n36    }\n37  \n38    // simulate ourselves retreiving a score from a remote  \n      database\n39    fn pull_score(&mut self) -> FutureResult<u32, Never> {\n40      self.status = Status::Loaded;\n41      thread::sleep(Duration::from_secs(self.ticks));\n42      ok(100)\n43    }\n44  }\n45  \n46  impl Future for Container {\n47    type Item = ();\n48    type Error = Never;\n49  \n50    fn poll(&mut self, _cx: &mut Context) -> Poll<Self::Item,  \n      Self::Error> {\n51      Ok(Async::Ready(()))\n52    }\n53  }\n55  const FINISHED: Result<(), Never> = Ok(());\n56  \n57  fn new_status(unit: &'static str, status: Status) {\n58    println!(\"{}: new status: {:?}\", unit, status);\n59  }\n```", "```rs\n61  fn local_until() {\n62    let mut container = Container::new(\"acme\");\n63  \n64    // setup our green thread pool\n65    let mut pool = LocalPool::new();\n66    let mut exec = pool.executor();\n67  \n68    // lazy will only execute the closure once the future has\n      been polled\n69    // we will simulate the poll by returning using the \n      future::ok method\n70  \n71    // typically, we perform some heavy computational process  \n      within this closure\n72    // such as loading graphic assets, sound, other parts of our  \n      framework/library/etc.\n73    let f = lazy(move |_| -> FutureResult<Container, Never> {\n74      container.status = Status::FetchingData;\n75      ok(container)\n76    });\n77  \n78    println!(\"container's current status: {:?}\",  \n      container.status);\n79  \n80    container = pool.run_until(f, &mut exec).unwrap();\n81    new_status(\"local_until\", container.status);\n82  \n83    // just to demonstrate a simulation of \"fetching data over a  \n      network\"\n84    println!(\"Fetching our container's score...\");\n85    let score = block_on(container.pull_score()).unwrap();\n86    println!(\"Our container's score is: {:?}\", score);\n87  \n88    // see if our status has changed since we fetched our score\n89    new_status(\"local_until\", container.status);\n90  }\n```", "```rs\n92  fn local_spawns_completed() {\n93    let (tx, rx) = oneshot::channel();\n94    let mut container = Container::new(\"acme\");\n95  \n96    let mut pool = LocalPool::new();\n97    let mut exec = pool.executor();\n98  \n99    // change our container's status and then send it to our  \n      oneshot channel\n100   exec.spawn_local(lazy(move |_| {\n101       container.status = Status::Loaded;\n102       tx.send(container).unwrap();\n103       FINISHED\n104     }))\n105     .unwrap();\n106 \n107   container = pool.run_until(rx, &mut exec).unwrap();\n108   new_status(\"local_spanws_completed\", container.status);\n109 }\n110 \n111 fn local_nested() {\n112   let mut container = Container::new(\"acme\");\n114   // we will need Rc (reference counts) since \n      we are referencing multiple owners\n115   // and we are not using Arc (atomic reference counts) \n      since we are only using\n116   // a local pool which is on the same thread technically\n117   let cnt = Rc::new(Cell::new(container));\n118   let cnt_2 = cnt.clone();\n119 \n120   let mut pool = LocalPool::new();\n121   let mut exec = pool.executor();\n122   let mut exec_2 = pool.executor();\n123 \n124   let _ = exec.spawn_local(lazy(move |_| {\n125     exec_2.spawn_local(lazy(move |_| {\n126         let mut container = cnt_2.get();\n127         container.status = Status::Loaded;\n128 \n129         cnt_2.set(container);\n130         FINISHED\n131       }))\n132       .unwrap();\n133     FINISHED\n134   }));\n135 \n136   let _ = pool.run(&mut exec);\n137 \n138   container = cnt.get();\n139   new_status(\"local_nested\", container.status);\n140 }\n```", "```rs\n142 fn thread_pool() {\n143   let (tx, rx) = mpsc::sync_channel(2);\n144   let tx_2 = tx.clone();\n145 \n146   // there are various thread builder options which are \n      referenced at\n147   // https://docs.rs/futures/0.2.0- \n      beta/futures/executor/struct.ThreadPoolBuilder.html\n148   let mut cpu_pool = ThreadPoolBuilder::new()\n149     .pool_size(2) // default is the number of cpus\n150     .create();\n151 \n152   // We need to box this part since we need the Send +'static trait\n153   // in order to safely send information across threads\n154   let _ = cpu_pool.spawn(Box::new(lazy(move |_| {\n155     tx.send(1).unwrap();\n156     FINISHED\n157   })));\n158 \n159   let f = lazy(move |_| {\n160     tx_2.send(1).unwrap();\n161     FINISHED\n162   });\n163 \n164   let _ = cpu_pool.run(f);\n165 \n166   let cnt = rx.into_iter().count();\n167   println!(\"Count should be 2: {:?}\", cnt);\n168 }\n```", "```rs\n170 fn main() {\n171   println!(\"local_until():\");\n172   local_until();\n173 \n174   println!(\"\\nlocal_spawns_completed():\");\n175   local_spawns_completed();\n176 \n177   println!(\"\\nlocal_nested():\");\n178   local_nested();\n179 \n180   println!(\"\\nthread_pool():\");\n181   thread_pool();\n182 }\n```", "```rs\npub trait Future {\n    type Item;\n    type Error;\n    fn poll(\n        &mut self, \n        cx: &mut Context\n    ) -> Result<Async<Self::Item>, Self::Error>;\n}\n```", "```rs\n1   extern crate futures;\n2   \n3   use futures::prelude::*;\n4   use futures::executor::block_on;\n5   use futures::stream;\n6   use futures::task::Context;\n7   use futures::future::{FutureResult, err};\n```", "```rs\n9   struct MyFuture {}\n10  impl MyFuture {\n11    fn new() -> Self {\n12      MyFuture {}\n13    }\n14  }\n15  \n16  fn map_error_example() -> FutureResult<(), &'static str> {\n17    err::<(), &'static str>(\"map_error has occurred\")\n18  }\n19  \n20  fn err_into_example() -> FutureResult<(), u8> {\n21    err::<(), u8>(1)\n22  }\n23  \n24  fn or_else_example() -> FutureResult<(), &'static str> {\n25    err::<(), &'static str>(\"or_else error has occurred\")\n26  }\n27  \n28  impl Future for MyFuture {\n29    type Item = ();\n30    type Error = &'static str;\n31  \n32    fn poll(&mut self, _cx: &mut Context) -> Poll<Self::Item, Self::Error> {\n33      Err(\"A generic error goes here\")\n34    }\n35  }\n36  \n37  struct FuturePanic {}\n38  \n39  impl Future for FuturePanic {\n40    type Item = ();\n41    type Error = ();\n42  \n43    fn poll(&mut self, _cx: &mut Context) -> Poll<Self::Item, \n      Self::Error> {\n44      panic!(\"It seems like there was a major issue with  \n        catch_unwind_example\")\n45    }\n46  }\n```", "```rs\n48  fn using_recover() {\n49    let f = MyFuture::new();\n50  \n51    let f_recover = f.recover::<Never, _>(|err| {\n52      println!(\"An error has occurred: {}\", err);\n53      ()\n54    });\n55  \n56    block_on(f_recover).unwrap();\n57  }\n58  \n59  fn map_error() {\n60    let map_fn = |err| format!(\"map_error_example: {}\", err);\n61  \n62    if let Err(e) = block_on(map_error_example().map_err(map_fn)) \n     {\n63      println!(\"block_on error: {}\", e)\n64    }\n65  }\n66  \n67  fn err_into() {\n68    if let Err(e) = block_on(err_into_example().err_into::()) {\n69      println!(\"block_on error code: {:?}\", e)\n70    }\n71  }\n72  \n73  fn or_else() {\n74    if let Err(e) = block_on(or_else_example()\n75      .or_else(|_| Err(\"changed or_else's error message\"))) {\n76      println!(\"block_on error: {}\", e)\n77    }\n78  }\n```", "```rs\n80  fn catch_unwind() {\n81    let f = FuturePanic {};\n82  \n83    if let Err(e) = block_on(f.catch_unwind()) {\n84      let err = e.downcast::<&'static str>().unwrap();\n85      println!(\"block_on error: {:?}\", err)\n86    }\n87  }\n88  \n89  fn stream_panics() {\n90    let stream_ok = stream::iter_ok::<_, bool>(vec![Some(1),  \n      Some(7), None, Some(20)]);\n91    // We panic on \"None\" values in order to simulate a stream  \n      that panics\n92    let stream_map = stream_ok.map(|o| o.unwrap());\n93  \n94    // We can use catch_unwind() for catching panics\n95    let stream = stream_map.catch_unwind().then(|r| Ok::<_, ()> \n      (r));\n96    let stream_results: Vec<_> =  \n       block_on(stream.collect()).unwrap();\n97  \n98    // Here we can use the partition() function to separate the Ok  \n      and Err values\n99    let (oks, errs): (Vec<_>, Vec<_>) =  \n      stream_results.into_iter().partition(Result::is_ok);\n100   let ok_values: Vec<_> =   \n      oks.into_iter().map(Result::unwrap).collect();\n101   let err_values: Vec<_> =  \n      errs.into_iter().map(Result::unwrap_err).collect();\n102 \n103   println!(\"Panic's Ok values: {:?}\", ok_values);\n104   println!(\"Panic's Err values: {:?}\", err_values);\n105 }\n```", "```rs\n107 fn main() {\n108   println!(\"using_recover():\");\n109   using_recover();\n110 \n111   println!(\"\\nmap_error():\");\n112   map_error();\n113 \n114   println!(\"\\nerr_into():\");\n115   err_into();\n116 \n117   println!(\"\\nor_else():\");\n118   or_else();\n119 \n120   println!(\"\\ncatch_unwind():\");\n121   catch_unwind();\n122 \n123   println!(\"\\nstream_panics():\");\n124   stream_panics();\n125 }\n```", "```rs\n1   extern crate futures;\n2   extern crate futures_util;\n3   \n4   use futures::prelude::*;\n5   use futures::channel::{mpsc, oneshot};\n6   use futures::executor::block_on;\n7   use futures::future::{ok, err, join_all, select_all, poll_fn};\n8   use futures::stream::iter_result;\n9   use futures_util::stream::select_all as select_all_stream;\n10  \n11  use std::thread;\n12  \n13  const FINISHED: Result<Async<()>, Never> = Ok(Async::Ready(()));\n```", "```rs\n15  fn join_all_example() {\n16    let future1 = Ok::<_, ()>(vec![1, 2, 3]);\n17    let future2 = Ok(vec![10, 20, 30]);\n18    let future3 = Ok(vec![100, 200, 300]);\n19  \n20    let results = block_on(join_all(vec![future1, future2,  \n      future3])).unwrap();\n21    println!(\"Results of joining 3 futures: {:?}\", results);\n22  \n23    // For parameters with a lifetime\n24    fn sum_vecs<'a>(vecs: Vec<&'a [i32]>) -> Box<Future, Error = \n      ()> + 'static> {\n25      Box::new(join_all(vecs.into_iter().map(|x| Ok::<i32, ()> \n        (x.iter().sum()))))\n26    }\n27  \n28    let sum_results = block_on(sum_vecs(vec![&[1, 3, 5], &[6, 7, \n      8], &[0]])).unwrap();\n29    println!(\"sum_results: {:?}\", sum_results);\n30  }\n31  \n```", "```rs\n32  fn shared() {\n33    let thread_number = 2;\n34    let (tx, rx) = oneshot::channel::();\n35    let f = rx.shared();\n36    let threads = (0..thread_number)\n37      .map(|thread_index| {\n38        let cloned_f = f.clone();\n39        thread::spawn(move || {\n40          let value = block_on(cloned_f).unwrap();\n41          println!(\"Thread #{}: {:?}\", thread_index, *value);\n42        })\n43      })\n44      .collect::<Vec<_>>();\n45    tx.send(42).unwrap();\n46  \n47    let shared_return = block_on(f).unwrap();\n48    println!(\"shared_return: {:?}\", shared_return);\n49  \n50    for f in threads {\n51      f.join().unwrap();\n52    }\n53  }\n```", "```rs\n55  fn select_all_example() {\n56    let vec = vec![ok(3), err(24), ok(7), ok(9)];\n57  \n58    let (value, _, vec) = block_on(select_all(vec)).unwrap();\n59    println!(\"Value of vec: = {}\", value);\n60  \n61    let (value, _, vec) = \n      block_on(select_all(vec)).err().unwrap();\n62    println!(\"Value of vec: = {}\", value);\n63  \n64    let (value, _, vec) = block_on(select_all(vec)).unwrap();\n65    println!(\"Value of vec: = {}\", value);\n66  \n67    let (value, _, _) = block_on(select_all(vec)).unwrap();\n68    println!(\"Value of vec: = {}\", value);\n69  \n70    let (tx_1, rx_1) = mpsc::unbounded::();\n71    let (tx_2, rx_2) = mpsc::unbounded::();\n72    let (tx_3, rx_3) = mpsc::unbounded::();\n73  \n74    let streams = vec![rx_1, rx_2, rx_3];\n75    let stream = select_all_stream(streams);\n76  \n77    tx_1.unbounded_send(3).unwrap();\n78    tx_2.unbounded_send(6).unwrap();\n79    tx_3.unbounded_send(9).unwrap();\n80  \n81    let (value, details) = block_on(stream.next()).unwrap();\n82  \n83    println!(\"value for select_all on streams: {:?}\", value);\n84    println!(\"stream details: {:?}\", details);\n85  }\n```", "```rs\n87  fn flatten() {\n88    let f = ok::<_, _>(ok::<u32, Never>(100));\n89    let f = f.flatten();\n90    let results = block_on(f).unwrap();\n91    println!(\"results: {}\", results);\n92  }\n93  \n94  fn fuse() {\n95    let mut f = ok::<u32, Never>(123).fuse();\n96  \n97    block_on(poll_fn(move |mut cx| {\n98        let first_result = f.poll(&mut cx);\n99        let second_result = f.poll(&mut cx);\n100       let third_result = f.poll(&mut cx);\n101 \n102       println!(\"first result: {:?}\", first_result);\n103       println!(\"second result: {:?}\", second_result);\n104       println!(\"third result: {:?}\", third_result);\n105 \n106       FINISHED\n107     }))\n108     .unwrap();\n109 }\n110 \n111 fn inspect() {\n112   let f = ok::<u32, Never>(111);\n113   let f = f.inspect(|&val| println!(\"inspecting: {}\", val));\n114   let results = block_on(f).unwrap();\n115   println!(\"results: {}\", results);\n116 }\n```", "```rs\n118 fn chaining() {\n119   let (tx, rx) = mpsc::channel(3);\n120   let f = tx.send(1)\n121     .and_then(|tx| tx.send(2))\n122     .and_then(|tx| tx.send(3));\n123 \n124   let t = thread::spawn(move || {\n125     block_on(f.into_future()).unwrap();\n126   });\n127 \n128   t.join().unwrap();\n129 \n130   let result: Vec<_> = block_on(rx.collect()).unwrap();\n131   println!(\"Result from chaining and_then: {:?}\", result);\n132 \n133   // Chaining streams together\n134   let stream1 = iter_result(vec![Ok(10), Err(false)]);\n135   let stream2 = iter_result(vec![Err(true), Ok(20)]);\n136 \n137   let stream = stream1.chain(stream2)\n138     .then(|result| Ok::<_, ()>(result));\n139 \n140   let result: Vec<_> = block_on(stream.collect()).unwrap();\n141   println!(\"Result from chaining our streams together: {:?}\",   \n      result);\n142 }\n```", "```rs\n144 fn main() {\n145   println!(\"join_all_example():\");\n146   join_all_example();\n147 \n148   println!(\"\\nshared():\");\n149   shared();\n150 \n151   println!(\"\\nselect_all_example():\");\n152   select_all_example();\n153 \n154   println!(\"\\nflatten():\");\n155   flatten();\n156 \n157   println!(\"\\nfuse():\");\n158   fuse();\n159 \n160   println!(\"\\ninspect():\");\n161   inspect();\n162 \n163   println!(\"\\nchaining():\");\n164   chaining();\n165 }\n```", "```rs\n1   extern crate futures;\n2   \n3   use std::thread;\n4   \n5   use futures::prelude::*;\n6   use futures::executor::block_on;\n7   use futures::future::poll_fn;\n8   use futures::stream::{iter_ok, iter_result};\n9   use futures::channel::mpsc;\n```", "```rs\n11  #[derive(Debug)]\n12  struct QuickStream {\n13    ticks: usize,\n14  }\n15  \n16  impl Stream for QuickStream {\n17    type Item = usize;\n18    type Error = Never;\n19  \n20    fn poll_next(&mut self, _cx: &mut task::Context) -> \n      Poll<Option, Self::Error> {\n21      match self.ticks {\n22        ref mut ticks if *ticks > 0 => {\n23          *ticks -= 1;\n24          println!(\"Ticks left on QuickStream: {}\", *ticks);\n25          Ok(Async::Ready(Some(*ticks)))\n26        }\n27        _ => {\n28          println!(\"QuickStream is closing!\");\n29          Ok(Async::Ready(None))\n30        }\n31      }\n32    }\n33  }\n34  \n35  const FINISHED: Result<Async<()>, Never> = Ok(Async::Ready(()));\n```", "```rs\n37  fn quick_streams() {\n38    let mut quick_stream = QuickStream { ticks: 10 };\n39  \n40    // Collect the first poll() call\n41    block_on(poll_fn(|cx| {\n42        let res = quick_stream.poll_next(cx).unwrap();\n43        println!(\"Quick stream's value: {:?}\", res);\n44        FINISHED\n45      }))\n46      .unwrap();\n47  \n48    // Collect the second poll() call\n49    block_on(poll_fn(|cx| {\n50        let res = quick_stream.poll_next(cx).unwrap();\n51        println!(\"Quick stream's next svalue: {:?}\", res);\n52        FINISHED\n53      }))\n54      .unwrap();\n55  \n56    // And now we should be starting from 7 when collecting the \n      rest of the stream\n57    let result: Vec<_> =  \n      block_on(quick_stream.collect()).unwrap();\n58    println!(\"quick_streams final result: {:?}\", result);\n59  }\n```", "```rs\n61  fn iterate_streams() {\n62    use std::borrow::BorrowMut;\n63  \n64    let stream_response = vec![Ok(5), Ok(7), Err(false), Ok(3)];\n65    let stream_response2 = vec![Ok(5), Ok(7), Err(false), Ok(3)];\n66  \n67    // Useful for converting any of the `Iterator` traits into a \n      `Stream` trait.\n68    let ok_stream = iter_ok::<_, ()>(vec![1, 5, 23, 12]);\n69    let ok_stream2 = iter_ok::<_, ()>(vec![7, 2, 14, 19]);\n70  \n71    let mut result_stream = iter_result(stream_response);\n72    let result_stream2 = iter_result(stream_response2);\n73  \n74    let ok_stream_response: Vec<_> = \n      block_on(ok_stream.collect()).unwrap();\n75    println!(\"ok_stream_response: {:?}\", ok_stream_response);\n76  \n77    let mut count = 1;\n78    loop {\n79      match block_on(result_stream.borrow_mut().next()) {\n80        Ok((res, _)) => {\n81          match res {\n82            Some(r) => println!(\"iter_result_stream result #{}: \n              {}\", count, r),\n83            None => { break }\n84          }\n85        },\n86        Err((err, _)) => println!(\"iter_result_stream had an \n          error #{}: {:?}\", count, err),\n87      }\n88      count += 1;\n89    }\n90  \n91    // Alternative way of iterating through an ok stream\n92    let ok_res: Vec<_> = block_on(ok_stream2.collect()).unwrap();\n93    for ok_val in ok_res.into_iter() {\n94      println!(\"ok_stream2 value: {}\", ok_val);\n95    }\n96  \n97    let (_, stream) = block_on(result_stream2.next()).unwrap();\n98    let (_, stream) = block_on(stream.next()).unwrap();\n99    let (err, _) = block_on(stream.next()).unwrap_err();\n100 \n101   println!(\"The error for our result_stream2 was: {:?}\", err);\n102 \n103   println!(\"All done.\");\n104 }\n```", "```rs\n106 fn channel_threads() {\n107   const MAX: usize = 10;\n108   let (mut tx, rx) = mpsc::channel(0);\n109 \n110   let t = thread::spawn(move || {\n111     for i in 0..MAX {\n112       loop {\n113         if tx.try_send(i).is_ok() {\n114           break;\n115         } else {\n116           println!(\"Thread transaction #{} is still pending!\", i);\n117         }\n118       }\n119     }\n120   });\n121 \n122   let result: Vec<_> = block_on(rx.collect()).unwrap();\n123   for (index, res) in result.into_iter().enumerate() {\n124     println!(\"Channel #{} result: {}\", index, res);\n125   }\n126 \n127   t.join().unwrap();\n128 }\n```", "```rs\n130 fn channel_error() {\n131   let (mut tx, rx) = mpsc::channel(0);\n132 \n133   tx.try_send(\"hola\").unwrap();\n134 \n135   // This should fail\n136   match tx.try_send(\"fail\") {\n137     Ok(_) => println!(\"This should not have been successful\"),\n138     Err(err) => println!(\"Send failed! {:?}\", err),\n139   }\n140 \n141   let (result, rx) = block_on(rx.next()).ok().unwrap();\n142   println!(\"The result of the channel transaction is: {}\",\n143        result.unwrap());\n144 \n145   // Now we should be able send to the transaction since we \n      poll'ed a result already\n146   tx.try_send(\"hasta la vista\").unwrap();\n147   drop(tx);\n148 \n149   let (result, rx) = block_on(rx.next()).ok().unwrap();\n150   println!(\"The next result of the channel transaction is: {}\",\n151        result.unwrap());\n152 \n153   // Pulling more should result in None\n154   let (result, _) = block_on(rx.next()).ok().unwrap();\n155   println!(\"The last result of the channel transaction is:  \n      {:?}\",\n156        result);\n157 }\n```", "```rs\n159 fn channel_buffer() {\n160   let (mut tx, mut rx) = mpsc::channel::(0);\n161 \n162   let f = poll_fn(move |cx| {\n163     if !tx.poll_ready(cx).unwrap().is_ready() {\n164       panic!(\"transactions should be ready right away!\");\n165     }\n166 \n167     tx.start_send(20).unwrap();\n168     if tx.poll_ready(cx).unwrap().is_pending() {\n169       println!(\"transaction is pending...\");\n170     }\n171 \n172     // When we're still in \"Pending mode\" we should not be able\n173     // to send more messages/values to the receiver\n174     if tx.start_send(10).unwrap_err().is_full() {\n175       println!(\"transaction could not have been sent to the \n          receiver due \\\n176             to being full...\");\n177     }\n178 \n179     let result = rx.poll_next(cx).unwrap();\n180     println!(\"the first result is: {:?}\", result);\n181     println!(\"is transaction ready? {:?}\",\n182          tx.poll_ready(cx).unwrap().is_ready());\n183 \n184     // We should now be able to send another message \n        since we've pulled\n185     // the first message into a result/value/variable.\n186     if !tx.poll_ready(cx).unwrap().is_ready() {\n187       panic!(\"transaction should be ready!\");\n188     }\n189 \n190     tx.start_send(22).unwrap();\n191     let result = rx.poll_next(cx).unwrap();\n192     println!(\"new result for transaction is: {:?}\", result);\n193 \n194     FINISHED\n195   });\n196 \n197   block_on(f).unwrap();\n198 }\n```", "```rs\n200 fn channel_threads_blocking() {\n201   let (tx, rx) = mpsc::channel::(0);\n202   let (tx_2, rx_2) = mpsc::channel::<()>(2);\n203 \n204   let t = thread::spawn(move || {\n205     let tx_2 = tx_2.sink_map_err(|_| panic!());\n206     let (a, b) = \n        block_on(tx.send(10).join(tx_2.send(()))).unwrap();\n207 \n208     block_on(a.send(30).join(b.send(()))).unwrap();\n209   });\n210 \n211   let (_, rx_2) = block_on(rx_2.next()).ok().unwrap();\n212   let (result, rx) = block_on(rx.next()).ok().unwrap();\n213   println!(\"The first number that we sent was: {}\", \n      result.unwrap());\n214 \n215   drop(block_on(rx_2.next()).ok().unwrap());\n216   let (result, _) = block_on(rx.next()).ok().unwrap();\n217   println!(\"The second number that we sent was: {}\", \n      result.unwrap());\n218 \n219   t.join().unwrap();\n220 }\n```", "```rs\n222 fn channel_unbounded() {\n223   const MAX_SENDS: u32 = 5;\n224   const MAX_THREADS: u32 = 4;\n225   let (tx, rx) = mpsc::unbounded::();\n226 \n227   let t = thread::spawn(move || {\n228     let result: Vec<_> = block_on(rx.collect()).unwrap();\n229     for item in result.iter() {\n230       println!(\"channel_unbounded: results on rx: {:?}\", item);\n231     }\n232   });\n233 \n234   for _ in 0..MAX_THREADS {\n235     let tx = tx.clone();\n236 \n237     thread::spawn(move || {\n238       for _ in 0..MAX_SENDS {\n239         tx.unbounded_send(1).unwrap();\n240       }\n241     });\n242   }\n243 \n244   drop(tx);\n245 \n246   t.join().ok().unwrap();\n247 }\n```", "```rs\n249 fn main() {\n250   println!(\"quick_streams():\");\n251   quick_streams();\n252 \n253   println!(\"\\niterate_streams():\");\n254   iterate_streams();\n255 \n256   println!(\"\\nchannel_threads():\");\n257   channel_threads();\n258 \n259   println!(\"\\nchannel_error():\");\n260   channel_error();\n261 \n262   println!(\"\\nchannel_buffer():\");\n263   channel_buffer();\n264 \n265   println!(\"\\nchannel_threads_blocking():\");\n266   channel_threads_blocking();\n267 \n268   println!(\"\\nchannel_unbounded():\");\n269   channel_unbounded();\n270 }\n```", "```rs\n1   extern crate futures;\n2   \n3   use futures::prelude::*;\n4   use futures::future::poll_fn;\n5   use futures::executor::block_on;\n6   use futures::sink::flush;\n7   use futures::stream::iter_ok;\n8   use futures::task::{Waker, Context};\n9   \n10  use std::mem;\n```", "```rs\n12  fn vector_sinks() {\n13    let mut vector = Vec::new();\n14    let result = vector.start_send(0);\n15    let result2 = vector.start_send(7);\n16  \n17    println!(\"vector_sink: results of sending should both be \n      Ok(()): {:?} and {:?}\",\n18         result,\n19         result2);\n20    println!(\"The entire vector is now {:?}\", vector);\n21  \n22    // Now we need to flush our vector sink.\n23    let flush = flush(vector);\n24    println!(\"Our flush value: {:?}\", flush);\n25    println!(\"Our vector value: {:?}\",  \n      flush.into_inner().unwrap());\n26  \n27    let vector = Vec::new();\n28    let mut result = vector.send(2);\n29    // safe to unwrap since we know that we have not flushed the \n      sink yet\n30    let result = result.get_mut().unwrap().send(4);\n31  \n32    println!(\"Result of send(): {:?}\", result);\n33    println!(\"Our vector after send(): {:?}\", \n      result.get_ref().unwrap());\n34  \n35    let vector = block_on(result).unwrap();\n36    println!(\"Our vector should already have one element: {:?}\", \n      vector);\n37  \n38    let result = block_on(vector.send(2)).unwrap();\n39    println!(\"We can still send to our stick to ammend values: \n      {:?}\",\n40         result);\n41  \n42    let vector = Vec::new();\n43    let send_all = vector.send_all(iter_ok(vec![1, 2, 3]));\n44    println!(\"The value of vector's send_all: {:?}\", send_all);\n45  \n46    // Add some more elements to our vector...\n47    let (vector, _) = block_on(send_all).unwrap();\n48    let (result, _) = block_on(vector.send_all(iter_ok(vec![0, 6, \n      7]))).unwrap();\n49    println!(\"send_all's return value: {:?}\", result);\n50  }\n```", "```rs\n52  fn mapping_sinks() {\n53    let sink = Vec::new().with(|elem: i32| Ok::<i32, Never>(elem \n      * elem));\n54  \n55    let sink = block_on(sink.send(0)).unwrap();\n56    let sink = block_on(sink.send(3)).unwrap();\n57    let sink = block_on(sink.send(5)).unwrap();\n58    println!(\"sink with() value: {:?}\", sink.into_inner());\n59  \n60    let sink = Vec::new().with_flat_map(|elem| iter_ok(vec![elem; \n      elem].into_iter().map(|y| y * y)));\n61  \n62    let sink = block_on(sink.send(0)).unwrap();\n63    let sink = block_on(sink.send(3)).unwrap();\n64    let sink = block_on(sink.send(5)).unwrap();\n65    let sink = block_on(sink.send(7)).unwrap();\n66    println!(\"sink with_flat_map() value: {:?}\", \n      sink.into_inner());\n67  }\n```", "```rs\n69  fn fanout() {\n70    let sink1 = vec![];\n71    let sink2 = vec![];\n72    let sink = sink1.fanout(sink2);\n73    let stream = iter_ok(vec![1, 2, 3]);\n74    let (sink, _) = block_on(sink.send_all(stream)).unwrap();\n75    let (sink1, sink2) = sink.into_inner();\n76  \n77    println!(\"sink1 values: {:?}\", sink1);\n78    println!(\"sink2 values: {:?}\", sink2);\n79  }\n```", "```rs\n81  #[derive(Debug)]\n82  struct ManualSink {\n83    data: Vec,\n84    waiting_tasks: Vec,\n85  }\n86  \n87  impl Sink for ManualSink {\n88    type SinkItem = Option; // Pass None to flush\n89    type SinkError = ();\n90  \n91    fn start_send(&mut self, op: Option) -> Result<(), \n      Self::SinkError> {\n92      if let Some(item) = op {\n93        self.data.push(item);\n94      } else {\n95        self.force_flush();\n96      }\n97  \n98      Ok(())\n99    }\n100 \n101   fn poll_ready(&mut self, _cx: &mut Context) -> Poll<(), ()> {\n102     Ok(Async::Ready(()))\n103   }\n104 \n105   fn poll_flush(&mut self, cx: &mut Context) -> Poll<(), ()> {\n106     if self.data.is_empty() {\n107       Ok(Async::Ready(()))\n108     } else {\n109       self.waiting_tasks.push(cx.waker().clone());\n110       Ok(Async::Pending)\n111     }\n112   }\n113 \n114   fn poll_close(&mut self, _cx: &mut Context) -> Poll<(), ()> {\n115     Ok(().into())\n116   }\n117 }\n118 \n119 impl ManualSink {\n120   fn new() -> ManualSink {\n121     ManualSink {\n122       data: Vec::new(),\n123       waiting_tasks: Vec::new(),\n124     }\n125   }\n126 \n127   fn force_flush(&mut self) -> Vec {\n128     for task in self.waiting_tasks.clone() {\n129       println!(\"Executing a task before replacing our values\");\n130       task.wake();\n131     }\n132 \n133     mem::replace(&mut self.data, vec![])\n134   }\n135 }\n```", "```rs\n137 fn manual_flush() {\n138   let mut sink = ManualSink::new().with(|x| Ok::<Option, ()> \n      (x));\n139   let _ = sink.get_mut().start_send(Some(3));\n140   let _ = sink.get_mut().start_send(Some(7));\n141 \n142   let f = poll_fn(move |cx| -> Poll<Option<_>, Never> {\n143     // Try to flush our ManualSink\n144     let _ = sink.get_mut().poll_flush(cx);\n145     let _ = flush(sink.get_mut());\n146 \n147     println!(\"Our sink after trying to flush: {:?}\", \n        sink.get_ref());\n148 \n149     let results = sink.get_mut().force_flush();\n150     println!(\"Sink data after manually flushing: {:?}\",\n151          sink.get_ref().data);\n152     println!(\"Final results of sink: {:?}\", results);\n153 \n154     Ok(Async::Ready(Some(())))\n155   });\n156 \n157   block_on(f).unwrap();\n158 }\n```", "```rs\n160 fn main() {\n161   println!(\"vector_sinks():\");\n162   vector_sinks();\n163 \n164   println!(\"\\nmapping_sinks():\");\n165   mapping_sinks();\n166 \n167   println!(\"\\nfanout():\");\n168   fanout();\n169 \n170   println!(\"\\nmanual_flush():\");\n171   manual_flush();\n172 }\n```", "```rs\npub trait Sink {\n    type SinkItem;\n    type SinkError;\n\n    fn poll_ready(\n        &mut self, \n        cx: &mut Context\n    ) -> Result<Async<()>, Self::SinkError>;\n    fn start_send(\n        &mut self, \n        item: Self::SinkItem\n    ) -> Result<(), Self::SinkError>;\n    fn poll_flush(\n        &mut self, \n        cx: &mut Context\n    ) -> Result<Async<()>, Self::SinkError>;\n    fn poll_close(\n        &mut self, \n        cx: &mut Context\n    ) -> Result<Async<()>, Self::SinkError>;\n}\n```", "```rs\n1   extern crate futures;\n2   \n3   use futures::prelude::*;\n4   use futures::channel::oneshot::*;\n5   use futures::executor::block_on;\n6   use futures::future::poll_fn;\n7   use futures::stream::futures_ordered;\n8   \n9   const FINISHED: Result<Async<()>, Never> =\n    Ok(Async::Ready(()));\n10  \n11  fn send_example() {\n12    // First, we'll need to initiate some oneshot channels like \n      so:\n13    let (tx_1, rx_1) = channel::();\n14    let (tx_2, rx_2) = channel::();\n15    let (tx_3, rx_3) = channel::();\n16  \n17    // We can decide if we want to sort our futures by FIFO \n      (futures_ordered)\n18    // or if the order doesn't matter (futures_unordered)\n19    // Note: All futured_ordered()'ed futures must be set as a \n      Box type\n20    let mut ordered_stream = futures_ordered(vec![\n21      Box::new(rx_1) as Box<Future>,\n22      Box::new(rx_2) as Box<Future>,\n23    ]);\n24  \n25    ordered_stream.push(Box::new(rx_3) as Box<Future>);\n26  \n27    // unordered example:\n28    // let unordered_stream = futures_unordered(vec![rx_1, rx_2, \n      rx_3]);\n29  \n30    // Call an API, database, etc. and return the values (in our  \n      case we're typecasting to u32)\n31    tx_1.send(7).unwrap();\n32    tx_2.send(12).unwrap();\n33    tx_3.send(3).unwrap();\n34  \n35    let ordered_results: Vec<_> = \n      block_on(ordered_stream.collect()).unwrap();\n36    println!(\"Ordered stream results: {:?}\", ordered_results);\n37  }\n38  \n39  fn check_if_closed() {\n40    let (tx, rx) = channel::();\n41  \n42    println!(\"Is our channel canceled? {:?}\", tx.is_canceled());\n43    drop(rx);\n44  \n45    println!(\"Is our channel canceled now? {:?}\", \n      tx.is_canceled());\n46  }\n47  \n48  fn check_if_ready() {\n49    let (mut tx, rx) = channel::();\n50    let mut rx = Some(rx);\n51  \n52    block_on(poll_fn(|cx| {\n53        println!(\"Is the transaction pending? {:?}\",\n54             tx.poll_cancel(cx).unwrap().is_pending());\n55        drop(rx.take());\n56  \n57        let is_ready = tx.poll_cancel(cx).unwrap().is_ready();\n58        let is_pending = \n          tx.poll_cancel(cx).unwrap().is_pending();\n59  \n60        println!(\"Are we ready? {:?} This means that the pending \n          should be false: {:?}\",\n61             is_ready,\n62             is_pending);\n63        FINISHED\n64      }))\n65      .unwrap();\n66  }\n67  \n68  fn main() {\n69    println!(\"send_example():\");\n70    send_example();\n71  \n72    println!(\"\\ncheck_if_closed():\");\n73    check_if_closed();\n74  \n75    println!(\"\\ncheck_if_ready():\");\n76    check_if_ready();\n77  }\n```", "```rs\n1   extern crate futures;\n2   \n3   use futures::executor::block_on;\n4   use futures::future::{join_all, Future, FutureResult, ok};\n5   use futures::prelude::*;\n6   \n7   #[derive(Clone, Copy, Debug, PartialEq)]\n8   enum PlayerStatus {\n9     Loading,\n10    Default,\n11    Jumping,\n12  }\n13  \n14  #[derive(Clone, Copy, Debug)]\n15  struct Player {\n16    name: &'static str,\n17    status: PlayerStatus,\n18    score: u32,\n19    ticks: usize,\n20  }\n```", "```rs\n22  impl Player {\n23    fn new(name: &'static str) -> Self {\n24      let mut ticks = 1;\n25      // Give Bob more ticks explicitly\n26      if name == \"Bob\" {\n27        ticks = 5;\n28      }\n29  \n30      Player {\n31        name: name,\n32        status: PlayerStatus::Loading,\n33        score: 0,\n34        ticks: ticks,\n35      }\n36    }\n37  \n38    fn set_status(&mut self, status: PlayerStatus) ->  \n      FutureResult<&mut Self, Never> {\n39      self.status = status;\n40      ok(self)\n41    }\n42  \n43    fn can_add_points(&mut self) -> bool {\n44      if self.status == PlayerStatus::Default {\n45        return true;\n46      }\n47  \n48      println!(\"We couldn't add any points for {}!\", self.name);\n49      return false;\n50    }\n51  \n52    fn add_points(&mut self, points: u32) -> Async<&mut Self> {\n53      if !self.can_add_points() {\n54        Async::Ready(self)\n55      } else {\n56        let new_score = self.score + points;\n57        // Here we would send the new score to a remote server\n58        // but for now we will manaully increment the player's \n          score.\n59  \n60        self.score = new_score;\n61  \n62        Async::Ready(self)\n63      }\n64    }\n65  }\n66  \n67  impl Future for Player {\n68    type Item = Player;\n69    type Error = ();\n70  \n71    fn poll(&mut self, cx: &mut task::Context) -> \n      Poll<Self::Item, Self::Error> {\n72      // Presuming we fetch our player's score from a\n73      // server upon initial load.\n74      // After we perform the fetch send the Result value.\n75  \n76      println!(\"Player {} has been poll'ed!\", self.name);\n77  \n78      if self.ticks == 0 {\n79        self.status = PlayerStatus::Default;\n80        Ok(Async::Ready(*self))\n81      } else {\n82        self.ticks -= 1;\n83        cx.waker().wake();\n84        Ok(Async::Pending)\n85      }\n86    }\n87  }\n```", "```rs\n89  fn async_add_points(player: &mut Player,\n90            points: u32)\n91            -> Box<Future + Send> {\n92    // Presuming that player.add_points() will send the points to a\n93    // database/server over a network and returns an updated\n94    // player score from the server/database.\n95    let _ = player.add_points(points);\n96  \n97    // Additionally, we may want to add logging mechanisms,\n98    // friend notifications, etc. here.\n99  \n100   return Box::new(ok(*player));\n101 }\n102 \n103 fn display_scoreboard(players: Vec<&Player>) {\n104   for player in players {\n105     println!(\"{}'s Score: {}\", player.name, player.score);\n106   }\n107 }\n```", "```rs\n109 fn main() {\n110   let mut player1 = Player::new(\"Bob\");\n111   let mut player2 = Player::new(\"Alice\");\n112 \n113   let tasks = join_all(vec![player1, player2]);\n114 \n115   let f = join_all(vec![\n116     async_add_points(&mut player1, 5),\n117     async_add_points(&mut player2, 2),\n118   ])\n119     .then(|x| {\n120       println!(\"First batch of adding points is done.\");\n121       x\n122     });\n123 \n124   block_on(f).unwrap();\n125 \n126   let players = block_on(tasks).unwrap();\n127   player1 = players[0];\n128   player2 = players[1];\n129 \n130   println!(\"Scores should be zero since no players were  \n      loaded\");\n131   display_scoreboard(vec![&player1, &player2]);\n132 \n133   // In our minigame, a player cannot score if they are  \n      currently\n134   // in the air or \"jumping.\"\n135   // Let's make one of our players' status set to the jumping \n      status.\n136 \n137   let f = \n       player2.set_status(PlayerStatus::Jumping).and_then(move |mut \n       new_player2| {\n138     async_add_points(&mut player1, 10)\n139       .and_then(move |_| {\n140         println!(\"Finished trying to give Player 1 points.\");\n141         async_add_points(&mut new_player2, 2)\n142       })\n143       .then(move |new_player2| {\n144         println!(\"Finished trying to give Player 2 points.\");\n145         println!(\"Player 1 (Bob) should have a score of 10 and \n            Player 2 (Alice) should \\\n146               have a score of 0\");\n147 \n148         // unwrap is used here to since\n149         display_scoreboard(vec![&player1, \n            &new_player2.unwrap()]);\n150         new_player2\n151       })\n152   });\n153 \n154   block_on(f).unwrap();\n155 \n156   println!(\"All done!\");\n157 }\n```", "```rs\nfn async_add_points<F>(f: F, player: &mut Player, points: u32) -> impl Future<Item = Player, Error = F::Error>\nwhere F: Future<Item = Player>,\n{\n    // Presuming that player.add_points() will send the points to a  \n    // database/server over a network and returns\n    // an updated player score from the server/database.\n    let _ = player.add_points(points).flatten();\n\n    // Additionally, we may want to add logging mechanisms, friend \n    notifications, etc. here.\n\n    return f.map(player.clone());\n}\n```", "```rs\n1   extern crate futures;\n2   extern crate futures_util;\n3   \n4   use futures::prelude::*;\n5   use futures::executor::LocalPool;\n6   use futures::task::{Context, LocalMap, Wake, Waker};\n7   use futures_util::lock::BiLock;\n8   \n9   use std::sync::Arc;\n10  \n11  struct FakeWaker;\n12  impl Wake for FakeWaker {\n13    fn wake(_: &Arc) {}\n14  }\n15  \n16  struct Reader {\n17    lock: BiLock,\n18  }\n19  \n20  struct Writer {\n21    lock: BiLock,\n22  }\n23  \n24  fn split() -> (Reader, Writer) {\n25    let (a, b) = BiLock::new(0);\n26    (Reader { lock: a }, Writer { lock: b })\n27  }\n29  fn main() {\n30    let pool = LocalPool::new();\n31    let mut exec = pool.executor();\n32    let waker = Waker::from(Arc::new(FakeWaker));\n33    let mut map = LocalMap::new();\n34    let mut cx = Context::new(&mut map, &waker, &mut exec);\n35  \n36    let (reader, writer) = split();\n37    println!(\"Lock should be ready for writer: {}\",\n38         writer.lock.poll_lock(&mut cx).is_ready());\n39    println!(\"Lock should be ready for reader: {}\",\n40         reader.lock.poll_lock(&mut cx).is_ready());\n41  \n42    let mut writer_lock = match writer.lock.lock().poll(&mut \n      cx).unwrap() {\n43      Async::Ready(t) => t,\n44      _ => panic!(\"We should be able to lock with writer\"),\n45    };\n46  \n47    println!(\"Lock should now be pending for reader: {}\",\n48         reader.lock.poll_lock(&mut cx).is_pending());\n49    *writer_lock = 123;\n50  \n51    let mut lock = reader.lock.lock();\n52    match lock.poll(&mut cx).unwrap() {\n53      Async::Ready(_) => {\n54        panic!(\"The lock should not be lockable since writer has \n          already locked it!\")\n55      }\n56      _ => println!(\"Couldn't lock with reader since writer has \n        already initiated the lock\"),\n57    };\n58  \n59    let writer = writer_lock.unlock();\n60  \n61    let reader_lock = match lock.poll(&mut cx).unwrap() {\n62      Async::Ready(t) => t,\n63      _ => panic!(\"We should be able to lock with reader\"),\n64    };\n65  \n66    println!(\"The new value for the lock is: {}\", *reader_lock);\n67  \n68    let reader = reader_lock.unlock();\n69    let reunited_value = reader.reunite(writer).unwrap();\n70  \n71    println!(\"After reuniting our locks, the final value is \n      still: {}\",\n72         reunited_value);\n73  }\n```"]