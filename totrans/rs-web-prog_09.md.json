["```rs\n#[cfg(test)]\nmod base_tests {\n    use super::Base;\n    use super::TaskStatus;\n    #[test]\n    fn new() {\n        let expected_title = String::from(\"test title\");\n        let expected_status = TaskStatus::DONE;\n        let new_base_struct = Base{\n            title: expected_title.clone(),\n            status: TaskStatus::DONE\n        };\n        assert_eq!(expected_title,\n                   new_base_struct.title);\n        assert_eq!(expected_status,\n                   new_base_struct.status);\n    }\n}\n```", "```rs\nassert_eq!(expected_status, new_base_struct.status);\n```", "```rs\n#[derive(Clone, Eq, Debug)]\npub enum TaskStatus {\n    DONE,\n    PENDING\n}\n```", "```rs\nimpl PartialEq for TaskStatus {\n    fn eq(&self, other: &Self) -> bool {\n        match self {\n            TaskStatus::DONE => {\n                match other {\n                    &TaskStatus::DONE => return true,\n                    &TaskStatus::PENDING => false\n                }\n            },\n            TaskStatus::PENDING => {\n                match other {\n                    &TaskStatus::DONE => return false,\n                    &TaskStatus::PENDING => true\n                }\n            }\n        }\n    }\n}\n```", "```rs\nfatal runtime error: stack overflow\n```", "```rs\ncargo test to_do::structs::base\n```", "```rs\nrunning 1 test\ntest to_do::structs::base::base_tests::new ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0\nfiltered out; finished in 0.00s\n```", "```rs\n#[cfg(test)]\nmod done_tests {\n    use super::Done;\n    use super::TaskStatus;\n    #[test]\n    fn new() {\n        let new_base_struct = Done::new(\"test title\");\n        assert_eq!(String::from(\"test title\"),\n                   new_base_struct.super_struct.title);\n        assert_eq!(TaskStatus::DONE,\n                   new_base_struct.super_struct.status);\n    }\n}\n```", "```rs\ncargo test\n```", "```rs\nrunning 2 tests\ntest to_do::structs::base::base_tests::new ... ok\ntest to_do::structs::done::done_tests::new ... ok\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0\nmeasured; 0 filtered out; finished in 0.00s\n```", "```rs\nimpl Config {\n    // existing function reading from file\n    #[cfg(not(test))]\n    pub fn new() -> Config {\n        . . .\n    }\n    // new function for testing\n    #[cfg(test)]\n    pub fn new() -> Config {\n        . . .\n    }\n}\n```", "```rs\nlet mut map = HashMap::new();\nmap.insert(String::from(\"DB_URL\"),\n           serde_yaml::from_str(\n           \"postgres://username:password@localhost:5433/\n           to_do\").unwrap());\nmap.insert(String::from(\"SECRET_KEY\"),\n           serde_yaml::from_str(\"secret\").unwrap());\nmap.insert(String::from(\"EXPIRE_MINUTES\"),\n           serde_yaml::from_str(\"120\").unwrap());\nmap.insert(String::from(\"REDIS_URL\"),\n           serde_yaml::from_str(\"redis://127.0.0.1/\")\n           .unwrap());\nreturn Config {map}\n```", "```rs\n#[cfg(test)]\nmod jwt_tests {\n    use std::str::FromStr;\n    use super::{JwToken, Config};\n    use actix_web::{HttpRequest, HttpResponse,\n                    test::TestRequest, web, App};\n    use actix_web::http::header::{HeaderValue,\n                                  HeaderName, ContentType};\n    use actix_web::test::{init_service, call_service};\n    use actix_web;\n    use serde_json::json;\n    use serde::{Deserialize, Serialize};\n    #[derive(Debug, Serialize, Deserialize)]\n    pub struct ResponseFromTest {\n        pub user_id: i32,\n        pub exp_minutes: i32\n    }\n    . . .\n}\n```", "```rs\n#[cfg(test)]\nmod jwt_tests {\n    . . .\n    #[test]\n    fn get_key() {\n        . . .\n    }\n    #[test]\n    fn get_exp() {\n        . . .\n    }\n    #[test]\n    fn decode_incorrect_token() {\n        . . .\n    }\n    #[test]\n    fn encode_decode() {\n        . . .\n    }\n    async fn test_handler(token: JwToken,\n                          _: HttpRequest) -> HttpResponse {\n        . . .\n    }\n    #[actix_web::test]\n    async fn test_no_token_request() {\n        . . .\n    }\n    #[actix_web::test]\n    async fn test_passing_token_request() {\n        . . .\n    }\n    #[actix_web::test]\n    async fn test_false_token_request() {\n        . . .\n    }\n}\n```", "```rs\n#[test]\nfn get_key() {\n    assert_eq!(String::from(\"secret\"), JwToken::get_key());\n}\n```", "```rs\n#[test]\nfn get_exp() {\n    let config = Config::new();\n    let minutes = config.map.get(\"EXPIRE_MINUTES\")\n                      .unwrap().as_i64().unwrap();\n    assert_eq!(120, minutes);\n}\n```", "```rs\n#[test]\nfn decode_incorrect_token() {\n    let encoded_token: String =\n        String::from(\"invalid_token\");\n    match JwToken::from_token(encoded_token) {\n        Err(message) => assert_eq!(\"InvalidToken\",\n                                    message),\n        _ => panic!(\n            \"Incorrect token should not be able to be\n             encoded\"\n             )\n    }\n}\n```", "```rs\n#[test]\nfn encode_decode() {\n    let test_token = JwToken::new(5);\n    let encoded_token = test_token.encode();\n    let new_token =\n        JwToken::from_token(encoded_token).unwrap();\n    assert_eq!(5, new_token.user_id);\n}\n```", "```rs\nasync fn test_handler(token: JwToken,\n                      _: HttpRequest) -> HttpResponse {\n    return HttpResponse::Ok().json(json!({\"user_id\":\n                                           token.user_id,\n                                          \"exp_minutes\":\n                                           60}))\n}\n```", "```rs\n#[actix_web::test]\nasync fn test_no_token_request() {\n    let app = init_service(App::new().route(\"/\", web::get()\n                               .to(test_handler))).await;\n    let req = TestRequest::default()\n        .insert_header(ContentType::plaintext())\n        .to_request();\n    let resp = call_service(&app, req).await;\n    assert_eq!(\"401\", resp.status().as_str());\n}\n```", "```rs\n#[actix_web::test]\nasync fn test_passing_token_request() {\n    let test_token = JwToken::new(5);\n    let encoded_token = test_token.encode();\n    let app = init_service(App::new().route(\"/\", web::get()\n                               .to(test_handler))).await;\n    let mut req = TestRequest::default()\n        .insert_header(ContentType::plaintext())\n        .to_request();\n    let header_name = HeaderName::from_str(\"token\")\n                                            .unwrap();\n    let header_value = HeaderValue::from_str(encoded_token\n                                             .as_str())\n                                             .unwrap();\n    req.headers_mut().insert(header_name, header_value);\n    let resp: ResponseFromTest = actix_web::test::\n        call_and_read_body_json(&app, req).await;\n    assert_eq!(5, resp.user_id);\n}\n```", "```rs\n#[actix_web::test]\nasync fn test_false_token_request() {\n    let app = init_service(App::new().route(\"/\", web::get()\n                  .to(test_handler))).await;\n    let mut req = TestRequest::default()\n        .insert_header(ContentType::plaintext())\n        .to_request();\n    let header_name = HeaderName::from_str(\"token\")\n        .unwrap();\n    let header_value = HeaderValue::from_str(\"test\")\n        .unwrap();\n    req.headers_mut().insert(header_name, header_value);\n    let resp = call_service(&app, req).await;\n    assert_eq!(\"401\", resp.status().as_str());\n}\n```", "```rs\nrunning 9 tests\ntest to_do::structs::base::base_tests::new ... ok\ntest to_do::structs::done::done_tests::new ... ok\ntest to_do::structs::pending::pending_tests::new ... ok\ntest jwt::jwt_tests::get_key ... ok\ntest jwt::jwt_tests::decode_incorrect_token ... ok\ntest jwt::jwt_tests::encode_decode ... ok\ntest jwt::jwt_tests::test_no_token_request ... ok\ntest jwt::jwt_tests::test_false_token_request ... ok\ntest jwt::jwt_tests::test_passing_token_request ... ok\ntest result: ok. 9 passed; 0 failed; 0 ignored;\n0 measured; 0 filtered out; finished in 0.00s\n```", "```rs\n    {\n    ```", "```rs\n        \"name\": \"maxwell\",\n    ```", "```rs\n        \"email\": \"maxwellflitton@gmail.com\",\n    ```", "```rs\n        \"password\": \"test\"\n    ```", "```rs\n    }\n    ```", "```rs\n    {\n    ```", "```rs\n        \"username\": \"maxwell\",\n    ```", "```rs\n        \"password\": \"test\"\n    ```", "```rs\n    }\n    ```", "```rs\nvar result = pm.response.json()\n```", "```rs\n    pm.test(\"response is ok\", function () {\n    ```", "```rs\n        pm.response.to.have.status(200);\n    ```", "```rs\n    });\n    ```", "```rs\n    pm.test(\"returns one pending item\", function(){\n    ```", "```rs\n        if (result[\"pending_items\"].length !== 1){\n    ```", "```rs\n            throw new Error(\n    ```", "```rs\n            \"returns the wrong number of pending items\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\n    pm.test(\"Pending item has the correct title\", function(){\n    ```", "```rs\n        if (result[\"pending_items\"][0][\"title\"] !==\n    ```", "```rs\n            \"washing\"){\n    ```", "```rs\n            throw new Error(\n    ```", "```rs\n            \"title of the pending item is not 'washing'\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\n    pm.test(\"Pending item has the correct status\",\n    ```", "```rs\n             function()\n    ```", "```rs\n        {\n    ```", "```rs\n            if (result[\"pending_items\"][0][\"status\"] !==\n    ```", "```rs\n                \"PENDING\"){\n    ```", "```rs\n                throw new Error(\n    ```", "```rs\n                \"status of the pending item is not\n    ```", "```rs\n                    'pending'\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\n    pm.test(\"returns zero done items\", function(){\n    ```", "```rs\n        if (result[\"done_items\"].length !== 0){\n    ```", "```rs\n            throw new Error(\n    ```", "```rs\n            \"returns the wrong number of done items\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\n    pm.test(\"checking pending item count\", function(){\n    ```", "```rs\n        if (result[\"pending_item_count\"] !== 1){\n    ```", "```rs\n            throw new Error(\n    ```", "```rs\n            \"pending_item_count needs to be one\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\n    pm.test(\"checking done item count\", function(){\n    ```", "```rs\n        if (result[\"done_item_count\"] !== 0){\n    ```", "```rs\n            throw new Error(\n    ```", "```rs\n            \"done_item_count needs to be zero\");\n    ```", "```rs\n        }\n    ```", "```rs\n    })\n    ```", "```rs\nvar result = pm.response.json()\npm.test(\"response is ok\", function () {\n    pm.response.to.have.status(200);\n});\npm.test(\"returns two pending item\", function(){\n    if (result[\"pending_items\"].length !== 2){\n        throw new Error(\n        \"returns the wrong number of pending items\");\n    }\n})\npm.test(\"Pending item has the correct title\", function(){\n    if (result[\"pending_items\"][0][\"title\"] !== \"washing\"){\n        throw new Error(\n        \"title of the pending item is not 'washing'\");\n    }\n})\npm.test(\"Pending item has the correct status\", function(){\n    if (result[\"pending_items\"][0][\"status\"] !==\n        \"PENDING\"){\n        throw new Error(\n        \"status of the pending item is not 'pending'\");\n    }\n})\npm.test(\"Pending item has the correct title\", function(){\n    if (result[\"pending_items\"][1][\"title\"] !== \"cooking\"){\n        throw new Error(\n        \"title of the pending item is not 'cooking'\");\n    }\n})\npm.test(\"Pending item has the correct status\", function(){\n    if (result[\"pending_items\"][1][\"status\"] !==\n        \"PENDING\"){\n        throw new Error(\n        \"status of the pending item is not 'pending'\");\n    }\n})\npm.test(\"returns zero done items\", function(){\n    if (result[\"done_items\"].length !== 0){\n        throw new Error(\n        \"returns the wrong number of done items\");\n    }\n})\npm.test(\"checking pending item count\", function(){\n    if (result[\"pending_item_count\"].length === 1){\n        throw new Error(\n        \"pending_item_count needs to be one\");\n    }\n})\npm.test(\"checking done item count\", function(){\n    if (result[\"done_item_count\"].length === 0){\n        throw new Error(\n        \"done_item_count needs to be zero\");\n    }\n})\n```", "```rs\n\"info\": {\n    \"_postman_id\": \"bab28260-c096-49b9-81e6-b56fc5f60e9d\",\n    \"name\": \"to_do_items\",\n    \"schema\": \"https://schema.getpostman.com\n    /json/collection/v2.1.0/collection.json\",\n    \"_exporter_id\": \"3356974\"\n},\n```", "```rs\n\"item\": [\n    {\n        \"name\": \"1_create\",\n        \"event\": [\n            {\n                \"listen\": \"test\",\n                \"script\": {\n                    \"exec\": [\n                        \"var result = pm.response.json()\",\n                        . . .\n                    ],\n                    \"type\": \"text/javascript\"\n                }\n            }\n        ],\n        \"request\": {\n            \"method\": \"POST\",\n            \"header\": [\n                {\n                    \"key\": \"token\",\n                    \"value\": \"eyJhbGciOiJIUzI1NiJ9\n                    .eyJ1c2VyX2lkIjo2fQ.\n                    uVo7u877IT2GEMpB_gxVtxhMAYAJD8\n                    W_XiUoNvR7_iM\",\n                    \"type\": \"text\",\n                    \"disabled\": true\n                }\n            ],\n            \"url\": {\n                \"raw\": \"http://127.0.0.1:8000/\n                v1/item/create/washing\",\n                \"protocol\": \"http\",\n                \"host\": [\"127\", \"0\", \"0\", \"1\"],\n                \"port\": \"8000\",\n                \"path\": [\"v1\", \"item\", \"create\", \"washing\"]\n            },\n            \"description\": \"create a to-do item,\n            and then check the\n            return to see if it is stored correctly \"\n        },\n        \"response\": []\n    },\n```", "```rs\nnpm install -g newman\n```", "```rs\n{\n  \"name\": \"newman testing\",\n  \"description\": \"\",\n  \"version\": \"0.1.0\",\n  \"scripts\": {\n    \"test\": \"newman run to_do_items.\n             postman_collection.json\"\n  },\n  \"dependencies\": {\n    \"newman\": \"5.3.2\"\n  }\n}\n```", "```rs\nnpm install\n```", "```rs\nnpm run test\n```", "```rs\nnewman run to_do_items.postman_collection.json\n```", "```rs\n→ 1_create\n    POST http://127.0.0.1:8000/v1/item/create/washing\n    [200 OK, 226B, 115ms]\n    ✓ response is ok\n    ✓ returns one pending item\n    ✓ Pending item has the correct title\n    ✓ Pending item has the correct status\n    ✓ returns zero done items\n    ✓ checking pending item count\n    ✓ checking done item count\n```", "```rs\n#!/bin/bash\n# move to directory of the project\nSCRIPTPATH=\"$( cd \"$(dirname \"$0\")\" ; pwd -P )\"\ncd $SCRIPTPATH\ncd ..\n```", "```rs\n# spin up docker and hold script until accepting connections\ndocker-compose up -d\nuntil pg_isready -h localhost -p 5433 -U username\ndo\n  echo \"Waiting for postgres\"\n  sleep 2;\ndone\n```", "```rs\ncargo build\ncargo test\n```", "```rs\n# run server in background\ncargo run config.yml &\nSERVER_PID=$!\nsleep 5\n```", "```rs\ndiesel migration run\n```", "```rs\n# create the user\ncurl --location --request POST 'http://localhost:8000/v1/user/create' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"maxwell\",\n    \"email\": \"maxwellflitton@gmail.com\",\n    \"password\": \"test\"\n}'\n```", "```rs\n# login getting a fresh token\necho $(curl --location --request GET 'http://localhost:8000/v1/auth/login' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"username\": \"maxwell\",\n    \"password\": \"test\"\n}') > ./fresh_token.json\n```", "```rs\nTOKEN=$(jq '.token' fresh_token.json)\njq '.auth.apikey[0].value = '\"$TOKEN\"''\nto_do_items.postman_collection.json > test_newman.json\nnewman run test_newman.json\n```", "```rs\nrm ./test_newman.json\nrm ./fresh_token.json\n# shut down rust server\nkill $SERVER_PID\ncd ..\ndocker-compose down\n```", "```rs\nsudo chmod +x ./run_test_pipeline.sh\n```", "```rs\nsh run_test_pipeline.sh\n```", "```rs\nsh run_test_pipeline.sh > full_log.txt\n```"]