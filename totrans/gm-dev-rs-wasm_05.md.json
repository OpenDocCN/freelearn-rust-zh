["```rs\nasync fn doesnt_compile() -> Result<(), Box<dyn std::error::Error>> {\n    let window = web_sys::window()?;\n    let json = fetch_json(\"rhb.json\").await?;\n    ...\n}\n```", "```rs\nmacro_rules! log {\n    ( $( $t:tt )* ) => {\n        web_sys::console::log_1(&format!( $( $t )*\n          ).into());\n    }\n}\n```", "```rs\n#[macro_use]\nmod browser;\n```", "```rs\n#[wasm_bindgen(start)]\npub fn main_js() -> Result<(), JsValue> {\n    console_error_panic_hook::set_once();\n    let window = web_sys::window().unwrap();\n    let document = window.document().unwrap();\n```", "```rs\npub fn window() -> Result<Window> {}\n```", "```rs\nuse web_sys::Window;\n```", "```rs\npub fn window() -> Result<Window> {\n    web_sys::window().unwrap()\n}\n```", "```rs\npub fn window() -> Result<Window> {\n    web_sys::window().ok_or_else(|| anyhow!(\"No Window Found\"))\n}\n```", "```rs\nlet window = browser::window().expect(\"No Window Found\");\nlet document = window.document().unwrap();\n```", "```rs\npub fn document() -> Result<Document> {\n    window()?.document().ok_or_else(|| anyhow!\n        (\"No Document Found\"))\n}\n```", "```rs\npub fn main_js() -> Result<(), JsValue> {\n    console_error_panic_hook::set_once();\nlet document = browser::document().expect(\"No Document Found\");\n...\n```", "```rs\nlet interval_callback = Closure::wrap(Box::new(move || {\n    ...\n}) as Box<dyn FnMut()>);\nbrowser::window()\n    .unwrap()\n    .set_interval_with_callback_and_timeout_and_arguments_0(\n        interval_callback.as_ref().unchecked_ref(),\n        50,\n    );\ninterval_callback.forget();\n```", "```rs\npub fn canvas() -> Result<HtmlCanvasElement> {\n    document()?\n        .get_element_by_id(\"canvas\")\n        .ok_or_else(|| anyhow!\n            (\"No Canvas Element found with ID 'canvas'\"))?\n        .dyn_into::<web_sys::HtmlCanvasElement>()\n        .map_err(|element| anyhow!(\"Error converting {:#?}\n          to HtmlCanvasElement\", element))\n}\n```", "```rs\npub fn context() -> Result<CanvasRenderingContext2d> {\n    canvas()?\n        .get_context(\"2d\")\n        .map_err(|js_value| anyhow!(\"Error getting 2d \n          context {:#?}\", js_value))?\n        .ok_or_else(|| anyhow!(\"No 2d context found\"))?\n        .dyn_into::<web_sys::CanvasRenderingContext2d>()\n        .map_err(|element| {\n            anyhow!( \"Error converting {:#?} to\n                      CanvasRenderingContext2d\",\n                      element\n            )\n        })\n}\n```", "```rs\npub fn spawn_local<F>(future: F)\nwhere\n    F: Future<Output = ()> + 'static,\n{\n    wasm_bindgen_futures::spawn_local(future);\n}\n```", "```rs\npub async fn fetch_with_str(resource: &str) ->\n  Result<JsValue> {\n    JsFuture::from(window()?.fetch_with_str(resource))\n        .await\n        .map_err(|err| anyhow!(\"error fetching {:#?}\", \n                                err))\n}\npub async fn fetch_json(json_path: &str) -> Result<JsValue> {\n    let resp_value = fetch_with_str(json_path).await?;\n    let resp: Response = resp_value\n        .dyn_into()\n        .map_err(|element| anyhow!(\"Error converting {:#?}\n           to Response\", element))?;\n    JsFuture::from(\n        resp.json()\n            .map_err(|err| anyhow!(\"Could not get JSON from \n              response {:#?}\", err))?,\n    )\n    .await\n    .map_err(|err| anyhow!(\"error fetching JSON {:#?}\", err))\n}\n```", "```rs\n#[wasm_bindgen(start)]\npub fn main_js() -> Result<(), JsValue> {\n    console_error_panic_hook::set_once();\n    let context = browser::context().expect(\"Could not get \n      browser context\");\n    browser::spawn_local(async move {\n        let sheet: Sheet = browser::fetch_json(\"rhb.json\")\n            .await\n            .expect(\"Could not fetch rhb.json\")\n            .into_serde()\n            .expect(\"Could not convert rhb.json into a \n                     Sheet structure\");\n        let image =\n          web_sys::HtmlImageElement::new().unwrap();\n...\n```", "```rs\nlet image = web_sys::HtmlImageElement::new().unwrap();\nlet (success_tx, success_rx) =\n   futures::channel::oneshot::channel::<Result<(),JsValue>>();\nlet success_tx = Rc::new(Mutex::new(Some(success_tx)));\nlet error_tx = Rc::clone(&success_tx);\nlet callback = Closure::once(Box::new(move || {\n    if let Some(success_tx) = \n      success_tx.lock().ok().and_then(|mut opt| opt.take())\n    {\n        success_tx.send(Ok(()));\n    }\n}));\nlet error_callback = Closure::once(Box::new(move |err| {\n    if let Some(error_tx) = \n      error_tx.lock().ok().and_then(|mut opt| opt.take()) {\n        error_tx.send(Err(err));\n    }\n}));\nimage.set_onload(Some(callback.as_ref().unchecked_ref()));\nimage.set_onload(Some(error_callback.as_ref().unchecked_ref()));\nimage.set_src(\"rhb.png\");\nsuccess_rx.await;\n```", "```rs\npub fn new_image() -> Result<HtmlImageElement> {\n    HtmlImageElement::new().map_err(|err| anyhow!(\"Could \n      not create HtmlImageElement: {:#?}\", err))\n}\npub fn closure_once<F, A, R>(fn_once: F) ->\n  Closure<F::FnMut>\nwhere\n    F: 'static + WasmClosureFnOnce<A, R>,\n{\n    Closure::once(fn_once)\n}\n```", "```rs\npub async fn load_image(source: &str) -> Result<HtmlImageElement> {\n    let image = browser::new_image()?;\n    let (complete_tx, complete_rx) = \n      channel::<Result<()>>();\n    let success_tx = \n      Rc::new(Mutex::new(Some(complete_tx)));\n    let error_tx = Rc::clone(&success_tx);\n    let success_callback = browser::closure_once(move || {\n        if let Some(success_tx) =\n          success_tx.lock().ok().and_then(\n          |mut opt| opt.take()) {\n            success_tx.send(Ok(()));\n        }\n    });\n    let error_callback: Closure<dyn FnMut(JsValue)> = \n      browser::closure_once(move |err| {\n        if let Some(error_tx) =\n          error_tx.lock().ok().and_then(\n          |mut opt| opt.take()) {\n            error_tx.send(Err(anyhow!(\"Error Loading Image:\n              {:#?}\", err)));\n        }\n    });\n    image.set_onload(Some(\n      success_callback.as_ref().unchecked_ref()));\n    image.set_onerror(Some(\n      error_callback.as_ref().unchecked_ref()));\n    image.set_src(source);\n    complete_rx.await??;\n    Ok(image)\n}\n```", "```rs\nlet sheet: Sheet = json\n    .into_serde()\n    .expect(\"Could not convert rhb.json into a Sheet \n             structure\");\nlet image = engine::load_image(\"rhb.png\")\n    .await\n    .expect(\"Could not load rhb.png\");\nlet mut frame = -1;\n```", "```rs\nwhile(!quit) {\n    handleInput()\n    updateGame()\n    drawGame()\n}\n```", "```rs\nfunction animate(now) {\n    draw(now);\n    requestAnimationFrame(animate);\n}\nrequestAnimationFrame(animate);\n```", "```rs\npub fn request_animation_frame(callback: &Function) -> \n  Result<i32> {\n    window()?\n        .request_animation_frame(callback)\n        .map_err(|err| anyhow!(\"Cannot request animation\n                                frame {:#?}\", err))\n}\n```", "```rs\npub fn request_animation_frame(callback: &Closure<\n  dyn FnMut(f64)>) -> Result<i32> {\n    window()?\n        .request_animation_frame(callback.as_ref().unchecked_ref())\n        .map_err(|err| anyhow!(\"Cannot request animation\n                                frame {:#?}\", err))\n}\n```", "```rs\npub type LoopClosure = Closure<dyn FnMut(f64)>;\npub fn request_animation_frame(callback: &LoopClosure) ->\n  Result<i32> {\n// ...\n```", "```rs\npub fn animate(perf: f64) {\n    browser::request_animation_frame(animate);\n}\n```", "```rs\npub fn create_raf_closure(f: impl FnMut(f64) + 'static) ->\n  LoopClosure {\n    closure_wrap(Box::new(f))\n}\n```", "```rs\npub fn closure_wrap<T: WasmClosure + ?Sized>(data: Box<T>)\n  -> Closure<T> {\n    Closure::wrap(data)\n}\n```", "```rs\nlet animate = create_raf_closure(move |perf| {\n    request_animation_frame(animate);\n});\nrequest_animation_frame(animate);\n```", "```rs\nlet f = Rc<RefCell<Option<LoopClosure>>> =  \n  Rc::new(RefCell::new(None));\nlet g = f.clone();\nlet animate = Some(create_raf_closure(move |perf: f64| {\n    request_animation_frame(f.borrow().as_ref().unwrap());\n});\n*g.borrow_mut() = animate;\nrequest_animation_frame(g.borrow().as_ref().unwrap());\n```", "```rs\npub trait Game {\n    fn update(&mut self);\n    fn draw(&self, context: &CanvasRenderingContext2d);\n}\n```", "```rs\npub struct GameLoop;\ntype SharedLoopClosure = Rc<RefCell<Option<LoopClosure>>>;\nimpl GameLoop {\n    pub async fn start(mut game: impl Game + 'static) -> \n      Result<()> {\n        let f: SharedLoopClosure =\n          Rc::new(RefCell::new(None));\n        let g = f.clone();\n        *g.borrow_mut() = Some(\n          browser::create_raf_closure(move |perf: f64| {\n            game.update();\n            game.draw(&browser::context().expect(\"Context\n              should exist\"));\n            browser::request_animation_frame(\n              f.borrow().as_ref().unwrap());\n        }));\n        browser::request_animation_frame(\n            g.borrow()\n                .as_ref()\n                .ok_or_else(|| anyhow!(\"GameLoop: Loop is \n                                        None\"))?,\n        )?;\n        Ok(())\n    }\n}\n```", "```rs\nconst FRAME_SIZE: f32 = 1.0 / 60.0 * 1000.0;\npub struct GameLoop {\n    last_frame: f64,\n    accumulated_delta: f32,\n}\n```", "```rs\nimpl GameLoop {\n    pub async fn start(mut game: impl Game + 'static) ->\n      Result<()> {\n        let mut game_loop = GameLoop {\n            last_frame: browser::now()?,\n            accumulated_delta: 0.0,\n        };\n        ...\n```", "```rs\npub fn now() -> Result<f64> {\n    Ok(window()?\n        .performance()\n        .ok_or_else(|| anyhow!\n            (\"Performance object not found\"))?\n        .now())\n}\n```", "```rs\n*g.borrow_mut() = Some(browser::create_raf_closure(move \n  |perf: f64| {\n    game_loop.accumulated_delta += (\n      perf - game_loop.last_frame) as f32;\n    while game_loop.accumulated_delta > FRAME_SIZE {\n        game.update();\n        game_loop.accumulated_delta -= FRAME_SIZE;\n    }\n    game_loop.last_frame = perf;\n    game.draw(&browser::context().expect(\"Context should\n      exist\"));\n```", "```rs\npub trait Game {\n    async fn initialize(&self) -> Result<Box<dyn Game>>;\n    fn update(&mut self);\n    fn draw(&self, context: &Renderer);\n}\n```", "```rs\n#[async_trait(?Send)]\npub trait Game {\n```", "```rs\nimpl GameLoop {\n    pub async fn start(game: impl Game + 'static) ->\n      Result<()> {\n        let mut game = game.initialize().await?;\n        ....\n```", "```rs\npub struct Renderer {\n    context: CanvasRenderingContext2d,\n}\n```", "```rs\nimpl Renderer {\n    pub fn clear(&self, rect: &Rect) {\n        self.context.clear_rect(\n            rect.x.into(),\n            rect.y.into(),\n            rect.width.into(),\n            rect.height.into(),\n        );\n    }\n    pub fn draw_image(&self, image: &HtmlImageElement,\n      frame: &Rect, destination: &Rect) {\n        self.context\n            .draw_image_with_html_image_element_and_sw_and_sh_                and_dx_and_dy_and_dw_and_dh(\n                &image,\n                frame.x.into(),\n                frame.y.into(),\n                frame.width.into(),\n                frame.height.into(),\n                destination.x.into(),\n                destination.y.into(),\n                destination.width.into(),\n                destination.height.into(),\n            )\n            .expect(\"Drawing is throwing exceptions!\n                     Unrecoverable error.\");\n    }\n}\n```", "```rs\npub struct Rect {\n    pub x: f32,\n    pub y: f32,\n    pub width: f32,\n    pub height: f32,\n}\n```", "```rs\n#[async_trait(?Send)]\npub trait Game {\n    ...\n    fn draw(&self, renderer: &Renderer);\n}\n```", "```rs\nlet mut game_loop = GameLoop {\n    last_frame: browser::now()?,\n    accumulated_delta: 0.0,\n};\nlet renderer = Renderer {\n    context: browser::context()?,\n};\n...\n*g.borrow_mut() = Some(browser::create_raf_closure(\n  move |perf: f64| {\n    ...\n    game.draw(&renderer);\n    browser::request_animation_frame(f.borrow().as_ref().        unwrap());\n}));\n```", "```rs\nuse crate::engine::{Game, Renderer};\nuse anyhow::Result;\nuse async_trait::async_trait;\npub struct WalkTheDog;\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        Ok(Box::new(WalkTheDog {}))\n    }\n    fn update(&mut self) {}\n    fn draw(&self, renderer: &Renderer) {}\n}\n```", "```rs\nfn draw(&self, renderer: &Renderer) {\n    let frame_name = format!(\"Run ({}).png\", self.frame +\n                              1);\n    let sprite = self.sheet.frames.get(&frame_name).expect(\n      \"Cell not found\");\n    renderer.clear(Rect {\n        x: 0.0,\n        y: 0.0,\n        width: 600.0,\n        height: 600.0,\n    });\n    renderer.draw_image(\n        &self.image,\n        Rect {\n            x: sprite.frame.x.into(),\n            y: sprite.frame.y.into(),\n            width: sprite.frame.w.into(),\n            height: sprite.frame.h.into(),\n        },\n        Rect {\n            x: 300.0,\n            y: 300.0,\n            width: sprite.frame.w.into(),\n            height: sprite.frame.h.into(),\n        },\n    );\n}\n```", "```rs\n#[derive(Deserialize)]\nstruct SheetRect {\n    x: i16,\n    y: i16,\n    w: i16,\n    h: i16,\n}\n#[derive(Deserialize)]\nstruct Cell {\n    frame: SheetRect,\n}\n#[derive(Deserialize)]\npub struct Sheet {\n    frames: HashMap<String, Cell>,\n}\npub struct WalkTheDog {\n    image: HtmlImageElement,\n    sheet: Sheet,\n    frame: u8,\n}\n```", "```rs\npub struct WalkTheDog {\n    image: Option<HtmlImageElement>,\n    sheet: Option<Sheet>,\n    frame: u8,\n}\n```", "```rs\nfn draw(&self, renderer: &Renderer) {\n    let frame_name = format!(\"Run ({}).png\", self.frame + 1);\n    let sprite = self\n        .sheet\n        .as_ref()\n        .and_then(|sheet| sheet.frames.get(&frame_name))\n        .expect(\"Cell not found\");\n    renderer.clear(&Rect {\n        x: 0.0,\n        y: 0.0,\n        width: 600.0,\n        height: 600.0,\n    });\n    self.image.as_ref().map(|image| {\n        renderer.draw_image(\n            &image,\n            &Rect {\n                x: sprite.frame.x.into(),\n                y: sprite.frame.y.into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n            &Rect {\n                x: 300.0,\n                y: 300.0,\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n        );\n    });\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        let sheet: Sheet = browser::fetch_json(\"rhb.json\")\n            .await\n            .expect(\"Could not fetch rhb.json\")\n            .into_serde()\n            .expect(\"Could not convert rhb.json into a \n                     Sheet structure\");\n        let image = engine::load_image(\"rhb.png\")\n            .await\n            .expect(\"Could not load rhb.png\");\n        Ok(Box::new(WalkTheDog {\n            image: Some(image),\n            sheet: Some(sheet),\n            frame: self.frame,\n        }))\n    }\n    ...\n```", "```rs\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        let sheet = browser::fetch_json(\n          \"rhb.json\").await?.into_serde()?;\n        let image = \n          Some(engine::load_image(\"rhb.png\").await?);\n        Ok(Box::new(WalkTheDog {\n            image,\n            sheet,\n            frame: self.frame,\n        }))\n    }\n```", "```rs\nfn update(&mut self) {\n    if self.frame < 23 {\n        self.frame += 1;\n    } else {\n        self.frame = 0;\n    }\n}\n```", "```rs\nfn draw(&self, renderer: &Renderer) {\n    let current_sprite = (self.frame / 3) + 1;\n    let frame_name = format!(\"Run ({}).png\", \n      current_sprite);\n    ...\n```", "```rs\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog {\n            image: None,\n            sheet: None,\n            frame: 0,\n        }\n    }\n}\n```", "```rs\n#[wasm_bindgen(start)]\npub fn main_js() -> Result<(), JsValue> {\n    console_error_panic_hook::set_once();\n    browser::spawn_local(async move {\n        let game = WalkTheDog::new();\n        GameLoop::start(game)\n            .await\n            .expect(\"Could not start game loop\");\n    });\n    Ok(())\n}\n```", "```rs\nfn prepare_input() {\n    let onkeydown = browser::closure_wrap(\n      Box::new(move |keycode: web_sys::KeyboardEvent| {})\n        as Box<dyn FnMut(web_sys::KeyboardEvent)>);\n    let onkeyup = browser::closure_wrap(Box::new(\n      move |keycode: web_sys::KeyboardEvent| {})\n        as Box<dyn FnMut(web_sys::KeyboardEvent)>);\n    browser::canvas()\n        .unwrap()\n        .set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));\n    browser::canvas()\n        .unwrap()\n        .set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));\n    onkeydown.forget();\n    onkeyup.forget();\n}\n```", "```rs\nfn prepare_input() -> Result<UnboundedReceiver<KeyPress>> {\n    let (keydown_sender, keyevent_receiver) = unbounded();\n    let keydown_sender = Rc::new(RefCell::new(keydown_sender));\n    let keyup_sender = Rc::clone(&keydown_sender);\n    let onkeydown = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {\n        keydown_sender\n            .borrow_mut()\n            .start_send(KeyPress::KeyDown(keycode));\n    }) as Box<dyn FnMut(web_sys::KeyboardEvent)>);\n    let onkeyup = browser::closure_wrap(Box::new(move |keycode: web_sys::KeyboardEvent| {\n        keyup_sender\n            .borrow_mut()\n            .start_send(KeyPress::KeyUp(keycode));\n    }) as Box<dyn FnMut(web_sys::KeyboardEvent)>);\n    browser::window()?.set_onkeydown(Some(onkeydown.as_ref().unchecked_ref()));\n    browser::window()?.set_onkeyup(Some(onkeyup.as_ref().unchecked_ref()));\n    onkeydown.forget();\n    onkeyup.forget();\n    Ok(keyevent_receiver)\n}\n```", "```rs\nenum KeyPress {\n    KeyUp(web_sys::KeyboardEvent),\n    KeyDown(web_sys::KeyboardEvent),\n}\n```", "```rs\nfn process_input(state: &mut KeyState, keyevent_receiver: &mut UnboundedReceiver<KeyPress>) {\n    loop {\n        match keyevent_receiver.try_next() {\n            Ok(None) => break,\n            Err(_err) => break,\n            Ok(Some(evt)) => match evt {\n                KeyPress::KeyUp(evt) => state.set_released(&evt.code()),\n                KeyPress::KeyDown(evt) => state.set_pressed(&evt.code(), evt),\n            },\n        };\n    }\n}\n```", "```rs\npub struct KeyState {\n    pressed_keys: HashMap<String, web_sys::KeyboardEvent>,\n}\nimpl KeyState {\n    fn new() -> Self {\n        KeyState {\n            pressed_keys: HashMap::new(),\n        }\n    }\n    pub fn is_pressed(&self, code: &str) -> bool {\n        self.pressed_keys.contains_key(code)\n    }\n    fn set_pressed(&mut self, code: &str, event: web_sys::KeyboardEvent) {\n        self.pressed_keys.insert(code.into(), event);\n    }\n    fn set_released(&mut self, code: &str) {\n        self.pressed_keys.remove(code.into());\n    }\n}\n```", "```rs\npub async fn start(mut game: impl Game + 'static) -> Result<()> {\n    let mut keyevent_receiver = prepare_input()?;\n    game.initialize().await?;\n```", "```rs\nlet mut keystate = KeyState::new();\n*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {\n    process_input(&mut keystate, &mut keyevent_receiver);\n```", "```rs\npub trait Game {\n    ...\n    fn update(&mut self, keystate: &KeyState);\n    ...\n```", "```rs\nwhile game_loop.accumulated_delta > frame_size {\n    game.update(&keystate);\n    game_loop.accumulated_delta -= frame_size;\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n```", "```rs\npub struct WalkTheDog {\n    image: Option<HtmlImageElement>,\n    sheet: Option<Sheet>,\n    frame: u8,\n    position: Point,\n}\n```", "```rs\n#[derive(Clone, Copy)]\npub struct Point {\n    pub x: i16,\n    pub y: i16,\n}\n```", "```rs\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog {\n            image: None,\n            sheet: None,\n            frame: 0,\n            position: Point { x: 0, y: 0 },\n        }\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        let json = browser::fetch_json(\"rhb.json\").await?;\n        let sheet = json.into_serde()?;\n        let image =\n          Some(engine::load_image(\"rhb.png\").await?);\n        Ok(Box::new(WalkTheDog {\n            image,\n            sheet,\n            position: self.position,\n            frame: self.frame,\n        }))\n}\n....\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        ....\n        self.image.as_ref().map(|image| {\n            renderer.draw_image(\n                &image,\n                &Rect {\n                    x: sprite.frame.x.into(),\n                    y: sprite.frame.y.into(),\n                    width: sprite.frame.w.into(),\n                    height: sprite.frame.h.into(),\n                },\n                &Rect {\n                    x: self.position.into(),\n                    y: self.position.into(),\n                    width: sprite.frame.w.into(),\n                    height: sprite.frame.h.into(),\n                },\n            );\n        });\n    }\n}\n```", "```rs\nfn update(&mut self, keystate: &KeyState) {\n    let mut velocity = Point { x: 0, y: 0 };\n    if keystate.is_pressed(\"ArrowDown\") {\n        velocity.y += 3;\n    }\n    if keystate.is_pressed(\"ArrowUp\") {\n        velocity.y -= 3;\n    }\n    if keystate.is_pressed(\"ArrowRight\") {\n        velocity.x += 3;\n    }\n    if keystate.is_pressed(\"ArrowLeft\") {\n        velocity.x -= 3;\n    }\n```", "```rs\nif keystate.is_pressed(\"ArrowLeft\") {\n    velocity.x -= 3;\n}\nself.position.x += velocity.x;\nself.position.y += velocity.y;\n```"]