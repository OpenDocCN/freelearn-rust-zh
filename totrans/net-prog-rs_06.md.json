["```rs\n$ cargo new --bin hyper-server\n```", "```rs\n[package]\nname = \"hyper-server\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nhyper = \"0.11.7\"\nfutures = \"0.1.17\"\n```", "```rs\n// ch6/hyper-server/src/main.rs\n\nextern crate hyper;\nextern crate futures;\n\nuse std::{ thread, time };\nuse futures::future::FutureResult;\nuse hyper::{Get, StatusCode};\nuse hyper::header::ContentLength;\nuse hyper::server::{Http, Service, Request, Response};\n\n// Simulate CPU intensive work by sleeping for 200 ms\nfn heavy_work() -> String {\n    let duration = time::Duration::from_millis(200);\n    thread::sleep(duration);\n    \"done\".to_string()\n}\n\n#[derive(Clone, Copy)]\nstruct Echo;\n\nimpl Service for Echo {\n    type Request = Request;\n    type Response = Response;\n    type Error = hyper::Error;\n    type Future = FutureResult<Response, hyper::Error>;\n\n    // This method handles actually processing requests\n    // We only handle GET requests on /data and ignore everything else\n    // returning a HTTP 404\n    fn call(&self, req: Request) -> Self::Future {\n        futures::future::ok(match (req.method(), req.path()) {\n        (&Get, \"/data\") => {\n        let b = heavy_work().into_bytes();\n        Response::new()\n        .with_header(ContentLength(b.len() as u64))\n        .with_body(b)\n}\n        _ => Response::new().with_status(StatusCode::NotFound),})\n    }\n}\n\nfn main() {\n    let addr = \"0.0.0.0:3000\".parse().unwrap();\n    let server = Http::new().bind(&addr, || Ok(Echo)).unwrap();\n    server.run().unwrap();\n}\n```", "```rs\n$ curl http://127.0.0.1:3000/data\ndone$\n```", "```rs\n$ ab -n 1000 -c 100 http://127.0.0.1:3000/data\nBenchmarking 127.0.0.1 (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\nCompleted 1000 requests\nFinished 1000 requests\n\nServer Software:\nServer Hostname: 127.0.0.1\nServer Port: 3000\n\nDocument Path: /data\nDocument Length: 4 bytes\n\nConcurrency Level: 100\nTime taken for tests: 203.442 seconds\nComplete requests: 1000\nFailed requests: 0\nTotal transferred: 79000 bytes\nHTML transferred: 4000 bytes\nRequests per second: 4.92 [#/sec] (mean)\nTime per request: 20344.234 [ms] (mean)\nTime per request: 103.442 [ms] (mean, across all concurrent requests)\nTransfer rate: 0.38 [Kbytes/sec] received\n\nConnection Times (ms)\nmin mean[+/-sd] median max\nConnect: 0 2 0.7 2 3\nProcessing: 5309 20123 8061.9 20396 33029\nWaiting: 203 12923 5518.0 14220 20417\nTotal: 5311 20124 8061.9 20397 33029\n\nPercentage of the requests served within a certain time (ms)\n  50% 20397\n  66% 25808\n  75% 26490\n  80% 27263\n  90% 28373\n  95% 28568\n  98% 33029\n  99% 33029\n 100% 33029 (longest request)\n```", "```rs\n$ cargo new --bin hyper-server-faster\n```", "```rs\n[package]\nname = \"hyper-server-faster\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nhyper = \"0.11.7\"\nfutures = \"0.1.17\"\nnet2 = \"0.2.31\"\ntokio-core = \"0.1.10\"\nnum_cpus = \"1.0\"\n```", "```rs\n// ch6/hyper-server-faster/src/main.rs\n\nextern crate futures;\nextern crate hyper;\nextern crate net2;\nextern crate tokio_core;\nextern crate num_cpus;\n\nuse futures::Stream;\nuse net2::unix::UnixTcpBuilderExt;\nuse tokio_core::reactor::Core;\nuse tokio_core::net::TcpListener;\nuse std::{thread, time};\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse futures::future::FutureResult;\nuse hyper::{Get, StatusCode};\nuse hyper::header::ContentLength;\nuse hyper::server::{Http, Service, Request, Response};\n\n// Same method like last example\nfn heavy_work() -> String {\n    let duration = time::Duration::from_millis(200);\n    thread::sleep(duration);\n    \"done\".to_string()\n}\n\n#[derive(Clone, Copy)]\nstruct Echo;\n\nimpl Service for Echo {\n    type Request = Request;\n    type Response = Response;\n    type Error = hyper::Error;\n    type Future = FutureResult<Response, hyper::Error>;\n\n    fn call(&self, req: Request) -> Self::Future {\n        futures::future::ok(match (req.method(), req.path()) {\n            (&Get, \"/data\") => {\n                let b = heavy_work().into_bytes();\n                Response::new()\n                    .with_header(ContentLength(b.len() as u64))\n                    .with_body(b)\n            }\n            _ => Response::new().with_status(StatusCode::NotFound),\n        })\n    }\n}\n\n// One server instance\nfn serve(addr: &SocketAddr, protocol: &Http) {\n    let mut core = Core::new().unwrap();\n    let handle = core.handle();\n    let listener = net2::TcpBuilder::new_v4()\n        .unwrap()\n        .reuse_port(true)\n        .unwrap()\n        .bind(addr)\n        .unwrap()\n        .listen(128)\n        .unwrap();\n    let listener = TcpListener::from_listener(listener, addr,\n    &handle).unwrap();\n    core.run(listener.incoming().for_each(|(socket, addr)| {\n        protocol.bind_connection(&handle, socket, addr, Echo);\n        Ok(())\n    })).unwrap();\n}\n\n// Starts num number of serving threads\nfn start_server(num: usize, addr: &str) {\n    let addr = addr.parse().unwrap();\n\n    let protocol = Arc::new(Http::new());\n    {\n        for _ in 0..num - 1 {\n            let protocol = Arc::clone(&protocol);\n            thread::spawn(move || serve(&addr, &protocol));\n        }\n    }\n    serve(&addr, &protocol);\n}\n\nfn main() {\n    start_server(num_cpus::get(), \"0.0.0.0:3000\");\n}\n```", "```rs\n$ ab -n 1000 -c 100 http://127.0.0.1:3000/data\nBenchmarking 127.0.0.1 (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\nCompleted 1000 requests\nFinished 1000 requests\n\nServer Software:\nServer Hostname: 127.0.0.1\nServer Port: 3000\n\nDocument Path: /data\nDocument Length: 4 bytes\n\nConcurrency Level: 100\nTime taken for tests: 102.724 seconds\nComplete requests: 1000\nFailed requests: 0\nTotal transferred: 79000 bytes\nHTML transferred: 4000 bytes\nRequests per second: 9.73 [#/sec] (mean)\nTime per request: 10272.445 [ms] (mean)\nTime per request: 102.724 [ms] (mean, across all concurrent requests)\nTransfer rate: 0.75 [Kbytes/sec] received\n\nConnection Times (ms)\n              min mean[+/-sd] median max\nConnect: 0 2 1.0 2 6\nProcessing: 304 10036 1852.8 10508 10826\nWaiting: 106 5482 2989.3 5458 10316\nTotal: 305 10038 1852.7 10510 10828\n\nPercentage of the requests served within a certain time (ms)\n  50% 10510\n  66% 10569\n  75% 10685\n  80% 10686\n  90% 10756\n  95% 10828\n  98% 10828\n  99% 10828\n 100% 10828 (longest request)\n```", "```rs\n$ cargo new --bin rocket-simple\n```", "```rs\n[package]\nname = \"rocket-simple\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nrocket = \"0.3.6\"\nrocket_codegen = \"0.3.6\"\n```", "```rs\n// ch6/rocket-simple/src/main.rs\n\n#![feature(plugin)]\n#![plugin(rocket_codegen)]\n\nextern crate rocket;\n\n#[get(\"/\")]\nfn blast_off() -> &'static str {\n    \"Hello, Rocket!\"\n}\n\nfn main() {\n    rocket::ignite().mount(\"/\", routes![blast_off]).launch();\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/rocket-simple`\nConfigured for development.\n    => address: localhost\n    => port: 8000\n    => log: normal\n    => workers: 16\n    => secret key: generated\n    => limits: forms = 32KiB\n    => tls: disabled\nMounting '/':\n    => GET /\nRocket has launched from http://localhost:8000\n```", "```rs\n$ curl http://localhost:8000\nHello, Rocket!$\n```", "```rs\n$ cargo install diesel_cli --no-default-features --features sqlite\n```", "```rs\n$ DATABASE_URL=db.sql diesel migration run\n```", "```rs\n$ cargo new --bin rocket-blog\n```", "```rs\n[package]\nauthors = [\"Foo <foo@bar.com>\"]\nname = \"rocket-blog\"\nversion = \"0.1.0\"\n\n[dependencies]\nrocket = \"0.3.5\"\nrocket_codegen = \"0.3.5\"\nrocket_contrib = \"0.3.5\"\ndiesel = { version = \"0.16.0\", features = [\"sqlite\"] }\ndiesel_codegen = { version = \"0.16.0\", features = [\"sqlite\"] }\ndotenv = \"0.10.1\"\nserde = \"1.0.21\"\nserde_json = \"1.0.6\"\nserde_derive = \"1.0.21\"\nlazy_static = \"0.2.11\"\nr2d2 = \"0.7.4\"\nr2d2-diesel = \"0.16.0\"\n```", "```rs\n$ tree src/\nsrc/\n├── db.rs\n├── error.rs\n├── main.rs\n├── models.rs\n├── post.rs\n└── schema.rs\n```", "```rs\n// ch6/rocket-blog/src/db.rs\n\nuse dotenv::dotenv;\nuse std::env;\nuse diesel::sqlite::SqliteConnection;\nuse r2d2;\nuse r2d2_diesel::ConnectionManager;\nuse rocket::request::{Outcome, FromRequest};\nuse rocket::Outcome::{Success, Failure};\nuse rocket::Request;\nuse rocket::http::Status;\n\n// Statically initialize our DB pool\nlazy_static! {\n    pub static ref DB_POOL:\n    r2d2::Pool<ConnectionManager<SqliteConnection>> = {\n        dotenv().ok();\n\n        let database_url = env::var(\"DATABASE_URL\").\n        expect(\"DATABASE_URL must be set\");\n        let config = r2d2::Config::builder()\n            .pool_size(32)\n            .build();\n        let manager = ConnectionManager::\n        <SqliteConnection>::new(database_url);\n        r2d2::Pool::new(config, manager).expect(\"Failed to create\n        pool.\")\n    };\n}\n\npub struct DB(r2d2::PooledConnection<ConnectionManager<SqliteConnection>>);\n\n// Make sure DB pointers deref nicely \nimpl Deref for DB {\n    type Target = SqliteConnection;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<'a, 'r> FromRequest<'a, 'r> for DB {\n    type Error = r2d2::GetTimeout;\n    fn from_request(_: &'a Request<'r>) -> Outcome<Self, Self::Error> {\n        match DB_POOL.get() {\n            Ok(conn) => Success(DB(conn)),\n            Err(e) => Failure((Status::InternalServerError, e)),\n        }\n    }\n}\n```", "```rs\n// ch6/rocket-blog/src/schema.rs\n\ninfer_schema!(\"dotenv:DATABASE_URL\");\n```", "```rs\n// ch6/rocket-blog/src/models.rs\n\nuse super::schema::posts;\nuse rocket::{Request, Data};\nuse rocket::data::{self, FromData};\nuse rocket::http::Status;\nuse rocket::Outcome::*;\nuse serde_json;\n\n// Represents a blog post in the database\n#[derive(Queryable)]\n#[derive(Serialize,Deserialize)]\npub struct Post {\n    pub id: i32,\n    pub title: String,\n    pub body: String,\n    pub pinned: bool,\n}\n\n// Represents a blog post as incoming request data\n#[derive(Insertable, Deserialize, AsChangeset)]\n#[table_name=\"posts\"]\npub struct PostData {\n    pub title: String,\n    pub body: String,\n    pub pinned: bool,\n}\n\n// This enables using PostData from incoming request data\nimpl FromData for PostData {\n    type Error = String;\n\n    #[allow(unused_variables)]\n    fn from_data(req: &Request, data: Data) -> data::Outcome<Self,\n    String> {\n        let reader = data.open();\n        match serde_json::from_reader(reader).map(|val| val) {\n            Ok(value) => Success(value),\n            Err(e) => Failure((Status::BadRequest, e.to_string())),\n        }\n    }\n}\n```", "```rs\n// ch6/rocket-blog/src/post.rs\n\nuse diesel::result::Error;\nuse diesel;\nuse diesel::sqlite::SqliteConnection;\nuse models::*;\nuse diesel::prelude::*;\nuse schema::posts;\n\n// Returns post with given id\npub fn get_post(conn: &SqliteConnection, id: i32) -> Result<Post, Error> {\n    posts::table\n        .find(id)\n        .first::<Post>(conn)\n}\n\n// Returns all posts\npub fn get_posts(conn: &SqliteConnection) -> Result<Vec<Post>, Error> {\n    posts::table\n        .load::<Post>(conn)\n}\n\n// Creates a post with the given PostData, assigns a ID\npub fn create_post(conn: &SqliteConnection, post: PostData) -> bool {\n    diesel::insert(&post)\n        .into(posts::table).execute(conn).is_ok()\n}\n\n// Deletes a post with the given ID\npub fn delete_post(conn: &SqliteConnection, id: i32) -> Result<usize, Error> {\n    diesel::delete(posts::table.find(id))\n        .execute(conn)\n}\n\n// Updates a post with the given ID and PostData\npub fn update_post(conn: &SqliteConnection, id: i32, updated_post: PostData) -> bool {\n    diesel::update(posts::table\n        .find(id))\n        .set(&updated_post).execute(conn).is_ok()\n}\n```", "```rs\n// ch6/rocket-blog/src/error.rs\n\nuse std::error::Error;\nuse std::convert::From;\nuse std::fmt;\nuse diesel::result::Error as DieselError;\nuse rocket::http::Status;\nuse rocket::response::{Response, Responder};\nuse rocket::Request;\n\n#[derive(Debug)]\npub enum ApiError {\n    NotFound,\n    InternalServerError,\n}\n\nimpl fmt::Display for ApiError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            ApiError::NotFound => f.write_str(\"NotFound\"),\n            ApiError::InternalServerError => f.write_str(\"InternalServerError\"),\n        }\n    }\n}\n\n// Translates a database error to an API error\nimpl From<DieselError> for ApiError {\n    fn from(e: DieselError) -> Self {\n        match e {\n            DieselError::NotFound => ApiError::NotFound,\n            _ => ApiError::InternalServerError,\n        }\n    }\n}\n\nimpl Error for ApiError {\n    fn description(&self) -> &str {\n        match *self {\n            ApiError::NotFound => \"Record not found\",\n            ApiError::InternalServerError => \"Internal server error\",\n        }\n    }\n}\n\n// This enables sending back an API error from a route\nimpl<'r> Responder<'r> for ApiError {\n    fn respond_to(self, _request: &Request) -> Result<Response<'r>, Status> {\n        match self {\n            ApiError::NotFound => Err(Status::NotFound),\n            _ => Err(Status::InternalServerError),\n        }\n    }\n}\n```", "```rs\n// ch6/rocket-blog/src/main.rs\n\n#![feature(plugin)]\n#![plugin(rocket_codegen)]\nextern crate rocket;\n#[macro_use]\nextern crate diesel;\n#[macro_use]\nextern crate diesel_codegen;\nextern crate dotenv;\nextern crate serde_json;\n#[macro_use]\nextern crate lazy_static;\nextern crate rocket_contrib;\n#[macro_use]\nextern crate serde_derive;\nextern crate r2d2;\nextern crate r2d2_diesel;\n\nmod schema;\nmod db;\nmod post;\nmod models;\nmod error;\n\nuse db::DB;\nuse post::{get_posts, get_post, create_post, delete_post, update_post};\nuse models::*;\nuse rocket_contrib::Json;\nuse rocket::response::status::{Created, NoContent};\nuse rocket::Rocket;\nuse error::ApiError;\n\n#[get(\"/posts\", format = \"application/json\")]\nfn posts_get(db: DB) -> Result<Json<Vec<Post>>, ApiError> {\n    let posts = get_posts(&db)?;\n    Ok(Json(posts))\n}\n\n#[get(\"/posts/<id>\", format = \"application/json\")]\nfn post_get(db: DB, id: i32) -> Result<Json<Post>, ApiError> {\n    let post = get_post(&db, id)?;\n    Ok(Json(post))\n}\n\n#[post(\"/posts\", format = \"application/json\", data = \"<post>\")]\nfn post_create(db: DB, post: PostData) -> Result<Created<String>, ApiError> {\n    let post = create_post(&db, post);\n    let url = format!(\"/post/{}\", post);\n    Ok(Created(url, Some(\"Done\".to_string())))\n}\n\n#[patch(\"/posts/<id>\", format = \"application/json\", data = \"<post>\")]\nfn post_edit(db: DB, id: i32, post: PostData) -> Result<Json<bool>, ApiError> {\n    let post = update_post(&db, id, post);\n    Ok(Json(post))\n}\n\n#[delete(\"/posts/<id>\")]\nfn post_delete(db: DB, id: i32) -> Result<NoContent, ApiError> {\n    delete_post(&db, id)?;\n    Ok(NoContent)\n}\n\n// Helper method to setup a rocket instance\nfn rocket() -> Rocket {\n    rocket::ignite().mount(\"/\", routes![post_create, posts_get, post_delete, post_edit, post_get])\n}\n\nfn main() {\n        rocket().launch();\n}\n```", "```rs\n$ DATABASE_URL=db.sql cargo run\njq for formatting the JSON nicely by piping curl's output to jq:\n```", "```rs\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"Hello Rust!\", \"body\": \"Rust is awesome!!\", \"pinned\": true}' http://localhost:8000/posts\nDone\n$ curl http://localhost:8000/posts | jq\n  % Total % Received % Xferd Average Speed Time Time Time Current\n                                 Dload Upload Total Spent Left Speed\n100 130 100 130 0 0 130 0 0:00:01 --:--:-- 0:00:01 8125\n[\n  {\n    \"id\": 1,\n    \"title\": \"test\",\n    \"body\": \"test body\",\n    \"pinned\": true\n  },\n  {\n    \"id\": 2,\n    \"title\": \"Hello Rust!\",\n    \"body\": \"Rust is awesome!!\",\n    \"pinned\": true\n  }\n]\n```", "```rs\n$ ab -n 10000 -c 100 http://localhost:8000/posts\nBenchmarking localhost (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests\n\nServer Software: Rocket\nServer Hostname: localhost\nServer Port: 8000\n\nDocument Path: /posts\nDocument Length: 130 bytes\n\nConcurrency Level: 100\nTime taken for tests: 2.110 seconds\nComplete requests: 10000\nFailed requests: 0\nTotal transferred: 2740000 bytes\nHTML transferred: 1300000 bytes\nRequests per second: 4740.00 [#/sec] (mean)\nTime per request: 21.097 [ms] (mean)\nTime per request: 0.211 [ms] (mean, across all concurrent requests)\nTransfer rate: 1268.32 [Kbytes/sec] received\n\nConnection Times (ms)\n              min mean[+/-sd] median max\nConnect: 0 0 0.4 0 4\nProcessing: 3 21 20.3 19 229\nWaiting: 2 20 19.8 18 228\nTotal: 7 21 20.3 19 229\n\nPercentage of the requests served within a certain time (ms)\n  50% 19\n  66% 19\n  75% 20\n  80% 20\n  90% 21\n  95% 22\n  98% 26\n  99% 214\n 100% 229 (longest request)\n```", "```rs\n$ cargo new --bin rocket-templates\n```", "```rs\n[package]\nauthors = [\"Foo<foo@bar.com>\"]\nname = \"rocket-templates\"\nversion = \"0.1.0\"\n\n[dependencies]\nrocket = \"0.3.5\"\nrocket_codegen = \"0.3.5\"\n\n[dependencies.rocket_contrib]\nversion = \"*\"\ndefault-features = false\nfeatures = [\"tera_templates\"]\n```", "```rs\n// ch6/rocket-templates/templates/webpage.html.tera\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Rocket template demo</title>\n  </head>\n  <body>\n    <h1>Hi {{name}}, you are visitor number {{ visitor_number }}</h1>\n  </body>\n</html>\n```", "```rs\n// ch6/rocket-templates/src/main.rs\n\n#![feature(plugin)]\n#![plugin(rocket_codegen)]\n\nextern crate rocket_contrib;\nextern crate rocket;\n\nuse rocket_contrib::Template;\nuse rocket::{Rocket, State};\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nstruct VisitorCounter {\n    visitor_number: AtomicUsize,\n}\n\n#[get(\"/webpage/<name>\")]\nfn webpage(name: String, visitor: State<VisitorCounter>) -> Template {\n    let mut context = HashMap::new();\n    context.insert(\"name\", name);\n    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);\n    context.insert(\"visitor_number\", current.to_string());\n    Template::render(\"webpage\", &context)\n}\n\nfn rocket() -> Rocket {\n    rocket::ignite()\n        .manage(VisitorCounter { visitor_number: AtomicUsize::new(1) })\n        .mount(\"/\", routes![webpage])\n        .attach(Template::fairing())\n}\n\nfn main() {\n    rocket().launch();\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/rocket-templates`\nConfigured for development.\n    => address: localhost\n    => port: 8000\n    => log: normal\n    => workers: 16\n    => secret key: generated\n    => limits: forms = 32KiB\n    => tls: disabled\nMounting '/':\n    => GET /webpage/<name>\nRocket has launched from http://localhost:8000\n```", "```rs\n$ curl http://localhost:8000/webpage/foo\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Rocket template demo</title>\n  </head>\n  <body>\n    <h1>Hi foo, you are visitor number 2</h1>\n  </body>\n</html>\n```", "```rs\n$ ab -n 10000 -c 100 http://localhost:8000/webpage/foobar\nBenchmarking localhost (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests\n\nServer Software: Rocket\nServer Hostname: localhost\nServer Port: 8000\n\nDocument Path: /webpage/foobar\nDocument Length: 191 bytes\n\nConcurrency Level: 100\nTime taken for tests: 2.305 seconds\nComplete requests: 10000\nFailed requests: 0\nTotal transferred: 3430000 bytes\nHTML transferred: 1910000 bytes\nRequests per second: 4337.53 [#/sec] (mean)\nTime per request: 23.055 [ms] (mean)\nTime per request: 0.231 [ms] (mean, across all concurrent requests)\nTransfer rate: 1452.90 [Kbytes/sec] received\n\nConnection Times (ms)\n              min mean[+/-sd] median max\nConnect: 0 0 2.8 0 200\nProcessing: 3 23 18.6 21 215\nWaiting: 3 22 18.0 20 214\nTotal: 7 23 18.8 21 215\n\nPercentage of the requests served within a certain time (ms)\n  50% 21\n  66% 21\n  75% 22\n  80% 22\n  90% 24\n  95% 25\n  98% 28\n  99% 202\n 100% 215 (longest request)\n```", "```rs\n$ cargo new --bin reqwest-example\n```", "```rs\n[package]\nname = \"reqwest-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nreqwest = \"0.8.1\"\nserde_json = \"1.0.6\"\nserde = \"1.0.21\"\nserde_derive = \"1.0.21\"\n```", "```rs\n// ch6/reqwest-example/src/main.rs\n\nextern crate serde_json;\n#[macro_use]\nextern crate serde_derive;\nextern crate reqwest;\n\n#[derive(Debug,Serialize, Deserialize)]\nstruct Post {\n    title: String,\n    body: String,\n    pinned: bool,\n}\n\nfn main() {\n    let url = \"http://localhost:8000/posts\";\n    let post: Post = Post {title: \"Testing this\".to_string(), body: \"Try to write something\".to_string(), pinned: true};\n    let client = reqwest::Client::new();\n\n    // Creates a new blog post using the synchronous client\n    let res = client.post(url)\n            .json(&post)\n            .send()\n            .unwrap();\n    println!(\"Got back: {}\", res.status());\n\n    // Retrieves all blog posts using the synchronous client\n    let mut posts = client.get(url).send().unwrap();\n    let json: Vec<Post> = posts.json().unwrap();\n    for post in json {\n        println!(\"{:?}\", post);\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling reqwest-example v0.1.0 (file:///src/ch6/reqwest-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.94 secs\n     Running `target/debug/reqwest-example`\nGot back: 201 Created\nPost { title: \"test\", body: \"test body\", pinned: true }\nPost { title: \"Hello Rust!\", body: \"Rust is awesome!!\", pinned: true }\nPost { title: \"Testing this\", body: \"Try to write something\", pinned: true }\n```", "```rs\n[package]\nname = \"reqwest-async\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nserde_json = \"1.0.6\"\nserde = \"1.0.21\"\nserde_derive = \"1.0.21\"\nfutures = \"0.1.17\"\ntokio-core = \"0.1.10\"\n\n[dependencies.reqwest]\nversion = \"0.8.1\"\nfeatures = [\"unstable\"]\n```", "```rs\n// ch6/reqwest-async/src/main.rs\n\nextern crate serde_json;\n#[macro_use]\nextern crate serde_derive;\nextern crate reqwest;\nextern crate futures;\nextern crate tokio_core;\n\nuse futures::Future;\nuse tokio_core::reactor::Core;\nuse reqwest::unstable::async::{Client, Decoder};\nuse std::mem;\nuse std::io::{self, Cursor};\nuse futures::Stream;\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Post {\n    title: String,\n    body: String,\n    pinned: bool,\n}\n\nfn main() {\n    let mut core = Core::new().expect(\"Could not create core\");\n    let url = \"http://localhost:8000/posts\";\n    let post: Post = Post {\n        title: \"Testing this\".to_string(),\n        body: \"Try to write something\".to_string(),\n        pinned: true,\n    };\n    let client = Client::new(&core.handle());\n\n    // Creates a new post using the async client\n    let res = client.post(url).json(&post).send().and_then(|res| {\n        println!(\"{}\", res.status());\n        Ok(())\n    });\n    core.run(res).unwrap();\n\n    // Gets all current blog posts using the async client\n    let posts = client\n        .get(url)\n        .send()\n        .and_then(|mut res| {\n            println!(\"{}\", res.status());\n            let body = mem::replace(res.body_mut(), Decoder::empty());\n            body.concat2().map_err(Into::into)\n        })\n        .and_then(|body| {\n            let mut body = Cursor::new(body);\n            let mut writer: Vec<u8> = vec![];\n            io::copy(&mut body, &mut writer).unwrap();\n            let posts: Vec<Post> = serde_json::from_str(std::str::from_utf8(&writer).unwrap())\n                .unwrap();\n            for post in posts {\n                println!(\"{:?}\", post);\n            }\n            Ok(())\n        });\n    core.run(posts).unwrap();\n}\n```"]