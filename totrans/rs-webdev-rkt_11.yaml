- en: '*Chapter 9*: Displaying Users'' Post'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to implement displaying user posts. Along with
    displaying user posts, we are going to learn about **generic data types** and
    **trait bounds** to group types that behave similarly and so reduce the creation
    of similar code. We are also going to learn about the most important part of the
    Rust programming language: the memory model and its terminologies. We are going
    to learn more about **ownership**, **moving**, **copying**, **cloning**, **borrowing**,
    and **lifetime**, and how we can implement those in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will understand and implement those concepts
    in Rust programming. Generic data types and trait bounds are useful to reduce
    repetitions, while the Rust memory model and concepts are arguably the most distinctive
    features of the Rust language and make it not only fast but one of the safest
    programming languages. Those concepts also make people say that Rust has a steep
    learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying posts – text, photo, and video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic data types and trait bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about ownership and moving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borrowing and lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying posts – text, photo, and video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we implemented user management, including listing,
    showing, creating, updating, and deleting user entities. Now, we want to do the
    same with posts. To refresh your memory, we are planning to have `User` posts.
    The posts can be either text, photos, or videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we implemented the application skeleton, we created a `Post` struct in
    `src/models/post.rs` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The plan is to use `post_type` to differentiate a post based on its type and
    use the `content` field to store the content of the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have rehashed what we wanted to do, let''s implement showing the
    posts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to create a migration file to change the database
    schema. We want to create a table to store the posts. In the application root
    folder, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should then see a new file in the `migrations` folder named `YYYYMMDDHHMMSS_create_posts.sql`
    (depending on the current date-time). Edit the file with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After editing the file, run the migration in the command line to create the
    database table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have also created a `DisplayPostContent` trait in `src/traits/mod.rs`, which
    has the `raw_html()` method. We want to show content in `Post` by converting content
    to HTML snippets and rendering the snippets in the Tera template. Change the signature
    of `raw_html()` so we can use `Post` as the source of HTML snippets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can implement each of the types in `src/models/text_post.rs`, `src/models/photo_post.rs`,
    and `src/models/video_post.rs`. Start with changing `src/models/text_post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The implementation is very simple, we are just wrapping the `Post` content inside
    a `p` HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify `src/models/photo_post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `PhotoPost`, we used the `Post` content as the source of the `img` HTML
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last type we modify is `src/models/video_post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `VideoPost`, we are using the `Post` content as the source of the `video`
    HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create templates for the posts. Let's start with a template that
    will be used in a single post or multiple posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `posts` folder in the `src/views` folder. Then, create a `_post.html.tera`
    file inside the `src/views/posts` folder. Add the following lines to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are wrapping some content inside a `div` and filtering the content as safe
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/views/posts` folder, create a `show.html.tera` file as a template
    to show a single post. Add the following lines to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `index.html.tera` file inside the `src/views/posts` folder to show
    user posts. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating the views, we can implement methods for the `Post` struct to
    get the data from the database. Modify the `src/models/post.rs` file to include
    `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to derive `FromRow` for the `Post` struct to convert database rows
    into `Post` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `impl` block for `Post`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `impl Post` block, we can add functions to query the database and
    return the `Post` data. As the functions are similar to the `User` functions,
    you can copy the code for *steps 14* to *17* in the `Chapter09/01DisplayingPost`
    source code folder. First, we add the `find()` method to get a single post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `find_all()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `find_all_without_pagination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `find_all_with_pagination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to add methods to convert a `Post` instance into `TextPost`, `PhotoPost`,
    or `VideoPost`. Add the following lines inside the `impl Post` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the view and model implementations are ready, we can implement the function
    for showing user posts. In `src/routes/post.rs`, add the required `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `get_post()` function inside `src/routes/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `get_post()` function, query the `user` information and the `post`
    information from the database. Write the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/views/posts/show.html.tera` and `src/views/posts/_post.html.tera`,
    we have set two variables: `user` and `post`. We have to add those two variables
    into the context passed to the template. Append two structs that will be passed
    to templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we can pass the `user` and `post` variables into `context`, render
    the template along with `context`, and return from the function. Append the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `get_posts()` function in `src/routes/post.rs`, we want to get the
    `posts` data from the database. Modify the function into the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have implemented getting the `posts` data, it''s time to render
    those posts as well. Inside the `get_posts()` function, append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have finished the code for `get_post()` and `get_posts()`, it''s time
    to test those two endpoints. Try adding images and videos to a static folder and
    add an entry in the database. You can find a sample image and video in the static
    folder in the source code in the GitHub repository for this chapter. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Testing the endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Testing the endpoints
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open a web browser and navigate to the user posts page, we should be
    able to see something similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Example user posts page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Example user posts page
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the functions to show posts, but if we look back at the
    code, we can see that all three types (Text, Photo, and Video) have the same method
    because they are all implementing the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let's convert those into generic data types and trait bounds in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic data types and trait bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **generic data type**, **generic type**, or simply, **generic**, is a way
    for programming languages to be able to apply the same routine to different data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to create a `multiplication(a, b) -> c {}` function for
    different data types, `u8` or `f64`. If a language does not have a generic, a
    programmer might have to implement two different functions, for example, `multiplication_u8(a:
    u8, b: u8) -> u8` and `multiplication_f64(a: f64, b: f64) -> f64`. Creating two
    different functions might look simple, but as the application grows in complexity,
    the branching and figuring out which function to use will be more complex. If
    a language has a generic, then the problem of multiple functions can be solved
    by using a single function that can accept `u8` and `f64`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Rust language, we can make a function to use generics by declaring the
    generics inside angle brackets after the function name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use generics in a `struct` or `enum` definition. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use generics inside method definitions. Following `Something<T>`,
    we can implement the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At compile time, the compiler identifies and changes the generic code into specific
    code by using the concrete type (`u8` or `f64` in our multiplication example),
    depending on which type is used. This process is called **monomorphization**.
    Because of monomorphization, code written using a generic will produce a binary
    that has the same execution speed as binary generated using specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have looked at an introduction to generics, let''s use generics
    in our existing application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/models/post.rs` file, add another method to convert `Post` instances
    into `media`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are telling the `to_media()` method to return the type that implemented `DisplayPostContent`
    and put `TextPost`, `PhotoPost`, or `VideoPost` into the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/routes/post.rs` file, inside the `get_post()` function, and after
    the `Context` struct declaration, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yes, we can create a function inside another function. The inner function will
    have local scope and cannot be used outside the `get_post()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the `context` variable from initiating the struct directly,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to change it into using the `create_context()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can see that `create_context()` can use any type, such as
    `String` or `u8`, but `String` and `u8` types don't have the `raw_html()` function.
    The Rust compiler will show an error when compiling the code. Let's fix this problem
    by using **trait bounds**.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined and implemented traits several times, and we already know that
    a trait provides consistent behavior for different data types. We defined the
    `DisplayPostContent` trait in `src/traits/mod.rs`, and every type that implements
    `DisplayPostContent` has the same method, `raw_html(&self) -> String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can limit the generic type by adding a trait after the generic declaration.
    Change the `create_context()` function to use trait bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, using `DisplayPostContent` alone is not enough, because the
    `T` size is not fixed. We can change the function parameters from `media: T` into
    a `media: &T` reference, as a reference has a fixed size. We also have another
    problem, as the `DisplayPostContent` size is not known at compile time, so we
    need to add another bound. Every `T` type is implicitly expected to have a constant
    size at compile time, implicitly trait bound to `std::marker::Sized`. We can remove
    the implicit bound by using a special `?Size` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have more than one trait bound and combine them using the `+` sign.
    The resulting signature for the `create_context()` function will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing multiple trait bounds inside angle brackets (`<>`) can make the function
    signature hard to read, so there''s an alternative syntax for defining trait bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we changed the function signature to use a reference, we have to change
    the function usage as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We get `media` object by dereferencing using the `*` sign and referencing `media`
    again using the `&` sign.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the Rust compiler should be able to compile the code again. We will learn
    more about reference in the next two sections, but before that, we have to learn
    about Rust's memory model called ownership and moving.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about ownership and moving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we instantiate a struct, we create an **instance**. Imagine a struct as
    being like a template; an instance is created in the memory based on the template
    and filled with appropriate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance in Rust has a **scope**; it is created in a function and gets returned.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If an instance is not returned, then it''s removed from memory because it''s
    not used anymore. In this example, the `user` instance will be removed by the
    end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can say that an instance has a scope, as mentioned previously. Any resources
    created inside a scope will be destroyed by the end of the scope in the *reverse
    order* of their creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a local scope in a routine by using curly brackets, `{}`.
    Any instance created inside the scope will be destroyed by the end of the scope.
    For example, the `user` scope is within the curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: An instance **owns** resources, not only in **stack memory** but also in **heap
    memory**. When an instance goes out of scope, either because of function exits
    or curly brackets scope exits, the resource attached to the instance is automatically
    cleaned *in reverse order of the creation*. This process is called **resource
    acquisition is initialization** (**RAII**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that computer memory consists of a stack and a heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance owns memory from stack memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Another instance may own memory from the stack and the heap. For example, a
    string can be a single word or a couple of paragraphs. We cannot say how large
    a `String` instance is going to be, so we cannot store all of the information
    in stack memory; instead, we can store some in stack memory and some in heap memory.
    This is a simplification of what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In other programming languages, there's a function called a `std::ops::Drop`
    trait. But, most types don't need to implement the `Drop` trait and are automatically
    removed from memory when they're out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, if we create an instance and set the instance to another instance,
    it is called `src/routes/post.rs` file, inside the `get_posts()` function, modify
    it into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile the program, we should see an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'What is moving? Let''s go back to the simplification of memory. When an instance
    is assigned to another instance, some of the second instance is allocated in stack
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, some of the new instance points to old data in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If both instances point to the same heap memory, what happens if the first instance
    gets dropped? Because of the possibility of invalid data, in Rust, only one instance
    may have its own resources. The Rust compiler will refuse to compile code that
    uses an instance that has been moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our code, the `to_media()` method in `Post` moved the `post`
    instance and put it inside either `TextPost`, `PhotoPost`, or `VideoPost`. As
    a result, we cannot use the `post` instance again in `post.uuid.to_string()` because
    it has been moved. Right now, we can fix the code by changing the order of the
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: There's no moving when we use `post.uuid.to_string()`, so the code should compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, how we can create a `std::marker::Copy` trait, then when we assign an
    instance from another instance, it will create a duplicate in the stack. This
    is the reason why simple types such as `u8`, which don''t require a lot of memory
    or have a known size, implement the `Copy` trait. Let''s see the illustration
    of how this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'A type may automatically derive the `Copy` trait if all members of that type
    implement the `Copy` trait. We also have to derive `Clone`, because the `Copy`
    trait is trait bound by the `Clone` trait in its definition: `pub trait Copy:
    Clone { })`. Here is an example of deriving the `Copy` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this example will not work because `String` does not implement `Copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Cloning works by copying the content of the heap memory. For example, let''s
    say we have the preceding code and the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize `dolly` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we assign another instance from `dolly`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the memory usage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'As allocating heap memory is expensive, we can use another way to see the value
    of an instance: **borrowing**.'
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing and lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used **references** in our code. A reference is an instance in the
    stack that points to another instance. Let''s recall what an instance memory usage
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'A reference is allocated in stack memory, pointing to another instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Allocating in the stack is cheaper than allocating in the heap. Because of this,
    using references most of the time is more efficient than cloning. The process
    of creating a reference is called **borrowing**, as the reference borrows the
    content of another instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have an instance named `airwolf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a reference to `airwolf` by using an ampersand (`&`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Borrowing an instance is like a camera monitor; a reference can see the value
    of the referenced instance, but the reference cannot modify the value. We can
    have more than one reference, as seen in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want a reference that can modify the value of the instance it referenced?
    We can create a `&mut` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Now, what will happen if we have two remote controls? Well, the helicopter cannot
    ascend and descend at the same time. In the same way, Rust restricts mutable references
    and only allows one mutable reference at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust also disallows using mutable references along with immutable references
    because data inconsistency may occur. For example, adding the following lines
    will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: What is the value of `last_load`? We expected `last_load` to be `None`, but
    the remote control already pushed something to cargo. Because of the data inconsistency
    problem, the Rust compiler will emit an error if we try to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing borrowing and lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned about ownership, moving, and borrowing, let's modify
    our code to use references.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the current definition for `TextPost`, `PhotoPost`, and `VideoPost`,
    we can see we are taking ownership of `post` and moving the `post` instance into
    a new instance of `TextPost`, `PhotoPost`, or `VideoPost`. In `src/models/text_post.rs`
    add the following struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in `src/models/post.rs` , add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can convert the `TextPost` field to be a reference to a `Post` instance.
    Modify `src/models/text_post.rs` into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are converting the unnamed field into a private unnamed field, we
    also need an initializer. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we changed the initialization of `TextPost`, we also need to change the
    implementation of `to_text()` and `to_media()`. In `src/models/post.rs`, change
    the `to_text()` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `to_media()` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try compiling the code. We should see an error as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The reason for this error is that the code needs a **lifetime specifier**.
    What is a lifetime specifier? Let''s see an example of a very simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, in Rust, any instance is removed automatically after we reach the
    end of the scope. In the preceding code, `y` is created inside a scope denoted
    by curly brackets, `{}`. When the code reaches the end of the scope, `}`, the
    `y` instance is cleared from the memory. So, what will happen with `x`? The preceding
    code will fail to compile because `x` is not valid anymore. We can fix the code
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s take a look at our code in `src/models/text_post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because Rust is multithreaded and has a lot of branching, we cannot guarantee
    that the reference to the `Post` instance, `&Post`, can exist for as long as the
    `TextPost` instance. What will happen if `&Post` is already destroyed while the
    `TextPost` instance is not destroyed? The solution is that we place a marker called
    a `TextPost` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: We are telling the compiler that any instance of `TextPost` should live as long
    as the referenced `&Post`, which indicated by lifetime indicator, `'a`. If the
    compiler finds out that `&Post` is not living as long as the `TextPost` instance,
    it does not compile the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention for a lifetime specifier is using a small, single letter such
    as `''a`, but there''s also a special lifetime specifier, `''static`. A `''static`
    lifetime specifier means the data referenced is living as long as the application.
    For example, we are saying the data referenced by `pi` will live as long as the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the rest of the application. We have seen how we use a lifetime
    specifier in the type definition; let''s use it in an `impl` block and method
    as well. Modify the rest of `src/models/text_post.rs` into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s change `PhotoPost` in `src/models/photo_post.rs` to use lifetime as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s also change `VideoPost` in `src/models/video_post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in `src/models/post.rs`, modify the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are using a borrowed `Post` instance for `TextPost`, `PhotoPost`, or
    `VideoPost` instances. But, before we end this chapter, let''s refactor the code
    a little bit by following these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the `ShowPost` struct is duplicated inside `get_post()` and `get_posts()`.
    Add a new struct into `src/models/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to convert `Post` into `ShowPost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/routes/post.rs`, add `ShowPost` to a `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `get_post()` function by removing these lines to remove unnecessary
    struct declarations and functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace those lines with the `context!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `get_posts()` function, remove these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace those lines with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, change the `context` instantiation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, remove the unnecessary `use` declaration. Remove these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The implementation of showing posts should be cleaner now we are using the borrowed
    `Post` instance. There should be no difference in the speed of the application
    because we are just using the reference of a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, sometimes it's better to use an owned attribute instead of a reference
    because there's no significant performance improvement. Using references can be
    useful in complex applications, high-memory usage applications, or high-performance
    applications such as gaming or high-speed trading with a lot of data, at the cost
    of development time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have implemented `get_post()` and `get_posts()` to show
    `Post` information in a web browser. Along with those implementations, we have
    learned about reducing code duplication through generics and trait bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about the most distinct and important feature of Rust:
    its memory model. We now know an instance owns a memory block, either in the stack
    or in both the stack and heap. We have also learned that assigning another instance
    to an instance means moving ownership unless it''s a simple type that implements
    the `Copy` and/or `Clone` trait. We have also learned about borrowing, the rules
    of borrowing, and the use of the lifetime specifier to complement moving, copying,
    and borrowing.'
  prefs: []
  type: TYPE_NORMAL
- en: Those rules are some of the most confusing parts of Rust, but those rules are
    also what make Rust a very safe language while still having the same performance
    as other system languages such as C or C++. Now that we have implemented showing
    posts, let's learn how to upload data in the next chapter.
  prefs: []
  type: TYPE_NORMAL
