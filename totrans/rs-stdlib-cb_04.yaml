- en: Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization basics with Serde
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with TOML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building JSON dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reinventing the wheel doesn't make sense. A great deal of functionality has
    already been provided by many programs that are more than happy to interact with
    your program. Of course, this offer is worthless if you're not able to communicate
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the most important formats in the Rust
    ecosystem in order to enable you to comfortably speak with other services.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nice and simple way to store uncomplicated and small datasets is CSV. This
    format is also of interest if you're working with spreadsheet applications such
    as Microsoft Excel, as they have excellent support for importing and exporting
    various flavors of CSV.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know what a CSV is, but a little refresher won't hurt.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the format is to take a table of values and write all rows down
    as *records*. Inside a record, every column item is written down and separated
    by a comma. That's where the format's name comes from—comma-separated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do an example. In the following code, we are going to write a CSV comparing
    various planets in the solar system to our own. A radius, distance from the sun,
    and gravity of `1` means *exactly as on earth*. Written as a table, our values
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **name** | **radius** | **distance_from_sun** | **gravity** |'
  prefs: []
  type: TYPE_TB
- en: '| Mercury | 0.38 | 0.47 | 0.38 |'
  prefs: []
  type: TYPE_TB
- en: '| Venus | 0.95 | 0.73 | 0.9 |'
  prefs: []
  type: TYPE_TB
- en: '| Earth | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Mars | 0.53 | 1.67 | 0.38 |'
  prefs: []
  type: TYPE_TB
- en: '| Jupiter | 11.21 | 5.46 | 2.53 |'
  prefs: []
  type: TYPE_TB
- en: '| Saturn | 9.45 | 10.12 | 1.07 |'
  prefs: []
  type: TYPE_TB
- en: '| Uranus | 4.01 | 20.11 | 0.89 |'
  prefs: []
  type: TYPE_TB
- en: '| Neptune | 3.88 | 30.33 | 1.14 |'
  prefs: []
  type: TYPE_TB
- en: 'Take every row, separate the values by commas, put them each on a separate
    line, and you end up with the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the heading ( `planet,radius,distance_from_sun,gravity`) is
    simply written as the first record.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter_four`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly-created `chapter_four` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `src` folder, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to `csv`'s crates.io page ([https://crates.io/crates/csv](https://crates.io/crates/csv))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `csv.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin csv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we prepare our file[9] and its `OpenOptions` so that we have both
    `read` and `write` access on the file. You will remember this from [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*; *Working with text files*.
  prefs: []
  type: TYPE_NORMAL
- en: Then we write the CSV. We do this by wrapping any kind of `Write` in a `csv::Writer`[30].
    You can then use `write_record` on it to write any data type that can be represented
    as an iterator over `&[u8]`. Most of the time, this will simply be an array of
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: While reading, we similarly wrap a `Read` in a `csv::Read`. The `records()`
    method returns an iterator over `Result` of `StringRecord`. This way, you get
    to decide how to handle a malformed record. In our example, we simply skip it.
    Lastly, we call `get()` on a record to get a certain field. If there was no entry
    at the specified index or if it was out of bounds, this would return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to read or write a custom CSV format, like one that uses tabs instead
    of commas as a delimiter, you can use `WriterBuilder` and `ReaderBuilder` to customize
    the expected format. Remember this well if you're planning on using Microsoft
    Excel, as it has the annoying tendency to be regionally inconsistent in its choice
    of delimiters ([https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon](https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon)).
  prefs: []
  type: TYPE_NORMAL
- en: When working with CSV and Microsoft Excel, be careful and sanitize your data
    before handing it to Excel. Even though CSV is defined as plain data with no control
    identifiers, Excel will interpret and execute macros when importing CSV. For examples
    of possible attack vectors opened by this, see [http://georgemauer.net/2017/10/07/csv-injection.html](http://georgemauer.net/2017/10/07/csv-injection.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also useful if a Windows application refuses to accept the `\n` terminator
    that `csv` uses as per default. In this case, simply specify the following code
    in the builder to use the Windows-native `\r\n` terminator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `csv` crate allows you to manipulate your data much more than what is shown
    in this recipe. You can, for example, insert new fields on the fly into a `StringRecord`.
    We deliberately don't explore these possibilities in detail as the CSV format
    is not meant for these kinds of data manipulation. If you need to do more than
    simple import/export, you should use a more suitable format, such as JSON, which
    we will explore in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with text files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization basics with Serde
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *de facto* standard for all things serialization in Rust is the Serde framework.
    All the other recipes in this chapter are going to use it to some extent. In order
    to make you familiar with the Serde way of doing things, we are going to rewrite
    the last recipe using it. Later in the chapter, we will learn in detail how Serde
    works in order to implement idiomatic deserialization into a homemade format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t done so already in the last recipe, add the following line
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the crates.io web pages for Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)),
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive)),
    and CSV ([https://crates.io/crates/csv](https://crates.io/crates/csv)) to check
    for the newest versions and use those ones instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `serde_csv.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin serde_csv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this recipe reads and writes the exact same CSV as the last recipe.
    The only difference is how we treat a single record. Serde helps us by enabling
    us to use plain old Rust structures for this. The only thing we need to do is
    derive our `Planet` structure from `Serialize` and `Deserialize` [9]. The rest
    is taken care of automatically by Serde.
  prefs: []
  type: TYPE_NORMAL
- en: Because we now use actual Rust structures to represent a planet, we create a
    record by calling `serialize` with a structure instead of `write_record` as before
    [42]. Looks way more readable, doesn't it? If you think that the example became
    a little bit too verbose, you could hide the actual object creation behind a constructor,
    as described in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*; *Using the Constructor Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: When reading a CSV, we also no longer have to manually access the fields of
    a `StringRecord`. Instead, `deserialize()` returns an iterator over a `Result`
    of an already deserialized `Planet` object. Again, look how much more readable
    this has become.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have already guessed, you should use Serde whenever you can, as it
    helps you catch possible errors early by providing you with readability and compile-time
    type safety.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serde gives you the ability to tweak the serialization process somewhat by
    annotating your fields. For example, you can give a field a standard value if
    it wasn''t able to be parsed by writing `#[serde(default)]` above its declaration.
    In a struct, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If `baz` hasn''t been parsed, its `Default::default` value (See [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*; Providing a default implementation) will be used. Another
    useful thing you can do with annotations is changed the expected case convention.
    By default, Serde will expect Rust''s `snake_case`, however, you can change this
    by annotating a `struct` or `enum` with `#[serde(rename_all = "PascalCase")]`.
    You can use it on a struct like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would, instead of parsing `number_of_clicks` and `total_time_played`, expect
    the `NumberOfClicks` and `TotalTimePlayed` keys to be called. Other possible case
    conventions than `PascalCase` that Serde supports are lowercase, *camelCase*,
    and *SCREAMING_SNAKE_CASE*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different and useful attributes. If you want to, you can familiarize
    yourself with them at [https://serde.rs/attributes.html](https://serde.rs/attributes.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can use Serde to provide idiomatic serialization and deserialization, however,
    discussing all best practices would cover an entire chapter on its own. If you
    want to delve into such things, Serde has a nice write-up on how to do it at [https://serde.rs/data-format.html](https://serde.rs/data-format.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the constructor pattern* and *Providing a default implementation* recipes
    in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with text files *recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml), *Handling
    Files and the Filesystem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with TOML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you like the simplicity of INI files but wish they were formally specified
    and had a few more features? So did Tom Preston-Werner, founder of services such
    as GitHub and Gravatar. He created Tom''s Obvious, Minimal Language, or TOML for
    short. This relatively new format is seeing increasing adoption in new projects.
    In fact, you have used it multiple times by now as well: Cargo''s dependencies
    are specified in every project''s `Cargo.toml` file!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At its heart, TOML is all about *key-value* pairs. This is the simplest TOML
    file you can create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the key message has the `"Hello World"` value. A value can also be an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A group of key-values is called a *table*. The following TOML lets the `smileys`
    table contain the `happy` key with the `":)"` value and the `sad` key with the `":("`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A particularly small table can be *inlined*, that is, written in one line.
    The last example is the exact same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Tables can be nested by separating their names with a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice property of TOML is that you can convert any key into a table if you
    need to specify additional information. For example, Cargo itself expects this
    when declaring dependency versions. For example, if you wanted to use `rocket_contrib`,
    a helper crate of the popular `rocket` web framework for Rust, at version 0.3.3,
    you would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you wanted to specify the exact features to be included in `rocket_contrib`,
    you would need to instead write it as a sub-table of `dependencies`. The following
    TOML would tell `Cargo` to use its JSON serialization feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another nice thing TOML brings to the table is that its whitespace is not significant,
    that is, you can indent a file however you want. You can even add comments by
    beginning a line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you want to explore the format further, the entirety of the TOML syntax is
    specified at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t done so already, add the following lines as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the crates.io web pages for TOML ([https://crates.io/crates/toml](https://crates.io/crates/toml)),
    Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)), and
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    to check for the newest versions and use those ones instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `toml.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the structures we are going to use throughout the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a new file and call the other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Save our structures as a TOML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Read` the TOML file we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always with Serde, we first need to declare the structures we plan on using
    [8 to 32].
  prefs: []
  type: TYPE_NORMAL
- en: While serializing, we can directly call Serde's `to_string` method with a structure
    as TOML re-exports them [77]. This returns a `String` that we can then write into
    a file [79]. The same is true of Serde's `from_str`, which, when type-annotated,
    takes a `&str` and converts it into a structure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that we are not using the try-operator (`?`) while reading
    or writing in this recipe. This is because the function's expected error types,
    `se::Error` [77] and `de::Error`[93], are incompatible with `std::io::Error`.
    In [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml), *Handling Errors*;* Providing
    user-defined Error types*, we will explore how to avoid this by returning our
    own error type that encompasses the other ones mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: The TOML crate used in this recipe is the same one that Cargo itself uses. If
    you are interested in how Cargo parses its own `Cargo.toml` file, you can check
    out [https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs](https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working with* text *files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Web APIs and many native APIs speak JSON nowadays. It should be your format
    of choice when designing data meant for consumption by other programs, as it is
    lightweight, simple, easy to use and understand, and has excellent library support
    across programming languages, most notably JavaScript, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON was created at a time when most web communication was done by sending
    XML over browser plugins such as Java or Flash. This was cumbersome and made the
    exchanged information quite bloated. Douglas Crockford, the creator of JSLint
    and author of the famous *JavaScript: The Good Parts*, decided in the early 2000s
    that it was time for a lightweight format that was easily integrated with JavaScript.
    He oriented himself on a small subset of JavaScript, namely the way it defined
    objects, and extended it a little bit to form the JavaScript Object Notation or
    JSON. Yes, you''ve read that right; JSON is *not* a subset of JavaScript, as it
    accepts things that JavaScript doesn''t. You can read more about that at [http://timelessrepo.com/json-isnt-a-javascript-subset.](http://timelessrepo.com/json-isnt-a-javascript-subset)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sad irony of the story is that today we have gone full-circle: our best
    practices for web development include a labyrinth of task runners, frameworks,
    and transpilers, which are all quite nice in theory but end up being a giant bloated
    mess in the end. But that is a story for another time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is built upon two structures:'
  prefs: []
  type: TYPE_NORMAL
- en: A group of key-value pairs surrounded by `{` and `}`, which is called an *object*
    and can be a value itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of values surrounded by `[` and `]` called an *array*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might remind you a bit of the TOML syntax we discussed earlier, and you
    might ask yourself when you should prefer one over the other. The answer is that
    JSON is a good format when your data is going to be read automatically by a tool,
    while TOML is excellent when your data is meant to be read and modified manually
    by a human.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that one thing that JSON *doesn't* allow is comments. This makes sense,
    as comments are not readable by tools anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a JSON object with values, sub-objects, and arrays could be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are going to write and read this exact example in the following code. The
    definitions of the pets are intentionally inconsistent because many web APIs omit
    certain keys in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t done so already, add the following lines as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the crates.io web pages for `serde_json` ([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json)),
    Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)), and
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    to check for the newest versions and use those ones instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `json.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the structures we are going to use throughout the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a new file and call the other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Save our structures as a JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the JSON file we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice how this recipe looks nearly identical to the last one? Except for the
    structures, the only significant difference is that we called `serde_json::to_string()`
    [81] instead of `toml::to_string()`, and `serde_json::from_str()` [96] instead
    of `toml::from_str()`. This is the beauty of a well-thought-out framework like
    Serde: the custom serialization and deserialization code are hidden behind trait
    definitions and we can use the same API without caring about internal implementation
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, there is nothing to say that hasn't been said in the previous
    recipe, which is why we are not going to go over any other formats. All important
    formats support Serde, so you can use them the exact same way you use the other
    formats in this chapter. For a full list of all supported formats, see [https://docs.serde.rs/serde/index.html](https://docs.serde.rs/serde/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON has no concept of something resembling an `enum`. As many languages *do*
    work with them, however, multiple conventions on how to handle the conversion
    from JSON into `enum` have emerged over the years. Serde allows you to support
    these conventions with annotations on your enums. For a full list of supported
    conversions, visit [https://serde.rs/enum-representations.html](https://serde.rs/enum-representations.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working with text* *files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building JSON dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a JSON API is designed with a poorly-thought-out schema and inconsistent
    objects, you might end up with giant structures where most members are an `Option`.
    If you find yourself only sending data to such a service, it might be a bit easier
    to dynamically build your JSON property by property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, if you haven''t done so already, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the `serde_json` crates.io web page ([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json))
    to check for the newest version and use that one instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `dynamic_json.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin dynamic_json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, the user can enter any number of key-value pairs until they
    decide to stop, at which point they receive their input back in the form of JSON.
    Some example input you could enter could include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Use `#[cfg(target_os = "some_operating_system")]` to handle operating system
    specific circumstances. In this recipe, we use this to conditionally compile the
    `END_OF_TRANSMISSION` constant differently on Windows than on Unix. This key combination
    tells the OS to stop the current input stream.
  prefs: []
  type: TYPE_NORMAL
- en: This program begins with the idea that a JSON object without a clearly defined
    schema is nothing but a `HashMap<String, String>`[9]. Now, `serde_json` doesn't
    accept a `String` as a value, as that would not be general enough. Instead, it
    wants a `serde_json::Value`, which you can easily construct by calling the `json!`
    macro on pretty much any type [20].
  prefs: []
  type: TYPE_NORMAL
- en: When we are done, we don't call `serde_json::to_string()` as before, but use
    `serde_json::to_string_pretty()` instead [28], as this results in a less efficient
    but much more readable JSON. Remember, JSON is not supposed to be primarily read
    by humans, which is why the default way Serde serialized it is without any whitespace
    whatsoever. If you're curious about the exact difference, feel free to go ahead
    and change `to_string_pretty()` to `to_string()` and compare the results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reading from stdin* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access collections as Iterators* and *Using a HashMap* recipe in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
