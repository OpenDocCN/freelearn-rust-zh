- en: Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Working with CSV
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理CSV
- en: Serialization basics with Serde
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Serde进行序列化基础
- en: Working with TOML
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理TOML
- en: Working with JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JSON
- en: Building JSON dynamically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态构建JSON
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Reinventing the wheel doesn't make sense. A great deal of functionality has
    already been provided by many programs that are more than happy to interact with
    your program. Of course, this offer is worthless if you're not able to communicate
    with them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发明轮子是没有意义的。许多程序已经提供了大量的功能，它们很乐意与您的程序交互。当然，如果您无法与他们通信，这种提供就毫无价值。
- en: In this chapter, we are going to look at the most important formats in the Rust
    ecosystem in order to enable you to comfortably speak with other services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Rust生态系统中最重要的格式，以便您能够轻松与其他服务进行交流。
- en: Working with CSV
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理CSV
- en: A nice and simple way to store uncomplicated and small datasets is CSV. This
    format is also of interest if you're working with spreadsheet applications such
    as Microsoft Excel, as they have excellent support for importing and exporting
    various flavors of CSV.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存储简单且小型数据集的一个好方法就是CSV。如果您正在使用像Microsoft Excel这样的电子表格应用程序，这个格式也很感兴趣，因为它们对导入和导出各种CSV格式有很好的支持。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You probably already know what a CSV is, but a little refresher won't hurt.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道CSV是什么，但稍微复习一下也无妨。
- en: The idea of the format is to take a table of values and write all rows down
    as *records*. Inside a record, every column item is written down and separated
    by a comma. That's where the format's name comes from—comma-separated values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式的想法是将值表的所有行都写下来作为*记录*。在记录内部，每个列项都写下来，并用逗号分隔。这就是该格式名称的由来——逗号分隔值。
- en: 'Let''s do an example. In the following code, we are going to write a CSV comparing
    various planets in the solar system to our own. A radius, distance from the sun,
    and gravity of `1` means *exactly as on earth*. Written as a table, our values
    look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个例子。在下面的代码中，我们将编写一个CSV文件，比较太阳系中各种行星与我们的地球。半径、距离太阳和重力为`1`表示*与地球完全相同*。以表格形式写出，我们的值看起来是这样的：
- en: '| **name** | **radius** | **distance_from_sun** | **gravity** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **name** | **radius** | **distance_from_sun** | **gravity** |'
- en: '| Mercury | 0.38 | 0.47 | 0.38 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 水星 | 0.38 | 0.47 | 0.38 |'
- en: '| Venus | 0.95 | 0.73 | 0.9 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 金星 | 0.95 | 0.73 | 0.9 |'
- en: '| Earth | 1 | 1 | 1 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 地球 | 1 | 1 | 1 |'
- en: '| Mars | 0.53 | 1.67 | 0.38 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 火星 | 0.53 | 1.67 | 0.38 |'
- en: '| Jupiter | 11.21 | 5.46 | 2.53 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 木星 | 11.21 | 5.46 | 2.53 |'
- en: '| Saturn | 9.45 | 10.12 | 1.07 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 土星 | 9.45 | 10.12 | 1.07 |'
- en: '| Uranus | 4.01 | 20.11 | 0.89 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 天王星 | 4.01 | 20.11 | 0.89 |'
- en: '| Neptune | 3.88 | 30.33 | 1.14 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 海王星 | 3.88 | 30.33 | 1.14 |'
- en: 'Take every row, separate the values by commas, put them each on a separate
    line, and you end up with the CSV file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将每一行取出来，用逗号分隔值，将它们各自放在单独的一行上，您就得到了CSV文件：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the heading ( `planet,radius,distance_from_sun,gravity`) is
    simply written as the first record.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，标题（`planet,radius,distance_from_sun,gravity`）简单地写成第一条记录。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a Rust project to work on during this chapter with `cargo new chapter_four`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter_four`创建一个Rust项目，在本章中对其进行操作。
- en: Navigate into the newly-created `chapter_four` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`chapter_four`文件夹。在本章的剩余部分，我们将假设您的命令行当前位于此目录。
- en: Inside the `src` folder, create a new folder called `bin`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内，创建一个名为`bin`的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们不是创建一个库。
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want, you can go to `csv`'s crates.io page ([https://crates.io/crates/csv](https://crates.io/crates/csv))
    to check for the newest version and use that one instead.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，可以访问`csv`的crates.io页面([https://crates.io/crates/csv](https://crates.io/crates/csv))，检查最新版本并使用它。
- en: In the `src/bin` folder, create a file called `csv.rs`
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`csv.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin csv`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin csv`运行它：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, we prepare our file[9] and its `OpenOptions` so that we have both
    `read` and `write` access on the file. You will remember this from [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*; *Working with text files*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们准备我们的文件[9]及其`OpenOptions`，以便我们可以在文件上同时拥有`read`和`write`访问权限。您会记得这一点来自[第3章](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml)，*处理文件和文件系统*；*处理文本文件*。
- en: Then we write the CSV. We do this by wrapping any kind of `Write` in a `csv::Writer`[30].
    You can then use `write_record` on it to write any data type that can be represented
    as an iterator over `&[u8]`. Most of the time, this will simply be an array of
    strings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们写入CSV。我们通过将任何类型的`Write`包装在`csv::Writer`[30]中来完成此操作。然后您可以使用`write_record`来写入任何可以表示为`&[u8]`迭代器的数据类型。大多数情况下，这只是一个字符串数组。
- en: While reading, we similarly wrap a `Read` in a `csv::Read`. The `records()`
    method returns an iterator over `Result` of `StringRecord`. This way, you get
    to decide how to handle a malformed record. In our example, we simply skip it.
    Lastly, we call `get()` on a record to get a certain field. If there was no entry
    at the specified index or if it was out of bounds, this would return `None`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取时，我们同样将一个`Read`包装在`csv::Read`中。`records()`方法返回一个`Result`的`StringRecord`迭代器。这样，您可以决定如何处理格式不正确的记录。在我们的例子中，我们简单地跳过它。最后，我们在一个记录上调用`get()`以获取某个字段。如果没有在指定的索引处有条目，或者它超出了范围，这将返回`None`。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you need to read or write a custom CSV format, like one that uses tabs instead
    of commas as a delimiter, you can use `WriterBuilder` and `ReaderBuilder` to customize
    the expected format. Remember this well if you're planning on using Microsoft
    Excel, as it has the annoying tendency to be regionally inconsistent in its choice
    of delimiters ([https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon](https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要读取或写入自定义CSV格式，例如使用制表符而不是逗号作为分隔符的格式，您可以使用`WriterBuilder`和`ReaderBuilder`来自定义预期的格式。如果您计划使用Microsoft
    Excel，请务必记住这一点，因为它在选择分隔符方面具有令人烦恼的区域不一致性([https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon](https://stackoverflow.com/questions/10140999/csv-with-comma-or-semicolon))。
- en: When working with CSV and Microsoft Excel, be careful and sanitize your data
    before handing it to Excel. Even though CSV is defined as plain data with no control
    identifiers, Excel will interpret and execute macros when importing CSV. For examples
    of possible attack vectors opened by this, see [http://georgemauer.net/2017/10/07/csv-injection.html](http://georgemauer.net/2017/10/07/csv-injection.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理CSV和Microsoft Excel时，请小心，并在将其交给Excel之前清理您的数据。尽管CSV被定义为没有控制标识符的纯数据，但Excel在导入CSV时会解释并执行宏。关于由此可能打开的可能攻击向量，请参阅[http://georgemauer.net/2017/10/07/csv-injection.html](http://georgemauer.net/2017/10/07/csv-injection.html)。
- en: 'This is also useful if a Windows application refuses to accept the `\n` terminator
    that `csv` uses as per default. In this case, simply specify the following code
    in the builder to use the Windows-native `\r\n` terminator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Windows应用程序拒绝接受`csv`默认使用的`\n`终止符，这也会很有用。在这种情况下，只需在构建者中指定以下代码即可使用Windows本地的`\r\n`终止符：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `csv` crate allows you to manipulate your data much more than what is shown
    in this recipe. You can, for example, insert new fields on the fly into a `StringRecord`.
    We deliberately don't explore these possibilities in detail as the CSV format
    is not meant for these kinds of data manipulation. If you need to do more than
    simple import/export, you should use a more suitable format, such as JSON, which
    we will explore in this chapter as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv`crate允许您比本配方中显示的更灵活地操作您的数据。例如，您可以在`StringRecord`中动态插入新字段。我们故意不详细探讨这些可能性，因为CSV格式并不适用于这类数据操作。如果您需要做比简单的导入/导出更多的事情，您应该使用更合适的格式，例如JSON，我们将在本章中也探讨这一点。'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the builder pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用构建者模式*的配方在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: '*Working with text files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理文本文件*的配方在[第3章](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml)，*处理文件和文件系统*'
- en: Serialization basics with Serde
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Serde进行序列化基础知识
- en: The *de facto* standard for all things serialization in Rust is the Serde framework.
    All the other recipes in this chapter are going to use it to some extent. In order
    to make you familiar with the Serde way of doing things, we are going to rewrite
    the last recipe using it. Later in the chapter, we will learn in detail how Serde
    works in order to implement idiomatic deserialization into a homemade format.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中所有序列化事物的**事实标准**是 Serde 框架。本章中的其他所有食谱都将部分使用它。为了让你熟悉 Serde 的做事方式，我们将使用它重写上一个食谱。在本章的后面部分，我们将详细了解
    Serde 的工作原理，以便实现将数据反序列化到自定义格式。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件。
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you haven''t done so already in the last recipe, add the following line
    as well:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有在上一个食谱中这样做，请添加以下行：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want, you can go to the crates.io web pages for Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)),
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive)),
    and CSV ([https://crates.io/crates/csv](https://crates.io/crates/csv)) to check
    for the newest versions and use those ones instead.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，可以去 Serde 的 crates.io 网页（[https://crates.io/crates/serde](https://crates.io/crates/serde)）、`serde_derive`（[https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive)）和
    CSV（[https://crates.io/crates/csv](https://crates.io/crates/csv)）查看最新版本，并使用这些版本。
- en: In the `bin` folder, create a file called `serde_csv.rs`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `serde_csv.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin serde_csv`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin serde_csv` 运行它：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code in this recipe reads and writes the exact same CSV as the last recipe.
    The only difference is how we treat a single record. Serde helps us by enabling
    us to use plain old Rust structures for this. The only thing we need to do is
    derive our `Planet` structure from `Serialize` and `Deserialize` [9]. The rest
    is taken care of automatically by Serde.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的代码读取和写入与上一个食谱完全相同的 CSV。唯一的区别是我们如何处理单个记录。Serde 通过允许我们使用普通的 Rust 结构体来帮助我们。我们唯一需要做的是从
    `Serialize` 和 `Deserialize` [9] 中派生我们的 `Planet` 结构体。其余的将由 Serde 自动处理。
- en: Because we now use actual Rust structures to represent a planet, we create a
    record by calling `serialize` with a structure instead of `write_record` as before
    [42]. Looks way more readable, doesn't it? If you think that the example became
    a little bit too verbose, you could hide the actual object creation behind a constructor,
    as described in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning
    the Basics*; *Using the Constructor Pattern*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在使用实际的 Rust 结构体来表示一个行星，我们通过调用 `serialize` 并传入一个结构体来创建记录，而不是像以前那样使用 `write_record`
    [42]。看起来是不是更易于阅读了？如果你认为示例变得有点冗长，你可以像在[第 1 章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)中描述的那样，将实际对象创建隐藏在构造函数后面，*学习基础知识*；*使用构造函数模式*。
- en: When reading a CSV, we also no longer have to manually access the fields of
    a `StringRecord`. Instead, `deserialize()` returns an iterator over a `Result`
    of an already deserialized `Planet` object. Again, look how much more readable
    this has become.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取 CSV 时，我们也不再需要手动访问 `StringRecord` 的字段。相反，`deserialize()` 返回一个已反序列化 `Planet`
    对象的 `Result` 迭代器。再次，看看这变得多么易于阅读。
- en: As you may have already guessed, you should use Serde whenever you can, as it
    helps you catch possible errors early by providing you with readability and compile-time
    type safety.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，你应该尽可能使用 Serde，因为它通过提供可读性和编译时类型安全来帮助你尽早捕获可能的错误。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Serde gives you the ability to tweak the serialization process somewhat by
    annotating your fields. For example, you can give a field a standard value if
    it wasn''t able to be parsed by writing `#[serde(default)]` above its declaration.
    In a struct, it would look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Serde 允许你通过注释你的字段来稍微调整序列化过程。例如，如果你无法通过写入 `#[serde(default)]` 在其声明上方为其提供一个标准值。在一个结构体中，它看起来像这样：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `baz` hasn''t been parsed, its `Default::default` value (See [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*; Providing a default implementation) will be used. Another
    useful thing you can do with annotations is changed the expected case convention.
    By default, Serde will expect Rust''s `snake_case`, however, you can change this
    by annotating a `struct` or `enum` with `#[serde(rename_all = "PascalCase")]`.
    You can use it on a struct like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `baz` 没有被解析，它的 `Default::default` 值（参见 [第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*；提供默认实现）将被使用。你可以用注解做的另一件有用的事情是改变期望的大小写约定。默认情况下，Serde
    会期望 Rust 的 `snake_case`，但是，你可以通过用 `#[serde(rename_all = "PascalCase")]` 注解一个 `struct`
    或 `enum` 来改变这一点。你可以在这样的 `struct` 上使用它：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would, instead of parsing `number_of_clicks` and `total_time_played`, expect
    the `NumberOfClicks` and `TotalTimePlayed` keys to be called. Other possible case
    conventions than `PascalCase` that Serde supports are lowercase, *camelCase*,
    and *SCREAMING_SNAKE_CASE*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将，而不是解析 `number_of_clicks` 和 `total_time_played`，期望 `NumberOfClicks` 和 `TotalTimePlayed`
    键被调用。Serde 支持的其他可能的比 `PascalCase` 更多的案例约定包括小写、*camelCase* 和 *SCREAMING_SNAKE_CASE*。
- en: There are many different and useful attributes. If you want to, you can familiarize
    yourself with them at [https://serde.rs/attributes.html](https://serde.rs/attributes.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同且有用的属性。如果你想，你可以在 [https://serde.rs/attributes.html](https://serde.rs/attributes.html)
    上熟悉它们。
- en: You can use Serde to provide idiomatic serialization and deserialization, however,
    discussing all best practices would cover an entire chapter on its own. If you
    want to delve into such things, Serde has a nice write-up on how to do it at [https://serde.rs/data-format.html](https://serde.rs/data-format.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Serde 提供惯用的序列化和反序列化，然而，讨论所有最佳实践将涵盖一个单独章节。如果你想深入了解这些内容，Serde 在 [https://serde.rs/data-format.html](https://serde.rs/data-format.html)
    上有一个很好的关于如何做到这一点的说明。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the constructor pattern* and *Providing a default implementation* recipes
    in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用构造函数模式* 和 *提供默认实现* 的配方在 [第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: '*Working with text files *recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml), *Handling
    Files and the Filesystem*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml)的“*处理文本文件*”中工作，*处理文件和文件系统*'
- en: Working with TOML
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 TOML 一起工作
- en: 'Do you like the simplicity of INI files but wish they were formally specified
    and had a few more features? So did Tom Preston-Werner, founder of services such
    as GitHub and Gravatar. He created Tom''s Obvious, Minimal Language, or TOML for
    short. This relatively new format is seeing increasing adoption in new projects.
    In fact, you have used it multiple times by now as well: Cargo''s dependencies
    are specified in every project''s `Cargo.toml` file!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢 INI 文件的简洁性，但希望它们有正式的规范并且有更多功能吗？汤姆·普雷斯顿-沃纳（GitHub 和 Gravatar 等服务的创始人）也是这样想的。他创建了汤姆的明显、最小化语言，简称
    TOML。这种相对较新的格式在新项目中越来越受欢迎。实际上，你现在已经多次使用它了：Cargo 的依赖关系在每一个项目的 `Cargo.toml` 文件中指定！
- en: Getting started
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'At its heart, TOML is all about *key-value* pairs. This is the simplest TOML
    file you can create:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，TOML 完全是关于 *键值* 对。这是你可以创建的最简单的 TOML 文件：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, the key message has the `"Hello World"` value. A value can also be an
    array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，键信息具有 `"Hello World"` 值。值也可以是一个数组：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A group of key-values is called a *table*. The following TOML lets the `smileys`
    table contain the `happy` key with the `":)"` value and the `sad` key with the `":("`
    value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一组键值被称为 *表*. 下面的 TOML 允许 `smileys` 表包含 `happy` 键和 `":)"` 值，以及 `sad` 键和 `":("`
    值：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A particularly small table can be *inlined*, that is, written in one line.
    The last example is the exact same as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别小的表可以 *内联*，也就是说，在一行中写出来。最后一个例子与以下内容完全相同：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Tables can be nested by separating their names with a dot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表可以通过用点分隔它们的名称来嵌套：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A nice property of TOML is that you can convert any key into a table if you
    need to specify additional information. For example, Cargo itself expects this
    when declaring dependency versions. For example, if you wanted to use `rocket_contrib`,
    a helper crate of the popular `rocket` web framework for Rust, at version 0.3.3,
    you would write this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 的一个优点是，如果你需要指定更多信息，你可以将任何键转换为表。例如，Cargo 本身期望在声明依赖版本时这样做。例如，如果你想使用 `rocket_contrib`，这是流行的
    Rust `rocket` 网络框架的辅助包，版本为 0.3.3，你会这样写：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, if you wanted to specify the exact features to be included in `rocket_contrib`,
    you would need to instead write it as a sub-table of `dependencies`. The following
    TOML would tell `Cargo` to use its JSON serialization feature:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要指定 `rocket_contrib` 中要包含的确切功能，你需要将其写成 `dependencies` 的子表。以下 TOML 会告诉
    `Cargo` 使用其 JSON 序列化功能：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another nice thing TOML brings to the table is that its whitespace is not significant,
    that is, you can indent a file however you want. You can even add comments by
    beginning a line with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 带来的另一个优点是它的空白不重要，也就是说，你可以按任何方式缩进文件。你甚至可以通过以下方式添加注释：从行的开头开始：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to explore the format further, the entirety of the TOML syntax is
    specified at [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进一步探索格式，TOML 语法的全部内容在 [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)
    中指定。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the `Cargo.toml` file that was generated earlier for you
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为你生成的 `Cargo.toml` 文件
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下添加以下行：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you haven''t done so already, add the following lines as well:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，也请添加以下行：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you want, you can go to the crates.io web pages for TOML ([https://crates.io/crates/toml](https://crates.io/crates/toml)),
    Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)), and
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    to check for the newest versions and use those ones instead
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以访问 TOML ([https://crates.io/crates/toml](https://crates.io/crates/toml))、Serde
    ([https://crates.io/crates/serde](https://crates.io/crates/serde)) 和 `serde_derive`
    ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    的 crates.io 网页，检查最新版本并使用这些版本。
- en: In the `bin` folder, create a file called `toml.rs`
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中创建一个名为 `toml.rs` 的文件
- en: 'Add the following code and run it with `cargo run --bin toml`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并使用 `cargo run --bin toml` 运行它：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are the structures we are going to use throughout the recipe:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是我们将在整个配方中使用的结构：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Prepare a new file and call the other functions:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个新的文件并调用其他函数：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Save our structures as a TOML file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的结构保存为 TOML 文件：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Read` the TOML file we just created:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`读取` 我们刚刚创建的 TOML 文件：'
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As always with Serde, we first need to declare the structures we plan on using
    [8 to 32].
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，使用 Serde，我们首先需要声明我们计划使用的结构 [8 to 32]。
- en: While serializing, we can directly call Serde's `to_string` method with a structure
    as TOML re-exports them [77]. This returns a `String` that we can then write into
    a file [79]. The same is true of Serde's `from_str`, which, when type-annotated,
    takes a `&str` and converts it into a structure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化过程中，我们可以直接调用 Serde 的 `to_string` 方法，因为 TOML 重新导出它们 [77]。这返回一个 `String`，然后我们可以将其写入文件
    [79]。Serde 的 `from_str` 也是如此，当类型注解时，它接受一个 `&str` 并将其转换为结构体。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed that we are not using the try-operator (`?`) while reading
    or writing in this recipe. This is because the function's expected error types,
    `se::Error` [77] and `de::Error`[93], are incompatible with `std::io::Error`.
    In [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml), *Handling Errors*;* Providing
    user-defined Error types*, we will explore how to avoid this by returning our
    own error type that encompasses the other ones mentioned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在阅读或编写此配方时我们没有使用 try-运算符（`?`）。这是因为函数期望的错误类型，`se::Error` [77] 和 `de::Error`[93]，与
    `std::io::Error` 不兼容。在[第6章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)，*处理错误*；*提供用户定义的错误类型*中，我们将探讨如何通过返回包含其他提到的错误类型的自己的错误类型来避免这种情况。
- en: The TOML crate used in this recipe is the same one that Cargo itself uses. If
    you are interested in how Cargo parses its own `Cargo.toml` file, you can check
    out [https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs](https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中使用的 TOML crate 与 Cargo 本身使用的相同。如果你对 Cargo 如何解析其自己的 `Cargo.toml` 文件感兴趣，可以查看
    [https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs](https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs)。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with* text *files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml)，*处理文件和文件系统*中的*处理文本文件*配方
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供用户定义的错误类型* 配方在 [第6章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)，*处理错误*'
- en: Working with JSON
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON
- en: Most Web APIs and many native APIs speak JSON nowadays. It should be your format
    of choice when designing data meant for consumption by other programs, as it is
    lightweight, simple, easy to use and understand, and has excellent library support
    across programming languages, most notably JavaScript, of course.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Web API 和许多本地 API 现在都使用 JSON。当设计供其他程序消费的数据时，它应该是你的首选格式，因为它轻量级、简单、易于使用和理解，并且在各种编程语言中都有出色的库支持，尤其是
    JavaScript。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'JSON was created at a time when most web communication was done by sending
    XML over browser plugins such as Java or Flash. This was cumbersome and made the
    exchanged information quite bloated. Douglas Crockford, the creator of JSLint
    and author of the famous *JavaScript: The Good Parts*, decided in the early 2000s
    that it was time for a lightweight format that was easily integrated with JavaScript.
    He oriented himself on a small subset of JavaScript, namely the way it defined
    objects, and extended it a little bit to form the JavaScript Object Notation or
    JSON. Yes, you''ve read that right; JSON is *not* a subset of JavaScript, as it
    accepts things that JavaScript doesn''t. You can read more about that at [http://timelessrepo.com/json-isnt-a-javascript-subset.](http://timelessrepo.com/json-isnt-a-javascript-subset)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON 是在大多数 Web 通信通过发送 XML 通过 Java 或 Flash 等浏览器插件完成的时候被创建的。这很麻烦，并且使得交换的信息相当庞大。JSLint
    的创造者、著名作品《JavaScript: The Good Parts》的作者 Douglas Crockford 在 2000 年初决定，是时候有一个轻量级且易于与
    JavaScript 集成的格式了。他将自己定位在 JavaScript 的小子集上，即它定义对象的方式，并在此基础上稍作扩展，形成了 JavaScript
    对象表示法或 JSON。是的，你没有看错；JSON *不是* JavaScript 的子集，因为它接受 JavaScript 不接受的事物。你可以在 [http://timelessrepo.com/json-isnt-a-javascript-subset.](http://timelessrepo.com/json-isnt-a-javascript-subset)
    上了解更多关于这一点。'
- en: 'The sad irony of the story is that today we have gone full-circle: our best
    practices for web development include a labyrinth of task runners, frameworks,
    and transpilers, which are all quite nice in theory but end up being a giant bloated
    mess in the end. But that is a story for another time.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事悲哀的讽刺之处在于，今天我们已经回到了原点：我们最好的 Web 开发实践包括一个错综复杂的任务运行器、框架和转换器迷宫，这些在理论上都很不错，但最终却变成了一个庞大的混乱。但这又是另一个故事了。
- en: 'JSON is built upon two structures:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 建立在两种结构之上：
- en: A group of key-value pairs surrounded by `{` and `}`, which is called an *object*
    and can be a value itself
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `{` 和 `}` 包围的一组键值对，这被称为 *对象*，它本身也可以是一个值
- en: A list of values surrounded by `[` and `]` called an *array*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被称为 *数组* 的由 `[` 和 `]` 包围的值列表
- en: This might remind you a bit of the TOML syntax we discussed earlier, and you
    might ask yourself when you should prefer one over the other. The answer is that
    JSON is a good format when your data is going to be read automatically by a tool,
    while TOML is excellent when your data is meant to be read and modified manually
    by a human.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你想起我们之前讨论的 TOML 语法，你可能会问自己在什么情况下应该选择其中一个。答案是，当你的数据将要被工具自动读取时，JSON 是一个好的格式，而当你的数据旨在由人类手动读取和修改时，TOML
    是出色的。
- en: Take note that one thing that JSON *doesn't* allow is comments. This makes sense,
    as comments are not readable by tools anyway.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON *不允许* 注释。这很有道理，因为注释无论如何都是不可读的。
- en: 'An example of a JSON object with values, sub-objects, and arrays could be the
    following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含值、子对象和数组的 JSON 对象示例可能是以下内容：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are going to write and read this exact example in the following code. The
    definitions of the pets are intentionally inconsistent because many web APIs omit
    certain keys in some situations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的代码中编写和读取这个精确的示例。宠物定义的不一致性是有意为之的，因为许多 Web API 在某些情况下会省略某些键。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that has been generated earlier for you
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you haven''t done so already, add the following lines as well:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，也请添加以下行：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want, you can go to the crates.io web pages for `serde_json` ([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json)),
    Serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)), and
    `serde_derive` ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    to check for the newest versions and use those ones instead
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想的话，你可以访问 `serde_json` ([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json))、Serde
    ([https://crates.io/crates/serde](https://crates.io/crates/serde)) 和 `serde_derive`
    ([https://crates.io/crates/serde_derive](https://crates.io/crates/serde_derive))
    的 crates.io 网页，检查最新版本并使用这些版本。
- en: In the `bin` folder, create a file called `json.rs`
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`json.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin json`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin json`运行：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are the structures we are going to use throughout the recipe:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是我们将在整个食谱中使用的结构：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Prepare a new file and call the other functions:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个新的文件并调用其他函数：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save our structures as a JSON file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的结构保存为JSON文件：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Read the JSON file we just created:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取我们刚刚创建的JSON文件：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Notice how this recipe looks nearly identical to the last one? Except for the
    structures, the only significant difference is that we called `serde_json::to_string()`
    [81] instead of `toml::to_string()`, and `serde_json::from_str()` [96] instead
    of `toml::from_str()`. This is the beauty of a well-thought-out framework like
    Serde: the custom serialization and deserialization code are hidden behind trait
    definitions and we can use the same API without caring about internal implementation
    details.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个食谱看起来几乎和上一个完全一样？除了结构，唯一的显著区别是我们调用了`serde_json::to_string()` [81]而不是`toml::to_string()`，以及`serde_json::from_str()`
    [96]而不是`toml::from_str()`。这正是像Serde这样的精心设计的框架的美丽之处：自定义序列化和反序列化代码隐藏在特质定义之后，我们可以使用相同的API而不必关心内部实现细节。
- en: Other than that, there is nothing to say that hasn't been said in the previous
    recipe, which is why we are not going to go over any other formats. All important
    formats support Serde, so you can use them the exact same way you use the other
    formats in this chapter. For a full list of all supported formats, see [https://docs.serde.rs/serde/index.html](https://docs.serde.rs/serde/index.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，没有其他需要说的，因为之前已经说过了，所以我们不会介绍其他格式。所有重要的格式都支持Serde，所以你可以像使用本章中的其他格式一样使用它们。有关所有支持格式的完整列表，请参阅[https://docs.serde.rs/serde/index.html](https://docs.serde.rs/serde/index.html)。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: JSON has no concept of something resembling an `enum`. As many languages *do*
    work with them, however, multiple conventions on how to handle the conversion
    from JSON into `enum` have emerged over the years. Serde allows you to support
    these conventions with annotations on your enums. For a full list of supported
    conversions, visit [https://serde.rs/enum-representations.html](https://serde.rs/enum-representations.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JSON没有类似`enum`的概念。然而，由于许多语言*确实*使用它们，多年来已经出现了多种处理从JSON到`enum`转换的约定。Serde允许你通过枚举上的注解来支持这些约定。有关支持的转换的完整列表，请访问[https://serde.rs/enum-representations.html](https://serde.rs/enum-representations.html)。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with text* *files* recipe in [Chapter 3](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml),
    *Handling Files and the Filesystem*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](6c3fb839-4c52-4c58-a2f9-183220f7a3be.xhtml)的*处理文本文件*食谱中，*处理文件和文件系统*
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)的*处理错误*食谱中，*提供用户定义的错误类型*
- en: Building JSON dynamically
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态构建JSON
- en: When a JSON API is designed with a poorly-thought-out schema and inconsistent
    objects, you might end up with giant structures where most members are an `Option`.
    If you find yourself only sending data to such a service, it might be a bit easier
    to dynamically build your JSON property by property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个JSON API使用一个考虑不周到的模式和不一致的对象设计时，你可能会得到一个大多数成员都是`Option`的巨大结构。如果你发现自己只向这样的服务发送数据，那么动态地逐个构建你的JSON属性可能会容易一些。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `Cargo.toml` file that was generated earlier for you
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件
- en: 'Under `[dependencies]`, if you haven''t done so already, add the following
    line:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`部分，如果你还没有这样做，请添加以下行：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you want, you can go to the `serde_json` crates.io web page ([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json))
    to check for the newest version and use that one instead
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以访问`serde_json`的crates.io网页([https://crates.io/crates/serde_json](https://crates.io/crates/serde_json))来检查最新版本，并使用那个版本
- en: In the `bin` folder, create a file called `dynamic_json.rs`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`dynamic_json.rs`的文件
- en: 'Add the following code and run it with `cargo run --bin dynamic_json`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin dynamic_json`运行：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, the user can enter any number of key-value pairs until they
    decide to stop, at which point they receive their input back in the form of JSON.
    Some example input you could enter could include:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户可以输入任意数量的键值对，直到他们决定停止，此时他们会以JSON的形式收到他们的输入。你可以输入的一些示例输入包括：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use `#[cfg(target_os = "some_operating_system")]` to handle operating system
    specific circumstances. In this recipe, we use this to conditionally compile the
    `END_OF_TRANSMISSION` constant differently on Windows than on Unix. This key combination
    tells the OS to stop the current input stream.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#[cfg(target_os = "some_operating_system")]` 来处理特定于操作系统的环境。在这个配方中，我们使用它来有条件地编译
    `END_OF_TRANSMISSION` 常量，在 Windows 上与 Unix 上不同。这个键组合告诉操作系统停止当前输入流。
- en: This program begins with the idea that a JSON object without a clearly defined
    schema is nothing but a `HashMap<String, String>`[9]. Now, `serde_json` doesn't
    accept a `String` as a value, as that would not be general enough. Instead, it
    wants a `serde_json::Value`, which you can easily construct by calling the `json!`
    macro on pretty much any type [20].
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的想法是，一个没有明确定义模式的 JSON 对象不过是一个 `HashMap<String, String>`[9]。现在，`serde_json`
    不接受 `String` 作为值，因为这不够通用。相反，它需要一个 `serde_json::Value`，你可以通过在几乎任何类型上调用 `json!`
    宏来轻松构建 [20]。
- en: When we are done, we don't call `serde_json::to_string()` as before, but use
    `serde_json::to_string_pretty()` instead [28], as this results in a less efficient
    but much more readable JSON. Remember, JSON is not supposed to be primarily read
    by humans, which is why the default way Serde serialized it is without any whitespace
    whatsoever. If you're curious about the exact difference, feel free to go ahead
    and change `to_string_pretty()` to `to_string()` and compare the results.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们不再像以前那样调用 `serde_json::to_string()`，而是使用 `serde_json::to_string_pretty()`
    [28]，因为这会产生效率较低但可读性更强的 JSON。记住，JSON 并不主要是供人类阅读的，这就是为什么 Serde 序列化它的默认方式是完全不带任何空白的。如果你对确切差异感到好奇，可以随意将
    `to_string_pretty()` 改为 `to_string()` 并比较结果。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Reading from stdin* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从标准输入读取* 的配方在 [第 1 章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: '*Access collections as Iterators* and *Using a HashMap* recipe in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为迭代器访问集合* 和 *使用 HashMap* 的配方在 [第 2 章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)，*与集合一起工作*'
