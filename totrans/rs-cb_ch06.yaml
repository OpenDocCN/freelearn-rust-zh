- en: Efficient Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的错误处理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing panic
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现panic
- en: Implementing Option
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Option
- en: Creating map combinator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建map组合器
- en: Creating and_then combinator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建and_then组合器
- en: Creating map for the Result type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Result类型创建map
- en: Implementing aliases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现别名
- en: Handling multiple errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个错误
- en: Implementing early returns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现早期返回
- en: Implementing the try! macro
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现try!宏
- en: Defining your own error types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自己的错误类型
- en: Implementing the boxing of errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现错误装箱
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Error handling is a fundamental part of all programming languages. It is the
    way in which a developer prepares for the worst conditions by noticing and managing
    errors due to which the application could fail. These error conditions can occur
    due to various reasons, such as wrong input provided at runtime and more. In this
    chapter, we will cover various methods using which we can efficiently handle errors
    in Rust. We'll also check out the standard library that helps avoid problematic
    situations and thus avoid a complete failure of the Rust application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是所有编程语言的基本部分。它是开发者通过注意到并管理可能导致应用程序失败的错误来为最坏的情况做准备的方式。这些错误条件可能由于各种原因而发生，例如在运行时提供的错误输入等。在本章中，我们将介绍使用Rust高效处理错误的各种方法。我们还将检查标准库，它有助于避免问题情况，从而避免Rust应用程序的完全失败。
- en: Implementing panic
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现panic
- en: Panic is the simplest error handling mechanism provided by Rust. It prints the
    error messages given to it, starts to unwind the task, and usually exits the program
    execution. In this recipe, we will explicitly call out a `panic` statement in
    the face of an undesired case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Panic是Rust提供的最简单的错误处理机制。它打印给它的错误消息，开始回滚任务，并通常退出程序执行。在本食谱中，我们将明确调用一个`panic`语句来面对不期望的情况。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the ensuing steps to get through this recipe:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此食谱：
- en: Create a file named `sample_panic.rs` and open it in your text editor.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_panic.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `compare_stmt` function; it accepts a string input:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`compare_stmt`函数；它接受一个字符串输入：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `main` function; it calls the `compare_stmt` function with different
    input:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数；它使用不同的输入调用`compare_stmt`函数：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码成功执行时，您将得到以下输出：
- en: '![](img/e399cede-55ef-43bc-aba5-1e7800e6fa64.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e399cede-55ef-43bc-aba5-1e7800e6fa64.png)'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have a function named `compare_stmt` that accepts an `str` variable as an
    argument and assigns it to a variable named `input` in its scope. It later checks
    whether the string value is `Another Book`. If it is, it calls the `panic!` function;
    otherwise, it prints the value that was passed. We passed two values from the
    main function: `Rust CookBook` and `` `Another Book` ``.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`compare_stmt`的函数，它接受一个`str`变量作为参数，并将其分配给它作用域中的名为`input`的变量。然后它检查字符串值是否为`Another
    Book`。如果是，它调用`panic!`函数；否则，它打印传递的值。我们从主函数传递了两个值：`Rust CookBook`和`Another Book`。
- en: When we run the preceding program, the first input will fail the `if` condition
    and will not invoke panic, so we get the print statement working. However, for
    the second input, which satisfies the `if` condition, panic is invoked and it
    returns `thread 'main' panicked at 'Rust Cookbook is not selected!!!!', sample_panic.rs:12`
    and exits the program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的程序时，第一个输入将失败`if`条件，不会调用panic，因此打印语句正常工作。然而，对于满足`if`条件的第二个输入，panic被调用，并返回`thread
    'main' panicked at 'Rust Cookbook is not selected!!!!', sample_panic.rs:12`并退出程序。
- en: Implementing Option
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Option
- en: Panic handles cases where there are identified instances of undesired input,
    but it does not handle zero input. For that, we have the `Option<T>` type, an
    `enum` from the standard library that you can use to handle cases where you have
    no input. In this recipe, you will learn the different ways in which you can use
    Options to handle zero case input.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Panic处理已识别的不期望输入的情况，但它不处理零输入。为此，我们有`Option<T>`类型，这是一个来自标准库的`enum`，您可以使用它来处理没有输入的情况。在本食谱中，您将学习如何使用Options以不同的方式处理零输入情况。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the ensuing steps to get through this recipe:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此菜谱：
- en: Create a file named `sample_option.rs` and open it in your text editor.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_option.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `compare_stmt_match` function; it accepts the `input` string of
    the `Option<&str>` type:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`compare_stmt_match`函数；它接受`Option<&str>`类型的`input`字符串：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, create the `compare_stmt_unwrap` function; it also accepts the `input`
    string of the `Option<&str>` type:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建`compare_stmt_unwrap`函数；它也接受`Option<&str>`类型的`input`字符串：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the `main` function; it calls the two functions with different input:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数；它使用不同的输入调用两个函数：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行代码后，您将得到以下输出：
- en: '![](img/da4d8747-d2ab-4086-bcf9-28b28b645e7f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da4d8747-d2ab-4086-bcf9-28b28b645e7f.png)'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding recipe, we knew we had to exit the program using `panic!`
    in the case of an undesired input, but the main problem we are trying to solve
    in this recipe is the way by which we can handle `None` input. We use the Rust
    standard library to address this problem. More specifically, we use an `enum`
    called `Option<T>` from the `std` library, which is used when there is no input:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们知道在输入不期望的情况下，我们必须使用`panic!`退出程序，但在这个菜谱中我们试图解决的主要问题是处理`None`输入的方式。我们使用Rust标准库来解决这个问题。更具体地说，我们使用来自`std`库的名为`Option<T>`的`enum`，它在没有输入时使用：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has two options, namely:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个选项，即：
- en: '`Some(T)`: This is an element of the type `T` that was sent'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(T)`：这是发送的类型`T`的元素'
- en: '`None`: This refers to the case where there was no input'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：这指的是没有输入的情况'
- en: 'We handle these cases in two ways: the explicit way of handling in which we
    use `match` and the implicit way in which we use `unwrap`. The implicit way of
    handling returns the inner element of either `enum` or `panic!`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以两种方式处理这些情况：使用`match`的显式处理方式和使用`unwrap`的隐式处理方式。隐式处理方式返回`enum`或`panic!`的内部元素。
- en: 'In the explicit way of handling, we declared three variables, namely `Desired_Book`,
    `Another_Book`, and `Empty_value` in the `main` function. We assigned them with
    book names, which were `Rust Cookbook`, `Another Book`, and `` `None` ``, respectively.
    Post this, we called the functions in the following manner:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式处理方式中，我们在`main`函数中声明了三个变量，分别是`Desired_Book`、`Another_Book`和`Empty_value`。我们分别将它们赋值为书名，即`Rust
    Cookbook`、`Another Book`和`None`。之后，我们以以下方式调用函数：
- en: '`compare_stmt_match(Desired_Book)`: This satisfies the match statement condition
    `Some("Rust CookBook")` to print `Rust CookBook was selected`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_stmt_match(Desired_Book)`：这满足了`match`语句条件`Some("Rust CookBook")`以打印`Rust
    CookBook was selected`'
- en: '`compare_stmt_match(Another_Book)`: This satisfies the `match` statement condition
    `Some(inner)` to print `"Rust CookBook not selected"`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_stmt_match(Another_Book)`：这满足了`match`语句条件`Some(inner)`以打印`"Rust CookBook
    not selected"`'
- en: '`compare_stmt_match(Empty_val)`: This satisfies the `match` statement condition
    `None` to print `No input provided`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_stmt_match(Empty_val)`：这满足了`match`语句条件`None`以打印`No input provided`'
- en: In implicit handling, we created `Rand_Book` and `No_val` with the values `Some("Random
    Book")` and `None`, respectively. We call another function that uses unwrap to
    handle `Some(T)` and `None` values. The `compare_stmt_unwrap(Rand_Book)` used
    `unwrap` to get `inside_val`, which successfully called the print statement; on
    the second function call `compare_stmt_unwrap(No_val)`, we got ``thread 'main'
    panicked at 'called `Option::unwrap()` on a `None` value', ../src/libcore/option.rs:323``.
    This was because `unwrap` returns a panic when we have `None` as the inner value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式处理中，我们使用`Some("Random Book")`和`None`的值创建了`Rand_Book`和`No_val`。我们调用另一个函数来处理`Some(T)`和`None`值。`compare_stmt_unwrap(Rand_Book)`使用`unwrap`获取`inside_val`，成功调用了打印语句；在第二次函数调用`compare_stmt_unwrap(No_val)`时，我们得到了`thread
    'main' panicked at 'called `Option::unwrap()` on a `None` value', ../src/libcore/option.rs:323`。这是因为`unwrap`在内部值为`None`时返回panic。
- en: Creating map combinator
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建映射组合器
- en: We will learn about the map combinator in this recipe, which again is a combinator
    for handling `Option` types. The `Option` has an inbuilt map method for simple
    mapping of `Some(T)` to another valid type; it can also handle the mapping of
    none values. The `map` is a great way to explicitly handle `None` case input.
    It also simplifies the code as it can be used multiple times. Combinators, in
    general, are high-order functions that apply only the functions and the combinators
    defined earlier to provide a result from their arguments. They are generally used
    to control the flow in a modular fashion in an application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习map组合子，它再次是一个用于处理`Option`类型的组合子。`Option`有一个内置的map方法，用于简单地将`Some(T)`映射到另一个有效类型；它也可以处理none值的映射。`map`是一个处理`None`情况输入的好方法。它还简化了代码，因为它可以被多次使用。组合子通常是一阶函数，它们只应用之前定义的函数和组合子，从它们的参数中提供结果。它们通常用于以模块化的方式控制应用程序中的流程。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_map.rs` and open it in your text editor.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_map.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a user-defined data type to use the program:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用户定义的数据类型来使用程序：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `peel` function; it accepts the `Option<Food>` type input and returns
    `Option<Peeled>`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`peel`函数；它接受`Option<Food>`类型的输入并返回`Option<Peeled>`：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the `chop` function; it accepts the `Option<Peeled>` type input and
    returns `Option<Chopped>`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`chop`函数；它接受`Option<Peeled>`类型的输入并返回`Option<Chopped>`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `cook` function; it accepts the `Option<Chopped>` type input and
    returns `Option<Cooked>`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`cook`函数；它接受`Option<Chopped>`类型的输入并返回`Option<Cooked>`：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the `process` function; it accepts the `Option<Food>` type input and
    returns `Option<Cooked>`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`process`函数；它接受`Option<Food>`类型的输入并返回`Option<Cooked>`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the `eat` function; it accepts the `Option<Cooked>` type input:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`eat`函数；它接受`Option<Cooked>`类型的输入：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the `main` function where we can create the different types of input
    to understand the working of the map combinator:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数，在那里我们可以创建不同类型的输入来理解map组合子的工作：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/21819b41-85ef-4299-b15b-01dc5bfc7f9e.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21819b41-85ef-4299-b15b-01dc5bfc7f9e.png)'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first created an `enum` type named `Food` that had data elements, namely
    `Apple`, `Carrot`, and `Potato`. Then we created three `struct` with user-defined
    data types, namely `Peeled`, `Chopped`, and `Cooked` with `Food` as a data field.
    In the `main` function, we created three variables and assigned them to the values
    of the `Option` data, where `apple` was valued `Food::Apple`, `carrot` as `Food::Carrot`,
    and `potato` as `None`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个名为`Food`的`enum`类型，它有数据元素，即`Apple`、`Carrot`和`Potato`。然后我们创建了三个具有用户定义数据类型的`struct`，即`Peeled`、`Chopped`和`Cooked`，其中`Food`作为数据字段。在`main`函数中，我们创建了三个变量并将它们分配给`Option`数据的值，其中`apple`的值为`Food::Apple`，`carrot`为`Food::Carrot`，`potato`为`None`。
- en: 'Now let''s check out how our function units react to different input:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的函数单元对不同输入的反应：
- en: '`peel`: This function takes in an `Option` type that has a field `enum` type
    `Food` along with the data and returns an `Option` of the `struct` data type `Peeled`.
    Here we use the `match` function to change the type.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peel`：这个函数接收一个包含字段`enum`类型`Food`以及数据的`Option`类型，并返回一个`struct`数据类型`Peeled`的`Option`。在这里，我们使用`match`函数来改变类型。'
- en: '`chop`: This function takes in the `Option` type that has a field `enum` type
    `Peeled` along with the data and returns an `Option` of the `struct` data type
    `Chopped`. Here we use the `match` function to change the type.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chop`：这个函数接收一个包含字段`enum`类型`Peeled`以及数据的`Option`类型，并返回一个`struct`数据类型`Chopped`的`Option`。在这里，我们使用`match`函数来改变类型。'
- en: '`cook`: This function takes in the `Option` type that has a field `enum` type
    `Chopped` along with the data and returns an `Option` of the `struct` data type
    `Cooked`. Here we use the `map` function to change the type, where we place the
    input type between two pipe symbols that convert them into the desired form.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cook`：这个函数接收一个包含字段`enum`类型`Chopped`以及数据的`Option`类型，并返回一个`struct`数据类型`Cooked`的`Option`。在这里，我们使用`map`函数来改变类型，我们将输入类型放在两个管道符号之间，将它们转换为所需的形式。'
- en: '`process`: Instead of having three functions to change types, we use map multiple
    times to convert `Option<Food>` into `Option<Cooked>` directly, where each map
    function successively converts the type to the desired form by this process we
    can peel, chop, and cook `food` type in a sequence by using multiple `map()`,
    thus it simplifies the code.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process`：我们不是使用三个函数来改变类型，而是多次使用 `map` 来直接将 `Option<Food>` 转换为 `Option<Cooked>`，其中每个
    `map` 函数依次通过这个过程将类型转换为所需的形式，通过多次使用 `map()`，我们可以按顺序剥皮、切和烹饪 `food` 类型，从而简化代码。'
- en: '`eat`: This function takes in the `Option<Cooked>` type as an input argument
    and checks it using a `match` statement. The first case `some(food)` would be
    true if a valid type exists for the `food` argument which is passed to the `match`
    statement, then it would print the value of the argument `food` in the place holder
    of the print statement else in the `None` case, it prints a default statement.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eat`：这个函数接受 `Option<Cooked>` 类型作为输入参数，并使用 `match` 语句进行检查。如果传递给 `match` 语句的
    `food` 参数存在有效类型，则第一个情况 `some(food)` 为真，然后它会打印出 `print` 语句中的 `food` 参数的值，否则在 `None`
    情况下，它会打印一个默认语句。'
- en: In the `main` function, we declared `cooked_apple` and assigned the return value
    of the `chop(peel(apple))` call. Since we didn't pass a `None` input, this was
    supposed to return the `Cooked(apple)` type of the data feed. Similarly, `cooked_carrot`
    had the value `Cooked(carrot)`; however, `cooked_potato`, for which we called
    the `process` function, returned `None`. Later, when we called the `eat` function,
    only the variable that had `Cooked` `struct` values got printed as `MM. I Love
    statement` and the variable that had `None` had `Oh No! statement`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们声明了 `cooked_apple` 并将 `chop(peel(apple))` 调用的返回值赋给它。由于我们没有传递
    `None` 输入，这应该返回数据源中的 `Cooked(apple)` 类型。同样，`cooked_carrot` 有 `Cooked(carrot)`
    的值；然而，对于 `cooked_potato`，我们调用了 `process` 函数，它返回了 `None`。后来，当我们调用 `eat` 函数时，只有具有
    `Cooked` `struct` 值的变量被打印为 `MM. I Love` 语句，而具有 `None` 的变量则打印为 `Oh No!` 语句。
- en: Creating and_then combinator
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 and_then 组合器
- en: The problem with `map` is that it can get confusing when we have too many functions
    returning maps. This is because the result will be nested in the `Option<Option<T>>`
    format, and this gets complicated and confusing on multiple calls of the map combinator.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 的问题在于，当我们有太多函数返回 `map` 时，它可能会变得令人困惑。这是因为结果将嵌套在 `Option<Option<T>>` 格式中，在多次调用
    `map` 组合器时，这会变得复杂且令人困惑。'
- en: Rust provides another combinator, namely `and_then()`, which solves the preceding
    problem by only returning the result instead. It does it by flattening the chained
    results to a single type. In this recipe, you will learn how to use this combinator
    in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了另一个组合器，即 `and_then()`，它通过仅返回结果来解决上述问题。它是通过将链式结果展平为单个类型来实现的。在这个菜谱中，你将详细了解如何使用这个组合器。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_and_then.rs` and open it in your text editor.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_and_then.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `enum` types `Food` and `Day`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `Food` 和 `Day` 的 `enum` 类型：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define a function named `have_ingredients` that will accept the `Food` type
    as an input argument and return `Option<Food>`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `have_ingredients` 的函数，它将接受 `Food` 类型作为输入参数并返回 `Option<Food>`：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define a function named `have_recipe` that will accept the `Food` type as an
    input argument and return `Option<Food>`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `have_recipe` 的函数，它将接受 `Food` 类型作为输入参数并返回 `Option<Food>`：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define a function named `cookable` that will accept the `Food` type as an input
    argument and return `Option<Food>`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `cookable` 的函数，它将接受 `Food` 类型作为输入参数并返回 `Option<Food>`：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define a function named `eat` that will accept the `Food` type as an input
    argument and return `Day`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `eat` 的函数，它将接受 `Food` 类型作为输入参数并返回 `Day`：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the `main` function; it will initialize and call all the functions:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数；它将初始化并调用所有函数：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你将得到以下输出：
- en: '![](img/6fe0fca8-1379-4550-8249-0cac73518195.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fe0fca8-1379-4550-8249-0cac73518195.png)'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We declared two `enum` types, namely `Food` and `Day`, where we had these elements:
    `CordonBleu`, `Steak`, and `Sushi` and `Monday`, `Tuesday`, and `Wednesday`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个`enum`类型，即`Food`和`Day`，其中包含以下元素：`CordonBleu`、`Steak`和`Sushi`以及`Monday`、`Tuesday`和`Wednesday`。
- en: 'Now let''s see how our function units react to different input:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的函数单元如何对不同输入做出反应：
- en: '`have_ingredients`: This function takes in the `enum` input `Food` and returns
    `Option<Food>`. It has a case in its `match` statement indicating whether `Food`
    has the value `Sushi` in that it returns `None` and for all other values, it returns
    the same `Food` value.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`have_ingredients`：这个函数接受`enum`输入`Food`并返回`Option<Food>`。在其`match`语句中有一个情况，表示`Food`是否有值`Sushi`，如果是，则返回`None`；对于所有其他值，它返回相同的`Food`值。'
- en: '`have_recipe`: This function takes in the `enum` input `Food` and returns `Option<Food>`.
    It has a case in its `match` statement indicating whether `Food` has the value
    `CordonBleu` in that it returns `None`; for all other values, it returns the same
    `Food` value.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`have_recipe`：这个函数接受`enum`输入`Food`并返回`Option<Food>`。在其`match`语句中有一个情况，表示`Food`是否有值`CordonBleu`，如果是，则返回`None`；对于所有其他值，它返回相同的`Food`值。'
- en: '`cookable`: This function takes in the `enum` input `Food` and returns `Option<Food>`.
    Here, we use the `and_then` combinator to check the `have_ingredients` and `have_recipe`
    functions in order to confirm that the `Food` type will pass these cases.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookable`：这个函数接受`enum`输入`Food`并返回`Option<Food>`。在这里，我们使用`and_then`组合器来检查`have_ingredients`和`have_recipe`函数，以确认`Food`类型将通过这些情况。'
- en: '`eat`: This function takes the `enum` input `Food` and `Day` and sends the
    `Food` value to the `cookable` function. Here we have a `match` statement that
    prints the day and `Food` type in the case of `Some(Food)` from the `cookable`
    function.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eat`：这个函数接受`enum`输入`Food`和`Day`，并将`Food`值发送到`cookable`函数。在这里，我们有一个`match`语句，当`cookable`函数返回`Some(Food)`时，它会打印出日期和`Food`类型。'
- en: We observe that for `cookable` to return a value, we need both the functions
    `have_ingredients` and `have_` recipe to return `Some(Food)`, which happens only
    in the case of `Steak`. In the `main` function, we called the `eat` function with
    all the values of `Food` and `Day`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到，为了让`cookable`返回一个值，我们需要`have_ingredients`和`have_recipe`函数都返回`Some(Food)`，这只有在`Steak`的情况下才会发生。在`main`函数中，我们用`Food`和`Day`的所有值调用了`eat`函数。
- en: Creating map for the Result type
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`Result`类型创建映射
- en: 'The `Result` type is similar to the `Option` type, but it offers more, as it
    also describes the possible error. This means we will have two outcomes: one where
    the desired element is found and the other where we may have found an error with
    an element. In this recipe, we will use the `map` method of `Result` to return
    a specific error.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类型与`Option`类型相似，但它提供了更多功能，因为它还描述了可能的错误。这意味着我们将有两种结果：一种是找到所需元素的情况，另一种是可能找到元素错误的情况。在这个菜谱中，我们将使用`Result`的`map`方法来返回特定的错误。'
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_map_result.rs` and open it in your text editor.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_map_result.rs`的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the standard library:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a function named `double_number` that will accept the `str` input and
    return a `Result<T>` type:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`double_number`的函数，它将接受`str`输入并返回`Result<T>`类型：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a function named `double_number_map` that will accept the `str` input
    and return a `Result<T>` type:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`double_number_map`的函数，它将接受`str`输入并返回`Result<T>`类型：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a function named `print` that will accept a `Result<T>` type as input:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print`的函数，它将接受`Result<T>`类型作为输入：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the `main` function and declare different input for different functions:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并为不同的函数声明不同的输入：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你会得到以下输出：
- en: '![](img/8614b77b-4a21-406c-9ca7-2506ddc273cf.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8614b77b-4a21-406c-9ca7-2506ddc273cf.png)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Panicking gives us only an error message, which is not of great use for being
    more specific regarding the return type and the error. We have the `Result` type,
    which is similar to Options, but it can also be used to mention the error type.
    In this recipe, we used the map method of Rust to get the specific error type.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在错误只提供了一个错误消息，这对于更具体地说明返回类型和错误没有太大帮助。我们有 `Result` 类型，它与 Options 类似，但也可以用来提及错误类型。在这个菜谱中，我们使用了
    Rust 的 map 方法来获取特定的错误类型。
- en: First, we called the standard library error type `ParseIntError`, which we used
    for returning error types as per the `Result` type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用了标准库的错误类型 `ParseIntError`，我们按照 `Result` 类型的要求使用它来返回错误类型。
- en: 'Let''s check out the different functional units in the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码中的不同功能单元：
- en: '`print`: This function takes in an input type of `Result<i32, ParseIntError>`,
    and based on its value, whether it is `Ok` or `Err`, prints the corresponding
    statements.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 这个函数接收一个 `Result<i32, ParseIntError>` 类型的输入，并根据其值，即它是否为 `Ok` 或 `Err`，打印相应的语句。'
- en: '`double_number_map`: This function takes in the `str` input and returns `Result<i32,
    ParseIntError>`. It parses the string to a value, and if it is a valid integer,
    we use the `map` function to multiply the input value by 2; else, we have the
    `Err` case.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_number_map`: 这个函数接收一个 `str` 类型的输入，并返回 `Result<i32, ParseIntError>`。它将字符串解析为值，如果是有效的整数，我们使用
    `map` 函数将输入值乘以 2；否则，我们得到 `Err` 情况。'
- en: '`double_number`: This function takes in the `str` input and returns `Result<i32,
    ParseIntError>`, where it has a `match` statement where it parses the string to
    a value. If it is a valid integer, it satisfies the `Ok` case and the value is
    multiplied by two if an `Err` case occurs.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_number`: 这个函数接收一个 `str` 类型的输入，并返回 `Result<i32, ParseIntError>`，其中包含一个
    `match` 语句，它将字符串解析为值。如果是有效的整数，它满足 `Ok` 情况，并且值被乘以两倍；如果发生 `Err` 情况。'
- en: '`print`: This function takes in `Result<i32, ParseIntError>`; using the `match`
    statement, we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 这个函数接收 `Result<i32, ParseIntError>` 类型的输入；使用 `match` 语句，我们检查是否有 `Ok`
    或 `Err` 情况以打印相应的语句。'
- en: In the `main` function, we had two variables, namely `twenty` and `tt`, assigned
    to `double_number("10")` and `double_number_map("t")`, respectively. When we called
    `double_number function` for `twenty`, it returned an integer value, but `double_number_map`
    returned an error for `t`. The print statement printed the final value of these
    `Result` type variables. In the case of passing a string to the`double_number`
    method that can't be parsed to integer will result in the `ParseIntError` and
    a valid integer argument of string type will result in double its value for `double_number_map`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们有两个变量，即 `twenty` 和 `tt`，分别被分配给 `double_number("10")` 和 `double_number_map("t")`。当我们为
    `twenty` 调用 `double_number` 函数时，它返回一个整数值，但 `double_number_map` 为 `t` 返回了一个错误。打印语句打印了这些
    `Result` 类型变量的最终值。如果将字符串传递给无法解析为整数的 `double_number` 方法，将导致 `ParseIntError`，而对于字符串类型的有效整数参数，`double_number_map`
    将将其值加倍。
- en: Implementing aliases
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现别名
- en: We use aliases in order to reuse a specific type multiple times. Rust allows
    us to create aliases of the `Result` type and more types in order to reuse them
    across the program. At the module level, this is really helpful as we can identify
    similar kinds of bugs and errors from the units/items of the module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用别名是为了多次重用特定的类型。Rust 允许我们创建 `Result` 类型的别名以及更多类型，以便在整个程序中重用它们。在模块级别，这非常有用，因为我们可以从模块的单元/项中识别出类似类型的错误和错误。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_aliases_result.rs` and open it in your text editor.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_aliases_result.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头部，包含相关信息：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Call the standard library:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a generic alias named `AliasedResult<T>` for the `Result` type:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `AliasedResult<T>` 的泛型别名，用于 `Result` 类型：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a function named `double_number` that will accept the `str` input and
    return an `AliasedResult<i32>` type:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `double_number` 的函数，它将接受 `str` 类型的输入并返回 `AliasedResult<i32>` 类型的输出：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a function named `print` that will accept an `AliasedResult<i32>` type
    as input:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print` 的函数，它将接受 `AliasedResult<i32>` 类型的输入：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用不同的函数：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/130a1552-7c90-42b0-af61-7d5ba2759561.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/130a1552-7c90-42b0-af61-7d5ba2759561.png)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Aliases work in a fairly simple manner. Its main role is to ease the usage of
    a particular type and maintain different types across different modules.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 别名以相当简单的方式工作。其主要作用是简化特定类型的用法，并在不同模块中维护不同类型。
- en: In this recipe, we used the `type` keyword to create an alias for `Result<T,
    ParseIntError>` as `AliasedResult<T>`; we used this as the type of all the units
    of the code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用 `type` 关键字为 `Result<T, ParseIntError>` 创建了一个别名 `AliasedResult<T>`；我们将其用作代码所有单元的类型。
- en: 'Let''s go through the different functional units of the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解代码的不同功能单元：
- en: '`double_number`: This function takes in the `str` input and returns `AliasedResult<T>`.
    It parses the string to a value, and if it is a valid integer, we use the `map`
    function to multiply the input value by 2; else, we have the `Err` case.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_number`：此函数接受 `str` 输入并返回 `AliasedResult<T>`。它将字符串解析为值，如果它是一个有效的整数，我们使用
    `map` 函数将输入值乘以 2；否则，我们有 `Err` 情况。'
- en: '`print`: This function takes in `AliasedResult<T>`, and using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`：此函数接受 `AliasedResult<T>` 作为输入，并使用 `match` 语句检查我们是否有 `Ok` 或 `Err` 情况以打印相应的语句。'
- en: In the `main` function, we called `print(double_number("10"))`, which printed
    the `Ok` case statements due to valid input, but `print(double_number("t"))` pushed
    back an error due to invalid input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们调用了 `print(double_number("10"))`，由于输入有效，它打印了 `Ok` 情况语句，但 `print(double_number("t"))`
    由于输入无效而返回了一个错误。
- en: Handling multiple errors
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个错误
- en: In the previous recipes, we saw and developed error-handling units, where Results
    interacted with other Results and Options interacted with other Options. However,
    we have cases where we need interaction between the `Option` type and `Result`
    or between `Result<T, Error_1>` type, and `Result<T, Error_2>`. In this recipe,
    you will learn how to build units to manage different error types and have them
    interact with each other; we will use our knowledge of combinators to achieve
    this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们看到了并开发了错误处理单元，其中 Results 与其他 Results 交互，而 Options 与其他 Options 交互。然而，我们有一些需要
    `Option` 类型与 `Result` 或 `Result<T, Error_1>` 类型与 `Result<T, Error_2>` 之间交互的情况。在本食谱中，您将学习如何构建管理不同错误类型的单元，并使它们相互交互；我们将使用我们对组合子的知识来实现这一点。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个食谱：
- en: Create a file named `sample_multiple_err.rs` and open it in your text editor.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_multiple_err.rs` 的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define a generic alias named `Result<T>` for the `std::result::Result<T, String>`
    type:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Result<T>` 的泛型别名，用于 `std::result::Result<T, String>` 类型：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `double_first` 的函数，它将接受 `Vec` 输入并返回 `Result<i32>` 类型：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print` 的函数，它将接受 `Result<i32>` 类型作为输入：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用不同的函数：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/186e200c-d8f9-4575-b7d1-27948c0198a4.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/186e200c-d8f9-4575-b7d1-27948c0198a4.png)'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous recipes, we handled cases where we had similar types, such as
    Results and Options interacting with other Results and Options. In this recipe,
    we handled cross types, for example, the interaction of Options with Results.
    We used our previous experience in relation to combinators to implement this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们处理了具有相似类型的情况，例如 Results 和 Options 与其他 Results 和 Options 交互。在本食谱中，我们处理了跨类型的情况，例如
    Options 与 Results 的交互。我们利用之前的组合子经验来实现这一点。
- en: First, we created an alias for `std::result::Result<T>, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `type` 关键字为 `std::result::Result<T, String>` 创建了一个别名 `Result<T>`，我们将在代码的功能单元中使用它。
- en: 'Let''s check out the working of all the functional units:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有功能单元的工作情况：
- en: '`double_first`: This function takes in the `vec` input and returns `Result<T>`.
    In our case, it took the first value of the vector sent to it using the `vec.first`
    method. If no values are provided, then it would enter `ok_or`, where it would
    print the statement asking the user to input at least one value to the vector.
    Next, it checks whether we are able to parse the string value to a valid integer
    value. If this is successful, it allows us to use the map function to double it
    by multiplying the parsed integer by 2; else, it takes the error value and maps
    it to the string equivalent.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_first`: 这个函数接收 `vec` 输入并返回 `Result<T>`。在我们的例子中，它使用 `vec.first` 方法获取发送给它的向量的第一个值。如果没有提供值，它将进入
    `ok_or`，它会打印出要求用户至少向向量中输入一个值的语句。接下来，它检查我们是否能够将字符串值解析为有效的整数值。如果这成功了，它允许我们使用 map
    函数将其乘以 2 来加倍；否则，它将错误值映射到字符串等效值。'
- en: '`print`: This function takes in `Result<T>`, and using the `match` statement,
    it checks whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 这个函数接收 `Result<T>` 类型的参数，并使用 `match` 语句检查是否有 `Ok` 或 `Err` 情况以便打印相应的语句。'
- en: In the `main` function, we had vectors. Out of these, one was `empty`--there
    were no values in the vector--and the other was `string`, where we only had string
    values. When we call the `double_first` function with these input values, we get
    the corresponding errors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们有向量。其中一个是 `empty`（向量为空），另一个是 `string`（向量中只有字符串值）。当我们用这些输入值调用
    `double_first` 函数时，我们会得到相应的错误。
- en: Implementing early returns
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现早期返回
- en: Another way of dealing with different errors is using the combination of both
    `match` and early `return` statements. This is where we explicitly handle errors
    by returning them, and we do so without stopping the execution, as in the case
    of panic and so on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不同错误的一种另一种方法是结合使用 `match` 和早期 `return` 语句。这就是我们通过返回错误来显式处理错误的地方，我们这样做而没有停止执行，就像在
    panic 的情况下一样。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_early_ret.rs` and open it in your text editor.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_early_ret.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define a generic alias named `Result<T>` for the `std::result::Result<T, String>`
    type:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Result<T>` 的泛型别名，对应于 `std::result::Result<T, String>` 类型：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `double_first` 的函数，它将接受 `Vec` 输入并返回 `Result<i32>` 类型：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print` 的函数，它将接受 `Result<i32>` 类型的输入：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用不同的函数：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代码成功执行后，你会得到以下输出：
- en: '![](img/f90ef85f-3ba8-4695-b218-9e8c41e99f99.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f90ef85f-3ba8-4695-b218-9e8c41e99f99.png)'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous recipe, we explicitly handled errors using combinators. Rust
    also provides us with another way to deal with these cases, where we use a combination
    of `match` statements and early returns. The early returns is a way by which we
    can catch errors at an early stage of the function process and return back to
    the user of the application or library.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们使用组合子显式处理了错误。Rust 还为我们提供了另一种处理这些情况的方法，即结合使用 `match` 语句和早期返回。早期返回是一种在函数处理早期阶段捕获错误并返回给应用程序或库用户的方法。
- en: First, we created an alias for `std::result::Result<T, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `type` 关键字创建了一个 `std::result::Result<T, String>` 的别名 `Result<T>`，我们将在代码的功能单元中使用它。
- en: 'Let''s check out the working of all the functional units:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有功能单元的工作原理：
- en: '`double_first`: This function takes in the `vec` input and returns `Result<T>`.
    In our case, we used the early `return Err` to handle errors. We declared a variable
    named `first`, which held onto the first value of the vector that was passed.
    On this `first` variable, we performed `match` statements. If the value you get
    is `None`, use `return Err` to implement an early return to pass the error. In
    case you have string values in the vector element, use the `Err` value of the
    aliased type to raise the error.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_first`：这个函数接受 `vec` 输入并返回 `Result<T>`。在我们的例子中，我们使用了早期的 `return Err`
    来处理错误。我们声明了一个名为 `first` 的变量，它保留传递给向量的第一个值。在这个 `first` 变量上，我们执行了 `match` 语句。如果你得到的值是
    `None`，使用 `return Err` 来实现早期返回以传递错误。如果你在向量元素中有字符串值，使用别名的 `Err` 值来引发错误。'
- en: '`print`: This function takes in `Result<T>`, and using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`：这个函数接受 `Result<T>`，并使用 `match` 语句检查我们是否有 `Ok` 或 `Err` 情况以打印相应的语句。'
- en: In the `main` function, we had vectors in which one was `empty`, where there
    were no values in the vector. The other was `string`, where we had only string
    values when we called the `double_first` function. With this input, we get the
    corresponding errors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们有一些向量，其中一个是 `empty`，向量中没有值。另一个是 `string`，当我们调用 `double_first`
    函数时，我们只有字符串值。使用这个输入，我们得到相应的错误。
- en: Implementing the try! macro
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `try!` 宏
- en: We have reached a state where we can now avoid panicking, but explicitly handling
    all our errors is still a very difficult task. In this recipe, we'll use `try!`
    for cases where we simply need to unwrap without having to panic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了一个可以避免 panic 的状态，但显式处理所有错误仍然是一个非常困难的任务。在这个菜谱中，我们将使用 `try!` 来处理我们只需要展开而不需要
    panic 的情况。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何完成...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_try.rs` and open it in your text editor.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_try.rs` 的文件，并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define a generic alias `Result<T>` for the `std::result::Result<T, String>`
    type:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `std::result::Result<T, String>` 类型定义一个泛型别名 `Result<T>`：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `double_first` 的函数，它将接受 `Vec` 输入并返回 `Result<i32>` 类型：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print` 的函数，它将接受 `Result<i32>` 类型的输入：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用不同的函数：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你将得到以下输出：
- en: '![](img/8b22d6d0-93f4-4cae-b6c7-3ad2082b2ddf.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b22d6d0-93f4-4cae-b6c7-3ad2082b2ddf.png)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `try!` macro enables us to simply unwrap without using panic. In the previous
    recipes, we used the unwrap and nested functionality many times to get the desired
    value. And `try!` is equivalent to an `unwrap` function that is returned instead
    of panic in the case of an error. In this recipe, you will learn how to use `try!`
    along with combinators.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`try!` 宏使我们能够简单地展开而不使用 panic。在之前的菜谱中，我们多次使用了展开和嵌套功能来获取所需值。`try!` 在出错的情况下相当于返回
    panic 而不是 `unwrap` 函数。在这个菜谱中，你将学习如何使用 `try!` 与组合子一起使用。'
- en: First, we created an alias for `std::result::Result<T, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `type` 关键字为 `std::result::Result<T, String>` 创建了一个别名 `Result<T>`，我们将在代码的功能单元中使用它。
- en: 'Let''s check out the working of all the functional units:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有功能单元的工作原理：
- en: '`double_first`: This function takes in the `vec` type input and returns a`Result<T>`
    type. We declare a variable named `first` and assign it to `try!` macro statements
    for different cases. First, we check whether the first element of the vector is
    empty using `vec.first()`, which fetches the first value of the vector, if it''s
    empty, we print a statement using the `ok_or` method and in the other `try!` we
    parse the `first` variable to an interger type. In case there is an error, we
    convert the error into a string using the `map_err` method.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_first`：这个函数接受 `vec` 类型的输入并返回一个 `Result<T>` 类型的结果。我们声明一个名为 `first` 的变量并将其分配给不同的
    `try!` 宏语句。首先，我们检查向量的第一个元素是否为空，使用 `vec.first()` 获取向量的第一个值，如果为空，我们使用 `ok_or` 方法打印一条语句，在其他的
    `try!` 中将 `first` 变量解析为整数类型。如果发生错误，我们使用 `map_err` 方法将错误转换为字符串。'
- en: '`print`: This function takes in `Result<T>`. Using the `match` statement, we
    check whether we have an `Ok` or `Err` case for printing the corresponding statement.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`：这个函数接受 `Result<T>`。使用 `match` 语句，我们检查是否有 `Ok` 或 `Err` 情况以打印相应的语句。'
- en: In the main function, we had vectors in which one was `empty`, where there were
    no values in the vector. The other was `string`, where we only had string values.
    When we call the `double_first` function with these input values, we get the corresponding
    errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们有一些向量，其中一个是 `empty`，表示向量为空，另一个是 `string`，表示向量中只有字符串值。当我们用这些输入值调用
    `double_first` 函数时，我们会得到相应的错误。
- en: Defining your own error types
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自己的错误类型
- en: Rust allows us to define our own error types using custom Rust datatypes like
    `enum` and `struct`. We will create customized error-handling cases where we will
    able to define our own error types and have a definition for implementing or doing
    something to handle those error cases.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许我们使用自定义的 Rust 数据类型，如 `enum` 和 `struct`，来定义自己的错误类型。我们将创建定制的错误处理案例，其中我们将能够定义自己的错误类型，并为处理这些错误案例提供定义。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个食谱：
- en: Create a file named `sample_error.rs` and open it in your text editor.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sample_error.rs` 的文件并在你的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头部，包含相关信息：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Call the standard crates and create a generic alias type `Result<T>` for the
    `std::result::Result<T, CustomError>` type:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准库并创建一个泛型别名类型 `Result<T>`，用于 `std::result::Result<T, CustomError>` 类型：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create an `enum` type `CustomError`, which is our user-defined error type:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CustomError` 的 `enum` 类型，这是我们自定义的错误类型：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement a customized way to display the error of the `CustomError` type:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一种自定义的方式来显示 `CustomError` 类型的错误：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `double_first` 的函数，它将接受 `Vec` 输入并返回一个 `Result<i32>` 类型的结果：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print` 的函数，它将接受一个 `Result<i32>` 类型的输入：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数并调用不同的函数：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，你会得到以下输出：
- en: '![](img/d5cb2219-4113-44cb-8056-a85c6f633d35.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5cb2219-4113-44cb-8056-a85c6f633d35.png)'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In general, we would define a good error type as something that would do the
    following things for the developer so that it''s easy for them to understand where
    exactly the code is breaking at runtime:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会定义一个好的错误类型，使其能够为开发者做以下事情，以便他们能够轻松理解代码在运行时究竟在何处出错：
- en: Represent the different errors in the code with the same type
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同类型表示代码中的不同错误
- en: Display proper error functions to the user so it is easy for the developer to
    classify between different errors
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示适当的错误函数，以便开发者能够轻松区分不同的错误
- en: Hold proper information about the error
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确记录错误信息
- en: 'In this recipe, we created our own customized `enum` error type named `CustomError`.
    It had two types of data: `EmptyVec` and `Parse(ParseIntError)`. For each of these
    errors, we had customized implementation of error handling, where we produced
    customized error display messages for different errors so that our error type
    `CustomError` could follow all the preceding properties of a good error type.
    In the case of `EmptyVec`, we did not pass or need extra information about the
    error, but in the case of `Parse(ParseIntError)`, we had to supply the information
    required to parse the error implementation for its error.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了自己的自定义`enum`错误类型，名为`CustomError`。它有两种数据类型：`EmptyVec`和`Parse(ParseIntError)`。对于这些错误中的每一个，我们都有自定义的错误处理实现，为不同的错误生成自定义的错误显示消息，以便我们的错误类型`CustomError`能够遵循所有先前的好错误类型的属性。在`EmptyVec`的情况下，我们没有传递或需要关于错误的额外信息，但在`Parse(ParseIntError)`的情况下，我们必须提供解析错误实现所需的信息。
- en: 'Let''s see how to implement custom display functions for different errors.
    In this case, we used the `impl` keyword to create a customized `fmt::Display`
    for our error type `CustomError`, where `fmt` represented the standard library.
    For the `fmt` method that takes in `&self, f: &mut fmt::Formatter` and returns
    the standard `fmt::Result`, we used the `match` statement to identify the type
    of error and display the corresponding error messages. In the case of `CustomError::EmptyVec`,
    we printed this error message: `please use a vector with at least one element.`
    In the case of `CustomError::Parse`, we formatted and printed the extra information
    of the type.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看如何为不同的错误实现自定义显示函数。在这种情况下，我们使用了`impl`关键字为我们的错误类型`CustomError`创建一个自定义的`fmt::Display`，其中`fmt`代表标准库。对于接收`&self,
    f: &mut fmt::Formatter`并返回标准`fmt::Result`的`fmt`方法，我们使用了`match`语句来识别错误类型并显示相应的错误消息。在`CustomError::EmptyVec`的情况下，我们打印了这个错误消息：“请使用至少包含一个元素的向量。”在`CustomError::Parse`的情况下，我们格式化和打印了额外的类型信息。'
- en: 'Let''s check out the working of all the functional units:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有功能单元的工作原理：
- en: '`double_first`: This function takes in the `vec` input and returns `Result<i32>`.
    It takes the first value of the vector sent to it using the `vec.first` method.
    If no values are provided, then it enters `ok_or`, where it changes the error
    type to `CustomError::EmptyVec`. Next, it checks whether we are able to parse
    the string value to a valid integer value. If this is successful, we use the `map`
    function to double it by multiplying the parsed integer by `2`; else, it takes
    the error value and maps it to the other `CustomError::Parse` type.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_first`: 这个函数接收`vec`输入并返回`Result<i32>`。它使用`vec.first`方法获取发送给它的向量的第一个值。如果没有提供任何值，则进入`ok_or`，其中它将错误类型更改为`CustomError::EmptyVec`。接下来，它检查我们是否能够将字符串值解析为有效的整数值。如果成功，我们使用`map`函数通过将解析的整数乘以`2`来将其加倍；否则，它将错误值映射到另一个`CustomError::Parse`类型。'
- en: '`print`: This function takes in `Result<i32>`. Using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 这个函数接收`Result<i32>`。使用`match`语句，我们检查是否有`Ok`或`Err`情况以打印相应的语句。'
- en: In the `main` function, we had vectors. One of them was a number, where we had
    the correct input type for producing the output without any errors. The next one
    was `empty`, where there were no values in the vector. Then, there was `strings`,
    where we had the first value as a string of character values that couldn't be
    parsed to an integer. When we call the `double_first` function with these input
    values, we get the corresponding errors.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们有向量。其中一个是一个数字，其中我们有了正确的输入类型来生成输出而不产生任何错误。下一个是`empty`，其中向量为空。然后是`strings`，其中第一个值是一个字符值的字符串，无法解析为整数。当我们用这些输入值调用`double_first`函数时，我们得到相应的错误。
- en: Implementing the boxing of errors
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现错误装箱
- en: Rust allows us to box our error types, which is the process of creating wrapper
    error types around standard library error types. Boxing of errors is a common
    practice where developers bring together all the error types of the different
    libraries and use them to build the project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许我们将错误类型装箱，这是在标准库错误类型周围创建包装错误类型的过程。错误装箱是开发者的常见做法，他们将不同库的所有错误类型汇集在一起，并使用它们来构建项目。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to get through this recipe:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个菜谱：
- en: Create a file named `sample_box.rs` and open it in your text editor.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample_box.rs`的文件，并在您的文本编辑器中打开它。
- en: 'Write the code header with the relevant information:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写带有相关信息的代码头：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Call the standard crates and create a generic alias type, namely `Result<T>`,
    for the `std::result::Result<T, Box<error::Error>>` type:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用标准crates并创建一个泛型别名类型，即`Result<T>`，用于`std::result::Result<T, Box<error::Error>>`类型：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create an `enum` type `CustomError`, which would be our user-defined error
    type:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomError`的`enum`类型，这是我们用户定义的错误类型：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Convert the standard library error type into a custom type:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准库的错误类型转换为自定义类型：
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implement a customized way to display an error for the `CustomError` type:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CustomError`类型实现一个自定义的错误显示方式：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Implement the `error` trait for the `CustomError` type:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CustomError`类型实现`error`特质：
- en: '[PRE62]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`double_first`的函数，该函数将接受`Vec`输入并返回`Result<i32>`类型：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print`的函数，该函数将接受`Result<i32>`类型作为输入：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define the `main` function and call the different functions:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数并调用不同的函数：
- en: '[PRE65]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will get the following output upon successful execution of the code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码成功执行后，您将得到以下输出：
- en: '![](img/15eb889d-c9a2-4605-9052-6a94b7751c28.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15eb889d-c9a2-4605-9052-6a94b7751c28.png)'
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std` library automatically converts any type that implements the `Error`
    trait into the trait object `Box<Error>` via the `From` trait object. However,
    a user may use many external libraries, and different libraries provide their
    own error types. In order to define a valid `Result<T, E>` type, perform the following
    tasks:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`std`库自动将实现`Error`特质的任何类型通过`From`特质对象转换为特质的对象`Box<Error>`。然而，用户可能使用许多外部库，不同的库提供它们自己的错误类型。为了定义一个有效的`Result<T,
    E>`类型，执行以下任务：'
- en: Define a new wrapper error type around the library's standard error types
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在库的标准错误类型周围定义一个新的包装错误类型
- en: Convert the error types into String or any other type that is convenient to
    handle
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误类型转换为字符串或任何其他便于处理的数据类型
- en: Box the error types into the `Box<Error>` type
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误类型装箱到`Box<Error>`类型
- en: 'In this recipe, we started off by calling the standard libraries `std::error`,
    `std::fmt`, and `std::num::ParseIntError`. We then created an alias `Result<T>`
    for `std::result::Result<T, Box<error::Error>>`. Next, we created our own customized
    `enum` error type named `CustomError`, which had two types of data: `EmptyVec`
    and `Parse(ParseIntError)`.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先调用了标准库`std::error`、`std::fmt`和`std::num::ParseIntError`。然后，我们为`std::result::Result<T,
    Box<error::Error>>`创建了一个别名`Result<T>`。接下来，我们创建了自己的自定义`enum`错误类型`CustomError`，它有两种数据类型：`EmptyVec`和`Parse(ParseIntError)`。
- en: The compiler is capable of providing basic implementations for some traits via
    the `#[derive]` attribute, where an attribute is a metadata applied to some module,
    crate, or item. We use the `#[derive(Debug)]` for getting an output format that
    is programmer-facing and has more debugging context.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器能够通过`#[derive]`属性提供一些特质的基实现，其中属性是应用于某些模块、crate或项的元数据。我们使用`#[derive(Debug)]`来获取面向程序员的输出格式，它具有更多的调试上下文。
- en: We converted the standard library's `ParseIntError` error into the custom error
    type `CustomError` by implementing the `From` trait. We did this because the `from`
    method takes in the standard error type `ParseIntError` as `err` and returns the
    `CustomError` type by setting `CustomError::Parse(err)`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`From`特质将标准库的`ParseIntError`错误转换为自定义错误类型`CustomError`。我们这样做是因为`from`方法接受标准错误类型`ParseIntError`作为`err`，并通过设置`CustomError::Parse(err)`返回`CustomError`类型。
- en: 'Now let''s see how we implemented custom display functions for the different
    errors. We used the `impl` keyword to create a customized `fmt::Display` for our
    `CustomError` error type, where `fmt` represented the standard library. The `fmt`
    method takes in `&self, f: &mut fmt::Formatter` and returns the standard `fmt::Result`.
    We used the `match` statement to identify what type of error it was and display
    the corresponding error messages. In the case of `CustomError::EmptyVec`, we printed
    this error message: `please use a vector with at least one element.` In the case
    of `CustomError::Parse`, we formatted and printed the extra information of the
    type.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们看看我们是如何为不同的错误实现自定义显示函数的。我们使用`impl`关键字为我们的`CustomError`错误类型创建了一个定制的`fmt::Display`，其中`fmt`代表标准库。`fmt`方法接收`&self,
    f: &mut fmt::Formatter`并返回标准的`fmt::Result`。我们使用`match`语句来识别错误类型并显示相应的错误信息。在`CustomError::EmptyVec`的情况下，我们打印了这个错误信息：“请使用至少包含一个元素的向量。”在`CustomError::Parse`的情况下，我们格式化和打印了额外的类型信息。'
- en: 'To implement `Box<Error>`, we had to implement the Error trait where we had
    two methods: `description` and `cause`. These methods take the value of the trait
    and return them. In the `description` method, using the `match` statement, we
    assigned a description about the error types; here we matched `CustomError::EmptyVec`
    to `empty vectors not allowed` and `CustomError::Parse(ref e)` to `e.description()`.
    Similarly, in the case of `cause`, we had sample values that led to the error,
    and we matched `CustomError::EmptyVec` to `None` and `CustomError::Parse(ref e)`
    to `Some(e)`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Box<Error>`，我们必须实现Error特质，其中有两个方法：`description`和`cause`。这些方法接受特质的值并返回它们。在`description`方法中，使用`match`语句，我们分配了关于错误类型的描述；这里我们将`CustomError::EmptyVec`匹配到`empty
    vectors not allowed`，将`CustomError::Parse(ref e)`匹配到`e.description()`。同样，在`cause`的情况下，我们有导致错误的样本值，并将`CustomError::EmptyVec`匹配到`None`，将`CustomError::Parse(ref
    e)`匹配到`Some(e)`。
- en: 'Let''s check out the working of all the functional units:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有功能单元的工作原理：
- en: '`double_first`: This function takes in the `vec` input and returns `Result<i32>`.
    In our case, it took the first value of the vector sent to it using the `vec.first`
    method with the `try!` macro and assigned it to the `first` variable. If no values
    are provided, then it would enter `ok_or`, where it changes the error type to
    `CustomError::EmptyVec`. Next, we checked whether we were able to parse the string
    value to a valid integer value by `first.parse::<i32>()`, using the `try!` macro
    and assigning it to the `parsed` variable. If this is successful, we double it
    by multiplying the parsed integer by `2`. In the `Ok` data type, it returns the
    `enum` type `Result<i32>`; else, it takes the error value parsed by the error
    type.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double_first`: 这个函数接收`vec`输入并返回`Result<i32>`。在我们的例子中，它使用`try!`宏通过`vec.first`方法获取发送给它的向量的第一个值，并将其赋值给`first`变量。如果没有提供任何值，它将进入`ok_or`，其中将错误类型更改为`CustomError::EmptyVec`。接下来，我们通过`first.parse::<i32>()`使用`try!`宏检查我们是否能够将字符串值解析为有效的整数值，并将其赋值给`parsed`变量。如果成功，我们将其乘以`2`。在`Ok`数据类型中，它返回`enum`类型的`Result<i32>`；否则，它采用错误类型解析的错误值。'
- en: '`print`: This function takes in `Result<i32>`. Using the `match` statement,
    we check whether we have an `Ok` or `Err` case to print the corresponding statement.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 这个函数接收`Result<i32>`。使用`match`语句，我们检查是否有`Ok`或`Err`情况来打印相应的语句。'
- en: In the `main` function, we had vectors. Among these, one was a number, where
    we had the correct input type for producing the output without any errors. The
    next one was `empty`, meaning there were no values in the vector. The other one
    was `strings`, where we had the first value of a string of character values that
    couldn't be parsed into an integer. When we call the `double_first` function with
    these input values, we get the corresponding errors.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们有向量。在这些向量中，有一个是数字，我们使用了正确的输入类型来生成输出而不产生任何错误。下一个是`empty`，表示向量为空。另一个是`strings`，其中我们有一个字符值字符串的第一个值，这些值无法解析为整数。当我们用这些输入值调用`double_first`函数时，我们得到相应的错误。
