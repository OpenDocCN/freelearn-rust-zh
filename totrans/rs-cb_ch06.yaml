- en: Efficient Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing panic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating map combinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and_then combinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating map for the Result type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing early returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the try! macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining your own error types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the boxing of errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is a fundamental part of all programming languages. It is the
    way in which a developer prepares for the worst conditions by noticing and managing
    errors due to which the application could fail. These error conditions can occur
    due to various reasons, such as wrong input provided at runtime and more. In this
    chapter, we will cover various methods using which we can efficiently handle errors
    in Rust. We'll also check out the standard library that helps avoid problematic
    situations and thus avoid a complete failure of the Rust application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing panic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panic is the simplest error handling mechanism provided by Rust. It prints the
    error messages given to it, starts to unwind the task, and usually exits the program
    execution. In this recipe, we will explicitly call out a `panic` statement in
    the face of an undesired case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the ensuing steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_panic.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `compare_stmt` function; it accepts a string input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function; it calls the `compare_stmt` function with different
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e399cede-55ef-43bc-aba5-1e7800e6fa64.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a function named `compare_stmt` that accepts an `str` variable as an
    argument and assigns it to a variable named `input` in its scope. It later checks
    whether the string value is `Another Book`. If it is, it calls the `panic!` function;
    otherwise, it prints the value that was passed. We passed two values from the
    main function: `Rust CookBook` and `` `Another Book` ``.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the preceding program, the first input will fail the `if` condition
    and will not invoke panic, so we get the print statement working. However, for
    the second input, which satisfies the `if` condition, panic is invoked and it
    returns `thread 'main' panicked at 'Rust Cookbook is not selected!!!!', sample_panic.rs:12`
    and exits the program.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panic handles cases where there are identified instances of undesired input,
    but it does not handle zero input. For that, we have the `Option<T>` type, an
    `enum` from the standard library that you can use to handle cases where you have
    no input. In this recipe, you will learn the different ways in which you can use
    Options to handle zero case input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the ensuing steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_option.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `compare_stmt_match` function; it accepts the `input` string of
    the `Option<&str>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create the `compare_stmt_unwrap` function; it also accepts the `input`
    string of the `Option<&str>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function; it calls the two functions with different input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da4d8747-d2ab-4086-bcf9-28b28b645e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding recipe, we knew we had to exit the program using `panic!`
    in the case of an undesired input, but the main problem we are trying to solve
    in this recipe is the way by which we can handle `None` input. We use the Rust
    standard library to address this problem. More specifically, we use an `enum`
    called `Option<T>` from the `std` library, which is used when there is no input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It has two options, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some(T)`: This is an element of the type `T` that was sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`: This refers to the case where there was no input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We handle these cases in two ways: the explicit way of handling in which we
    use `match` and the implicit way in which we use `unwrap`. The implicit way of
    handling returns the inner element of either `enum` or `panic!`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the explicit way of handling, we declared three variables, namely `Desired_Book`,
    `Another_Book`, and `Empty_value` in the `main` function. We assigned them with
    book names, which were `Rust Cookbook`, `Another Book`, and `` `None` ``, respectively.
    Post this, we called the functions in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compare_stmt_match(Desired_Book)`: This satisfies the match statement condition
    `Some("Rust CookBook")` to print `Rust CookBook was selected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare_stmt_match(Another_Book)`: This satisfies the `match` statement condition
    `Some(inner)` to print `"Rust CookBook not selected"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare_stmt_match(Empty_val)`: This satisfies the `match` statement condition
    `None` to print `No input provided`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In implicit handling, we created `Rand_Book` and `No_val` with the values `Some("Random
    Book")` and `None`, respectively. We call another function that uses unwrap to
    handle `Some(T)` and `None` values. The `compare_stmt_unwrap(Rand_Book)` used
    `unwrap` to get `inside_val`, which successfully called the print statement; on
    the second function call `compare_stmt_unwrap(No_val)`, we got ``thread 'main'
    panicked at 'called `Option::unwrap()` on a `None` value', ../src/libcore/option.rs:323``.
    This was because `unwrap` returns a panic when we have `None` as the inner value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating map combinator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn about the map combinator in this recipe, which again is a combinator
    for handling `Option` types. The `Option` has an inbuilt map method for simple
    mapping of `Some(T)` to another valid type; it can also handle the mapping of
    none values. The `map` is a great way to explicitly handle `None` case input.
    It also simplifies the code as it can be used multiple times. Combinators, in
    general, are high-order functions that apply only the functions and the combinators
    defined earlier to provide a result from their arguments. They are generally used
    to control the flow in a modular fashion in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_map.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a user-defined data type to use the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `peel` function; it accepts the `Option<Food>` type input and returns
    `Option<Peeled>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `chop` function; it accepts the `Option<Peeled>` type input and
    returns `Option<Chopped>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `cook` function; it accepts the `Option<Chopped>` type input and
    returns `Option<Cooked>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `process` function; it accepts the `Option<Food>` type input and
    returns `Option<Cooked>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `eat` function; it accepts the `Option<Cooked>` type input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function where we can create the different types of input
    to understand the working of the map combinator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21819b41-85ef-4299-b15b-01dc5bfc7f9e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first created an `enum` type named `Food` that had data elements, namely
    `Apple`, `Carrot`, and `Potato`. Then we created three `struct` with user-defined
    data types, namely `Peeled`, `Chopped`, and `Cooked` with `Food` as a data field.
    In the `main` function, we created three variables and assigned them to the values
    of the `Option` data, where `apple` was valued `Food::Apple`, `carrot` as `Food::Carrot`,
    and `potato` as `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check out how our function units react to different input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`peel`: This function takes in an `Option` type that has a field `enum` type
    `Food` along with the data and returns an `Option` of the `struct` data type `Peeled`.
    Here we use the `match` function to change the type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chop`: This function takes in the `Option` type that has a field `enum` type
    `Peeled` along with the data and returns an `Option` of the `struct` data type
    `Chopped`. Here we use the `match` function to change the type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cook`: This function takes in the `Option` type that has a field `enum` type
    `Chopped` along with the data and returns an `Option` of the `struct` data type
    `Cooked`. Here we use the `map` function to change the type, where we place the
    input type between two pipe symbols that convert them into the desired form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process`: Instead of having three functions to change types, we use map multiple
    times to convert `Option<Food>` into `Option<Cooked>` directly, where each map
    function successively converts the type to the desired form by this process we
    can peel, chop, and cook `food` type in a sequence by using multiple `map()`,
    thus it simplifies the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eat`: This function takes in the `Option<Cooked>` type as an input argument
    and checks it using a `match` statement. The first case `some(food)` would be
    true if a valid type exists for the `food` argument which is passed to the `match`
    statement, then it would print the value of the argument `food` in the place holder
    of the print statement else in the `None` case, it prints a default statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we declared `cooked_apple` and assigned the return value
    of the `chop(peel(apple))` call. Since we didn't pass a `None` input, this was
    supposed to return the `Cooked(apple)` type of the data feed. Similarly, `cooked_carrot`
    had the value `Cooked(carrot)`; however, `cooked_potato`, for which we called
    the `process` function, returned `None`. Later, when we called the `eat` function,
    only the variable that had `Cooked` `struct` values got printed as `MM. I Love
    statement` and the variable that had `None` had `Oh No! statement`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and_then combinator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with `map` is that it can get confusing when we have too many functions
    returning maps. This is because the result will be nested in the `Option<Option<T>>`
    format, and this gets complicated and confusing on multiple calls of the map combinator.
  prefs: []
  type: TYPE_NORMAL
- en: Rust provides another combinator, namely `and_then()`, which solves the preceding
    problem by only returning the result instead. It does it by flattening the chained
    results to a single type. In this recipe, you will learn how to use this combinator
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_and_then.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `enum` types `Food` and `Day`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `have_ingredients` that will accept the `Food` type
    as an input argument and return `Option<Food>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `have_recipe` that will accept the `Food` type as an
    input argument and return `Option<Food>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `cookable` that will accept the `Food` type as an input
    argument and return `Option<Food>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function named `eat` that will accept the `Food` type as an input
    argument and return `Day`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function; it will initialize and call all the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fe0fca8-1379-4550-8249-0cac73518195.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We declared two `enum` types, namely `Food` and `Day`, where we had these elements:
    `CordonBleu`, `Steak`, and `Sushi` and `Monday`, `Tuesday`, and `Wednesday`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how our function units react to different input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`have_ingredients`: This function takes in the `enum` input `Food` and returns
    `Option<Food>`. It has a case in its `match` statement indicating whether `Food`
    has the value `Sushi` in that it returns `None` and for all other values, it returns
    the same `Food` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`have_recipe`: This function takes in the `enum` input `Food` and returns `Option<Food>`.
    It has a case in its `match` statement indicating whether `Food` has the value
    `CordonBleu` in that it returns `None`; for all other values, it returns the same
    `Food` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookable`: This function takes in the `enum` input `Food` and returns `Option<Food>`.
    Here, we use the `and_then` combinator to check the `have_ingredients` and `have_recipe`
    functions in order to confirm that the `Food` type will pass these cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eat`: This function takes the `enum` input `Food` and `Day` and sends the
    `Food` value to the `cookable` function. Here we have a `match` statement that
    prints the day and `Food` type in the case of `Some(Food)` from the `cookable`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We observe that for `cookable` to return a value, we need both the functions
    `have_ingredients` and `have_` recipe to return `Some(Food)`, which happens only
    in the case of `Steak`. In the `main` function, we called the `eat` function with
    all the values of `Food` and `Day`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating map for the Result type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Result` type is similar to the `Option` type, but it offers more, as it
    also describes the possible error. This means we will have two outcomes: one where
    the desired element is found and the other where we may have found an error with
    an element. In this recipe, we will use the `map` method of `Result` to return
    a specific error.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_map_result.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_number` that will accept the `str` input and
    return a `Result<T>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_number_map` that will accept the `str` input
    and return a `Result<T>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<T>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and declare different input for different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8614b77b-4a21-406c-9ca7-2506ddc273cf.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panicking gives us only an error message, which is not of great use for being
    more specific regarding the return type and the error. We have the `Result` type,
    which is similar to Options, but it can also be used to mention the error type.
    In this recipe, we used the map method of Rust to get the specific error type.
  prefs: []
  type: TYPE_NORMAL
- en: First, we called the standard library error type `ParseIntError`, which we used
    for returning error types as per the `Result` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the different functional units in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print`: This function takes in an input type of `Result<i32, ParseIntError>`,
    and based on its value, whether it is `Ok` or `Err`, prints the corresponding
    statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double_number_map`: This function takes in the `str` input and returns `Result<i32,
    ParseIntError>`. It parses the string to a value, and if it is a valid integer,
    we use the `map` function to multiply the input value by 2; else, we have the
    `Err` case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double_number`: This function takes in the `str` input and returns `Result<i32,
    ParseIntError>`, where it has a `match` statement where it parses the string to
    a value. If it is a valid integer, it satisfies the `Ok` case and the value is
    multiplied by two if an `Err` case occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<i32, ParseIntError>`; using the `match`
    statement, we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we had two variables, namely `twenty` and `tt`, assigned
    to `double_number("10")` and `double_number_map("t")`, respectively. When we called
    `double_number function` for `twenty`, it returned an integer value, but `double_number_map`
    returned an error for `t`. The print statement printed the final value of these
    `Result` type variables. In the case of passing a string to the`double_number`
    method that can't be parsed to integer will result in the `ParseIntError` and
    a valid integer argument of string type will result in double its value for `double_number_map`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use aliases in order to reuse a specific type multiple times. Rust allows
    us to create aliases of the `Result` type and more types in order to reuse them
    across the program. At the module level, this is really helpful as we can identify
    similar kinds of bugs and errors from the units/items of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_aliases_result.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a generic alias named `AliasedResult<T>` for the `Result` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_number` that will accept the `str` input and
    return an `AliasedResult<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept an `AliasedResult<i32>` type
    as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/130a1552-7c90-42b0-af61-7d5ba2759561.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliases work in a fairly simple manner. Its main role is to ease the usage of
    a particular type and maintain different types across different modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the `type` keyword to create an alias for `Result<T,
    ParseIntError>` as `AliasedResult<T>`; we used this as the type of all the units
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the different functional units of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_number`: This function takes in the `str` input and returns `AliasedResult<T>`.
    It parses the string to a value, and if it is a valid integer, we use the `map`
    function to multiply the input value by 2; else, we have the `Err` case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `AliasedResult<T>`, and using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we called `print(double_number("10"))`, which printed
    the `Ok` case statements due to valid input, but `print(double_number("t"))` pushed
    back an error due to invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw and developed error-handling units, where Results
    interacted with other Results and Options interacted with other Options. However,
    we have cases where we need interaction between the `Option` type and `Result`
    or between `Result<T, Error_1>` type, and `Result<T, Error_2>`. In this recipe,
    you will learn how to build units to manage different error types and have them
    interact with each other; we will use our knowledge of combinators to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_multiple_err.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a generic alias named `Result<T>` for the `std::result::Result<T, String>`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/186e200c-d8f9-4575-b7d1-27948c0198a4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we handled cases where we had similar types, such as
    Results and Options interacting with other Results and Options. In this recipe,
    we handled cross types, for example, the interaction of Options with Results.
    We used our previous experience in relation to combinators to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created an alias for `std::result::Result<T>, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the working of all the functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_first`: This function takes in the `vec` input and returns `Result<T>`.
    In our case, it took the first value of the vector sent to it using the `vec.first`
    method. If no values are provided, then it would enter `ok_or`, where it would
    print the statement asking the user to input at least one value to the vector.
    Next, it checks whether we are able to parse the string value to a valid integer
    value. If this is successful, it allows us to use the map function to double it
    by multiplying the parsed integer by 2; else, it takes the error value and maps
    it to the string equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<T>`, and using the `match` statement,
    it checks whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we had vectors. Out of these, one was `empty`--there
    were no values in the vector--and the other was `string`, where we only had string
    values. When we call the `double_first` function with these input values, we get
    the corresponding errors.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing early returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of dealing with different errors is using the combination of both
    `match` and early `return` statements. This is where we explicitly handle errors
    by returning them, and we do so without stopping the execution, as in the case
    of panic and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_early_ret.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a generic alias named `Result<T>` for the `std::result::Result<T, String>`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f90ef85f-3ba8-4695-b218-9e8c41e99f99.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we explicitly handled errors using combinators. Rust
    also provides us with another way to deal with these cases, where we use a combination
    of `match` statements and early returns. The early returns is a way by which we
    can catch errors at an early stage of the function process and return back to
    the user of the application or library.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created an alias for `std::result::Result<T, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the working of all the functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_first`: This function takes in the `vec` input and returns `Result<T>`.
    In our case, we used the early `return Err` to handle errors. We declared a variable
    named `first`, which held onto the first value of the vector that was passed.
    On this `first` variable, we performed `match` statements. If the value you get
    is `None`, use `return Err` to implement an early return to pass the error. In
    case you have string values in the vector element, use the `Err` value of the
    aliased type to raise the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<T>`, and using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we had vectors in which one was `empty`, where there
    were no values in the vector. The other was `string`, where we had only string
    values when we called the `double_first` function. With this input, we get the
    corresponding errors.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the try! macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached a state where we can now avoid panicking, but explicitly handling
    all our errors is still a very difficult task. In this recipe, we'll use `try!`
    for cases where we simply need to unwrap without having to panic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_try.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a generic alias `Result<T>` for the `std::result::Result<T, String>`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b22d6d0-93f4-4cae-b6c7-3ad2082b2ddf.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `try!` macro enables us to simply unwrap without using panic. In the previous
    recipes, we used the unwrap and nested functionality many times to get the desired
    value. And `try!` is equivalent to an `unwrap` function that is returned instead
    of panic in the case of an error. In this recipe, you will learn how to use `try!`
    along with combinators.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created an alias for `std::result::Result<T, String>` using the `type`
    keyword as `Result<T>`, which we will use across the functional units of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the working of all the functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_first`: This function takes in the `vec` type input and returns a`Result<T>`
    type. We declare a variable named `first` and assign it to `try!` macro statements
    for different cases. First, we check whether the first element of the vector is
    empty using `vec.first()`, which fetches the first value of the vector, if it''s
    empty, we print a statement using the `ok_or` method and in the other `try!` we
    parse the `first` variable to an interger type. In case there is an error, we
    convert the error into a string using the `map_err` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<T>`. Using the `match` statement, we
    check whether we have an `Ok` or `Err` case for printing the corresponding statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main function, we had vectors in which one was `empty`, where there were
    no values in the vector. The other was `string`, where we only had string values.
    When we call the `double_first` function with these input values, we get the corresponding
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your own error types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows us to define our own error types using custom Rust datatypes like
    `enum` and `struct`. We will create customized error-handling cases where we will
    able to define our own error types and have a definition for implementing or doing
    something to handle those error cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_error.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard crates and create a generic alias type `Result<T>` for the
    `std::result::Result<T, CustomError>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `enum` type `CustomError`, which is our user-defined error type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a customized way to display the error of the `CustomError` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5cb2219-4113-44cb-8056-a85c6f633d35.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, we would define a good error type as something that would do the
    following things for the developer so that it''s easy for them to understand where
    exactly the code is breaking at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Represent the different errors in the code with the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display proper error functions to the user so it is easy for the developer to
    classify between different errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold proper information about the error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we created our own customized `enum` error type named `CustomError`.
    It had two types of data: `EmptyVec` and `Parse(ParseIntError)`. For each of these
    errors, we had customized implementation of error handling, where we produced
    customized error display messages for different errors so that our error type
    `CustomError` could follow all the preceding properties of a good error type.
    In the case of `EmptyVec`, we did not pass or need extra information about the
    error, but in the case of `Parse(ParseIntError)`, we had to supply the information
    required to parse the error implementation for its error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to implement custom display functions for different errors.
    In this case, we used the `impl` keyword to create a customized `fmt::Display`
    for our error type `CustomError`, where `fmt` represented the standard library.
    For the `fmt` method that takes in `&self, f: &mut fmt::Formatter` and returns
    the standard `fmt::Result`, we used the `match` statement to identify the type
    of error and display the corresponding error messages. In the case of `CustomError::EmptyVec`,
    we printed this error message: `please use a vector with at least one element.`
    In the case of `CustomError::Parse`, we formatted and printed the extra information
    of the type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the working of all the functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_first`: This function takes in the `vec` input and returns `Result<i32>`.
    It takes the first value of the vector sent to it using the `vec.first` method.
    If no values are provided, then it enters `ok_or`, where it changes the error
    type to `CustomError::EmptyVec`. Next, it checks whether we are able to parse
    the string value to a valid integer value. If this is successful, we use the `map`
    function to double it by multiplying the parsed integer by `2`; else, it takes
    the error value and maps it to the other `CustomError::Parse` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<i32>`. Using the `match` statement,
    we check whether we have an `Ok` or `Err` case for printing the corresponding
    statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we had vectors. One of them was a number, where we had
    the correct input type for producing the output without any errors. The next one
    was `empty`, where there were no values in the vector. Then, there was `strings`,
    where we had the first value as a string of character values that couldn't be
    parsed to an integer. When we call the `double_first` function with these input
    values, we get the corresponding errors.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the boxing of errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows us to box our error types, which is the process of creating wrapper
    error types around standard library error types. Boxing of errors is a common
    practice where developers bring together all the error types of the different
    libraries and use them to build the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for developing the Rust
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to get through this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sample_box.rs` and open it in your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code header with the relevant information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the standard crates and create a generic alias type, namely `Result<T>`,
    for the `std::result::Result<T, Box<error::Error>>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `enum` type `CustomError`, which would be our user-defined error
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the standard library error type into a custom type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a customized way to display an error for the `CustomError` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `error` trait for the `CustomError` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `double_first` that will accept the `Vec` input and
    return a `Result<i32>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `print` that will accept a `Result<i32>` type as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `main` function and call the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon successful execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15eb889d-c9a2-4605-9052-6a94b7751c28.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std` library automatically converts any type that implements the `Error`
    trait into the trait object `Box<Error>` via the `From` trait object. However,
    a user may use many external libraries, and different libraries provide their
    own error types. In order to define a valid `Result<T, E>` type, perform the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new wrapper error type around the library's standard error types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the error types into String or any other type that is convenient to
    handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box the error types into the `Box<Error>` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we started off by calling the standard libraries `std::error`,
    `std::fmt`, and `std::num::ParseIntError`. We then created an alias `Result<T>`
    for `std::result::Result<T, Box<error::Error>>`. Next, we created our own customized
    `enum` error type named `CustomError`, which had two types of data: `EmptyVec`
    and `Parse(ParseIntError)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler is capable of providing basic implementations for some traits via
    the `#[derive]` attribute, where an attribute is a metadata applied to some module,
    crate, or item. We use the `#[derive(Debug)]` for getting an output format that
    is programmer-facing and has more debugging context.
  prefs: []
  type: TYPE_NORMAL
- en: We converted the standard library's `ParseIntError` error into the custom error
    type `CustomError` by implementing the `From` trait. We did this because the `from`
    method takes in the standard error type `ParseIntError` as `err` and returns the
    `CustomError` type by setting `CustomError::Parse(err)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we implemented custom display functions for the different
    errors. We used the `impl` keyword to create a customized `fmt::Display` for our
    `CustomError` error type, where `fmt` represented the standard library. The `fmt`
    method takes in `&self, f: &mut fmt::Formatter` and returns the standard `fmt::Result`.
    We used the `match` statement to identify what type of error it was and display
    the corresponding error messages. In the case of `CustomError::EmptyVec`, we printed
    this error message: `please use a vector with at least one element.` In the case
    of `CustomError::Parse`, we formatted and printed the extra information of the
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement `Box<Error>`, we had to implement the Error trait where we had
    two methods: `description` and `cause`. These methods take the value of the trait
    and return them. In the `description` method, using the `match` statement, we
    assigned a description about the error types; here we matched `CustomError::EmptyVec`
    to `empty vectors not allowed` and `CustomError::Parse(ref e)` to `e.description()`.
    Similarly, in the case of `cause`, we had sample values that led to the error,
    and we matched `CustomError::EmptyVec` to `None` and `CustomError::Parse(ref e)`
    to `Some(e)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the working of all the functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double_first`: This function takes in the `vec` input and returns `Result<i32>`.
    In our case, it took the first value of the vector sent to it using the `vec.first`
    method with the `try!` macro and assigned it to the `first` variable. If no values
    are provided, then it would enter `ok_or`, where it changes the error type to
    `CustomError::EmptyVec`. Next, we checked whether we were able to parse the string
    value to a valid integer value by `first.parse::<i32>()`, using the `try!` macro
    and assigning it to the `parsed` variable. If this is successful, we double it
    by multiplying the parsed integer by `2`. In the `Ok` data type, it returns the
    `enum` type `Result<i32>`; else, it takes the error value parsed by the error
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: This function takes in `Result<i32>`. Using the `match` statement,
    we check whether we have an `Ok` or `Err` case to print the corresponding statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we had vectors. Among these, one was a number, where
    we had the correct input type for producing the output without any errors. The
    next one was `empty`, meaning there were no values in the vector. The other one
    was `strings`, where we had the first value of a string of character values that
    couldn't be parsed into an integer. When we call the `double_first` function with
    these input values, we get the corresponding errors.
  prefs: []
  type: TYPE_NORMAL
