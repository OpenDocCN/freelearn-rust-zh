- en: Handling Errors and Other Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling errors is always an interesting challenge in every programming language.
    There are many styles available: returning numeric values, exceptions (software
    interrupts), result and option types, and so on. Each way requires different architectures
    and has implications for performance, readability, and maintainability. Rust''s
    approach is—just like many functional programming languages—based on integrating
    failure as part of the regular workflow. This means that whatever the return value,
    an error is not a special case but integrated into the handling. `Option` and
    `Result` are the central types that allow for returning results as well as errors.
    `panic!` is an additional macro to halt the thread immediately in case it cannot/should
    not continue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover some basic recipes and architectures to use Rust''s
    error handling effectively so that your code is easy to read, understand, and
    maintain. For this reason, in this chapter, you can look forward to learning about the
    following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Panicking responsibly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with exceptional results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with external crates for error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving between Option and Result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panicking responsibly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there is no way for an execution thread to continue. This may be
    due to things such as invalid configuration files, unresponsive peers or servers,
    or OS-related errors. Rust has many ways to panic, explicitly or implicitly. The
    most ubiquitous one is probably `unwrap()` for multiple `Option` types and related
    types, which panic on error or `None`. Yet, for more complex programs, it is essential
    to take control of the panicking (for example, by avoiding multiple `unwrap()` calls
    and libraries that use it) and the `panic!` macro supports that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine how we can take control of multiple `panic!` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new panicking-responsibly --lib` and open it
    with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and replace the default tests with a regular, straightforward
    panic instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other ways to halt the program too. Let''s add another `test`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, these panics all have a generic error message, which is not very informative
    with regard to what the application was doing. Using `expect()` lets you provide
    an error message to explain the causes of the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `panic!` macro provides a similar way of explaining the sudden halt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro can also return numerical values, something that is very important
    for Unix-type OSes that can check for those values. Add another test to return 
    an integer code to indicate a specific failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another great way of halting the program based on invalid values is by using
    the `assert!` macro. It should be well-known from writing tests, so let''s add
    a few to see Rust''s variants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is, as usual, to compile and run the code we have just written
    using `cargo test`. The output shows whether the tests have passed (which they
    should):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But how does this allow us to panic responsibly? Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to Rust's ability to check panic results, we can verify the messages
    and the fact that the panic occurred. From *step 2* to *step 4*, we are simply
    panicking using various (common) methods, such as `unwrap()` ([https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap))
    or `panic!()` ([https://doc.rust-lang.org/std/macro.panic.html](https://doc.rust-lang.org/std/macro.panic.html)).
    These methods return messages such as ``'called `Option::unwrap()` on a `None`
    value', src/libcore/option.rs:347:21``, or `panicked at 'explicit panic', src/lib.rs:64:9`,
    which are not easy to debug.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a variation of `unwrap()` called `expect()`, which takes a `&str`
    parameter as a simple message for users to debug the issue further. *Steps 4* to* 6*
    show how messages and return values are incorporated. In *step 7*, we cover the
    additional `assert!` macro that is typically seen in tests but finds its way into
    productive systems as well to guard against rare and irrecoverable values.
  prefs: []
  type: TYPE_NORMAL
- en: Halting the execution of a thread or program should always be the last resort,
    especially when you are creating a library for others to use. Think about it—some
    bug leads to an unexpected value in a third-party library, which then panics and
    brings the service to an immediate unexpected halt. Imagine if that happened thanks
    to a call to `unwrap()` instead of using more robust methods.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to panic responsibly. Now, let's move on to the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever an application becomes more complex and includes third-party frameworks,
    all kinds of error types need to be taken care of *consistently *without having
    a condition for each one. For example, a web service's large range of possible
    errors can bubble up to the handler where they need to be translated into HTTP
    codes with informative messages. These expected errors can range from parser errors
    to invalid authentication details, failed database connections, or an application-specific
    error with an error code. In this recipe, we'll cover how to deal with this variety
    of errors using wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an error wrapper in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project you created with `cargo new multiple-errors` with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` to and add some imports at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In our application, we will deal with three user-defined errors. Let''s declare
    them right after the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the wrapper: since we are dealing with multiple variations of something, `enum`
    will fit the purpose perfectly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it would be nice to have the same interface as other errors, so let''s
    implement the `std::error::Error` trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The trait makes it necessary to implement `std::fmt::Display` as well, so this
    will be the next `impl` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to see the results of our labor. Replace the existing `main` function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we execute `cargo run` to see that the output matches what we expected
    before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple errors may not seem much of an issue at first, but for a clean, readable
    architecture, it is necessary to address them somehow. An enum that wraps possible
    variants has been shown to be the most practical solution, and, by implementing
    `std::error::Error` (and the `std::fmt::Display` requirement), the handling of
    the new error type should be seamless. In *steps 3* to* 6*, we show an example
    implementation of the required traits in a reductionist fashion. *Step 7* shows
    how to use the wrapping enum and how to use the `Display` and `Error` implementations
    to help match the variants.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `Error` trait will allow interesting aspects in the future,
    including recursive nesting. Check the documentation at [https://doc.rust-lang.org/std/error/trait.Error.html#method.source](https://doc.rust-lang.org/std/error/trait.Error.html#method.source) to
    find out more. Typically, we would not create these error variants themselves
    if we can avoid it, which is why there are supportive crates taking care of all
    of the boilerplate code—we'll cover that in a different recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe to complement our newfound skills in handling
    multiple errors!
  prefs: []
  type: TYPE_NORMAL
- en: Working with exceptional results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than the `Option` type, a `Result` type can have two custom types, which
    means that `Result` provides additional information about the cause of the error.
    This is more expressive than returning `Option`, which returns a single type instance
    or `None`. However, this `None` instance can mean anything from *failure to process* to
    *wrong input*. This way, the `Result` type can be seen as a similar system as
    exceptions in other languages, but they are part of the regular workflow of a
    program. One example is a search, where a multitude of scenarios can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The desired value is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desired value is not found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection was invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value was invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you use the `Result` type effectively? Let's find out in this recipe!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some steps for working with `Result` and `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new exceptional-results --lib` and open it
    with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and add a function before the `test` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name suggests, this is not the best way to communicate failure in Rust.
    What is a better way, though? One answer is to utilize the `Option` enum. Add
    another function underneath the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it possible to reason about the expected return values, but Rust
    allows a more expressive variation—such as the `Result` type. Add the following
    to the current collection of functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we implemented a few variations of the same function, let''s test
    them. For the first function, add the following to the `test` module and replace
    the existing (default) test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The other test functions look very similar. To have consistent outcomes and
    show the differences between the return types, add these to the `test` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run `cargo test` to see the test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what's behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust and many other programming languages use the `Result` type to communicate
    multiple function outcomes at once. This way, the function can return just as
    it was designed without (unexpected) jumps such as the exception mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* of this recipe, we show one way of communicating errors that is
    common in other languages (for example, Java)—however, as we can see in the test
    (*step 6*), the outcome for an empty string is unexpected (`0` instead of `-1`).
    In *step 3*, we define a better return type, but is it enough? No, it isn't. In
    *step 4*, we implement the best version of the function where each `Result` type
    is easy to interpret and clearly defined.
  prefs: []
  type: TYPE_NORMAL
- en: One even greater example of how to use `Result` can be found in the standard
    library. It's the `quick_search` function on the `slice` trait, which returns
    `Ok()` with the position that it found the item in and `Err()` with the position
    that the item should have been found at. Check out the documentation at [https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search](https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Others will love your expressive APIs once you master using multiple `Result` and
    `Option` types to communicate beyond success and failure. Keep learning by moving
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exceptions represent a special case in many programs: they have their own execution
    path and the program can jump into this path any time. Is this ideal, though?
    This depends on the size of the `try` block (or whatever the name); this might
    cover several statements and debugging a runtime exception stops being fun quickly.
    A better way to achieve safe error handling could be to integrate errors in the
    results of a function call—a practice that can already be seen in C functions
    where the parameters do the data transfer and the return code indicates success/failure.
    Newer, more functional paradigms suggest something akin to the `Result` type in
    Rust—which comes with functions to elegantly deal with the various outcomes. This
    makes the errors an expected outcome of a function and enables smooth error handling
    without additional `if` conditions for every call.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll go over several methods to work with errors seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through some steps to handle errors seamlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new exceptional-results --lib` and open it
    with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and replace the existing test with a new test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name suggests, we''ll add some positive result tests in the function''s
    body. Let''s start with a declaration and something simple. Replace the preceding `//
    code goes here` section with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some more variation since multiple `Result` types can behave just
    like Booleans. Add some more code into the `good_results` test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, where there are good results, bad results may happen too! In the case
    of the `Result` type, it is about the `Err` variant. Add another empty test called
    `negative_results`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like before, we are replacing the `//code goes here` comment with some
    actual tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the positive results, the negative results often have their own
    functions such as `map_err`. Contrary to that, the Boolean functions behave consistently
    and treat the `Err` result as false. Add the following to the `negative_results`
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we run `cargo test` to see the test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Do you want to know more? Keep reading to find out how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Result` type is important for creating code that integrates all of the possible
    function outcomes into the regular workflow. This eliminates the need for special
    handling of exceptions, making the code less verbose and easier to reason about.
    Since these types are known beforehand, the library can offer specialized functions
    as well, which is what we are looking at in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first few steps (*step 2* to *step 4*), we are working with positive
    results, which means values that are wrapped in the `Ok` enum variant. First,
    we covered the `and_then` function, which provides chaining of various functions
    that should only be executed when the initial `Result` is `Ok`. In the case of
    an `Err` return value of one of the functions in the chain, the `Err` result is
    passed through, skipping the positive handlers (such as `and_then` and `map`).
    Similarly, `map()` allows transformation within the `Result` type. Both `map`
    and `and_then` only make it possible to transform `Result<i32, i32>` into `Result<MyOwnType,
    i32>` but not `MyOwnType` alone. Lastly, the test covers Boolean operations with
    the multiple `Result` types summarized in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **A and B** |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | `Ok` | `Ok` (B) |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | `Err` | `Err` |'
  prefs: []
  type: TYPE_TB
- en: '| `Err` | `Ok` | `Err`  |'
  prefs: []
  type: TYPE_TB
- en: '| `Err` | `Err` | `Err` (A) |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | `Ok` | `Ok` (A) |'
  prefs: []
  type: TYPE_TB
- en: 'The remaining steps (*step 5* to *step 7*) show the same process with a negative
    result type: `Err`. In the same manner that `map()` handles only `Ok` results, `map_err()`
    transforms `Err`. A special case of that is the `or_else()` function, which executes
    the provided closure whenever `Err` was returned. The last parts of the test cover
    the Boolean functions of multiple `Result` types and show how they work with various
    `Err` parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen many different variations of working with `Ok` and `Err`,
    let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `Result` type doesn''t care about the type it returns in the `Err`
    branch, returning `String` instances for error messages is not ideal either. Typical
    errors have several things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a root cause or error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the error message?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a more in-depth message to output?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard library's errors all follow a common trait from `std::error::Error`—let's
    see how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining error types is not hard—just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new custom-errors` and open it with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using VS Code, open `src/main.rs` and create a basic struct called `MyError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an `Error` trait that we can implement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the trait also requires us (next to `Debug`—which we derived) to implement
    `std::fmt::Display`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s see these traits in action and replace the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see everything work together using `cargo run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's see whether we can get behind the scenes of this short recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although any type will work just fine in a `Result` arm, Rust offers an error
    trait that can be implemented for better integration into other crates. An example
    of that is the `actix_web` framework's error handling ([https://actix.rs/docs/errors/](https://actix.rs/docs/errors/))
    that works with `std::error::Error` as well as with its own types (we will look
    at that in more depth in [Chapter 8](e90b9507-b016-4a88-aefa-54e710617d96.xhtml), *Safe
    Programming for the Web*).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, the `Error` trait also offers nesting, and, using dynamic
    dispatch, all `Errors` can follow a common API. In *step 2*, we declare the type
    and derive the (mandatory) `Debug` trait. In *step 3* and *step 4*, the remaining
    implementations follow. The rest of the recipe executes the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this short and sweet recipe, we can create custom error types. Now, let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Resilient programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning `Result` or `Option` will always follow a certain pattern that generates
    a lot of boilerplate code—especially for uncertain operations such as reading
    or creating files and searching for values. In particular, the pattern produces
    either code that uses early returns a lot (remember `goto`?) or nested statements,
    both of which produce code that is hard to reason about. Therefore, early versions
    of the Rust library implemented a `try!` macro, which has been replaced with the `?` operator
    as a quick early return option. Let's see how that influences the code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to write more resilient programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new resilient-programming` and open it with
    VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` to add a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function prints the file contents if it finds the file; in addition
    to that, we have to call this function. For that, replace the existing `main`
    function with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it—run `cargo run` to find out what the results are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these four steps, we saw the use of the question mark operator and how it
    can avoid the boilerplate typically associated with guards. In *step 3*, we create
    a function that prints the file contents if the file has been found (and was readable),
    and, by using the `?` operator, we can skip checking the return value and exiting
    the function if necessary—it's all done with a simple `?` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we not only call the previously created function, but we are also
    printing the result to show how it works. On top of that, the same pattern is
    applied to the (special) `main` function, which now has a return value. Therefore,
    `?` is not limited to sub-functions but can be applied throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: In just a few simple steps, we have seen how to use the `?` operator to unwrap
    `Result` safely. Now, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Working with external crates for error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and wrapping errors is a common task in modern programs. However, as
    we have seen in various recipes in this chapter, it can be quite tedious to handle
    every possible case and, on top of that, care about each possible variation that
    might be returned. This problem is well known and the Rust community has come
    up with ways to make that a lot easier. We'll touch on macros in the next chapter
    ([Chapter 6](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml), *Expressing Yourself
    with Macros*), but creating error types leans a lot on using macros. Additionally,
    this recipe mirrors a previous recipe (*Handling multiple errors*) to show the
    differences in code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s pull in some external crates to handle errors better in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new external-crates` and open it with VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `Cargo.toml` to add the `quick-error` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the provided macros in `quick-error`, we need to import them explicitly.
    Add the following `use` statements to `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In one step, we are then going to add all of the errors we want to declare
    inside the `quick_error!` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is only complete when the `main` function is added as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `cargo run` to find the output of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Did you understand the code? Let's find out how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the previous recipe where we declared multiple errors, this declaration
    is much shorter and has several added benefits. The first benefit is that each
    error type can be created using the `From` trait (first `IOError` in *step 4*).
    Secondly, each type generates an automated description and `Display` implementation
    (see *step 3,* `UnexpectedDeviceStateError`, and then *step 5*) with the error's
    name. This is not perfect, but OK as a first step.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, `quick-error` generates one enum that handles all possible cases
    and generates the implementations if necessary. Check out the `main` macro—quite
    impressive ([http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html](http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html))! To
    tailor the use of `quick-error` to your needs, check out the rest of their documentation
    at [http://tailhook.github.io/quick-error/quick_error/index.html](http://tailhook.github.io/quick-error/quick_error/index.html).
    Alternatively, there is the `error-chain` crate ([https://github.com/rust-lang-nursery/error-chain](https://github.com/rust-lang-nursery/error-chain)),
    which takes a different approach to create those error types. Either of these
    options lets you vastly improve the readability and implementation speed of your
    errors while removing all of the boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to improve our error handling by using external
    crates. Now, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Moving between Option and Result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a binary result is to be returned from a function, the choice is between
    using `Result` or `Option`. Both can communicate a failed function call—but the
    former provides too much specificity, while the latter may give too little. While
    this is a decision to make for the specific situation, Rust's types provide the
    tools to move between them with ease. Let's go over them in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a few quick steps, you''ll know how to move between `Option` and `Result`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new options-results --lib` and open it with
    VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s edit `src/lib.rs` and replace the existing test (inside `mod tests`)
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to replace `// code will follow` with an example of how to use the
    `transpose()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This works with `Err` as well and, for proof, add this to the `transpose()`
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is the special case of `None`. Complete the `transpose()` test
    with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving between the two types is not only about transposing—there are more complex
    ways to do that too. Create another `test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As a first test, let''s replace `// more to follow` with something that can
    be used instead of `unwrap()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the conversion test, also add the following to `test`. These are
    conversions but from the `Err` side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we should run the code using `cargo test` and see successful test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the discussion of when to use `Option` and when to use `Result` takes
    place on a high level, Rust supports the transition between the two types with
    several functions. In addition to `map()`, `and_then()`, and so on (discussed
    in the *Seamless error handling* section in this chapter), these functions provide
    powerful and elegant ways to work with a variety of errors. In *step 1* to *step
    4,* we are slowly building a simple test that shows the applicability of the transpose
    function. It makes it possible to switch from `Ok(Some(42))` to `Some(Ok(42))` (notice
    the subtle difference) with a single call to a function. Similarly, the `Err`
    variation of the call goes from a regular `Err(MyError)` function to `Some(Err(MyError))`.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining steps (*step 6* to *step 8*) show more traditional ways to convert
    between the two types. These include fetching the values of `Ok` and `Err`, as
    well as providing an error instance for positive results. In general, these functions
    should be enough to replace most `unwrap()` or `expect()` calls and have a single
    execution path through the program without having to resort to `if` and `match`
    conditionals. This adds the bonus of robustness and readability, and your future
    colleagues and users will thank you!
  prefs: []
  type: TYPE_NORMAL
