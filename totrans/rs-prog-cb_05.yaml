- en: Handling Errors and Other Results
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和其他结果
- en: 'Handling errors is always an interesting challenge in every programming language.
    There are many styles available: returning numeric values, exceptions (software
    interrupts), result and option types, and so on. Each way requires different architectures
    and has implications for performance, readability, and maintainability. Rust''s
    approach is—just like many functional programming languages—based on integrating
    failure as part of the regular workflow. This means that whatever the return value,
    an error is not a special case but integrated into the handling. `Option` and
    `Result` are the central types that allow for returning results as well as errors.
    `panic!` is an additional macro to halt the thread immediately in case it cannot/should
    not continue.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，处理错误始终是一个有趣的挑战。有许多风格可供选择：返回数值、异常（软件中断）、结果和选项类型等。每种方式都需要不同的架构，并对性能、可读性和可维护性有影响。Rust
    的方法——就像许多函数式编程语言一样——基于将失败集成到常规工作流程中。这意味着无论返回值如何，错误都不是一个特殊情况，而是集成到处理中。`Option`
    和 `Result` 是中心类型，允许返回结果以及错误。`panic!` 是一个额外的宏，在无法/不应继续时立即停止线程。
- en: 'In this chapter, we''ll cover some basic recipes and architectures to use Rust''s
    error handling effectively so that your code is easy to read, understand, and
    maintain. For this reason, in this chapter, you can look forward to learning about the
    following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些基本的配方和架构，以有效地使用 Rust 的错误处理，使你的代码易于阅读、理解和维护。因此，在本章中，你可以期待学习以下配方：
- en: Panicking responsibly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责任地恐慌
- en: Handling multiple errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个错误
- en: Working with exceptional results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与异常结果一起工作
- en: Seamless error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝错误处理
- en: Customizing errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义错误
- en: Resilient programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性编程
- en: Working with external crates for error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部 crate 进行错误处理
- en: Moving between Option and Result
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Option 和 Result 之间移动
- en: Panicking responsibly
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负责任地恐慌
- en: Sometimes, there is no way for an execution thread to continue. This may be
    due to things such as invalid configuration files, unresponsive peers or servers,
    or OS-related errors. Rust has many ways to panic, explicitly or implicitly. The
    most ubiquitous one is probably `unwrap()` for multiple `Option` types and related
    types, which panic on error or `None`. Yet, for more complex programs, it is essential
    to take control of the panicking (for example, by avoiding multiple `unwrap()` calls
    and libraries that use it) and the `panic!` macro supports that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，执行线程无法继续执行。这可能是由于无效的配置文件、无响应的同伴或服务器，或与操作系统相关的错误。Rust 有许多方法可以恐慌，无论是显式还是隐式。最普遍的一个可能是
    `unwrap()` 对于多个 `Option` 类型及其相关类型，它在出错或 `None` 时会恐慌。然而，对于更复杂的程序，控制恐慌（例如，通过避免多个
    `unwrap()` 调用和使用它的库）是至关重要的，而 `panic!` 宏支持这一点。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s examine how we can take control of multiple `panic!` instances:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何可以控制多个 `panic!` 实例：
- en: Create a new project with `cargo new panicking-responsibly --lib` and open it
    with VS Code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new panicking-responsibly --lib` 创建一个新的项目，并用 VS Code 打开它。
- en: 'Open `src/lib.rs` and replace the default tests with a regular, straightforward
    panic instances:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/lib.rs` 并将默认测试替换为常规、直接的恐慌实例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are many other ways to halt the program too. Let''s add another `test`
    instance:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有许多其他停止程序的方法。让我们添加另一个 `test` 实例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, these panics all have a generic error message, which is not very informative
    with regard to what the application was doing. Using `expect()` lets you provide
    an error message to explain the causes of the error:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这些恐慌都有一个通用的错误消息，这并不很有助于了解应用程序正在做什么。使用 `expect()` 可以让你提供一个错误消息来解释错误的起因：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `panic!` macro provides a similar way of explaining the sudden halt:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`panic!` 宏提供了一种类似的方式来解释突然的停止：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The macro can also return numerical values, something that is very important
    for Unix-type OSes that can check for those values. Add another test to return 
    an integer code to indicate a specific failure:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏也可以返回数值，这对于可以检查这些值的 Unix 类操作系统来说非常重要。添加另一个测试以返回一个整数代码来指示特定的失败：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another great way of halting the program based on invalid values is by using
    the `assert!` macro. It should be well-known from writing tests, so let''s add
    a few to see Rust''s variants:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于无效值停止程序的另一种很好的方法是使用 `assert!` 宏。它应该从编写测试中很熟悉，所以让我们添加一些来看看 Rust 的变体：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last step is, as usual, to compile and run the code we have just written
    using `cargo test`. The output shows whether the tests have passed (which they
    should):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，像往常一样，使用`cargo test`编译并运行我们刚刚编写的代码。输出显示测试是否通过（它们应该通过）：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But how does this allow us to panic responsibly? Let's see how it works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但这如何让我们能够负责任地恐慌呢？让我们看看它是如何工作的。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Thanks to Rust's ability to check panic results, we can verify the messages
    and the fact that the panic occurred. From *step 2* to *step 4*, we are simply
    panicking using various (common) methods, such as `unwrap()` ([https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap))
    or `panic!()` ([https://doc.rust-lang.org/std/macro.panic.html](https://doc.rust-lang.org/std/macro.panic.html)).
    These methods return messages such as ``'called `Option::unwrap()` on a `None`
    value', src/libcore/option.rs:347:21``, or `panicked at 'explicit panic', src/lib.rs:64:9`,
    which are not easy to debug.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Rust检查panic结果的能力，我们可以验证消息和panic发生的事实。从*步骤2*到*步骤4*，我们只是在使用各种（常见）方法恐慌，例如`unwrap()`
    ([https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap))或`panic!()`
    ([https://doc.rust-lang.org/std/macro.panic.html](https://doc.rust-lang.org/std/macro.panic.html))。这些方法返回的消息，如`'called
    `Option::unwrap()` on a `None` value', src/libcore/option.rs:347:21`或`panicked
    at 'explicit panic', src/lib.rs:64:9`，并不容易调试。
- en: However, there is a variation of `unwrap()` called `expect()`, which takes a `&str`
    parameter as a simple message for users to debug the issue further. *Steps 4* to* 6*
    show how messages and return values are incorporated. In *step 7*, we cover the
    additional `assert!` macro that is typically seen in tests but finds its way into
    productive systems as well to guard against rare and irrecoverable values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个名为`unwrap()`的`expect()`变体，它接受一个`&str`参数作为用户用于进一步调试问题的简单消息。*步骤4*到*步骤6*展示了如何结合消息和返回值。在*步骤7*中，我们介绍了额外的`assert!`宏，它通常在测试中看到，但也进入生产系统以防止罕见且无法恢复的值。
- en: Halting the execution of a thread or program should always be the last resort,
    especially when you are creating a library for others to use. Think about it—some
    bug leads to an unexpected value in a third-party library, which then panics and
    brings the service to an immediate unexpected halt. Imagine if that happened thanks
    to a call to `unwrap()` instead of using more robust methods.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 停止线程或程序的执行应该是最后的手段，尤其是在你为他人创建库时。想想看——一些错误导致第三方库中出现意外的值，然后引发恐慌并使服务立即意外停止。想象一下，如果这种情况是由于调用`unwrap()`而不是使用更健壮的方法而发生的。
- en: We've successfully learned how to panic responsibly. Now, let's move on to the
    next recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学会了如何负责任地恐慌。现在，让我们继续下一个菜谱。
- en: Handling multiple errors
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个错误
- en: Whenever an application becomes more complex and includes third-party frameworks,
    all kinds of error types need to be taken care of *consistently *without having
    a condition for each one. For example, a web service's large range of possible
    errors can bubble up to the handler where they need to be translated into HTTP
    codes with informative messages. These expected errors can range from parser errors
    to invalid authentication details, failed database connections, or an application-specific
    error with an error code. In this recipe, we'll cover how to deal with this variety
    of errors using wrappers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序变得更加复杂并包含第三方框架时，需要一致地处理各种错误类型，而不需要对每个错误都设置条件。例如，一个网络服务的大量可能错误可能会冒泡到处理器，在那里它们需要被转换成带有信息性消息的HTTP代码。这些预期的错误可能从解析错误到无效的认证细节，失败的数据库连接，或者带有错误代码的应用程序特定错误。在这个菜谱中，我们将介绍如何使用包装器来处理这些各种错误。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create an error wrapper in a few steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分几个步骤创建一个错误包装器：
- en: Open the project you created with `cargo new multiple-errors` with VS Code.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code打开你用`cargo new multiple-errors`创建的项目。
- en: 'Open `src/main.rs` to and add some imports at the top:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/main.rs`并添加一些顶部的导入：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our application, we will deal with three user-defined errors. Let''s declare
    them right after the imports:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将处理三种用户定义的错误。让我们在导入之后立即声明它们：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now for the wrapper: since we are dealing with multiple variations of something, `enum`
    will fit the purpose perfectly:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是包装器的时间：由于我们正在处理某种事物的多个变体，`enum`将完美地满足这个目的：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, it would be nice to have the same interface as other errors, so let''s
    implement the `std::error::Error` trait:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果有一个与其他错误相同的接口那就更好了，所以让我们实现`std::error::Error`特质：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The trait makes it necessary to implement `std::fmt::Display` as well, so this
    will be the next `impl` block:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特性使得必须实现`std::fmt::Display`，因此这将是我们下一个`impl`块：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we want to see the results of our labor. Replace the existing `main` function
    as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想看到我们劳动的结果。按照以下方式替换现有的`main`函数：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we execute `cargo run` to see that the output matches what we expected
    before:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们执行`cargo run`以查看输出是否与我们之前预期的相符：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后，更好地理解代码。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Multiple errors may not seem much of an issue at first, but for a clean, readable
    architecture, it is necessary to address them somehow. An enum that wraps possible
    variants has been shown to be the most practical solution, and, by implementing
    `std::error::Error` (and the `std::fmt::Display` requirement), the handling of
    the new error type should be seamless. In *steps 3* to* 6*, we show an example
    implementation of the required traits in a reductionist fashion. *Step 7* shows
    how to use the wrapping enum and how to use the `Display` and `Error` implementations
    to help match the variants.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多个错误一开始可能看起来不是什么大问题，但对于一个清晰、易读的架构，有必要以某种方式解决它们。一个封装可能变体的枚举已被证明是最实用的解决方案，通过实现`std::error::Error`（以及`std::fmt::Display`要求），新错误类型的处理应该无缝。在*步骤3*到*6*中，我们以简约的方式展示了所需特性的示例实现。*步骤7*展示了如何使用封装枚举以及如何使用`Display`和`Error`实现来帮助匹配变体。
- en: Implementing the `Error` trait will allow interesting aspects in the future,
    including recursive nesting. Check the documentation at [https://doc.rust-lang.org/std/error/trait.Error.html#method.source](https://doc.rust-lang.org/std/error/trait.Error.html#method.source) to
    find out more. Typically, we would not create these error variants themselves
    if we can avoid it, which is why there are supportive crates taking care of all
    of the boilerplate code—we'll cover that in a different recipe in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Error`特性将在未来允许有趣的特点，包括递归嵌套。检查[https://doc.rust-lang.org/std/error/trait.Error.html#method.source](https://doc.rust-lang.org/std/error/trait.Error.html#method.source)文档以了解更多信息。通常，如果我们能避免，我们不会创建这些错误变体，这就是为什么有支持性crate负责所有样板代码——我们将在本章的另一道菜中介绍这一点。
- en: Let's move on to the next recipe to complement our newfound skills in handling
    multiple errors!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一个菜谱，以补充我们在处理多个错误方面的新技能！
- en: Working with exceptional results
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与异常结果一起工作
- en: 'Other than the `Option` type, a `Result` type can have two custom types, which
    means that `Result` provides additional information about the cause of the error.
    This is more expressive than returning `Option`, which returns a single type instance
    or `None`. However, this `None` instance can mean anything from *failure to process* to
    *wrong input*. This way, the `Result` type can be seen as a similar system as
    exceptions in other languages, but they are part of the regular workflow of a
    program. One example is a search, where a multitude of scenarios can happen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Option`类型外，`Result`类型还可以有两个自定义类型，这意味着`Result`提供了关于错误原因的额外信息。这比返回单个类型实例或`None`的`Option`更具有表达性。然而，这个`None`实例可以意味着从*处理失败*到*输入错误*的任何东西。这样，`Result`类型可以被视为与其他语言中的异常类似系统，但它们是程序常规工作流程的一部分。一个例子是搜索，其中可能发生多种情况：
- en: The desired value is found.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到了所需值。
- en: The desired value is not found.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未找到所需值。
- en: The collection was invalid.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合无效。
- en: The value was invalid.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值无效。
- en: How can you use the `Result` type effectively? Let's find out in this recipe!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如何有效地使用`Result`类型？让我们在这个菜谱中找出答案！
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are some steps for working with `Result` and `Option`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用`Result`和`Option`的步骤：
- en: Create a new project with `cargo new exceptional-results --lib` and open it
    with VS Code.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new exceptional-results --lib`创建一个新的项目，并用VS Code打开它。
- en: 'Open `src/lib.rs` and add a function before the `test` module:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/lib.rs`并在`test`模块之前添加一个函数：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As the name suggests, this is not the best way to communicate failure in Rust.
    What is a better way, though? One answer is to utilize the `Option` enum. Add
    another function underneath the first one:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名所示，这不是在Rust中传达失败的最佳方式。那么更好的方式是什么呢？一个答案是利用`Option`枚举。在第一个函数下面添加另一个函数：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This makes it possible to reason about the expected return values, but Rust
    allows a more expressive variation—such as the `Result` type. Add the following
    to the current collection of functions:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得推理预期的返回值成为可能，但Rust允许更丰富的变化——例如`Result`类型。将以下内容添加到当前函数集合中：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we implemented a few variations of the same function, let''s test
    them. For the first function, add the following to the `test` module and replace
    the existing (default) test:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现了几种相同函数的变体，让我们来测试它们。对于第一个函数，将以下内容添加到 `test` 模块中，并替换现有的（默认）测试：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The other test functions look very similar. To have consistent outcomes and
    show the differences between the return types, add these to the `test` module:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他测试函数看起来非常相似。为了保持一致的结果并展示返回类型之间的差异，将这些添加到 `test` 模块中：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s run `cargo test` to see the test results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 `cargo test` 来查看测试结果：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's see what's behind the scenes to understand the code better.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后发生了什么，以便更好地理解代码。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rust and many other programming languages use the `Result` type to communicate
    multiple function outcomes at once. This way, the function can return just as
    it was designed without (unexpected) jumps such as the exception mechanism.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 和许多其他编程语言使用 `Result` 类型来一次性传达多个函数结果。这样，函数可以像设计的那样返回，而不需要（意外的）跳跃，例如异常机制。
- en: In *step 3* of this recipe, we show one way of communicating errors that is
    common in other languages (for example, Java)—however, as we can see in the test
    (*step 6*), the outcome for an empty string is unexpected (`0` instead of `-1`).
    In *step 3*, we define a better return type, but is it enough? No, it isn't. In
    *step 4*, we implement the best version of the function where each `Result` type
    is easy to interpret and clearly defined.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的 *第 3 步* 中，我们展示了在其他语言中常见的错误通信方式（例如，Java）——然而，正如我们在测试 (*第 6 步*) 中所看到的，空字符串的结果是意外的（`0`
    而不是 `-1`）。在第 *3 步* 中，我们定义了一个更好的返回类型，但这足够吗？不，还不够。在第 *4 步* 中，我们实现了函数的最佳版本，其中每个 `Result`
    类型都易于解释和明确定义。
- en: One even greater example of how to use `Result` can be found in the standard
    library. It's the `quick_search` function on the `slice` trait, which returns
    `Ok()` with the position that it found the item in and `Err()` with the position
    that the item should have been found at. Check out the documentation at [https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search](https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search)
    for more details.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个如何使用 `Result` 的更伟大的例子可以在标准库中找到。它是 `slice` 特性上的 `quick_search` 函数，它返回找到项的位置的
    `Ok()` 和应该找到项的位置的 `Err()`。有关更多详细信息，请查看[https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search](https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search)文档。
- en: Others will love your expressive APIs once you master using multiple `Result` and
    `Option` types to communicate beyond success and failure. Keep learning by moving
    on to the next recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了使用多个 `Result` 和 `Option` 类型来传达成功和失败之外的信息的技巧，其他人会喜欢你的表达性 API。继续学习，进入下一个菜谱。
- en: Seamless error handling
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝错误处理
- en: 'Exceptions represent a special case in many programs: they have their own execution
    path and the program can jump into this path any time. Is this ideal, though?
    This depends on the size of the `try` block (or whatever the name); this might
    cover several statements and debugging a runtime exception stops being fun quickly.
    A better way to achieve safe error handling could be to integrate errors in the
    results of a function call—a practice that can already be seen in C functions
    where the parameters do the data transfer and the return code indicates success/failure.
    Newer, more functional paradigms suggest something akin to the `Result` type in
    Rust—which comes with functions to elegantly deal with the various outcomes. This
    makes the errors an expected outcome of a function and enables smooth error handling
    without additional `if` conditions for every call.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在许多程序中是一个特殊情况：它们有自己的执行路径，程序可以随时跳入这个路径。但这理想吗？这取决于 `try` 块的大小（或 whatever 的名称）；这可能会覆盖几个语句，调试运行时异常很快就会变得不有趣。实现安全错误处理的一种更好的方式可能是将错误集成到函数调用的结果中——这种做法已经在
    C 函数中看到，其中参数执行数据传输，返回代码表示成功/失败。较新的、更函数式的方法建议类似于 Rust 中的 `Result` 类型——它带有用于优雅地处理各种结果的功能。这使得错误成为函数的预期结果，并使错误处理无需为每个调用添加额外的
    `if` 条件。
- en: In this recipe, we'll go over several methods to work with errors seamlessly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍几种无缝处理错误的方法。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s go through some steps to handle errors seamlessly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些步骤来无缝处理错误：
- en: Create a new project with `cargo new exceptional-results --lib` and open it
    with VS Code.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new exceptional-results --lib` 创建一个新的项目，并用 VS Code 打开它。
- en: 'Open `src/lib.rs` and replace the existing test with a new test:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/lib.rs`并替换现有的测试为新测试：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the name suggests, we''ll add some positive result tests in the function''s
    body. Let''s start with a declaration and something simple. Replace the preceding `//
    code goes here` section with the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名所示，我们将在函数体中添加一些正面的结果测试。让我们从声明和简单的内容开始。用以下内容替换前面的`// code goes here`部分：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add some more variation since multiple `Result` types can behave just
    like Booleans. Add some more code into the `good_results` test:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些更多的变化，因为多个`Result`类型可以表现得就像布尔值一样。在`good_results`测试中添加一些更多的代码：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, where there are good results, bad results may happen too! In the case
    of the `Result` type, it is about the `Err` variant. Add another empty test called
    `negative_results`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有好结果的地方，也可能会有坏结果！在`Result`类型的情况下，这关乎`Err`变体。添加另一个名为`negative_results`的空测试：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just like before, we are replacing the `//code goes here` comment with some
    actual tests:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，我们将`//code goes here`注释替换为一些实际的测试：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Other than the positive results, the negative results often have their own
    functions such as `map_err`. Contrary to that, the Boolean functions behave consistently
    and treat the `Err` result as false. Add the following to the `negative_results`
    test:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了正面的结果外，负面的结果通常有自己的函数，例如`map_err`。与它相反，布尔函数表现一致，并将`Err`结果视为假。将以下内容添加到`negative_results`测试中：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the last step, we run `cargo test` to see the test results:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们运行`cargo test`来查看测试结果：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do you want to know more? Keep reading to find out how it works.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道更多吗？继续阅读以了解它是如何工作的。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Result` type is important for creating code that integrates all of the possible
    function outcomes into the regular workflow. This eliminates the need for special
    handling of exceptions, making the code less verbose and easier to reason about.
    Since these types are known beforehand, the library can offer specialized functions
    as well, which is what we are looking at in this recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类型对于创建将所有可能函数结果集成到常规工作流程中的代码非常重要。这消除了对异常的特殊处理需求，使代码更加简洁，更容易推理。由于这些类型事先已知，库可以提供专门的函数，这正是我们在本菜谱中要探讨的。'
- en: 'In the first few steps (*step 2* to *step 4*), we are working with positive
    results, which means values that are wrapped in the `Ok` enum variant. First,
    we covered the `and_then` function, which provides chaining of various functions
    that should only be executed when the initial `Result` is `Ok`. In the case of
    an `Err` return value of one of the functions in the chain, the `Err` result is
    passed through, skipping the positive handlers (such as `and_then` and `map`).
    Similarly, `map()` allows transformation within the `Result` type. Both `map`
    and `and_then` only make it possible to transform `Result<i32, i32>` into `Result<MyOwnType,
    i32>` but not `MyOwnType` alone. Lastly, the test covers Boolean operations with
    the multiple `Result` types summarized in this table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几个步骤（*步骤 2* 到 *步骤 4*），我们正在处理正面的结果，这意味着被`Ok`枚举变体包裹的值。首先，我们介绍了`and_then`函数，它提供了各种函数的链式调用，这些函数只有在初始`Result`为`Ok`时才应该执行。如果链中的某个函数返回`Err`值，则`Err`结果会被传递下去，跳过正面的处理器（如`and_then`和`map`）。同样，`map()`允许在`Result`类型内进行转换。`map`和`and_then`都只允许将`Result<i32,
    i32>`转换为`Result<MyOwnType, i32>`，但不能单独转换为`MyOwnType`。最后，测试覆盖了表中总结的多个`Result`类型的布尔运算：
- en: '| **A** | **B** | **A and B** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A and B** |'
- en: '| `Ok` | `Ok` | `Ok` (B) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | `Ok` | `Ok` (B) |'
- en: '| `Ok` | `Err` | `Err` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | `Err` | `Err` |'
- en: '| `Err` | `Ok` | `Err`  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Err` | `Ok` | `Err`  |'
- en: '| `Err` | `Err` | `Err` (A) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Err` | `Err` | `Err` (A) |'
- en: '| `Ok` | `Ok` | `Ok` (A) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | `Ok` | `Ok` (A) |'
- en: 'The remaining steps (*step 5* to *step 7*) show the same process with a negative
    result type: `Err`. In the same manner that `map()` handles only `Ok` results, `map_err()`
    transforms `Err`. A special case of that is the `or_else()` function, which executes
    the provided closure whenever `Err` was returned. The last parts of the test cover
    the Boolean functions of multiple `Result` types and show how they work with various
    `Err` parameters.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的步骤（*步骤 5* 到 *步骤 7*）展示了与负面的结果类型`Err`相同的处理过程：`map()`只处理`Ok`结果，`map_err()`转换`Err`。其特殊情况是`or_else()`函数，它在返回`Err`时执行提供的闭包。测试的最后部分涵盖了多个`Result`类型的布尔函数，并展示了它们如何与各种`Err`参数一起工作。
- en: Now that we have seen many different variations of working with `Ok` and `Err`,
    let's move on to the next recipe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了许多处理`Ok`和`Err`的不同变体，让我们继续下一个菜谱。
- en: Customizing errors
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义错误
- en: 'While the `Result` type doesn''t care about the type it returns in the `Err`
    branch, returning `String` instances for error messages is not ideal either. Typical
    errors have several things to consider:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Result`类型对`Err`分支返回的类型不关心，但返回`String`实例作为错误信息也不是最佳选择。典型的错误有几个需要考虑的因素：
- en: Is there a root cause or error?
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有根本原因或错误？
- en: What is the error message?
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是错误信息？
- en: Is there a more in-depth message to output?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有更深入的消息要输出？
- en: The standard library's errors all follow a common trait from `std::error::Error`—let's
    see how they are implemented.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的错误都遵循来自`std::error::Error`的通用特质——让我们看看它们是如何实现的。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Defining error types is not hard—just follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 定义错误类型并不难——只需遵循以下步骤：
- en: Create a new project with `cargo new custom-errors` and open it with VS Code.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new custom-errors`创建一个新的项目，并用VS Code打开它。
- en: 'Using VS Code, open `src/main.rs` and create a basic struct called `MyError`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code，打开`src/main.rs`并创建一个名为`MyError`的基本结构体：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is an `Error` trait that we can implement, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以实现一个`Error`特质，如下所示：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, the trait also requires us (next to `Debug`—which we derived) to implement
    `std::fmt::Display`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，特质还要求我们（除了我们推导出的`Debug`之外）实现`std::fmt::Display`：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, let''s see these traits in action and replace the `main` function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看这些特质是如何发挥作用的，并替换`main`函数：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can see everything work together using `cargo run`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`cargo run`看到一切是如何协同工作的：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's see whether we can get behind the scenes of this short recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以深入了解这个简短的食谱。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although any type will work just fine in a `Result` arm, Rust offers an error
    trait that can be implemented for better integration into other crates. An example
    of that is the `actix_web` framework's error handling ([https://actix.rs/docs/errors/](https://actix.rs/docs/errors/))
    that works with `std::error::Error` as well as with its own types (we will look
    at that in more depth in [Chapter 8](e90b9507-b016-4a88-aefa-54e710617d96.xhtml), *Safe
    Programming for the Web*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何类型在`Result`分支中都可以正常工作，但Rust提供了一个错误特质，可以用于更好地集成到其他crate中。一个例子是`actix_web`框架的错误处理（[https://actix.rs/docs/errors/](https://actix.rs/docs/errors/)），它既与`std::error::Error`一起工作，也与其自己的类型一起工作（我们将在第8章[Chapter
    8](e90b9507-b016-4a88-aefa-54e710617d96.xhtml)，*Web的安全编程*）进行更深入的探讨）。
- en: In addition to that, the `Error` trait also offers nesting, and, using dynamic
    dispatch, all `Errors` can follow a common API. In *step 2*, we declare the type
    and derive the (mandatory) `Debug` trait. In *step 3* and *step 4*, the remaining
    implementations follow. The rest of the recipe executes the code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Error`特质还提供了嵌套，并且，通过动态分派，所有`Errors`都可以遵循一个通用的API。在*步骤2*中，我们声明类型并推导出（强制性的）`Debug`特质。在*步骤3*和*步骤4*中，剩余的实现遵循。其余的食谱执行代码。
- en: In this short and sweet recipe, we can create custom error types. Now, let's
    move on to the next recipe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短而甜美的食谱中，我们可以创建自定义错误类型。现在，让我们继续下一个食谱。
- en: Resilient programming
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性编程
- en: Returning `Result` or `Option` will always follow a certain pattern that generates
    a lot of boilerplate code—especially for uncertain operations such as reading
    or creating files and searching for values. In particular, the pattern produces
    either code that uses early returns a lot (remember `goto`?) or nested statements,
    both of which produce code that is hard to reason about. Therefore, early versions
    of the Rust library implemented a `try!` macro, which has been replaced with the `?` operator
    as a quick early return option. Let's see how that influences the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Result`或`Option`将始终遵循一个特定的模式，该模式生成大量的模板代码——特别是对于不确定的操作，如读取或创建文件和搜索值。特别是，该模式会产生大量使用早期返回的代码（记得`goto`吗？）或嵌套语句，这两种情况都会产生难以推理的代码。因此，Rust库的早期版本实现了一个`try!`宏，它已被`?`运算符所取代，作为快速早期返回的选项。让我们看看这如何影响代码。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to write more resilient programs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编写更健壮的程序：
- en: Create a new project with `cargo new resilient-programming` and open it with
    VS Code.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new resilient-programming`创建一个新的项目，并用VS Code打开它。
- en: 'Open `src/main.rs` to add a function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/main.rs`以添加一个函数：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding function prints the file contents if it finds the file; in addition
    to that, we have to call this function. For that, replace the existing `main`
    function with this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的函数在找到文件时会打印文件内容；除此之外，我们还需要调用这个函数。为此，用以下内容替换现有的`main`函数：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s it—run `cargo run` to find out what the results are:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样——运行`cargo run`以找出结果：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In these four steps, we saw the use of the question mark operator and how it
    can avoid the boilerplate typically associated with guards. In *step 3*, we create
    a function that prints the file contents if the file has been found (and was readable),
    and, by using the `?` operator, we can skip checking the return value and exiting
    the function if necessary—it's all done with a simple `?` operator.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个步骤中，我们看到了问号运算符的使用以及它是如何避免与守卫相关的典型模板代码。在*步骤3*中，我们创建了一个函数，如果找到了文件（并且可读），它会打印文件内容；通过使用`?`运算符，我们可以跳过检查返回值并在必要时退出函数——所有这些操作都通过简单的`?`运算符完成。
- en: In *step 4*, we not only call the previously created function, but we are also
    printing the result to show how it works. On top of that, the same pattern is
    applied to the (special) `main` function, which now has a return value. Therefore,
    `?` is not limited to sub-functions but can be applied throughout the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们不仅调用了之前创建的函数，而且还打印了结果以展示其工作方式。此外，相同的模式也应用于（特殊的）`main`函数，它现在有返回值。因此，`?`不仅限于子函数，还可以应用于整个应用程序。
- en: In just a few simple steps, we have seen how to use the `?` operator to unwrap
    `Result` safely. Now, let's move on to the next recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个简单的步骤，我们就看到了如何安全地使用`?`运算符来解包`Result`。现在，让我们继续下一个菜谱。
- en: Working with external crates for error handling
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部crate进行错误处理
- en: Creating and wrapping errors is a common task in modern programs. However, as
    we have seen in various recipes in this chapter, it can be quite tedious to handle
    every possible case and, on top of that, care about each possible variation that
    might be returned. This problem is well known and the Rust community has come
    up with ways to make that a lot easier. We'll touch on macros in the next chapter
    ([Chapter 6](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml), *Expressing Yourself
    with Macros*), but creating error types leans a lot on using macros. Additionally,
    this recipe mirrors a previous recipe (*Handling multiple errors*) to show the
    differences in code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代程序中，创建和包装错误是一个常见的任务。然而，正如我们在本章的各种菜谱中所看到的，处理每一个可能的案例以及关心可能返回的每个可能的变体可能会相当繁琐。这个问题是众所周知的，Rust社区已经找到了使这变得更容易的方法。我们将在下一章（[第6章](a8fae7de-6021-4d6e-9c75-e24288bc92e7.xhtml)，*使用宏表达自己*）中涉及宏，但创建错误类型很大程度上依赖于使用宏。此外，这个菜谱与之前的菜谱（*处理多个错误*）相呼应，以展示代码中的差异。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s pull in some external crates to handle errors better in just a few steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个步骤引入一些外部crate来更好地处理错误：
- en: Create a new project with `cargo new external-crates` and open it with VS Code.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new external-crates`创建一个新的项目，并用VS Code打开它。
- en: 'Edit `Cargo.toml` to add the `quick-error` dependency:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`Cargo.toml`以添加`quick-error`依赖项：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To use the provided macros in `quick-error`, we need to import them explicitly.
    Add the following `use` statements to `src/main.rs`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`quick-error`中提供的宏，我们需要显式地导入它们。将以下`use`语句添加到`src/main.rs`中：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In one step, we are then going to add all of the errors we want to declare
    inside the `quick_error!` macro:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将一步添加所有我们想要在`quick_error!`宏中声明的错误：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The code is only complete when the `main` function is added as well:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码只有在添加了`main`函数后才是完整的：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use `cargo run` to find the output of the program:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo run`来查找程序的输出：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Did you understand the code? Let's find out how it works.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你理解代码了吗？让我们找出它是如何工作的。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Compared to the previous recipe where we declared multiple errors, this declaration
    is much shorter and has several added benefits. The first benefit is that each
    error type can be created using the `From` trait (first `IOError` in *step 4*).
    Secondly, each type generates an automated description and `Display` implementation
    (see *step 3,* `UnexpectedDeviceStateError`, and then *step 5*) with the error's
    name. This is not perfect, but OK as a first step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前声明多个错误的菜谱相比，这个声明要短得多，并且有几个额外的优点。第一个优点是，每个错误类型都可以使用`From`特质创建（*步骤4*中的第一个`IOError`）。其次，每个类型都会自动生成错误名称的描述和`Display`实现（参见*步骤3*中的`UnexpectedDeviceStateError`，然后是*步骤5*）。这并不完美，但作为第一步是不错的。
- en: Under the hood, `quick-error` generates one enum that handles all possible cases
    and generates the implementations if necessary. Check out the `main` macro—quite
    impressive ([http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html](http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html))! To
    tailor the use of `quick-error` to your needs, check out the rest of their documentation
    at [http://tailhook.github.io/quick-error/quick_error/index.html](http://tailhook.github.io/quick-error/quick_error/index.html).
    Alternatively, there is the `error-chain` crate ([https://github.com/rust-lang-nursery/error-chain](https://github.com/rust-lang-nursery/error-chain)),
    which takes a different approach to create those error types. Either of these
    options lets you vastly improve the readability and implementation speed of your
    errors while removing all of the boilerplate code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`quick-error` 生成一个处理所有可能情况的枚举，并在必要时生成实现。查看 `main` 宏——相当令人印象深刻（[http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html](http://tailhook.github.io/quick-error/quick_error/macro.quick_error.html)）！为了根据您的需求定制
    `quick-error` 的使用，请查看他们的其余文档，网址为 [http://tailhook.github.io/quick-error/quick_error/index.html](http://tailhook.github.io/quick-error/quick_error/index.html)。或者，还有
    `error-chain` crate ([https://github.com/rust-lang-nursery/error-chain](https://github.com/rust-lang-nursery/error-chain))，它采用不同的方法来创建这些错误类型。这两种选项中的任何一种都可以让您极大地提高错误的可读性和实现速度，同时移除所有样板代码。
- en: We've successfully learned how to improve our error handling by using external
    crates. Now, let's move on to the next recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何通过使用外部 crate 来改进我们的错误处理。现在，让我们继续到下一个菜谱。
- en: Moving between Option and Result
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Option 和 Result 之间切换
- en: Whenever a binary result is to be returned from a function, the choice is between
    using `Result` or `Option`. Both can communicate a failed function call—but the
    former provides too much specificity, while the latter may give too little. While
    this is a decision to make for the specific situation, Rust's types provide the
    tools to move between them with ease. Let's go over them in this recipe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数需要返回二进制结果时，选择使用 `Result` 或 `Option`。两者都可以传达函数调用失败的信息——但前者提供了过多的具体信息，而后者可能提供的信息过少。虽然这是一个针对特定情况做出的决定，但
    Rust 的类型提供了在它们之间轻松转换的工具。让我们在这道菜谱中逐一了解它们。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a few quick steps, you''ll know how to move between `Option` and `Result`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个快速步骤中，您将了解如何在不同之间切换 `Option` 和 `Result`：
- en: Create a new project with `cargo new options-results --lib` and open it with
    VS Code.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new options-results --lib` 创建一个新的项目，并用 VS Code 打开它。
- en: 'Let''s edit `src/lib.rs` and replace the existing test (inside `mod tests`)
    with the following:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编辑 `src/lib.rs` 并将现有的测试（在 `mod tests` 内部）替换为以下内容：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have to replace `// code will follow` with an example of how to use the
    `transpose()` function:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 `// code will follow` 替换为如何使用 `transpose()` 函数的示例：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This works with `Err` as well and, for proof, add this to the `transpose()`
    test:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也适用于 `Err`，为了证明这一点，将其添加到 `transpose()` 测试中：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'What''s left is the special case of `None`. Complete the `transpose()` test
    with this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的特殊情况是 `None`。使用以下内容完成 `transpose()` 测试：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Moving between the two types is not only about transposing—there are more complex
    ways to do that too. Create another `test`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两种类型之间切换不仅涉及转置——还有更复杂的方法可以做到这一点。创建另一个 `test`：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As a first test, let''s replace `// more to follow` with something that can
    be used instead of `unwrap()`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一次测试，让我们用可以替代 `unwrap()` 的内容替换 `// more to follow`：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To complete the conversion test, also add the following to `test`. These are
    conversions but from the `Err` side:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成转换测试，也请将以下内容添加到 `test` 中。这些是转换，但来自 `Err` 方面：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Lastly, we should run the code using `cargo test` and see successful test results:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该使用 `cargo test` 运行代码，并查看成功的测试结果：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入幕后，更好地理解代码。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While the discussion of when to use `Option` and when to use `Result` takes
    place on a high level, Rust supports the transition between the two types with
    several functions. In addition to `map()`, `and_then()`, and so on (discussed
    in the *Seamless error handling* section in this chapter), these functions provide
    powerful and elegant ways to work with a variety of errors. In *step 1* to *step
    4,* we are slowly building a simple test that shows the applicability of the transpose
    function. It makes it possible to switch from `Ok(Some(42))` to `Some(Ok(42))` (notice
    the subtle difference) with a single call to a function. Similarly, the `Err`
    variation of the call goes from a regular `Err(MyError)` function to `Some(Err(MyError))`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于何时使用 `Option` 和何时使用 `Result` 的讨论发生在较高层面，但 Rust 通过几个函数支持这两种类型之间的转换。除了 `map()`、`and_then()`
    等函数（在本章的 *无缝错误处理* 部分讨论过）之外，这些函数还提供了处理各种错误的有效且优雅的方法。在 *步骤 1* 到 *步骤 4* 中，我们逐渐构建了一个简单的测试，展示了转置函数的应用性。这使得通过一个函数调用就能从
    `Ok(Some(42))` 切换到 `Some(Ok(42))`（注意细微的区别）。同样，调用中的 `Err` 变体从常规的 `Err(MyError)`
    函数变为 `Some(Err(MyError))`。
- en: The remaining steps (*step 6* to *step 8*) show more traditional ways to convert
    between the two types. These include fetching the values of `Ok` and `Err`, as
    well as providing an error instance for positive results. In general, these functions
    should be enough to replace most `unwrap()` or `expect()` calls and have a single
    execution path through the program without having to resort to `if` and `match`
    conditionals. This adds the bonus of robustness and readability, and your future
    colleagues and users will thank you!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的步骤（*步骤 6* 到 *步骤 8*）展示了在两种类型之间转换的更传统方法。这包括获取 `Ok` 和 `Err` 的值，以及为正结果提供错误实例。一般来说，这些函数足以替换大多数
    `unwrap()` 或 `expect()` 调用，并且程序中只有一个执行路径，无需求助于 `if` 和 `match` 条件语句。这增加了鲁棒性和可读性的额外优势，你的未来同事和用户会感谢你！
