- en: Atomics – Safely Reclaiming Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作 – 安全地回收内存
- en: In the previous chapter, we discussed the atomic primitives available to the
    Rust programmer, implementing higher-level synchronization primitives and some
    data structures built entirely of atomics. A key challenge with atomic-only programming,
    compared to using higher-level synchronization primitives, is memory reclamation.
    It is only safe to free memory once. When we build concurrent algorithms only
    from atomic primitives, it's very challenging to do something only once and keep
    performance up. That is, safely reclaiming memory requires some form of synchronization.
    But, as the total number of concurrent actors rise, the cost of synchronization
    dwarfs the latency or throughput benefits of atomic programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Rust程序员可用的原子原语，实现了高级同步原语和一些完全由原子组成的数据结构。与使用高级同步原语相比，原子编程的一个关键挑战是内存回收。内存只能安全地释放一次。当我们仅从原子原语构建并发算法时，要只做一次并保持性能是非常具有挑战性的。也就是说，安全地回收内存需要某种形式的同步。但是，随着并发角色的总数增加，同步的成本会超过原子编程的延迟或吞吐量收益。
- en: In this chapter, we will discuss three techniques to resolve the memory reclamation
    issue of atomic programming—reference counting, hazard pointers, and epoch-based
    reclamation. These methods will be familiar to you from previous chapters, but
    here we will do a deep-dive on them, investigating their trade-offs. We will introduce
    two new libraries, `conc` and crossbeam, which implement hazard pointers and epoch-based
    reclamation, respectively. By the close of this chapter, you should have a good
    handle on the three approaches presented and be in a good place to start laying
    down production-quality code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论三种解决原子编程内存回收问题的技术——引用计数、危害指针和基于时代的回收。这些方法你从前几章中应该已经熟悉，但在这里我们将深入探讨它们，研究它们的权衡。我们将介绍两个新的库，`conc`和crossbeam，分别实现了危害指针和基于时代的回收。到本章结束时，你应该对这三种方法有很好的掌握，并准备好开始编写生产级别的代码。
- en: 'By the end of this chapter, we will have:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将：
- en: Discussed reference counting and its associated tradeoffs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论引用计数及其相关的权衡
- en: Discussed the hazard pointer approach to memory reclamation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论危害指针的内存回收方法
- en: Investigated a Treiber stack using the hazard pointer approach via the `conc`
    crate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`conc`库通过危害指针方法研究了Treiber栈
- en: Discussed the epoch-based reclamation strategy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论基于时代的回收策略
- en: Done a deep investigation of the `crossbeam_epoch` crate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`crossbeam_epoch`库进行了深入研究
- en: Investigated a Treiber stack using the epoch-based reclamation approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于时代的回收方法研究了Treiber栈
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a working Rust installation. The details of verifying
    your installation are covered in [Chapter 1](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml),
    *Preliminaries – Machine Architecture and Getting Started with Rust*. No additional
    software tools are required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装一个可工作的Rust环境。验证安装的详细信息请参阅[第1章](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml)，*预备知识
    – 计算机架构和Rust入门*。不需要额外的软件工具。
- en: 'You can find the source code for this book''s projects on GitHub: [https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust](https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust).
    The source code for this chapter is under `Chapter07`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本书项目的源代码：[https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust](https://github.com/PacktPublishing/Hands-On-Concurrency-with-Rust)。本章的源代码位于`Chapter07`。
- en: Approaches to memory reclamation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存回收方法
- en: In the discussion that follows, the three techniques are laid out roughly in
    order of their speed, slowest to fastest, as well as their difficulty, easiest
    to hardest. You should not be discouraged—you are now at one of the forefronts
    of the software engineering world. Welcome. Go boldly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论中，三种技术将按其速度大致排序，从慢到快，以及它们的难度，从易到难。你不应该气馁——你现在正处于软件工程世界的前沿。欢迎。大胆前行。
- en: Reference counting
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数
- en: Reference-counting memory reclamation associates a piece of protected data with
    an atomic counter. Every thread reading or writing to that protected data increases
    the counter on acquisition and decreases the counter on de-acquisition. The thread
    to decrease the counter and find it as zero is the last to hold the data and may
    either mark the data as available for reclamation or deallocate it immediately.
    This should, hopefully, sound familiar. The Rust standard library ships with `std::sync::Arc`—discussed
    in [Chapter 4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml), *Sync and Send – the
    Foundation of Rust Concurrency*, and [Chapter 5](e2de1ba7-c291-494e-82da-37fee7323c1d.xhtml),
    *Locks – Mutex, Condvar, Barriers and RWLock*, especially—to fulfill this exact
    need. While we discussed the usage of `Arc`, we did not discuss its internals
    previously, owing to our need to reach [Chapter 6](d42acb0b-a05e-4068-894f-81365d147bf4.xhtml), *Atomics – the
    Primitives of Synchronization*, before we had the necessary background. Let's
    dig into `Arc` now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数内存回收将一块受保护的数据与一个原子计数器关联。每个读取或写入该受保护数据的线程在获取时增加计数器，在释放时减少计数器。减少计数器并发现它为零的线程是最后一个持有数据的线程，它可以标记数据为可回收，或者立即释放它。这应该听起来很熟悉。Rust标准库附带`std::sync::Arc`——在第4章[4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml)，*同步和发送——Rust并发的基石*，以及第5章[5](e2de1ba7-c291-494e-82da-37fee7323c1d.xhtml)，*锁——Mutex,
    Condvar, Barriers和RWLock*中特别提到，以满足这一确切需求。虽然我们讨论了`Arc`的使用，但我们之前没有讨论其内部结构，因为我们需要先达到第6章[6](d42acb0b-a05e-4068-894f-81365d147bf4.xhtml)，*原子操作——同步的原始操作*，以获得必要的背景知识。现在让我们深入探讨`Arc`。
- en: 'The Rust compiler''s code for `Arc` is `src/liballoc/arc.rs`. The structure
    definition is compact enough:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Rust编译器的`Arc`代码在`src/liballoc/arc.rs`中。结构定义足够紧凑：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We encountered `Shared<T>` in [Chapter 3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml), 
    *The Rust Memory Model – Ownership, References and Manipulation*, with it being
    a pointer with the same characteristics as `*mut X` except that it is non-null.
    There are two functions for creating a new `Shared<T>`, which are `const unsafe
    fn new_unchecked(ptr: *mut X) -> Self` and `fn new(ptr: *mut X) -> Option<Self>`.
    In the first variant, the caller is responsible for ensuring that the pointer
    is non-null, in the second, the nulled nature of the pointer is checked. Please
    refer back to [Chapter 3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml),  *The Rust
    Memory Model – Ownership, References and Manipulation*, *Rc* section for a deep-dive.
    We know, then, that `ptr` in `Arc<T>` is non-null and, owing to the phantom data
    field, that the store of `T` is not held in `Arc<T>`. That''d be in `ArcInner<T>`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在第3章[3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml)，*Rust内存模型——所有权、引用和操作*中遇到了`Shared<T>`，它是一个具有与`*mut
    X`相同特性的指针，除了它不是空指针。创建新的`Shared<T>`有两个函数，分别是`const unsafe fn new_unchecked(ptr:
    *mut X) -> Self`和`fn new(ptr: *mut X) -> Option<Self>`。在第一个变体中，调用者负责确保指针不是空指针，在第二个变体中，检查指针是否为空。请参阅第3章[3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml)，*Rust内存模型——所有权、引用和操作*中的*Rc*部分以深入了解。我们知道，在`Arc<T>`中的`ptr`不是空指针，由于幻数数据字段，`T`的存储不在`Arc<T>`中。那会在`ArcInner<T>`中：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We see two inner `AtomicUsize` fields: `strong` and `weak`. Like `Rc`, `Arc<T>`
    allows two kinds of strength references to the interior data. A weak reference
    does not own the interior data, allowing for `Arc<T>` to be arranged in a cycle
    without causing an impossible memory-reclamation situation. A strong reference
    owns the interior data. Here, we see the creation of a new strong reference via
    `Arc<T>::clone() -> Arc<T>`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到两个内部`AtomicUsize`字段：`strong`和`weak`。像`Rc`一样，`Arc<T>`允许对内部数据有两种类型的强度引用。弱引用不拥有内部数据，允许`Arc<T>`在循环中排列而不造成不可能的内存回收情况。强引用拥有内部数据。在这里，我们看到通过`Arc<T>::clone()
    -> Arc<T>`创建一个新的强引用：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we can see that on every clone, the `strong` of `ArcInner<T>` is increased
    by one  when you use relaxed ordering. The code comment to this block—dropped
    for brevity in this text—asserts that relaxed ordering is sufficient owing to
    the circumstance of the use of `Arc`*.* Using a relaxed ordering is alright here,
    as knowledge of the original reference prevents other threads from erroneously
    deleting the object. This is an important consideration. Why does clone not require
    a more strict ordering? Consider a thread, `A`, that clones some `Arc<T>` and
    passes it to another thread, `B`, and then, having passed to `B`, immediately
    drops its own copy of `Arc`. We can determine from the inspection of `Arc<T>::new()
    -> Arc<T>` that, at creation time, `Arc` always has one strong and one weak reference:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，在每次克隆时，使用relaxed排序时，`ArcInner<T>`的`strong`会增加一个。对此代码块的注释——由于文本简洁性在此省略——断言由于`Arc`的使用情况，relaxed排序是足够的。在这里使用relaxed排序是可以的，因为对原始引用的了解可以防止其他线程错误地删除对象。这是一个重要的考虑因素。为什么克隆不需要更严格的排序？考虑一个线程`A`，它克隆了一些`Arc<T>`并将其传递给另一个线程`B`，然后，在传递给`B`之后，立即释放自己的`Arc`副本。我们可以从检查`Arc<T>::new()
    -> Arc<T>`中确定，在创建时，`Arc`始终有一个强引用和一个弱引用：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the perspective of thread `A`, the cloning of `Arc` is composed of the
    following operations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从线程`A`的角度来看，`Arc`的克隆由以下操作组成：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We know from discussion in the previous chapter, that `Release` ordering does
    not offer a causality relationship. It''s entirely possible that a hostile CPU
    could reorder the increment of `strong` to after the movement of  `New Arc` into
    `B`. Would we be in trouble if `B` then immediately dropped `Arc`? We need to
    inspect `Arc<T>::drop()`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一章的讨论中我们知道，`Release`排序不提供因果关系。完全有可能一个敌对的CPU会重新排序`strong`的增加，在`New Arc`移动到`B`之后。如果`B`随后立即释放`Arc`，我们会遇到麻烦吗？我们需要检查`Arc<T>::drop()`：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we go. `atomic::fence(Acquire)` is new to us. `std::sync::atomic::fence`
    prevents memory migration around itself, according to the causality relationship
    established by the provided memory ordering. The fence applies to same-thread
    and other-thread memory operations. Recall that `Release` ordering disallows loads
    and stores from migrating downward in the source-code order. Here, we see, that
    the load and store of strong will disallow migrations downward but will not be
    reordered after the `Acquire` fence. Therefore, the deallocation of the `T` interior
    to `Arc` will not happen until both the `A` and `B` threads have synchronized
    and removed all strong references. An additional thread, `C`, cannot come through
    and increase the strong references to the interior `T` while this is ongoing,
    owing to the causality relationship established—neither `A` nor `B` can give `C`
    a strong reference without increasing the strong counter, causing the drops of
    `A` or `B` to bail out early. A similar analysis holds for weak references.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始了。`atomic::fence(Acquire)`对我们来说是新的。`std::sync::atomic::fence`根据提供的内存排序建立的因果关系，防止内存迁移。栅栏适用于同一线程和其他线程的内存操作。回想一下，`Release`排序禁止在源代码顺序中向下迁移加载和存储。在这里，我们看到，强引用的加载和存储将禁止向下迁移，但不会在`Acquire`栅栏之后重新排序。因此，`T`内部的分配给`Arc`将不会发生，直到`A`和`B`两个线程都已同步并移除了所有强引用。由于建立了因果关系，一个额外的线程`C`不能在此时通过并增加内部`T`的强引用，因为`A`和`B`都不能在不增加强计数器的情况下给`C`一个强引用，这会导致`A`或`B`的释放提前退出。对于弱引用也有类似的结论。
- en: 'Doing an immutable dereference of `Arc` does not increase the strong or weak
    counts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Arc`进行不可变解引用不会增加强或弱计数：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because drop requires a mutable self, it is impossible to free `Arc<T>` while
    there is a valid `&T`. Getting `&mut T` is more involved, which is done via `Arc<T>::get_mut(&mut
    Self) -> Option<&mut T>`. Note that the return is an `Option`. If there are other
    strong or weak references to the interior `T`, then it''s not safe to consume `Arc`.
    The implementation of `get_mut` is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`drop`需要一个可变的`self`，所以在存在有效的`&T`时，无法释放`Arc<T>`。获取`&mut T`更为复杂，这是通过`Arc<T>::get_mut(&mut
    Self) -> Option<&mut T>`来实现的。请注意，返回值是一个`Option`。如果内部`T`有其他强或弱引用，那么消耗`Arc`是不安全的。`get_mut`的实现如下：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Where `is_unique` is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`is_unique`是：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The compare and exchange operation on weak ensures that there is only one weak
    reference outstanding—implying uniqueness—and does so on success with `Acquire`
    ordering. This ordering will force the subsequent check of the strong references
    to occur after the check of weak references in the code order and above the release
    store to the same. This exact technique will be familiar from our discussion on
    mutual exclusion in the previous chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在弱引用上进行的比较和交换操作确保只有一个弱引用存在——意味着唯一性——并在成功时使用 `Acquire` 排序。这种排序将迫使后续对强引用的检查在代码顺序中发生在弱引用检查之后，并且在释放存储之前。这种确切的技术在我们上一章关于互斥锁的讨论中已经熟悉。
- en: Tradeoffs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权衡
- en: Reference counting has much to recommend it as an approach for atomic memory
    reclamation. The programming model of reference counting is straightforward to
    understand and memory is reclaimed as soon as it's possible to be safely reclaimed.
    Programming reference-counted implementations without the use of `Arc<T>` remains
    difficult, owing to the lack of double-word compare and swap in Rust. Consider
    a Treiber stack in which the reference counter is internal to stack nodes. The
    head of the stack might be snapshotted, then freed by some other thread, and the
    subsequent read to the reference counter will be forced through an invalid pointer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数作为原子内存回收的方法有很多优点。引用计数的编程模型易于理解，并且一旦可以安全回收，就会立即回收内存。在 Rust 中，由于缺乏双字比较和交换，不使用
    `Arc<T>` 编程引用计数的实现仍然很困难。考虑一个 Treiber 栈，其中引用计数器是栈节点内部的。栈的头部可能被快照，然后由其他线程释放，后续对引用计数器的读取将被迫通过一个无效指针。
- en: 'The following reference-counted Treiber stack is flawed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引用计数的 Treiber 栈存在缺陷：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is one of the few (intentionally) flawed examples in this book. You are
    encouraged to apply the techniques discussed earlier in this book to identify
    and correct the flaws with this implementation. It should be interesting. J.D.
    Valois' 1995 paper, *Lock-Free Linked Lists Using Compare-and-Swap*, will be of
    use. You are further warmly encouraged to attempt a Treiber stack using only `Arc`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中故意存在的一些（故意）有缺陷的例子之一。鼓励你将本书前面讨论的技术应用到识别和纠正这个实现中的缺陷。这应该很有趣。J.D. Valois 1995年的论文，《使用比较和交换的无锁链表》，将会有所帮助。此外，强烈鼓励你尝试仅使用
    `Arc` 实现一个 Treiber 栈。
- en: Ultimately, where reference counting struggles is contention, as the number
    of threads operating on the same reference-counted data increase., those acquire/release
    pairs don't come cheaply. Reference counting is a good model when you expect the
    number of threads to be relatively low or where absolute performance is not a
    key consideration. Otherwise, you'll need to investigate the following methods,
    which have tradeoffs of their own.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当操作同一引用计数字据的线程数量增加时，引用计数的竞争问题就会出现，那些获取/释放对并不便宜。当预期线程数量相对较低或绝对性能不是关键考虑因素时，引用计数是一个很好的模型。否则，你需要调查以下方法，这些方法也有自己的权衡。
- en: Hazard pointers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 危险指针
- en: We touched on hazard pointers as a method for safe memory reclamation in the
    previous chapter. We'll now examine the concept in-depth and in the context of
    a more or less ready-to-use implementation via the Redox project ([https://crates.io/crates/conc](https://crates.io/crates/conc)).
    We'll be inspecting `conc` as a part of its parent project, tfs ([https://github.com/redox-os/tfs](https://github.com/redox-os/tfs)),
    at SHA `3e7dcdb0c586d0d8bb3f25bfd948d2f418a4ab10`. Incidentally, if you're unfamiliar
    with this, Redox is a Rust microkernel-based operating system. The allocator,
    coreutils, and netutils are all encouraged reading.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中提到了危险指针作为安全内存回收的方法。现在，我们将深入探讨这个概念，并通过对 Redox 项目（[https://crates.io/crates/conc](https://crates.io/crates/conc)）的更多或更少的可用实现进行考察。我们将检查
    `conc` 作为其父项目 tfs（[https://github.com/redox-os/tfs](https://github.com/redox-os/tfs)）的一部分，在
    SHA `3e7dcdb0c586d0d8bb3f25bfd948d2f418a4ab10`。顺便说一句，如果你不熟悉这个，Redox 是一个基于 Rust
    微内核的操作系统。分配器、coreutils 和 netutils 都是推荐阅读的内容。
- en: The conc crate is not listed in its entirety. You can find the full listing
    in this book's source repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Conc crate 并没有列出全部内容。你可以在本书的源代码仓库中找到完整的列表。
- en: 'Hazard pointers were introduced by Maged Michael—of Michael and Scott Queue
    fame—in his 2004 book, *Hazard Pointers: Safe Memory Reclamation for Lock-Free
    Objects*. A *hazard*, in this context, is any pointer that is subject to races
    or ABA issues in the rendezvous of multiple treads participating in some shared
    data structure. In the previous section''s Treiber stack, the hazard is the head
    pointer inside of the Stack struct, and in the Michael and Scott queue, it is
    the head and tail pointers. A hazard pointer associates these hazards with *single-writer
    multireader shared pointers*, owned by a single writer thread and read by any
    other threads participating in the data structure.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '危险指针是由 Maged Michael——以 Michael 和 Scott 队列闻名——在他的 2004 年著作《Hazard Pointers:
    Safe Memory Reclamation for Lock-Free Objects》中引入的。在这个上下文中，“危险”是指任何在多个线程参与某些共享数据结构的
    rendezvous 中可能发生竞态或 ABA 问题的指针。在上一节的 Treiber 栈中，危险是指 Stack 结构体内部的头指针，而在 Michael
    和 Scott 队列中，它是头和尾指针。危险指针将这些危险与由单个写入线程拥有并由任何其他参与数据结构的线程读取的 *单写入多读取共享指针* 关联起来。'
- en: Every participating thread maintains a reference to its own hazard pointers
    and all other participating threads in addition to private, thread-local lists
    for the coordination of deallocation. The algorithm description in section 3 of
    Michael's paper is done at a high level and is difficult to follow with an eye
    towards producing a concrete implementation. Rather than repeat that here, we
    will instead examine a specific implementation, `conc`. The reader is encouraged
    to read Michael's paper ahead of the discussion of `conc`, but this is not mandatory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与线程都维护对其自己的危险指针和所有其他参与线程的引用，以及用于协调分配的私有、线程局部列表。Michael 论文第 3 节中的算法描述是在高层次上进行的，并且很难通过具体实现来跟踪。而不是在这里重复，我们将检查一个具体的实现，`conc`。鼓励读者在讨论
    `conc` 之前先阅读 Michael 的论文，但这不是强制性的。
- en: A hazard-pointer Treiber stack
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个危险指针 Treiber 栈
- en: 'The introduction of the Treiber stack in the previous section on reference
    counting was not an idle introduction. We''ll examine hazard pointers and epoch-based
    reclamation here, through the lens of an effectively reclaimed Treiber stack.
    It so happens that `conc` ships with a Treiber stack, in `tfs/conc/src/sync/treiber.rs`.
    The preamble is mostly familiar:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于引用计数的部分中引入 Treiber 栈并非无的放矢。我们将通过一个有效回收的 Treiber 栈的视角来检查危险指针和基于纪元的回收。碰巧的是，`conc`
    包含了一个 Treiber 栈，位于 `tfs/conc/src/sync/treiber.rs`。前言部分大部分是熟悉的：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both `Guard` and `add_garbage_box` are new, but we''ll get to them directly.
    The `Treiber` struct is as you might have imaged it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guard` 和 `add_garbage_box` 都是新的，但我们将直接进入正题。`Treiber` 结构体正如你所想象的那样：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As is the node:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也是一样：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is where we need to understand `conc::Guard`. Much like `MutexGuard` in
    the standard library, `Guard` exists here to protect the contained data from being
    multiply mutated. `Guard` is the hazard pointer interface for `conc`. Let''s examine
    `Guard` in detail and get to the hazard pointer algorithm. `Guard` is defined
    in `tfs/conc/src/guard.rs`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要理解 `conc::Guard` 的地方。与标准库中的 `MutexGuard` 类似，`Guard` 在这里存在是为了保护包含的数据不被多次修改。`Guard`
    是 `conc` 的危险指针接口。让我们详细检查 `Guard` 并了解危险指针算法。`Guard` 定义在 `tfs/conc/src/guard.rs`：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As of writing this book, all `T` protected by `Guard` have to be static, but
    we''ll ignore that as the codebase has references to a desire to relax that restriction.
    Just be aware of it should you wish to make immediate use of `conc` in your project.
    Like `MutexGuard`, `Guard` does not own the underlying data but merely protects
    a reference to it, and we can see that our `Guard` is the writer-end of the hazard.
    What is `hazard::Writer`? It''s defined in `tfs/conc/src/hazard.rs`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，所有由 `Guard` 保护的 `T` 都必须是静态的，但我们将忽略这一点，因为代码库中引用了放宽该限制的愿望。如果你想在项目中立即使用
    `conc`，请注意这一点。就像 `MutexGuard` 一样，`Guard` 并不拥有底层数据，而只是保护对它的引用，我们可以看到我们的 `Guard`
    是危险指针的写入端。那么什么是 `hazard::Writer`？它在 `tfs/conc/src/hazard.rs` 中定义：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pointer to the heap-allocated hazard? Okay, let''s back out a bit. We know
    from the algorithm description that there has to be thread-local storage happening
    in coordination with, apparently, heap storage. We also know that `Guard` is our
    primary interface to the hazard pointers. There are three functions to create
    new instances of `Guard`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 指向堆分配的危险指针？好吧，让我们退一步。我们知道从算法描述中，必须有与堆存储协调的线程局部存储。我们还知道 `Guard` 是我们访问危险指针的主要接口。有三个函数用于创建
    `Guard` 的新实例：
- en: '`Guard<T>::new<F: FnOnce() -> &''static T>(ptr: F) -> Guard<T>`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Guard<T>::new<F: FnOnce() -> &''static T>(ptr: F) -> Guard<T>`'
- en: '`Guard<T>::maybe_new<F: FnOnce() -> Option<&''static T>>(ptr: F) -> Option<Guard<T>>`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Guard<T>::maybe_new<F: FnOnce() -> Option<&''static T>>(ptr: F) -> Option<Guard<T>>`'
- en: '`Guard<T>::try_new<F: FnOnce() -> Result<&''static T, E>>(ptr: F) -> Result<Guard<T>,
    E>`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Guard<T>::try_new<F: FnOnce() -> Result<&''static T, E>>(ptr: F) -> Result<Guard<T>,
    E>`'
- en: 'The first two are defined in terms of `try_new`. Let''s dissect `try_new`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是通过`try_new`定义的。让我们剖析一下`try_new`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The function takes `FnOnce` whose responsibility is to kick out a reference
    to `T` or fail. The first call in `try_new` is an increment of `CURRENT_CREATING`,
    which is `thread-local Cell<usize>`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受`FnOnce`，其责任是提供一个`T`的引用或失败。`try_new`中的第一个调用是`CURRENT_CREATING`的增加，它是一个`thread-local
    Cell<usize>`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve seen `Cell` in [Chapter 3](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml), 
    *The Rust Memory Model – Ownership, References and Manipulation*, but `thread_local!`
    is new. This macro wraps one or more static values into `std::thread::LocalKey`,
    Rust''s take on thread-local stores. The exact implementation varies from platform
    to platform but the basic idea holds: the value will act as a static global but
    will be confined to a single thread. In this way, we can program as if the value
    were global but without having to manage coordination between threads. Once `CURRENT_CREATING`
    is incremented:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](605ce307-29ed-4b5a-961e-8d327467b84f.xhtml)中看到了`Cell`，*《Rust内存模型——所有权、引用和操作*，但`thread_local!`是新的。这个宏将一个或多个静态值包装到`std::thread::LocalKey`中，这是Rust对线程局部存储的实现。具体的实现因平台而异，但基本思想是一致的：值将作为静态全局变量，但将限制在单个线程中。这样，我们可以像使用全局变量一样编程，而无需管理线程之间的协调。一旦`CURRENT_CREATING`增加：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `local::get_hazard` function is defined in `tfs/conc/src/local.rs`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`local::get_hazard`函数定义在`tfs/conc/src/local.rs`中：'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `STATE` referenced in this function is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中引用的`STATE`是：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `State` is type defined like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`的定义如下：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The field garbage maintains a list of `Garbage` that has yet to be moved to
    the global state—more on that in a minute—for reclamation. `Garbage` is a pointer
    to bytes and a function pointer to bytes called `dtor`, for destructor. Memory
    reclamation schemes must be able to deallocate, regardless of the underlying type.
    The common approach, and the approach taken by `Garbage`, is to build a monomorphized
    destructor function when the type information is available, but otherwise work
    on byte buffers. You are encouraged to thumb through the implementation of `Garbage`
    yourself, but the primary trick is `Box::from_raw(ptr as *mut u8 as *mut T)`,
    which we've seen repeatedly throughout this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字段垃圾维护了一个尚未移动到全局状态的`Garbage`列表——关于这一点，我们稍后再谈——用于回收。`Garbage`是一个指向字节的指针，以及一个指向字节的函数指针，称为`dtor`，用于析构函数。内存回收方案必须能够释放，无论底层类型如何。常见的做法，也是`Garbage`采取的做法，是在类型信息可用时构建一个单态化析构函数，否则在字节缓冲区上工作。我们鼓励你自己浏览`Garbage`的实现，但主要的技巧是`Box::from_raw(ptr
    as *mut u8 as *mut T)`，这是我们在这本书中反复看到的。
- en: 'The `available_hazards` field stores the previously allocated hazard writers
    that aren''t currently being used. The implementation keeps this as a cache to
    avoid allocator thrash. We can see this in action in `local::State::get_hazard`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`available_hazards`字段存储了之前分配但尚未使用的分配器危害写入器。实现将其作为缓存以避免分配器抖动。我们可以在`local::State::get_hazard`中看到这一点：'
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final field, `available_hazards_free_before`, stores hazards in the freed state,
    prior to the actual deallocation of the underlying type. We''ll discuss this more
    later. Hazards are in one of four states: free, dead, blocked, or protecting.
    A dead hazard can be deallocated safely, along with the protected memory. A dead
    hazard should not be read. A free hazard is protecting nothing and may be reused.
    A blocked hazard is in use by some other thread can and will cause reads of the
    hazard to stall. A protecting hazard is, well, protecting some bit of memory.
    Now, jump back to this branch in `local::get_hazard`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段`available_hazards_free_before`存储了在释放底层类型之前的释放状态中的危害。我们稍后会进一步讨论这个问题。危害处于四种状态之一：空闲、已死亡、阻塞或保护。一个已死亡的危害可以安全地释放，包括受保护的内存。一个已死亡的危害不应该被读取。一个空闲的危害没有保护任何东西，可以重用。一个阻塞的危害正被其他线程使用，并且会导致危害读取停滞。一个保护危害正在保护一些内存。现在，回到`local::get_hazard`的这个分支：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What is `global::create_hazard`? This module is `tfs/conc/src/global.rs` and
    the function is:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`global::create_hazard`是什么？此模块是`tfs/conc/src/global.rs`，函数如下：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The variable names are confusing. This `STATE` is not the thread-local `STATE`
    but a globally scoped `STATE`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名令人困惑。这个 `STATE` 不是线程本地的 `STATE`，而是一个全局作用域的 `STATE`：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s dig in there:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The global `STATE` is a mpsc `Sender` of `Message` and a mutex-guarded `Garbo`. `Message`
    is a simple enumeration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `STATE` 是 `Message` 的 mpsc `Sender` 和一个互斥锁保护的 `Garbo`。`Message` 是一个简单的枚举：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Garbo` is something we''ll get into directly. Suffice it to say for now that
    `Garbo` acts as the global garbage collector for this implementation. The global
    state sets up a channel, maintaining the sender side in the global state and feeding
    the receiver into `Garbo`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Garbo` 是我们将直接探讨的内容。现在只需说，`Garbo` 作为此实现的全球垃圾回收器。全局状态设置了一个通道，维护全局状态中的发送方，并将接收方喂入
    `Garbo`：'
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The creation of a new global hazard doesn''t take much:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的全局风险并不需要太多：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This establishes a new hazard via `hazard::create()` and feeds the reader side
    down through to `Garbo`, returning the writer side back out to `local::get_hazard()`.
    While the names writer and reader suggest that hazard is itself an MPSC, this
    is not true. The hazard module is `tfs/conc/src/hazard.rs` and creation is:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过 `hazard::create()` 建立了一个新的风险，并将读取器侧向下传递到 `Garbo`，将写入器侧返回到 `local::get_hazard()`。虽然
    writer 和 reader 的名字暗示风险本身是一个 MPSC，但这并不正确。风险模块是 `tfs/conc/src/hazard.rs`，创建如下：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, look at that. What we have here are two structs, `Writer` and `Reader`,
    which each store the same raw pointer to a heap-allocated atomic pointer to a
    mutable byte pointer. Phew! We've seen this trick previously but what's special
    here is the leverage of the type system to provide for different reading and writing
    interfaces over the same bit of raw memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看看这个。我们这里有两个结构体，`Writer` 和 `Reader`，它们各自存储指向堆分配的原子指针的可变字节指针的相同原始指针。呼！我们之前已经看到过这个技巧，但这里特殊的是利用类型系统为同一块原始内存提供不同的读写接口。
- en: 'What about `Garbo`? It''s defined in the global module and is defined as:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `Garbo` 呢？它在全局模块中定义，定义为：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Garbo` defines a `gc` function that reads all `Messages` from its channel,
    storing the garbage into the garbage field and free hazards into hazards. Dead
    hazards are destroyed, freeing its storage as the other holder is guaranteed to
    have hung up already. Protected hazards also make their way into hazards, which
    are to be scanned during the next call of gc. Garbage collections are sometimes
    performed when a thread calls `global::tick()` or when `global::try_gc()` is called.
    A tick is performed whenever `local::add_garbage` is called, which is what `whatconc::add_garbage_box` calls.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Garbo` 定义了一个 `gc` 函数，该函数从其通道读取所有 `Messages`，将垃圾存储到垃圾字段，将自由风险存储到风险字段。已死亡的风险被销毁，释放其存储空间，因为其他持有者已经保证已经挂起。受保护的风险也进入风险字段，这些字段将在下一次调用
    gc 时被扫描。当线程调用 `global::tick()` 或调用 `global::try_gc()` 时，有时会执行垃圾回收。每当调用 `local::add_garbage`
    时，就会执行一个 tick，这是 `whatconc::add_garbage_box` 调用的。'
- en: We first encountered `add_barbage_box` at the start of this section. Every time
    a thread signals a node as garbage, it rolls the dice and potentially becomes
    responsible for performing a global garbage collection over all of the threads'
    hazard-pointed memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节的开头首次遇到了 `add_barbage_box`。每当一个线程将一个节点标记为垃圾时，它掷骰子，并可能成为负责在所有线程的风险指针内存上执行全局垃圾回收的责任人。
- en: 'Now that we understand how memory reclamation works, all that remains is to
    understand how hazard pointers protect memory from reads and writes. Let''s finish
    `guard::try_new` in one large jump:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了内存回收的工作原理，剩下要理解的是风险指针如何保护内存免受读写。让我们一次性完成 `guard::try_new`：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that the conc authors have inserted a sequentially consistent fence
    that they question. The model laid out by Michael does not require sequential
    consistency and I believe that this fence is not needed, being a significant drag
    on performance. The key things here to note are the call to `hazard::protect`
    and `''hazard::free`. Both calls are part of `hazard::Writer`, the former setting
    the internal pointer to the byte pointer fed to it, the latter marking the hazard
    as free. Both states interact with the garbage collector, as we''ve seen. The
    remaining bit has to do with `hardard::Reader::get`, the function used to retrieve
    the state of the hazard. Here it is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，conc 的作者插入了一个他们质疑的顺序一致性栅栏。Michael 提出的模型不需要顺序一致性，我相信这个栅栏是不必要的，因为它会显著降低性能。这里要注意的关键点是
    `hazard::protect` 调用和 `'hazard::free'`。这两个调用都是 `hazard::Writer` 的部分，前者将内部指针设置为提供给它的字节指针，后者将危害标记为自由。这两种状态都与垃圾回收器交互，正如我们所见。剩下的部分与
    `hardard::Reader::get` 有关，这是用来检索危害状态的函数。这里就是它：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Only if the hazard is blocked does the get of the state spin until it's dead,
    free, or merely protected. What blocks the hazard? Recall that they're created
    blocked. By creating the hazards in a blocked state, it is not possible to perform
    garbage collection over a pointer that has not been fully initialized—a problem
    we saw with the reference-counting implementation—nor is it possible to read from
    a partially-initialized hazarded pointer. Only once the pointer is moved into
    the protected state can reads move forward.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当危害被阻塞时，状态的获取才会旋转，直到它死亡、自由或仅仅被保护。什么阻塞了危害？回想一下，它们是在阻塞状态下创建的。通过在阻塞状态下创建危害，我们无法在未完全初始化的指针上执行垃圾回收——这是我们参考计数实现中遇到的问题——也无法从部分初始化的危害指针中读取。只有当指针移动到保护状态后，读取才能继续。
- en: And there you go—garbage collection and atomic isolation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——垃圾回收和原子隔离。
- en: 'Let''s go all the way back up to the stack and look at its push implementation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一路追溯到栈，看看其推送实现：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the top of the function, the implementation loads the hazard pointer for
    the head node into the snapshot. `Guard::as_ptr(&self) -> *const T` retrieves
    the current pointer for the hazard on each invocation, adapting as the underlying
    data shifts forward. The node is the allocated and raw-pointered `Node` containing
    `item: T`. The remainder of the loop is the same compare-and-swap we''ve seen
    for other data structures of this kind, merely in terms of a hazard `Guard` instead
    of raw `AtomicPtrs` or the like. The programming model is very direct, as it is
    for `pop` as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数顶部，实现将头节点的危害指针加载到快照中。`Guard::as_ptr(&self) -> *const T` 在每次调用时检索危害的当前指针，随着底层数据的向前移动而适应。节点是包含
    `item: T` 的已分配和原始指针 `Node`。循环的其余部分与我们所见到的其他此类数据结构的比较和交换相同，只是用危害 `Guard` 而不是原始
    `AtomicPtrs` 或类似的东西。编程模型非常直接，就像 `pop` 一样：'
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that when the old node is removed from the stack, `add_garbage_box` is
    called on it, adding the node to be garbage-collected at a later date. We know,
    further, from inspection, that this later date might well be exactly the moment
    of invocation, depending on luck.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当旧节点从栈中移除时，会对其调用 `add_garbage_box`，将节点添加到稍后进行垃圾回收。此外，通过检查我们知道，这个“稍后”可能正好是调用的那一刻，这取决于运气。
- en: The hazard of Nightly
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 夜间危害
- en: Unfortunately, conc relies on an unstable feature of the Rust compiler and will
    not compile with a recent `rustc`. The last update to `conc`, and to TFS, its
    parent project, was in August of 2017\. We'll have to travel back in time for
    a nightly `rustc` from that period. If you followed the instructions laid out
    in [Chapter 1](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml), *Preliminaries – Machine
    Architecture and Getting Started with Rust*, and are using `rustup`, that's a
    simple `rustup` default nightly-2017-08-17 away. Don't forget to switch back to
    a more modern Rust when you're done playing with conc.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，conc 依赖于 Rust 编译器的一个不稳定特性，并且无法与最近的 `rustc` 编译。`conc` 以及其父项目 TFS 的最后一次更新是在
    2017 年 8 月。我们将不得不回到那个时期的夜间 `rustc`。如果你遵循了 [第 1 章](5f3aec9d-fd53-48ff-9ba8-43ce13e91cff.xhtml)
    中概述的说明，*预备知识 – 计算机架构和 Rust 入门*，并且使用 `rustup`，那么只需简单地使用 `rustup` 默认的 nightly-2017-08-17。当你玩完
    conc 后，别忘了切换回更现代的 Rust。
- en: Exercizing the hazard-pointer Treiber stack
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习危害指针 Treiber 栈
- en: 'Let''s put the conc, Treiber stack through the wringer to get an idea of the
    performance of this approach. Key areas of interest for us will be:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 conc、Treiber 栈来测试这个方法，以了解其性能。对我们来说，关键的兴趣领域包括：
- en: Push/pop cycles per second
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒的推入/弹出周期
- en: Memory behavior, high-water mark, and what not
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存行为，最高水位线，等等
- en: Cache behavior
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存行为
- en: We'll run our programs on x86 and ARM, as in previous chapters. One thing to
    note here, before we proceed, is that conc—at least as of version 0.5—requires
    the nightly channel to be compiled. Please read the section just before this one
    if you're jumping around in the book for full details.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 x86 和 ARM 上运行我们的程序，就像前几章所做的那样。在此进行之前需要注意的一点是，至少在版本 0.5 中，conc 需要使用夜间频道进行编译。如果您在书中跳来跳去，请阅读本节之前的部分以获取完整详情。
- en: 'Because we have to run on an old version of nightly, we have to stick static
    `AtomicUsize` into `lazy_static!`, a technique you''ll see in older Rust code
    but not in this book, usually. With that in mind, here is our exercise program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们必须运行在旧版本的夜间版本上，所以我们不得不将静态 `AtomicUsize` 放入 `lazy_static!` 中，这是一种你会在旧 Rust
    代码中看到但通常不会在这本书中看到的技巧。考虑到这一点，以下是我们练习程序：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have a number of worker threads equal to the total number of CPUs in the
    target machine, each doing one push and then an immediate pop on the stack. A
    `COUNT` is kept and the main thread swaps that value for `0` every second or so,
    tossing the value into a quantile estimate structure—discussed in more detail
    in [Chapter 4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml), *Sync and Send – the
    Foundation of Rust Concurrency*—and printing out a summary of the recorded cycles
    per second, scaled to the number of CPUs. The worker threads the cycle up through
    to `MAX_I`, which is arbitrarily set to the smallish value of `2**26`. When the
    worker is finished cycling, it decreases `WORKERS` and exits. Once `WORKERS` hits
    zero, the main loop also exits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与目标机器中 CPU 总数相等的多个工作线程，每个线程执行一次推入然后立即弹出栈的操作。一个 `COUNT` 被保持，主线程大约每秒交换那个值到
    `0`，并将该值投入到一个分位数估计结构中——在 [第 4 章](5a332d94-37e4-4748-8920-1679b07e2880.xhtml) 中更详细地讨论了这一点，*同步和发送——Rust
    并发的基础*——并打印出每秒记录的周期摘要，按 CPU 数量进行缩放。工作线程将周期推进到 `MAX_I`，这个值任意设置为 `2**26` 的小值。当工作线程完成周期后，它减少
    `WORKERS` 并退出。一旦 `WORKERS` 达到零，主循环也退出。
- en: 'On my x86 machine, it takes approximately 58 seconds for this program to exit,
    with this output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 x86 机器上，这个程序退出大约需要 58 秒，输出如下：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The x86 perf run is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: x86 的性能运行如下：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The memory-allocation behavior of this program is very favorable as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的内存分配行为也非常有利。
- en: 'On my ARM machine, it takes approximately 460 seconds for the program to run
    to completion, with this output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 ARM 机器上，程序运行到完成大约需要 460 秒，输出如下：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is about 7.5 times slower than the x86 machine, even though both machines
    have the same number of cores. The x86 machine has a faster clock and a faster
    memory bus than my ARM:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这比 x86 机器慢大约 7.5 倍，尽管两台机器的核心数量相同。x86 机器的时钟和内存总线比我的 ARM 快：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The fact that the branch misses on ARM are 12% higher than on x86 is an interesting
    result.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 上的分支缺失率比 x86 高 12%，这是一个有趣的结果。
- en: Before moving on, do remember to execute the rustup default stable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记住执行 rustup default stable。
- en: Tradeoffs
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折衷
- en: 'Assuming that conc was brought up to speed with modern Rust, where would you
    want to apply it? Well, let''s compare it to reference counting. In a reference-counting
    data structure, every read and modification requires manipulating atomic values,
    implying some level of synchronization between threads with an impact on performance.
    A similar situation exists with hazard pointers, though to a lesser degree. As
    we''ve seen, the hazard requires synchronization, but reading anything apart from
    the hazard, through it, is going to be at machine speed. That''s a significant
    improvement over reference counting. Furthermore, we know that the hazard pointer
    approach does accumulate garbage—and the implementation of conc is done via an
    especially neat trick—but this garbage is bounded in size, no matter the frequency
    of updates to the hazardous structure. The cost of garbage collection is placed
    on one thread, incurring potentially high latency spikes for some operations while
    benefiting from bulk-operation calls to the deallocator. This is distinct from
    reference counting approaches where every thread is responsible for deallocating
    dead memory as soon as it is dead, keeping operation cost overheads similar but
    higher than baseline, and incurred on each operation without the benefit of bulk
    accumulation of deallocations. The hazard pointer approach struggles as the number
    of threads increase: recall that the number of hazards needed grows linearly with
    the number of threads, but also consider that an increase in thread count increases
    the traversal cost of any structure. Furthermore, while many structures have easily
    identifiable hazards, this is not universally true. Where do you put the hazard
    pointers for a b-tree?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设conc已经与现代化的Rust同步，您希望在哪里应用它？好吧，让我们将其与引用计数进行比较。在引用计数的数据结构中，每次读取和修改都需要操作原子值，这意味着线程之间需要一定程度的同步，这会影响性能。在危险指针的情况下也存在类似的情况，尽管程度较小。正如我们所见，危险指针需要同步，但通过它读取除危险指针之外的内容，将会以机器速度进行。这比引用计数有显著的改进。此外，我们知道危险指针方法确实会积累垃圾——而conc的实现是通过一个特别巧妙的方法完成的——但无论更新危险结构的频率如何，这种垃圾的大小都是有限的。垃圾回收的成本被放在一个线程上，这可能导致某些操作的高延迟峰值，但同时也从批量操作调用分配器中受益。这与引用计数方法不同，在引用计数方法中，每个线程都负责在内存死亡时立即释放死亡内存，保持操作成本开销相似但高于基线，并且在每个操作上产生，而没有批量积累释放操作的好处。随着线程数量的增加，危险指针方法会面临挑战：回想一下，所需的危险数量会随着线程数量的线性增长而增长，但也要考虑到线程数量的增加会增加任何结构的遍历成本。此外，虽然许多结构都有容易识别的危险点，但这并不普遍适用。对于b树，您将把危险指针放在哪里？
- en: In summary—hazard pointers are an excellent choice when you have relatively
    few hazardous memory references to make and need bounded garbage, no matter the
    load on your structure. Hazard-based memory reclamation does not have the raw
    speed of epoch-based reclamation, but bounded memory use in all cases is hard
    to pass up.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说——当您需要处理的危险内存引用相对较少，并且需要有限制的垃圾回收，无论结构上的负载如何时，危险指针是一个非常好的选择。基于危险的内存回收并不具备基于时代的回收的原始速度，但在所有情况下有限的内存使用都是难以放弃的。
- en: Epoch-based reclamation
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时代的回收
- en: We touched on epoch-based memory reclamation in the last chapter. We'll now
    examine the concept in depth and in the context of a ready-to-use implementation
    via the crossbeam project ([https://github.com/crossbeam-rs](https://github.com/crossbeam-rs)).
    Some of the developers of conc overlap with crossbeam, but there's been more work
    done to crossbeam in the pursuit of a general-purpose framework for low-level
    atomic programming in Rust. The developers note that they plan to support other
    memory management schemes, for example hazard pointers (HP) and quiescent state-based
    reclamation (QSBR). The crate is re-exported as the epoch module. Future editions
    of this book may well only cover crossbeam and simply discuss the various memory
    reclamation techniques embedded in it. The particular crate we'll be discussing
    in this section is crossbeam-epoch, at SHA `3179e799f384816a0a9f2a3da82a147850e14d38`.
    This coincides with the 0.4.1 release of the project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了基于纪元的内存回收。现在，我们将深入探讨这一概念，并通过对 crossbeam 项目（[https://github.com/crossbeam-rs](https://github.com/crossbeam-rs)）的现成实现进行考察。一些
    conc 的开发者与 crossbeam 有交集，但为了追求 Rust 中的低级原子编程的通用框架，crossbeam 上做了更多的工作。开发者们指出，他们计划支持其他内存管理方案，例如危害指针（HP）和静默状态基于回收（QSBR）。该包被重新导出为纪元模块。本书的未来版本可能只会涵盖
    crossbeam，并简单地讨论其中嵌入的各种内存回收技术。本节我们将讨论的特定包是 crossbeam-epoch，其 SHA 值为 `3179e799f384816a0a9f2a3da82a147850e14d38`。这与项目的
    0.4.1 版本相一致。
- en: The crossbeam crates under discussion here are not listed in their entirety.
    You can find the full listings in this book's source repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的 crossbeam 包并不完整。您可以在本书的源代码库中找到完整的列表。
- en: 'Epoch-based memory reclamation was introduced by Keir Fraser in his 2004 PhD
    thesis, *Practical lock-freedom*. Fraser''s work builds on previous limbo list approaches,
    whereby garbage is placed in a global list and reclaimed through periodic scanning
    when it can be demonstrated that the garbage is no longer referenced. The exact
    mechanism varies somewhat by author, but limbo lists have some serious correctness
    and performance downsides. Fraser''s improvement is to separate limbo lists into
    three epochs, a current epoch, a middle, and an epoch from which garbage may be
    collected. Every participating thread is responsible for observing the current epoch
    on start, adds its garbage to the current epoch, and attempts to increase the
    epoch count when its operations complete. The last thread to complete is the one
    that succeeds in increasing the epoch and is responsible for performing garbage
    collection on the final epoch. Three total epochs are needed as threads move from
    epochs independently from one another: a thread at epoch n may still hold a reference
    from n-1, but not n-2, and so only n-2 is safe to reclaim. Fraser''s thesis is
    quite long—being, well, being that it is sufficient work to acquire a PhD—but
    Hart et al''s 2007 paper, *Performance of Memory Reclamation for Lockless Synchronization*, is
    warmly recommended to the reader pressed for time.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基于纪元的内存回收是由 Keir Fraser 在他的 2004 年博士论文《实用锁自由》中引入的。Fraser 的工作建立在之前的 limbo 列表方法之上，其中垃圾被放置在全局列表中，并通过周期性扫描回收，当可以证明垃圾不再被引用时。确切的机制因作者而异，但
    limbo 列表有一些严重的正确性和性能缺点。Fraser 的改进是将 limbo 列表分为三个纪元：当前纪元、中间纪元和可以回收垃圾的纪元。每个参与线程在启动时负责观察当前纪元，将其垃圾添加到当前纪元，并在其操作完成后尝试增加纪元计数。最后一个完成操作的线程将成功增加纪元，并负责在最终纪元上执行垃圾回收。当线程独立移动到纪元时，需要三个总纪元：一个位于纪元
    n 的线程可能仍然持有来自 n-1 的引用，但不能持有来自 n-2 的引用，因此只有 n-2 是安全的可以回收。Fraser 的论文相当长——毕竟，这是获得博士学位的足够工作量——但
    Hart 等人 2007 年的论文《无锁同步的内存回收性能》强烈推荐给时间紧迫的读者。
- en: An epoch-based Treiber stack
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于纪元的 Treiber 栈
- en: 'We inspected reference counting and hazard-pointer-based Treiber stacks earlier
    in this chapter and will follow this approach in this section as well. Fortunately,
    crossbeam also ships with a Treiber stack implementation, in the crossbeam-rs/crossbeam
    project, which we''ll examine at SHA `89bd6857cd701bff54f7a8bf47ccaa38d5022bfb`,
    which is the source for `crossbeam::sync::TreiberStack` is in `src/sync/treiber_stack.rs`.
    The preamble is almost immediately interesting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早期检查了基于引用计数和危害指针的 Treiber 栈，本节也将采用这种方法。幸运的是，crossbeam 还提供了一个 Treiber 栈实现，位于
    crossbeam-rs/crossbeam 项目中，我们将在 SHA 值为 `89bd6857cd701bff54f7a8bf47ccaa38d5022bfb`
    的位置进行考察，这是 `crossbeam::sync::TreiberStack` 的来源，位于 `src/sync/treiber_stack.rs`。前言部分几乎立即就很有趣：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What, for instance, are `epoch::Atomic` and `epoch::Owned`? Well, we''ll explore
    these here. Unlike the section on hazard pointers, which explored the implementation
    of conc in a depth-first fashion, we''ll take a breadth-first approach here, more
    or less. The reason being, crossbeam-epoch is intricate—it''s easy to get lost.
    Setting aside the somewhat unknown nature of `epoch::Atomic`, the `TreiberStack`
    and `Node` structs are similar to what we''ve seen in other implementations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，`epoch::Atomic`和`epoch::Owned`是什么意思？嗯，我们在这里会探讨这些。与探索conc实现的深度优先方法不同，我们将采取广度优先的方法，或多或少。原因在于crossbeam-epoch很复杂——很容易迷路。抛开对`epoch::Atomic`的某种未知性质，`TreiberStack`和`Node`结构体与我们看到的其他实现类似：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As is the creation of a new stack:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以及创建一个新的栈：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Pushing a new element also looks familiar:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 推入一个新元素看起来也很熟悉：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Except, what is `epoch::pin()`? This function `pins` the current thread, returning
    a `crossbeam_epoch::Guard`. Much like previous guards we've seen throughout the
    book, crossbeam_epoch's `Guard` protects a resource. In this case, the guard protects
    the pinned nature of the thread. Once the guard drops, the thread is no longer
    pinned. Okay, great, so what does it mean for a thread to be pinned? Recall that
    epoch-based reclamation works by a thread entering an epoch, doing some stuff
    with memory, and then potentially increasing the epoch after finishing up fiddling
    with memory. This process is observed in crossbeam by pinning. `Guard` in hand—implying
    a safe epoch has been entered—the thread is able to take a heap allocation and
    get a stack reference to it. Just any old heap allocation and stack reference
    would be unsafe, however. There's no magic here. That's where `Atomic` and `Owned`
    come in. They're analogs to `AtomicPtr` and `Box` from the standard library, except
    that the operations done on them require a reference to `crossbeam_epoch::Guard`.
    We saw this technique in [Chapter 4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml), *Sync
    and Send – the Foundation of Rust Concurrency*, when discussing hopper, using
    the type-system to ensure that potentially thread-unsafe operations are done safely
    by requiring the caller to pass in a guard of some sort. Programmer error can
    creep in by using `AtomicPtr`, `Box`, or any non-epoch unprotected memory accesses,
    but these will tend to stand out.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了，`epoch::pin()`是什么意思？这个函数`pins`当前线程，返回一个`crossbeam_epoch::Guard`。就像我们在书中看到的之前的守卫一样，crossbeam_epoch的`Guard`保护一个资源。在这种情况下，守卫保护线程的固定性质。一旦守卫释放，线程就不再固定。好吧，太好了，那么线程固定意味着什么呢？回想一下，基于epoch的回收是通过线程进入一个epoch，对内存进行一些操作，然后在完成与内存的交互后可能增加epoch来工作的。这个过程在crossbeam中通过固定来实现。持有`Guard`意味着已经进入了一个安全的epoch——线程能够进行堆分配并获取其栈引用。然而，任何旧的堆分配和栈引用都是不安全的。这里没有魔法。这就是`Atomic`和`Owned`出现的地方。它们是标准库中的`AtomicPtr`和`Box`的类似物，只不过对它们的操作需要`crossbeam_epoch::Guard`的引用。我们在[第4章](5a332d94-37e4-4748-8920-1679b07e2880.xhtml)中看到了这种技术，当时在讨论hopper时，使用类型系统确保通过要求调用者传递某种类型的守卫来安全地执行可能不安全的线程操作。程序员错误可能会通过使用`AtomicPtr`、`Box`或任何非epoch未受保护的内存访问而悄悄出现，但这些通常会突出显示。
- en: 'Let''s look at popping an element off the stack, where we know marking memory
    as safe to delete will have to happen:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从栈中弹出元素的情况，我们知道标记内存为可删除的安全操作将必须发生：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The key things to note are the creation of `head_shared` by performing a load
    on an Atomic, the usual compare and set operation, and then this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是通过对Atomic进行加载创建`head_shared`，然后是常规的比较和设置操作，以及以下内容：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`head_shared` is moved into a closure, converted, and that closure is then
    passed into the as-yet unexamined defer function of `Guard`. But, head is dereferenced
    and the data from it is read out and returned. Absent some special trick, that''s
    dangerous. We need to know more.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`head_shared`被移动到一个闭包中，转换，然后这个闭包被传递到`Guard`尚未检查的defer函数中。但是，头被解引用，并从中读取数据并返回。如果没有一些特殊的技巧，这是危险的。我们需要了解更多信息。'
- en: crossbeam_epoch::Atomic
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: crossbeam_epoch::Atomic
- en: 'Let''s dig in with the holder of our data, `Atomic`. This structure is from
    the crossbeam_epoch library and its implementation is in `src/atomic.rs`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨我们的数据持有者`Atomic`。这个结构来自crossbeam_epoch库，其实现位于`src/atomic.rs`：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The representation is a little odd: why not `data: *mut T`? Crossbeam''s developers
    have done something neat here. On modern machines, there''s a fair bit of space
    inside of pointer to store information, in the least significant bits. Consider
    that if we point only to aligned data, the address of a bit of memory will be
    multiples of 4 on a 32-bit system, or multiples of 8 on a 64-bit system. This
    leaves either two zero bits at the end of a pointer on 32-bit systems or three
    zero bits on a 64-bit system. Those bits can store information, called a tag.
    The fact that `Atomic` can be tagged will come into play. But, Rust doesn''t allow
    us to manipulate pointers in the fashion of other systems programming languages.
    To that end, and because `usize` is the size of the machine word, crossbeam stores
    its `*mut T` as a `usize`, allowing for tagging of the pointer. Null `Atomics`
    are equivalent to tagged pointers to zero:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '表示有点奇怪：为什么不直接是 `data: *mut T`？Crossbeam 的开发者在这里做了一些巧妙的事情。在现代机器上，指针内部有相当多的空间来存储信息，在最低有效位。考虑一下，如果我们只指向对齐的数据，内存地址在
    32 位系统上将是 4 的倍数，在 64 位系统上是 8 的倍数。这会在 32 位系统上留下指针末尾的两个零位，在 64 位系统上留下三个零位。这些位可以存储信息，称为标记。`Atomic`
    可以被标记的事实将发挥作用。但是，Rust 不允许我们像其他系统编程语言那样操作指针。为此，并且因为 `usize` 是机器字的大小，crossbeam 将其
    `*mut T` 存储为 `usize`，允许对指针进行标记。空 `Atomics` 等价于指向零的标记指针：'
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'New `Atomic`s are created by passing `T` down through `Owned`—which we saw
    previously—and then converting from that `Owned`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Atomic` 通过将 `T` 传递给 `Owned`—这是我们之前看到的，然后从那个 `Owned` 转换而来来创建：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`Owned` boxes `T`, performing a heap allocation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Owned` 盒子 `T`，执行堆分配：'
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And subsequently converts that box into `*mut T`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将那个盒转换为 `*mut T`：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And converts that into a tagged pointer:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它转换为一个标记指针：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's a bit of a trek, but what that tells us is that `Atomic` is no different
    in terms of data representation compared to `AtomicPtr`, except that the pointer
    itself is tagged.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点远，但那告诉我们 `Atomic` 在数据表示方面与 `AtomicPtr` 没有区别，只是指针本身被标记了。
- en: 'Now, what about the usual operations on an atomic pointer, loading and the
    like? How do those differ in `Atomic`? Well, for one, we know that an epoch `Guard`
    has to be passed in to each call, but there are other important differences. Here''s
    `Atomic::load`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于原子指针的常规操作，如加载等，又是如何不同的？在 `Atomic` 中，这些有什么区别？好吧，首先，我们知道每个调用都必须传递一个 epoch
    `Guard`，但还有其他重要的区别。这是 `Atomic::load`：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see `self.data.load(ord)`, so the underlying atomic load is performed
    as expected. But, what is `Shared`?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `self.data.load(ord)`，所以底层原子加载是按预期进行的。但是，什么是 `Shared`？
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It''s a reference to `Atomic` with an embedded reference to `Guard`. So long
    as `Shared` exists, the `Guard` that makes memory operations on it safe will also
    exist and cannot, importantly, cease to exist until `Shared` has been dropped.
    `Atomic::compare_and_set` introduces a few more traits:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它是对 `Atomic` 的引用，其中嵌入了 `Guard` 的引用。只要 `Shared` 存在，对它进行内存操作的安全 `Guard` 也会存在，并且，重要的是，不能在
    `Shared` 被丢弃之前停止存在。`Atomic::compare_and_set` 引入了一些额外的特质：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice that `compare_and_set` is defined in terms of `compare_exchange`. This
    CAS primitive is equivalent to a comparative exchange, but that exchange allows
    failure to be given more relaxed semantics, offering a performance boost on some
    platforms. Implementation of compare-and-set, then, requires understanding of
    which success `Ordering` matches with which failure `Ordering`, from which need
    comes `CompareAndSetOrdering`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `compare_and_set` 是基于 `compare_exchange` 定义的。这个 CAS 原语相当于比较交换，但那个交换允许失败具有更宽松的语义，在某些平台上提供性能提升。比较和设置的实现需要理解哪种成功
    `Ordering` 与哪种失败 `Ordering` 匹配，从而产生 `CompareAndSetOrdering`：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Where `strongest_failure_ordering` is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `strongest_failure_ordering` 是：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The final new trait is `Pointer`, a little utility trait to provide functions
    over both `Owned` and `Shared`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个新特质是 `Pointer`，这是一个提供对 `Owned` 和 `Shared` 上的函数的小工具特质：
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: crossbeam_epoch::Guard::defer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: crossbeam_epoch::Guard::defer
- en: Now, again, how is the following in `TreiberStack::try_pop` a safe operation?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次，以下在 `TreiberStack::try_pop` 中的操作是如何安全进行的？
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'What we need to explore now is `defer`, which lives in crossbeam-epoch at `src/guard.rs`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要探索的是 `defer`，它在 `crossbeam-epoch` 的 `src/guard.rs` 中：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to understand `Garbage`. It''s defined in `src/garbage.rs` as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解 `Garbage`。它在 `src/garbage.rs` 中定义为：
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The implementation of `Garbage` is very brief:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Garbage` 的实现非常简短：'
- en: '[PRE61]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`Deferred` is a small structure that wraps `FnOnce()`, storing it inline or
    on the heap as size allows. You are encouraged to examine the implementation yourself,
    but the basic idea is to maintain the same properties of `FnOnce` in a heap-allocated
    structure that finds use in the `Garbage` drop implementation. What drops `Garbage`?
    This is where the following comes into play:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deferred` 是一个小的结构，它包装了 `FnOnce()`，根据大小允许将其存储在行内或堆上。鼓励你自己检查实现，但基本思想是在堆分配的结构中保持
    `FnOnce` 的相同属性，该结构在 `Garbage` 丢弃实现中找到用途。什么丢弃 `Garbage`？这正是以下内容发挥作用的地方：'
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `self.local` of `Guard` is `*const Local`, a struct called a participant
    for garbage collection in crossbeam''s documentation. We need to understand where
    and how this `Local` is created. Let''s understand the `Guard` internals, first:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guard` 的 `self.local` 是 `*const Local`，这是一个在 crossbeam 文档中被称为垃圾回收参与者的结构。我们需要了解这个
    `Local` 是在哪里以及如何被创建的。首先让我们来理解一下 `Guard` 的内部结构：'
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`Guard` is a wrapper around a const pointer to `Local`. We know that instances
    of `Guard` are created by `crossbeam_epoch::pin`, defined in `src/default.rs`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guard` 是一个指向 `Local` 的常量指针的包装器。我们知道 `Guard` 的实例是由 `crossbeam_epoch::pin` 创建的，该函数定义在
    `src/default.rs` 中：'
- en: '[PRE64]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`HANDLE` is a thread-local static variable:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`HANDLE` 是一个线程局部静态变量：'
- en: '[PRE65]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`COLLECTOR` is a static, global variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`COLLECTOR` 是一个静态的全局变量：'
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is a lot of new things all at once. Pinning is a non-trivial activity!
    As its name implies and its documentation states, `COLLECTOR` is the entry point
    for crossbeam-epoch''s global garbage collector, called `Global`. `Collector`
    is defined in `src/collector.rs` and has a very brief implementation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次同时出现了很多新事物。固定是一个非平凡的活动！正如其名称所暗示的以及其文档所述，`COLLECTOR` 是 crossbeam-epoch 的全局垃圾收集器的入口点，称为
    `Global`。`Collector` 定义在 `src/collector.rs` 中，并且有一个非常简短的实现：
- en: '[PRE67]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We know that `Collector` is a global static, implying that `Global::new()`
    will be called only once. `Global`, defined in `src/internal.rs`, is the data
    repository for the global garbage collector:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `Collector` 是一个全局静态变量，这意味着 `Global::new()` 只会调用一次。`Global` 定义在 `src/internal.rs`
    中，是全局垃圾收集器的数据存储库：
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'List is an intrusive list, which we saw reference to in the definition of `Local`.
    An intrusive list is a linked list in which the pointer to the next node in the
    list is stored in the data itself, the `entry: Entry` field of `Local`. Intrusive
    lists pop up fairly rarely, but they are quite useful when you''re concerned about
    small memory allocations or need to store an element in multiple collections,
    both of which apply to crossbeam. `Queue` is a Michael and Scott queue. The epoch
    is a cache-padded `AtomicEpoch`, cache-padding being a technique to disable write
    contention on cache lines, called false sharing. `AtomicEpoch` is a wrapper around
    `AtomicUsize`. `Global` is, then, a linked-list of instances of `Local` – which,
    themselves, are associated with thread-pinned `Guards`—a queue of `Bag`s, which
    we haven''t investigated yet, associated with some epoch number (a `usize`) and
    an atomic, global `Epoch`. This layout is not unlike what the algorithm description
    suggests. Once the sole `Global` is initialized, every thread-local `Handle` is
    created by calling `Collector::register`, which is `Local::register` internally:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '列表是一个侵入式列表，我们在 `Local` 的定义中看到了对其的引用。侵入式列表是一个链表，其中列表中下一个节点的指针存储在数据本身中，即 `Local`
    的 `entry: Entry` 字段。侵入式列表并不常见，但当你关心小内存分配或需要在多个集合中存储元素时，它们非常有用，这两者都适用于 crossbeam。`Queue`
    是 Michael 和 Scott 队列。时期是一个缓存填充的 `AtomicEpoch`，缓存填充是一种禁用缓存行写冲突的技术，称为伪共享。`AtomicEpoch`
    是 `AtomicUsize` 的包装器。那么，`Global` 是一个 `Local` 实例的链表——这些实例本身与线程固定的 `Guards` 关联——一个
    `Bag` 的队列，我们尚未研究，与某些时期号（`usize`）和一个原子的全局 `Epoch` 关联。这种布局与算法描述所建议的非常相似。一旦唯一的 `Global`
    被初始化，每个线程局部 `Handle` 都是通过调用 `Collector::register` 创建的，该调用在内部是 `Local::register`：'
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note, specifically, that the `collector.global.locals.insert(local, &unprotected())` call
    is inserting the newly created `Local` into the list of `Global` locals. (`unprotected`
    is a `Guard` that points to a null, rather than some valid `Local`). Every pinned
    thread has a `Local` registered with the global garbage collector''s data. In
    fact, let''s look at what happens when `Guard` is dropped, before we finish `defer`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，特别是 `collector.global.locals.insert(local, &unprotected())` 这个调用是将新创建的 `Local`
    插入到 `Global` 局部列表中。（`unprotected` 是一个指向空指针的 `Guard`，而不是指向某个有效 `Local`）。每个固定线程都会在全局垃圾收集器的数据中注册一个
    `Local`。实际上，在我们完成 `defer` 之前，让我们看看当 `Guard` 被丢弃时会发生什么：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `unpin` method of `Local` is called:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Local` 的 `unpin` 方法：
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `guard_count` field, recall, is the total number of participating threads
    or otherwise arranged for guards that keep the thread pinned. The `handle_count` field
    is a similar mechanism, but one used by `Collector` and `Local`. `Local::finalize`
    is where the action is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`guard_count`字段是参与线程的总数或为保持线程锁定而安排的守护者的总数。`handle_count`字段是一个类似的机制，但由`Collector`和`Local`使用。`Local::finalize`是动作发生的地方：
- en: '[PRE72]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`Local` contains a `self.bag` field of the `UnsafeCell<Bag>` type. Here''s
    `Bag`, defined in `src/garbage.rs`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local`包含一个`self.bag`字段，其类型为`UnsafeCell<Bag>`。以下是`Bag`，在`src/garbage.rs`中定义：'
- en: '[PRE73]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`ArrayVec` is new to this book. It''s defined in the `ArrayVec` crate and is
    a `Vec` but with a capped maximum size. It''s the same growable vector we know
    and love, but one that can''t allocate to infinity. `Bag`, then, is a growable
    vector of `Garbage`, capped at `MAX_OBJECTS` total size:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayVec`是这本书的新内容。它在`ArrayVec`crate中定义，是一个`Vec`，但具有最大容量限制。它是我们熟悉和喜爱的可增长向量，但不能无限分配。然后，`Bag`是一个可增长向量，包含`Garbage`，总大小限制为`MAX_OBJECTS`：'
- en: '[PRE74]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Attempting to push garbage into a bag above `MAX_OBJECTS` will fail, signaling
    to the caller that it''s time to collect some garbage. What `Local::finalize`
    is doing, specifically with `self.global().push_bag(&mut *self.bag.get(), guard)`,
    is taking the `Local`''s bag of garbage and pushing it into the `Global`''s bag
    of garbage as a part of shutting `Local` down. `Global::push_bag` is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将垃圾推入超过`MAX_OBJECTS`的袋子将失败，向调用者发出信号，表明是时候收集一些垃圾了。`Local::finalize`具体做了什么，特别是与`self.global().push_bag(&mut
    *self.bag.get(), guard)`相关，是将`Local`的垃圾袋推入`Global`的垃圾袋，作为关闭`Local`的一部分。`Global::push_bag`是：
- en: '[PRE75]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Unpinning `Guard` potentially shuts down a `Local`, which pushes its garbage
    into the queue of epoch-tagged garbage in `Global`. Now that we understand that,
    let''s finish `Guard::defer` by inspecting `Local::defer`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 解除`Guard`的锁定可能会关闭一个`Local`，将其垃圾推入`Global`中标记为纪元的垃圾队列。现在我们明白了，让我们通过检查`Local::defer`来完成`Guard::defer`：
- en: '[PRE76]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The pinned caller signals garbage to its `Guard` by calling `defer`. The `Guard`,
    in turn, defers this garbage to its `Local`, which enters a while loop wherein
    it attempts to push garbage onto the local bag of garbage but will shift garbage
    into `Global` so long as the local bag is full.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定的调用者通过调用`defer`将垃圾信号传递给其`Guard`。然后，`Guard`将此垃圾延迟到其`Local`，后者进入一个while循环，尝试将垃圾推入本地垃圾袋，但只要本地垃圾袋满了，就会将垃圾移入`Global`。
- en: When does garbage get collected from `Global`? The answer is in a function we've
    not yet examined, `Local::pin`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾何时从`Global`中回收？答案是存在于我们尚未检查的函数中，即`Local::pin`。
- en: crossbeam_epoch::Local::pin
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: crossbeam_epoch::Local::pin
- en: 'Recall that `crossbeam_epoch::pin` calls `Handle::pin`, which in turn calls
    `pin` on its `Local`. What happens during the execution of `Local::pin`? A lot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`crossbeam_epoch::pin`调用`Handle::pin`，后者又调用其`Local`上的`pin`。在`Local::pin`执行期间会发生什么？很多：
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `Local` guard count is increased, which is done amusingly by creating a
    `Guard` with `self`. If the guard count was previously zero:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local`的守护者计数增加，这是通过创建一个带有`self`的`Guard`来完成的。如果守护者计数之前为零：'
- en: '[PRE78]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This means that there are no other active participants in `Local`, and `Local`
    needs to query for the global epoch. The global epoch is loaded as the `Local`
    epoch:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`Local`中没有其他活跃的参与者，并且`Local`需要查询全局纪元。全局纪元被加载为`Local`纪元：
- en: '[PRE79]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Sequential consistency is used here to ensure that ordering is maintained with
    regard to future and past atomic operations. Finally, the `Local`''s `pin_count`
    is increased and this kicks off, potentially, `Global::collect`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用顺序一致性来确保未来和过去原子操作的一致性。最后，`Local`的`pin_count`增加，这可能会启动`Global::collect`：
- en: '[PRE80]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It is possible for `Local` to be pinned and unpinned repeatedly, which is where
    `pin_count` comes into play. This mechanism doesn''t find use in our discussion
    here, but the reader is referred to `Guard::repin` and `Guard::repin_after`. The
    latter function is especially useful when mixing network calls with atomic data
    structures as, if you''ll recall, garbage cannot be collected until epochs advance
    and the epoch is only advanced by unpinning, usually. `Global::collect` is brief:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Local`可以反复锁定和解锁，这时`pin_count`就派上用场。这种机制在我们的讨论中并未使用，但读者可以参考`Guard::repin`和`Guard::repin_after`。后者函数在混合网络调用和原子数据结构时特别有用，因为正如你回忆的那样，垃圾回收只能在纪元推进后进行，而纪元的推进通常是通过解除锁定来实现的。`Global::collect`非常简洁：'
- en: '[PRE81]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The global epoch is potentially advanced by `Global::try_advance`, the advancement
    only happening if every `Local` in the global list of `Local` is not in another
    epoch *or* the list of locals is not modified during examination. The detection
    of concurrent modification is an especially neat trick, being part of crossbeam-epoch''s
    private `List` iteration. The tagged pointer plays a part in this iteration and
    the reader is warmly encouraged to read and understand the `List` implementation
    crossbeam-epoch uses:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 全球时代可能通过`Global::try_advance`向前推进，这种推进只有在全局`Local`列表中的每个`Local`都不在另一个时代，或者列表在检查期间没有被修改时才会发生。并发修改的检测是一个特别巧妙的技巧，它是crossbeam-epoch的私有`List`迭代的一部分。标记指针在这个迭代中扮演了一定的角色，强烈建议读者阅读并理解crossbeam-epoch使用的`List`实现：
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The condition will be passed into the Global''s `Queue::try_pop_if`, which
    only pops an element from the queue that matches the conditional. We can see the
    algorithm at play again here. Recall `self.queue :: Queue<(Epoch, Bag)>`? Bags
    of garbage will only be pulled from the queue if they are greater than two epochs
    away from the current epoch, otherwise there may still be live and dangerous references
    to them. The steps control how much garbage will end up being collected, doing
    a tradeoff for time versus memory use. Recall that every newly pinned thread is
    participating in this process, deallocating some of the global garbage.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '条件将被传递到Global的`Queue::try_pop_if`，它只会从队列中弹出与条件匹配的元素。我们在这里再次看到了算法的作用。回想一下`self.queue
    :: Queue<(Epoch, Bag)>`？垃圾袋只有在距离当前时代超过两个时代时才会从队列中取出，否则可能仍然存在对它们的活跃和危险的引用。这些步骤控制着最终将被收集的垃圾量，在时间与内存使用之间进行权衡。回想一下，每个新固定的线程都在参与这个过程，释放一些全局垃圾。'
- en: To summarize, when the programmer calls for their thread to be pinned, this
    creates a `Local` for storing thread-local garbage that is linked into a list
    of all `Local`s in a `Global` context. The thread will attempt to collect `Global`
    garbage, potentially pushing the epoch forward in the process. Any garbage the
    programmer defers during execution is preferentially pushed into the `Local` bag
    of garbage or, if that's full, causes some garbage to shift into the `Global`
    bag. Any garbage in the `Local` bag is shifted onto the `Global` bag when the
    `Local` is unpinned. Every atomic operation, by reason of requiring a reference
    to `Guard`, is implicitly associated with some `Local`, some epoch, and can be
    safely reclaimed by the method outlined in the preceding algorithm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当程序员调用线程固定时，这会为存储线程局部垃圾创建一个`Local`，并将其链接到`Global`上下文中所有`Local`的列表中。线程将尝试收集`Global`垃圾，在这个过程中可能推动时代向前。程序员在执行期间延迟的任何垃圾都会优先推入`Local`垃圾袋，如果这个袋满了，就会导致一些垃圾转移到`Global`袋中。当`Local`被取消固定时，`Local`袋中的任何垃圾都会转移到`Global`袋中。由于每个原子操作都需要对`Guard`的引用，因此每个原子操作隐式地与某个`Local`、某个时代相关联，并且可以安全地通过前面算法中概述的方法回收。
- en: Phew!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！
- en: Exercising the epoch-based Treiber stack
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习基于时代的Treiber栈
- en: 'Let''s put the crossbeam-epoch Treiber stack through the wringer to get an
    idea of the performance of this approach. Key areas of interest for us will be:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将crossbeam-epoch Treiber栈进行彻底测试，以了解这种方法的表现。对我们来说，关键的兴趣领域将是：
- en: Push/pop cycles per second
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒的推/弹周期
- en: Memory behavior, high-water mark, and what not
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存行为、水位线以及诸如此类的事情
- en: cache behavior
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存行为
- en: 'We''ll run our programs on x86 and ARM, like we did in previous chapters. Our
    exercise program, similar to the hazard pointer program from the previous section:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在x86和ARM上运行我们的程序，就像我们在前面的章节中所做的那样。我们的练习程序与上一节中的危险指针程序类似：
- en: '[PRE83]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We have a number of worker threads equal to the total number of CPUs in the
    target machine, each doing one push and then an immediate pop on the stack. A
    `COUNT` is kept and the main thread swaps that value for 0 every second or so,
    tossing the value into a quantile estimate structure—discussed in more detail
    in [Chapter 4](5a332d94-37e4-4748-8920-1679b07e2880.xhtml), *Sync and Send – the
    Foundation of Rust Concurrency*—and printing out a summary of the recorded cycles
    per second, scaled to the number of CPUs. The worker threads cycle up through
    to `MAX_I`, which is arbitrarily set to the smallish value of `2**26`. When the
    worker is finished cycling, it decreases `WORKERS` and exits. Once `WORKERS` hits
    zero, the main loop also exits.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'On my x86 machine, it takes approximately 38 seconds for this program to exit,
    with this output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Compare this to the x86 hazard implementation, which takes 58 total seconds.
    The x86 perf run is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The total number of executed instructions is much, much lower in the epoch-based
    approach, which squares well with the analysis in the opening discussion of this
    section. Even with a single hazardous pointer, epoch-based approaches do less
    work. On my ARM machine, it takes approximately 72 seconds for the program to
    run to completion, with this output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Compared to the ARM hazard implementation, which takes 463 total seconds! The
    ARM perf run is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Again, drastically fewer instructions are executed compared to the hazard-pointer
    implementation on the same processor architecture. In passing, it's worth noting
    that the memory use of both the x86 and ARM versions' `epoch_stack` were lower
    than the hazard pointer stack implementations, though neither were memory hogs,
    consuming only a few kilobytes each. Had one of our epoch threads slept for a
    long while—say, a second or so—before leaving its epoch, memory use would have
    grown during execution. The reader is encouraged to wreak havoc on their own system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Tradeoffs
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the three approaches outlined in this chapter, crossbeam-epoch is the fastest,
    both in terms of our measurements and from discussions in the literature. The
    faster technique, quiescent-state-based memory reclamation, is not discussed in
    this chapter as it''s an awkward fit for user-space programs and there is no readily-available
    implementation in Rust. Furthermore, the authors of the library have put years
    of work into the implementation: it is well-documented and runs on modern Rust
    across multiple CPU architectures.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Traditional issues with the approach—namely, threads introducing long delays
    to pinned critical sections, resulting in long-lived epochs and garbage buildup—are
    addressed in the API by the abiltiy of `Guard `to be arbitrarily repinned. The
    transition of standard-library `AtomicPtr` data structures to crossbeam is a project,
    to be sure, but an approachable one. As we've seen, crossbeam-epoch does introduce
    some overhead, both in terms of cache padding and thread synchronization. This
    overhead is minimal and should be expected to improve with time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed three memory reclamation techniques: reference
    counting, hazard pointers, and epoch-based reclamation. Each, in turn, is faster
    than the last, though there are tradeoffs with each approach. Reference counting
    incurs the most overhead and has to be incorporated carefully into your data structure,
    unless Arc fits your needs, which it may well. Hazard pointers require the identification
    of hazards, memory accesses that result in memory that cannot be reclaimed without
    some type of coordination. This approach incurs overhead on each access to the
    hazard, which is costly if traversal of a hazardous structure must be done. Finally,
    epoch-based reclamation incurs overhead at thread-pinning, which denotes the start
    of an epoch and may require the newly pinned thread to participate in garage collection.
    Additional overhead is not incurred on memory accesses post-pin, a big win if
    you''re doing traversal or can otherwise include many memory operations in a pinned
    section.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The crossbeam library is exceptionally well done. Unless you have an atomic
    data structure specifically designed to not require allocations or to cope with
    allocations on a relaxed memory system without recourse to garbage collection,
    you are warmly encouraged to consider crossbeam as part and parcel with doing
    atomic programming in Rust, as of this writing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will leave the realm of atomic programming and discuss
    higher-level approaches to parallel programming, using thread pooling and data
    parallel iterators.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects*, Maged Michael.
    This paper introduces the hazard-pointer reclamation technique discussed in this
    chapter. The paper specifically discusses the newly invented technique in comparison
    to reference counting and demonstrates the construction of a safe Michael and
    Scott queue using the hazard pointer technique.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical Lock-Freedom*, Keir Fraser. This is Keir Fraser''s PhD thesis and
    is quite long, being concerned with the introduction of abstractions to ease the
    writing of lock-free structures—one of which is epoch-based reclamation—and the
    introduction of lock-free search structures, skip-lists, binary search trees,
    and red-black trees. Warmly recommended.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance of Memory Reclamation for Lockless Synchronization*, Thomas Hart
    et al. This paper provides an overview of four techniques, all of which were discussed
    in passing in [Chapter 6](d42acb0b-a05e-4068-894f-81365d147bf4.xhtml), *Atomics
    – the Primitives of Synchronization*, of this book, and three of which were discussed
    in-depth in this chapter. Further, the paper introduces an optimization to epoch-based
    reclamation, which has influenced crossbeam, if your author is not mistaken. The
    paper is an excellent overview of the algorithms and provides comparative measurements
    of the algorithms'' performance in a well-defined manner.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFCs for changes to Crossbeam*, available at [https://github.com/crossbeam-rs/rfcs](https://github.com/crossbeam-rs/rfcs).
    This Github repository is the primary discussion point for large-scale changes
    to the crossbeam library and is an especially important read for its discussions.
    For instance, RFC 2017-07-23-relaxed-memory lays out the changes necessary to
    crossbeam to operate on relaxed-memory systems, a topic rarely discussed in the
    literature.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CDSCHECKER: Checking Concurrent Data Structures Written with C/C++ Atomics*,
    Brian Norris and Brian Demsky. This paper introduces a tool for checking the behavior
    of concurrent data structures according to the C++11/LLVM memory model. Given
    how utterly confounding relaxed-memory ordering can be, this tool is extremely
    useful when doing C++ work. I am unaware of a Rust analog but hope this will be
    seen as an opportunity for some bright spark reading this. Good luck, you.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Promising Semantics for Relaxed-Memory Concurrency*, Jeehoon Kang et al.
    Reasoning about the memory model proposed in C++/LLVM is very difficult. Which,
    despite how many people have thought about it in-depth over the years, there''s
    still active research into formalizing this model to validate the correct function
    of optimizers and algorithms. Do read this paper in conjunction with `CDSCHECKER`
    by Norris and Demsky.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
