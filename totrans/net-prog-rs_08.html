<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Security</h1>
                
            
            <article>
                
<p class="calibre2">Security is often looked at as an afterthought in systems design. That is evident in common protocols; security related RFCs has historically been proposed after the main protocol. Notice that any communication over a public medium (like the internet) is vulnerable to man-in-the-middle attacks. An adversary might hijack the communication by carefully inspecting input packets from both sides. In light of that, some security related questions are reasonable: When a client connects to a server, how does it verify that the server is the one it claims to be? How do they decide on a shared secret key to use for encryption? In this chapter, we will see how these questions are commonly addressed.</p>
<p class="calibre2">We will cover the following topics:</p>
<ul class="calibre7">
<li class="calibre8">Securing web-based applications using certificates</li>
<li class="calibre8">Key exchange using the Diffie-Hellman method</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Securing the web</h1>
                
            
            <article>
                
<p class="calibre2">In a previous chapter, we studied HTTP. We noted how important it has been in making our lives easier. However, HTTP is vulnerable to a range of attacks that might result in leaking the payload. Thus, it was necessary to add some form of security between parties using HTTP to communicate. RFC 2818 proposed HTTPS (HTTP Secure) as a version of HTTP that uses a secure streaming protocol underneath. Initially, this was <strong class="calibre1">Secure Socket Layer</strong> (<span><strong class="calibre1">SSL</strong>), </span>and later evolved into <strong class="calibre1">Transport Layer Security</strong> (<span><strong class="calibre1">TLS</strong>)</span>.</p>
<p class="calibre2">The basic scheme of things goes like this:</p>
<ul class="calibre7">
<li class="calibre8">The <strong class="calibre1">Client</strong> and <strong class="calibre1">Server</strong> establish a TCP connection.</li>
<li class="calibre8">The <strong class="calibre1">Client</strong> and <strong class="calibre1">Server</strong> agree upon a cipher and hash function to use throughout the connection. For this, the client sends a list of ciphers and hash functions. The <strong class="calibre1">Server</strong> picks one from that list and lets the <strong class="calibre1">Client</strong> know.</li>
<li class="calibre8">The <strong class="calibre1">Server</strong> sends a certificate to the <strong class="calibre1">Client</strong>. The <strong class="calibre1">Client</strong> validates this against a list of certificate authorities that it has locally.</li>
<li class="calibre8">Both agree on a session key to be used to encrypt data during the connection.</li>
<li class="calibre8">At this point, a regular HTTP session can begin.</li>
</ul>
<p class="calibre2">The following image illustrates the steps for this:</p>
<div class="cdpaligncenter"><img src="../images/00017.jpeg" class="calibre41"/></div>
<div class="packt_figref">Client-server communication over SSL</div>
<p class="calibre2">One of the most important steps here is verifying the server's identity. This answers a fundamental question: W<em class="calibre16">hen the client talks to a server, how does it know the server is actually the server it wanted?</em> In practice, this is achieved using certificates. A certificate is a document that is signed by a certificate authority, a trusted provider who is legally allowed to vouch for others. A client has a list of trusted CAs, and if the CA which issued a given certificate is on that list, a client can trust the server that presents that certificate. In practice, there are often a chain of certificates issued as a chain of trust relationships, going back to a root CA.</p>
<p class="calibre2">In recent years, search engines put a heavy emphasis on having HTTPS on websites, often ranking them higher in that case. However, issuing a certificate for a website has traditionally been a tedious process. A website owner will have to log in to a CA's website and provide some form of identification. Issuing the certificate often took a few hours and was very costly for small business owners. In 2015, Let's Encrypt launched as a non-profit CA with the goal of providing free, short-lived certificates to all websites on the internet. They automate the validation process by issuing a challenge to the server administrator. This typically involves either placing a given file in a known location on the website or creating a DNS record with a given content. Once <kbd class="calibre11">letsencrypt</kbd> has validated the server, it issues a certificate valid for 90 days. Thus, the certificate needs to be renewed periodically.</p>
<p class="calibre2">More recently, <kbd class="calibre11">letsencrypt</kbd> standardized the challenge response protocol as JSON over HTTPS and named it ACME. Here is how this works:</p>
<ul class="calibre7">
<li class="calibre8">The local client generates a private-public keypair and contacts the letsencrypt server with the <strong class="calibre1">Public</strong> key.</li>
<li class="calibre8">The server creates an account for the given key and registers it.</li>
<li class="calibre8">Based on challenge preferences, the <strong class="calibre1">Client</strong> will present a list of challenges that can be fulfilled and ask the server to validate the domain. Currently, two challenges are supported: an HTTP based challenge where a file is placed on a known location and the server will read it to validate, or a DNS based challenge where the operator has to create a <kbd class="calibre11">TXT</kbd> record on the domain with a given content.</li>
<li class="calibre8">The server generates the challenge and sends it back.</li>
<li class="calibre8">At this point, the client will poll the server for confirmation.</li>
<li class="calibre8">When the server returns an OK, the client can proceed to generating a <strong class="calibre1">certificate signing request</strong> (<strong class="calibre1">CSR</strong>) for the server and send it across.</li>
<li class="calibre8">The server then generates a certificate and sends it back.</li>
</ul>
<p class="calibre2">The following diagram illustrates individual steps in the ACME protocol:</p>
<div class="cdpaligncenter"><img src="../images/00018.jpeg" class="calibre42"/></div>
<div class="packt_figref">ACME protocol operation</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Letsencrypt using Rust</h1>
                
            
            <article>
                
<p class="calibre2">Currently, there is one crate that allows access to <kbd class="calibre11">letsencrypt</kbd> using Rust. The CLI tool called <kbd class="calibre11">acme-client</kbd> can interact with the API to obtain or revoke a certificate or run validations of ownership. The binary is backed by a crate called acme-client that enables programmatic interaction with the API. Let's see how this can be used to secure an HTTP server running on Rocket. Remember, for this to work, <kbd class="calibre11">letsencrypt</kbd> will need to reach the server. Thus, this needs to be publicly accessible over the internet.</p>
<p class="calibre2">The first step is to install the CLI tool using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo install acme-client</strong></pre>
<p class="calibre2">For our example, we will run our rocket blog over TLS. While Rocket does support TLS out of the box, it is not enabled by default. We will need to change the <kbd class="calibre11">Cargo.toml</kbd> file to add TLS as a feature flag. It should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/>name = "rocket-blog"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rocket = { version="0.3.5", features = ["tls"] }<br class="title-page-name"/>rocket_codegen = "0.3.5"<br class="title-page-name"/>rocket_contrib = "0.3.5"<br class="title-page-name"/>diesel = { version = "0.16.0", features = ["sqlite"] }<br class="title-page-name"/>diesel_codegen = { version = "0.16.0", features = ["sqlite"] }<br class="title-page-name"/>dotenv = "0.10.1"<br class="title-page-name"/>serde = "1.0.21"<br class="title-page-name"/>serde_json = "1.0.6"<br class="title-page-name"/>serde_derive = "1.0.21"<br class="title-page-name"/>lazy_static = "0.2.11"<br class="title-page-name"/>r2d2 = "0.7.4"<br class="title-page-name"/>r2d2-diesel = "0.16.0"</pre>
<p class="calibre2">We will also run Rocket on the public interface. For this, we will place a config file called <kbd class="calibre11">Rocket.toml</kbd> in the root of the repository. This is how it looks; everything else is left at the defaults:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Rocket.toml</strong><br class="title-page-name"/>[global]<br class="title-page-name"/>address = "0.0.0.0"</pre>
<p class="calibre2">Like we did before, we can run our server using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ DATABASE_URL=./db.sql cargo run</strong></pre>
<p class="calibre2">Letsencrypt also requires all servers to have a domain name. Thus, we will need to create a record for our server in a DNS provider. In our example, that DNS name is <kbd class="calibre11">my.domain.io</kbd>, which we will use in subsequent steps. Once that record has propagated everywhere, we can move on to the next step: generating certificates. Here is how we will do that using the CLI:</p>
<pre class="calibre17"><strong class="calibre1">$ acme-client -vvvvv sign --dns -D my.domain.io -P /var/www -o domain.crt</strong><br class="title-page-name"/>INFO:acme_client: Registering account<br class="title-page-name"/>DEBUG:acme_client: User successfully registered<br class="title-page-name"/>INFO:acme_client: Sending identifier authorization request for foo.datasine.com<br class="title-page-name"/>Please create a TXT record for _acme-challenge.my.domain.io: MFfatN9I3UFQk2WP_f1uRWi4rLnr4qMVaI<br class="title-page-name"/>Press enter to continue<br class="title-page-name"/><br class="title-page-name"/>INFO:acme_client: Triggering dns-01 validation<br class="title-page-name"/>DEBUG:acme_client: Status is pending, trying again...<br class="title-page-name"/>INFO:acme_client: Signing certificate<br class="title-page-name"/>DEBUG:acme_client: Certificate successfully signed</pre>
<p class="calibre2">We will have to use the DNS based validation here since we will not be able to serve back challenges. The CLI asked us to create a <kbd class="calibre11">TXT</kbd> record with a given name and content. Once we create the record, we will need to wait for some time so that it can propagate before we move forward. It is a good idea to check if the record is updated using <kbd class="calibre11">dig</kbd> before moving forward. Here is how the output of <kbd class="calibre11">dig</kbd> should look:</p>
<pre class="calibre17"><strong class="calibre1">$ dig _acme-challenge.my.domain.io TXT</strong><br class="title-page-name"/><br class="title-page-name"/>; &lt;&lt;&gt;&gt; DiG 9.9.7-P3 &lt;&lt;&gt;&gt; _acme-challenge.my.domain.io TXT<br class="title-page-name"/>;; global options: +cmd<br class="title-page-name"/>;; Got answer:<br class="title-page-name"/>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 49153<br class="title-page-name"/>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1<br class="title-page-name"/><br class="title-page-name"/>;; OPT PSEUDOSECTION:<br class="title-page-name"/>; EDNS: version: 0, flags:; udp: 8192<br class="title-page-name"/>;; QUESTION SECTION:<br class="title-page-name"/>;_acme-challenge.my.domain.io. IN TXT<br class="title-page-name"/><br class="title-page-name"/>;; ANSWER SECTION:<br class="title-page-name"/>_acme-challenge.my.domain.io. 60 IN TXT "MFfatN9I3UFQk2WP_f1uRWi4rLnr4qMVaI"<br class="title-page-name"/><br class="title-page-name"/>;; Query time: 213 msec<br class="title-page-name"/>;; SERVER: 192.168.0.1#53(192.168.0.1)<br class="title-page-name"/>;; WHEN: Fri Jan 05 18:04:01 GMT 2018<br class="title-page-name"/>;; MSG SIZE rcvd: 117</pre>
<p class="calibre2">When the output from <kbd class="calibre11">dig</kbd> says that we have the correct <kbd class="calibre11">TXT</kbd> record, we can move ahead with installing the certificate. <kbd class="calibre11">letsencrypt</kbd> will then query the <kbd class="calibre11">TXT</kbd> record and run domain validation. When everything looks fine, we will get a new certificate named <kbd class="calibre11">domain.crt</kbd>. Let's inspect the certificate to make sure everything looks okay. The subject should match our domain name and the issuer should always be <em class="calibre16">Let's Encrypt</em>, as shown in the following code snippet:</p>
<pre class="calibre17"><strong class="calibre1">$ openssl x509 -in domain.crt -subject -issuer -noout</strong><br class="title-page-name"/>subject= /CN=my.domain.io<br class="title-page-name"/>issuer= /C=US/O=Let's Encrypt/CN=Let's Encrypt Authority X3</pre>
<p class="calibre2">Now we are ready to use this certificate in our Rocket application. We will need to place it at a location where the running Rocket has permission to read it. Now, if we restart Rocket and use <kbd class="calibre11">curl</kbd> to access the endpoint over HTTPS, it should work exactly like last time:</p>
<pre class="calibre17"><strong class="calibre1">$ curl -sS -D - https://my.domain.io:8000/posts</strong><br class="title-page-name"/>HTTP/1.1 200 OK<br class="title-page-name"/>Content-Type: application/json<br class="title-page-name"/>Server: Rocket<br class="title-page-name"/>Content-Length: 992<br class="title-page-name"/>Date: Fri, 05 Jan 2018 18:37:58 GMT<br class="title-page-name"/><br class="title-page-name"/>[{"id":1,"title":"test","body":"test body","pinned":true},{"id":2,"title":"Hello Rust!","body":"Rust is awesome!!","pinned":true},{"id":3,"title":"Testing this","body":"Try to write something","pinned":true},{"id":4,"title":"Testing this","body":"Try to write something","pinned":true},{"id":5,"title":"Testing this","body":"Try to write something","pinned":true},{"id":6,"title":"Testing this","body":"Try to write something","pinned":true},{"id":7,"title":"Testing this","body":"Try to write something","pinned":true},{"id":8,"title":"Testing this","body":"Try to write something","pinned":true},{"id":9,"title":"Testing this","body":"Try to write something","pinned":true},{"id":10,"title":"Testing this","body":"Try to write something","pinned":true},{"id":11,"title":"Testing this","body":"Try to write something","pinned":true},{"id":12,"title":"Testing this","body":"Try to write something","pinned":true},{"id":13,"title":"Testing this","body":"Try to write something","pinned":true}]</pre>
<div class="packt_infobox">As of the time of writing, Let's Encrypt has a limit of five certificates for a given domain per week. For testing, it is possible to reach that limit pretty quickly. If that happens, the client will just say <span class="calibre18">Acme server error</span><em class="calibre27">.</em></div>
<p class="calibre2">Let's write a simple client for our server here using <kbd class="calibre11">rustls</kbd>. We set up the project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin rustls-client</strong></pre>
<p class="calibre2">We then add <kbd class="calibre11">rustls</kbd> to our project <span>as a dependency </span>:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "rustls-client"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rustls = "0.12.0"<br class="title-page-name"/>webpki = "0.18.0-alpha"<br class="title-page-name"/>webpki-roots = "0.14.0"</pre>
<p class="calibre2">Here is how the client looks; note that the <kbd class="calibre11">webpki</kbd> crate does DNS resolution, which is then used by <kbd class="calibre11">rustls</kbd>:</p>
<pre class="calibre17">// ch8/rustls-client/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>use std::sync::Arc;<br class="title-page-name"/><br class="title-page-name"/>use std::net::TcpStream;<br class="title-page-name"/>use std::io::{Read, Write};<br class="title-page-name"/><br class="title-page-name"/>extern crate rustls;<br class="title-page-name"/>extern crate webpki;<br class="title-page-name"/>extern crate webpki_roots;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut tls = rustls::ClientConfig::new();<br class="title-page-name"/>    tls.root_store.add_server_trust_anchors<br class="title-page-name"/>    (&amp;webpki_roots::TLS_SERVER_ROOTS);<br class="title-page-name"/><br class="title-page-name"/>    let name = webpki::DNSNameRef::try_from_ascii_str("my.domain.io")<br class="title-page-name"/>    .expect("Could not resolve name");<br class="title-page-name"/>    let mut sess = rustls::ClientSession::new(&amp;Arc::new(tls), name);<br class="title-page-name"/>    let mut conn = TcpStream::connect("my.domain.io:8000").unwrap();<br class="title-page-name"/>    let mut stream = rustls::Stream::new(&amp;mut sess, &amp;mut conn);<br class="title-page-name"/>    stream.write(concat!("GET /posts HTTP/1.1\r\n",<br class="title-page-name"/>                      "Connection: close\r\n",<br class="title-page-name"/>                      "\r\n")<br class="title-page-name"/>              .as_bytes())<br class="title-page-name"/>        .expect("Could not write request");<br class="title-page-name"/>    let mut plaintext = Vec::new();<br class="title-page-name"/>    stream.read_to_end(&amp;mut plaintext).expect("Could not read");<br class="title-page-name"/>    println!("{}", String::from_utf8(plaintext)<br class="title-page-name"/>    .expect("Could not print output"));<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we are connecting to our server and running the same HTTP request. We import all three required crates. The first step is to initialize a TLS session and add the root certificates to it. We then resolve our given server to a DNS name reference and establish a TLS session with it. Having set this up, we can set up a TCP session by using <kbd class="calibre11">connect</kbd>. Finally, a <kbd class="calibre11">rustls</kbd> <kbd class="calibre11">Stream</kbd> is a combination of the SSL session and the TCP session. Once all those are working, we can write HTTP queries by hand. Here we are running a <kbd class="calibre11">GET</kbd> on the <kbd class="calibre11">/posts</kbd> endpoint. Later, we read the response and print it out. The output should be exactly the same as using the other clients:</p>
<pre class="calibre17">HTTP/1.1 200 OK<br class="title-page-name"/>Content-Type: application/json<br class="title-page-name"/>Server: Rocket<br class="title-page-name"/>Content-Length: 992<br class="title-page-name"/>Date: Fri, 05 Jan 2018 18:37:58 GMT<br class="title-page-name"/><br class="title-page-name"/>[{"id":1,"title":"test","body":"test body","pinned":true},{"id":2,"title":"Hello Rust!","body":"Rust is awesome!!","pinned":true},{"id":3,"title":"Testing this","body":"Try to write something","pinned":true},{"id":4,"title":"Testing this","body":"Try to write something","pinned":true},{"id":5,"title":"Testing this","body":"Try to write something","pinned":true},{"id":6,"title":"Testing this","body":"Try to write something","pinned":true},{"id":7,"title":"Testing this","body":"Try to write something","pinned":true},{"id":8,"title":"Testing this","body":"Try to write something","pinned":true},{"id":9,"title":"Testing this","body":"Try to write something","pinned":true},{"id":10,"title":"Testing this","body":"Try to write something","pinned":true},{"id":11,"title":"Testing this","body":"Try to write something","pinned":true},{"id":12,"title":"Testing this","body":"Try to write something","pinned":true},{"id":13,"title":"Testing this","body":"Try to write something","pinned":true}]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">OpenSSL using Rust</h1>
                
            
            <article>
                
<p class="calibre2">The OpenSSL library and CLI is a complete set of tools to work with SSL (and TLS) objects. It is an open source project and is widely used by companies all around. As one would expect, Rust has bindings for using as a library in Rust projects. In this discussion, we will take a closer look at the certificates we saw in the last section.</p>
<p class="calibre2">These are commonly defined by a standard called X.509 (defined in RFC 5280) and have the following fields:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Version number</strong>: Almost always set to 2, corresponding to version 3 (since the first version is 0). According to the standard, this field can be omitted and should be assumed to be version 1 (value set to 0).</li>
<li class="calibre8"><strong class="calibre1">Serial number</strong>: A 20 octet identifier that is unique for the CA which signed this certificate.</li>
<li class="calibre8"><strong class="calibre1">Signature</strong>: A unique ID that identifies the algorithm used to sign this certificate. This is usually a string defined in subsequent RFCs, an example being <kbd class="calibre11">sha1WithRSAEncryption</kbd>.</li>
<li class="calibre8"><strong class="calibre1">Issuer name</strong>: Identifies the CA that signed the certificate. This must have at least one <strong class="calibre1">Distinguished name</strong> (<strong class="calibre1">DN</strong>) composed of a number of components, including a <strong class="calibre1">Common Name</strong> (<strong class="calibre1">CN</strong>), <strong class="calibre1">State</strong> (<strong class="calibre1">ST</strong>), <strong class="calibre1">Country</strong> (<strong class="calibre1">C</strong>), and so on.</li>
<li class="calibre8"><strong class="calibre1">Validity</strong>: Defines when the certificate should be valid. This has two sub-fields; <kbd class="calibre11">notBefore</kbd> denotes when this starts to be valid and <kbd class="calibre11">notAfter</kbd> denotes when it expires.</li>
<li class="calibre8"><strong class="calibre1">Subject name</strong>: Identifies the entity this certificate certifies. For a root certificate, this will be the same as the issuer. This has the same format as the issuer name and should at least have a DN.</li>
<li class="calibre8"><strong class="calibre1">Subject public key info</strong>: Information about the subject's encrypted public key. This has two sub-fields; the first one is an ID for the encryption algorithm (as in the signature field), and the second is a bit stream that has the encrypted public key.</li>
<li class="calibre8"><strong class="calibre1">Issuer unique ID</strong>: An optional field that can be used to uniquely identify the issuer.</li>
<li class="calibre8"><strong class="calibre1">Subject unique ID</strong>: An optional field that can be used to identify the subject.</li>
<li class="calibre8"><strong class="calibre1">Extensions</strong>: This field is only applicable if the version is set to 3. Denotes a number of optional fields that can be used to attach additional information to certificates.</li>
<li class="calibre8"><strong class="calibre1">Certificate signature algorithm</strong>: Algorithm used to sign this certificate; must be the same as the one used in the signature attribute previously.</li>
<li class="calibre8"><strong class="calibre1">Certificate signature value</strong>: A bit string that has the actual signature for verification.</li>
</ul>
<p class="calibre2">In the following example, we will use <kbd class="calibre11">rust-openssl</kbd> to generate and inspect a certificate from scratch. Installing the library, however, can be a little complicated. Since it is a wrapper around <kbd class="calibre11">libopenssl</kbd>, it needs to link against the native library. Thus, the library has to be installed. The crate's documentation has instructions to get this set up. The project setup is routine:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin openssl-example</strong></pre>
<p class="calibre2"><span>Here is the <kbd class="calibre11">Cargo.toml</kbd> file:</span></p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "openssl-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>openssl = { git = "https://github.com/sfackler/rust-openssl" }</pre>
<p class="calibre2"><span>Also, for this example, we will use the master branch of the repository, since we need a few features that are not released yet. For that, we will need to specify the repository link, as shown previously. Here is the main file:</span></p>
<pre class="calibre17">// ch8/openssl-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate openssl;<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/>use std::fs::File;<br class="title-page-name"/>use std::io::Write;<br class="title-page-name"/><br class="title-page-name"/>use openssl::x509::{X509, X509Name};<br class="title-page-name"/>use openssl::nid::Nid;<br class="title-page-name"/>use openssl::pkey::{PKey, Private};<br class="title-page-name"/>use openssl::rsa::Rsa;<br class="title-page-name"/>use openssl::error::ErrorStack;<br class="title-page-name"/>use openssl::asn1::Asn1Time;<br class="title-page-name"/>use openssl::bn::{BigNum, MsbOption};<br class="title-page-name"/>use openssl::hash::MessageDigest;<br class="title-page-name"/><br class="title-page-name"/>fn create_cert() -&gt; Result&lt;(X509, PKey&lt;Private&gt;), ErrorStack&gt; {<br class="title-page-name"/>    let mut cert_builder = X509::builder()?;<br class="title-page-name"/>    cert_builder.set_version(2)?;<br class="title-page-name"/><br class="title-page-name"/>    let serial_number = {<br class="title-page-name"/>        let mut serial = BigNum::new()?;<br class="title-page-name"/>        serial.rand(160, MsbOption::MAYBE_ZERO, false)?;<br class="title-page-name"/>        serial.to_asn1_integer()?<br class="title-page-name"/>    };<br class="title-page-name"/>    cert_builder.set_serial_number(&amp;serial_number)?;<br class="title-page-name"/><br class="title-page-name"/>    let mut name = X509Name::builder()?;<br class="title-page-name"/>    name.append_entry_by_text("C", "UK")?;<br class="title-page-name"/>    name.append_entry_by_text("CN", "Our common name")?;<br class="title-page-name"/>    let cert_name = name.build();<br class="title-page-name"/>    cert_builder.set_issuer_name(&amp;cert_name)?;<br class="title-page-name"/><br class="title-page-name"/>    let not_before = Asn1Time::days_from_now(0)?;<br class="title-page-name"/>    cert_builder.set_not_before(&amp;not_before)?;<br class="title-page-name"/><br class="title-page-name"/>    let not_after = Asn1Time::days_from_now(365)?;<br class="title-page-name"/>    cert_builder.set_not_after(&amp;not_after)?;<br class="title-page-name"/><br class="title-page-name"/>    cert_builder.set_subject_name(&amp;cert_name)?;<br class="title-page-name"/><br class="title-page-name"/>    let private_key = PKey::from_rsa(Rsa::generate(3072)?)?;<br class="title-page-name"/>    cert_builder.set_pubkey(&amp;private_key)?;<br class="title-page-name"/><br class="title-page-name"/>    cert_builder.sign(&amp;private_key, MessageDigest::sha512())?;<br class="title-page-name"/>    let cert = cert_builder.build();<br class="title-page-name"/><br class="title-page-name"/>    Ok((cert, private_key))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    if let Some(arg) = env::args().nth(1) {<br class="title-page-name"/>        let (cert, _key) = create_cert().expect("could not create<br class="title-page-name"/>        cert");<br class="title-page-name"/>        let cert_data = cert.to_pem().expect("could not convert cert<br class="title-page-name"/>        to pem");<br class="title-page-name"/><br class="title-page-name"/>        let mut cert_file = File::create(arg)<br class="title-page-name"/>        .expect("could not create cert file");<br class="title-page-name"/>        cert_file<br class="title-page-name"/>            .write_all(&amp;cert_data)<br class="title-page-name"/>            .expect("failed to write cert");<br class="title-page-name"/><br class="title-page-name"/>        let subject = cert.subject_name();<br class="title-page-name"/>        let cn = subject<br class="title-page-name"/>            .entries_by_nid(Nid::COMMONNAME)<br class="title-page-name"/>            .next()<br class="title-page-name"/>            .expect("failed to get subject");<br class="title-page-name"/>        println!("{}",String::from_utf8(cn.data()<br class="title-page-name"/>        .as_slice().to_vec()).unwrap()<br class="title-page-name"/>        );<br class="title-page-name"/>    } else {<br class="title-page-name"/>        eprintln!("Expected at least one argument");<br class="title-page-name"/>        std::process::exit(1);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we take in a filename as a command-line parameter to write the certificate to. Certificate creation is offloaded to a helper function called <kbd class="calibre11">create_cert</kbd> that returns either a tuple having the generated certificate and private key or a list of errors as a <kbd class="calibre11">Result</kbd>.</p>
<p class="calibre2">The first step is to initialize a certificate builder object that we will add on to, and finally, build our certificate. <span>We use the <kbd class="calibre11">set_version</kbd> method to set the version to 3 (numerically set to <kbd class="calibre11">2</kbd>). Now we need to generate a serial number and set it. We generate that by randomly sampling 160 bits (20 octets of 8 bits each). We use the <kbd class="calibre11">set_serial_number</kbd> method to set the serial number. The next step is to generate a name by using a name builder. The <kbd class="calibre11">append_entry_by_text</kbd> method is then used to add a country name and a common name to our name builder. We use <kbd class="calibre11">set_issuer_name</kbd> to append the <kbd class="calibre11">name</kbd> object to the certificate. We set the expiry date to 365 days after the current date and use <kbd class="calibre11">set_not_before</kbd> and <kbd class="calibre11">set_not_after</kbd> to set those two. The subject name is set to the same name object using <kbd class="calibre11">set_subject_name</kbd>. Finally, we need to generate a private key, which we generate using the <kbd class="calibre11">Rsa</kbd> module, and we set the private key on the certificate. Now, the certificate needs to be signed with the private key using SHA512. Once done, we can use the <kbd class="calibre11">build</kbd> method to create the certificate. At the end of the function, we return the certificate and private key to the caller.</span></p>
<p class="calibre2">In our <kbd class="calibre11">main</kbd> function, we call the <kbd class="calibre11">helper</kbd> function. For our example, we will ignore the key, but a real application does need to save it for verification later. We convert the <kbd class="calibre11">certificate</kbd> object to PEM encoding and write it to a file on the disk. The next step is reading the subject name programmatically. For this, we use the <kbd class="calibre11">subject_name</kbd> method on the <kbd class="calibre11">certificate</kbd> object and print it out as a string. This should match the subject name we set earlier.</p>
<p class="calibre2">Here is how we can run this using Cargo. Note that this creates a certificate named <kbd class="calibre11">bar.crt</kbd> in the current directory:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run bar.crt</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/openssl-example bar.crt`<br class="title-page-name"/>Our common name<br class="title-page-name"/><strong class="calibre1">$ ls -la bar.crt</strong><br class="title-page-name"/>-rw-r--r--+ 1 Abhishek staff 1399 19 Feb 22:02 bar.crt</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Securing tokio applications</h1>
                
            
            <article>
                
<p class="calibre2">A common problem in implementing Tokio based protocols is around securing them. Luckily, the Tokio ecosystem has <kbd class="calibre11">tokio-tls</kbd> for this. Let's look at an example of using this to secure our hyper example from a previous chapter. Here is our setup:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin tokio-tls-example</strong></pre>
<p class="calibre2">The Cargo manifest should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "tokio-tls-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>hyper = "0.11.7"<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>net2 = "0.2.31"<br class="title-page-name"/>tokio-core = "0.1.10"<br class="title-page-name"/>num_cpus = "1.0"<br class="title-page-name"/>native-tls = "*"<br class="title-page-name"/>tokio-service = "*"<br class="title-page-name"/>tokio-proto = "*"<br class="title-page-name"/>tokio-tls = { version = "0.1", features = ["tokio-proto"] }</pre>
<p class="calibre2">We will need to use the <kbd class="calibre11">tokio-proto</kbd> feature on <kbd class="calibre11">tokio-tls</kbd> to enable integration with <kbd class="calibre11">tokio-proto</kbd>. The next step is to generate a self-signed certificate for our server. <kbd class="calibre11">tokio-tls</kbd> uses the <kbd class="calibre11">native-tls</kbd> library underneath, and that does not support constructing acceptors from X509 certificates at the time of this writing. Thus, we will need to use PKCS12 certificates. The command shown ahead generates a self signed certificate, valid for 365 days, in PEM format. This will ask for a pass-phrase for the certificate. In our case, we used <kbd class="calibre11">foobar</kbd>. Please ensure that this command is run in the <kbd class="calibre11">tokio-tls-example</kbd> directory so that our code can read the certificate:</p>
<pre class="calibre17"><strong class="calibre1">$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365</strong></pre>
<p class="calibre2">The following command converts the given certificate to PKCS12 format. This should generate a file called <kbd class="calibre11">cert.pfx</kbd> in the current directory, which we will use in the code:</p>
<pre class="calibre17"><strong class="calibre1">$ openssl pkcs12 -export -out cert.pfx -inkey key.pem -in cert.pem</strong></pre>
<p class="calibre2">Here is our main file, with some changes for enabling SSL:</p>
<pre class="calibre17">// ch8/tokio-tls-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate hyper;<br class="title-page-name"/>extern crate native_tls;<br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/>extern crate tokio_tls;<br class="title-page-name"/><br class="title-page-name"/>use std::io;<br class="title-page-name"/>use std::{thread, time};<br class="title-page-name"/>use futures::future::{ok, Future};<br class="title-page-name"/>use hyper::server::Http;<br class="title-page-name"/>use hyper::header::ContentLength;<br class="title-page-name"/>use hyper::{Request, Response, StatusCode};<br class="title-page-name"/>use native_tls::{Pkcs12, TlsAcceptor};<br class="title-page-name"/>use tokio_proto::TcpServer;<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/>use tokio_tls::proto;<br class="title-page-name"/><br class="title-page-name"/>fn heavy_work() -&gt; String {<br class="title-page-name"/>    let duration = time::Duration::from_millis(100);<br class="title-page-name"/>    thread::sleep(duration);<br class="title-page-name"/>    "done".to_string()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>struct SlowMo;<br class="title-page-name"/><br class="title-page-name"/>impl Service for SlowMo {<br class="title-page-name"/>    type Request = Request;<br class="title-page-name"/>    type Response = Response;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = Response, Error = io::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Request) -&gt; Self::Future {<br class="title-page-name"/>        let b = heavy_work().into_bytes();<br class="title-page-name"/>        println!("Request: {:?}", req);<br class="title-page-name"/>        Box::new(ok(Response::new()<br class="title-page-name"/>            .with_status(StatusCode::Ok)<br class="title-page-name"/>            .with_header(ContentLength(b.len() as u64))<br class="title-page-name"/>            .with_body(b)))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let raw_cert = include_bytes!("../cert.pfx");<br class="title-page-name"/>    let cert = Pkcs12::from_der(raw_cert, "foobar").unwrap();<br class="title-page-name"/>    let acceptor = TlsAcceptor::builder(cert).unwrap().build().unwrap();<br class="title-page-name"/>    let proto = proto::Server::new(Http::new(), acceptor);<br class="title-page-name"/>    let addr = "0.0.0.0:9999".parse().unwrap();<br class="title-page-name"/>    let srv = TcpServer::new(proto, addr);<br class="title-page-name"/>    println!("Listening on {}", addr);<br class="title-page-name"/>    srv.serve(|| Ok(SlowMo));<br class="title-page-name"/>}</pre>
<p class="calibre2">The major changes here are that in the main function, we use the <kbd class="calibre11">include_bytes</kbd> macro to read the certificate as raw bytes. We then construct a <kbd class="calibre11">Pkcs12</kbd> object using <kbd class="calibre11">from_der</kbd> by passing the certificate bytes and the pass-phrase that we used while creating the certificate. The next step is to create a <kbd class="calibre11">TlsAcceptor</kbd> object using the given <kbd class="calibre11">Pkcs12</kbd> <kbd class="calibre11">certificate</kbd> object. We will then need to wrap the <kbd class="calibre11">acceptor</kbd> object and the <kbd class="calibre11">hyper protocol</kbd> object into a <kbd class="calibre11">Server</kbd>. This is passed to the <kbd class="calibre11">TcpServer</kbd> constructor, which we then start.</p>
<p class="calibre2">Here is what a session looks like from a client's perspective:</p>
<pre class="calibre17"><strong class="calibre1">$ curl -k https://localhost:9999</strong><br class="title-page-name"/>done</pre>
<p class="calibre2">Here is what the server prints; this originates from the <kbd class="calibre11">println!</kbd> macro in the call function:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling rustls-example v0.1.0 (file:///src/ch8/rustls-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 3.14 secs<br class="title-page-name"/>     Running `target/debug/rustls-example`<br class="title-page-name"/>Listening on 0.0.0.0:9999<br class="title-page-name"/>Request: Request { method: Get, uri: "/", version: Http11, remote_addr: None, headers: {"Host": "localhost:9999", "User-Agent": "curl/7.57.0", "Accept": "*/*"} }<br class="title-page-name"/>^C</pre>
<p class="calibre2">Interestingly, the <kbd class="calibre11">openssl</kbd> command-line tool has a TCP client that can be used to test SSL connections as well. Here is how to use it to test our server:</p>
<pre class="calibre17"><strong class="calibre1">$ openssl s_client -connect 127.0.0.1:9999</strong><br class="title-page-name"/>CONNECTED(00000003)<br class="title-page-name"/>depth=0 C = UK, ST = Scotland, O = Internet Widgits Pty Ltd<br class="title-page-name"/>verify error:num=18:self signed certificate<br class="title-page-name"/>verify return:1<br class="title-page-name"/>depth=0 C = UK, ST = Scotland, O = Internet Widgits Pty Ltd<br class="title-page-name"/>verify return:1<br class="title-page-name"/>---<br class="title-page-name"/>Certificate chain<br class="title-page-name"/> 0 s:/C=UK/ST=Scotland/O=Internet Widgits Pty Ltd<br class="title-page-name"/>   i:/C=UK/ST=Scotland/O=Internet Widgits Pty Ltd<br class="title-page-name"/>---<br class="title-page-name"/>Server certificate<br class="title-page-name"/>-----BEGIN CERTIFICATE-----<br class="title-page-name"/>...<br class="title-page-name"/>-----END CERTIFICATE-----<br class="title-page-name"/>subject=/C=UK/ST=Scotland/O=Internet Widgits Pty Ltd<br class="title-page-name"/>issuer=/C=UK/ST=Scotland/O=Internet Widgits Pty Ltd<br class="title-page-name"/>---<br class="title-page-name"/>No client certificate CA names sent<br class="title-page-name"/>Peer signing digest: SHA256<br class="title-page-name"/>Server Temp Key: ECDH, P-256, 256 bits<br class="title-page-name"/>---<br class="title-page-name"/>SSL handshake has read 2128 bytes and written 433 bytes<br class="title-page-name"/>---<br class="title-page-name"/>New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384<br class="title-page-name"/>Server public key is 4096 bit<br class="title-page-name"/>Secure Renegotiation IS supported<br class="title-page-name"/>Compression: NONE<br class="title-page-name"/>Expansion: NONE<br class="title-page-name"/>No ALPN negotiated<br class="title-page-name"/>SSL-Session:<br class="title-page-name"/>    Protocol : TLSv1.2<br class="title-page-name"/>    Cipher : ECDHE-RSA-AES256-GCM-SHA384<br class="title-page-name"/>    Session-ID: 9FAB89D29DB02891EF52C825AC23E3A658FDCE228A1A7E4FD97652AC3A5E24F3<br class="title-page-name"/>    Session-ID-ctx:<br class="title-page-name"/>    Master-Key: 940EF0C4FA1A929133C2D273739C8042FAF1BD5057E793ED1D7A0F0187F0236EF9E43D236DF8C17D663D7B77F1B4CEDD<br class="title-page-name"/>    Key-Arg : None<br class="title-page-name"/>    PSK identity: None<br class="title-page-name"/>    PSK identity hint: None<br class="title-page-name"/>    SRP username: None<br class="title-page-name"/>    Start Time: 1515350045<br class="title-page-name"/>    Timeout : 300 (sec)<br class="title-page-name"/>    Verify return code: 18 (self signed certificate)<br class="title-page-name"/>---<br class="title-page-name"/>GET / HTTP/1.1<br class="title-page-name"/>host: foobar<br class="title-page-name"/><br class="title-page-name"/>HTTP/1.1 200 OK<br class="title-page-name"/>Content-Length: 4<br class="title-page-name"/>Date: Sun, 07 Jan 2018 18:34:52 GMT<br class="title-page-name"/><br class="title-page-name"/>done</pre>
<p class="calibre2">This tool negotiates an SSL session and dumps the server certificate as shown previously (we have replaced the actual certificate for brevity). Notice that it correctly detects that the given server is using a self-signed certificate. Finally, it starts a TCP session. Since this is bare TCP, we will need to hand craft our HTTP requests. If we use a simple <kbd class="calibre11">GET</kbd> request on <kbd class="calibre11">/</kbd>, we get back a response of <kbd class="calibre11">200 OK</kbd>, and the string is done. On the other side, this is what the server prints:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/tokio-tls-example`<br class="title-page-name"/>Listening on 0.0.0.0:9999<br class="title-page-name"/>Request: Request { method: Get, uri: "/", version: Http11, remote_addr: None, headers: {"Host": "foobar"} }</pre>
<p class="calibre2">Notice that this prints the <kbd class="calibre11">Host</kbd> header, set to the string <kbd class="calibre11">foobar</kbd>, as we wrote on the client side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cryptography using ring</h1>
                
            
            <article>
                
<p class="calibre2">A commonly used crate for cryptography is called <kbd class="calibre11">ring</kbd>. This crate supports a number of lower-level crypto primitives, like random number generation, key exchanges, and so on. In this section, we will take key exchange as an example and see how this crate can be used in client-server applications.</p>
<p class="calibre2">A common problem in communication is that of encrypting information so that a third-party cannot decipher it. In a private key system, both the client and the server will need to agree on a key to use for this to work. Now, this key cannot be transmitted in plain text over an insecure connection. The Diffie-Hellman key exchange method defines a mechanism where two parties talking over a secure link can negotiate a key that is shared between them, but has not been transmitted over the connection. This method has a number of implementations on many platforms, including the crate in question.</p>
<p class="calibre2">The following diagram shows how the protocol works:</p>
<div class="cdpaligncenter"><img src="../images/00019.jpeg" class="calibre43"/></div>
<div class="packt_figref">Diffie-Hellman key exchange in action</div>
<p class="calibre2">Initially, the server will be listening for incoming clients. When a client connects, this is the sequence of events:</p>
<ol class="calibre13">
<li value="1" class="calibre8">A TCP session is first set up.</li>
<li value="2" class="calibre8">Both the server and the client generate private and public keys.</li>
<li value="3" class="calibre8">The client then sends its public key to the server.</li>
<li value="4" class="calibre8">The server responds by sending the public key that it generated.</li>
<li value="5" class="calibre8">At this point, both of the parties can generate the shared secret key using their private keys and the public key that they received.</li>
<li value="6" class="calibre8">Further communication can be encrypted using the shared secret key.</li>
</ol>
<p class="calibre2">We will create an empty library project for this example. We will then create an example directory and place the two files shown <span>later</span> in there. Project setup will go like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new key-exchange</strong></pre>
<p class="calibre2">Also, here is what <kbd class="calibre11">Cargo.toml</kbd> should look like:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "key-exchange"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>ring = "0.12.1"<br class="title-page-name"/>untrusted = "0.5.1"</pre>
<p class="calibre2">Let's look at the client first. This is heavily borrowed from the simple TCP servers we wrote in the second chapter. This is completely synchronous and blocking:</p>
<pre class="calibre17">// ch8/key-exchange/examples/client.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate ring;<br class="title-page-name"/>extern crate untrusted;<br class="title-page-name"/><br class="title-page-name"/>use std::net::TcpStream;<br class="title-page-name"/>use std::io::{BufRead, BufReader, Write};<br class="title-page-name"/><br class="title-page-name"/>use ring::{agreement, rand};<br class="title-page-name"/>use untrusted::Input;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut stream = TcpStream::connect("127.0.0.1:8888")<br class="title-page-name"/>    .expect("Could not connect to server");<br class="title-page-name"/><br class="title-page-name"/>    let rng = rand::SystemRandom::new();<br class="title-page-name"/><br class="title-page-name"/>    // Generate the client's private key<br class="title-page-name"/>    let client_private_key =<br class="title-page-name"/>    agreement::EphemeralPrivateKey::generate(&amp;agreement::X25519, &amp;rng)<br class="title-page-name"/>                            .expect("Failed to generate key");<br class="title-page-name"/>    let mut client_public_key = [0u8; agreement::PUBLIC_KEY_MAX_LEN];<br class="title-page-name"/>    let client_public_key = &amp;mut<br class="title-page-name"/>    client_public_key[..client_private_key.public_key_len()];<br class="title-page-name"/><br class="title-page-name"/>    // Generate the client's public key<br class="title-page-name"/>    client_private_key.compute_public_key<br class="title-page-name"/>    (client_public_key).expect("Failed to<br class="title-page-name"/>    generate key");<br class="title-page-name"/><br class="title-page-name"/>    // Send client's public key to server<br class="title-page-name"/>    stream.write(client_public_key)<br class="title-page-name"/>    .expect("Failed to write to server");<br class="title-page-name"/><br class="title-page-name"/>    let mut buffer: Vec&lt;u8&gt; = Vec::new();<br class="title-page-name"/>    let mut reader = BufReader::new(&amp;stream);<br class="title-page-name"/><br class="title-page-name"/>    // Read server's public key<br class="title-page-name"/>    reader.read_until(b'\n', &amp;mut buffer)<br class="title-page-name"/>    .expect("Could not read into buffer");<br class="title-page-name"/>    let peer_public_key = Input::from(&amp;buffer);<br class="title-page-name"/><br class="title-page-name"/>    println!("Received: {:?}", peer_public_key);<br class="title-page-name"/><br class="title-page-name"/>    // Generate shared secret key<br class="title-page-name"/>    let res = agreement::agree_ephemeral<br class="title-page-name"/>    (client_private_key, &amp;agreement::X25519,<br class="title-page-name"/>    peer_public_key,<br class="title-page-name"/>    ring::error::Unspecified,<br class="title-page-name"/>    |key_material| {<br class="title-page-name"/>        let mut key = Vec::new();<br class="title-page-name"/>        key.extend_from_slice(key_material);<br class="title-page-name"/>        Ok(key)<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    println!("{:?}", res.unwrap());<br class="title-page-name"/>}</pre>
<p class="calibre2">We of course need the <kbd class="calibre11">ring</kbd> crate as an external dependency. The other crate, called <kbd class="calibre11">untrusted</kbd>, is a helper for taking in data from untrusted sources to <kbd class="calibre11">ring</kbd> as input. We then initialize ring's random number generator; this will be used to generate keys later. We then generate a private key for the client using the <kbd class="calibre11">generate</kbd> method. The client's public key is generated based on the private key using <kbd class="calibre11">compute_public_key</kbd>. At this point, the client is ready to send the public key to the server. It writes the key as a byte stream to the connection created earlier. Ideally, the server should send out its public key at this point, which the client needs to read off the same connection. This is done by the <kbd class="calibre11">read_until</kbd> call that places the data received in the buffer. The incoming data is then passed through the untrusted crate so that <kbd class="calibre11">ring</kbd> can consume it. Finally, the client-side key is generated using <kbd class="calibre11">agree_ephemeral</kbd>, which takes in the two keys collected (the client's private key and the server's public key), an error value, and a closure to be used on the generated byte stream. In the closure, we collect all the data in a vector and return it. The last step is to print that vector.</p>
<p class="calibre2">The server is similar and looks like the following code snippet:</p>
<pre class="calibre17">// ch8/key-exchange/src/examples/server.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate ring;<br class="title-page-name"/>extern crate untrusted;<br class="title-page-name"/><br class="title-page-name"/>use std::net::{TcpListener, TcpStream};<br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use std::io::{Read, Write};<br class="title-page-name"/><br class="title-page-name"/>use ring::{agreement, rand};<br class="title-page-name"/>use untrusted::Input;<br class="title-page-name"/>use ring::error::Unspecified;<br class="title-page-name"/><br class="title-page-name"/>fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Unspecified&gt; {<br class="title-page-name"/>    let rng = rand::SystemRandom::new();<br class="title-page-name"/><br class="title-page-name"/>    // Generate server's private key<br class="title-page-name"/>    let server_private_key =<br class="title-page-name"/>    agreement::EphemeralPrivateKey::generate<br class="title-page-name"/>    (&amp;agreement::X25519, &amp;rng)?;<br class="title-page-name"/>    let mut server_public_key = [0u8; agreement::PUBLIC_KEY_MAX_LEN];<br class="title-page-name"/>    let server_public_key = &amp;mut<br class="title-page-name"/>    server_public_key[..server_private_key.public_key_len()];<br class="title-page-name"/><br class="title-page-name"/>    // Generate server's public key<br class="title-page-name"/>    server_private_key.compute_public_key(server_public_key)?;<br class="title-page-name"/><br class="title-page-name"/>    let mut peer_public_key_buf = [0u8; 32];<br class="title-page-name"/><br class="title-page-name"/>    // Read client's public key<br class="title-page-name"/>    stream.read(&amp;mut peer_public_key_buf).expect("Failed to read");<br class="title-page-name"/>    let peer_public_key = Input::from(&amp;peer_public_key_buf);<br class="title-page-name"/><br class="title-page-name"/>    println!("Received: {:?}", peer_public_key);<br class="title-page-name"/><br class="title-page-name"/>    // Send server's public key<br class="title-page-name"/>    stream.write(&amp;server_public_key)<br class="title-page-name"/>    .expect("Failed to send server public key");<br class="title-page-name"/><br class="title-page-name"/>    // Generate shared secret key<br class="title-page-name"/>    let res = agreement::agree_ephemeral(server_private_key,<br class="title-page-name"/>                                        &amp;agreement::X25519,<br class="title-page-name"/>                                        peer_public_key,<br class="title-page-name"/>                                        ring::error::Unspecified,<br class="title-page-name"/>                                        |key_material| {<br class="title-page-name"/>        let mut key = Vec::new();<br class="title-page-name"/>        key.extend_from_slice(key_material);<br class="title-page-name"/>        Ok(key)<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    println!("{:?}", res.unwrap());<br class="title-page-name"/><br class="title-page-name"/>    Ok(())<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let listener = TcpListener::bind("0.0.0.0:8888").expect("Could not bind");<br class="title-page-name"/>    for stream in listener.incoming() {<br class="title-page-name"/>        match stream {<br class="title-page-name"/>            Err(e) =&gt; { eprintln!("failed: {}", e) }<br class="title-page-name"/>            Ok(stream) =&gt; {<br class="title-page-name"/>                thread::spawn(move || {<br class="title-page-name"/>                    handle_client(stream)<br class="title-page-name"/>                    .unwrap_or_else(|error| eprintln!(<br class="title-page-name"/>                    "{:?}", error));<br class="title-page-name"/>                });<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Like we did last time, we handle each client in a new thread. The semantics in the <kbd class="calibre11">handle_client</kbd> function is similar to that of the client; we start with generating a private and a public key. The next step is to read the public key that the client sent, followed by sending the public key of the server. Once settled, we can then use <kbd class="calibre11">agree_ephemeral</kbd> to generate the shared secret key, which should match the one generated on the client side.</p>
<p class="calibre2">Here is a sample run on the server side:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --example server</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/examples/server`<br class="title-page-name"/>Received: Input { value: Slice { bytes: [60, 110, 82, 192, 131, 173, 255, 92, 134, 0, 185, 186, 87, 178, 51, 71, 136, 201, 15, 179, 204, 137, 125, 32, 87, 94, 227, 209, 47, 243, 75, 73] } }<br class="title-page-name"/>Generated: [184, 9, 123, 15, 139, 191, 170, 9, 133, 143, 81, 45, 254, 15, 234, 12, 223, 57, 131, 145, 127, 231, 93, 101, 92, 251, 163, 179, 219, 24, 81, 111]</pre>
<p class="calibre2">And here is one on the client side:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --example client</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/examples/client`<br class="title-page-name"/>Received: Input { value: Slice { bytes: [83, 44, 93, 28, 132, 238, 70, 152, 163, 73, 185, 146, 142, 5, 172, 255, 219, 52, 51, 151, 99, 134, 35, 98, 154, 192, 210, 137, 141, 167, 60, 67] } }<br class="title-page-name"/>Generated: [184, 9, 123, 15, 139, 191, 170, 9, 133, 143, 81, 45, 254, 15, 234, 12, 223, 57, 131, 145, 127, 231, 93, 101, 92, 251, 163, 179, 219, 24, 81, 111]</pre>
<p class="calibre2">Note that the generated key is the same for both the server and the client, which is what we expect.</p>
<div class="packt_infobox">At the time of writing, the ring crate does not work on the latest nightly. To make it work, run these in the project directory:<br class="calibre22"/>
<kbd class="calibre31"><strong class="calibre19">$ rustup component add rustfmt-preview --toolchain nightly-2017-12-21</strong></kbd><br class="calibre22"/>
<kbd class="calibre31"><strong class="calibre19">$ rustup override set nightly-2017-12-21</strong></kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we took a quick look at securing communication over public networks. We started with an overview of certificates and how they are used for identifying servers on the web. We looked at using <kbd class="calibre11">letsencrypt</kbd> and <kbd class="calibre11">openssl</kbd> in Rust. We then moved on to securing Tokio applications using the same techniques. Finally, we took a quick look at doing key exchanges using the DH method.</p>
<p class="calibre2">The following section is the appendix; there, we will look at some extra crates and techniques that are becoming popular in the community.</p>


            </article>

            
        </section>
    </body></html>