- en: '*Chapter 11*: Further Resources and What''s Next?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked your way through this entire book, reading and writing code
    in every section, that's fantastic! I don't believe there's a better way to learn
    the material, and now you have a functioning game. In addition, you probably spent
    a lot of time debugging when you made mistakes, tweaking when you wanted to have
    fun, and puzzling over the stranger bits that weren't explained as well as I'd
    like to think. However, you might still be wondering if you really learned anything,
    or if you just copied/pasted what I had without understanding it. Don't worry
    – that's normal, and that is why we're going to do a little bit of a review.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A challenging review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter is completed, you'll have validated what you have learned,
    and I hope to see your games on the web!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a small amount of code in this chapter, found at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11).
  prefs: []
  type: TYPE_NORMAL
- en: The final version of the game is also available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly),
    and the deployed production version of the game is at [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/).
  prefs: []
  type: TYPE_NORMAL
- en: To complete the challenge, you'll need the latest version of the assets at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3JVabRg](https://bit.ly/3JVabRg)'
  prefs: []
  type: TYPE_NORMAL
- en: A challenging review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reviewing code in a book is a strange concept; after all, you can just flip
    back to the earlier chapters to review what you've learned, so why bother to reiterate
    that now? At the same time, I've taught a lot of classes, and if there's one thing
    that's consistent, it's that sometimes smart students sit quietly, listen, nod,
    and then leave the classroom without understanding anything that you've just said.
    The only way to get an understanding is to take the knowledge we've practiced
    so far and build something upon it. Fortunately, we have just the thing.
  prefs: []
  type: TYPE_NORMAL
- en: What happened to the dog?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing
    Sprites*, we did a quick game design session where we described how our little
    **Red Hat Boy** (**RHB**) would be chasing his dog, who was startled by a cat.
    Yet, in the proceeding nine chapters, there has been no sign of the dog. Simply
    put, adding the dog, and a cat, requires very little that you don''t already know
    how to do and would have been redundant. Adding them will be a great way to reinforce
    what you''ve done and perhaps learn a new trick or two along the way. To add the
    dog will require a few steps, intentionally outlined here at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the dog sprite sheet into the game: You''ll need to take the sprite sheet,
    found in the `sprite_sheets` folder in the assets with the name `dog_sheet`. That''s
    the dog in his running animation, ready to be put into place. Look at [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, to remind
    yourself how that works.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a dog `struct`: There will need to be a dog `struct` in the game as one
    of the many game objects. It will look similar to the `RedHatBoy` object, which,
    as you''ve probably guessed, means you are likely to need a state machine, as
    we covered in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*. What would you use a state machine for? To make
    sure that the dog goes to the right at the start of the game, only to have him
    turn around and run back to RHB when RHB crashes. You would have states for running
    right and running left. The dog should also hold still right at the beginning,
    making sure to only take off after a moment, after which RHB gives chase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the `WalkTheDogStateMachine`: For the dog to hold still, and for RHP
    to ignore user commands, you''re going to need to extend `WalkTheDogStateMachine`
    beyond the `Ready` state. We covered all of this in [*Chapter 8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185),
    *Adding a UI*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, that's a simple way to add the dog, but this being a video game,
    you're only limited by your imagination. Probably the simplest thing to do would
    be to have the dog run off screen, and then run back after RHB falls over. You
    can also keep the dog on screen and have him safely navigate the platforms the
    same way that the player attempts to. That will mean a few more changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add hints to the endless runner: In [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139),
    *Creating an Endless Runner*, we created segments of the game based on where the
    player was and a random value. Each segment can also have "hints" for the dog,
    so it knows when to jump to get around the various obstacles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the dog barks: As a dog owner, there''s one thing I know about them
    – they are not *silent*. Our dog should make noise, such as barking, using the
    same technology we covered in [*Chapter 7*](B17151_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Sound Effects and Music*. You can also add some running sound effects, as well
    as a crash when the user fails to get by a platform or hits a rock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keeping score: The game doesn''t really keep score, and it could. It uses a
    time-based model, racking up points the longer the player stays alive and adding
    bonuses every time the player completes a jump on a platform or slides under a
    box. There are a ton of choices. You''ll keep that score in the `Game` object
    we initially implemented in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, and display it using the same technology we used in [*Chapter
    8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185), *Adding a UI*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using slide: The tiles sprite sheet has a lot more graphics than just the little
    islands and the rock we''ve used so far. We''ve also got a slide animation, but
    we don''t have anything short enough to slide under. Using the techniques from
    [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating an Endless
    Runner*, set up a segment that the player can slide under.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a cliché, but the limits are really your imagination. Years ago, I taught
    a workshop on HTML5 game development where I provided the students with an *Asteroids*
    clone to start with. One of them returned the next week with a Mario-like platformer!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that each chapter of this book is reachable from a Git tag at the repository
    [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly).
    In addition, the main branch contains the entire game, including my solutions
    to these challenges as they are completed. If you purchased this book early enough,
    you can even see me work on them live at [www.twitch.tv/paytonrules](http://www.twitch.tv/paytonrules).
  prefs: []
  type: TYPE_NORMAL
- en: Further resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After working through this game and completing some of the challenges that I
    just mentioned, maybe you want to go even bigger with your next game. I hope you
    do. You can add particle effects, explosions, or an online scorekeeping system.
    You can also use this framework as the start of a completely original game. You
    can also decide to use this game as an introduction and start a completely new
    game of your own using a completely different framework. This section is meant
    to show you just a few of the options available to you now if you want to keep
    making games, especially with Rust and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This entire game has been written using Rust as our language of choice, effectively
    discarding the entire JavaScript ecosystem. That's been a deliberate choice, but
    it's not the only one. We could also have called into a Rust Wasm library from
    an existing JavaScript framework or could have used `wasm-bindgen` to enable calling
    out to a JavaScript library or framework from Rust code. The first is more practical,
    and a great way to introduce Rust into an existing JavaScript project. The second
    one is more fun, so naturally, we'll be taking a brief peek at that one, with
    an example written using PixiJS.
  prefs: []
  type: TYPE_NORMAL
- en: PixiJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PixiJS** ([https://pixijs.com/](https://pixijs.com/)) is a popular and productive
    JavaScript framework for making games and visualizations in JavaScript. It has
    a Canvas and WebGL-backed renderer, and it''s a great way to get high-performance
    2D graphics without writing WebGL shaders yourself. It supports a ton of cool
    features and is a lot faster than using the Canvas as we did in our game. It has
    screenshots like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)](img/Figure_11.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also a lot more complicated than our engine, which is one reason why
    this book does not use it, but it''s great to try on your *next* game. To use
    JavaScript libraries from Rust code, you need to import functions using the `wasm-bindgen`
    library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I've hidden the `use` declarations, but this is a version of `lib.rs` from our
    game that just uses PixiJS to render a static screen. It's not much fun yet, but
    it's enough to demonstrate how, using the `wasm_bindgen` macro and the `extern
    "C" struct`, you can import any JavaScript functions into your Rust library that
    you may want to use. This allows you to use arbitrary JavaScript code in your
    Rust program, with a little bit of glue code to wire the parts together. In fact,
    this is exactly how `web_sys`, which we've been using all over the place, works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use all that Pixi code, you''ll need to add a reference to the
    `pixi.js` JavaScript library, and a quick and dirty way to do this is to add the
    following to `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a professional deployment environment, you'd probably want to use WebPack
    to bundle the JavaScript with your own source code, but this works for now. I've
    also removed our canvas element from the HTML because Pixi provides its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Rust code, I was able to import the `PIXI.Application`, `PIXI.Container`,
    and `PIXI.Sprite` types from `pixi.js`, and I''ve also pulled in quite a few functions
    associated with them. This allowed me to use them in `main_js`, just like native
    Rust code. The example here is not professional, using `unwrap` all over the place,
    but it successfully creates a PixiJS application and then creates `Sprite` from
    a file we already had in our game. Then, it adds it to `stage`, which is a PixiJS
    concept that you can think of as the canvas. This code leads to a screen that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – A rock'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – A rock
  prefs: []
  type: TYPE_NORMAL
- en: Okay, it doesn't look like much, but the point is that you can use PixiJS in
    a Rust project by declaring the types you need using `wasm-bindgen`. We won't
    be covering all that here, but the docs for `wasm-bindgen` are extremely thorough
    at [https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, maybe you don't like PixiJS, and you want to use **PhaserJS**;
    the same principle applies! You can use any of the great frameworks available
    to JavaScript programmers for game development, such as **Three.JS** and **Babylon3D**,
    provided you can include them in your WebAssembly project. But what if you don't
    want to use JavaScript at all but still want to run on the web?
  prefs: []
  type: TYPE_NORMAL
- en: Macroquad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Macroquad** ([https://macroquad.rs/](https://macroquad.rs/)) is one of many
    game development libraries written in Rust. The authors refer to it as a "**game
    library**", which is a way of saying it''s not as fully featured as an entire
    framework, but it''s more featured than just writing to the HTML Canvas element,
    as we did in our game. It supports WebAssembly out of the box, without writing
    any JavaScript. An example of the code in Macroquad is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This very simple example will compile and run on the web simply by specifying
    the target with `cargo build --target wasm32-unknown-unknown` – no JavaScript,
    no problem. Macroquad is great, but it's not really a full engine. So, what if
    you want that experience?
  prefs: []
  type: TYPE_NORMAL
- en: Bevy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another choice with more features is **Bevy** ([https://bevyengine.org/](https://bevyengine.org/)),
    which has been extremely popular since its initial announcement and supports WebAssembly.
    Its "Hello World" is very different from the Macroquad version and resembles the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The most unique part of this system is the `add_system` function, which allows
    you to add "systems" to the Bevy engine. Bevy uses a modern Entity Component System
    for its development, which is meant to aid in structuring your program as well
    as performance. It''s gaining popularity extremely rapidly and moving faster than
    its documentation can keep up with. Currently, if you''re looking to learn how
    to use Bevy for 2D and 3D games, your best bet is to get involved with the community
    here: [https://bevyengine.org/community/](https://bevyengine.org/community/).
    If you do, you''ll be rewarded, as Bevy is a very advanced engine, but it doesn''t
    have an editor such as Unity3D or Unreal. If you''re looking for that, fortunately,
    you have an excellent option.'
  prefs: []
  type: TYPE_NORMAL
- en: Godot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'My first experiences with game development in Rust were using the Godot game
    engine ([https://godotengine.org](https://godotengine.org)). Godot is a truly
    free and open source engine that''s popular with hobbyists and professional game
    developers alike. It comes with its own built-in language, GDScript, out of the
    box but is also able to use Rust through its GDNative wrappers. Originally devised
    to allow the use of C and C++, GDNative works extremely well with Rust. It has
    a thriving community of its own, and you can download it here: [https://godot-rust.github.io](https://godot-rust.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Godot will mean getting a fully featured 2D and 3D engine that''s capable
    of competing with Unity3D at its best. It''s possible that the entire time you
    were reading this book, you wanted to see a proper commercial game engine such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – A Godot game engine](img/Figure_11.03_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – A Godot game engine
  prefs: []
  type: TYPE_NORMAL
- en: If so, Godot is the one for you. To see an example Godot program written in
    Rust, you can see the one I wrote at [https://github.com/paytonrules/Aircombat](https://github.com/paytonrules/Aircombat).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The website [https://arewegameyet.rs](https://arewegameyet.rs) asks the question,
    "*Is Rust ready for game development?*" and answers with, "*Almost.*" Respectfully,
    because it's a really cool site, I disagree. We have all of the tools that JavaScript
    developers had a few years ago, with all the advantages of an excellent type system
    and Wasm. We have far more tools than developers have had for most of game development
    history, and while we may not have our Unity or Unreal yet, we have everything
    we need to *build our own*. So, go out there, build your own games, extend the
    engine, and have fun! I hope I hear from you with far better games than this one.
    If you need help, want to show off your games, or just want to hang out with like-minded
    people, you can find me on the Rustacean Station Discord at [https://discord.gg/cHc3Gyc](https://discord.gg/cHc3Gyc).
    You can always find me as `@paytonrules` on Twitter, and I'd be really excited
    to hear from you.
  prefs: []
  type: TYPE_NORMAL
