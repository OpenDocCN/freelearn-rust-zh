- en: '*Chapter 11*: Further Resources and What''s Next?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：更多资源和下一步是什么？'
- en: If you have worked your way through this entire book, reading and writing code
    in every section, that's fantastic! I don't believe there's a better way to learn
    the material, and now you have a functioning game. In addition, you probably spent
    a lot of time debugging when you made mistakes, tweaking when you wanted to have
    fun, and puzzling over the stranger bits that weren't explained as well as I'd
    like to think. However, you might still be wondering if you really learned anything,
    or if you just copied/pasted what I had without understanding it. Don't worry
    – that's normal, and that is why we're going to do a little bit of a review.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经通读了这本书的每一部分，阅读并编写了代码，那真是太棒了！我相信没有更好的学习方法，现在你有一个可以运行的游戏。此外，你可能花了大量时间在犯错时调试，在想要娱乐时调整，对那些没有解释得很好的陌生部分感到困惑。然而，你可能还在想你是否真的学到了什么，或者你只是复制/粘贴了我所写的内容而没有理解。不用担心——这是正常的，这就是为什么我们要进行一点回顾。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A challenging review
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有挑战性的回顾
- en: Further resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多资源
- en: After this chapter is completed, you'll have validated what you have learned,
    and I hope to see your games on the web!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成后，你将验证你所学的知识，我希望能在网上看到你的游戏！
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There is a small amount of code in this chapter, found at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含少量代码，可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11)找到。
- en: The final version of the game is also available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly),
    and the deployed production version of the game is at [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的最终版本也可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly)找到，游戏的部署生产版本在[https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/)。
- en: To complete the challenge, you'll need the latest version of the assets at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个挑战，你需要[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)中资产的最新版本。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3JVabRg](https://bit.ly/3JVabRg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3JVabRg](https://bit.ly/3JVabRg)
- en: A challenging review
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个具有挑战性的回顾
- en: Reviewing code in a book is a strange concept; after all, you can just flip
    back to the earlier chapters to review what you've learned, so why bother to reiterate
    that now? At the same time, I've taught a lot of classes, and if there's one thing
    that's consistent, it's that sometimes smart students sit quietly, listen, nod,
    and then leave the classroom without understanding anything that you've just said.
    The only way to get an understanding is to take the knowledge we've practiced
    so far and build something upon it. Fortunately, we have just the thing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中审查代码是一个奇怪的概念；毕竟，你可以直接翻到前面的章节来回顾你学到的知识，那么现在为什么要重复呢？同时，我教过很多课程，如果有一件事是一致的，那就是有时候聪明的学生静静地坐着，倾听，点头，然后离开教室，对你说的话一无所知。唯一获得理解的方法是将我们迄今为止所练习的知识应用于构建。幸运的是，我们正好有这个工具。
- en: What happened to the dog?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 狗发生了什么事？
- en: 'In [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing
    Sprites*, we did a quick game design session where we described how our little
    **Red Hat Boy** (**RHB**) would be chasing his dog, who was startled by a cat.
    Yet, in the proceeding nine chapters, there has been no sign of the dog. Simply
    put, adding the dog, and a cat, requires very little that you don''t already know
    how to do and would have been redundant. Adding them will be a great way to reinforce
    what you''ve done and perhaps learn a new trick or two along the way. To add the
    dog will require a few steps, intentionally outlined here at a high level:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*中，我们进行了一次快速的游戏设计会议，描述了我们的小**红帽男孩**（**RHB**）是如何追逐他的狗，而那只狗被一只猫吓到了。然而，在接下来的九个章节中，狗的身影却从未出现。简单来说，添加狗和猫所需的知识点并不多，而且如果添加它们可能会显得多余。添加它们将是一个很好的方式来巩固你所学的知识，也许还能在学习过程中学到一些新技巧。为了添加狗，需要以下几个步骤，这里故意以高层次概述：
- en: 'Get the dog sprite sheet into the game: You''ll need to take the sprite sheet,
    found in the `sprite_sheets` folder in the assets with the name `dog_sheet`. That''s
    the dog in his running animation, ready to be put into place. Look at [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, to remind
    yourself how that works.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将狗精灵图集放入游戏：你需要将精灵图集放入游戏，这个图集位于`sprite_sheets`文件夹中的`assets`目录，名为`dog_sheet`。这是狗在奔跑动画中的样子，准备好被放置到游戏中。查看[*第二章*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038)，*绘制精灵*，以提醒自己这是如何工作的。
- en: 'Add a dog `struct`: There will need to be a dog `struct` in the game as one
    of the many game objects. It will look similar to the `RedHatBoy` object, which,
    as you''ve probably guessed, means you are likely to need a state machine, as
    we covered in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*. What would you use a state machine for? To make
    sure that the dog goes to the right at the start of the game, only to have him
    turn around and run back to RHB when RHB crashes. You would have states for running
    right and running left. The dog should also hold still right at the beginning,
    making sure to only take off after a moment, after which RHB gives chase.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 添加狗`struct`：游戏中需要有一个狗`struct`作为众多游戏对象之一。它看起来会与`RedHatBoy`对象相似，正如你可能猜到的，这意味着你可能需要使用状态机，正如我们在[*第四章*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093)，*使用状态机管理动画*中提到的。你会用状态机做什么？确保狗在游戏开始时向右走，当RHB发生碰撞时，它会转身跑回RHB。你需要为向右跑和向左跑设置状态。狗也应该在开始时保持静止，确保在RHB追逐之后的一段时间内才开始奔跑。
- en: 'Extend the `WalkTheDogStateMachine`: For the dog to hold still, and for RHP
    to ignore user commands, you''re going to need to extend `WalkTheDogStateMachine`
    beyond the `Ready` state. We covered all of this in [*Chapter 8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185),
    *Adding a UI*.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`WalkTheDogStateMachine`：为了让狗保持静止，以及让RHP忽略用户指令，你需要将`WalkTheDogStateMachine`扩展到`Ready`状态之外。我们已经在[*第八章*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185)，*添加用户界面*中涵盖了所有这些内容。
- en: Of course, that's a simple way to add the dog, but this being a video game,
    you're only limited by your imagination. Probably the simplest thing to do would
    be to have the dog run off screen, and then run back after RHB falls over. You
    can also keep the dog on screen and have him safely navigate the platforms the
    same way that the player attempts to. That will mean a few more changes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一种添加狗的简单方法，但作为一个视频游戏，你的想象力是唯一的限制。可能最简单的事情就是让狗跑出屏幕，然后在RHB倒下后跑回来。你也可以让狗保持在屏幕上，并像玩家尝试的那样安全地导航平台。这将意味着需要更多的更改。
- en: 'Add hints to the endless runner: In [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139),
    *Creating an Endless Runner*, we created segments of the game based on where the
    player was and a random value. Each segment can also have "hints" for the dog,
    so it knows when to jump to get around the various obstacles.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向无尽跑酷游戏添加提示：在[*第六章*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139)，*创建无尽跑酷*中，我们根据玩家的位置和随机值创建了游戏的部分。每个部分也可以为狗添加“提示”，这样狗就知道何时跳跃以绕过各种障碍。
- en: 'Make sure the dog barks: As a dog owner, there''s one thing I know about them
    – they are not *silent*. Our dog should make noise, such as barking, using the
    same technology we covered in [*Chapter 7*](B17151_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Sound Effects and Music*. You can also add some running sound effects, as well
    as a crash when the user fails to get by a platform or hits a rock.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保狗会吠叫：作为一个狗的主人，我知道它们的一个特点——它们不是*安静的*。我们的狗应该发出声音，比如吠叫，使用我们在[*第7章*](B17151_07_Final_PG_ePub.xhtml#_idTextAnchor166)中提到的相同技术，*声音效果和音乐*。你还可以添加一些跑步声音效果，以及当用户未能通过平台或撞到岩石时的碰撞声。
- en: 'Keeping score: The game doesn''t really keep score, and it could. It uses a
    time-based model, racking up points the longer the player stays alive and adding
    bonuses every time the player completes a jump on a platform or slides under a
    box. There are a ton of choices. You''ll keep that score in the `Game` object
    we initially implemented in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, and display it using the same technology we used in [*Chapter
    8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185), *Adding a UI*.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记分：这个游戏实际上并没有记分，但它可以。它使用基于时间的模型，玩家存活时间越长，得分就越高，每次玩家在平台上完成跳跃或滑行穿过箱子时，都会增加奖励。有大量的选择。你将在我们最初在[*第3章*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)中实现的`Game`对象中保持这个分数，*创建游戏循环*，并使用我们在[*第8章*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185)中使用的相同技术显示它，*添加用户界面*。
- en: 'Using slide: The tiles sprite sheet has a lot more graphics than just the little
    islands and the rock we''ve used so far. We''ve also got a slide animation, but
    we don''t have anything short enough to slide under. Using the techniques from
    [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating an Endless
    Runner*, set up a segment that the player can slide under.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑行：除了我们迄今为止使用的那些小岛和岩石之外，瓦片精灵图集还有更多的图形。我们还有一个滑行动画，但我们没有足够短的东西可以滑行。使用[*第6章*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139)中提到的技术，*创建无限跑酷游戏*，设置一个玩家可以滑行的段落。
- en: It's a cliché, but the limits are really your imagination. Years ago, I taught
    a workshop on HTML5 game development where I provided the students with an *Asteroids*
    clone to start with. One of them returned the next week with a Mario-like platformer!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个陈词滥调，但限制真的是你的想象力。多年前，我教了一个HTML5游戏开发的研讨会，我给学生提供了一个*Asteroids*克隆版作为起点。其中一个人下周就带着一个类似马里奥的平台游戏回来了！
- en: Tip
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that each chapter of this book is reachable from a Git tag at the repository
    [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly).
    In addition, the main branch contains the entire game, including my solutions
    to these challenges as they are completed. If you purchased this book early enough,
    you can even see me work on them live at [www.twitch.tv/paytonrules](http://www.twitch.tv/paytonrules).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这本书的每一章都可以从仓库的Git标签[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly)中访问。此外，主分支包含整个游戏，包括我完成这些挑战时的解决方案。如果你这本书买得早，你甚至可以看到我现场工作在[www.twitch.tv/paytonrules](http://www.twitch.tv/paytonrules)。
- en: Further resources
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: After working through this game and completing some of the challenges that I
    just mentioned, maybe you want to go even bigger with your next game. I hope you
    do. You can add particle effects, explosions, or an online scorekeeping system.
    You can also use this framework as the start of a completely original game. You
    can also decide to use this game as an introduction and start a completely new
    game of your own using a completely different framework. This section is meant
    to show you just a few of the options available to you now if you want to keep
    making games, especially with Rust and WebAssembly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个游戏并完成我刚才提到的挑战之后，也许你想要在下一款游戏中做得更大。我希望你能这样做。你可以添加粒子效果、爆炸或在线记分系统。你还可以将这个框架作为一款完全原创游戏的起点。你也可以决定使用这个游戏作为介绍，并使用一个完全不同的框架开始一个全新的游戏。本节旨在向你展示，如果你想要继续制作游戏，特别是使用Rust和WebAssembly，你现在有哪些选项可用。
- en: Using JavaScript libraries
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript库
- en: This entire game has been written using Rust as our language of choice, effectively
    discarding the entire JavaScript ecosystem. That's been a deliberate choice, but
    it's not the only one. We could also have called into a Rust Wasm library from
    an existing JavaScript framework or could have used `wasm-bindgen` to enable calling
    out to a JavaScript library or framework from Rust code. The first is more practical,
    and a great way to introduce Rust into an existing JavaScript project. The second
    one is more fun, so naturally, we'll be taking a brief peek at that one, with
    an example written using PixiJS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏都是使用Rust作为我们的首选语言编写的，有效地摒弃了整个JavaScript生态系统。这是一个有意的选择，但并非唯一的选择。我们也可以从现有的JavaScript框架调用Rust
    Wasm库，或者可以使用`wasm-bindgen`从Rust代码中调用JavaScript库或框架。第一个方法更实用，是向现有JavaScript项目引入Rust的绝佳方式。第二个方法更有趣，所以自然地，我们将简要地看看这个例子，使用PixiJS编写的示例。
- en: PixiJS
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PixiJS
- en: '**PixiJS** ([https://pixijs.com/](https://pixijs.com/)) is a popular and productive
    JavaScript framework for making games and visualizations in JavaScript. It has
    a Canvas and WebGL-backed renderer, and it''s a great way to get high-performance
    2D graphics without writing WebGL shaders yourself. It supports a ton of cool
    features and is a lot faster than using the Canvas as we did in our game. It has
    screenshots like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**PixiJS** ([https://pixijs.com/](https://pixijs.com/)) 是一个流行的、高效的JavaScript框架，用于在JavaScript中制作游戏和可视化。它有一个基于Canvas和WebGL的渲染器，是获得高性能2D图形而不必自己编写WebGL着色器的好方法。它支持众多酷炫的功能，比我们游戏中使用Canvas要快得多。它有像这样的截图：'
- en: '![Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)](img/Figure_11.01_B17151.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 一个纹理网格](https://bit.ly/3JkhbXw)(img/Figure_11.01_B17151.jpg)'
- en: Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 一个纹理网格 (https://bit.ly/3JkhbXw)
- en: 'It is also a lot more complicated than our engine, which is one reason why
    this book does not use it, but it''s great to try on your *next* game. To use
    JavaScript libraries from Rust code, you need to import functions using the `wasm-bindgen`
    library, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它也比我们的引擎复杂得多，这也是本书没有使用它的一个原因，但它在你的*下一个*游戏中尝试是非常棒的。要从Rust代码中使用JavaScript库，你需要使用`wasm-bindgen`库导入函数，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I've hidden the `use` declarations, but this is a version of `lib.rs` from our
    game that just uses PixiJS to render a static screen. It's not much fun yet, but
    it's enough to demonstrate how, using the `wasm_bindgen` macro and the `extern
    "C" struct`, you can import any JavaScript functions into your Rust library that
    you may want to use. This allows you to use arbitrary JavaScript code in your
    Rust program, with a little bit of glue code to wire the parts together. In fact,
    this is exactly how `web_sys`, which we've been using all over the place, works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经隐藏了`use`声明，但这是从我们的游戏中使用PixiJS渲染静态屏幕的`lib.rs`版本。现在还没有什么乐趣，但足以展示如何使用`wasm_bindgen`宏和`extern
    "C" struct`将任何JavaScript函数导入到你的Rust库中，你可能想使用。这允许你在Rust程序中使用任意JavaScript代码，只需要一点粘合代码来连接各个部分。实际上，这正是`web_sys`的工作方式，我们一直在各处使用它。
- en: 'In order to use all that Pixi code, you''ll need to add a reference to the
    `pixi.js` JavaScript library, and a quick and dirty way to do this is to add the
    following to `index.html`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用所有这些Pixi代码，你需要添加对`pixi.js` JavaScript库的引用，而快速且简单的方法是将以下内容添加到`index.html`中：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In a professional deployment environment, you'd probably want to use WebPack
    to bundle the JavaScript with your own source code, but this works for now. I've
    also removed our canvas element from the HTML because Pixi provides its own.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个专业的部署环境中，你可能想使用WebPack将JavaScript与你的源代码捆绑在一起，但现在这就可以了。我也已经从HTML中移除了我们的canvas元素，因为Pixi提供了自己的。
- en: 'In the Rust code, I was able to import the `PIXI.Application`, `PIXI.Container`,
    and `PIXI.Sprite` types from `pixi.js`, and I''ve also pulled in quite a few functions
    associated with them. This allowed me to use them in `main_js`, just like native
    Rust code. The example here is not professional, using `unwrap` all over the place,
    but it successfully creates a PixiJS application and then creates `Sprite` from
    a file we already had in our game. Then, it adds it to `stage`, which is a PixiJS
    concept that you can think of as the canvas. This code leads to a screen that
    looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 代码中，我能够从 `pixi.js` 中导入 `PIXI.Application`、`PIXI.Container` 和 `PIXI.Sprite`
    类型，并且我还引入了与它们相关的一些函数。这使得我可以在 `main_js` 中使用它们，就像使用原生的 Rust 代码一样。这里的示例并不专业，到处都在使用
    `unwrap`，但它成功地创建了一个 PixiJS 应用程序，并从我们游戏中已有的文件中创建了一个 `Sprite`。然后，它将其添加到 `stage`
    中，这是 PixiJS 的一个概念，你可以将其视为画布。这段代码导致了一个看起来像这样的屏幕：
- en: '![Figure 11.2 – A rock'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 一块石头'
- en: '](img/Figure_11.02_B17151.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.02_B17151](img/Figure_11.02_B17151.jpg)'
- en: Figure 11.2 – A rock
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 一块石头
- en: Okay, it doesn't look like much, but the point is that you can use PixiJS in
    a Rust project by declaring the types you need using `wasm-bindgen`. We won't
    be covering all that here, but the docs for `wasm-bindgen` are extremely thorough
    at [https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看起来并不怎么样，但重点是你可以通过使用 `wasm-bindgen` 声明你需要的类型，在 Rust 项目中使用 PixiJS。我们在这里不会涵盖所有内容，但
    `wasm-bindgen` 的文档在 [https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html)
    上非常详尽。
- en: More importantly, maybe you don't like PixiJS, and you want to use **PhaserJS**;
    the same principle applies! You can use any of the great frameworks available
    to JavaScript programmers for game development, such as **Three.JS** and **Babylon3D**,
    provided you can include them in your WebAssembly project. But what if you don't
    want to use JavaScript at all but still want to run on the web?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，也许你不喜欢 PixiJS，而想使用 **PhaserJS**；同样的原则适用！你可以使用任何 JavaScript 程序员可用的优秀框架进行游戏开发，例如
    **Three.JS** 和 **Babylon3D**，只要你能在你的 WebAssembly 项目中包含它们。但如果你根本不想使用 JavaScript，但仍想在网络上运行呢？
- en: Macroquad
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Macroquad
- en: '**Macroquad** ([https://macroquad.rs/](https://macroquad.rs/)) is one of many
    game development libraries written in Rust. The authors refer to it as a "**game
    library**", which is a way of saying it''s not as fully featured as an entire
    framework, but it''s more featured than just writing to the HTML Canvas element,
    as we did in our game. It supports WebAssembly out of the box, without writing
    any JavaScript. An example of the code in Macroquad is shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Macroquad** ([https://macroquad.rs/](https://macroquad.rs/)) 是用 Rust 编写的许多游戏开发库之一。作者将其称为“**游戏库**”，这意味着它并不像整个框架那样功能全面，但它比仅仅编写
    HTML Canvas 元素的功能要多，就像我们在游戏中做的那样。它支持开箱即用的 WebAssembly，无需编写任何 JavaScript。以下是一个
    Macroquad 中代码的示例：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This very simple example will compile and run on the web simply by specifying
    the target with `cargo build --target wasm32-unknown-unknown` – no JavaScript,
    no problem. Macroquad is great, but it's not really a full engine. So, what if
    you want that experience?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的示例只需通过指定目标 `cargo build --target wasm32-unknown-unknown` 就可以在网络上编译和运行——没有
    JavaScript，没问题。Macroquad 很好，但它并不是一个完整的引擎。那么，如果你想要那种体验呢？
- en: Bevy
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bevy
- en: 'Another choice with more features is **Bevy** ([https://bevyengine.org/](https://bevyengine.org/)),
    which has been extremely popular since its initial announcement and supports WebAssembly.
    Its "Hello World" is very different from the Macroquad version and resembles the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具有更多功能的选项是 **Bevy** ([https://bevyengine.org/](https://bevyengine.org/))，自从其最初发布以来就非常受欢迎，并支持
    WebAssembly。它的“Hello World”与 Macroquad 版本非常不同，如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The most unique part of this system is the `add_system` function, which allows
    you to add "systems" to the Bevy engine. Bevy uses a modern Entity Component System
    for its development, which is meant to aid in structuring your program as well
    as performance. It''s gaining popularity extremely rapidly and moving faster than
    its documentation can keep up with. Currently, if you''re looking to learn how
    to use Bevy for 2D and 3D games, your best bet is to get involved with the community
    here: [https://bevyengine.org/community/](https://bevyengine.org/community/).
    If you do, you''ll be rewarded, as Bevy is a very advanced engine, but it doesn''t
    have an editor such as Unity3D or Unreal. If you''re looking for that, fortunately,
    you have an excellent option.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统最独特的地方是 `add_system` 函数，它允许你向 Bevy 引擎添加“系统”。Bevy 使用现代的实体组件系统进行开发，旨在帮助您构建程序结构以及提高性能。它正以极快的速度迅速流行起来，并且发展速度超过了其文档的更新速度。目前，如果你想要学习如何使用
    Bevy 进行 2D 和 3D 游戏开发，你最好的选择是加入这里的社区：[https://bevyengine.org/community/](https://bevyengine.org/community/)。如果你这样做，你会得到回报，因为
    Bevy 是一个非常先进的引擎，但它没有像 Unity3D 或 Unreal 那样的编辑器。如果你在寻找这样的编辑器，幸运的是，你有一个非常好的选择。
- en: Godot
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Godot
- en: 'My first experiences with game development in Rust were using the Godot game
    engine ([https://godotengine.org](https://godotengine.org)). Godot is a truly
    free and open source engine that''s popular with hobbyists and professional game
    developers alike. It comes with its own built-in language, GDScript, out of the
    box but is also able to use Rust through its GDNative wrappers. Originally devised
    to allow the use of C and C++, GDNative works extremely well with Rust. It has
    a thriving community of its own, and you can download it here: [https://godot-rust.github.io](https://godot-rust.github.io).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次在 Rust 中进行游戏开发是使用 Godot 游戏引擎 ([https://godotengine.org](https://godotengine.org))。Godot
    是一个真正免费且开源的引擎，受到业余爱好者和专业游戏开发者的喜爱。它自带内置语言 GDScript，无需额外安装，但也能够通过 GDNative 包装器使用
    Rust。GDNative 最初是为了允许使用 C 和 C++ 而设计的，它与 Rust 的配合非常出色。它拥有自己繁荣的社区，你可以在以下链接下载它：[https://godot-rust.github.io](https://godot-rust.github.io)。
- en: 'Using Godot will mean getting a fully featured 2D and 3D engine that''s capable
    of competing with Unity3D at its best. It''s possible that the entire time you
    were reading this book, you wanted to see a proper commercial game engine such
    as this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Godot 将意味着获得一个功能齐全的 2D 和 3D 引擎，其性能可以与 Unity3D 的最佳表现相媲美。在你阅读这本书的整个过程中，你可能一直想看到这样一个合适的商业游戏引擎：
- en: '![Figure 11.3 – A Godot game engine](img/Figure_11.03_B17151.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Godot 游戏引擎](img/Figure_11.03_B17151.jpg)'
- en: Figure 11.3 – A Godot game engine
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Godot 游戏引擎
- en: If so, Godot is the one for you. To see an example Godot program written in
    Rust, you can see the one I wrote at [https://github.com/paytonrules/Aircombat](https://github.com/paytonrules/Aircombat).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，Godot 就是你的选择。要查看用 Rust 编写的示例 Godot 程序，你可以查看我在 [https://github.com/paytonrules/Aircombat](https://github.com/paytonrules/Aircombat)
    上写的程序。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The website [https://arewegameyet.rs](https://arewegameyet.rs) asks the question,
    "*Is Rust ready for game development?*" and answers with, "*Almost.*" Respectfully,
    because it's a really cool site, I disagree. We have all of the tools that JavaScript
    developers had a few years ago, with all the advantages of an excellent type system
    and Wasm. We have far more tools than developers have had for most of game development
    history, and while we may not have our Unity or Unreal yet, we have everything
    we need to *build our own*. So, go out there, build your own games, extend the
    engine, and have fun! I hope I hear from you with far better games than this one.
    If you need help, want to show off your games, or just want to hang out with like-minded
    people, you can find me on the Rustacean Station Discord at [https://discord.gg/cHc3Gyc](https://discord.gg/cHc3Gyc).
    You can always find me as `@paytonrules` on Twitter, and I'd be really excited
    to hear from you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网站 [https://arewegameyet.rs](https://arewegameyet.rs) 提出了问题，“*Rust 是否准备好进行游戏开发？*”，并以“*几乎准备好了*”作为回答。尊重地说，因为这是一个非常酷的网站，我不同意。我们拥有
    JavaScript 开发者在几年前就拥有的所有工具，以及优秀的类型系统和 Wasm 的所有优势。我们拥有的工具比游戏开发历史上大多数开发者拥有的工具都要多，虽然我们可能还没有
    Unity 或 Unreal，但我们拥有构建我们自己的所有东西。所以，出去那里，创建你自己的游戏，扩展引擎，享受乐趣！我希望听到你比这个更好的游戏。如果你需要帮助，想要展示你的游戏，或者只是想和志同道合的人一起消磨时光，你可以在
    Rustacean Station Discord 上找到我 [https://discord.gg/cHc3Gyc](https://discord.gg/cHc3Gyc)。你总是可以在
    Twitter 上找到我作为 `@paytonrules`，我非常期待收到你的来信。
