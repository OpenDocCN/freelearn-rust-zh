- en: '*Chapter 11*: Further Resources and What''s Next?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：更多资源和下一步是什么？'
- en: If you have worked your way through this entire book, reading and writing code
    in every section, that's fantastic! I don't believe there's a better way to learn
    the material, and now you have a functioning game. In addition, you probably spent
    a lot of time debugging when you made mistakes, tweaking when you wanted to have
    fun, and puzzling over the stranger bits that weren't explained as well as I'd
    like to think. However, you might still be wondering if you really learned anything,
    or if you just copied/pasted what I had without understanding it. Don't worry
    – that's normal, and that is why we're going to do a little bit of a review.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经通读了这本书的每一部分，阅读并编写了代码，那真是太棒了！我相信没有更好的学习方法，现在你有一个可以运行的游戏。此外，你可能花了大量时间在犯错时调试，在想要娱乐时调整，对那些没有解释得很好的陌生部分感到困惑。然而，你可能还在想你是否真的学到了什么，或者你只是复制/粘贴了我所写的内容而没有理解。不用担心——这是正常的，这就是为什么我们要进行一点回顾。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A challenging review
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有挑战性的回顾
- en: Further resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多资源
- en: After this chapter is completed, you'll have validated what you have learned,
    and I hope to see your games on the web!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成后，你将验证你所学的知识，我希望能在网上看到你的游戏！
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There is a small amount of code in this chapter, found at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含少量代码，可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11)找到。
- en: The final version of the game is also available at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly),
    and the deployed production version of the game is at [https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的最终版本也可在[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly)找到，游戏的部署生产版本在[https://rust-games-webassembly.netlify.app/](https://rust-games-webassembly.netlify.app/)。
- en: To complete the challenge, you'll need the latest version of the assets at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个挑战，你需要[https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets)中资产的最新版本。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3JVabRg](https://bit.ly/3JVabRg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3JVabRg](https://bit.ly/3JVabRg)
- en: A challenging review
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个具有挑战性的回顾
- en: Reviewing code in a book is a strange concept; after all, you can just flip
    back to the earlier chapters to review what you've learned, so why bother to reiterate
    that now? At the same time, I've taught a lot of classes, and if there's one thing
    that's consistent, it's that sometimes smart students sit quietly, listen, nod,
    and then leave the classroom without understanding anything that you've just said.
    The only way to get an understanding is to take the knowledge we've practiced
    so far and build something upon it. Fortunately, we have just the thing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中审查代码是一个奇怪的概念；毕竟，你可以直接翻到前面的章节来回顾你学到的知识，那么现在为什么要重复呢？同时，我教过很多课程，如果有一件事是一致的，那就是有时候聪明的学生静静地坐着，倾听，点头，然后离开教室，对你说的话一无所知。唯一获得理解的方法是将我们迄今为止所练习的知识应用于构建。幸运的是，我们正好有这个工具。
- en: What happened to the dog?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 狗发生了什么事？
- en: 'In [*Chapter 2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing
    Sprites*, we did a quick game design session where we described how our little
    **Red Hat Boy** (**RHB**) would be chasing his dog, who was startled by a cat.
    Yet, in the proceeding nine chapters, there has been no sign of the dog. Simply
    put, adding the dog, and a cat, requires very little that you don''t already know
    how to do and would have been redundant. Adding them will be a great way to reinforce
    what you''ve done and perhaps learn a new trick or two along the way. To add the
    dog will require a few steps, intentionally outlined here at a high level:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the dog sprite sheet into the game: You''ll need to take the sprite sheet,
    found in the `sprite_sheets` folder in the assets with the name `dog_sheet`. That''s
    the dog in his running animation, ready to be put into place. Look at [*Chapter
    2*](B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038), *Drawing Sprites*, to remind
    yourself how that works.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a dog `struct`: There will need to be a dog `struct` in the game as one
    of the many game objects. It will look similar to the `RedHatBoy` object, which,
    as you''ve probably guessed, means you are likely to need a state machine, as
    we covered in [*Chapter 4*](B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093), *Managing
    Animations with State Machines*. What would you use a state machine for? To make
    sure that the dog goes to the right at the start of the game, only to have him
    turn around and run back to RHB when RHB crashes. You would have states for running
    right and running left. The dog should also hold still right at the beginning,
    making sure to only take off after a moment, after which RHB gives chase.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the `WalkTheDogStateMachine`: For the dog to hold still, and for RHP
    to ignore user commands, you''re going to need to extend `WalkTheDogStateMachine`
    beyond the `Ready` state. We covered all of this in [*Chapter 8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185),
    *Adding a UI*.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, that's a simple way to add the dog, but this being a video game,
    you're only limited by your imagination. Probably the simplest thing to do would
    be to have the dog run off screen, and then run back after RHB falls over. You
    can also keep the dog on screen and have him safely navigate the platforms the
    same way that the player attempts to. That will mean a few more changes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Add hints to the endless runner: In [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139),
    *Creating an Endless Runner*, we created segments of the game based on where the
    player was and a random value. Each segment can also have "hints" for the dog,
    so it knows when to jump to get around the various obstacles.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the dog barks: As a dog owner, there''s one thing I know about them
    – they are not *silent*. Our dog should make noise, such as barking, using the
    same technology we covered in [*Chapter 7*](B17151_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Sound Effects and Music*. You can also add some running sound effects, as well
    as a crash when the user fails to get by a platform or hits a rock.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keeping score: The game doesn''t really keep score, and it could. It uses a
    time-based model, racking up points the longer the player stays alive and adding
    bonuses every time the player completes a jump on a platform or slides under a
    box. There are a ton of choices. You''ll keep that score in the `Game` object
    we initially implemented in [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *Creating a Game Loop*, and display it using the same technology we used in [*Chapter
    8*](B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185), *Adding a UI*.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using slide: The tiles sprite sheet has a lot more graphics than just the little
    islands and the rock we''ve used so far. We''ve also got a slide animation, but
    we don''t have anything short enough to slide under. Using the techniques from
    [*Chapter 6*](B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139), *Creating an Endless
    Runner*, set up a segment that the player can slide under.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a cliché, but the limits are really your imagination. Years ago, I taught
    a workshop on HTML5 game development where I provided the students with an *Asteroids*
    clone to start with. One of them returned the next week with a Mario-like platformer!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Remember that each chapter of this book is reachable from a Git tag at the repository
    [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly).
    In addition, the main branch contains the entire game, including my solutions
    to these challenges as they are completed. If you purchased this book early enough,
    you can even see me work on them live at [www.twitch.tv/paytonrules](http://www.twitch.tv/paytonrules).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Further resources
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After working through this game and completing some of the challenges that I
    just mentioned, maybe you want to go even bigger with your next game. I hope you
    do. You can add particle effects, explosions, or an online scorekeeping system.
    You can also use this framework as the start of a completely original game. You
    can also decide to use this game as an introduction and start a completely new
    game of your own using a completely different framework. This section is meant
    to show you just a few of the options available to you now if you want to keep
    making games, especially with Rust and WebAssembly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript libraries
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This entire game has been written using Rust as our language of choice, effectively
    discarding the entire JavaScript ecosystem. That's been a deliberate choice, but
    it's not the only one. We could also have called into a Rust Wasm library from
    an existing JavaScript framework or could have used `wasm-bindgen` to enable calling
    out to a JavaScript library or framework from Rust code. The first is more practical,
    and a great way to introduce Rust into an existing JavaScript project. The second
    one is more fun, so naturally, we'll be taking a brief peek at that one, with
    an example written using PixiJS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏都是使用Rust作为我们的首选语言编写的，有效地摒弃了整个JavaScript生态系统。这是一个有意的选择，但并非唯一的选择。我们也可以从现有的JavaScript框架调用Rust
    Wasm库，或者可以使用`wasm-bindgen`从Rust代码中调用JavaScript库或框架。第一个方法更实用，是向现有JavaScript项目引入Rust的绝佳方式。第二个方法更有趣，所以自然地，我们将简要地看看这个例子，使用PixiJS编写的示例。
- en: PixiJS
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PixiJS
- en: '**PixiJS** ([https://pixijs.com/](https://pixijs.com/)) is a popular and productive
    JavaScript framework for making games and visualizations in JavaScript. It has
    a Canvas and WebGL-backed renderer, and it''s a great way to get high-performance
    2D graphics without writing WebGL shaders yourself. It supports a ton of cool
    features and is a lot faster than using the Canvas as we did in our game. It has
    screenshots like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**PixiJS** ([https://pixijs.com/](https://pixijs.com/)) 是一个流行的、高效的JavaScript框架，用于在JavaScript中制作游戏和可视化。它有一个基于Canvas和WebGL的渲染器，是获得高性能2D图形而不必自己编写WebGL着色器的好方法。它支持众多酷炫的功能，比我们游戏中使用Canvas要快得多。它有像这样的截图：'
- en: '![Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)](img/Figure_11.01_B17151.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 一个纹理网格](https://bit.ly/3JkhbXw)(img/Figure_11.01_B17151.jpg)'
- en: Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 一个纹理网格 (https://bit.ly/3JkhbXw)
- en: 'It is also a lot more complicated than our engine, which is one reason why
    this book does not use it, but it''s great to try on your *next* game. To use
    JavaScript libraries from Rust code, you need to import functions using the `wasm-bindgen`
    library, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它也比我们的引擎复杂得多，这也是本书没有使用它的一个原因，但它在你的*下一个*游戏中尝试是非常棒的。要从Rust代码中使用JavaScript库，你需要使用`wasm-bindgen`库导入函数，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I've hidden the `use` declarations, but this is a version of `lib.rs` from our
    game that just uses PixiJS to render a static screen. It's not much fun yet, but
    it's enough to demonstrate how, using the `wasm_bindgen` macro and the `extern
    "C" struct`, you can import any JavaScript functions into your Rust library that
    you may want to use. This allows you to use arbitrary JavaScript code in your
    Rust program, with a little bit of glue code to wire the parts together. In fact,
    this is exactly how `web_sys`, which we've been using all over the place, works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经隐藏了`use`声明，但这是从我们的游戏中使用PixiJS渲染静态屏幕的`lib.rs`版本。现在还没有什么乐趣，但足以展示如何使用`wasm_bindgen`宏和`extern
    "C" struct`将任何JavaScript函数导入到你的Rust库中，你可能想使用。这允许你在Rust程序中使用任意JavaScript代码，只需要一点粘合代码来连接各个部分。实际上，这正是`web_sys`的工作方式，我们一直在各处使用它。
- en: 'In order to use all that Pixi code, you''ll need to add a reference to the
    `pixi.js` JavaScript library, and a quick and dirty way to do this is to add the
    following to `index.html`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用所有这些Pixi代码，你需要添加对`pixi.js` JavaScript库的引用，而快速且简单的方法是将以下内容添加到`index.html`中：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In a professional deployment environment, you'd probably want to use WebPack
    to bundle the JavaScript with your own source code, but this works for now. I've
    also removed our canvas element from the HTML because Pixi provides its own.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个专业的部署环境中，你可能想使用WebPack将JavaScript与你的源代码捆绑在一起，但现在这就可以了。我也已经从HTML中移除了我们的canvas元素，因为Pixi提供了自己的。
- en: 'In the Rust code, I was able to import the `PIXI.Application`, `PIXI.Container`,
    and `PIXI.Sprite` types from `pixi.js`, and I''ve also pulled in quite a few functions
    associated with them. This allowed me to use them in `main_js`, just like native
    Rust code. The example here is not professional, using `unwrap` all over the place,
    but it successfully creates a PixiJS application and then creates `Sprite` from
    a file we already had in our game. Then, it adds it to `stage`, which is a PixiJS
    concept that you can think of as the canvas. This code leads to a screen that
    looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – A rock'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B17151.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – A rock
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Okay, it doesn't look like much, but the point is that you can use PixiJS in
    a Rust project by declaring the types you need using `wasm-bindgen`. We won't
    be covering all that here, but the docs for `wasm-bindgen` are extremely thorough
    at [https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html](https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, maybe you don't like PixiJS, and you want to use **PhaserJS**;
    the same principle applies! You can use any of the great frameworks available
    to JavaScript programmers for game development, such as **Three.JS** and **Babylon3D**,
    provided you can include them in your WebAssembly project. But what if you don't
    want to use JavaScript at all but still want to run on the web?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Macroquad
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Macroquad** ([https://macroquad.rs/](https://macroquad.rs/)) is one of many
    game development libraries written in Rust. The authors refer to it as a "**game
    library**", which is a way of saying it''s not as fully featured as an entire
    framework, but it''s more featured than just writing to the HTML Canvas element,
    as we did in our game. It supports WebAssembly out of the box, without writing
    any JavaScript. An example of the code in Macroquad is shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This very simple example will compile and run on the web simply by specifying
    the target with `cargo build --target wasm32-unknown-unknown` – no JavaScript,
    no problem. Macroquad is great, but it's not really a full engine. So, what if
    you want that experience?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Bevy
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another choice with more features is **Bevy** ([https://bevyengine.org/](https://bevyengine.org/)),
    which has been extremely popular since its initial announcement and supports WebAssembly.
    Its "Hello World" is very different from the Macroquad version and resembles the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The most unique part of this system is the `add_system` function, which allows
    you to add "systems" to the Bevy engine. Bevy uses a modern Entity Component System
    for its development, which is meant to aid in structuring your program as well
    as performance. It''s gaining popularity extremely rapidly and moving faster than
    its documentation can keep up with. Currently, if you''re looking to learn how
    to use Bevy for 2D and 3D games, your best bet is to get involved with the community
    here: [https://bevyengine.org/community/](https://bevyengine.org/community/).
    If you do, you''ll be rewarded, as Bevy is a very advanced engine, but it doesn''t
    have an editor such as Unity3D or Unreal. If you''re looking for that, fortunately,
    you have an excellent option.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Godot
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'My first experiences with game development in Rust were using the Godot game
    engine ([https://godotengine.org](https://godotengine.org)). Godot is a truly
    free and open source engine that''s popular with hobbyists and professional game
    developers alike. It comes with its own built-in language, GDScript, out of the
    box but is also able to use Rust through its GDNative wrappers. Originally devised
    to allow the use of C and C++, GDNative works extremely well with Rust. It has
    a thriving community of its own, and you can download it here: [https://godot-rust.github.io](https://godot-rust.github.io).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Godot will mean getting a fully featured 2D and 3D engine that''s capable
    of competing with Unity3D at its best. It''s possible that the entire time you
    were reading this book, you wanted to see a proper commercial game engine such
    as this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – A Godot game engine](img/Figure_11.03_B17151.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – A Godot game engine
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: If so, Godot is the one for you. To see an example Godot program written in
    Rust, you can see the one I wrote at [https://github.com/paytonrules/Aircombat](https://github.com/paytonrules/Aircombat).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The website [https://arewegameyet.rs](https://arewegameyet.rs) asks the question,
    "*Is Rust ready for game development?*" and answers with, "*Almost.*" Respectfully,
    because it's a really cool site, I disagree. We have all of the tools that JavaScript
    developers had a few years ago, with all the advantages of an excellent type system
    and Wasm. We have far more tools than developers have had for most of game development
    history, and while we may not have our Unity or Unreal yet, we have everything
    we need to *build our own*. So, go out there, build your own games, extend the
    engine, and have fun! I hope I hear from you with far better games than this one.
    If you need help, want to show off your games, or just want to hang out with like-minded
    people, you can find me on the Rustacean Station Discord at [https://discord.gg/cHc3Gyc](https://discord.gg/cHc3Gyc).
    You can always find me as `@paytonrules` on Twitter, and I'd be really excited
    to hear from you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
