<html><head></head><body>
		<div><h1 id="_idParaDest-110"><em class="italic"><a id="_idTextAnchor113"/>Chapter 7</em>: <a id="_idTextAnchor114"/>Implementing Terminal I/O in Rust</h1>
			<p>In the previous chapter, we looked at how to work with files and directories. We also built a shell command in Rust that generates consolidated source code metrics for Rust source files in a project directory.</p>
			<p>In this chapter, we will look at building <strong class="bold">terminal-based applications</strong> in Rust. Terminal applications are an integral part of many software programs, including <strong class="bold">games</strong>, <strong class="bold">text editors</strong>, and <strong class="bold">terminal emulators</strong>. For developing these types of programs, it helps to understand how to build customized terminal interface-based applications. This is the focus of this chapter.</p>
			<p>For this chapter, we will review the basics of how terminals work, and then look at how to perform various types of actions on a terminal, such as setting colors and styles, performing cursor operations (such as clearing and positioning), and working with keyboard and mouse inputs.</p>
			<p>We will cover the topics in the following order:</p>
			<ul>
				<li>Introducing terminal I/O fundamentals</li>
				<li>Working with the terminal UI (size, color, styles) and cursors</li>
				<li>Processing keyboard inputs and scrolling</li>
				<li>Processing mouse inputs</li>
			</ul>
			<p>A bulk of this chapter will be dedicated to explaining these concepts through a practical example. We will build a mini text viewer that will demonstrate key concepts of working with terminals. The text viewer will be able to load a file from disk and display its contents on the terminal interface. It will also allow a user to scroll through the contents using the various arrow keys on the keyboard, and display information on the header and footer bar.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor115"/>Technical requirements</h1>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui</a>.</p>
			<p>For those working on the Windows platform, a virtual machine needs to be installed for this chapter, as the third-party crate used for terminal management does not support the Windows platform (at the time of writing this book). It is recommended to install a virtual machine such as VirtualBox or equivalent running Linux for working with the code in this chapter. Instructions to install VirtualBox can be found at <a href="https://www.virtualbox.org">https://www.virtualbox.org</a>.</p>
			<p>For working with terminals, Rust provides several features to read keypresses and to control <em class="italic">standard input</em> and <em class="italic">standard output</em> for a process. When a user types characters in the command line, the bytes generated are available to the program when the user presses the <em class="italic">Enter</em> key. This is useful for several types of programs. But for some types of programs, such as games or text editors, which require more fine-grained control, the program must process each character as it is typed by the user, which is also known as <strong class="bold">raw mode</strong>. There are several third-party crates available that make raw mode processing easy. We will be using one such crate, <strong class="bold">Termion</strong>, in this chapter.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor116"/>Introducing terminal I/O fundamentals</h1>
			<p>In this section, we'll cover the key characteristics of terminals, see an overview of the Termion crate, and define <a id="_idIndexMarker511"/>the scope of what we will be building in this project.</p>
			<p>Let's first look at some fundamentals of terminals.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Characteristics of terminals</h2>
			<p>Terminals are devices with <a id="_idIndexMarker512"/>which users can interact with a computer. Using a terminal, a user can get command-line access to interact with the computer's operating system. A shell typically acts as the controlling program to drive the terminal on one hand and the interface with the operating system on the other hand.</p>
			<p>Originally, UNIX systems were accessed using a <a id="_idIndexMarker513"/>terminal (also called a console) connected to a serial line. These terminals typically had a <em class="italic">24 x 80</em> row x column character-based interface, or in some cases, had rudimentary graphics capabilities. In order to perform operations on the terminal, such as clearing the screen or moving the cursor, specific escape sequences were used.</p>
			<p>There are two modes in which terminals can operate: </p>
			<ul>
				<li><strong class="bold">Canonical mode</strong>: In canonical <a id="_idIndexMarker514"/>mode, the inputs from the user are processed line by line, and the user has to press the <em class="italic">Enter</em> key for the characters to be sent to the program for processing. </li>
				<li><strong class="bold">Noncanonical or raw mode</strong>: In raw <a id="_idIndexMarker515"/>mode, terminal input is not collected into lines, but the <a id="_idIndexMarker516"/>program can read each character as it is typed by the user.</li>
			</ul>
			<p>Terminals can be either physical devices or virtual <a id="_idIndexMarker517"/>devices. Most terminals today are <strong class="bold">pseudo-terminals</strong>, which are virtual devices <a id="_idIndexMarker518"/>that are connected to a terminal device on one side, and to a program that drives the terminal device on the other end. Pseudo-terminals help us write programs where a user on one host machine can execute a <em class="italic">terminal-oriented program</em> on another host machine using network communications. An example of a pseudo-terminal application is <strong class="bold">SSH</strong>, which allows a user to log in to a remote host over a network.</p>
			<p>Terminal management includes the ability to perform the following things on a terminal screen:</p>
			<ul>
				<li><strong class="bold">Color management</strong>: Setting various <a id="_idIndexMarker519"/>foreground and background colors on the terminal and resetting the colors to default values.</li>
				<li><strong class="bold">Style management</strong>: Setting the <a id="_idIndexMarker520"/>style of text to <em class="italic">bold</em>, <em class="italic">italics</em>, <em class="italic">underline</em>, and so on.</li>
				<li><strong class="bold">Cursor management</strong>: Setting the <a id="_idIndexMarker521"/>cursor at a particular position, saving the current cursor position, showing and hiding a cursor, and other special features, such as blinking cursors.</li>
				<li><strong class="bold">Event handling</strong>: Listening and <a id="_idIndexMarker522"/>responding to keyboard and mouse events.</li>
				<li><strong class="bold">Screen handling</strong>: Switching from <a id="_idIndexMarker523"/>main to alternate screens and clearing the screen.</li>
				<li><strong class="bold">Raw mode</strong>: Switching a <a id="_idIndexMarker524"/>terminal to raw mode.</li>
			</ul>
			<p>In this chapter, we will use a combination of the Rust standard library and the Termion crate to develop a terminal-oriented application. Let's see an overview of the Termion crate in the next section.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor118"/>The Termion crate</h2>
			<p>The Termion <a id="_idIndexMarker525"/>crate provides the features listed in the previous section, while also providing the user with easy-to-use command-line interfaces. We will be using many of these features in this chapter.</p>
			<p class="callout-heading">Why use an external crate for terminal management?</p>
			<p class="callout">While it is technically possible to work at the byte level using the Rust standard library, it is cumbersome. External crates such as Termion help us group individual bytes to keypresses, and also implement many of the commonly used terminal management functions, which allows us to focus on the higher-level, user-directed functionality.</p>
			<p>Let's discuss a few terminal management features of the Termion crate. The official documentation of the crate can be found at <a href="https://docs.rs/termion/">https://docs.rs/termion/</a>.</p>
			<p>The Termion crate has the following key modules:</p>
			<ul>
				<li><code>cursor</code>: For moving cursors</li>
				<li><code>event</code>: For handling key and mouse events</li>
				<li><code>raw</code>: To switch the terminal to raw mode</li>
				<li><code>style</code>: To set various styles on text</li>
				<li><code>clear</code>: To clear the entire screen or individual lines</li>
				<li><code>color</code>: To set various colors to text</li>
				<li><code>input</code>: To handle advanced user input</li>
				<li><code>scroll</code>: To scroll across the screen</li>
			</ul>
			<p>To include the Termion crate, start a new project and add the following entry to <code>cargo.toml</code>:</p>
			<pre>[dependencies]
termion = "1.5.5"</pre>
			<p>A few examples of Termion usage are shown through code snippets here:</p>
			<ul>
				<li>To get the terminal size, use the following:<pre>termion::terminal_size()</pre></li>
				<li>To set the foreground color, use the following:<pre>println!("{}", color::Fg(color::Blue));</pre></li>
				<li>To set the background color and then reset the background color to the original state, use the following:<pre>    println!(
        "{}Background{} ",
        color::Bg(color::Cyan),
        color::Bg(color::Reset)
    );</pre></li>
				<li>To set bold <a id="_idIndexMarker526"/>style, use the following:<pre>  println!(
        "{}You can see me in bold?",
        style::Bold
    );</pre></li>
				<li>To set the cursor to a particular position, use the following:<pre>termion::cursor::Goto(5, 10)</pre></li>
				<li>To clear the screen, use the following:<pre>print!("{}", termion::clear::All);</pre></li>
			</ul>
			<p>We will use these terminal management features in a practical example in the upcoming sections. Let's now define what we are going to build in this chapter.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>What will we build?</h2>
			<p>We will develop a mini <a id="_idIndexMarker527"/>text viewer application. This application provides a terminal text interface to load a document from a directory location and view the document. The user can scroll through the document using keyboard keys. We'll build this project p<a id="_idTextAnchor120"/>rogressively over multiple iterations of code.</p>
			<p><em class="italic">Figure 7.1</em> shows the screen layout of what we will build in this chapter:</p>
			<div><div><img src="img/Figure_7.1_B16405.jpg" alt="Figure 7.1 – Text viewer screen layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Text viewer screen layout</p>
			<p>There are <a id="_idIndexMarker528"/>three components in the terminal interface of the text viewer:</p>
			<ul>
				<li><strong class="bold">Header bar</strong>: This contains the title of the text editor.</li>
				<li><strong class="bold">Text area</strong>: This contains the lines of text to be displayed.</li>
				<li><strong class="bold">Footer bar</strong>: This displays the position of the cursor, the number of lines of text in the file, and the name of the file being displayed.</li>
			</ul>
			<p>The text viewer will allow the user to perform the following actions:</p>
			<ul>
				<li>Users can provide a filename as a command-line argument to display. This should be a valid filename that already exists. If the file does not exist, the program will display an error message and exit.</li>
				<li>The text viewer will load the file contents and display them on the terminal. If the number of lines in a file is more than the terminal height, the program will allow the user to scroll through the document, and repaint the next set of lines.</li>
				<li>Users can use the up, down, left, and right keys to scroll through the terminal.</li>
				<li>Users can press <em class="italic">Ctrl</em> + <em class="italic">Q</em> to exit the text viewer.</li>
			</ul>
			<p>A popular text viewer <a id="_idIndexMarker529"/>would have a lot more features, but this core scope provides an adequate opportunity for us to learn about developing a terminal-oriented application in Rust.</p>
			<p>In this section, we've learned what terminals are and what kinds of features they support. We also saw an overview of how to work with the Termion crate and defined what we will be building as part of the project in this chapter. In the next section, we'll develop the first iteration of the text viewer.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor121"/>Working with the terminal UI (size, color, styles) and cursors</h1>
			<p>In this section, we will build the <a id="_idIndexMarker530"/>first iteration of the text viewer. At the <a id="_idIndexMarker531"/>end of this section, we will have a program that will accept a filename from the command line, display its contents, and display a header and footer bar. We will use <a id="_idIndexMarker532"/>a Termion crate to set the color and style, get the terminal size, position the cursor at specific coordinates, and clear the screen.</p>
			<p>The code in this section is organized as follows:</p>
			<ul>
				<li>Writing data structures and the <code>main()</code> function</li>
				<li>Initializing the text viewer and getting the terminal size</li>
				<li>Displaying a document and styling the terminal color, styles, and cursor position</li>
				<li>Exiting the text viewer</li>
			</ul>
			<p>Let's start with data structures and the <code>main()</code> function of the text viewer</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor122"/>Writing data structures and the main() function</h2>
			<p>In this section, we'll <a id="_idIndexMarker533"/>define the data structures <a id="_idIndexMarker534"/>needed to represent the text viewer in memory. We'll also write the <code>main()</code> function, which coordinates and invokes various other functions:</p>
			<ol>
				<li>Create a new project and switch to the directory with the following command:<pre><code>tui</code> stands for <code>text-viewer1.rs</code> under <code>src/bin</code>.</p></li>
				<li>Add the following to <code>cargo.toml</code>:<pre>[dependencies]
termion = "1.5.5"</pre></li>
				<li>Let's first import the required modules from the standard library and the Termion crate:<pre>use std::env::args;
use std::fs;
use std::io::{stdin, stdout, Write};
use termion::event::Key;
use termion::input::TermRead;
use termion::raw::IntoRawMode;
use termion::{color, style};</pre></li>
				<li>Let's next define the data structures to represent a text viewer:<pre>struct Doc {
    lines: Vec&lt;String&gt;,
}
#[derive(Debug)]
struct Coordinates {
    pub x: usize,
    pub y: usize,
}
struct TextViewer {
    doc: Doc,
    doc_length: usize,
    cur_pos: Coordinates,
    terminal_size: Coordinates,
    file_name: String,
}</pre><p>This code shows three data structures defined for the text viewer:</p><p>The <a id="_idIndexMarker536"/>document that will be displayed in the viewer is <a id="_idIndexMarker537"/>defined as a <code>Doc</code> struct, which is a vector of strings.</p><p>To store cursor position <em class="italic">x</em> and <em class="italic">y</em> coordinates and to record the current size of the terminal (the total number of rows and columns of characters), we have defined a <code>Coordinates</code> struct.</p><p>The <code>TextViewer</code> struct is the main data structure representing the text viewer. The number of lines contained in the file being viewed is captured in the <code>doc_length</code> field. The name of the file to be shown in the viewer is recorded in the <code>file_name</code> field.</p></li>
				<li>Let's now define the <code>main()</code> function, which is the entry point for the text viewer application:<pre>fn main() {
    //Get arguments from command line
    let args: Vec&lt;String&gt; = args().collect();
    if args.len() &lt; 2 {
        println!("Please provide file name 
            as argument");
        std::process::exit(0);
    }
    //Check if file exists. If not, print error 
    // message and exit process
    if !std::path::Path::new(&amp;args[1]).exists() {
        println!("File does not exist");
        std::process::exit(0);
    }
    // Open file &amp; load into struct
    println!("{}", termion::cursor::Show);
    // Initialize viewer
    let mut viewer = TextViewer::init(&amp;args[1]);
    viewer.show_document();
    viewer.run();
}</pre><p>The <code>main()</code> function accepts a filename as a command-line parameter and exits the program if the file does not exist. Furthermore, if a filename is not provided as a command-line parameter, it displays an error message and exits the program.</p></li>
				<li>If the file is found, the <code>main()</code> function does the following:<p>It first calls the <code>init()</code> method on the <code>TextViewer</code> struct to initialize the variables.</p><p>Then, it invokes the <code>show_document()</code> method to display the contents of the file on the terminal screen. </p><p>Lastly, the <code>run()</code> method is called, which waits for user inputs to the process. If the user presses <em class="italic">Ctrl</em> + <em class="italic">Q</em>, the program exits.</p></li>
				<li>We will now <a id="_idIndexMarker538"/>write three method <a id="_idIndexMarker539"/>signatures – <code>init()</code>, <code>show_document()</code>, and <code>run()</code>. These three methods should be added to the <code>impl</code> block of the <code>TextViewer</code> struct, as shown:<pre>impl TextViewer {
    fn init(file_name: &amp;str) -&gt; Self {
        //...
    }
    fn show_document(&amp;mut self) {
        // ...
    }
    fn run(&amp;mut self) {
        // ...
    }
}</pre></li>
			</ol>
			<p>So far, we've defined the data structures and written the <code>main()</code> function with placeholders for the other functions. In the next section, let's write the function to initialize the text viewer.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor123"/>Initializing the text viewer and getting the terminal size</h2>
			<p>When a user <a id="_idIndexMarker540"/>starts the text viewer with a document name, we have to <a id="_idIndexMarker541"/>initialize the text viewer with some information and perform startup tasks. This is the purpose of the <code>init()</code> method.</p>
			<p>Here is the complete code for the <code>init()</code> method:</p>
			<pre>fn init(file_name: &amp;str) -&gt; Self {
    let mut doc_file = Doc { lines: vec![] };           <strong class="bold">&lt;1&gt;</strong>
    let file_handle = fs::read_to_string(file_name)
        .unwrap();                                      <strong class="bold">&lt;2&gt;</strong>
                                                        
    for doc_line in file_handle.lines() {               <strong class="bold">&lt;3&gt;</strong>
        doc_file.lines.push(doc_line.to_string());
    }
    let mut doc_length = file_handle.lines().count();   <strong class="bold">&lt;4&gt;</strong>
 
    let size = termion::terminal_size().unwrap();       <strong class="bold">&lt;5&gt;</strong>
    Self {                                              <strong class="bold">&lt;6&gt;</strong>
        doc: doc_file,
        cur_pos: Coordinates {
            x: 1,
            y: doc_length,
        },
        doc_length: doc_length,
        terminal_size: Coordinates {
            x: size.0 as usize,
            y: size.1 as usize,
        },
        file_name: file_name.into(),
    }
}</pre>
			<p>The code <a id="_idIndexMarker542"/>annotations in the <code>init()</code> method are described <a id="_idIndexMarker543"/>here:</p>
			<ol>
				<li value="1">Initialize the buffer that is used to store the file contents.</li>
				<li>Read the file contents as a string.</li>
				<li>Read each line from the file and store it in the <code>Doc</code> buffer.</li>
				<li>Initialize the <code>doc_length</code> variable with the number of lines in the file.</li>
				<li>Use the <code>termion</code> crate to get the terminal size.</li>
				<li>Create a new struct of the <code>TextViewer</code> type and return it from the <code>init()</code> method.</li>
			</ol>
			<p>We've written the initialization code for the text viewer. Next, we'll write the code to display the document contents on the terminal screen, and also display the header and footer.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor124"/>Displaying a document and styling the terminal color, styles, and cursor position</h2>
			<p>We saw earlier the <a id="_idIndexMarker544"/>layout of the text viewer <a id="_idIndexMarker545"/>that we would like to build. There <a id="_idIndexMarker546"/>are three main <a id="_idIndexMarker547"/>parts of the text viewer screen layout – the header, the document area, and the footer. In this section, we'll write the primary function and supporting function to display the contents as per the defined screen layout.</p>
			<p>Let's look at the <code>show_document()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer1.rs</p>
			<pre>fn show_document(&amp;mut self) {
    let pos = &amp;self.cur_pos;
    let (old_x, old_y) = (pos.x, pos.y);
    print!("{}{}", termion::clear::All,         termion::cursor::Goto(1, 1));
    println!(
        "{}{}Welcome to Super text viewer\r{}",
        color::Bg(color::Black),
        color::Fg(color::White),
        style::Reset
    );
    for line in 0..self.doc_length {
        println!("{}\r", self.doc.lines[line as usize]);
    }
    println!(
        "{}",
        termion::cursor::Goto(0, (self.terminal_size.y - 2) as             u16),
    );
    println!(
        "{}{} line-count={} Filename: {}{}",
        color::Fg(color::Red),
        style::Bold,
        self.doc_length,
        self.file_name,
        style::Reset
    );
    self.set_pos(old_x, old_y);
}</pre>
			<p>The code <a id="_idIndexMarker548"/>annotations for the <code>show_document()</code> method are described here:</p>
			<ol>
				<li value="1">Store the current <a id="_idIndexMarker549"/>positions of the cursor <em class="italic">x</em> and <em class="italic">y</em> coordinates <a id="_idIndexMarker550"/>in temp <a id="_idIndexMarker551"/>variables. This will be used to restore the cursor position in a later step.</li>
				<li>Using the Termion crate, clear the entire screen and move the cursor to row 1 and column 1 on the screen.</li>
				<li>Print the header bar of the text viewer. A background color of black and a foreground color of white is used to print text.</li>
				<li>Display each line from the internal document buffer to the terminal screen.</li>
				<li>Move the cursor to the bottom of the screen (using the terminal size <em class="italic">y</em> coordinate) to print the footer.</li>
				<li>Print the footer text in red and with bold style. Print the number of lines in the document and filename to the footer.</li>
				<li>Reset the cursor to the original position (which was saved to temporary variable in <em class="italic">step 1</em>).</li>
			</ol>
			<p>Let's look at the <code>set_pos()</code> helper method used by the <code>show_document()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer1.rs</p>
			<pre>fn set_pos(&amp;mut self, x: usize, y: usize) {
    self.cur_pos.x = x;
    self.cur_pos.y = y;
    println!(
        "{}",
        termion::cursor::Goto(self.cur_pos.x as u16, 
            (self.cur_pos.y) as u16)
    );
}</pre>
			<p>This helper <a id="_idIndexMarker552"/>method synchronizes the internal cursor tracking field (the <code>cur_pos</code> field of the <code>TextViewer</code> struct) and the on-screen cursor position.</p>
			<p>We now <a id="_idIndexMarker553"/>have the code to initialize the text <a id="_idIndexMarker554"/>viewer and to display <a id="_idIndexMarker555"/>the document on the screen. With this, a user can open a document in the text viewer and view its contents. But how does the user exit the text viewer? We'll find out in the next section.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor125"/>Exiting the text viewer</h2>
			<p>Let's say that a <a id="_idIndexMarker556"/>key combination of <em class="italic">Ctrl</em> + <em class="italic">Q</em> will let the user exit the text viewer program. How can we implement this code?</p>
			<p>To achieve this, we need a way to listen for user key strokes, and when a particular key combination is pressed, we should exit the program. As discussed earlier, we need to get the terminal into raw mode of operation, where each character is available for the program to evaluate, rather than wait for the user to press the <em class="italic">Enter</em> key. Once we get the raw characters, the rest of it becomes fairly straightforward. Let's write the code to do this in the <code>run()</code> method, within the <code>impl TextViewer</code> block, as shown:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer1.rs</p>
			<pre>fn run(&amp;mut self) {
    let mut stdout = stdout().into_raw_mode().unwrap();
    let stdin = stdin();
    for c in stdin.keys() {
        match c.unwrap() {
            Key::Ctrl('q') =&gt; {
                break;
            }
            _ =&gt; {}
        }
        stdout.flush().unwrap();
    }
}</pre>
			<p>In the code shown, we <a id="_idIndexMarker557"/>use the <code>stdin.keys()</code> method to listen for user inputs in a loop. <code>stdout()</code> is used to display text to the terminal. When <em class="italic">Ctrl</em> + <em class="italic">Q</em> is pressed, the program exits.</p>
			<p>We can now run the program with the following:</p>
			<pre>cargo run --bin text-viewer1 &lt;file-name-with-full-path&gt;</pre>
			<p>Since we have not implemented scrolling yet, pass a filename to the program that has 24 lines or less of content (this is typically the default height of a standard terminal in terms of the number of rows). You will see the text viewer <em class="italic">open up</em> and the <em class="italic">header bar</em>, <em class="italic">footer bar</em>, and <em class="italic">file contents</em> printed to the terminal. Type <em class="italic">Ctrl</em> + <em class="italic">Q</em> to exit. Note that you have to specify the filename with the full file path as a command-line argument.</p>
			<p>In this section, we learned how to get the terminal size, set the foreground and background colors, and <a id="_idIndexMarker558"/>apply bold style using the Termion crate. We also learned how to position the cursor onscreen at specified coordinates, and how to clear the screen. </p>
			<p>In the next section, we will look at processing keystrokes for user navigation within the document displayed in the text editor and how to implement scrolling.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor126"/>Processing keyboard inputs and scrolling</h1>
			<p>In the previous <a id="_idIndexMarker559"/>section, we built the first <a id="_idIndexMarker560"/>iteration of our text viewer terminal-oriented application. We were able to display a file with fewer than 24 lines and see the header and footer bar containing some information. Finally, we were able to exit the program with <em class="italic">Ctrl</em> + <em class="italic">Q</em>.</p>
			<p>In this section, we will add the following features to the text viewer:</p>
			<ul>
				<li>Provide the ability to display files of any size.</li>
				<li>Provide the ability for the user to scroll through the document using arrow keys.</li>
				<li>Add cursor position coordinates to the footer bar.</li>
			</ul>
			<p>Let's begin by creating a new version of the code.</p>
			<p>Copy the original code to a new file, as shown:</p>
			<pre>cp src/bin/text-viewer1.rs src/bin/text-viewer2.rs</pre>
			<p>This section is organized into three parts. First, we'll implement the logic to respond to the following keystrokes from a user: up, down, left, right, and backspace. Next, we'll implement the functionality to update the cursor position in internal data structures, and simultaneously update the cursor position onscreen. Lastly, we'll allow scrolling through a multi-page document.</p>
			<p>We'll begin with handling user keystrokes.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor127"/>Listening to keystrokes from the user</h2>
			<p>Let's modify the <code>run()</code> method <a id="_idIndexMarker561"/>to act on user inputs and scroll through the document. We also want to record and display the current cursor position in the footer bar. The code is shown here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer2.rs</p>
			<pre>fn run(&amp;mut self) {
    let mut stdout = stdout().into_raw_mode().unwrap();
    let stdin = stdin();
    for c in stdin.keys() {
        match c.unwrap() {
            Key::Ctrl('q') =&gt; {
                break;
            }
<strong class="bold">            Key::Left =&gt; {</strong>
<strong class="bold">                self.dec_x();</strong>
<strong class="bold">                self.show_document();</strong>
<strong class="bold">            }</strong>
<strong class="bold">            Key::Right =&gt; {</strong>
<strong class="bold">                self.inc_x();</strong>
<strong class="bold">                self.show_document();</strong>
<strong class="bold">            }</strong>
<strong class="bold">            Key::Up =&gt; {</strong>
<strong class="bold">                self.dec_y();</strong>
<strong class="bold">                self.show_document();</strong>
<strong class="bold">            }</strong>
<strong class="bold">            Key::Down =&gt; {</strong>
<strong class="bold">                self.inc_y();</strong>
<strong class="bold">                self.show_document();</strong>
<strong class="bold">            }</strong>
<strong class="bold">            Key::Backspace =&gt; {</strong>
<strong class="bold">                self.dec_x();</strong>
<strong class="bold">            }</strong>
            _ =&gt; {}
        }
        stdout.flush().unwrap();
    }
}</pre>
			<p>Lines in bold show the changes to the <code>run()</code> method from the earlier version. In this code, we are listening for up, down, left, right, and backspace keys. For any of these keypresses, we <a id="_idIndexMarker562"/>are incrementing the <em class="italic">x</em> or <em class="italic">y</em> coordinate appropriately using one of the following methods: <code>inc_x()</code>, <code>inc_y()</code>, <code>dec_x()</code>, or <code>dec_y()</code>. For example, if the right arrow is pressed, the <em class="italic">x</em> coordinate of the cursor position is incremented using the <code>inc_x()</code> method, and if the down arrow is pressed, only the <em class="italic">y</em> coordinate is incremented using the <code>inc_y()</code> method. The changes to coordinates are recorded in the internal data structure (the <code>cur_pos</code> field of the <code>TextViewer</code> struct). Also, the cursor is repositioned on the screen. All these are achieved by the <code>inc_x()</code>, <code>inc_y()</code>, <code>dec_x()</code>, and <code>dec_y()</code> methods.</p>
			<p>After updating the cursor position, the screen is refreshed fully and repainted. </p>
			<p>Let's look at implementing the four methods to update cursor coordinates, and reposition the cursor on the screen.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor128"/>Positioning the terminal cursor</h2>
			<p>Let's write the code for the <code>inc_x()</code>, <code>inc_y()</code>, <code>dec_x()</code>, and <code>dec_y()</code> methods. These should be <a id="_idIndexMarker563"/>added as a part of the <code>impl TextViewer</code> block of code like the other methods:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer2.rs</p>
			<pre>fn <strong class="bold">inc_x</strong>(&amp;mut self) {
    if self.cur_pos.x &lt; self.terminal_size.x {
        self.cur_pos.x += 1;
    }
    println!(
        "{}",
        termion::cursor::Goto(self.cur_pos.x as u16, 
            self.cur_pos.y as u16)
    );
}
fn <strong class="bold">dec_x</strong>(&amp;mut self) {
    if self.cur_pos.x &gt; 1 {
        self.cur_pos.x -= 1;
    }
    println!(
        "{}",
        termion::cursor::Goto(self.cur_pos.x as u16,     
            self.cur_pos.y as u16)
    );
}
fn <strong class="bold">inc_y</strong>(&amp;mut self) {
    if self.cur_pos.y &lt; self.doc_length {
        self.cur_pos.y += 1;
    }
 
    println!(
        "{}",
        termion::cursor::Goto(self.cur_pos.x as u16, 
            self.cur_pos.y as u16)
    );
}
fn <strong class="bold">dec_y</strong>(&amp;mut self) {
    if self.cur_pos.y &gt; 1 {
        self.cur_pos.y -= 1;
    }
    println!(
        "{}",
        termion::cursor::Goto(self.cur_pos.x as u16,     
            self.cur_pos.y as u16)
    );
}</pre>
			<p>The structure <a id="_idIndexMarker564"/>of all these four methods is similar and each performs only two steps:</p>
			<ol>
				<li value="1">Depending on the keypress, the corresponding coordinate (<em class="italic">x</em> or <em class="italic">y</em>) is incremented or decremented and recorded in the <code>cur_pos</code> internal variable.</li>
				<li>The cursor is repositioned on the screen at the new coordinates.</li>
			</ol>
			<p>We now have a mechanism to update the cursor coordinates whenever the user presses the up, down, left, right, or backspace keys. But that's not enough. The cursor should be repositioned on the <a id="_idIndexMarker565"/>screen to the latest cursor coordinates. For this, we will have to update the <code>show_document()</code> method, which we will do in the next section.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor129"/>Enabling scrolling on the terminal</h2>
			<p>We <a id="_idIndexMarker566"/>have so far implemented the code to listen for user keystrokes and reposition the cursor onscreen. Now, let's turn our attention to another major issue in the code. If we load a document that has fewer lines than the terminal height, then the code works fine. But consider a situation where the terminal has the capacity to display 24 rows of characters, and there are 50 lines in the document to be displayed on text viewer. Our code cannot handle it. We're going to fix it in this section.</p>
			<p>To display more lines than is possible for the screen size, it is not enough to reposition the cursor. We will have to repaint the screen to fit a portion of the document in the terminal screen depending on the cursor location. Let's see the modifications needed to the <code>show_document()</code> method to enable scrolling. Look for the following lines of code in the <code>show_document()</code> method:</p>
			<pre>  for line in 0..self.doc_length {
            println!("{}\r", self.doc.lines[line as 
                usize]);
        }</pre>
			<p>Replace the preceding with the following code:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/bin/text-viewer2.rs</p>
			<pre>        if self.doc_length &lt; self.terminal_size.y {  <strong class="bold">&lt;1&gt;</strong>                                                                                                                           
            for line in 0..self.doc_length {
                println!("{}\r", self.doc.lines[line as    
                    usize]);
            }
        } else {                                                
                                                     
            if pos.y &lt;= self.terminal_size.y {       <strong class="bold">&lt;2&gt;</strong>  
                for line in 0..self.terminal_size.y - 3 {
                    println!("{}\r", self.doc.lines[line as 
                        usize]);
                }
            } else {
                for line in pos.y - (self.terminal_size.y – 
                    3)..pos.y {
                    println!("{}\r", self.doc.lines[line as     
                        usize]);
                }
            }
        }</pre>
			<p>The code <a id="_idIndexMarker567"/>annotations in the <code>show_document()</code> method snippet are described here:</p>
			<ol>
				<li value="1">First, check whether the number of lines in the input document is less than the terminal height. If so, display all lines from the input document on the terminal screen.</li>
				<li>If the number of lines in the input document is greater than the terminal height, we have to display the document in parts. Initially, the first set of lines from the document are displayed onscreen corresponding to the number of rows that will fit into the terminal height. For example, if we allocate 21 lines to the text display area, then as long as the cursor is within these lines, the original set of lines is displayed. If the user scrolls down further, then the next set of lines is displayed onscreen.</li>
			</ol>
			<p>Let's run the program with the following:</p>
			<pre>cargo run –-bin text-viewer2 &lt;file-name-with-full-path&gt;</pre>
			<p>You can try two kinds of file inputs:</p>
			<ul>
				<li>A file where the number of lines is less than the terminal height</li>
				<li>A file where the number of lines is more than the terminal height</li>
			</ul>
			<p>You can use the up, down, left, and right arrows to scroll through the document and see the contents. You will also see the current cursor position (both <em class="italic">x</em> and <em class="italic">y</em> coordinates) displayed on the footer bar. Type <em class="italic">Ctrl</em> + <em class="italic">Q</em> to exit.</p>
			<p>This <a id="_idIndexMarker568"/>concludes the text viewer project for this chapter. You have built a functional text viewer that can display files of any size, and can scroll through its contents using the arrow keys. You can also view the current position of the cursor along with the filename and number of lines in the footer bar.</p>
			<p class="callout-heading">Note on the text viewer </p>
			<p class="callout">Note that what we have implemented is a mini version of a text viewer in under 200 lines of code. While it demonstrates the key functionality, additional features and edge cases can be implemented by you to enhance the application and improve its usability. Furthermore, this viewer can also be converted into a full-fledged text editor. These are left to you, the reader, as an exercise. </p>
			<p>We've completed the implementation of the text viewer project in this section. The text viewer is a classic command-line application and does not have a GUI interface where mouse inputs are needed. But it is important to learn how to handle mouse events, for developing GUI-based terminal interfaces. We'll learn how to do that in the next section.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor130"/>Processing mouse inputs </h1>
			<p>Like keyboard events, the Termion crate <a id="_idIndexMarker569"/>also supports the ability to listen for mouse events, track the mouse cursor location, and react to it in code. Let's see how to do this here.</p>
			<p>Create a new source file called <code>mouse-events.rs</code> under <code>src/bin</code>.</p>
			<p>Here is the code logic:</p>
			<ol>
				<li value="1">Import the needed modules.</li>
				<li>Enable mouse support in the terminal.</li>
				<li>Clear the screen.</li>
				<li>Create an iterator over incoming events.</li>
				<li>Listen to mouse presses, release and hold events, and display the mouse cursor location on the terminal screen.</li>
			</ol>
			<p>The code is explained in snippets corresponding to each of these points.</p>
			<p>Let's first look at module imports:</p>
			<ol>
				<li value="1">We're importing the <code>termion</code> crate modules for switching to raw mode, detecting the cursor position, and listening to mouse events:<pre>use std::io::{self, Write};
use termion::cursor::{self, DetectCursorPos};
use termion::event::*;
use termion::input::{MouseTerminal, TermRead};
use termion::raw::IntoRawMode;</pre><p>In the <code>main()</code> function, let's enable mouse support as shown: </p><pre>fn main() {
    let stdin = io::stdin();
    let mut stdout = MouseTerminal::from(io::stdout().
        into_raw_mode().unwrap());   
    // ...Other code not shown
 }</pre><p>To ensure that previous text on the terminal screen does not interfere with this program, let's clear the screen, as shown here:</p><pre>    writeln!(
        stdout,
        "{}{} Type q to exit.",
        termion::clear::All,
        termion::cursor::Goto(1, 1)
    )
    .unwrap();                                                                                                                        </pre></li>
				<li>Next, let's <a id="_idIndexMarker570"/>create an iterator over incoming events and listen to mouse events. Display the location of the mouse cursor on the terminal:<pre>    for c in stdin.events() {                                                                                                         
        let evt = c.unwrap(); 
        match evt { 
            Event::Key(Key::Char('q')) =&gt; break, 
            Event::Mouse(m) =&gt; match m { 
                MouseEvent::Press(_, a, b) |     
                    MouseEvent::Release(a, b) |    
                    MouseEvent::Hold(a, b) =&gt; {                                                                                                                                                                
                        write!(stdout, "{}",    
                        cursor::Goto(a, b))
                        .unwrap(); 
                        let (x, y) = stdout.cursor_pos
                            ().unwrap();
                        write!( 
                            stdout, 
                            "{}{}Cursor is at:    
                            ({},{}){}", 
                            cursor::Goto(5, 5), 
                            termion::clear::
                                UntilNewline, 
                             x, 
                             y, 
                            cursor::Goto(a, b) 
                        ) 
                        .unwrap(); 
                } 
            }, 
            _ =&gt; {} 
        } 
  
        stdout.flush().unwrap(); 
    }</pre><p>In the code <a id="_idIndexMarker571"/>shown, we are listening to both keyboard events and mouse events. In keyboard events, we are specifically looking for the <em class="italic">Q</em> key, which exits the program. We are also listening to mouse events – press, release, and hold. In this case, we position the cursor at the specified coordinates and also print out the coordinates to the terminal screen.</p></li>
				<li>Run the program with the following command:<pre><strong class="bold">cargo run --bin mouse-events</strong></pre></li>
				<li>Click around the <a id="_idIndexMarker572"/>screen with the mouse, and you will see the cursor position coordinates displayed on the terminal screen. Press <code>q</code> to exit.</li>
			</ol>
			<p>With this, we conclude the section on working with mouse events on the terminal. This also concludes the chapter on terminal I/O management using Rust.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, we learned the basics of terminal management by writing a mini text viewer. We learned how to use the Termion library to get the terminal size, set the foreground and background colors, and set styles. After this, we learned how to work with cursors on the terminal, including clearing the screen, positioning the cursor at a particular set of coordinates, and keeping track of the current cursor position.</p>
			<p>We learned how to listen to user inputs and track the keyboard arrow keys for scrolling operations, including left, right, up, and down. We wrote code to display document contents dynamically as the user scrolls through it, keeping the constraints of the terminal size in mind. As an exercise, you can refine the text viewer, and also add functionality to convert the text viewer into a full-fledged editor.</p>
			<p>Learning these features is important to write applications such as terminal-based games, editing and viewing applications and terminal graphical interfaces, and to provide terminal-based dashboards.</p>
			<p>In the next chapter, we will learn the basics of process management using Rust, including starting and stopping processes and handling errors and signals.</p>
		</div>
	</body></html>