<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Creating a Computer Emulator Using Nom
                </header>
            
            <article>
                
<p>In the last chapter, we saw how to parse text files—in particular, how to program source files in a simple programming language. Text files aren't the only thing you could need to parse—several kinds of system software need to parse binary files (such as binary executables, multimedia files, and inter-process communication messages).</p>
<p>In this chapter, we will look at how to cope with the need for parsing binary files and how the <kbd>nom</kbd> library can be used to ease this task. <span>First, we will look at how to parse and interpret a very simple machine language without using an external library, and then how the <kbd>nom</kbd> library can be used to ease this task. </span></p>
<p>To do this, we will cover the following topics:</p>
<ul>
<li><span>Introducing a very simple machine language using only 16-bit words</span></li>
<li>Writing a couple of programs in this language</li>
<li>Writing a parser and an interpreter for this language and running it on the previously presented programs</li>
<li><span>Defining a byte-addressing machine language derived from the previous one</span></li>
<li>Explaining the addressing issue (endianness) that emerges when a byte-addressing machine language must handle words containing several bytes</li>
<li>Presenting a version in the <span>new machine language</span> of the previously presented machine language program </li>
<li>Writing a parser and an interpreter for this language using the <kbd>nom</kbd> library and running it on the machine language program</li>
<li>Writing a translator for the C language that converts the <span>machine language program into an equivalent C language program</span></li>
<li>Writing a couple of disassemblers—programs that convert machine language programs into assembly language—and applying them <span>to our machine language program</span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>By the end of this chapter, you will have learned the main concepts of CPU architectures, interpretation, and translating machine language.</span></p>
<h1 id="uuid-3145ebe9-0d4b-4f2b-b1e9-a9e2f031e9bb">Technical requirements</h1>
<p>For<span> the parts of this chapter referring to the <kbd>nom</kbd> library, knowledge of </span>the preceding chapter is required.</p>
<p><span>The complete source code for this chapter is found in the <kbd>Chapter09</kbd></span><span> </span><span>folder </span><span>of the repository at </span><a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a><span>.</span></p>
<h1 id="uuid-72fb3dfc-e120-4fd0-a242-81a0c8d1dbd3">Project overview</h1>
<p>In this chapter, first, the general concepts regarding machine languages will be presented. Then, a very simple machine language will be presented. Of course, this will be quite unrealistic to use as no real hardware exists to run it. It will simply be used to demonstrate how to process it.</p>
<p>Then, a very simple algorithm will be written in the machine language—a <span>formatter of integer numbers. A Rust program to interpret this program will be written without using an external library (<kbd>word_machine_convert</kbd>).</span></p>
<p>Then, a more complex program will be written in this machine language—the famous algorithms invented by Eratosthenes to find prime numbers (named the <span><strong>sieve of Eratosthenes</strong>). The previous Rust program will be used to interpret this machine language program (<kbd>word_machine_sieve</kbd>).</span></p>
<p>Afterward, a somewhat more realistic machine language will be defined that is capable of addressing single bytes instead of words. The issues raised by this machine language<span> will be explained. A</span> new version of the <span>sieve of Eratosthenes </span>will be written in this updated machine language and an interpreter will be written in Rust to run it. In addition, this Rust program will translate the machine language program into C language. This interpreter and compiler will use the <kbd>nom</kbd> library, already introduced in the previous chapter, to generate an intermediate version of the program. This intermediate data structure will be both interpreted and compiled to the C language (<kbd><span>nom_byte_machine</span></kbd>).</p>
<p class="mce-root"/>
<p>Finally, a <strong>disassembler</strong> will be built<span> </span><span>for this machine language</span><span> (</span><kbd>nom_disassembler</kbd><span>). It will again </span><span>use</span><span> </span><span>the <kbd>nom</kbd> library and it will show two kinds of disassembling—one meant to aid debugging and the other meant to generate source code for an assembler; that is, a program that translates symbolic code to machine language.</span></p>
<h1 id="uuid-7088acd2-ac24-4eb9-8914-ed6b654d1ae5">Introducing a very simple machine language</h1>
<p><span>Real machine languages and real computers are way too complex to be covered in a single chapter; therefore, we will use a toy machine language that is easier to process and understand. In fact, two machine languages will be used:</span></p>
<ul>
<li><span>The first language that we will use is the simpler one. For</span> simplicity, it addresses <span>16-bit words, instead of </span>memory bytes.</li>
<li>The second language presented can address single bytes, as most modern computers do.</li>
</ul>
<p>Therefore, any program of the first language that we will use is just a sequence of <span>16-bit </span>words, and any program written in it can<span> </span><span>only</span><span> manipulate</span> <span>16-bit </span><span>words.</span></p>
<p class="mce-root">Both<span> </span><span>machine languages use just one memory segment containing both machine code and data. Here, there is no real distinction between code and data; instructions can read or write both code and data and data can wrongly be executed as if it were instructions. Usually, code, and some data as well (the so-called</span> <strong>constants</strong><span>), is not meant to change, but here, there is no guarantee.</span></p>
<div class="packt_tip"><span>In most computer architecture, the memory used by any process is composed of several portions, named </span><strong>segments</strong><span>. The most common memory segments are machine code (often named text), static data, heaps, and stacks. Some segments can be read-only, while others may be writable. Some segments may have a fixed size and others may be resized. Some segments can be shared with other processes. </span></div>
<p><span>Let's look at some reasons why we might need to process machine language software:</span></p>
<ul>
<li>Running a binary program for a computer when that computer is not available (because it is too costly to buy or because it has not yet been built)</li>
<li>Debugging or analyzing a binary program when its source code is not available and <span>the computer that must run it is so resource-constrained that no debugger can run on it</span></li>
<li>Disassembling machine code—that is, translating it into assembly code</li>
<li>T<span>ranslating a binary program into another machine language to run it natively </span><span>in a much faster way than by interpreting i</span><span>t</span></li>
<li><span>T</span><span>ranslating a binary program into a high-level programming language to change it easily and then to recompile it into any machine language</span></li>
</ul>
<p class="mce-root"><span>Writing a program directly in machine code is very error-prone, so no one does it. Anyone that needs to write some machine language first writes that code in a symbolic language, named <strong>assembly language</strong>, and then translates it into machine language. This translation can be done manually or by using a specific program, named an <strong>assembler</strong>. Here, we don't have an assembler for our programs, so we will translate the assembly code manually. However, before describing our machine languages, let's look at some concepts relating to machine language. </span></p>
<h2 id="uuid-e07e8e9b-b2d6-4a72-8a05-3ffd4b65c4b8">The most important concepts relating to machine language</h2>
<p class="mce-root">In any programming language, you need a way to specify variables and statements. In addition, to document your code, you need a way to insert comments into the program. The following code is a very simple program in assembly language, containing the declaration of some variables, some instructions, and some comments:</p>
<pre class="mce-root">// <strong>data</strong><br/>n<br/>    word 17<br/>m<br/>    word 9<br/>sum<br/>    word 0<br/>// <strong>code</strong><br/>    load n<br/>    add m<br/>    store sum<br/>    terminate 0</pre>
<p>The double backslashes (<kbd>//</kbd>) begin the comments. The first comment declares (for humans) where the <kbd>data</kbd> section starts. The second comment <span>declares where the</span> <kbd>code</kbd> <span>section starts.</span></p>
<div class="packt_infobox">Notice that, apart from comments, some lines are indented and others aren't. Actual declarations and instructions must be indented. Lines written in the first column are <strong>labels </strong>that mark positions in the program.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding code, there is some data, as shown in the first line. Every data item is a word, and so it is declared using the <kbd>word</kbd> keyword. At position <kbd>n</kbd>, there is a word whose initial value is <kbd>17</kbd>. <span>At position </span><kbd>m</kbd>,<span> there is another word whose initial value is </span><kbd>9</kbd><span> and at position <kbd>sum</kbd>, there is a word whose initial value is <kbd>0</kbd>.</span></p>
<p class="mce-root">Then, there are four instructions, each on a different line. Each instruction has two parts:</p>
<ul>
<li class="mce-root"><strong>Operation Code</strong> (<strong>opcode</strong>): This is a command for the processor.</li>
<li class="mce-root"><strong>Operand</strong>: This is the argument for an opcode command—that is, the data on which the command operates.</li>
</ul>
<p class="mce-root"><span>All machine language is designed for specific computer architecture. The c</span>omputer meant to run this program has just two 16-bit CPU registers:</p>
<ul>
<li class="mce-root">One to keep the data word to manipulate, named the <strong>accumulator</strong></li>
<li class="mce-root">One to keep the address of the next instruction to execute, named the <strong>instruction pointer</strong> (or <strong>program counter</strong>)</li>
</ul>
<p class="mce-root">The first instruction of the program is <kbd>load n</kbd>. This instruction <span>is equivalent to the </span><kbd>accumulator = n;</kbd><span> </span><span>Rust statement</span><span>. It</span> <span>copies the current value of the word that is at the address labeled with </span><kbd>n</kbd><span> </span><span>in the accumulator</span><span>.</span></p>
<p class="mce-root">The second instruction is <kbd>add m</kbd>. This <span>is equivalent to the <kbd>accumulator += m;</kbd></span><span> </span><span>Rust statement</span><span>. It adds the value of the word that is at the address labeled with </span><kbd>m</kbd><span> </span><span>to the value currently contained in the accumulator</span><span> and it stores</span><span> </span><span>the result</span><span> into the accumulator.</span></p>
<p class="mce-root">The third instruction is <kbd>store sum</kbd>. <span>This </span><span>is equivalent to the <kbd>sum = accumulator;</kbd></span><span> </span><span>Rust statement</span><span>. It</span> <span>copies</span><span> the current value of the accumulator</span><span> into the word that is at the address labeled with </span><kbd>sum</kbd><span>.</span></p>
<p class="mce-root">The last instruction is <kbd>terminate 0</kbd>. This terminates the execution of the program (returning control to the operating system, if there is one) and it returns a value of <kbd>0</kbd> to the process that launched this program (if there is one).</p>
<p class="mce-root">So,<span> </span><span>if we follow the effect of the ins</span><span>truction</span><span>s on the data, we find that this program starts with the three data words containing</span> <kbd>17</kbd><span>,</span> <kbd>9</kbd><span>, and</span> <kbd>0</kbd><span> and</span><span> ends with them containing</span> <kbd>17</kbd><span>,</span> <kbd>9</kbd><span>, and <kbd>26</kbd>.</span></p>
<p class="mce-root">However, to run this program, we need to translate it into machine language.</p>
<p class="mce-root"/>
<p>Here, a distinction between the words <strong>program</strong> and <strong>process</strong> is needed. A machine language program is the machine code that exists before running it. <kbd>t</kbd> is either stored in a storage device or ROM. Instead, a process is found in the RAM area in which the program is loaded and run. This distinction is particularly important in multiprocessing systems, where you may have several processes running on the same program, but it is also important in systems running one process at a time.</p>
<p class="mce-root">Let's assume that our machine requires any program to have the following structure:</p>
<table style="border-collapse: collapse;width: 100%;height: 375px" border="1">
<tbody>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> Length of the process</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> First instruction</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"> Second instruction</td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"> Third instruction</td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> ...</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> Last instruction</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> First word of data</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> Second word of data</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"><span> Third word of data</span></td>
</tr>
<tr>
<td style="width: 180px" class="CDPAlignCenter CDPAlign"> ...</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">This table shows that the first word of the program is meant to be the length of the whole process in words. The words after it are meant to be instructions in machine language. The words that follow the last instruction of the program are meant to be data.</p>
<p class="mce-root">In the preceding program, we have four instructions, and each of them uses one word for the opcode and one for the operand. Therefore, eight words are occupied by four instructions. If we add together the initial word containing the length of the process and the three words occupied by the three variables (one word per variable), we get <em>1 + 8 + 3 = 12</em> words. This is the size of the memory space used by this program, measured in words. If we set this number as the initial word of the program, it means that we need exactly that memory in our process.</p>
<p>If we lay out the instructions and data, we get the following array of words for our process:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Position</strong></td>
<td><strong>Contents</strong></td>
</tr>
<tr>
<td><kbd>0</kbd></td>
<td>The length of the process</td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td>The opcode of the <kbd>load</kbd> instruction</td>
</tr>
<tr>
<td><kbd>2</kbd></td>
<td>The <kbd>n</kbd> operand</td>
</tr>
<tr>
<td><kbd>3</kbd></td>
<td>The opcode of the <kbd>add</kbd> instruction</td>
</tr>
<tr>
<td><kbd>4</kbd></td>
<td>The <kbd>m</kbd> operand</td>
</tr>
<tr>
<td><kbd>5</kbd></td>
<td>The opcode of the <kbd>store</kbd> instruction</td>
</tr>
<tr>
<td><kbd>6</kbd></td>
<td>The <kbd>sum</kbd> operand</td>
</tr>
<tr>
<td><kbd>7</kbd></td>
<td>The opcode of the <kbd>terminate</kbd> instruction</td>
</tr>
<tr>
<td><kbd>8</kbd></td>
<td>The <kbd>0</kbd> operand</td>
</tr>
<tr>
<td><kbd>9</kbd></td>
<td>Data 17</td>
</tr>
<tr>
<td><kbd>10</kbd></td>
<td>Data 9</td>
</tr>
<tr>
<td><kbd>11</kbd></td>
<td>Data 0</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The position of any word is its distance from the beginning of the program measured in words. Any position is named the <strong>address</strong> of the word, as this number allows us to access the word in the process.</p>
<p class="mce-root"><span>Machine language does not use </span>labels; it only <span>uses</span><span> </span><span>addresses. So, to translate the assembly code into machine language, we must replace the use of labels with memory addresses. The address of the first word is, by definition, <kbd>0</kbd>. The address of the first instruction is <kbd>1</kbd>. Any instruction is two-words long, and so the address of the second instruction is</span> <em>1 + 2 = 3</em><span>. The address after the last instruction—that is, the address of the first data word, labeled by</span> <kbd>n</kbd><span>—is <kbd>9</kbd>. The address of the second data word, labeled</span> <kbd>m</kbd><span>, is <kbd>10</kbd>. The address of the last data word, labeled</span> <kbd>sum</kbd><span>, is <kbd>11</kbd>.</span></p>
<p class="mce-root">After adding the initial length, moving the instructions before the data, and replacing the labels, our program becomes the following:</p>
<pre class="mce-root">12<br/>load 9<br/>add 10<br/>store 11<br/>terminate 0<br/>word 17<br/>word 9<br/>word 0</pre>
<p class="mce-root">Then, we must replace every symbolic code with its corresponding machine language opcode, which is a unique number.</p>
<p class="mce-root">Let's assume the following correspondence between the opcode and symbolic instruction code:</p>
<pre class="mce-root">0 = terminate<br/>1 = load<br/>2 = store<br/>3 = add</pre>
<p class="mce-root">The<span> </span><kbd>word</kbd><span> </span><span>keyword does not actually generate instructions. So, our program beco</span><span>mes the following:</span></p>
<pre class="mce-root"><span>12<br/></span><span>1: 9<br/></span><span>3: 10<br/></span><span>2: 11<br/></span><span>0: 0<br/></span><span>17<br/></span><span>9<br/></span><span>0</span></pre>
<p class="mce-root">Of course, these numbers will be stored as a vector of binary numbers. So, in Rust, it will be the following:</p>
<pre class="mce-root">let mut program: Vec&lt;u16&gt; = vec![12, 1, 9, 3, 10, 2, 11, 0, 0, 17, 9, 0];</pre>
<p>So, we have been able to manually translate an assembly language program into a machine language program. However, we used a very small machine language containing only four kinds of instructions—that is, only four different opcodes. To carry out useful work, some more kinds of instructions are needed.</p>
<h2 id="uuid-e1d28a3e-f273-4150-9de0-f876367e7f01">Extending our machine language</h2>
<p class="mce-root">The machine language that we saw in the preceding section is only capable of<span> </span>making additions and it has no input/output capabilities. Such a limited language is not very interesting. So, to have a language that can be used to build meaningful programs, let's add some <span>kinds</span><span> of </span><span>instruction to our machine language.</span></p>
<p class="mce-root">Our assembly language (and its corresponding machine language) is defined by the following table:</p>
<table style="border-collapse: collapse;width: 101.104%" border="1">
<tbody>
<tr>
<td style="width: 10%"><strong>Opcode</strong></td>
<td style="width: 21%"><strong>Assembly syntax</strong></td>
<td style="width: 56%"><strong><span>Description</span></strong></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0</kbd></td>
<td style="width: 21%"><kbd>terminate operand</kbd></td>
<td style="width: 56%"><span>This terminates the program, returning the operand to the caller.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>1</kbd></td>
<td style="width: 21%"><kbd>set operand</kbd></td>
<td style="width: 56%"><span>This copies the operand to the accumulator.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>2</kbd></td>
<td style="width: 21%"><kbd>load<span> address</span></kbd></td>
<td style="width: 56%"><span>This copies the value at this address</span> to the accumulator.</td>
</tr>
<tr>
<td style="width: 10%"><kbd>3</kbd></td>
<td style="width: 21%"><kbd>store<span> address</span></kbd></td>
<td style="width: 56%"><span>This copies the value of the accumulator</span> to this address.<span><br/></span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>4</kbd></td>
<td style="width: 21%"><kbd><span>indirect_load address</span></kbd></td>
<td style="width: 56%"><span>This copies the value whose address is specified at this address</span> to the accumulator.</td>
</tr>
<tr>
<td style="width: 10%"><kbd>5</kbd></td>
<td style="width: 21%"><kbd><span><span>indirect_store address</span></span></kbd></td>
<td style="width: 56%"><span><span>This copies </span></span>the value of the accumulator to the address <span>specified at this address. </span><span><span><br/></span></span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>6</kbd></td>
<td style="width: 21%"><kbd><span>input length</span></kbd></td>
<td style="width: 56%"><span>This asks the user for console input until the <em>Enter</em></span> key <span>is pressed. Then, at most, the <kbd>length</kbd> characters of the input line are copied into consecutive memory words. This sequence of memory words begins at the address contained in the accumulator. Each memory word contains exactly one character. If the user types less than length characters, the remaining words are set to binary zero (<kbd>0</kbd>). So, in any case, <kbd>length</kbd> memory words are set by this instruction.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>7</kbd></td>
<td style="width: 21%"><kbd><span><span>output length</span></span></kbd></td>
<td style="width: 56%"><span>This emits to the console the <kbd>length</kbd> ASCII characters whose codes are in consecutive memory words. This sequence of memory words to output begins at the address contained in the accumulator. Only 7-bit ASCII characters are correctly supported.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>8</kbd></td>
<td style="width: 21%"><kbd>add address</kbd></td>
<td style="width: 56%"><span><span>This adds the value at this address</span></span> to the value of the accumulator and keeps <span>the result in the accumulator. It uses 16-bit integer arithmetic with a wraparound—that is, in the case of integer overflow, the value modulo of 65,536 is obtained.</span><span><span><br/></span></span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>9</kbd></td>
<td style="width: 21%"><kbd><span>subtract address</span></kbd></td>
<td style="width: 56%"><span><span><span><span>This subtracts the value at this address </span></span></span></span><span><span><span>from the value of the accumulator,</span></span></span><span><span> using wrap-around arithmetic, and keeps the result in the accumulator</span></span><span>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>10</kbd></td>
<td style="width: 21%"><kbd>multiply address</kbd></td>
<td style="width: 56%"><span><span><span>This multiplies the value of the accumulator by the value at this address,</span></span></span><span><span> using wrap-around arithmetic, and keeps the result in the accumulator</span></span><span>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>11</kbd></td>
<td style="width: 21%"><kbd>divide address</kbd></td>
<td style="width: 56%"><span>This divides the value of the accumulator by the value at this address using integer arithmetic (truncation) and keeps the result in the accumulator (quotient).</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>12</kbd></td>
<td style="width: 21%"><kbd>remainder address</kbd></td>
<td style="width: 56%"><span><span>This divides the value of the accumulator by the value at this address </span></span><span>using integer arithmetic (truncation) and keeps the integer remainder</span> in the accumulator.<span><br/></span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>13</kbd></td>
<td style="width: 21%"><kbd><span>jump address</span></kbd></td>
<td style="width: 56%">This proceeds to the execution of the instruction present at <kbd>address</kbd>.</td>
</tr>
<tr>
<td style="width: 10%"><kbd>14</kbd></td>
<td style="width: 21%"><kbd><span><span>jump_if_zero </span></span><span>address</span></kbd></td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at <kbd>address</kbd></span><span>, but only if the value of the accumulator is equal to <kbd>0</kbd>. Otherwise, it proceeds to the next instruction.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>15</kbd></td>
<td style="width: 21%"><kbd><span><span>jump_if_nonzero address</span></span></kbd></td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at <kbd>address</kbd></span><span> if the value of the accumulator is not <kbd>0</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>16</kbd></td>
<td style="width: 21%"><kbd><span>jump_if_positive address</span></kbd></td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at </span><kbd>address</kbd><span> if the value of the accumulator is a positive number.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>17</kbd></td>
<td style="width: 21%"><kbd><span>jump_if_negative address</span></kbd></td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at </span><kbd>address</kbd><span> if the value of the accumulator is a negative number.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>18</kbd></td>
<td style="width: 21%">
<div>
<div><kbd><span>jump_if_nonpositive address</span></kbd></div>
</div>
</td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at </span><kbd>address</kbd><span>, but only if the value of the accumulator is non-positive—that is, if it is a negative number or it is equal to <kbd>0</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>19</kbd></td>
<td style="width: 21%"><kbd><span>jump_if_nonnegative address</span></kbd></td>
<td style="width: 56%"><span>This proceeds to the execution of the instruction present at </span><kbd>address</kbd><span><span> if the value of the accumulator is </span></span><span><span>non-negative—that is, if it is a </span></span><span>positive number or it is equal to <kbd>0</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"> –</td>
<td style="width: 21%"><kbd><span>word value</span></kbd></td>
<td style="width: 56%"><span>This reserves a word for data. Its initial content is specified by <kbd>value</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"> – </td>
<td style="width: 21%"><kbd>array length</kbd></td>
<td style="width: 56%"><span>This reserves an array of <kbd>length</kbd> words. All these words are initialized to <kbd>0</kbd>.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Notice that the <kbd>set</kbd> instruction type (opcode <kbd>1</kbd>) is quite simple; it assigns the operand <span>to the accumulator</span>. Almost all the other assignment and arithmetic instruction types have one level of indirectness—their operand is the memory address of the data that must be operated on. However, the two instructions—<kbd>indirect_load</kbd> (opcode <kbd>4</kbd>) and <kbd>indirect_store</kbd> (opcode <kbd>5</kbd>)—have two levels of indirectness. Their operand is the memory address of a word—that is, the memory address of <span>the data that must be operated on.</span></p>
<p>Now that we have a powerful enough machine language, we can write a meaningful program using it.</p>
<h2 id="uuid-2acba33e-627d-4042-adca-2e40153696ca">Writing a very simple program</h2>
<p class="mce-root">To show you how to use this language, let's write some code with it. We will create a program that, when given a positive integer number in a memory word (in binary format), prints it in decimal notation.</p>
<p class="mce-root">Let's assume that the number to print is hardcoded as <kbd>6710</kbd>. When we write the algorithm in Rust, it is as shown in the following code snippet:</p>
<pre class="mce-root">fn main() {<br/>    let mut n: u16 = 6710;<br/>    let mut digits: [u16; 5] = [0; 5];<br/>    let mut pos: usize;<br/>    let number_base: u16 = 10;<br/>    let ascii_zero: u16 = 48;<br/>    <br/>    pos = 5;<br/>    loop {<br/>        pos -= 1;<br/>        digits[pos] = ascii_zero + n % number_base;<br/>        n /= number_base;<br/>        if n == 0 { break; }<br/>    }<br/>    for pos in pos..5 {<br/>        print!("{}", digits[pos] as u8 as char);<br/>    }<br/>}</pre>
<p>In the preceding code, the <kbd>n</kbd> variable is the unsigned 16-bit number to convert and print. The <kbd>digits</kbd> variable is a buffer that will contain the ASCII values of the generated digits. As a 16-bit number can have, at most, five decimal digits, an array of five digits is enough. The <kbd>pos</kbd> variable is the position of the current digit in the <kbd>digits</kbd> array.</p>
<p>The <kbd>number_base</kbd> variable is <kbd>10</kbd> as we are using decimal notation. The <kbd>ascii_zero</kbd> variable contains the ASCII code for the zeroth character (which is <kbd>48</kbd>).</p>
<p>The first loop computes any ASCII decimal digit by computing the remainder of <kbd>n</kbd> divided by 10 using the <kbd>%</kbd> operator, and by adding it to <kbd>ascii_zero</kbd>. Then, <kbd>n</kbd> is divided by the <kbd>number_base</kbd> variable to remove<span> </span><span>the least significant decimal digit</span><span> from it. The second loop prints</span> <span>the five generated digits </span><span>to the console.</span></p>
<p>The problem with this program is that it needs to use array indexing. Actually, <kbd>pos</kbd> is an index to the <kbd>digits</kbd> array. Machine language uses addresses, not indices; so, to mimic machine language, we must replace the type of <kbd>pos</kbd> with that of raw pointers, whose dereference operation is unsafe in Rust. Instead of counting up to five, we set an <kbd>end</kbd> pointer. When <kbd>pos</kbd> reaches this pointer, it will have finished the array.</p>
<p class="mce-root">So, let's translate our Rust program into a format that is more similar to what can be translated into machine language<span> </span><span>using raw pointers</span><span>:</span></p>
<pre class="mce-root">fn main() {<br/>    let mut n: u16 = 6710;<br/>    let mut digits: [u16; 5] = [0; 5];<br/>    let mut pos: *mut u16;<br/>    let number_base: u16 = 10;<br/>    let ascii_zero: u16 = 48;<br/>    let end = unsafe {<br/>        (&amp;mut digits[0] as *mut u16).offset(digits.len() as isize)<br/>    };<br/>    pos = end;<br/>    loop {<br/>        pos = unsafe { pos.offset(-1) };<br/>        unsafe { *pos = ascii_zero + n % number_base };<br/>        n /= number_base;<br/>        if n == 0 { break; }<br/>    }<br/>    while pos != end {<br/>        print!("{}", unsafe { *pos } as u8 as char);<br/>        pos = unsafe { pos.offset(1) };<br/>    }<br/>}</pre>
<p>In the preceding program, the unsafe <kbd>offset</kbd> method of raw pointers is used. When given a raw pointer, it generates another raw pointer by advancing by the specified number of positions<span> </span><span>in memory</span><span>.</span></p>
<p class="mce-root">To have a program that is even more similar to a machine language program, we should split all the Rust statements into elementary statements that correspond to machine instructions.</p>
<p>However, there is another problem—our accumulator register <span>will </span><span>some</span><span>ti</span><span>mes</span><span> </span><span>contain numbers and other times addresses. Using Rust, this is inconvenient because numbers and addresses have different types in Rust. Therefore, here, we will use two variables—</span><kbd>acc</kbd><span> (which represents the accumulator when it is used to store a number) and</span> <kbd>ptr_acc</kbd><span> (which represents the </span><span>accumulator when it is used to store an address—that is, a memory pointer). </span></p>
<p class="mce-root">Here is the obtained program, which is quite similar to a machine language program:</p>
<pre class="mce-root">fn main() {<br/>    let mut ptr_acc: *mut u16; // pointer accumulator<br/>    let mut acc: u16; // accumulator<br/>    let mut n: u16 = 6710;<br/>    let mut digits: [u16; 5] = [0; 5];<br/>    let mut pos: *mut u16;<br/>    let number_base: u16 = 10;<br/>    let ascii_zero: u16 = 48;<br/>    let one: u16 = 1;<br/>    <br/>    ptr_acc = unsafe {<br/>        (&amp;mut digits[0] as *mut u16).offset(digits.len() as isize)<br/>    };<br/>    pos = ptr_acc;<br/>    loop {<br/>        ptr_acc = pos;<br/>        ptr_acc = unsafe { ptr_acc.offset(-(one as isize)) };<br/>        pos = ptr_acc;<br/>        acc = n;<br/>        acc %= number_base;<br/>        acc += ascii_zero;<br/>        unsafe { *pos = acc };<br/>        acc = n;<br/>        acc /= number_base;<br/>        n = acc;<br/>        if n == 0 { break; }<br/>    }<br/>    for &amp;digit in &amp;digits {<br/>        print!("{}",<br/>            if digit == 0 { ' ' }<br/>            else { digit as u8 as char}<br/>        );<br/>    }<br/>}</pre>
<p>Notice that now, the statements after the empty line, except for the final <kbd>for</kbd> loop, are quite simple. They are only assignments, possibly combined with one operation, such as <kbd>%=</kbd>, <kbd>+=</kbd>, or <kbd>/=</kbd>. In addition, there is one <kbd>if</kbd> statement used to break the loop when the <kbd>n</kbd> variable is <kbd>0</kbd>.</p>
<p class="mce-root">This can be easily translated into our assembly language, as shown:</p>
<pre class="mce-root">n<br/>    word 6710<br/>digits<br/>    array 5<br/>pos<br/>    word 0<br/>number_base<br/>    word 10<br/>ascii_zero<br/>    word 48<br/>one<br/>    word 1<br/><br/>    set pos<br/>    store pos<br/>before_generating_digits<br/>    load pos<br/>    subtract one<br/>    store pos<br/>    load n<br/>    remainder number_base<br/>    add ascii_zero<br/>    store_indirect pos<br/>    load n<br/>    divide number_base<br/>    store n<br/>    jump_if_nonzero before_generating_digits<br/>    set digits<br/>    output 5<br/>    terminate 0</pre>
<p class="mce-root">This assembly language program can be manually translated into machine language.</p>
<p class="mce-root">As there are 5 data words, 1 data array of five words, 16 instructions occupying two words each, and the initial word, we have a total of <em>5 + 1 * 5 + 16 * 2 + 1 = 43</em> words. This number will be the value of the first word of our program.</p>
<p>Then, considering the required layout (the process length, followed by the instruction, <span>followed by the </span>data), we can compute the addresses of the jump destinations and the addresses of the data, obtaining the following code:</p>
<pre>0: 43<br/>1: set 39 // pos<br/>3: store 39 // pos<br/>5: before_generating_digits<br/>5: load 39 // pos<br/>7: subtract 42 // one<br/>9: store 39 // pos<br/>11: load 33 // n<br/>13: remainder 40 // number_base<br/>15: add 41 // ascii_zero<br/>17: store_indirect 39 // pos<br/>19: load 33 // n<br/>21: divide 40 // number_base<br/>23: store 33 // n<br/>25: jump_if_nonzero 5 // before_generating_digits<br/>27: set 34 // digits<br/>29: output 5<br/>31: terminate 0<br/>33: n: 6710<br/>34: digits: 0, 0, 0, 0, 0<br/>39: pos: 0<br/>40: number_base: 10<br/>41: ascii_zero: 48<br/>42: one: 1</pre>
<p><span>In the preceding code, notice that the symbolic names of the addresses are commented out.</span></p>
<p class="mce-root">Then, by replacing the symbolic codes with the opcodes and by removing the comments and line addresses, we get the machine language program as a comma-separated list of decimal numbers:</p>
<pre class="mce-root">43,<br/>1, 39,<br/>3, 39,<br/>2, 39,<br/>9, 42,<br/>3, 39,<br/>2, 33,<br/>12, 40,<br/>8, 41,<br/>5, 39,<br/>2, 33,<br/>11, 40,<br/>3, 33,<br/>15, 5,<br/>1, 34,<br/>7, 5,<br/>0, 0,<br/>6710,<br/>0, 0, 0, 0, 0,<br/>0,<br/>10,<br/>48,<br/>1</pre>
<p class="mce-root">For example, we start with the following line:</p>
<pre>1: set 39 // pos</pre>
<p>The preceding line becomes the following:</p>
<pre>1, 39,</pre>
<p>Because the <kbd>1:</kbd><span> </span><span>line address </span><span>has been removed, the </span><kbd>set</kbd><span> </span><span>symbolic code </span><span>has been replaced by its opcode (</span><kbd>1</kbd><span>), the</span> <kbd>// pos</kbd><span> </span><span>comment</span><span> </span><span>has been removed, and two commas have been added to separate the numbers.</span></p>
<p>Now, we can build a Rust program that interprets this program. You can find it in the <kbd>word_machine_convert</kbd><span> </span><span>project</span><span>.</span></p>
<p>If you execute the <kbd>cargo run</kbd> command on this project, the program is compiled in a short time because it has no dependencies. The execution will simply print <kbd>6710</kbd> with a leading space. The name of this project means to convert a number using a machine language that uses word addressing.</p>
<p class="mce-root">The <kbd>main</kbd> function of this Rust program just passes the preceding list of numbers to the <kbd>execute</kbd> function.</p>
<p class="mce-root">This function begins with the following code:</p>
<pre>fn execute(program: &amp;[u16]) -&gt; u16 {<br/>    let mut acc: u16 = 0;<br/>    let mut process = vec![0u16; program[0] as usize];<br/>    process[..program.len()].copy_from_slice(program);<br/>    let mut ip = 1;<br/>    loop {<br/>        let opcode = process[ip];<br/>        let operand = process[ip + 1];<br/>        //println!("ip: {} opcode: {} operand: {} acc: {}",<br/>        //ip, opcode, operand, acc);<br/>        ip += 2;</pre>
<p>The previously mentioned function (<kbd>execute</kbd>) emulates an extremely simple machine language processor that addresses memory as a slice of 16-bit words. This function, if it returns, returns the operand of the <kbd>terminate</kbd> instruction that it may execute.</p>
<p>The <kbd>acc</kbd> variable represents the accumulator register. The <kbd>process</kbd> variable represents the actual runtime content of memory. Its size, in words, is the number specified by the first word of the program. It makes no sense to have a process shorter than the program that it runs because some data would be lost.</p>
<p>However, it makes sense to have a process larger than the programs that it runs because in doing so, it allocates memory that will be used by code with no need to declare it in the program. In this way, you can have a program with a few words using a memory space of up to 65,536 words, which is 128<span> </span><strong><span>Kibibytes</span></strong><span> (</span><strong><span>KiB</span></strong><span>).</span></p>
<p>The first part of the <kbd>process</kbd> variable is initialized with the contents of <kbd>program</kbd>, received as an argument of the <kbd>execute</kbd> function.</p>
<p>The <kbd>ip</kbd> variable is the instruction pointer, which is initialized to <kbd>1</kbd>—that is, it points to the second word, where there is a first instruction to execute.</p>
<p>Then, there is the processing loop. Every instruction has exactly one opcode and one operand, and so they are loaded into the respective variables. Then, there is a debugging statement that is commented out; this can be useful if your program does not do what you hoped.</p>
<p>After executing any instruction, the<span> </span><span>instruction</span><span> that follows it will </span><span>usually</span><span> </span><span>be executed, and so the instruction pointer is incremented right away by two words to skip the current instruction</span><span>. The exceptions are the <kbd>jump</kbd> instructions and </span><kbd>terminate</kbd> <span>instructions. The <kbd>jump</kbd> instructions, if their condition is satisfied, will change the instruction pointer </span><span>again</span><span> </span><span>and the</span> <kbd>terminate</kbd> <span>instruction will jump out of the processing loop, and out of the</span> <kbd>execute</kbd> <span>function, too.</span></p>
<p>The rest of the function is a large <kbd>match</kbd> statement, which is needed to process the current instruction. Here are its first few lines:</p>
<pre>match opcode {<br/>    0 =&gt; // terminate<br/>        { return operand }<br/>    1 =&gt; // set<br/>        { acc = operand }<br/>    2 =&gt; // load<br/>        { acc = process[operand as usize] }</pre>
<p>The behavior of each arm of this kind of a <kbd>match</kbd> statement is quite simple as it is meant to be executed by hardware. For example, if the current instruction is <kbd>terminate</kbd>, the function returns the operand; if it is <kbd>set</kbd>, the operand is assigned to the accumulator; if it is <kbd>load</kbd>, the memory word whose address is the operand is assigned to the accumulator; and so on.</p>
<p>Here is a pair of arithmetic instructions:</p>
<pre>9 =&gt; // subtract<br/>    { acc = acc.wrapping_sub(process[operand as usize]) }<br/>10 =&gt; // multiply<br/>    { acc = acc.wrapping_mul(process[operand as usize]) }</pre>
<p>In all modern computers, integer numbers are stored in two complementary formats and they perform their operations accordingly. This has several advantages:</p>
<ul>
<li>A single arithmetic operation can work if the operands are both interpreted as signed numbers or unsigned numbers (but not one signed number and the other unsigned).</li>
<li>If an addition or subtraction causes an integer to overflow and then another operation causes the result to go back into the allowed range, the result is still valid.</li>
</ul>
<p>In high-level languages, such as Rust, arithmetic overflow is <span>usually </span><span>not allowed by default. In Rust, the arithmetic of overflow of basic operators causes panic when it shows a message such as </span><kbd>attempt to add with overflow</kbd><span>. To allow two complementary arithmetics, the Rust standard library provides</span><span> </span><span>the corresponding wrapping method</span><span> for any operator, which is the one usually implemented in machine language. To use it, instead of writing</span> <kbd>a + b</kbd><span>, you write </span><kbd>a.wrapping_add(b)</kbd><span>; instead </span><span>of writing </span><kbd>a - b</kbd><span>, you write </span><kbd>a.wrapping_sub(b)</kbd><span>, and so on for the other operators.</span></p>
<p>The <kbd>jump</kbd> instructions are a bit different from other instructions, as shown:</p>
<pre>15 =&gt; // jump_if_nonzero<br/>    { if acc != 0 { ip = operand as usize } }<br/>16 =&gt; // jump_if_positive<br/>    { if (acc as i16) &gt; 0 { ip = operand as usize } }</pre>
<p>In the preceding code, the <kbd>jump_if_nonzero</kbd> instruction checks the value of the accumulator and sets the instruction pointer to the specified value only if this value is not <kbd>0</kbd>.</p>
<p>The <kbd>jump_if_positive</kbd> instruction checks whether the value of the accumulator is positive, interpreting it as a signed number. Without the <kbd>as i16</kbd> clause, the check would <span>always</span><span> succeed as the</span> <kbd>acc</kbd> <span>variable is unsigned.</span></p>
<div class="packt_tip">Notice that in Rust, an unsigned number can be converted into a signed one, even if the result is negative; for example, the expression <kbd>40_000_u16 as i16 == -25_536_i16</kbd> is true.</div>
<p>The <kbd>input</kbd> and <kbd>output</kbd> instructions are unusually complex, and they even interact with the operating system. Of course, they are not real-world machine language instructions. They were added to this pseudo-machine language just to be able to write a complete program with reasonable effort. In practice, in a real-world machine language, I/O is performed using a convoluted sequence of instructions or by calling an operating system service.</p>
<p>So, we have seen how to interpret a machine language program. It was quite a trivial program, however; so, in the next section, we'll look at a more interesting and complex machine language program.</p>
<h2 id="uuid-cad3794e-0fd9-41b9-9ed7-dacbfe20f0ec">A more complex program – the sieve of <span>Eratosthenes</span></h2>
<p class="mce-root">Now, let's consider a more realistic but challenging problem—implementing an algorithm <span>to print all the prime numbers that are less than a number, </span><em>N</em><span>, where </span><em>N</em><span> is typed in by the user at runtime. This is called </span>the <strong>sieve of Eratosthenes </strong>algorithm.</p>
<p class="mce-root">Here is the Rust version of this program:</p>
<pre>fn main() {<br/>    let limit;<br/>    loop {<br/>        let mut text = String::new();<br/>        std::io::stdin()<br/>            .read_line(&amp;mut text)<br/>            .expect("Cannot read line.");<br/>        if let Ok(value) = text.trim().parse::&lt;i16&gt;() {<br/>            if value &gt;= 2 {<br/>                limit = value as u16;<br/>                break;<br/>            }<br/>        }<br/>        println!("Invalid number (2..32767). Re-enter:")<br/>    }<br/><br/>    let mut primes = vec![0u8; limit as usize];<br/>    for i in 2..limit {<br/>        if primes[i as usize] == 0 {<br/>            let mut j = i + i;<br/>            while j &lt; limit {<br/>                primes[j as usize] = 1;<br/>                j += i;<br/>            }<br/>        }<br/>    }<br/><br/>    for i in 2..limit {<br/>        if primes[i as usize] == 0 {<br/>            print!("{} ", i);<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding code, the first 14 lines of the <kbd>main</kbd> function ask the user to type in a number until the typed number is between <kbd>2</kbd> and <kbd>32767</kbd>.</p>
<p>The next group of statements allocates a vector of bytes to store the numbers that have been detected as non-primes. Initially, it contains all zeros, meaning that every number in the required range could be a prime. Then, all the numbers of the range are scanned in increasing order, and for each of them, if it is still considered a prime number, all of its multiples are marked as non-primes.</p>
<p>The last group of statements <span>again</span><span> </span><span>scans all the numbers and prints only those that are still marked as prime numbers.</span></p>
<p class="mce-root">The difficulty of this program is that it needs to allocate memory to be used by a vector. Our machine language does not allow memory allocation. We can pre-allocate an array with the maximum desired size, say, 400 words.</p>
<p class="mce-root">To pre-allocate such an array, it is enough to specify that the process size is equal to the program size plus 400 words. In doing this, when the process begins its execution, it will allocate the required space and it will initialize it to be a sequence of zeros.</p>
<p>As you can imagine, the corresponding assembly and machine language program is quite complex. It can be found in the <kbd>word_machine_sieve</kbd> project.</p>
<p>If you run it and then type in a number that isn't larger than 400, all the prime numbers that are smaller than the typed number will be printed to the console. The interpreter is identical to the one used in the preceding projects, but there is another machine language program in the <kbd>main</kbd> function.</p>
<p>This machine language program is much larger than that of the preceding project, and it is explained by comments. T<span>he assembly language is equivalent in</span><span> any instruction or data item in a comment. Here is the initial part, containing four instructions:</span></p>
<pre>600, // 0:<br/>// Let the user input the digits of the limit number.<br/>1, 190, // 1: set digits<br/>6, 5, // 3: input 5<br/>// Initialize digit pointer.<br/>1, 190, // 5: set digits<br/>3, 195, // 7: store pos </pre>
<p>The process size, <kbd>600</kbd>, is 400 words, which is larger than the program size by 200 words.</p>
<p>There are some explanatory comments interleaved, such as those in the second and fifth lines.</p>
<p>The third line is a <kbd>set</kbd> instruction (opcode 1), with operand <kbd>190</kbd>. The comment explains that this instruction begins at address <kbd>1</kbd> and corresponds with the <kbd>set digits</kbd><span> </span><span>assembly instruction</span><span>.</span></p>
<p>As you can imagine, it is almost impossible to write a machine language program <span>directly</span> without passing through its assembly language version, and it is an error-prone chore<em> </em>to <span>manually </span>translate an assembly language into machine language. Fortunately, it is rather easy to write an assembler program that does this for you. You can do this by using the compiling techniques explained in the preceding chapter.</p>
<p>In the next section, we will look at a more realistic machine language and how to use the <kbd>nom</kbd> parsing library to ease its interpretation.</p>
<h1 id="uuid-2c5fbef7-20f0-44a4-9e51-574f3d50eca1">Defining a byte-addressing machine language</h1>
<p>In <span>the preceding section, we saw</span> <span>a different kind </span>of machine language. However, this kind of machine language is quite unrealistic for several reasons:</p>
<ul>
<li>It addresses memory word by word. This was common in the early days of computer technology, until around 1970. Then, it became more and more common to have processors that address single bytes of memory. Today, probably every processor in production can address single bytes of memory.</li>
<li>It has instructions of the same length. There has probably never been a machine language where all the instructions are of the same length. A very simple instruction, such as a <span><strong>No-Operation</strong> </span>(<strong><span>NOP</span></strong>), can stay in a single byte, while there are processors that have instructions spanning many bytes.</li>
<li>Any kind of operation operates on a 16-bit word for real-world processors, for any kind of operation—for example, addition. There can be an instruction that operates on single bytes, adding an 8-bit byte to another byte, another instruction that does the same thing but on 16-bit words, adding a word to another word, another instruction for 32-bit double-words, and even <span>instructions that operate on </span>larger bit sequences.</li>
<li>It has just one processor register—the accumulator. Real-world processors have much more processor registers.</li>
<li>It has few operations available. Real-world machine languages have more possible operations, such as logical operations, function calls and function return instructions, stack manipulation operations, and increment and decrement operators.</li>
</ul>
<p>Here, we will change our machine language to introduce the following missing features:</p>
<ul>
<li>Byte addressing</li>
<li>Variable-length instructions</li>
<li>Instructions to load or store a single byte, in addition to those to load or store words</li>
</ul>
<p><span>So, we apply the following changes to our</span> byte-addressing <span>machine language</span><span>:</span></p>
<ul>
<li>Every address represents the position of a memory byte, not the position of a memory word.</li>
<li>Every opcode occupies only one byte, instead of the word as was the case in the preceding language.</li>
<li>While most instruction types still have a one-word operand, three instruction types have a 1-byte operand. They are <kbd>terminate operand</kbd>, <kbd>input length</kbd>, and <kbd>output <span>length</span></kbd>.</li>
<li>Four instruction types are added to the language to manipulate a single byte.</li>
</ul>
<p>To understand this new machine language, it is important to realize that every 16-bit word contains 2 bytes, one containing the eight least significant bits of the number and the other containing the eight most significant bits of the number. The first byte is named the <strong>low byte</strong> and the other is named the <strong>high byte</strong>. When a byte inside a word is manipulated, it is important to know whether it is the low byte or the high byte of that word.</p>
<p>The new instruction types are defined in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10%"><strong>Opcode</strong></td>
<td style="width: 24.7055%"><strong>Assembly syntax</strong></td>
<td style="width: 54.2945%"><strong><span>Description</span></strong></td>
</tr>
<tr>
<td style="width: 10%"><kbd>20</kbd></td>
<td style="width: 24.7055%"><kbd>load_byte address</kbd></td>
<td style="width: 54.2945%">This copies the value of the byte at that address to the low byte of the accumulator. <span>The high byte of the accumulator is set to <kbd>0</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>21</kbd></td>
<td style="width: 24.7055%"><kbd>store_byte address</kbd></td>
<td style="width: 54.2945%">This copies the low byte of the value of the accumulator to that <span>address</span><span>. </span><span>The high byte of the accumulator is not used.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>22</kbd></td>
<td style="width: 24.7055%"><kbd><span>indirect_load_byte address</span></kbd></td>
<td style="width: 54.2945%">This copies the byte value whose address is specified at that address to the low byte of the accumulator.<span> </span><span>The high byte of the accumulator is set to <kbd>0</kbd>.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>23</kbd></td>
<td style="width: 24.7055%"><kbd><span>indirect_store_byte address</span></kbd></td>
<td style="width: 54.2945%">This copies the low byte of the value of the accumulator to the address specified at that address. <span>The high byte of the accumulator is not used.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>These four instructions are needed because the <kbd>load</kbd>, <kbd>store</kbd>, <kbd>indirect_load</kbd>, and <kbd>indirect_store</kbd> instruction types still transfer whole words, while we also need to read or write a single byte of memo<span>ry without re</span><span>ading or writing the byte next to the specified address.</span></p>
<p>As a result of these changes, in the previous machine language, every instruction occupied four bytes. However, in this new language, the three instruction types—<kbd>terminate</kbd>, <kbd>input</kbd>, and <kbd>output</kbd>—occupy only 2 bytes and all the other<span> instruction types </span>occupy 3 bytes.</p>
<p>Notice that all the other instruction types remain unchanged and the size of the accumulator and the instruction pointer is still 16 bits.</p>
<p><span>Havin</span>g byte-addressing capability, together with words spanning sever<span>al bytes, raises an issue, however. This is the so-called <strong>endianness</strong> issue, described in the next section.</span></p>
<h2 id="uuid-a9f32f80-aa41-4fe9-bf0d-18d2ad004ab0">Coping with the endianness issue</h2>
<p>Consider a word in the accumulator with a value of <kbd>256</kbd>. The low byte of this word is <kbd>0</kbd> and the high byte is <kbd>1</kbd>. This word will be stored at the <kbd>1000</kbd><span> </span><span>memory address</span><span>. Because this address </span><span>now</span><span> </span><span>refers to a single byte, not to a two-byte word, the</span> <kbd>store</kbd> <span>instruction must </span><span>also</span><span> </span><span>access another memory byte to store a word. For every computer system, the other </span><span>byte that is needed is one with the following consecutive address, and so it is at address <kbd>1001</kbd>.</span></p>
<p>So, our accumulator will be stored in the 2 bytes with addresses <kbd>1000</kbd> and <kbd>1001</kbd>. However, the low byte of number <kbd>256</kbd>, whose value is <kbd>0</kbd>, could be stored at address <kbd>1000</kbd> or at address <kbd>1001</kbd>.</p>
<p>In the first case, when the low byte is stored at address <kbd>1000</kbd>, the high byte, whose value is <kbd>1</kbd>, will be stored at address <kbd>1001</kbd>. Here is the memory layout of this case:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10%"><strong>Address</strong></td>
<td style="width: 13%"><strong>Memory content</strong></td>
</tr>
<tr>
<td style="width: 10%"><kbd>1000</kbd></td>
<td style="width: 13%">00000000</td>
</tr>
<tr>
<td style="width: 10%"><kbd>1001</kbd></td>
<td style="width: 13%">00000001</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the second case, <span>when the low byte is stored at address <kbd>1001</kbd>, the high byte </span><span>will be stored at address <kbd>1000</kbd></span>. <span>Here is the memory layout of this case:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10%"><strong>Address</strong></td>
<td style="width: 13%"><strong>Memory contents</strong></td>
</tr>
<tr>
<td style="width: 10%"><kbd>1000</kbd></td>
<td style="width: 13%">00000001</td>
</tr>
<tr>
<td style="width: 10%"><kbd>1001</kbd></td>
<td style="width: 13%">00000000</td>
</tr>
</tbody>
</table>
<p> </p>
<p>This is just a matter of<span> </span>convention.</p>
<p>Unfortunately, some important computer vendors chose one convention and some other important computer vendors chose the other. Some computer hardware can even be programmed to change convention at runtime, and so it is up to the operating system to choose the convention.</p>
<p>The convention where the low byte has a lower memory address is named <strong>little-endian</strong>, which is shown in the first of the previous two tables. The other convention, <span>where the high byte has a lower memory address, is named <strong>big-endian</strong>, and it is shown in the second of the preceding two tables. The issue itself is named the <strong>endianness</strong> issue.</span></p>
<p><span>For our machine language, we chose little-endian.</span></p>
<p>Now that we have defined the new byte-addressing machine language and we have chosen to adopt the little-endian convention for it, we can write an interpreter for this machine language.</p>
<h1 id="uuid-45206412-6f6b-4c9a-b63d-c2d4a3677ede">The nom_byte_machine project</h1>
<p>Now that we have a new machine language, we can write some programs using it and try to build an interpreter for these programs. In addition, it is possible to use the <kbd>nom</kbd> library, already seen in <a href="24e48581-b784-455c-bb17-b08a380cdab7.xhtml">Chapter 8</a>, <em>Using a Parser Combinator for Interpreting and Compiling</em>, to ease the building of this sort of interpreter.</p>
<p>However, before we start coding, let's consider the possible techniques to <span>execute a machine language program. In fact, </span>there are at least three possible ways to execute a machine language program without having real hardware:</p>
<ul>
<li><strong>Technique 1</strong>: Interpreting it just as the hardware would interpret it. This is the technique used <span>in the previous sections</span> to interpret the sieve of Eratosthenes program in the <kbd>word_machine_sieve</kbd> project.</li>
<li><strong>Technique 2</strong>: First, parsing it all and transforming it into a high-level data structure, then interpreting this data structure.</li>
<li><strong>Technique 3</strong>: Translating it into another programming language, and then using an interpreter or a compiler for this programming language.</li>
</ul>
<p><em>Technique 1</em> is the only one of the three that can obtain the correct result for any possible program. The other two techniques <span>only</span><span> </span><span>work if the program is well </span><span>formed</span><span>, following these rules:</span></p>
<ol>
<li>It begins with a little-endian word containing the size of the process in bytes.</li>
<li>After the initial word, there is a sequence of valid machine language instructions, with no interleaved spaces or data.</li>
<li>The <kbd>Terminate</kbd> instruction occurs once—and only once—as the last instruction so that it marks the end of the sequence of instructions. After this, there is only data left.</li>
<li>No statement writes on the instructions; only the data can be changed. So, the program is not self-modifying; or, said in another way, the program instructions are the same as the process instructions.</li>
</ol>
<p class="mce-root">The <kbd>nom_byte_machine</kbd> project implements all three techniques and applies them to a well-formed machine language program. This program is a version of the sieve algorithm seen in the preceding section, implemented for the byte-addressing machine language.</p>
<p class="mce-root"/>
<p>First of all, let's try to build and run the project by typing <kbd>cargo run</kbd> in the <kbd>project</kbd> folder. The build will take some time because it uses the <kbd>nom</kbd> library. The execution starts by creating the <kbd>prog.c</kbd><span> </span><span>file</span><span>, containing a C language version of the machine language program, and printing the following on the console:</span></p>
<pre><strong>Compiled to prog.c.</strong></pre>
<p>Then, the program interprets the program using the first technique described earlier. This causes it to wait until the user types in a number. You should type in a number between <kbd>0</kbd> and <kbd>400</kbd> and press <em>Enter</em>.</p>
<p>Some prime numbers will be printed using <em>Technique 1</em>, and then <span>the program interprets the same program using <em>Technique 2</em>, and, therefore, it waits again until the user types in a number. You should type in a number again and press <em>Enter</em>.</span></p>
<p>For example, if you entered <kbd>100</kbd><span> the first time</span><span> and the second time you entered </span><kbd>40</kbd><span>, then the console should display this:</span></p>
<pre><strong>Compiled to prog.c.</strong><br/><strong>100</strong><br/><strong>    2    3    5    7   11   13   17   19   23   29   31   37   41   43   47   53</strong><br/><strong>   59   61   67   71   73   79   83   89   97</strong><br/><strong>Return code: 0</strong><br/><strong>40</strong><br/><strong>    2    3    5    7   11   13   17   19   23   29   31   37</strong><br/><strong>Return code: 0</strong></pre>
<p>After executing it, the <kbd>prog.c</kbd><span> </span><span>file </span><span>will exist in the</span> <kbd>project</kbd> <span>folder. Using a Unix-like environment, you can compile it with the following command:</span></p>
<pre><strong>cc prog.c -o prog.exe</strong></pre>
<p>This will create the <kbd>prog.exe</kbd><span> </span><span>file</span><span>. Then, you can run it with the following </span>command<span>:</span></p>
<p> </p>
<pre><strong>./prog.exe</strong></pre>
<p>Of course, this program has the same behavior as the previously interpreted program. It first asks for a number, and if, for example, you type in <kbd>25</kbd>, the output is this:</p>
<pre><strong>25</strong><br/><strong>    2    3    5    7   11   13   17   19   23</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>As this project is somewhat complex, its source code has been split into several source files. They are as follows:</p>
<ul>
<li><kbd>main.rs</kbd>: This contains the machine language program and the calls to the functions contained in the other source files.</li>
<li><kbd>instructions.rs</kbd>: This contains the definitions of the machine language instructions and the <kbd>nom</kbd> parsers to recognize them.</li>
<li><kbd>emulator.rs</kbd><span>: This is a low-level interpreter of the machine code. Every instruction is first parsed and then executed.</span></li>
<li><kbd>parsing_interpreter.rs</kbd><span>: This first parses all the instructions of the machine code, constructing a data structure, and then executes this data structure.</span></li>
<li><span><kbd>translator.rs</kbd>: This translates all the instruction of the machine code into C language code and adds some C language lines to create a valid C program.</span></li>
</ul>
<p>Let's look at each of the files in the following sections.</p>
<h2 id="uuid-b51c138d-5b87-4655-ac1b-afd0cfa93d06">Understanding the main.rs source file</h2>
<p>The <kbd>main.rs</kbd> file contains the <kbd>main</kbd> function, which begins with the following lines:</p>
<pre>let prog = vec![<br/>    187, 2, // 0: 699<br/>    // Let the user input the digits of the limit number.<br/>    1, 28, 1, // 2, 0: set digits<br/>    6, 5, // 5, 0: input 5<br/>    // Initialize digit pointer.<br/>    1, 28, 1, // 7, 0: set digits<br/>    3, 33, 1, // 10, 0: store pos</pre>
<p>This machine language program is similar to the one used in the<span> </span><kbd>word_machine_sieve</kbd><span> </span>project. While in those programs the numbers represented words (<kbd>u16</kbd>), now they represent bytes (<kbd>u8</kbd>).</p>
<p>First, read the comments, except for the descriptive comments that a<span>re on their own in a</span><span> </span><span>line. These comments contain the address of the current instruction or data, followed by a colon</span><span>, followed by an assembly statement.</span></p>
<p>The first line represe<span>nts what starts at address <kbd>0</kbd>. In this case, this is number <kbd>699</kbd>, which is the required length of the process. As we said in the previous section, we adopted the</span> little-endian convention <span>to store words, and so </span><span>this number is stored as the pair of bytes,</span> <kbd>187, 2</kbd><span>, which means <em>2 x 256 + 187</em>.</span></p>
<p class="mce-root"/>
<p>The second line is a descriptive comment. The third line represents what starts at address <kbd>2</kbd>, which in little-endian notation is <kbd>2, 0</kbd>. The content is the <kbd>set</kbd><span> </span><span>instruction</span><span>, with the address of the </span><kbd>digits</kbd><span> </span><span>label</span><span> as its operand. The opcode of the</span> <kbd>set</kbd> <span>instruction is</span> <kbd>1</kbd><span> and the </span><kbd>digits</kbd><span> </span><span>label </span><span>is at address <kbd>284</kbd>, which in little-endian notation is</span> <kbd>28, 1</kbd><span>. So, we have,</span> <kbd>1, 28, 1</kbd><span> on this line.</span></p>
<p>The fourth line <span>represents what starts at address <kbd>5</kbd>, which is an instruction that in assembly is <kbd>input 5</kbd> and in machine code is <kbd>6, 5</kbd>. </span>The rest of the program is similar.</p>
<p>The last part of the program is the data section. Here is a snippet of it:</p>
<pre>0, 0, 0, 0, 0, // 28, 1: digits: array 5<br/>0, 0, // 33, 1: pos: word 0<br/>10, 0, // 35, 1: number_base: word 10</pre>
<p>The first line represents an array of 5 bytes, all of them initialized to <kbd>0</kbd>. Its label is <kbd>digits</kbd> and its address is <kbd>284</kbd>, which is represented by the <kbd>28, 1</kbd><span> </span><span>pair</span><span>.</span></p>
<p>The second line represents a word initialized to <kbd>0</kbd> whose label is <kbd>pos</kbd> and address is the <kbd>33, 1</kbd><span> </span><span>pair</span><span>, which is 5 bytes after the</span> <kbd>digits</kbd><span> address.</span></p>
<p>The third line represents a word initialized to 10 (represented by the <kbd>10, 0</kbd><span> </span><span>pair</span><span>) whose label is</span> <kbd>number_base</kbd><span> and whose address is the </span><kbd>35, 1</kbd><span> </span><span>pair</span><span>, which is two bytes after the</span> <kbd>pos</kbd> <span>address.</span></p>
<p>The main function ends with the following lines:</p>
<pre>let _ = translator::translate_program_to_c(&amp;prog, "prog.c");<br/><br/>let return_code = emulator::execute_program(&amp;prog).unwrap();<br/>println!("\nReturn code: {}", return_code);<br/><br/>let mut parsed_program = parsing_interpreter::parse_program(&amp;prog).unwrap();<br/>let return_code = parsing_interpreter::execute_parsed_program(&amp;mut parsed_program);<br/>println!("\nReturn code: {}", return_code);</pre>
<p>From the preceding code, the first statement invokes a function that translates the <kbd>prog</kbd> machine language program into a C language file with the specified name.</p>
<p>The second <span>statement interprets the program using the first technique instruction by instruction.</span></p>
<p class="mce-root"/>
<p>The last block of statements first invokes the <kbd>parse_program</kbd> <span>statement, which translates the program into a data structure and stores it in the <kbd>parsed_program</kbd> variable, and then the <kbd>execute_parsed_program</kbd> function is invoked to execute this data structure.</span></p>
<p>The rest of the Rust program implements these functions and we are going to use the <kbd>nom</kbd> library for this purpose.</p>
<h2 id="uuid-c01b791a-c93d-43e7-a0c1-e1e4b640bd8f">Using the Nom library</h2>
<p>The code that will implement what is described in this section can be found in the <kbd>instructions.rs</kbd> source file.</p>
<p>In the preceding chapters, we saw how to use the <kbd>nom</kbd> library to parse text, which is string slices. Well, <kbd>nom</kbd> is not limited to text, however; it can also be used to parse binary data, which is byte slices. In fact, it was created just for that, and the capability to parse strings was added later.</p>
<p>Here, we are going to use the binary parsing capability of <kbd>nom</kbd> to process our machine language.</p>
<p>Parsing a binary file is no more difficult than parsing a text file. The only difference between them is that when parsing a text file, the parsed text is a reference to a string slice, with an <kbd>&amp;str</kbd><span> </span><span>type</span><span>, while when parsing a binary file, the parsed text is a reference to a slice of bytes, with an </span><kbd>&amp;[u8]</kbd><span> type.</span></p>
<p>For example, this is the signature of a parser that recognizes an <kbd>add</kbd> instruction:</p>
<pre>fn parse_add(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Instruction&gt; {</pre>
<p>The <kbd>parse_add</kbd> function takes a reference to a slice of bytes<span> </span><span>as input</span><span> and, of course, its remaining sequence is still </span><span>a reference to a slice of bytes. We want its return value to </span><span>fully</span><span> </span><span>describe the parsed instruction, and so the custom </span><kbd>Instruction</kbd> <span>type is used.</span></p>
<p>This type can be defined in the following way:</p>
<pre>#[derive(Debug, Clone, Copy)]<br/>enum Instruction {<br/>    Terminate(u8),<br/>    Set(u16),<br/>    Load(u16),<br/>    Store(u16),<br/>    IndirectLoad(u16),<br/>    IndirectStore(u16),<br/>    Input(u8),<br/>    Output(u8),<br/>    Add(u16),<br/>    Subtract(u16),<br/>    Multiply(u16),<br/>    Divide(u16),<br/>    Remainder(u16),<br/>    Jump(u16),<br/>    JumpIfZero(u16),<br/>    JumpIfNonZero(u16),<br/>    JumpIfPositive(u16),<br/>    JumpIfNegative(u16),<br/>    JumpIfNonPositive(u16),<br/>    JumpIfNonNegative(u16),<br/>    LoadByte(u16),<br/>    StoreByte(u16),<br/>    IndirectLoadByte(u16),<br/>    IndirectStoreByte(u16),<br/>    Byte(u8),<br/>}</pre>
<p>From the preceding code snippet, every instruction type is a variant of the <kbd>Instruction</kbd> enum, and these variants have a parameter to store the value of the operator. The <kbd>Terminate</kbd>, <kbd>Input</kbd>, and <kbd>Output</kbd><span> </span><span>variants </span><span>have a</span> <kbd>u8</kbd> <span>parameter, while the other instruction types have a</span> <kbd>u16</kbd> <span>parameter. Notice that the last variant is not an instruction; it is</span> <kbd>Byte(u8)</kbd><span>, which represents a data byte contained in the process.</span></p>
<p>Using a Rust enum, it is quite easy to encapsulate the operands of the instructions<span> </span><span>in a variant</span><span>, even if there are more than one, as is typical of real-world machine languages. The operands are always rather small objects, and so it is efficient to derive the </span><kbd>Copy</kbd> <span>trait for the <kbd>Instruction</kbd> enum.</span></p>
<p>The body of the <kbd>parse_add</kbd> function is as follows:</p>
<pre>preceded(tag("\x08"), map(le_u16, Instruction::Add))(input)</pre>
<p>The <kbd>preceded</kbd> parser combinator, already seen in preceding chapters, gets two parsers, applies them in sequence, discards the result of the first one, and returns the result of the second one.</p>
<p>Its first parser is <kbd>tag("\x08")</kbd>. <span>In the preceding chapters, w</span>e already saw the <kbd>tag</kbd> function used as a parser that can recognize a literal string slice. In fact, it can <span>also </span>recognize a literal sequence of bytes, specified as a literal string. To specify a byte using a number instead of an ASCII character, a hexadecimal escape sequence is appropriate. So, this parser recognizes a byte as having a value of <kbd>8</kbd>, which is the opcode of the <kbd>add</kbd> instruction.</p>
<p class="mce-root"/>
<p>The second parser processed by <kbd>preceded</kbd> must recognize a little-endian 2-byte operand. So, the <kbd>le_u16</kbd> parser is used for this. Its name means little-endian u16. There is also a corresponding <kbd>be_u16</kbd> to recognize a word using the big-endian byte order.</p>
<p>The <kbd>le_u16</kbd><span> parser </span><span>just</span><span> </span><span>returns a</span> <kbd>u16</kbd> <span>value. However, we want an </span><kbd>Instruction::Add</kbd> <span>object to encapsulate this value. So, the</span> <kbd>map</kbd> <span>function is used to create an</span> <kbd>Add</kbd> <span>object containing the parsed word.</span></p>
<p>So, the body of <span>the </span><kbd>parse_add</kbd><span> function first checks whether there are 8 bytes, then discards them; then, it reads a pair of bytes to build a 16-bit number according to the little-endian byte order, then returns an <kbd>Add</kbd> object containing this word.</span></p>
<p>For all the instructions with a word operand, a similar parser can be created. However, for the instructions <span>with a byte operand, a different operand parser must be used. When parsing a single byte, there is no endianness issue; however, for terminological consistency, the <kbd>le_u8</kbd> parser will be used, even if the <kbd>be_u8</kbd> parser could have been used just as well as it is identical to it.</span></p>
<p><span>So, here the parser is used to recognize a <kbd>terminate</kbd> instruction, with opcode <kbd>0</kbd>:</span></p>
<pre>fn parse_terminate(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Instruction&gt; {<br/>    preceded(tag("\x00"), map(le_u8, Instruction::Terminate))(input)<br/>}</pre>
<p>We invoke <kbd>parse_add</kbd> when we want to recognize an <kbd>add</kbd> instruction and <kbd>parse_terminate</kbd> when we want to <span>recognize a </span><kbd>terminate</kbd><span> instruction; however, when we want to recognize any possible instruction, we must combine all the parsers for all the instructions</span><span> </span><span>as alternatives</span><span> using the</span> <kbd>alt</kbd> <span>parser combinator, already seen in the preceding chapters. </span></p>
<p><span>This parser combinator has a limitation, however—it cannot combine more than 20 parsers. Actually, we have 24 instruction types, and so 24 parsers to combine. This issue can </span><span>easily</span><span> </span><span>be overcome by nesting the use of</span> <kbd>alt</kbd><span>. Here is the resulting function:</span></p>
<pre>fn parse_instruction(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Instruction&gt; {<br/>    alt((<br/>        alt((<br/>            parse_terminate,<br/>            parse_set,<br/>            parse_load,<br/>            parse_store,<br/>            parse_indirect_load,<br/>            parse_indirect_store,<br/>            parse_input,<br/>            parse_output,<br/>            parse_add,<br/>            parse_subtract,<br/>            parse_multiply,<br/>            parse_divide,<br/>            parse_remainder,<br/>            parse_jump,<br/>            parse_jump_if_zero,<br/>            parse_jump_if_nonzero,<br/>            parse_jump_if_positive,<br/>            parse_jump_if_negative,<br/>            parse_jump_if_nonpositive,<br/>            parse_jump_if_nonnegative,<br/>        )),<br/>        alt((<br/>            parse_load_byte,<br/>            parse_store_byte,<br/>            parse_indirect_load_byte,<br/>            parse_indirect_store_byte,<br/>        )),<br/>    ))(input)<br/>}</pre>
<p>From the preceding code, the <kbd>parse_instruction</kbd> function uses <kbd>alt</kbd> to combine just two parsers; the first one uses <kbd>alt</kbd> to combine the parsers for 20 instructions and the other one uses <kbd>alt</kbd> to combine the parsers for the remaining 4 instructions. When a byte slice is passed to this function, it returns the only instruction that can be parsed from it or an error if no instruction is recognized.</p>
<p>The <kbd>Instruction</kbd> enum implements the <kbd>len</kbd> method, which is useful to find out the length of the instruction. It is given as follows:</p>
<pre>impl Instruction {<br/>    pub fn len(self) -&gt; usize {<br/>        use Instruction::*;<br/>        match self {<br/>            Byte(_) =&gt; 1,<br/>            Terminate(_) | Input(_) | Output(_) =&gt; 2,<br/>            _ =&gt; 3,<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding code, <kbd>Byte</kbd> occupies <kbd>1</kbd> byte, the <kbd>Terminate</kbd>, <kbd>Input</kbd>, and <kbd>Output</kbd> instructions occupy <kbd>2</kbd> bytes, and the other instructions occupy <kbd>3</kbd> bytes.</p>
<p class="mce-root"/>
<p>The <kbd>get_process_size</kbd> function is useful for reading the length of the process from the first two bytes of the program. Notice that all the parsers (of this module)<span> </span><span>are private</span><span>, except for </span><kbd>parse_instruction</kbd><span>, so that we can parse machine code instructions.</span></p>
<p><span>Now that we have a parser for the instructions, we can build a low-level interpreter (that is, an </span>emulator<span>) using it.</span></p>
<h2 id="uuid-8e795691-1a29-4938-a214-55af1e8c30a9">The emulator.rs source file</h2>
<p>This emulator is implemented in the <kbd>emulator.rs</kbd> source file. The entry point of the interpreter is the following function:</p>
<pre>pub fn execute_program(program: &amp;[u8]) -&gt; Result&lt;u8, ()&gt; {<br/>    let process_size_parsed: u16 = match get_process_size(program) {<br/>        Ok(ok) =&gt; ok,<br/>        Err(_) =&gt; return Err(()),<br/>    };<br/>    let mut process = vec![0u8; process_size_parsed as usize];<br/>    process[0..program.len()].copy_from_slice(&amp;program);<br/>    let mut registers = RegisterSet { ip: 2, acc: 0 };<br/>    loop {<br/>        let instruction = match parse_instruction(&amp;process[registers.ip as usize..]) {<br/>            Ok(instruction) =&gt; instruction.1,<br/>            Err(_) =&gt; return Err(()),<br/>        };<br/>        if let Some(return_code) = execute_instruction(&amp;mut process, &amp;mut registers, instruction) {<br/>            return Ok(return_code);<br/>        }<br/>    }<br/>}</pre>
<p>The preceding function receives a program as an argument and executes it by parsing and executing one instruction at a time. If any parse error occurs because of a malformed instruction, the function returns that parse error. If no parse error occurs, the program goes on until a <kbd>Terminate</kbd><span> instruction</span> is encountered. Then, the program returns the operand of the <kbd>Terminate</kbd> <span>instruction</span>.</p>
<p>The first statement gets the required size of the process. Then, a <kbd>process</kbd> variable is created as a vector of bytes, with the specified length. The content of the program is copied into the first part of the process, then the rest of the process is initialized to zeros.</p>
<p class="mce-root"/>
<p>Then, at the eighth line of the <span>preceding</span> code, the <kbd>registers</kbd> variable is declared with a <kbd>RegisterSet</kbd> type, declared as follows:</p>
<pre>pub struct RegisterSet {<br/>    ip: u16,<br/>    acc: u16,<br/>}</pre>
<p><span>In this simple machine architecture, there is no big gain in encapsulating the instruction pointer and the accumulator</span><span> </span><span>in a struct</span><span>, but with more complex processors with many registers, it would be convenient.</span></p>
<p>At last, there is the interpretation loop. It consists of two steps:</p>
<ol>
<li>The call to <kbd>parse_instruction</kbd> parses the process from the current position of the instruction pointer and returns <kbd>Instruction</kbd>.</li>
<li>The call to <kbd>execute_instruction</kbd> executes the instruction generated by the <span>preceding</span> step, taking into account the whole process and the register set.</li>
</ol>
<p>The <kbd>execute_instruction</kbd> function is just a large <kbd>match</kbd> statement that begins with the following:</p>
<pre>match instruction {<br/>    Terminate(operand) =&gt; {<br/>        r.ip += 2;<br/>        return Some(operand);<br/>    }<br/>    Set(operand) =&gt; {<br/>        r.acc = operand;<br/>        r.ip += 3;<br/>    }<br/>    Load(address) =&gt; {<br/>        r.acc = get_le_word(process, address);<br/>        r.ip += 3;<br/>    }<br/>    Store(address) =&gt; {<br/>        set_le_word(process, address, r.acc);<br/>        r.ip += 3;<br/>    }</pre>
<p>For each instruction type, the appropriate action is taken. Notice the following:</p>
<ul>
<li>The <kbd>Terminate</kbd> instruction causes the function to return <kbd>Some</kbd>, while for any other instruction, <kbd>None</kbd> is returned. This allows the caller to terminate the execution loop.</li>
<li>The <kbd>Set</kbd> instruction sets the accumulator (<kbd>r.acc</kbd>) to the operand value.</li>
<li>The <kbd>Load</kbd> instruction uses the <kbd>get_le_word</kbd> function to read a little-endian word from the <kbd>address</kbd> position of <kbd>process</kbd> and assigns it to the accumulator.</li>
<li>The<span> </span><kbd>Store</kbd><span> </span>instruction uses the <kbd>set_le_word</kbd><span> </span>function to assign a little-endian word taken from the accumulator to the <kbd>address</kbd> position of <kbd>process</kbd>.</li>
<li>All the instructions increment the instruction pointer (<kbd>r.ip</kbd>) by the length of the instruction itself.</li>
</ul>
<p>Let's see the auxiliary functions used every time an instruction needs to read or to write a word in memory<span>, respectively</span><span>:</span></p>
<pre>fn get_le_word(slice: &amp;[u8], address: u16) -&gt; u16 {<br/>    u16::from(slice[address as usize]) + (u16::from(slice[address as usize + 1]) &lt;&lt; 8)<br/>}<br/><br/>fn set_le_word(slice: &amp;mut [u8], address: u16, value: u16) {<br/>    slice[address as usize] = value as u8;<br/>    slice[address as usize + 1] = (value &gt;&gt; 8) as u8;<br/>}<br/><br/></pre>
<p>In the <span>preceding</span> code, the <kbd>get_le_word</kbd> function gets a byte at <kbd>address</kbd> and another byte at the next position. The second one is the most significant in little-endian notation, and so its value is shifted to the left by 8 bits before adding it to the other byte.</p>
<p><kbd>set_le_word</kbd> saves a byte, along with the address position, and another one at the next position. The first one is obtained by converting the word into a <kbd>u8</kbd> type, and the second one is obtained by shifting the word<span> </span><span>to the right</span><span> by 8 bits.</span></p>
<p class="mce-root"><span>Of course, the <kbd>jump</kbd> instructions are different. For example, look at the following code snippet:</span></p>
<pre>    JumpIfPositive(address) =&gt; {<br/>        if (r.acc as i16) &gt; 0 {<br/>            r.ip = address;<br/>        } else {<br/>            r.ip += 3;<br/>        }<br/>    }</pre>
<p>Consider the <kbd>JumpIfPositive</kbd> instruction's operand as a signed number. If this value is positive, the instruction pointer is set to the operand. Otherwise, the usual increment is performed.</p>
<p class="mce-root"/>
<p>As another example, let's see how to <span>indirectly</span><span> </span><span>load a byte:</span></p>
<pre>    IndirectLoadByte(address) =&gt; {<br/>        r.acc = get_byte(process, get_le_word(process, address));<br/>        r.ip += 3;<br/>    }</pre>
<p>Using the <kbd>get_le_word</kbd> function, the 16-bit value at the <kbd>address</kbd> <span>position </span>is read from <kbd>process</kbd>. This value is an address of a byte, and so the <kbd>get_byte</kbd> function is used to read this byte to assign it to the accumulator.</p>
<p>So, in this section, we have seen the first execution technique—the one that parses and executes one instruction at a time.</p>
<h2 id="uuid-dc0c80de-e995-47bb-b591-b239af5df574">The parsing_interpreter.rs source file</h2>
<p>Now, we can look at the other <span>e</span><span>xecution technique—the one that first parses the whole program and then executes the result of the parsing.</span></p>
<p>The <kbd>parsing_interpreter</kbd> module has two entry points:</p>
<ol>
<li><kbd>parse_program</kbd> </li>
<li><kbd>execute_parsed_program</kbd></li>
</ol>
<p>The first one calls <kbd>get_process_size</kbd> <span>once</span> to get the process size from the first two bytes, then it parses the program instructions using the following loop:</p>
<pre>let mut parsed_program = vec![Instruction::Byte(0); process_size_parsed];<br/>let mut ip = 2;<br/>loop {<br/>    match parse_instruction(&amp;program[ip..]) {<br/>        Ok(instruction) =&gt; {<br/>            parsed_program[ip] = instruction.1;<br/>            ip += instruction.1.len();<br/>            if let Instruction::Terminate(_) = instruction.1 {<br/>                break;<br/>            }<br/>        }<br/>        Err(_) =&gt; return Err(()),<br/>    };<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the following code, the data structure that we are going to build is the <kbd>parsed_program</kbd> variable. That variable is a vector of instructions or byte data. It is initialized by single data bytes with zero value, but then some of these bytes are replaced with instructions.</p>
<p>Starting at position <kbd>2</kbd>, the program is repeatedly parsed using the <kbd>parse_instruction</kbd> function. This function returns an instruction that is stored in the vector at the position corresponding to its position in the program. When the <kbd>Terminate</kbd> instruction is parsed, the loop ends.</p>
<p>The <kbd>parse_instruction</kbd> function is the same as the one we saw in the <kbd>instructions</kbd> module.</p>
<p>After this loop, we need to set the data values into the vector. This is done by using the following loop:</p>
<pre>for ip in ip..program.len() {<br/>    parsed_program[ip] = Instruction::Byte(program[ip]);<br/>}</pre>
<p>This replaces any byte of the vector with another byte whose value is taken from the program. The <kbd>execute_parsed_program</kbd> function has the following body:</p>
<pre>let mut registers = ParsedRegisterSet { ip: 2, acc: 0 };<br/>loop {<br/>    if let Some(return_code) = execute_parsed_instruction(parsed_program, &amp;mut registers) {<br/>        return return_code;<br/>    };<br/>}</pre>
<p>The <span>preceding</span> code defines a register set and then calls <kbd>execute_parsed_instruction</kbd> <span>repeatedly </span>until it returns <kbd>Some</kbd>. This function is very similar to the <kbd>execute_instruction</kbd> functions of the <kbd>emulator</kbd> module.</p>
<p>The main differences are in the use of the <kbd>get_parsed_le_word</kbd>, <kbd>set_parsed_le_word</kbd>, <kbd>get_parsed_byte</kbd>, and <kbd>set_parsed_byte</kbd><span> </span><span>functions, </span><span>instead of</span> <kbd>get_le_word</kbd><span>,</span> <kbd>set_le_word</kbd><span>,</span> <kbd>get_byte</kbd><span>, and </span><kbd>set_byte</kbd><span>.</span></p>
<p>These functions, instead of getting or setting the <kbd>u8</kbd> values in a slice of <kbd>u8</kbd> objects, get or set the <kbd>Instruction::Byte</kbd> values in a slice of the <kbd>Instruction</kbd> objects. This slice is the parsed program.</p>
<p>We will now move on to the last technique.</p>
<p class="mce-root"/>
<h2 id="uuid-7436d882-cdfb-49d8-8f06-934f08eedc4c">The<span> </span>translator.rs source file</h2>
<p>Now, we can look at the last execution technique—the one that translates the program into a C language program so that it can be compiled with any C compiler.</p>
<p>The <kbd>translator.rs</kbd> module has just one entry point:</p>
<pre>pub fn translate_program_to_c(program: &amp;[u8], target_path: &amp;str) -&gt; Result&lt;()&gt; {</pre>
<p>This function gets the machine language program to translate the program and the path of the file to create and return a result that indicates its success or failure.</p>
<p>Its body creates a text file and writes into it using statements such as this one:</p>
<pre> writeln!(file, "#include &lt;stdio.h&gt;")?;</pre>
<p>It writes a string into the <kbd>file</kbd> stream. Notice that the <kbd>writeln</kbd> macro, in a similar way to the <kbd>println</kbd> macro, supports string interpolation through pairs of braces:</p>
<pre>writeln!(file, " addr_{}: acc = {};", *ip, operand)?;</pre>
<p>Therefore, any real brace must be doubled:</p>
<pre>writeln!(file, "unsigned char memory[] = {{")?;</pre>
<p>The translation algorithm is quite simple. First, the declaration of a global byte array is emitted:</p>
<pre>unsigned char memory[];</pre>
<p>Then, we have the definitions of two utility functions. Their signatures are as follows:</p>
<pre>unsigned short bytes_to_u16_le(unsigned int address)<br/>void u16_to_bytes_le(unsigned int address, unsigned short operand)</pre>
<p>The first one reads the two bytes in the <kbd>memory</kbd> array at two positions—<kbd>address</kbd> and <kbd>address + 1</kbd>—and, interpreting them as a little-endian 16-bit number, returns the number. The second one generates the two bytes that comprise the <kbd>operand</kbd> value and writes them in memory as a little-endian 16-bit number at the <kbd>address</kbd> and <kbd>address + 1</kbd> positions.</p>
<p>Then, the <kbd>main</kbd> C function is emitted. It begins by declaring the <kbd>acc</kbd> variable, which will be used as an accumulator register.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>It may be surprising that there is no need for a variable containing the instruction pointer. This means that during the execution of the C program, the current C language statement corresponds to the current machine language instruction.</p>
<p>The machine language jumps are implemented using the infamous <kbd>goto</kbd> statement. To be able to jump to any instruction, the instructions that are the destination of a jump must be preceded by a C language unique label. For simplicity, when translating any instruction, a different label is generated, even if most of them will never be used by a <kbd>goto</kbd> statement.</p>
<p>As an example, let's consider the <kbd>store pos</kbd><span> </span><span>assembly language instruction</span><span>, corresponding to the </span><kbd>3, 33, 1</kbd><span> </span><span>machine language instruction</span><span>, where</span> <kbd>3</kbd> <span>is the opcode of the</span> <kbd>store</kbd> <span>instruction and</span> <kbd>33, 1</kbd> <span>represents</span> <kbd>289</kbd><span> in </span><span>little-endian notation. Assume that this instruction starts at position</span> <kbd>10</kbd> <span>of the program. For this instruction, the following C language statement will be generated:</span></p>
<pre>addr_10: u16_to_bytes_le(289, acc);</pre>
<p>First, there is the label as a target of a possible <kbd>jump</kbd> instruction. Labels are created, concatenating the position of the instruction to the <kbd>addr_</kbd><span> </span><span>constant</span><span>. Then, there is a function call that copies the value of the </span><kbd>acc</kbd><span> </span><span>variable</span><span> to the bytes at positions</span> <kbd>289</kbd> <span>and <kbd>230</kbd> of the </span><kbd>memory</kbd><span> </span><span>array</span><span> in little-endian notation.</span></p>
<p>To create these statements, a loop is performed that parses an instruction at a time using the <kbd>parse_instruction</kbd> function, and then generates the corresponding C language statement using the <kbd>translate_instruction_to_c</kbd> function.</p>
<p>This function contains a large <kbd>match</kbd> statement, with a branch for every instruction type. For example, the branch that translates the <kbd>Store</kbd> instructions is as follows:</p>
<pre>Store(address) =&gt; {<br/>    writeln!(file, " addr_{}: u16_to_bytes_le({}, acc);", *ip, address)?;<br/>    *ip += 3;<br/>}</pre>
<p>After the <kbd>Terminate</kbd> statement has been processed by the loop, the <kbd>main</kbd> <span>C </span>function is closed and the <kbd>memory</kbd> array, which was only just declared, is now defined and initialized using the entire content of the machine language program.</p>
<p>In fact, the machine language instructions could be omitted from this array as they are not used by the C language code, but this way is simpler.</p>
<p>So, we have seen how to generate an equivalent C language program from a machine language program, assuming it is well formed. This technique could be used to generate programs in other programming languages, as long as there is a <kbd>goto</kbd> statement.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>Now that we have seen several ways to execute machine language programs, we can look at another use of a machine language parser.</span></p>
<h1 id="uuid-80d52096-c1bf-4b03-a468-335a0d82f3e2">The nom_disassembler project</h1>
<p>We have seen that usually, machine language programs are written in assembly language and are then translated into machine language. So, if we want to understand or debug a <span>machine language </span><span>program written by our company, we should look at the assembly language program used to generate it.</span></p>
<p><span>However, if this program wasn't written by our company and we don't have its assembly language source code available, it is useful to have a tool that tries its best to translate machine language programs into the corresponding assembly language programs. This tool, named a</span> disassembler<span>, cannot create an excellent assembly language program for the following reasons:</span></p>
<ul>
<li>No meaningful comments can be inserted into the code.</li>
<li>Data variables have no symbolic name to make sense of them. They are just bytes of memory positions where some data is placed, and so they are referenced by their address.</li>
<li>The destinations of jumps have no symbolic names to make sense of them. They are just memory positions <span>where some instruction begins, and so they are referenced by their address.</span></li>
</ul>
<p>Regarding 16-bit words, sometimes it is useful to see them <span>as single numbers and sometimes </span>as pairs of bytes. If you <span>are disassembling a program to apply some changes to it and then submit the changed assembly program to an assembler (to obtain a changed machine language program), it is better to only </span><span>generate</span><span> </span><span>a single number</span><span> </span><span>for every 16-bit number</span><span> (in little-endian notation, for our kind of processor).</span></p>
<p>Instead, if you are disassembling a program just to understand it deeply, it is better to generate both a single number notation and a pair of its bytes<span> </span><span>for every 16-bit number</span><span>.</span></p>
<p>Typical disassemblers use hexadecimal notation. A 16-bit number is represented by four <span>hexadecimal </span>digits, where two digits represent one byte and the other <span>two</span><span> </span><span>digits represent the other byte.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Instead, to continue with decimal notation<span>, the <kbd>nom_disassembler</kbd> project gene</span><span>rates two outputs from the same machine language program:</span></p>
<ul>
<li><span>A</span> <kbd>FOR DEBUG</kbd> <span>output, where every 16-bit number is shown both as a single number and as a pair of bytes</span></li>
<li><span>A<strong> </strong></span><kbd>FOR ASSEMBLING</kbd><span><strong> </strong>output, where every 16-bit number is shown only as a single number</span></li>
</ul>
<p>We will now learn how to run the project in the next subsection.</p>
<h2 id="uuid-3f161882-8910-4065-be9b-15aafe12674f">Running the project</h2>
<p>If you type in <kbd>cargo run</kbd> for this project, you'll see a long output that begins with the following:</p>
<pre><strong>FOR DEBUG</strong><br/><strong>Program size: 299</strong><br/><strong>Process size: 699</strong><br/><strong>    2: Set(284: 28, 1)</strong><br/><strong>    5: Input(5)</strong><br/><strong>    7: Set(284: 28, 1)</strong><br/><strong>   10: Store(289: 33, 1)</strong><br/><strong>   13: IndirectLoadByte(289: 33, 1)</strong></pre>
<p>After a few lines, you'll find the following:</p>
<pre><strong>  297: Byte(2)</strong><br/><strong>  298: Byte(0)</strong><br/><br/><strong>FOR ASSEMBLING</strong><br/><strong>process size 699</strong><br/><strong>    2: set 284</strong><br/><strong>    5: input 5</strong><br/><strong>    7: set 284</strong><br/><strong>   10: store 289</strong><br/><strong>   13: indirect load byte 289</strong></pre>
<p>At the end, you'll find the following:</p>
<pre><strong>  297: data byte 2</strong><br/><strong>  298: data byte 0</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first part of the output is the <kbd>FOR DEBUG</kbd> disassembly. After showing the size of the program and the process, the disassembled instructions begin. The first one is a <kbd>Set</kbd> instruction, whose 16-bit operand is number <kbd>284</kbd>, which is composed of the <kbd>28</kbd> and <kbd>1</kbd><span> </span><span>bytes </span><span>in little-endian order. The second instruction is</span> <kbd>Input</kbd><span>, which has an </span><span>8-bit operand.</span></p>
<p>Any instruction is preceded by the address of the first byte of the instruction. So, <kbd>Set</kbd> is preceded by <kbd>2</kbd> (it is the third byte of the program), and <kbd>Input</kbd> is preceded by <kbd>5</kbd> (it is the sixth byte of the program).</p>
<p>The program ends with a sequence of bytes. As machine language has no concept of word data, the data is just a sequence of bytes.</p>
<p>The second part of the output is the <kbd>FOR ASSEMBLING</kbd> disassembly. This differs from the first kind of disassembling technique by the following aspects:</p>
<ul>
<li>There is no program size. Any assembler program can compute the size of the corresponding machine language program. There is no need to specify it in the source for the assembler.</li>
<li>Instructions' symbolic names only contain lowercase letters and they can be composed of several words, separated by spaces. In this way, they are easier to read and to write. Instead, the <kbd>FOR DEBUG</kbd> output uses just the names of the variants of the<span> instruction enum</span>.</li>
<li>The operands are a single number.</li>
</ul>
<p>We will now take a look at the source code to help us understand it further.</p>
<h2 id="uuid-535bf4f4-4aaf-42da-807e-9e17140530c9">Examining the source code</h2>
<p>Now, let's see how this project obtained this output by examining the source code, which is all in the <kbd>main.rs</kbd> file. <span>This</span> <span>function, after defining the</span> <kbd>prog</kbd> <span>variable as in the preceding project, contains just these statements:</span></p>
<pre>    println!("FOR DEBUG");<br/>    let _ = disassembly_program_for_debug(&amp;prog);<br/>    println!();<br/>    println!("FOR ASSEMBLING");<br/>    let _ = disassembly_program(&amp;prog);</pre>
<p>The <kbd>disassembly_program_for_debug</kbd> function produces the first kind of output and the <kbd>disassembly_program</kbd> function produces the second kind of output. Let's see what these functions do.</p>
<p class="mce-root"/>
<h2 id="uuid-e9692d51-a880-472e-8417-165d0799fd71">Generating disassembly code that is useful for debugging</h2>
<p class="mce-root">The interesting part of the <kbd>disassembly_program_for_debug</kbd> function is the following code snippet:</p>
<pre>loop {<br/>    let instruction = parse_instruction(rest)?;<br/>    println!("{:5}: {:?}", offset, instruction.1);<br/>    offset += instruction.1.len();<br/>    rest = instruction.0;<br/>    if let Terminate(_) = instruction.1 {<br/>        break;<br/>    }<br/>}<br/>for byte in rest {<br/>    let instr = Byte(*byte);<br/>    println!("{:5}: {:?}", offset, instr);<br/>    offset += instr.len();<br/>}</pre>
<p>In the <span>preceding</span> code, there is first a loop that parses each instruction using the <kbd>parse_instruction</kbd> function, and then there is a loop that scans each data byte. For every parsed instruction, the obtained instruction is printed by <kbd>println</kbd> and its size is added to the current position inside the program, named <kbd>offset</kbd>. </p>
<p>This loop ends when the <kbd>Terminate</kbd> instruction is found. For the data bytes, a <kbd>Byte</kbd> variant is built and it is printed in a similar way. This raises the question of how an object of the <kbd>Instruction</kbd> type <span>can be printed.</span></p>
<p><span>To be printed using the <kbd>{:?}</kbd> placeholder of <kbd>println</kbd>, the <kbd>Debug</kbd> trait must be implemented. However, if you print an <kbd>Instruction</kbd> object such as those defined in the preceding chapters, we don't get the output we want. For example, if you execute the <kbd>print!("{:?}", Instruction::Set(284))</kbd> statement, you will get the following output:</span></p>
<pre><strong> Set(284)</strong></pre>
<p><span>But instead, we want the following output:</span></p>
<pre><span> </span><strong>Set(284: 28, 1)</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To obtain the desired formatting, a new type must be defined in the following way:</p>
<pre>#[derive(Copy, Clone)]<br/>struct Word(u16);</pre>
<p>The <kbd>Word</kbd> type encapsulates all the <kbd>u16</kbd> arguments of the variants of <kbd>Instruction</kbd> in the following way:</p>
<pre>#[derive(Debug, Copy, Clone)]<br/>enum Instruction {<br/>    Terminate(u8),<br/>    Set(Word),<br/>    Load(Word),<br/>    ...</pre>
<p>Of course, this causes any construction of an <kbd>Instruction</kbd> object to construct a <kbd>Word</kbd> object inside of it, and every trait implemented by <kbd>Instruction</kbd> must be implemented also by <kbd>Word</kbd>. The <kbd>Copy</kbd> and <kbd>Clone</kbd> traits are implemented using default derivations.</p>
<p>Instead, the <kbd>Debug</kbd> trait is implemented in the following way:</p>
<pre>impl std::fmt::Debug for Word {<br/>    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {<br/>        write!(f, "{}: {}, {}", self.0, self.0 as u8, self.0 &gt;&gt; 8)<br/>    }<br/>}</pre>
<p>The body of the <kbd>fmt</kbd> function writes three numbers—the whole argument (<kbd>self.0</kbd>), its low byte (<kbd>self.0 as u8</kbd>), and its high byte (<kbd>self.0 &gt;&gt; 8</kbd>). In this way, we get the desired formatting.</p>
<p><kbd>Instruction</kbd> objects are created by the instruction parsers. So, these parsers must be changed, with respect to the project, <kbd>nom_byte_machine</kbd>. In that project, we saw that some parsers accept 16-bit numbers, such as this one:</p>
<pre>fn parse_set(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Instruction&gt; {<br/>    preceded(tag("\x01"), map(<span>le_u16</span>, Instruction::Set))(input)<br/>}</pre>
<p>For all of these parsers, the use of the <kbd>le_u16</kbd> parser must be replaced with the use of the <kbd>le_word</kbd> parser, obtaining the following:</p>
<pre>fn parse_set(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Instruction&gt; {<br/>    preceded(tag("\x01"), map(le_word, Instruction::Set))(input)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This parser is defined as follows:</p>
<pre>fn le_word(input: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], Word&gt; {<br/>    le_u16(input).map(|(input, output)| (input, Word(output)))<br/>}</pre>
<p>It still calls the <kbd>le_u16</kbd> parser, but then it gets the generated <kbd>(input, output)</kbd> pair and encapsulates the <kbd>output</kbd> item in a <kbd>Word</kbd> object, obtaining an <kbd>(input, Word(output))</kbd> pair.</p>
<p>We have seen how to convert a machine language program into a kind of assembly code. That disassembled code is useful for debugging purposes, but it is not easy to change and reassemble it to generate a new machine language program. In the next section, we will look at another kind of disassembly code that is useful for assembling it again.</p>
<h2 id="uuid-722687f5-e296-425b-ab38-24c2af489ded">Generating disassembly code that is useful for reassembling</h2>
<p>Regarding the other kind of output, <kbd>FOR ASSEMBLING</kbd>, we must examine the <kbd>disassembly_program</kbd> function, which is quite similar to the corresponding part of the <kbd>disassembly_program_for_debug</kbd> function. The only differences are the following:</p>
<ul>
<li>The program size is not emitted.</li>
<li>The format strings of the two <kbd>println</kbd> statements are <kbd>"{:5}: {}"</kbd>, instead of <kbd>"{:5}: {:?}"</kbd>.</li>
</ul>
<p>For this kind of format placeholder, the <kbd>Display</kbd> trait must be implemented by the <kbd>Instruction</kbd> type:</p>
<pre>impl std::fmt::Display for Instruction {<br/>    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {<br/>        use Instruction::*;<br/>        match self {<br/>            Terminate(byte) =&gt; write!(f, "terminate {}", byte),<br/>            Set(word) =&gt; write!(f, "set {}", word),<br/>            Load(word) =&gt; write!(f, "load {}", word),<br/>            ...<br/>            Byte(byte) =&gt; write!(f, "data byte {}", byte),<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>For any variant, the <kbd>write</kbd> macro is used to emit the symbolic name of the instruction, followed by the formatted value of the byte or word. This formatting <span>also </span><span>requires the implementation of the</span> <kbd>Display</kbd> <span>trait for the arguments. Bytes are of the </span><kbd>u8</kbd><span> </span><span>type</span><span>, which already implements the </span><kbd>Display</kbd> <span>trait. Instead, for words, the following declaration is required:</span></p>
<pre>impl std::fmt::Display for Word {<br/>    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {<br/>        write!(f, "{}", self.0)<br/>    }<br/>}</pre>
<p>This simply produces the numeric value encapsulated in a <kbd>Word</kbd> object. So, we have seen how to transform a machine language program into two possible formats of disassembled text.</p>
<p>We have also seen another kind of disassembling. As an exercise, you should write an assembler for this machine language, run it on the code generated by this disassembler, and check that the resulting machine code is identical to the original one.</p>
<h1 id="uuid-4bcbf137-0159-4b86-8056-5a017802555f">Summary</h1>
<p>In this chapter, we <span>first </span>defined an extremely simple toy machine language, and then a slightly more complex one to experiment with techniques of machine language manipulation.</p>
<p>The first machine language defined assumes that memory is just a sequence of 16-bit words and that any instruction is composed of two parts of one word each—an opcode and an operand. The second machine language assumes that memory is a sequence of bytes and some instructions can manipulate single bytes, while other instructions can manipulate whole words.</p>
<p>This introduced the endianness issue, which concerns how to interpret two consecutive bytes as a word. As an example, the <span>sieve of </span>Eratosthenes algorithm was <span>first</span><span> </span><span>written in Rust and then translated into both machine languages.</span></p>
<p>For the first machine language, an interpreter was written without using any external library. It was used to <span>first</span><span> </span><span>interpret a small number conversion program (</span><kbd>word_machine_convert</kbd><span>) and then the more complex sieve algorithm (</span><kbd>word_machine_sieve</kbd><span>).</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For the second machine language, three procedures were written in a single project (<kbd>nom_byte_machine</kbd>). All of these procedures used the <kbd>nom</kbd> parsing library. The first procedure was an instruction-by-instruction interpreter. The second procedure first parsed the whole program and then interpreted the parsed program. The third procedure translated the program into C language.</p>
<p>For the second machine language, two kinds of disassemblers were built using the <kbd>nom</kbd> library (<kbd>nom_disassembler</kbd>)—one disassembler emitted output useful for debugging and the other emitted output useful for reassembling it after editing.</p>
<p>So, after reading this chapter, you should now understand what a machine language is, what its corresponding assembly language is, how to translate assembly language into machine language and vice versa, how to translate machine language into C language, how to interpret machine language, and how to use the <kbd>nom</kbd> parsing library to carry out these tasks.</p>
<p class="mce-root">In the next chapter, we will learn how to create a Linux kernel module.</p>
<h1 id="uuid-4ce7ce6f-6e5d-42d2-a375-0d83deac4f95">Questions</h1>
<ol>
<li>How can a machine language emulator be useful?</li>
<li>What is the accumulator of a processor?</li>
<li>What is the instruction pointer<span> of a processor</span>?</li>
<li><span>Why is it very difficult to write directly in machine language and, therefore, better to use an assembler?</span></li>
<li>How can a Rust enum represent a machine language instruction?</li>
<li>What is little-endian notation and what is big-endian <span>notation?</span></li>
<li><span>What is the difference between a <kbd>nom</kbd> parser that accepts text and one that accepts binary data?</span></li>
<li><span>Which rules must be respected by a machine language program to be able to parse it all or to be able to translate it into another programming language?</span></li>
<li>Why might different kinds of output, or a hexadecimal output format, <span>be preferred for a disassembler?</span></li>
<li><span>How can a single number be printed in different ways?</span></li>
</ol>


            </article>

            
        </section>
    </body></html>