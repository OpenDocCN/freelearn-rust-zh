["```rs\n1  fn main() {\n2   by_moving();\n3   by_cloning();\n4   by_mutating();\n5  }\n6\n7  fn by_moving() {\n8   let hello = \"hello \".to_string();\n9   let world = \"world!\";\n10\n11   // Moving hello into a new variable\n12   let hello_world = hello + world;\n13   // Hello CANNOT be used anymore\n14   println!(\"{}\", hello_world); // Prints \"hello world!\"\n15  }\n16\n17  fn by_cloning() {\n18   let hello = \"hello \".to_string();\n19   let world = \"world!\";\n20\n21   // Creating a copy of hello and moving it into a new variable\n22   let hello_world = hello.clone() + world;\n23   // Hello can still be used\n24   println!(\"{}\", hello_world); // Prints \"hello world!\"\n25  }\n26\n27  fn by_mutating() {\n28   let mut hello = \"hello \".to_string();\n29   let world = \"world!\";\n30\n31   // hello gets modified in place\n32   hello.push_str(world);\n33   // hello is both usable and modifiable\n34   println!(\"{}\", hello); // Prints \"hello world!\"\n35  }\n```", "```rs\n1  fn main() {\n2    let colour = \"red\";\n3    // The '{}' it the formatted string gets replaced by the\n   parameter\n4    let favourite = format!(\"My favourite colour is {}\", colour);\n5    println!(\"{}\", favourite);\n6     \n7    // You can add multiple parameters, which will be\n8    // put in place one after another\n9    let hello = \"hello \";\n10   let world = \"world!\";\n11   let hello_world = format!(\"{}{}\", hello, world);\n12   println!(\"{}\", hello_world); // Prints \"hello world!\"\n13     \n14   // format! can concatenate any data types that\n15   // implement the 'Display' trait, such as numbers\n16   let favourite_num = format!(\"My favourite number is {}\", 42);\n17   println!(\"{}\", favourite_num); // Prints \"My favourite number\n     is 42\"\n18     \n19   // If you want to include certain parameters multiple times\n20   // into the string, you can use positional parameters\n21   let duck_duck_goose = format!(\"{0}, {0}, {0}, {1}!\", \"duck\",\n     \"goose\");\n22   println!(\"{}\", duck_duck_goose); // Prints \"duck, duck, duck,\n     goose!\"\n23     \n24   // You can even name your parameters!\n25   let introduction = format!(\n26     \"My name is {surname}, {forename} {surname}\",\n27     surname=\"Bond\",\n28     forename=\"James\"\n29   );\n30   println!(\"{}\", introduction) // Prints \"My name is Bond, James\n     Bond\"\n31  }\n```", "```rs\nformat!(\"My favourite number is {}\", 42);\n```", "```rs\nformat!(\"{message} {}\", message=\"Hello there,\", \"friendo\")\n```", "```rs\nformat!(\"{message} {}\", \"friendo\", message=\"Hello there,\")\n // Returns \"hello there, friendo\"\n```", "```rs\nformat!(\"{1} {} {0} {}\", \"a\", \"b\") // Returns \"b a a b\"\n```", "```rs\nformat!(\"{:.*}\", 2, 1.234567) // Returns \"1.23\"\n```", "```rs\n1  fn main() {\n2    // There's a default value for nearly every primitive type\n3    let foo: i32 = Default::default();\n4    println!(\"foo: {}\", foo); // Prints \"foo: 0\"\n5 \n6 \n7    // A struct that derives from Default can be initialized like\n     this\n8    let pizza: PizzaConfig = Default::default();\n9    // Prints \"wants_cheese: false\n10   println!(\"wants_cheese: {}\", pizza.wants_cheese);\n11 \n12   // Prints \"number_of_olives: 0\"\n13   println!(\"number_of_olives: {}\", pizza.number_of_olives);\n14 \n15   // Prints \"special_message: \"\n16   println!(\"special message: {}\", pizza.special_message);\n17 \n18   let crust_type = match pizza.crust_type {\n19     CrustType::Thin => \"Nice and thin\",\n20     CrustType::Thick => \"Extra thick and extra filling\",\n21   };\n22   // Prints \"crust_type: Nice and thin\"\n23   println!(\"crust_type: {}\", crust_type);\n24 \n25 \n26   // You can also configure only certain values\n27   let custom_pizza = PizzaConfig {\n28     number_of_olives: 12,\n29     ..Default::default()\n30   };\n31 \n32   // You can define as many values as you want\n33   let deluxe_custom_pizza = PizzaConfig {\n34     number_of_olives: 12,\n35     wants_cheese: true,\n36     special_message: \"Will you marry me?\".to_string(),\n37     ..Default::default()\n38   };\n39\n40 }\n41 \n42  #[derive(Default)]\n43  struct PizzaConfig {\n44    wants_cheese: bool,\n45    number_of_olives: i32,\n46    special_message: String,\n47    crust_type: CrustType,\n48  }\n49 \n50  // You can implement default easily for your own types\n51  enum CrustType {\n52    Thin,\n53    Thick,\n54  }\n55  impl Default for CrustType {\n56    fn default() -> CrustType {\n57      CrustType::Thin\n58    }\n59  }\n```", "```rs\n1  fn main() {\n2    // We don't need to care about\n3    // the internal structure of NameLength\n4    // Instead, we can just call it's constructor\n5    let name_length = NameLength::new(\"John\");\n6 \n7    // Prints \"The name 'John' is '4' characters long\"\n8    name_length.print();\n9  }\n10 \n11  struct NameLength {\n12    name: String,\n13    length: usize,\n14  }\n15 \n16  impl NameLength {\n17    // The user doesn't need to setup length\n18    // We do it for him!\n19    fn new(name: &str) -> Self {\n20      NameLength {\n21        length: name.len(),\n22        name,\n23      }\n24    }\n25 \n26    fn print(&self) {\n27      println!(\n28        \"The name '{}' is '{}' characters long\",\n29          self.name,\n30          self.length\n31      );\n32    }\n33  }\n```", "```rs\nuse std::borrow::Cow;\nstruct NameLength<'a> {\n    name: Cow<'a, str>,\n    length: usize,\n}\n\nimpl<'a> NameLength<'a> {\n    // The user doesn't need to setup length\n    // We do it for him!\n    fn new<S>(name: S) -> Self\n    where\n        S: Into<Cow<'a, str>>,\n    {\n        let name: Cow<'a, str> = name.into();\n        NameLength {\n            length: name.len(),\n            name,\n        }\n    }\n\n    fn print(&self) {\n        println!(\n            \"The name '{}' is '{}' characters long\",\n            self.name, self.length\n        );\n    }\n}\n```", "```rs\n1  fn main() {\n2    // We can easily create different configurations\n3    let normal_burger = BurgerBuilder::new().build();\n4    let cheese_burger = BurgerBuilder::new()\n       .cheese(true)\n       .salad(false)\n       .build();\n5    let veggie_bigmac = BurgerBuilder::new()\n       .vegetarian(true)\n       .patty_count(2)\n       .build();\n6\n7    if let Ok(normal_burger) = normal_burger {\n8      normal_burger.print();\n9    }\n10   if let Ok(cheese_burger) = cheese_burger {\n11     cheese_burger.print();\n12   }\n13   if let Ok(veggie_bigmac) = veggie_bigmac {\n14     veggie_bigmac.print();\n15   }\n16\n17   // Our builder can perform a check for\n18   // invalid configurations\n19   let invalid_burger = BurgerBuilder::new()\n       .vegetarian(true)\n       .bacon(true)\n       .build();\n20   if let Err(error) = invalid_burger {\n21     println!(\"Failed to print burger: {}\", error);\n22   }\n23\n24   // If we omit the last step, we can reuse our builder\n25   let cheese_burger_builder = BurgerBuilder::new().cheese(true);\n26   for i in 1..10 {\n27     let cheese_burger = cheese_burger_builder.build();\n28     if let Ok(cheese_burger) = cheese_burger {\n29       println!(\"cheese burger number {} is ready!\", i);\n30       cheese_burger.print();\n31     }\n32   }\n33 }\n```", "```rs\n35 struct Burger {\n36    patty_count: i32,\n37    vegetarian: bool,\n38    cheese: bool,\n39    bacon: bool,\n40    salad: bool,\n41 }\n42 impl Burger {\n43    // This method is just here for illustrative purposes\n44    fn print(&self) {\n45        let pretty_patties = if self.patty_count == 1 {\n46            \"patty\"\n47        } else {\n48            \"patties\"\n49        };\n50        let pretty_bool = |val| if val { \"\" } else { \"no \" };\n51        let pretty_vegetarian = if self.vegetarian { \"vegetarian \" \n           }\n          else { \"\" };\n52        println!(\n53            \"This is a {}burger with {} {}, {}cheese, {}bacon and\n              {}salad\",\n54            pretty_vegetarian,\n55            self.patty_count,\n56            pretty_patties,\n57            pretty_bool(self.cheese),\n58            pretty_bool(self.bacon),\n59            pretty_bool(self.salad)\n60        )\n61    }\n62 }\n```", "```rs\n64  struct BurgerBuilder {\n65    patty_count: i32,\n66    vegetarian: bool,\n67    cheese: bool,\n68    bacon: bool,\n69    salad: bool,\n70  }\n71  impl BurgerBuilder {\n72    // in the constructor, we can specify\n73    // the standard values\n74    fn new() -> Self {\n75      BurgerBuilder {\n76        patty_count: 1,\n77        vegetarian: false,\n78        cheese: false,\n79        bacon: false,\n80        salad: true,\n81      }\n82    }\n83\n84    // Now we have to define a method for every\n85    // configurable value\n86    fn patty_count(mut self, val: i32) -> Self {\n87      self.patty_count = val;\n88      self\n89    }\n90\n91    fn vegetarian(mut self, val: bool) -> Self {\n92      self.vegetarian = val;\n93      self\n94    }\n95    fn cheese(mut self, val: bool) -> Self {\n96      self.cheese = val;\n97      self\n98    }\n99    fn bacon(mut self, val: bool) -> Self {\n100     self.bacon = val;\n101     self\n102   }\n103   fn salad(mut self, val: bool) -> Self {\n104     self.salad = val;\n105     self\n106   }\n107\n108   // The final method actually constructs our object\n109   fn build(&self) -> Result<Burger, String> {\n110     let burger = Burger {\n111       patty_count: self.patty_count,\n112       vegetarian: self.vegetarian,\n113       cheese: self.cheese,\n114       bacon: self.bacon,\n115       salad: self.salad,\n116   };\n117   // Check for invalid configuration\n118   if burger.vegetarian && burger.bacon {\n119     Err(\"Sorry, but we don't server vegetarian bacon\n             yet\".to_string())\n120     } else {\n121       Ok(burger)\n122     }\n123   }\n124 }\n```", "```rs\nlet normal_burger = BurgerBuilder::new().build();\nlet cheese_burger = BurgerBuilder::new()\n    .cheese(true)\n    .salad(false)\n    .build();\nlet veggie_bigmac = BurgerBuilder::new()\n    .vegetarian(true)\n    .patty_count(2)\n    .build();\n```", "```rs\nif let Err(error) = invalid_burger {\n    println!(\"Failed to print burger: {}\", error);\n}\n```", "```rs\n1   use std::thread;\n2\n3   fn main() {\n4     // Spawning a thread lets it execute a lambda\n5     let child = thread::spawn(|| println!(\"Hello from a new\n      thread!\"));\n6     println!(\"Hello from the main thread!\");\n7     // Joining a child thread with the main thread means\n8     // that the main thread waits until the child has\n9     // finished it's work\n10    child.join().expect(\"Failed to join the child thread\");\n11 \n12    let sum = parallel_sum(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n13    println!(\"The sum of the numbers 1 to 10 is {}\", sum);\n14  }\n15 \n16  // We are going to write a function that\n17  // sums the numbers in a slice in parallel\n18  fn parallel_sum(range: &[i32]) -> i32 {\n19    // We are going to use exactly 4 threads to sum the numbers\n20    const NUM_THREADS: usize = 4;\n21     \n22    // If we have less numbers than threads,\n23    // there's no point in multithreading them\n24    if range.len() < NUM_THREADS {\n25      sum_bucket(range)\n26    } else {\n27        // We define \"bucket\" as the amount of numbers\n28        // we sum in a single thread\n29        let bucket_size = range.len() / NUM_THREADS;\n30        let mut count = 0;\n31        // This vector will keep track of our threads\n32        let mut threads = Vec::new();\n33        // We try to sum as much as possible in other threads\n34        while count + bucket_size < range.len() {\n35          let bucket = range[count..count +\n                               bucket_size].to_vec();\n36          let thread = thread::Builder::new()\n37            .name(\"calculation\".to_string())\n38            .spawn(move || sum_bucket(&bucket))\n39            .expect(\"Failed to create the thread\");\n40          threads.push(thread);\n41             \n42          count += bucket_size\n43    }\n44    // We are going to sum the rest in the main thread\n45    let mut sum = sum_bucket(&range[count..]);\n46         \n47    // Time to add the results up\n48    for thread in threads {\n49      sum += thread.join().expect(\"Failed to join thread\");\n50    }\n51    sum\n52  }\n53 }\n54 \n55  // This is the function that will be executed in the threads\n56  fn sum_bucket(range: &[i32]) -> i32 {\n57    let mut sum = 0;\n58    for num in range {\n59      sum += *num;\n60    }\n61     sum\n62  }\n```", "```rs\nlet bucket = range[count..count + bucket_size].to_vec();\n```", "```rs\nrand = \"0.3\"\n```", "```rs\n1   extern crate rand;\n2 \n3   fn main() {\n4     // random_num1 will be any integer between\n5     // std::i32::MIN and std::i32::MAX\n6     let random_num1 = rand::random::<i32>();\n7     println!(\"random_num1: {}\", random_num1);\n8     let random_num2: i32 = rand::random();\n9     println!(\"random_num2: {}\", random_num2);\n10    // The initialization of random_num1 and random_num2\n11    // is equivalent.\n12 \n13    // Every primitive data type can be randomized\n14    let random_char = rand::random::<char>();\n15    // Altough random_char will probably not be\n16    // representable on most operating systems\n17    println!(\"random_char: {}\", random_char);\n18 \n19 \n20    use rand::Rng;\n21    // We can use a reusable generator\n22    let mut rng = rand::thread_rng();\n23    // This is equivalent to rand::random()\n24    if rng.gen() {\n25      println!(\"This message has a 50-50 chance of being\n                  printed\");\n26    }\n27    // A generator enables us to use ranges\n28    // random_num3 will be between 0 and 9\n29    let random_num3 = rng.gen_range(0, 10);\n30    println!(\"random_num3: {}\", random_num3);\n31 \n32    // random_float will be between 0.0 and 0.999999999999...\n33    let random_float = rng.gen_range(0.0, 1.0);\n34    println!(\"random_float: {}\", random_float);\n35 \n36    // Per default, the generator uses a uniform distribution,\n37    // which should be good enough for nearly all of your\n38    // use cases. If you require a particular distribution,\n39    // you specify it when creating the generator:\n40    let mut chacha_rng = rand::ChaChaRng::new_unseeded();\n41    let random_chacha_num = chacha_rng.gen::<i32>();\n42    println!(\"random_chacha_num: {}\", random_chacha_num);\n43  }\n```", "```rs\nextern crate rand;\n```", "```rs\nprintln!(\"min: {}, max: {}\", std::i32::MIN, std::i32::MAX);\n```", "```rs\nregex = \"0.2\"\n```", "```rs\n1   extern crate regex;\n2\n3   fn main() {\n4     use regex::Regex;\n5     // Beginning a string with 'r' makes it a raw string,\n6     // in which you don't need to escape any symbols\n7     let date_regex =\n        Regex::new(r\"^\\d{2}.\\d{2}.\\d{4}$\").expect(\"Failed\n          to create regex\");\n8     let date = \"15.10.2017\";\n9     // Check for a match\n10    let is_date = date_regex.is_match(date);\n11    println!(\"Is '{}' a date? {}\", date, is_date);\n12\n13    // Let's use capture groups now\n14    let date_regex = Regex::new(r\"(\\d{2}).(\\d{2})\n        .(\\d{4})\").expect(\"Failed to create regex\");\n15    let text_with_dates = \"Alan Turing was born on 23.06.1912 and\n          died on 07.06.1954\\. \\\n16      A movie about his life called 'The Imitation Game' came out\n          on 14.11.2017\";\n17    // Iterate over the matches\n18    for cap in date_regex.captures_iter(text_with_dates) {\n19      println!(\"Found date {}\", &cap[0]);\n20      println!(\"Year: {} Month: {} Day: {}\", &cap[3], &cap[2],\n          &cap[1]);\n21    }\n22    // Replace the date format\n23    println!(\"Original text:\\t\\t{}\", text_with_dates);\n24    let text_with_indian_dates =\n        date_regex.replace_all(text_with_dates, \"$1-$2-$3\");\n25    println!(\"In indian format:\\t{}\", text_with_indian_dates);\n26\n27    // Replacing groups is easier when we name them\n28    // ?P<somename> gives a capture group a name\n29    let date_regex = Regex::new(r\"(?P<day>\\d{2}).(?P<month>\\d{2})\n        .(?P<year>\\d{4})\")\n30      .expect(\"Failed to create regex\");\n31    let text_with_american_dates =\n        date_regex.replace_all(text_with_dates,\n          \"$month/$day/$year\");\n32    println!(\"In american format:\\t{}\", \n      text_with_american_dates);\n33    let rust_regex = Regex::new(r\"(?i)rust\").expect(\"Failed to\n        create regex\");\n34    println!(\"Do we match RuSt? {}\", \n      rust_regex.is_match(\"RuSt\"));\n35    use regex::RegexBuilder;\n36    let rust_regex = RegexBuilder::new(r\"rust\")\n37      .case_insensitive(true)\n38      .build()\n39      .expect(\"Failed to create regex\");\n40    println!(\"Do we still match RuSt? {}\",\n        rust_regex.is_match(\"RuSt\"));\n41  }\n```", "```rs\n\"(\\\\d{2}).(\\\\d{2}).(\\\\d{4})\"\n```", "```rs\n1   use std::env;\n2\n3   fn main() {\n4     // env::args returns an iterator over the parameters\n5     println!(\"Got following parameters: \");\n6     for arg in env::args() {\n7       println!(\"- {}\", arg);\n8     }\n9\n10    // We can access specific parameters using the iterator API\n11    let mut args = env::args();\n12    if let Some(arg) = args.nth(0) {\n13      println!(\"The path to this program is: {}\", arg);\n14    }\n15    if let Some(arg) = args.nth(1) {\n16        println!(\"The first parameter is: {}\", arg);\n17    }\n18    if let Some(arg) = args.nth(2) {\n19        println!(\"The second parameter is: {}\", arg);\n20    }\n21\n22    // Or as a vector\n23    let args: Vec<_> = env::args().collect();\n24    println!(\"The path to this program is: {}\", args[0]);\n25    if args.len() > 1 {\n26        println!(\"The first parameter is: {}\", args[1]);\n27    }\n28    if args.len() > 2 {\n29        println!(\"The second parameter is: {}\", args[2]);\n30    }\n31  }\n```", "```rs\n1   use std::env;\n2\n3   fn main() {\n4     // We can iterate over all the env vars for the current\n      process\n5     println!(\"Listing all env vars:\");\n6     for (key, val) in env::vars() {\n7       println!(\"{}: {}\", key, val);\n8     }\n9\n10    let key = \"PORT\";\n11    println!(\"Setting env var {}\", key);\n12    // Setting an env var for the current process\n13    env::set_var(key, \"8080\");\n14\n15    print_env_var(key);\n16\n17    // Removing an env var for the current process\n18    println!(\"Removing env var {}\", key);\n19    env::remove_var(key);\n20\n21    print_env_var(key);\n22  }\n23\n24  fn print_env_var(key: &str) {\n25    // Accessing an env var\n26    match env::var(key) {\n27      Ok(val) => println!(\"{}: {}\", key, val),\n28      Err(e) => println!(\"Couldn't print env var {}: {}\", key, e),\n29    }\n30  }\n```", "```rs\nredis_addr = env::var(\"REDIS_ADDR\")\n    .unwrap_or_default(\"localhost:6379\".to_string());\n```", "```rs\n1   use std::io;\n2   use std::io::prelude::*;\n3\n4   fn main() {\n5     print_single_line(\"Please enter your forename: \");\n6     let forename = read_line_iter();\n7\n8     print_single_line(\"Please enter your surname: \");\n9     let surname = read_line_buffer();\n10\n11    print_single_line(\"Please enter your age: \");\n12    let age = read_number();\n13\n14    println!(\n15      \"Hello, {} year old human named {} {}!\",\n16      age, forename, surname\n17    );\n18  }\n19\n20  fn print_single_line(text: &str) {\n21    // We can print lines without adding a newline\n22    print!(\"{}\", text);\n23    // However, we need to flush stdout afterwards\n24    // in order to guarantee that the data actually displays\n25    io::stdout().flush().expect(\"Failed to flush stdout\");\n26  }\n27\n28  fn read_line_iter() -> String {\n29    let stdin = io::stdin();\n30    // Read one line of input iterator-style\n31    let input = stdin.lock().lines().next();\n32    input\n33      .expect(\"No lines in buffer\")\n34      .expect(\"Failed to read line\")\n35      .trim()\n36      .to_string()\n37  }\n38\n39  fn read_line_buffer() -> String {\n40    // Read one line of input buffer-style\n41    let mut input = String::new();\n42    io::stdin()\n43      .read_line(&mut input)\n44      .expect(\"Failed to read line\");\n45    input.trim().to_string()\n46  }\n47\n48  fn read_number() -> i32 {\n49    let stdin = io::stdin();\n50    loop {\n51      // Iterate over all lines that will be inputted\n52      for line in stdin.lock().lines() {\n53        let input = line.expect(\"Failed to read line\");\n54        // Try to convert a string into a number\n55        match input.trim().parse::<i32>() {\n56          Ok(num) => return num,\n57            Err(e) => println!(\"Failed to read number: {}\", e),\n58        }\n59      }\n60    }\n61  }\n```", "```rs\n1   macro_rules! multiply {\n2     // Edge case\n3     ( $last:expr ) => { $last };\n4\n5     ( $head:expr, $($tail:expr), +) => {\n6       // Recursive call\n7       $head * multiply!($($tail),+)\n8     };\n9   }\n10\n11  fn main() {\n12    // You can call multiply! with\n13    // as many parameters as you want\n14    let val = multiply!(2, 4, 8);\n15    println!(\"2*4*8 = {}\", val)\n16  }\n```"]