["```rs\nstruct Tetrimino {\n    states: Vec<Vec<Vec<u8>>>,\n    x: isize,\n    y: usize,\n    current_state: u8,\n}\n```", "```rs\nstates: Vec<Vec<Vec<u8>>>,\n```", "```rs\nvec![vec![1, 1, 0, 0],\n     vec![1, 1, 0, 0],\n     vec![0, 0, 0, 0],\n     vec![0, 0, 0, 0]]\n```", "```rs\ntype Piece = Vec<Vec<u8>>;\n```", "```rs\nstates: Vec<Piece>,\n```", "```rs\ntype States = Vec<Piece>;\n```", "```rs\nstates: States,\n```", "```rs\nstruct Tetrimino {\n    states: States,\n    x: isize,\n    y: usize,\n    current_state: u8,\n}\n\n```", "```rs\ntrait TetriminoGenerator {\n    fn new() -> Tetrimino;\n}\n```", "```rs\nstruct TetriminoI;\n```", "```rs\nimpl TetriminoGenerator for TetriminoI {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![1, 1, 1, 1],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nlet tetrimino = TetriminoI::new();\n```", "```rs\nstruct TetriminoJ;\n\nimpl TetriminoGenerator for TetriminoJ {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![2, 2, 2, 0],\n                              vec![2, 0, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![2, 2, 0, 0],\n                              vec![0, 2, 0, 0],\n                              vec![0, 2, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 0, 2, 0],\n                              vec![2, 2, 2, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![2, 0, 0, 0],\n                              vec![2, 0, 0, 0],\n                              vec![2, 2, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nstruct TetriminoL;\n\nimpl TetriminoGenerator for TetriminoL {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![3, 3, 3, 0],\n                              vec![0, 0, 3, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 3, 0, 0],\n                              vec![0, 3, 0, 0],\n                              vec![3, 3, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![3, 0, 0, 0],\n                              vec![3, 3, 3, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![3, 3, 0, 0],\n                              vec![3, 0, 0, 0],\n                              vec![3, 0, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nstruct TetriminoO;\n\nimpl TetriminoGenerator for TetriminoO {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![4, 4, 0, 0],\n                              vec![4, 4, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 5,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nstruct TetriminoS;\n\nimpl TetriminoGenerator for TetriminoS {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![0, 5, 5, 0],\n                              vec![5, 5, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 5, 0, 0],\n                              vec![0, 5, 5, 0],\n                              vec![0, 0, 5, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nstruct TetriminoZ;\n\nimpl TetriminoGenerator for TetriminoZ {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![6, 6, 0, 0],\n                              vec![0, 6, 6, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 0, 6, 0],\n                              vec![0, 6, 6, 0],\n                              vec![0, 6, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nstruct TetriminoT;\n\nimpl TetriminoGenerator for TetriminoT {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![7, 7, 7, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![7, 7, 0, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![7, 7, 7, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![0, 7, 7, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n```", "```rs\nrand = \"0.3\"\n```", "```rs\nextern crate rand;\n```", "```rs\nfn create_new_tetrimino() -> Tetrimino {\n    let rand_nb = rand::random::<u8>() % 7;\n    match rand_nb {\n        0 => TetriminoI::new(),\n        1 => TetriminoJ::new(),\n        2 => TetriminoL::new(),\n        3 => TetriminoO::new(),\n        4 => TetriminoS::new(),\n        5 => TetriminoZ::new(),\n        6 => TetriminoT::new(),\n        _ => unreachable!(),\n    }\n}\n```", "```rs\nfn create_new_tetrimino() -> Tetrimino {\n    static mut PREV: u8 = 7;\n    let mut rand_nb = rand::random::<u8>() % 7;\n    if unsafe { PREV } == rand_nb {\n        rand_nb = rand::random::<u8>() % 7;\n    }\n    unsafe { PREV = rand_nb; }\n    match rand_nb {\n        0 => TetriminoI::new(),\n        1 => TetriminoJ::new(),\n        2 => TetriminoL::new(),\n        3 => TetriminoO::new(),\n        4 => TetriminoS::new(),\n        5 => TetriminoZ::new(),\n        6 => TetriminoT::new(),\n        _ => unreachable!(),\n    }\n}\n```", "```rs\nfn foo() -> u32 {\n    static mut VALUE: u32 = 12;\n    unsafe {\n        VALUE += 1;\n        VALUE\n    }\n}\n\nfor _ in 0..5 {\n    println!(\"{}\", foo());\n}\n```", "```rs\n13\n14\n15\n16\n17\n```", "```rs\nimpl Tetrimino {\n    fn rotate(&mut self) {\n        self.current_state += 1;\n        if self.current_state as usize >= self.states.len() {\n            self.current_state = 0;\n        }\n    }\n}\n```", "```rs\nVec<Vec<u8>>\n```", "```rs\nfn test_position(&self, game_map: &[Vec<u8>],\n                 tmp_state: usize, x: isize, y: usize) -> bool {\n    for decal_y in 0..4 {\n      for decal_x in 0..4 {\n        let x = x + decal_x;\n        if self.states[tmp_state][decal_y][decal_x as usize] != 0 \n            &&\n                (y + decal_y >= game_map.len() ||\n                 x < 0 ||\n                 x as usize >= game_map[y + decal_y].len() ||\n                 game_map[y + decal_y][x as usize] != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```", "```rs\nfn rotate(&mut self, game_map: &[Vec<u8>]) {\n    let mut tmp_state = self.current_state + 1;\n    if tmp_state as usize >= self.states.len() {\n        tmp_state = 0;\n    }\n    let x_pos = [0, -1, 1, -2, 2, -3];\n    for x in x_pos.iter() {\n        if self.test_position(game_map, tmp_state as usize,\n                              self.x + x, self.y) == true {\n            self.current_state = tmp_state;\n            self.x += *x;\n            break\n        }\n    }\n}\n```", "```rs\nlet mut tmp_state = self.current_state + 1;\nif tmp_state as usize >= self.states.len() {\n    tmp_state = 0;\n}\n```", "```rs\nlet x_pos = [0, -1, 1, -2, 2, -3];\n```", "```rs\nfor x in x_pos.iter() {\n    if self.test_position(game_map, tmp_state as usize,\n                          self.x + x, self.y) == true {\n        self.current_state = tmp_state;\n        self.x += *x;\n        break\n    }\n}\n```", "```rs\nfn change_position(&mut self, game_map: &[Vec<u8>], new_x: isize, new_y: usize) -> bool {\n    if self.test_position(game_map, self.current_state as usize,  \n    new_x, new_y) == true {\n        self.x = new_x as isize;\n        self.y = new_y;\n        true\n    } else {\n        false\n    }\n}\n```", "```rs\nfn test_current_position(&self, game_map: &[Vec<u8>]) -> bool {\n    self.test_position(game_map, self.current_state as usize,  \n    self.x, self.y)\n}\n```", "```rs\nstruct Tetris {\n    game_map: Vec<Vec<u8>>,\n    current_level: u32,\n    score: u32,\n    nb_lines: u32,\n    current_piece: Option<Tetrimino>,\n}\n```", "```rs\nimpl Tetris {\n    fn new() -> Tetris {\n        let mut game_map = Vec::new();\n        for _ in 0..16 {\n            game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        }\n        Tetris {\n            game_map: game_map,\n            current_level: 1,\n            score: 0,\n            nb_lines: 0,\n            current_piece: None,\n        }\n    }\n}\n```", "```rs\nlet mut game_map = Vec::new();\nfor _ in 0..16 {\n    game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n}\n```", "```rs\nrand = \"0.3\"\n```", "```rs\nextern crate rand;\n```", "```rs\nfn create_new_tetrimino(&self) -> Tetrimino {\n    static mut PREV: u8 = 7;\n    let mut rand_nb = rand::random::<u8>() % 7;\n    if unsafe { PREV } == rand_nb {\n        rand_nb = rand::random::<u8>() % 7;\n    }\n    unsafe { PREV = rand_nb; }\n    match rand_nb {\n        0 => TetriminoI::new(),\n        1 => TetriminoJ::new(),\n        2 => TetriminoL::new(),\n        3 => TetriminoO::new(),\n        4 => TetriminoS::new(),\n        5 => TetriminoZ::new(),\n        6 => TetriminoT::new(),\n        _ => unreachable!(),\n    }\n}\n```", "```rs\nstatic mut PREV: u8 = 7;\n```", "```rs\nfn incr() -> u32 {\n    static mut NB: u32 = 0;\n    unsafe {\n        NB += 1;\n        NB\n    }\n}\n```", "```rs\nfor _ in 0..5 {\n    println!(\"{}\", incr());\n}\n```", "```rs\n1\n2\n3\n4\n5\n```", "```rs\nlet mut rand_nb = rand::random::<u8>() % 7;\n```", "```rs\nif unsafe { PREV } == rand_nb {\n    rand_nb = rand::random::<u8>() % 7;\n}\n```", "```rs\nunsafe { PREV = rand_nb; }\n```", "```rs\nmatch rand_nb {\n    0 => TetriminoI::new(),\n    1 => TetriminoJ::new(),\n    2 => TetriminoL::new(),\n    3 => TetriminoO::new(),\n    4 => TetriminoS::new(),\n    5 => TetriminoZ::new(),\n    6 => TetriminoT::new(),\n    _ => unreachable!(),\n}\n```", "```rs\n_ => unreachable!(),\n```", "```rs\nfn check_lines(&mut self) {\n    let mut y = 0;\n\n    while y < self.game_map.len() {\n        let mut complete = true;\n\n        for x in &self.game_map[y] {\n            if *x == 0 {\n                complete = false;\n                break\n            }\n        }\n        if complete == true {\n            self.game_map.remove(y);\n            y -= 1;\n            // increase the number of self.lines\n        }\n        y += 1;\n    }\n    while self.game_map.len() < 16 {\n        self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    }\n}\n```", "```rs\nwhile y < self.game_map.len() {\n```", "```rs\nfor line in self.game_map {\n```", "```rs\nself.game_map.remove(y);\n```", "```rs\nwhile self.game_map.len() < 16 {\n    self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n}\n```", "```rs\nfn make_permanent(&mut self) {\n    if let Some(ref mut piece) = self.current_piece {\n        let mut shift_y = 0;\n\n        while shift_y < piece.states[piece.current_state as  \n         usize].len() &&\n              piece.y + shift_y < self.game_map.len() {\n            let mut shift_x = 0;\n\n            while shift_x < piece.states[piece.current_state as  \n             usize][shift_y].len() &&\n                  (piece.x + shift_x as isize) < \n                   self.game_map[piece.y +  \n                   shift_y].len() as isize {\n                if piece.states[piece.current_state as usize] \n                [shift_y][shift_x] != 0 {\n                    let x = piece.x + shift_x as isize;\n                    self.game_map[piece.y + shift_y][x as usize] =\n                        piece.states[piece.current_state as usize] \n                         [shift_y][shift_x];\n                }\n                shift_x += 1;\n            }\n            shift_y += 1;\n        }\n    }\n    self.check_lines();\n    self.current_piece = None;\n}\n```", "```rs\nif let Some(ref mut piece) = self.current_piece {\n```", "```rs\nwhile shift_y < piece.states[piece.current_state as usize].len() &&\n      piece.y + shift_y < self.game_map.len() {\n```", "```rs\nwhile shift_x < piece.states[piece.current_state as usize][shift_y].len() &&\n      (piece.x + shift_x as isize) < self.game_map[piece.y + shift_y].len() as isize {\n```", "```rs\nif piece.states[piece.current_state as usize][shift_y][shift_x] != 0 {\n    let x = piece.x + shift_x as isize;\n    self.game_map[piece.y + shift_y][x as usize] =\n        piece.states[piece.current_state as usize][shift_y][shift_x];\n}\n```", "```rs\nif let Some(ref mut piece) = self.current_piece {\n```", "```rs\nfn handle_events(tetris: &mut Tetris, quit: &mut bool, timer: &mut SystemTime,\n                 event_pump: &mut sdl2::EventPump) -> bool {\n    let mut make_permanent = false;\n    if let Some(ref mut piece) = tetris.current_piece {\n        let mut tmp_x = piece.x;\n        let mut tmp_y = piece.y;\n\n        for event in event_pump.poll_iter() {\n          match event {\n          Event::Quit { .. } |\n          Event::KeyDown { keycode: Some(Keycode::Escape), .. } => \n                {\n                    *quit = true;\n                    break\n                }\n           Event::KeyDown { keycode: Some(Keycode::Down), .. } =>\n                {\n                    *timer = SystemTime::now();\n                    tmp_y += 1;\n                }\n           Event::KeyDown { keycode: Some(Keycode::Right), .. } => \n                {\n                    tmp_x += 1;\n                }\n            Event::KeyDown { keycode: Some(Keycode::Left), .. } => \n                {\n                    tmp_x -= 1;\n                }\n            Event::KeyDown { keycode: Some(Keycode::Up), .. } => \n                {\n                    piece.rotate(&tetris.game_map);\n                }\n           Event::KeyDown { keycode: Some(Keycode::Space), .. } => \n               {\n                  let x = piece.x;\n                  let mut y = piece.y;\n           while piece.change_position(&tetris.game_map, x, y + 1) \n           == true {\n                        y += 1;\n                   }\n                    make_permanent = true;\n                }\n                _ => {}\n            }\n        }\n        if !make_permanent {\n         if piece.change_position(&tetris.game_map, tmp_x, tmp_y)\n           == \n            false &&\n               tmp_y != piece.y {\n                make_permanent = true;\n            }\n        }\n    }\n    if make_permanent {\n        tetris.make_permanent();\n        *timer = SystemTime::now();\n    }\n    make_permanent\n}\n```", "```rs\nlet mut make_permanent = false;\n```", "```rs\nif let Some(ref mut piece) = tetris.current_piece {\n```", "```rs\nlet mut tmp_x = piece.x;\nlet mut tmp_y = piece.y;\n```", "```rs\nfor event in event_pump.poll_iter() {\n```", "```rs\nmatch event {\n    Event::Quit { .. } |\n    Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n        *quit = true;\n        break\n    }\n    Event::KeyDown { keycode: Some(Keycode::Down), .. } => {\n        *timer = SystemTime::now();\n        tmp_y += 1;\n    }\n    Event::KeyDown { keycode: Some(Keycode::Right), .. } => {\n        tmp_x += 1;\n    }\n    Event::KeyDown { keycode: Some(Keycode::Left), .. } => {\n        tmp_x -= 1;\n    }\n    Event::KeyDown { keycode: Some(Keycode::Up), .. } => {\n        piece.rotate(&tetris.game_map);\n    }\n    Event::KeyDown { keycode: Some(Keycode::Space), .. } => {\n      let x = piece.x;\n      let mut y = piece.y;\n      while piece.change_position(&tetris.game_map, x, y + 1) ==  \n      true {\n            y += 1;\n        }\n        make_permanent = true;\n    }\n    _ => {}\n}\n```", "```rs\nEvent::Quit { .. } |\nEvent::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n    *quit = true;\n    break\n}\n```", "```rs\nEvent::KeyDown { keycode: Some(Keycode::Down), .. } => {\n    *timer = SystemTime::now();\n    tmp_y += 1;\n}\n```", "```rs\nEvent::KeyDown { keycode: Some(Keycode::Right), .. } => {\n    tmp_x += 1;\n}\nEvent::KeyDown { keycode: Some(Keycode::Left), .. } => {\n    tmp_x -= 1;\n}\n```", "```rs\nEvent::KeyDown { keycode: Some(Keycode::Up), .. } => {\n    piece.rotate(&tetris.game_map);\n}\n```", "```rs\nEvent::KeyDown { keycode: Some(Keycode::Space), .. } => {\n   let x = piece.x;\n   let mut y = piece.y;\n  while piece.change_position(&tetris.game_map, x, y + 1) == true {\n        y += 1;\n    }\n    make_permanent = true;\n}\n```", "```rs\nfn print_game_information(tetris: &Tetris) {\n    println!(\"Game over...\");\n    println!(\"Score:           {}\", tetris.score);\n    // println!(\"Number of lines: {}\", tetris.nb_lines);\n    println!(\"Current level:   {}\", tetris.current_level);\n    // Check highscores here and update if needed\n}\n\nlet mut tetris = Tetris::new();\nlet mut timer = SystemTime::now();\n\nloop {\n    if match timer.elapsed() {\n        Ok(elapsed) => elapsed.as_secs() >= 1,\n        Err(_) => false,\n    } {\n        let mut make_permanent = false;\n        if let Some(ref mut piece) = tetris.current_piece {\n            let x = piece.x;\n            let y = piece.y + 1;\n            make_permanent =  \n             !piece.change_position(&tetris.game_map,  \n             x, y);\n        }\n        if make_permanent {\n            tetris.make_permanent();\n        }\n        timer = SystemTime::now();\n    }\n\n    // We need to draw the tetris \"grid\" in here.\n\n    if tetris.current_piece.is_none() {\n        let current_piece = tetris.create_new_tetrimino();\n        if !current_piece.test_current_position(&tetris.game_map) {\n            print_game_information(&tetris);\n            break\n        }\n        tetris.current_piece = Some(current_piece);\n    }\n    let mut quit = false;\n    if !handle_events(&mut tetris, &mut quit, &mut timer, &mut \n     event_pump) {\n        if let Some(ref mut piece) = tetris.current_piece {\n            // We need to draw our current tetrimino in here.\n        }\n    }\n    if quit {\n        print_game_information(&tetris);\n        break\n    }\n\n    // We need to draw the game map in here.\n\n    sleep(Duration::new(0, 1_000_000_000u32 / 60));\n}\n```", "```rs\nlet mut tetris = Tetris::new();\nlet mut timer = SystemTime::now();\n```", "```rs\nif match timer.elapsed() {\n    Ok(elapsed) => elapsed.as_secs() >= 1,\n    Err(_) => false,\n} {\n    let mut make_permanent = false;\n    if let Some(ref mut piece) = tetris.current_piece {\n        let x = piece.x;\n        let y = piece.y + 1;\n        make_permanent = !piece.change_position(&tetris.game_map,\n         x, y);\n    }\n    if make_permanent {\n        tetris.make_permanent();\n    }\n    timer = SystemTime::now();\n}\n```", "```rs\nOk(elapsed) => elapsed.as_secs() >= 1,\n```", "```rs\n!piece.change_position(&tetris.game_map, x, y)\n```", "```rs\nif let Some(ref mut piece) = tetris.current_piece {\n```", "```rs\nif tetris.current_piece.is_none() {\n    let current_piece = tetris.create_new_tetrimino();\n    if !current_piece.test_current_position(&tetris.game_map) {\n        print_game_information(&tetris);\n        return\n    }\n    tetris.current_piece = Some(current_piece);\n}\n```", "```rs\nlet mut quit = false;\nif !handle_events(&mut tetris, &mut quit, &mut timer, &mut event_pump) {\n    if let Some(ref mut piece) = tetris.current_piece {\n        // We need to draw our current tetrimino in here.\n    }\n}\nif quit {\n    print_game_information(&tetris);\n    break\n}\n```", "```rs\nfn update_score(&mut self, to_add: u32) {\n    self.score += to_add;\n}\n```", "```rs\nfn check_lines(&mut self) {\n    let mut y = 0;\n    let mut score_add = 0;\n\n    while y < self.game_map.len() {\n        let mut complete = true;\n\n        for x in &self.game_map[y] {\n            if *x == 0 {\n                complete = false;\n                break\n            }\n        }\n        if complete == true {\n            score_add += self.current_level;\n            self.game_map.remove(y);\n            y -= 1;\n        }\n        y += 1;\n    }\n    if self.game_map.len() == 0 {\n        // A \"tetris\"!\n        score_add += 1000;\n    }\n    self.update_score(score_add);\n    while self.game_map.len() < 16 {\n        // we'll add this method just after!\n        self.increase_line();\n        self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0]);\n    }\n}\n```", "```rs\nfn make_permanent(&mut self) {\n    let mut to_add = 0;\n    if let Some(ref mut piece) = self.current_piece {\n        let mut shift_y = 0;\n\n        while shift_y < piece.states[piece.current_state as \n         usize].len() &&\n              piece.y + shift_y < self.game_map.len() {\n            let mut shift_x = 0;\n\n            while shift_x < piece.states[piece.current_state as usize] \n             [shift_y].len() &&\n                  (piece.x + shift_x as isize) < self.game_map[piece.y  \n                   + shift_y].len() as isize {\n                if piece.states[piece.current_state as usize][shift_y] \n                 [shift_x] != 0 {\n                    let x = piece.x + shift_x as isize;\n                    self.game_map[piece.y + shift_y][x as usize] =\n                        piece.states[piece.current_state as usize]    \n                         [shift_y][shift_x];\n                }\n                shift_x += 1;\n            }\n            shift_y += 1;\n        }\n        to_add += self.current_level;\n    }\n    self.update_score(to_add);\n    self.check_lines();\n    self.current_piece = None;\n}\n```", "```rs\nconst LEVEL_TIMES: [u32; 10] = [1000, 850, 700, 600, 500, 400, 300, 250, 221, 190];\nconst LEVEL_LINES: [u32; 10] = [20,   40,  60,  80,  100, 120, 140, 160, 180, 200];\n```", "```rs\nfn increase_line(&mut self) {\n    self.nb_lines += 1;\n    if self.nb_lines > LEVEL_LINES[self.current_level as usize - 1] {\n        self.current_level += 1;\n    }\n}\n```", "```rs\nfn is_time_over() {\n    match timer.elapsed() {\n        Ok(elapsed) => {\n            let millis = elapsed.as_secs() as u32 * 1000 + \n             elapsed.subsec_nanos() / 1_000_000;\n            millis > LEVEL_TIMES[tetris.current_level as usize - 1]\n        }\n        Err(_) => false,\n    }\n}\n```", "```rs\nif is_time_over(&tetris, &timer) {\n    let mut make_permanent = false;\n    if let Some(ref mut piece) = tetris.current_piece {\n        let x = piece.x;\n        let y = piece.y + 1;\n        make_permanent = !piece.change_position(&tetris.game_map,\n         x, y);\n    }\n    if make_permanent {\n        tetris.make_permanent();\n    }\n    timer = SystemTime::now();\n}\n```", "```rs\nconst NB_HIGHSCORES: usize = 5;\n\nfn update_vec(v: &mut Vec<u32>, value: u32) -> bool {\n    if v.len() < NB_HIGHSCORES {\n        v.push(value);\n        v.sort();\n        true\n    } else {\n        for entry in v.iter_mut() {\n            if value > *entry {\n                *entry = value;\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn print_game_information(tetris: &Tetris) {\n    let mut new_highest_highscore = true;\n    let mut new_highest_lines_sent = true;\n    if let Some((mut highscores, mut lines_sent)) = \n     load_highscores_and_lines() {\n        new_highest_highscore = update_vec(&mut highscores,  \n         tetris.score);\n        new_highest_lines_sent = update_vec(&mut lines_sent,  \n         tetris.nb_lines);\n        if new_highest_highscore || new_highest_lines_sent {\n            save_highscores_and_lines(&highscores, &lines_sent);\n        }\n    } else {\n        save_highscores_and_lines(&[tetris.score], &\n         [tetris.nb_lines]);\n    }\n    println!(\"Game over...\");\n    println!(\"Score:           {}{}\",\n             tetris.score,\n             if new_highest_highscore { \" [NEW HIGHSCORE]\"} else {   \n              \"\" });\n    println!(\"Number of lines: {}{}\",\n             tetris.nb_lines,\n             if new_highest_lines_sent { \" [NEW HIGHSCORE]\"} else {  \n              \"\" });\n    println!(\"Current level:   {}\", tetris.current_level);\n}\n```", "```rs\nextern crate rand;\nextern crate sdl2;\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\nuse sdl2::pixels::Color;\nuse sdl2::rect::Rect;\nuse sdl2::render::{Canvas, Texture, TextureCreator};\nuse sdl2::video::{Window, WindowContext};\n\nuse std::fs::File;\nuse std::io::{self, Read, Write};\nuse std::thread::sleep;\nuse std::time::{Duration, SystemTime};\n\nconst TETRIS_HEIGHT: usize = 40;\nconst HIGHSCORE_FILE: &'static str = \"scores.txt\";\nconst LEVEL_TIMES: [u32; 10] = [1000, 850, 700, 600, 500, 400, 300, 250, 221, 190];\nconst LEVEL_LINES: [u32; 10] = [20,   40,  60,  80,  100, 120, 140, 160, 180, 200];\nconst NB_HIGHSCORES: usize = 5;\n\ntype Piece = Vec<Vec<u8>>;\ntype States = Vec<Piece>;\n\ntrait TetriminoGenerator {\n    fn new() -> Tetrimino;\n}\n\nstruct TetriminoI;\n\nimpl TetriminoGenerator for TetriminoI {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![1, 1, 1, 1],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0],\n                              vec![0, 1, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoJ;\n\nimpl TetriminoGenerator for TetriminoJ {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![2, 2, 2, 0],\n                              vec![2, 0, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![2, 2, 0, 0],\n                              vec![0, 2, 0, 0],\n                              vec![0, 2, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 0, 2, 0],\n                              vec![2, 2, 2, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![2, 0, 0, 0],\n                              vec![2, 0, 0, 0],\n                              vec![2, 2, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoL;\n\nimpl TetriminoGenerator for TetriminoL {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![3, 3, 3, 0],\n                              vec![0, 0, 3, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 3, 0, 0],\n                              vec![0, 3, 0, 0],\n                              vec![3, 3, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![3, 0, 0, 0],\n                              vec![3, 3, 3, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![3, 3, 0, 0],\n                              vec![3, 0, 0, 0],\n                              vec![3, 0, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoO;\n\nimpl TetriminoGenerator for TetriminoO {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![4, 4, 0, 0],\n                              vec![4, 4, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 5,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoS;\n\nimpl TetriminoGenerator for TetriminoS {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![0, 5, 5, 0],\n                              vec![5, 5, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 5, 0, 0],\n                              vec![0, 5, 5, 0],\n                              vec![0, 0, 5, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoZ;\n\nimpl TetriminoGenerator for TetriminoZ {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![6, 6, 0, 0],\n                              vec![0, 6, 6, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 0, 6, 0],\n                              vec![0, 6, 6, 0],\n                              vec![0, 6, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct TetriminoT;\n\nimpl TetriminoGenerator for TetriminoT {\n    fn new() -> Tetrimino {\n        Tetrimino {\n            states: vec![vec![vec![7, 7, 7, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![7, 7, 0, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![7, 7, 7, 0],\n                              vec![0, 0, 0, 0],\n                              vec![0, 0, 0, 0]],\n                         vec![vec![0, 7, 0, 0],\n                              vec![0, 7, 7, 0],\n                              vec![0, 7, 0, 0],\n                              vec![0, 0, 0, 0]]],\n            x: 4,\n            y: 0,\n            current_state: 0,\n        }\n    }\n}\n\nstruct Tetrimino {\n    states: States,\n    x: isize,\n    y: usize,\n    current_state: u8,\n}\n\nimpl Tetrimino {\n    fn rotate(&mut self, game_map: &[Vec<u8>]) {\n        let mut tmp_state = self.current_state + 1;\n        if tmp_state as usize >= self.states.len() {\n            tmp_state = 0;\n        }\n        let x_pos = [0, -1, 1, -2, 2, -3];\n        for x in x_pos.iter() {\n            if self.test_position(game_map, tmp_state as usize,\n                                  self.x + x, self.y) == true {\n                self.current_state = tmp_state;\n                self.x += *x;\n                break\n            }\n        }\n    }\n\n    fn test_position(&self, game_map: &[Vec<u8>],\n                     tmp_state: usize, x: isize, y: usize) -> bool {\n        for shift_y in 0..4 {\n            for shift_x in 0..4 {\n                let x = x + shift_x;\n                if self.states[tmp_state][shift_y][shift_x as usize] != 0 &&\n                    (y + shift_y >= game_map.len() ||\n                     x < 0 ||\n                     x as usize >= game_map[y + shift_y].len() ||\n                     game_map[y + shift_y][x as usize] != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    fn test_current_position(&self, game_map: &[Vec<u8>]) -> bool {\n        self.test_position(game_map, self.current_state as usize, self.x, self.y)\n    }\n\n    fn change_position(&mut self, game_map: &[Vec<u8>], new_x: isize, new_y: usize) -> bool {\n        if self.test_position(game_map, self.current_state as usize, new_x, new_y) == true {\n            self.x = new_x as isize;\n            self.y = new_y;\n            true\n        } else {\n            false\n        }\n    }\n}\n\nstruct Tetris {\n    game_map: Vec<Vec<u8>>,\n    current_level: u32,\n    score: u32,\n    nb_lines: u32,\n    current_piece: Option<Tetrimino>,\n}\n\nimpl Tetris {\n    fn new() -> Tetris {\n        let mut game_map = Vec::new();\n        for _ in 0..16 {\n            game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        }\n        Tetris {\n            game_map: game_map,\n            current_level: 1,\n            score: 0,\n            nb_lines: 0,\n            current_piece: None,\n        }\n    }\n\n    fn update_score(&mut self, to_add: u32) {\n        self.score += to_add;\n    }\n\n    fn increase_level(&mut self) {\n        self.current_level += 1;\n    }\n\n    fn increase_line(&mut self) {\n        self.nb_lines += 1;\n        if self.nb_lines > LEVEL_LINES[self.current_level as usize - 1] {\n            self.increase_level();\n        }\n    }\n\n    fn check_lines(&mut self) {\n        let mut y = 0;\n        let mut score_add = 0;\n\n        while y < self.game_map.len() {\n            let mut complete = true;\n\n            for x in &self.game_map[y] {\n                if *x == 0 {\n                    complete = false;\n                    break\n                }\n            }\n            if complete == true {\n                score_add += self.current_level;\n                self.game_map.remove(y);\n                y -= 1;\n            }\n            y += 1;\n        }\n        if self.game_map.len() == 0 {\n            // A \"tetris\"!\n            score_add += 1000;\n        }\n        self.update_score(score_add);\n        while self.game_map.len() < 16 {\n            self.increase_line();\n            self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        }\n    }\n\n    fn create_new_tetrimino(&self) -> Tetrimino {\n        static mut PREV: u8 = 7;\n        let mut rand_nb = rand::random::<u8>() % 7;\n        if unsafe { PREV } == rand_nb {\n            rand_nb = rand::random::<u8>() % 7;\n        }\n        unsafe { PREV = rand_nb; }\n        match rand_nb {\n            0 => TetriminoI::new(),\n            1 => TetriminoJ::new(),\n            2 => TetriminoL::new(),\n            3 => TetriminoO::new(),\n            4 => TetriminoS::new(),\n            5 => TetriminoZ::new(),\n            6 => TetriminoT::new(),\n            _ => unreachable!(),\n        }\n    }\n\n    fn make_permanent(&mut self) {\n        let mut to_add = 0;\n        if let Some(ref mut piece) = self.current_piece {\n            let mut shift_y = 0;\n\n            while shift_y < piece.states[piece.current_state as usize].len() &&\n                  piece.y + shift_y < self.game_map.len() {\n                let mut shift_x = 0;\n\n                while shift_x < piece.states[piece.current_state as usize] \n                  [shift_y].len() &&\n                      (piece.x + shift_x as isize) < self.game_map[piece.y + \n                       shift_y].len() as isize {\n                    if piece.states[piece.current_state as usize][shift_y][shift_x]  \n                    != 0 {\n                        let x = piece.x + shift_x as isize;\n                        self.game_map[piece.y + shift_y][x as usize] =\n                            piece.states[piece.current_state as usize][shift_y]\n                            [shift_x];\n                    }\n                    shift_x += 1;\n                }\n                shift_y += 1;\n            }\n            to_add += self.current_level;\n        }\n        self.update_score(to_add);\n        self.check_lines();\n        self.current_piece = None;\n    }\n}\n\nfn handle_events(tetris: &mut Tetris, quit: &mut bool, timer: &mut SystemTime,\n                 event_pump: &mut sdl2::EventPump) -> bool {\n    let mut make_permanent = false;\n    if let Some(ref mut piece) = tetris.current_piece {\n        let mut tmp_x = piece.x;\n        let mut tmp_y = piece.y;\n\n        for event in event_pump.poll_iter() {\n            match event {\n                Event::Quit { .. } |\n                Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n                    *quit = true;\n                    break\n                }\n                Event::KeyDown { keycode: Some(Keycode::Down), .. } => {\n                    *timer = SystemTime::now();\n                    tmp_y += 1;\n                }\n                Event::KeyDown { keycode: Some(Keycode::Right), .. } => {\n                    tmp_x += 1;\n                }\n                Event::KeyDown { keycode: Some(Keycode::Left), .. } => {\n                    tmp_x -= 1;\n                }\n                Event::KeyDown { keycode: Some(Keycode::Up), .. } => {\n                    piece.rotate(&tetris.game_map);\n                }\n                Event::KeyDown { keycode: Some(Keycode::Space), .. } => {\n                    let x = piece.x;\n                    let mut y = piece.y;\n                    while piece.change_position(&tetris.game_map, x, y + 1) == true \n                    {\n                        y += 1;\n                    }\n                    make_permanent = true;\n                }\n                _ => {}\n            }\n        }\n        if !make_permanent {\n            if piece.change_position(&tetris.game_map, tmp_x, tmp_y) == false &&\n               tmp_y != piece.y {\n                make_permanent = true;\n            }\n        }\n    }\n    if make_permanent {\n        tetris.make_permanent();\n        *timer = SystemTime::now();\n    }\n    make_permanent\n}\n\nfn write_into_file(content: &str, file_name: &str) -> io::Result<()> {\n    let mut f = File::create(file_name)?;\n    f.write_all(content.as_bytes())\n}\n\nfn read_from_file(file_name: &str) -> io::Result<String> {\n    let mut f = File::open(file_name)?;\n    let mut content = String::new();\n    f.read_to_string(&mut content)?;\n    Ok(content)\n}\n\nfn slice_to_string(slice: &[u32]) -> String {\n    slice.iter().map(|highscore| highscore.to_string()).collect::<Vec<String>>().join(\" \")\n}\n\nfn save_highscores_and_lines(highscores: &[u32], number_of_lines: &[u32]) -> bool {\n    let s_highscores = slice_to_string(highscores);\n    let s_number_of_lines = slice_to_string(number_of_lines);\n    write_into_file(&format!(\"{}\\n{}\\n\", s_highscores, s_number_of_lines), HIGHSCORE_FILE).is_ok()\n}\n\nfn line_to_slice(line: &str) -> Vec<u32> {\n    line.split(\" \").filter_map(|nb| nb.parse::<u32>().ok()).collect()\n}\n\nfn load_highscores_and_lines() -> Option<(Vec<u32>, Vec<u32>)> {\n    if let Ok(content) = read_from_file(HIGHSCORE_FILE) {\n        let mut lines = content.splitn(2, \"\\n\").map(|line| line_to_slice(line)).collect::<Vec<_>>();\n        if lines.len() == 2 {\n            let (lines_sent, highscores) = (lines.pop().unwrap(), lines.pop().unwrap());\n            Some((highscores, lines_sent))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n}\n\nfn update_vec(v: &mut Vec<u32>, value: u32) -> bool {\n    if v.len() < NB_HIGHSCORES {\n        v.push(value);\n        true\n    } else {\n        for entry in v.iter_mut() {\n            if value > *entry {\n                *entry = value;\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn print_game_information(tetris: &Tetris) {\n    let mut new_highest_highscore = true;\n    let mut new_highest_lines_sent = true;\n    if let Some((mut highscores, mut lines_sent)) = load_highscores_and_lines() {\n        new_highest_highscore = update_vec(&mut highscores, tetris.score);\n        new_highest_lines_sent = update_vec(&mut lines_sent, tetris.nb_lines);\n        if new_highest_highscore || new_highest_lines_sent {\n            save_highscores_and_lines(&highscores, &lines_sent);\n        }\n    } else {\n        save_highscores_and_lines(&[tetris.score], &[tetris.nb_lines]);\n    }\n    println!(\"Game over...\");\n    println!(\"Score:           {}{}\",\n             tetris.score,\n             if new_highest_highscore { \" [NEW HIGHSCORE]\"} else { \"\" });\n    println!(\"Number of lines: {}{}\",\n             tetris.nb_lines,\n             if new_highest_lines_sent { \" [NEW HIGHSCORE]\"} else { \"\" });\n    println!(\"Current level:   {}\", tetris.current_level);\n}\n\nfn is_time_over(tetris: &Tetris, timer: &SystemTime) -> bool {\n    match timer.elapsed() {\n        Ok(elapsed) => {\n            let millis = elapsed.as_secs() as u32 * 1000 + elapsed.subsec_nanos() /  \n             1_000_000;\n            millis > LEVEL_TIMES[tetris.current_level as usize - 1]\n        }\n        Err(_) => false,\n    }\n}\n\nfn main() {\n    let sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n    let mut tetris = Tetris::new();\n    let mut timer = SystemTime::now();\n\n    let mut event_pump = sdl_context.event_pump().expect(\"Failed to get SDL event \n     pump\");\n\n    let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;\n    let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;\n\n    loop {\n        if is_time_over(&tetris, &timer) {\n            let mut make_permanent = false;\n            if let Some(ref mut piece) = tetris.current_piece {\n                let x = piece.x;\n                let y = piece.y + 1;\n                make_permanent = !piece.change_position(&tetris.game_map, x, y);\n            }\n            if make_permanent {\n                tetris.make_permanent();\n            }\n            timer = SystemTime::now();\n        }\n\n        // We need to draw the tetris \"grid\" in here.\n\n        if tetris.current_piece.is_none() {\n            let current_piece = tetris.create_new_tetrimino();\n            if !current_piece.test_current_position(&tetris.game_map) {\n                print_game_information(&tetris);\n                break\n            }\n            tetris.current_piece = Some(current_piece);\n        }\n        let mut quit = false;\n        if !handle_events(&mut tetris, &mut quit, &mut timer, &mut event_pump) {\n            if let Some(ref mut piece) = tetris.current_piece {\n                // We need to draw our current tetrimino in here.\n            }\n        }\n        if quit {\n            print_game_information(&tetris);\n            break\n        }\n\n        // We need to draw the game map in here.\n\n        sleep(Duration::new(0, 1_000_000_000u32 / 60));\n    }\n}\n\n```"]