<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Asynchronous Network Programming Using Tokio</h1>
                
            
            <article>
                
<p class="calibre2">In a sequential programming model, code is always executed in the order dictated by the semantics of the programming language. Thus, if one operation blocks for some reason (waiting for a resource, and so forth), the whole execution blocks and can only move forward once that operation has completed. This often leads to poor utilization of resources, because the main thread will be busy waiting on one operation. In GUI apps, this also leads to poor user interactivity, because the main thread, which is responsible for managing the GUI, is busy waiting for something else. This is a major problem in our specific case of network programming, as we often need to wait for data to be available on a socket. In the past, we worked around these issues using multiple threads. In that model, we delegated a costly operation to a background thread, making the main thread free for user interaction, or some other task. In contrast, an asynchronous model of programming dictates that no operation should ever block. Instead, there should be a mechanism to check whether they have completed from the main thread. But how do we achieve this? A simple way would be to run each operation in its own thread, and then to join on all of those threads. In practice, this is troublesome owing to the large number of potential threads and coordination between them.</p>
<p class="calibre2">Rust provides a few crates that support asynchronous programming using a futures-based, event loop-driven model. We will study that in detail in this chapter. Here are the topics we will cover here:</p>
<ul class="calibre7">
<li class="calibre8">Futures abstraction in Rust</li>
<li class="calibre8">Asynchronous programming using the tokio stack</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking into the Future</h1>
                
            
            <article>
                
<p class="calibre2">The backbone of Rust's asynchronous programming story is the futures crate. This crate provides a construct called a <em class="calibre16">future</em>. This is essentially a placeholder for the result of an operation. As you would expect, the result of an operation can be in one of two states—either the operation is still in progress and the result is not available yet, or the operation has finished and the result is available. Note that in the second case, there might have been an error, making the result immaterial.</p>
<p class="calibre2">The library provides a trait called <kbd class="calibre11">Future</kbd> (among other things),which any type can implement to be able to act like a future. This is how the trait looks:</p>
<pre class="calibre17">trait Future {<br class="title-page-name"/>    type Item;<br class="title-page-name"/>    type Error;<br class="title-page-name"/>    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, <kbd class="calibre11">Item</kbd> refers to the type of the returned result on successful completion of the operation, and <kbd class="calibre11">Error</kbd> is the type that is returned if the operation fails. An implementation must specify those and also implement the poll method that gets the current state of the computation. If it has already finished, the result will be returned. If not, the future will register that the current task is interested in the outcome of the given operation. This function returns a <kbd class="calibre11">Poll</kbd>, which looks like this:</p>
<pre class="calibre17">type Poll&lt;T, E&gt; = Result&lt;Async&lt;T&gt;, E&gt;;</pre>
<p class="calibre2">A <kbd class="calibre11">Poll</kbd> is typed to a result of another type called <kbd class="calibre11">Async</kbd> (and the given error type), which is defined next.</p>
<pre class="calibre17">pub enum Async&lt;T&gt; {
    Ready(T),
    NotReady,
}</pre>
<p class="calibre2"><kbd class="calibre11">Async</kbd>, in turn, is an enum that can either be in <kbd class="calibre11">Ready(T)</kbd> or <kbd class="calibre11">NotReady</kbd>. These last two states correspond to the state of the operation. Thus, the poll function can return three possible states:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">Ok(Async::Ready(result))</kbd> when the operation has completed successfully and the result is in the inner variable called <kbd class="calibre11">result</kbd>.</li>
<li class="calibre8"><kbd class="calibre11">Ok(Async::NotReady)</kbd> when the operation has not completed yet and a result is not available. Note that this does not indicate an error condition.</li>
<li class="calibre8"><kbd class="calibre11">Err(e)</kbd> when the operation ran into an error. No result is available in this case.</li>
</ul>
<p class="calibre2">It is easy to note that a <kbd class="calibre11">Future</kbd> is essentially a <kbd class="calibre11">Result</kbd> that might still be running something to actually produce that <kbd class="calibre11">Result</kbd>. If one removes the case that the <kbd class="calibre11">Result</kbd> might not be ready at any point in time, the only two options we are left with are the <kbd class="calibre11">Ok</kbd> and the <kbd class="calibre11">Err</kbd> cases, which exactly correspond to a <kbd class="calibre11">Result</kbd>.</p>
<p class="calibre2">Thus, a <kbd class="calibre11">Future</kbd> can represent anything that takes a non-trivial amount of time to complete. This can be a networking event, a disk read, and so on. Now, the most common question at this point is: how do we return a future from a given function? There are a few ways of doing that. Let us look at an example here. The project setup is the same as it always is.</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin futures-example</strong></pre>
<p class="calibre2">We will need to add some libraries in our Cargo config, which will look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "futures-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>futures-cpupool = "0.1.7"</pre>
<p class="calibre2">In our main file, we set up everything as usual. We are interested in finding out whether a given integer is a prime or not, and this will represent the part of our operation that takes some time to complete. We have two functions, doing exactly that. These two use two different styles of returning futures, as we will see later. In practice, the naive way of primality testing did not turn out to be slow enough to be a good example. Thus, we had to sleep for a random time to simulate slowness.</p>
<pre class="calibre17">// ch7/futures-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(conservative_impl_trait)]<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate futures_cpupool;<br class="title-page-name"/><br class="title-page-name"/>use std::io;<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use futures_cpupool::CpuPool;<br class="title-page-name"/><br class="title-page-name"/>// This implementation returns a boxed future<br class="title-page-name"/>fn check_prime_boxed(n: u64) -&gt; Box&lt;Future&lt;Item = bool, Error = io::Error&gt;&gt; {<br class="title-page-name"/>    for i in 2..n {<br class="title-page-name"/>        if n % i == 0 { return Box::new(futures::future::ok(false)); }<br class="title-page-name"/>    }<br class="title-page-name"/>    Box::new(futures::future::ok(true))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This returns a future using impl trait<br class="title-page-name"/>fn check_prime_impl_trait(n: u64) -&gt; impl Future&lt;Item = bool, Error = io::Error&gt; {<br class="title-page-name"/>        for i in 2..n {<br class="title-page-name"/>        if n % i == 0 { return futures::future::ok(false); }<br class="title-page-name"/>    }<br class="title-page-name"/>    futures::future::ok(true)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// This does not return a future<br class="title-page-name"/>fn check_prime(n: u64) -&gt; bool {<br class="title-page-name"/>    for i in 2..n {<br class="title-page-name"/>        if n % i == 0 { return false }<br class="title-page-name"/>    }<br class="title-page-name"/>    true<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let input: u64 = 58466453;<br class="title-page-name"/>    println!("Right before first call");<br class="title-page-name"/>    let res_one = check_prime_boxed(input);<br class="title-page-name"/>    println!("Called check_prime_boxed");<br class="title-page-name"/>    let res_two = check_prime_impl_trait(input);<br class="title-page-name"/>    println!("Called check_prime_impl_trait");<br class="title-page-name"/>    println!("Results are {} and {}", res_one.wait().unwrap(),<br class="title-page-name"/>    res_two.wait().unwrap());<br class="title-page-name"/><br class="title-page-name"/>    let thread_pool = CpuPool::new(4);<br class="title-page-name"/>    let res_three = thread_pool.spawn_fn(move || {<br class="title-page-name"/>        let temp = check_prime(input);<br class="title-page-name"/>        let result: Result&lt;bool, ()&gt; = Ok(temp);<br class="title-page-name"/>        result<br class="title-page-name"/>    });<br class="title-page-name"/>    println!("Called check_prime in another thread");<br class="title-page-name"/>    println!("Result from the last call: {}", res_three.wait().unwrap());<br class="title-page-name"/>}</pre>
<p class="calibre2">There are a few major ways of returning futures. The first one is using trait objects, as done in <kbd class="calibre11">check_prime_boxed</kbd>. Now, <kbd class="calibre11">Box</kbd> is a pointer type pointing to an object on the heap. It is a managed pointer in the sense that the object will be automatically cleaned up when it goes out of scope. The return type of the function is a trait object, which can represent any future that has its <kbd class="calibre11">Item</kbd> set to bool and <kbd class="calibre11">Error</kbd> set to <kbd class="calibre11">io:Error</kbd>. Thus, this represents dynamic dispatch. The second way of returning a future is using the <kbd class="calibre11">impl</kbd> trait feature. In the case of <kbd class="calibre11">check_prime_impl_trait</kbd>, that is what we do. We say that the function returns a type that implements <kbd class="calibre11">Future&lt;Item=bool, Error=io::Error&gt;</kbd>, and as any type that implements the <kbd class="calibre11">Future</kbd> trait is a future, our function is returning a future. Note that in this case, we do not need to box before returning the result. Thus, an advantage of this approach is that no allocation is necessary for returning the future. Both of our functions use the <kbd class="calibre11">future::ok</kbd> function to signal that our computation has finished successfully with the given result. Another option is to not actually return a future and to use the futures-based thread pool crate to do the heavy lifting toward creating a future and managing it. This is the case with <kbd class="calibre11">check_prime</kbd> that just returns a <kbd class="calibre11">bool</kbd>. In our main function, we set up a thread pool using the futures-<kbd class="calibre11">cpupool</kbd> crate, and we run the last function in that pool. We get back a future on which we can call <kbd class="calibre11">wait</kbd> to get the result. A totally different option for achieving the same goal is to return a custom type that implements the <kbd class="calibre11">Future</kbd> trait. This one is the least ergonomic, as it involves writing some extra code, but it is the most flexible approach.</p>
<div class="packt_infobox">The <kbd class="calibre31">impl</kbd> trait is not a stable feature yet. Thus, <kbd class="calibre31">check_prime_impl_trait</kbd> will only work on nightly Rust.</div>
<p class="calibre2">Having constructed a future, the next goal is to execute it. There are three ways of doing this:</p>
<ul class="calibre7">
<li class="calibre8">In the current thread: This will end up blocking the current thread till the future has finished executing. In our previous example, <kbd class="calibre11">res_one</kbd> and <kbd class="calibre11">res_two</kbd> are executed on the main thread, blocking user interaction.</li>
<li class="calibre8">In a thread pool: This is the case with <kbd class="calibre11">res_three</kbd>, which is executed in a thread pool named <kbd class="calibre11">thread_pool</kbd>. Thus, in this case, the calling thread is free to move on with its own processing.</li>
<li class="calibre8">In an event loop: In some cases, neither of the above is possible. The only option then is to execute futures in an event loop. Conveniently, the tokio-core crate provides futures-friendly APIs to use event loops. We will look deeper into this model in the next section.</li>
</ul>
<p class="calibre2">In our main function, we call the first two functions in the main thread. Thus, they will block execution of the main thread. The last one, however, is run on a different thread. In that case, the main thread is immediately free to print out that <kbd class="calibre11">check_prime</kbd> has been called. It blocks again on calling <kbd class="calibre11">wait</kbd> on the future. Note that the futures are lazily evaluated in all cases. When we run this, we should see the following:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling futures-example v0.1.0 (file:///src/ch7/futures-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.77 secs<br class="title-page-name"/>     Running `target/debug/futures-example`<br class="title-page-name"/>Right before first call<br class="title-page-name"/>Called check_prime_boxed<br class="title-page-name"/>Called check_prime_impl_trait<br class="title-page-name"/>Results are true and true<br class="title-page-name"/>Called check_prime in another thread<br class="title-page-name"/>Result from the last call: true</pre>
<p class="calibre2">What sets futures apart from regular threads is that they can be chained ergonomically. This is like saying, <em class="calibre16">download the web page and then parse the html and then extract a given word</em>. Each of these steps in series is a future, and the next one cannot start unless the first one has finished. The whole operation is a <kbd class="calibre11">Future</kbd> as well, being made up of a number of constituent futures. When this larger future is being executed, it is called a task. The crate provides a number of APIs for interacting with tasks in the <kbd class="calibre11">futures::task</kbd> namespace. The library provides a number of functions to work with futures in this manner. When a given type implements the <kbd class="calibre11">Future</kbd> trait (implements the <kbd class="calibre11">poll</kbd> method), the compiler can provide implementations for all of these combinators. Let us look at an example of implementing a timeout functionality using chaining. We will use the tokio-timer crate for the timeout future and, in our code, we have two competing functions that sleep for a random amount of time and then return a fixed string to the caller. We will dispatch all these simultaneously and, if we get back the string corresponding to the first function, we declare that it has won. Similarly, this applies for the second one. In case we do not get back either, we know that the timeout future has triggered. Let's start with the project setup:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin futures-chaining</strong></pre>
<p class="calibre2">We then add our dependencies in our <kbd class="calibre11">Cargo.toml</kbd></p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "futures-chaining"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>tokio-timer = "0.1.2"<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>futures-cpupool = "0.1.7"<br class="title-page-name"/>rand = "0.3.18"</pre>
<p class="calibre2">Like last time, we use a thread pool to execute our futures using the futures-<kbd class="calibre11">cpupool</kbd> crate. Lets us look at the code:</p>
<pre class="calibre17">// ch7/futures-chaining/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate futures_cpupool;<br class="title-page-name"/>extern crate tokio_timer;<br class="title-page-name"/>extern crate rand;<br class="title-page-name"/><br class="title-page-name"/>use futures::future::select_ok;<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/><br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use futures_cpupool::CpuPool;<br class="title-page-name"/>use tokio_timer::Timer;<br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use rand::{thread_rng, Rng};<br class="title-page-name"/><br class="title-page-name"/>// First player, identified by the string "player_one"<br class="title-page-name"/>fn player_one() -&gt; &amp;'static str {<br class="title-page-name"/>    let d = thread_rng().gen_range::&lt;u64&gt;(1, 5);<br class="title-page-name"/>    thread::sleep(Duration::from_secs(d));<br class="title-page-name"/>    "player_one"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Second player, identified by the string "player_two"<br class="title-page-name"/>fn player_two() -&gt; &amp;'static str {<br class="title-page-name"/>    let d = thread_rng().gen_range::&lt;u64&gt;(1, 5);<br class="title-page-name"/>    thread::sleep(Duration::from_secs(d));<br class="title-page-name"/>    "player_two"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let pool = CpuPool::new_num_cpus();<br class="title-page-name"/>    let timer = Timer::default();<br class="title-page-name"/><br class="title-page-name"/>    // Defining the timeout future<br class="title-page-name"/>    let timeout = timer.sleep(Duration::from_secs(3))<br class="title-page-name"/>        .then(|_| Err(()));<br class="title-page-name"/><br class="title-page-name"/>    // Running the first player in the pool<br class="title-page-name"/>    let one = pool.spawn_fn(|| {<br class="title-page-name"/>        Ok(player_one())<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    // Running second player in the pool<br class="title-page-name"/>    let two = pool.spawn_fn(|| {<br class="title-page-name"/>        Ok(player_two())<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    let tasks = vec![one, two];<br class="title-page-name"/>    // Combining the players with the timeout future<br class="title-page-name"/>    // and filtering out result<br class="title-page-name"/>    let winner = select_ok(tasks).select(timeout).map(|(result, _)|<br class="title-page-name"/>    result);<br class="title-page-name"/>    let result = winner.wait().ok();<br class="title-page-name"/>    match result {<br class="title-page-name"/>        Some(("player_one", _)) =&gt; println!("Player one won"),<br class="title-page-name"/>        Some(("player_two", _)) =&gt; println!("Player two won"),<br class="title-page-name"/>        Some((_, _)) | None =&gt; println!("Timed out"),<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Our two players are very similar; both of them generate a random number between <kbd class="calibre11">1</kbd> and <kbd class="calibre11">5</kbd> and sleep for that amount of seconds. After that, they return a fixed string corresponding to their names. We will later use these strings to identify them uniquely. In our main function, we initialize the thread pool and the timer. We use the combinator on the timer to return a future that errors out after <kbd class="calibre11">3</kbd> seconds. We then spawn the two players in the thread pool and return <kbd class="calibre11">Result</kbd>s from those as futures. Note that those functions are not really running at this point, because futures are lazily evaluated. We then put those futures in a list and use the <kbd class="calibre11">select_ok</kbd> combinator to run those in parallel. This function takes in a iterable of futures and selects the first successful future; the only restriction here is that all the futures passed to this function should be of the same type. Thus, we cannot pass the timeout future here. We chain the result of <kbd class="calibre11">select_ok</kbd> to the timeout future using the <kbd class="calibre11">select</kbd> combinator that takes two futures and waits for either to finish executing. The resultant future will have the one that has finished and the one that hasn't. We then use the <kbd class="calibre11">map</kbd> combinator to discard the second part. Finally, we block on our futures and signal the end of the chain using <kbd class="calibre11">ok()</kbd>. We can then compare the result with the known strings to determine which future has won, and print out messages accordingly.</p>
<p class="calibre2">This is how a few runs will look. As our timeout is smaller than the maximum sleep period of either of the two functions, we should see a few timeouts. Whenever a function chooses a time less than the timeout, it gets a shot at winning.</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-chaining`<br class="title-page-name"/>Player two won<br class="title-page-name"/><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-chaining`<br class="title-page-name"/>Player one won<br class="title-page-name"/><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-chaining`<br class="title-page-name"/>Timed out</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with streams and sinks</h1>
                
            
            <article>
                
<p class="calibre2">The futures crate provides another useful abstraction for a lazily evaluated series of events, called <kbd class="calibre11">Stream</kbd>. If <kbd class="calibre11">Future</kbd> corresponds to <kbd class="calibre11">Result</kbd>, a <kbd class="calibre11">Stream</kbd> corresponds to <kbd class="calibre11">Iterator</kbd>. Semantically, they are very similar to futures, and they look like this:</p>
<pre class="calibre17">trait Stream {<br class="title-page-name"/>    type Item;<br class="title-page-name"/>    type Error;<br class="title-page-name"/>    fn poll(&amp; mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt;;<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">The only difference here is that the return type is wrapped in an <kbd class="calibre11">Option</kbd>, exactly like the <kbd class="calibre11">Iterator</kbd> trait. Thus, a <kbd class="calibre11">None</kbd> here would indicate that the stream has terminated. Also, all streams are futures and can be converted using <kbd class="calibre11">into_future</kbd>. Let us look at an example of using this construct. We will partially reuse our collatz example from a previous chapter. The first step is to set up the project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin streams</strong></pre>
<p class="calibre2">With all the dependencies added, our Cargo config looks like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "streams"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>futures = "0.1.17"<br class="title-page-name"/>rand = "0.3.18"</pre>
<p class="calibre2">Having set everything up, our main file will look as follows. In this case, we have a struct called <kbd class="calibre11">CollatzStream</kbd> that has two fields for the current state and the end state (which should always be <kbd class="calibre11">1</kbd>). We will implement the <kbd class="calibre11">Stream</kbd> trait on this to make this behave as a stream:</p>
<pre class="calibre17">// ch7/streams/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate rand;<br class="title-page-name"/><br class="title-page-name"/>use std::{io, thread};<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/>use futures::stream::Stream;<br class="title-page-name"/>use futures::{Poll, Async};<br class="title-page-name"/>use rand::{thread_rng, Rng};<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/><br class="title-page-name"/>// This struct holds the current state and the end condition<br class="title-page-name"/>// for the stream<br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>struct CollatzStream {<br class="title-page-name"/>    current: u64,<br class="title-page-name"/>    end: u64,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A constructor to initialize the struct with defaults<br class="title-page-name"/>impl CollatzStream {<br class="title-page-name"/>    fn new(start: u64) -&gt; CollatzStream {<br class="title-page-name"/>        CollatzStream {<br class="title-page-name"/>            current: start,<br class="title-page-name"/>            end: 1<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Implementation of the Stream trait for our struct<br class="title-page-name"/>impl Stream for CollatzStream {<br class="title-page-name"/>    type Item = u64;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, io::Error&gt; {<br class="title-page-name"/>        let d = thread_rng().gen_range::&lt;u64&gt;(1, 5);<br class="title-page-name"/>        thread::sleep(Duration::from_secs(d));<br class="title-page-name"/>        if self.current % 2 == 0 {<br class="title-page-name"/>            self.current = self.current / 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            self.current = 3 * self.current + 1;<br class="title-page-name"/>        }<br class="title-page-name"/>        if self.current == self.end {<br class="title-page-name"/>            Ok(Async::Ready(None))<br class="title-page-name"/>        } else {<br class="title-page-name"/>            Ok(Async::Ready(Some(self.current)))<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let stream = CollatzStream::new(10);<br class="title-page-name"/>    let f = stream.for_each(|num| {<br class="title-page-name"/>        println!("{}", num);<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    });<br class="title-page-name"/>    f.wait().ok();<br class="title-page-name"/>}</pre>
<p class="calibre2">We simulate a delay in returning the result by sleeping for a random amount of time between <kbd class="calibre11">1</kbd> and <kbd class="calibre11">5</kbd> seconds. Our implementation for the poll returns <kbd class="calibre11">Ok(Async::Ready(None))</kbd> to signal that the stream has finished when it reaches <kbd class="calibre11">1</kbd>. Otherwise, it returns the current state as <kbd class="calibre11">Ok(Async::Ready(Some(self.current)))</kbd>. It's easy to note that, except for the stream semantics, this implementation is the same as that for iterators. In our main function, we initialize the struct and use the <kbd class="calibre11">for_each</kbd> combinator to print out each item in the stream. This combinator returns a future on which we call <kbd class="calibre11">wait</kbd> and <kbd class="calibre11">ok</kbd> to block and get all results. Here is what we see on running the last example:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/streams`<br class="title-page-name"/>5<br class="title-page-name"/>16<br class="title-page-name"/>8<br class="title-page-name"/>4<br class="title-page-name"/>2</pre>
<p class="calibre2">As it is with the <kbd class="calibre11">Future</kbd> trait, the <kbd class="calibre11">Stream</kbd> trait also supports a number of other combinators useful for different purposes. The dual of a <kbd class="calibre11">Stream</kbd> is a <kbd class="calibre11">Sink</kbd>, which is a receiver of asynchronous events. This is extremely useful in modeling the sending end of Rust channels, network sockets, file descriptors, and so on.</p>
<p class="calibre2">A common pattern in any asynchronous system is synchronization. This becomes important, as more often than not, components need to communicate with one another to pass data or coordinate tasks. We solved this exact problem in the past using channels. But those constructions are not applicable here, as the channel implementation in the standard library is not asynchronous. Thus, futures has its own channel implementation, which provides all the guarantees you would expect from an asynchronous system. Let us look at an example; our project setup should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin futures-ping-pong</strong></pre>
<p class="calibre2">Cargo config should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "futures-ping-pong"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>rand = "0.3.18"</pre>
<p class="calibre2">Now we have two functions. One waits for a random amount of time and then randomly returns either <kbd class="calibre11">"ping"</kbd> or <kbd class="calibre11">"pong"</kbd>. This function will be our sender. Here is what it looks like:</p>
<pre class="calibre17">// ch7/futures-ping-pong/src/main<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate rand;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use std::fmt::Debug;<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use rand::{thread_rng, Rng};<br class="title-page-name"/><br class="title-page-name"/>use futures::sync::mpsc;<br class="title-page-name"/>use futures::{Sink, Stream};<br class="title-page-name"/>use futures::sync::mpsc::Receiver;<br class="title-page-name"/><br class="title-page-name"/>// Randomly selects a sleep duration between 1 and 5 seconds. Then<br class="title-page-name"/>// randomly returns either "ping" or "pong"<br class="title-page-name"/>fn sender() -&gt; &amp;'static str {<br class="title-page-name"/>    let mut d = thread_rng();<br class="title-page-name"/>    thread::sleep(Duration::from_secs(d.gen_range::&lt;u64&gt;(1, 5)));<br class="title-page-name"/>    d.choose(&amp;["ping", "pong"]).unwrap()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Receives input on the given channel and prints each item<br class="title-page-name"/>fn receiver&lt;T: Debug&gt;(recv: Receiver&lt;T&gt;) {<br class="title-page-name"/>    let f = recv.for_each(|item| {<br class="title-page-name"/>        println!("{:?}", item);<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    });<br class="title-page-name"/>    f.wait().ok();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let (tx, rx) = mpsc::channel(100);<br class="title-page-name"/>    let h1 = thread::spawn(|| {<br class="title-page-name"/>        tx.send(sender()).wait().ok();<br class="title-page-name"/>    });<br class="title-page-name"/>    let h2 = thread::spawn(|| {<br class="title-page-name"/>        receiver::&lt;&amp;str&gt;(rx);<br class="title-page-name"/>    });<br class="title-page-name"/>    h1.join().unwrap();<br class="title-page-name"/>    h2.join().unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">The futures crate provides two types of channel: a <em class="calibre16">oneshot</em> channel that can be used only once to send and receive any messages, and a regular <em class="calibre16">mpsc</em> channel that can be used multiple times. In our main function, we get hold of both ends of the channel and spawn our sender in another thread as a future. The receiver is spawned in another thread. In both cases, we record the handles to be able to wait for them to finish (using <kbd class="calibre11">join</kbd>) later. Note that our receiver takes in the receiving end of the channel as parameter. Because <kbd class="calibre11">Receiver</kbd> implements <kbd class="calibre11">Stream</kbd>, we can use the <kbd class="calibre11">and_then</kbd> combinator on it to print out the value. Finally, we call <kbd class="calibre11">wait()</kbd> and <kbd class="calibre11">ok()</kbd> on the future before exiting the receiver function. In the main function, we join on the two thread handles to drive them to completion.</p>
<p class="calibre2">Running the last example will randomly print either <kbd class="calibre11">"ping"</kbd> or <kbd class="calibre11">"pong"</kbd>, depending on what was sent via the channel. Note that the actual printing happens on the receiving end.</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-ping-pong`<br class="title-page-name"/>"ping"</pre>
<p class="calibre2">The futures crate also provides a locking mechanism in <kbd class="calibre11">futures::sync::BiLock</kbd> that closely mirrors <kbd class="calibre11">std::sync::Mutex</kbd>. This is a future-aware mutex that arbitrates sharing a resource between two owners. Note that a <kbd class="calibre11">BiLock</kbd> is only for two futures, which is an annoying limitation. Here is how it works: we are interested in modifying our last example to show a counter when the sender function is called. Now our counter needs to be thread-safe so that it can be shared across consumers. Set up the project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin future-bilock</strong></pre>
<p class="calibre2">Our <kbd class="calibre11">Cargo.toml</kbd> file should be exactly the same, and here is how the main file looks:</p>
<pre class="calibre17">// ch7/future-bilock/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate rand;<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use std::fmt::Debug;<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/>use futures::{Future, Async};<br class="title-page-name"/>use rand::{thread_rng, Rng};<br class="title-page-name"/><br class="title-page-name"/>use futures::sync::{mpsc, BiLock};<br class="title-page-name"/>use futures::{Sink, Stream};<br class="title-page-name"/>use futures::sync::mpsc::Receiver;<br class="title-page-name"/><br class="title-page-name"/>// Increments the shared counter if it can acquire a lock, then<br class="title-page-name"/>// sleeps for a random duration between 1 and 5 seconds, then<br class="title-page-name"/>// randomly returns either "ping" or "pong"<br class="title-page-name"/>fn sender(send: &amp;BiLock&lt;u64&gt;) -&gt; &amp;'static str {<br class="title-page-name"/>    match send.poll_lock() {<br class="title-page-name"/>        Async::Ready(mut lock) =&gt; *lock += 1,<br class="title-page-name"/>        Async::NotReady =&gt; ()<br class="title-page-name"/>    }<br class="title-page-name"/>    let mut d = thread_rng();<br class="title-page-name"/>    thread::sleep(Duration::from_secs(d.gen_range::&lt;u64&gt;(1, 5)));<br class="title-page-name"/>    d.choose(&amp;["ping", "pong"]).unwrap()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Tries to acquire a lock on the shared variable and prints it's<br class="title-page-name"/>// value if it got the lock. Then prints each item in the given<br class="title-page-name"/>// stream<br class="title-page-name"/>fn receiver&lt;T: Debug&gt;(recv: Receiver&lt;T&gt;, recv_lock: BiLock&lt;u64&gt;) {<br class="title-page-name"/>    match recv_lock.poll_lock() {<br class="title-page-name"/>        Async::Ready(lock) =&gt; println!("Value of lock {}", *lock),<br class="title-page-name"/>        Async::NotReady =&gt; ()<br class="title-page-name"/>    }<br class="title-page-name"/>    let f = recv.for_each(|item| {<br class="title-page-name"/>        println!("{:?}", item);<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    });<br class="title-page-name"/>    f.wait().ok();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let counter = 0;<br class="title-page-name"/>    let (send, recv) = BiLock::new(counter);<br class="title-page-name"/>    let (tx, rx) = mpsc::channel(100);<br class="title-page-name"/>    let h1 = thread::spawn(move || {<br class="title-page-name"/>        tx.send(sender(&amp;send)).wait().ok();<br class="title-page-name"/>    });<br class="title-page-name"/>    let h2 = thread::spawn(|| {<br class="title-page-name"/>        receiver::&lt;&amp;str&gt;(rx, recv);<br class="title-page-name"/>    });<br class="title-page-name"/>    h1.join().unwrap();<br class="title-page-name"/>    h2.join().unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">While this is basically the same as the last example, there are some differences. In our main function, we set the counter to zero. We then create a <kbd class="calibre11">BiLock</kbd> on the counter. The constructor returns two handles like a channel, which we can then pass around. We then create our channel and spawn the sender. Now, if we look at the sender, it has been modified to take in a reference to a <kbd class="calibre11">BiLock</kbd>. In the function, we attempt to acquire a lock using <kbd class="calibre11">poll_lock</kbd>, and, if that works, we increment the counter. Otherwise, we do nothing. We then move on to our usual business of returning <kbd class="calibre11">"ping"</kbd> or <kbd class="calibre11">"pong"</kbd>. The receiver has been modified to take a <kbd class="calibre11">BiLock</kbd> as well. In that, we try to acquire a lock and, if successful, we print out the value of the data being locked. In our main function, we spawn these futures using threads and join on them to wait for those to finish.</p>
<p class="calibre2">Here is what happens on an unsuccessful run, when both parties fail to acquire the lock. In a real example, we would want to handle the error gracefully and retry. We left out that part for the sake of brevity:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-bilock`<br class="title-page-name"/>thread '&lt;unnamed&gt;' panicked at 'no Task is currently running', libcore/option.rs:917:5<br class="title-page-name"/>note: Run with `RUST_BACKTRACE=1` for a backtrace.<br class="title-page-name"/>thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Any', libcore/result.rs:945:5</pre>
<p class="calibre2">Here is what a good run looks like: </p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/futures-bilock`<br class="title-page-name"/>Value of lock 1<br class="title-page-name"/>"pong"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Heading to tokio</h1>
                
            
            <article>
                
<p class="calibre2">The tokio ecosystem is an implementation of a network stack in Rust. It has all the major functionality of the standard library, the major difference being that it is non-blocking (most common calls do not block the current thread). This is achieved by using mio to do all the low-level heavy lifting, and using futures to abstract away long-running operations. The ecosystem has two basic crates, everything else being built around those:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">tokio-proto</kbd> provides primitives for building asynchronous servers and clients. This depends heavily on mio for low-level networking and on futures for abstraction.</li>
<li class="calibre8"><kbd class="calibre11">tokio-core</kbd> provides an event loop to run futures in and a number of related APIs. This is useful when an application needs fine-grained control over IO.</li>
</ul>
<p class="calibre2">As we mentioned in the last section, one way to run futures is on an event loop. An event loop (called a <kbd class="calibre11">reactor</kbd> in tokio) is an infinite loop that listens for defined events and takes appropriate action once it receives one. Here is how this works: we will borrow our previous example of a function that determines whether the given input is a prime or not. This returns a future with the result, which we then print out. The project setup is the same as it always is:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin futures-loop</strong></pre>
<p class="calibre2">Here is what <kbd class="calibre11">Cargo.toml</kbd> should look like:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "futures-loop"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-core = "0.1"</pre>
<p class="calibre2">For this example, we will take input in an infinite loop. For each input, we trim out newlines and spaces and try to parse it as an <kbd class="calibre11">u64</kbd>. Here is how it looks:</p>
<pre class="calibre17">// ch7/futures-loop/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/><br class="title-page-name"/>use std::io;<br class="title-page-name"/>use std::io::BufRead;<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/><br class="title-page-name"/>fn check_prime_boxed(n: u64) -&gt; Box&lt;Future&lt;Item = bool, Error = io::Error&gt;&gt; {<br class="title-page-name"/>    for i in 2..n {<br class="title-page-name"/>        if n % i == 0 {<br class="title-page-name"/>            return Box::new(futures::future::ok(false));<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    Box::new(futures::future::ok(true))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut core = Core::new().expect("Could not create event loop");<br class="title-page-name"/>    let stdin = io::stdin();<br class="title-page-name"/><br class="title-page-name"/>    loop {<br class="title-page-name"/>        let mut line = String::new();<br class="title-page-name"/>        stdin<br class="title-page-name"/>            .lock()<br class="title-page-name"/>            .read_line(&amp;mut line)<br class="title-page-name"/>            .expect("Could not read from stdin");<br class="title-page-name"/>        let input = line.trim()<br class="title-page-name"/>            .parse::&lt;u64&gt;()<br class="title-page-name"/>            .expect("Could not parse input as u64");<br class="title-page-name"/>        let result = core.run(check_prime_boxed(input))<br class="title-page-name"/>            .expect("Could not run future");<br class="title-page-name"/>        println!("{}", result);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In our main function, we create the core and start our infinite loop. We use the <kbd class="calibre11">run</kbd> method of core to start a task to execute the future asynchronously. The result is collected and printed on the standard output. Here is what a session should look like:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>12<br class="title-page-name"/>false<br class="title-page-name"/>13<br class="title-page-name"/>true<br class="title-page-name"/>991<br class="title-page-name"/>true</pre>
<p class="calibre2">The <kbd class="calibre11">tokio-proto</kbd> crate is an asynchronous server (and client) building toolkit. Any server that uses this crate has the following three distinct layers:</p>
<ul class="calibre7">
<li class="calibre8">A codec that dictates how data should be read from and written to the underlying socket forming the transport layer for our protocol. Subsequently, this layer is the bottom-most (closest to the physical medium). In practice, writing a codec amounts to implementing a few given traits from the library that processes a stream of bytes.</li>
<li class="calibre8">A protocol sits above a codec and below the actual event loop running the protocol. This acts as a glue to bind those together. tokio supports multiple protocol types, depending on the application: a simple request-response type protocol, a multiplexed protocol, and a streaming protocol. We will delve into each of these shortly.</li>
<li class="calibre8">A service that actually runs all this as a future. As this is just a future, an easy way to think of this is as an asynchronous function that transforms an input to an eventual response (which could be an error). In practice, most of the computation is done in this layer.</li>
</ul>
<p class="calibre2">Because the layers are swappable, an implementation is perfectly free to swap the protocol type for another, or the service for another one, or the codec. Let us look at an example of a simple service using <kbd class="calibre11">tokio-proto</kbd>. This one is a traditional request-response service that provides a text-based interface. It takes in a number and returns its collatz sequence as an array. If the input is not a valid integer, it send back a message indicating the same. Our project setup is pretty simple:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin collatz-proto</strong></pre>
<p class="calibre2">The Cargo config looks like the following sample:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "collatz-proto"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>bytes = "0.4"<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-io = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>tokio-proto = "0.1"<br class="title-page-name"/>tokio-service = "0.1"</pre>
<p class="calibre2">As described earlier, we will need to implement the different layers. In our current case, each of our layers do not need to hold much state. Thus, they can be represented using unit structs. If that was not the case, we would need to put some data in those.</p>
<pre class="calibre17">// ch7/collatz-proto/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate bytes;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_io;<br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/><br class="title-page-name"/>use std::io;<br class="title-page-name"/>use std::str;<br class="title-page-name"/>use bytes::BytesMut;<br class="title-page-name"/>use tokio_io::codec::{Encoder, Decoder};<br class="title-page-name"/>use tokio_io::{AsyncRead, AsyncWrite};<br class="title-page-name"/>use tokio_io::codec::Framed;<br class="title-page-name"/>use tokio_proto::pipeline::ServerProto;<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/>use futures::{future, Future};<br class="title-page-name"/>use tokio_proto::TcpServer;<br class="title-page-name"/><br class="title-page-name"/>// Codec implementation, our codec is a simple unit struct<br class="title-page-name"/>pub struct CollatzCodec;<br class="title-page-name"/><br class="title-page-name"/>// Decoding a byte stream from the underlying socket<br class="title-page-name"/>impl Decoder for CollatzCodec {<br class="title-page-name"/>    type Item = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {<br class="title-page-name"/>        // Since a newline denotes end of input, read till a newline<br class="title-page-name"/>        if let Some(i) = buf.iter().position(|&amp;b| b == b'\n') {<br class="title-page-name"/>            let line = buf.split_to(i);<br class="title-page-name"/>            // and remove the newline<br class="title-page-name"/>            buf.split_to(1);<br class="title-page-name"/>            // try to decode into an UTF8 string before passing<br class="title-page-name"/>            // to the protocol<br class="title-page-name"/>            match str::from_utf8(&amp;line) {<br class="title-page-name"/>                Ok(s) =&gt; Ok(Some(s.to_string())),<br class="title-page-name"/>                Err(_) =&gt; Err(io::Error::new(io::ErrorKind::Other, <br class="title-page-name"/>                "invalid UTF-8")),<br class="title-page-name"/>            }<br class="title-page-name"/>        } else {<br class="title-page-name"/>            Ok(None)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Encoding a string to a newline terminated byte stream<br class="title-page-name"/>impl Encoder for CollatzCodec {<br class="title-page-name"/>    type Item = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn encode(&amp;mut self, msg: String, buf: &amp;mut BytesMut) -&gt; <br class="title-page-name"/>    io::Result&lt;()&gt; {<br class="title-page-name"/>        buf.extend(msg.as_bytes());<br class="title-page-name"/>        buf.extend(b"\n");<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Protocol implementation as an unit struct<br class="title-page-name"/>pub struct CollatzProto;<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: AsyncRead + AsyncWrite + 'static&gt; ServerProto&lt;T&gt; for CollatzProto {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type Transport = Framed&lt;T, CollatzCodec&gt;;<br class="title-page-name"/>    type BindTransport = Result&lt;Self::Transport, io::Error&gt;;<br class="title-page-name"/>    fn bind_transport(&amp;self, io: T) -&gt; Self::BindTransport {<br class="title-page-name"/>        Ok(io.framed(CollatzCodec))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Service implementation<br class="title-page-name"/>pub struct CollatzService;<br class="title-page-name"/><br class="title-page-name"/>fn get_sequence(n: u64) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    let mut n = n.clone();<br class="title-page-name"/>    let mut result = vec![];<br class="title-page-name"/>    result.push(n);<br class="title-page-name"/>    while n &gt; 1 {<br class="title-page-name"/>        if n % 2 == 0 {<br class="title-page-name"/>            n /= 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            n = 3 * n + 1;<br class="title-page-name"/>        }<br class="title-page-name"/>        result.push(n);<br class="title-page-name"/>    }<br class="title-page-name"/>    result<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Service for CollatzService {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = Self::Response, Error = Self::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Self::Request) -&gt; Self::Future {<br class="title-page-name"/>        match req.trim().parse::&lt;u64&gt;() {<br class="title-page-name"/>            Ok(num) =&gt; {<br class="title-page-name"/>                let res = get_sequence(num);<br class="title-page-name"/>                Box::new(future::ok(format!("{:?}", res)))<br class="title-page-name"/>            }<br class="title-page-name"/>            Err(_) =&gt; Box::new(future::ok("Could not parse input as an<br class="title-page-name"/>            u64".to_owned())),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let addr = "0.0.0.0:9999".parse().unwrap();<br class="title-page-name"/>    let server = TcpServer::new(CollatzProto, addr);<br class="title-page-name"/>    server.serve(|| Ok(CollatzService));<br class="title-page-name"/>}</pre>
<p class="calibre2">As we saw earlier, the first step is to tell the codec how to read data to and from the socket. This is done by implementing <kbd class="calibre11">Encoder</kbd> and <kbd class="calibre11">Decoder</kbd> from <kbd class="calibre11">tokio_io::codec</kbd>. Note that we don't have to deal with raw sockets here; we get a stream of bytes as input, which we are free to process. According to our protocol defined before, a newline indicates an end of input. So, in our decoder, we read till a newline and return the data after removing the said newline as a UTF-8 encoded string. In case of an error, we return a <kbd class="calibre11">None</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">Encoder</kbd> implementation is exactly the reverse: it transforms a string into a stream of bytes. The next step is the protocol definition, this one is really simple, as it does not do multiplexing or streaming. We implement <kbd class="calibre11">bind_transport</kbd> to bind the codec to our raw socket, which we will get to later. The only catch here is that the <kbd class="calibre11">Request</kbd> and <kbd class="calibre11">Response</kbd> types here should match that of the codec. Having set these up, the next step is to implement the service, by declaring an unit struct and implementing the <kbd class="calibre11">Service</kbd> trait on it. Our helper function <kbd class="calibre11">get_sequence</kbd> returns the collatz sequence given a <kbd class="calibre11">u64</kbd> as input. The <kbd class="calibre11">call</kbd> method in <kbd class="calibre11">Service</kbd> implements the logic of computing the response. We parse the input as a <kbd class="calibre11">u64</kbd> (remember that our codec returns input as a String). If that did not error out, we call our helper function and return the result as a static string, otherwise we return an error. Our main function looks similar to such a function as would use standard networking types, but, we use the <kbd class="calibre11">TcpServer</kbd> type from tokio, which takes in our socket (to bind it to the codec) and our protocol definition. Finally, we call the <kbd class="calibre11">serve</kbd> method while passing our service as a closure. This method takes care of managing the event loop and cleaning up things on exit.</p>
<p class="calibre2">Let us use <kbd class="calibre11">telnet</kbd> to interact with it. Here is how a session will look:</p>
<pre class="calibre17"><strong class="calibre1">$ telnet localhost 9999</strong><br class="title-page-name"/>Connected to localhost.<br class="title-page-name"/>Escape character is '^]'.<br class="title-page-name"/>12<br class="title-page-name"/>[12, 6, 3, 10, 5, 16, 8, 4, 2, 1]<br class="title-page-name"/>30<br class="title-page-name"/>[30, 15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]<br class="title-page-name"/>foobar<br class="title-page-name"/>Could not parse input as an u64</pre>
<p class="calibre2">As always, it would be much more useful to write a client for our server. We will borrow a lot from the example of running a future in an event loop. We start with setting up our project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin collatz-client</strong></pre>
<p class="calibre2">Our Cargo setup will look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "collatz-client"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Abhishek Chanda &lt;abhishek.becs@gmail.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>tokio-io = "0.1"</pre>
<p class="calibre2">Here is our main file:</p>
<pre class="calibre17">// ch7/collatz-client/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_io;<br class="title-page-name"/><br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/>use std::io::BufReader;<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_core::net::TcpStream;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut core = Core::new().expect("Could not create event loop");<br class="title-page-name"/>    let handle = core.handle();<br class="title-page-name"/>    let addr: SocketAddr = "127.0.0.1:9999".parse().expect("Could not parse as SocketAddr");<br class="title-page-name"/>    let socket = TcpStream::connect(&amp;addr, &amp;handle);<br class="title-page-name"/>    let request = socket.and_then(|socket| {<br class="title-page-name"/>        tokio_io::io::write_all(socket, b"110\n")<br class="title-page-name"/>    });<br class="title-page-name"/>    let response = request.and_then(|(socket, _request)| {<br class="title-page-name"/>        let sock = BufReader::new(socket);<br class="title-page-name"/>        tokio_io::io::read_until(sock, b'\n', Vec::new())<br class="title-page-name"/>    });<br class="title-page-name"/>    let (_socket, data) = core.run(response).unwrap();<br class="title-page-name"/>    println!("{}", String::from_utf8_lossy(&amp;data));<br class="title-page-name"/>}</pre>
<p class="calibre2">Of course, this one sends a single integer to the server (110 in decimal), but it is trivial to put this in a loop to read input and send those. We leave that as an exercise for the reader. Here, we create a event loop and get its handle. We then use the asynchronous <kbd class="calibre11">TcpStream</kbd> implementation to connect to the server on a given address. This returns a future, which we combine with a closure using <kbd class="calibre11">and_then</kbd> to write to the given socket. The whole construct returns a new future called <kbd class="calibre11">request</kbd>, which is chained with a reader future. The final future is called <kbd class="calibre11">response</kbd> and is run on the event loop. Finally, we read the response and print it out. At every step, we have to respect our protocol that a newline denotes end-of-input for both the server and the client. Here is what a session looks like:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling futures-loop v0.1.0 (file:///src/ch7/collatz-client)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.94 secs<br class="title-page-name"/>     Running `target/debug/futures-loop`<br class="title-page-name"/>[110, 55, 166, 83, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Socket multiplexing in tokio</h1>
                
            
            <article>
                
<p class="calibre2">One model of asynchronous-request processing in a server is through multiplexing incoming connections. In this case, each connection is assigned a unique ID of some kind and replies are issued whenever one is ready, irrespective of the order in which it was received. Thus, this allows a higher throughput, as the shortest job gets the highest priority implicitly. This model also makes the server highly responsive with a larger number of incoming requests of varying complexity. Traditional Unix-like systems support this using the select and poll system calls for socket multiplexing.</p>
<p class="calibre2">In the tokio ecosystem, this is mirrored by a number of traits that enable implementing multiplexed protocols. The basic anatomy of the server is the same as a simple server: we have the codec, the protocol using the codec, and a service that actually runs the protocol. The only difference here is that we will assign a request ID to each incoming request. This will be used later to disambiguate while sending back responses. We will also need to implement some traits from the <kbd class="calibre11">tokio_proto::multiplex</kbd> namespace. As an example, we will modify our collatz server and add multiplexing to it. Our project setup is a bit different in this case, as we are planning to run the binaries using Cargo, and our project will be a library. We set it up like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new collatz-multiplexed</strong></pre>
<p class="calibre2">The Cargo config is similar:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "collatz-multiplexed"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>bytes = "0.4"<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-io = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>tokio-proto = "0.1"<br class="title-page-name"/>tokio-service = "0.1"</pre>
<p class="calibre2">Here is what the <kbd class="calibre11">lib.rs</kbd> file looks like:</p>
<pre class="calibre17">// ch7/collatz-multiplexed/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate bytes;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_io;<br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/><br class="title-page-name"/>use futures::{future, Future};<br class="title-page-name"/><br class="title-page-name"/>use tokio_io::{AsyncRead, AsyncWrite};<br class="title-page-name"/>use tokio_io::codec::{Decoder, Encoder, Framed};<br class="title-page-name"/>use tokio_core::net::TcpStream;<br class="title-page-name"/>use tokio_core::reactor::Handle;<br class="title-page-name"/>use tokio_proto::TcpClient;<br class="title-page-name"/>use tokio_proto::multiplex::{ClientProto, ClientService, RequestId, ServerProto};<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/><br class="title-page-name"/>use bytes::{BigEndian, Buf, BufMut, BytesMut};<br class="title-page-name"/><br class="title-page-name"/>use std::{io, str};<br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/><br class="title-page-name"/>// Everything client side<br class="title-page-name"/>// Represents a client connecting to our server<br class="title-page-name"/>pub struct Client {<br class="title-page-name"/>    inner: ClientService&lt;TcpStream, CollatzProto&gt;,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Client {<br class="title-page-name"/>    pub fn connect(<br class="title-page-name"/>        addr: &amp;SocketAddr,<br class="title-page-name"/>        handle: &amp;Handle,<br class="title-page-name"/>    ) -&gt; Box&lt;Future&lt;Item = Client, Error = io::Error&gt;&gt; {<br class="title-page-name"/>        let ret = TcpClient::new(CollatzProto)<br class="title-page-name"/>            .connect(addr, handle)<br class="title-page-name"/>            .map(|service| Client {<br class="title-page-name"/>                inner: service,<br class="title-page-name"/>            });<br class="title-page-name"/><br class="title-page-name"/>        Box::new(ret)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Service for Client {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = String, Error = io::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: String) -&gt; Self::Future {<br class="title-page-name"/>        Box::new(self.inner.call(req).and_then(move |resp| Ok(resp)))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Everything server side<br class="title-page-name"/>pub struct CollatzCodec;<br class="title-page-name"/>pub struct CollatzProto;<br class="title-page-name"/><br class="title-page-name"/>// Represents a frame that has a RequestId and the actual data (String)<br class="title-page-name"/>type CollatzFrame = (RequestId, String);<br class="title-page-name"/><br class="title-page-name"/>impl Decoder for CollatzCodec {<br class="title-page-name"/>    type Item = CollatzFrame;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt; <br class="title-page-name"/>    Result&lt;Option&lt;CollatzFrame&gt;, io::Error&gt; {<br class="title-page-name"/>        // Do not proceed if we haven't received at least 6 bytes yet<br class="title-page-name"/>        // 4 bytes for the RequestId + data + 1 byte for newline<br class="title-page-name"/>        if buf.len() &lt; 5 {<br class="title-page-name"/>            return Ok(None);<br class="title-page-name"/>        }<br class="title-page-name"/>        let newline = buf[4..].iter().position(|b| *b == b'\n');<br class="title-page-name"/>        if let Some(n) = newline {<br class="title-page-name"/>            let line = buf.split_to(n + 4);<br class="title-page-name"/>            buf.split_to(1);<br class="title-page-name"/>            let request_id = io::Cursor::new(&amp;line[0..4]).get_u32:<br class="title-page-name"/>            :&lt;BigEndian&gt;();<br class="title-page-name"/>            return match str::from_utf8(&amp;line.as_ref()[4..]) {<br class="title-page-name"/>                Ok(s) =&gt; Ok(Some((u64::from(request_id),<br class="title-page-name"/>                s.to_string()))),<br class="title-page-name"/>                Err(_) =&gt; Err(io::Error::new(io::ErrorKind::Other, <br class="title-page-name"/>                "invalid string")),<br class="title-page-name"/>            };<br class="title-page-name"/>        }<br class="title-page-name"/>        // Frame is not complete if it does not have a newline at the<br class="title-page-name"/>        end<br class="title-page-name"/>        Ok(None)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Encoder for CollatzCodec {<br class="title-page-name"/>    type Item = CollatzFrame;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn encode(&amp;mut self, msg: CollatzFrame, buf: &amp;mut BytesMut) -&gt;<br class="title-page-name"/>    io::Result&lt;()&gt; {<br class="title-page-name"/>        // Calculate final message length first<br class="title-page-name"/>        let len = 4 + msg.1.len() + 1;<br class="title-page-name"/>        buf.reserve(len);<br class="title-page-name"/><br class="title-page-name"/>        let (request_id, msg) = msg;<br class="title-page-name"/><br class="title-page-name"/>        buf.put_u32::&lt;BigEndian&gt;(request_id as u32);<br class="title-page-name"/>        buf.put_slice(msg.as_bytes());<br class="title-page-name"/>        buf.put_u8(b'\n');<br class="title-page-name"/><br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: AsyncRead + AsyncWrite + 'static&gt; ClientProto&lt;T&gt; for CollatzProto {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/><br class="title-page-name"/>    type Transport = Framed&lt;T, CollatzCodec&gt;;<br class="title-page-name"/>    type BindTransport = Result&lt;Self::Transport, io::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn bind_transport(&amp;self, io: T) -&gt; Self::BindTransport {<br class="title-page-name"/>        Ok(io.framed(CollatzCodec))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: AsyncRead + AsyncWrite + 'static&gt; ServerProto&lt;T&gt; for CollatzProto {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/><br class="title-page-name"/>    type Transport = Framed&lt;T, CollatzCodec&gt;;<br class="title-page-name"/>    type BindTransport = Result&lt;Self::Transport, io::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn bind_transport(&amp;self, io: T) -&gt; Self::BindTransport {<br class="title-page-name"/>        Ok(io.framed(CollatzCodec))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>pub struct CollatzService;<br class="title-page-name"/><br class="title-page-name"/>fn get_sequence(mut n: u64) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    let mut result = vec![];<br class="title-page-name"/>    result.push(n);<br class="title-page-name"/>    while n &gt; 1 {<br class="title-page-name"/>        if n % 2 == 0 {<br class="title-page-name"/>            n /= 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            n = 3 * n + 1;<br class="title-page-name"/>        }<br class="title-page-name"/>        result.push(n);<br class="title-page-name"/>    }<br class="title-page-name"/>    result<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Service for CollatzService {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = Self::Response, Error = Self::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Self::Request) -&gt; Self::Future {<br class="title-page-name"/>        match req.trim().parse::&lt;u64&gt;() {<br class="title-page-name"/>            Ok(num) =&gt; {<br class="title-page-name"/>                let res = get_sequence(num);<br class="title-page-name"/>                Box::new(future::ok(format!("{:?}", res)))<br class="title-page-name"/>            }<br class="title-page-name"/>            Err(_) =&gt; Box::new(future::ok("Could not parse input as an<br class="title-page-name"/>            u64".to_owned())),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Tokio provides a built-in type called <kbd class="calibre11">RequestId</kbd> to represent unique IDs for incoming requests, all states associated with it being managed internally by tokio. We define a custom data type called <span><kbd class="calibre11">CollatzFrame</kbd> </span>for our frame; this has the <kbd class="calibre11">RequestId</kbd> and a <kbd class="calibre11">String</kbd> for our data. We move on to implementing <kbd class="calibre11">Decoder</kbd> and <kbd class="calibre11">Encoder</kbd> for <kbd class="calibre11">CollatzCodec</kbd> like last time. But, in both of these cases, we have to take into account the request ID in the header and the trailing newline. Because the <kbd class="calibre11">RequestId</kbd> type is a <kbd class="calibre11">u64</kbd> under the hood, it will always be four bytes and one extra byte for a newline. Thus, if we have received fewer than 5 bytes, we know that the whole frame has not been received yet. Note that this is not an error case, the frame is still being transmitted, so we return an <kbd class="calibre11">Ok(None)</kbd>. We then check whether the buffer has a newline (in compliance with our protocol). If everything looks good, we parse the request ID from the first 4 bytes (note that this will be in network-byte order). We then construct an instance of <kbd class="calibre11">CollatzFrame</kbd> and return it. The encoder implementation is the inverse; we just need to put the request ID back in, then the actual data, and end with a newline.</p>
<p class="calibre2">The next steps are to implement <kbd class="calibre11">ServerProto</kbd> and <kbd class="calibre11">ClientProto</kbd> for <kbd class="calibre11">CollatzProto</kbd>; both of these are boilerplates that bind the codec with the transport. Like last time, the last step is to implement the service. This step does not change at all. Note that we do not need to care about dealing with the request ID after implementing the codec because later stages do not see it at all. The codec deals with and manages it while passing on the actual data to later layers.</p>
<p class="calibre2">Here is what our frame looks like:</p>
<div class="cdpaligncenter"><img src="../images/00016.jpeg" class="calibre40"/></div>
<div class="packt_figref">Our request frame with the RequestId as header and a trailing newline</div>
<p class="calibre2">This time, our client will be based on tokio too. Our <kbd class="calibre11">Client</kbd> struct wraps an instance of <kbd class="calibre11">ClientService</kbd>, which takes in the underlying TCP stream and the protocol implementation to use. We have a convenience function called <kbd class="calibre11">connect</kbd> for the <kbd class="calibre11">Client</kbd> type, which connects to a given server and returns a future. Lastly, we implement <kbd class="calibre11">Service</kbd> for <kbd class="calibre11">Client</kbd> in which the <kbd class="calibre11">call</kbd> method returns a future. We run the server and client as examples by putting them in a directory called <kbd class="calibre11">examples</kbd>. This way, cargo knows that those should be run as associated examples with this crate. The server looks like this:</p>
<pre class="calibre17">// ch7/collatz-multiplexed/examples/server.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate collatz_multiplexed as collatz;<br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/><br class="title-page-name"/>use tokio_proto::TcpServer;<br class="title-page-name"/>use collatz::{CollatzService, CollatzProto};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let addr = "0.0.0.0:9999".parse().unwrap();<br class="title-page-name"/>    TcpServer::new(CollatzProto, addr).serve(|| Ok(CollatzService));<br class="title-page-name"/>}</pre>
<p class="calibre2">This is pretty much the same as last time, just in a different file. We have to declare our parent crate as an external dependency so that Cargo can link everything properly. This is how the client looks:</p>
<pre class="calibre17">// ch7/collatz-multiplexed/examples/client.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate collatz_multiplexed as collatz;<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/><br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/><br class="title-page-name"/>pub fn main() {<br class="title-page-name"/>    let addr = "127.0.0.1:9999".parse().unwrap();<br class="title-page-name"/>    let mut core = Core::new().unwrap();<br class="title-page-name"/>    let handle = core.handle();<br class="title-page-name"/><br class="title-page-name"/>    core.run(<br class="title-page-name"/>        collatz::Client::connect(&amp;addr, &amp;handle)<br class="title-page-name"/>            .and_then(|client| {<br class="title-page-name"/>                client.call("110".to_string())<br class="title-page-name"/>                    .and_then(move |response| {<br class="title-page-name"/>                        println!("We got back: {:?}", response);<br class="title-page-name"/>                        Ok(())<br class="title-page-name"/>                    })<br class="title-page-name"/>            })<br class="title-page-name"/>    ).unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">We run our client in an event loop, using tokio-core. We use the connect method defined on the client to get a future wrapping the connection. We use the <kbd class="calibre11">and_then</kbd> combinator and use the call method to send a string to the server. As this method returns a future as well, we can use the <kbd class="calibre11">and_then</kbd> combinator on the inner future to extract the response and then resolve it by returning an <kbd class="calibre11">Ok(())</kbd>. This also resolves the outer future.</p>
<p class="calibre2">Now, if we open two terminals and run the server in one and the client in another, here is what we should see in the client. Note that as we do not have sophisticated retries and error handling, the server should be run before the client:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --example client</strong><br class="title-page-name"/>   Compiling collatz-multiplexed v0.1.0 (file:///src/ch7/collatz-multiplexed)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.93 secs<br class="title-page-name"/>     Running `target/debug/examples/client`<br class="title-page-name"/>We got back: "[110, 55, 166, 83, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]"</pre>
<p class="calibre2">And, as expected, this output matches what we got before.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing streaming protocols</h1>
                
            
            <article>
                
<p class="calibre2">In a number of cases, a protocol has a data unit with a header attached to it. The server typically reads the header first and, based on that, decides how to process the data. In some cases, the server may be able to do some processing based on the header. One such example is IP, which has a header that has the destination address. A server may start running a longest prefix match based on that information, before reading the body. In this section, we will look into using tokio to write such servers. We will expand our toy collatz protocol to include a header and some data body, and work from there. Let us start with an example, and our project setup will be exactly the same, setting it up using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new collatz-streaming</strong></pre>
<p class="calibre2">Cargo config does not change much:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "collatz-streaming"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>bytes = "0.4"<br class="title-page-name"/>futures = "0.1"<br class="title-page-name"/>tokio-io = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>tokio-proto = "0.1"<br class="title-page-name"/>tokio-service = "0.1"</pre>
<p class="calibre2">As this example is large, we have broken this down into constituent pieces, as follows. The first part shows setting up the client:</p>
<pre class="calibre17">// ch7/collatz-streaming/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate bytes;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_io;<br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/><br class="title-page-name"/>use futures::{future, Future, Poll, Stream};<br class="title-page-name"/>use futures::sync::mpsc;<br class="title-page-name"/>use tokio_io::{AsyncRead, AsyncWrite};<br class="title-page-name"/>use tokio_io::codec::{Decoder, Encoder, Framed};<br class="title-page-name"/>use tokio_core::reactor::Handle;<br class="title-page-name"/>use tokio_proto::TcpClient;<br class="title-page-name"/>use tokio_proto::streaming::{Body, Message};<br class="title-page-name"/>use tokio_proto::streaming::pipeline::{ClientProto, Frame, ServerProto};<br class="title-page-name"/>use tokio_proto::util::client_proxy::ClientProxy;<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/>use std::str::FromStr;<br class="title-page-name"/>use bytes::{BufMut, BytesMut};<br class="title-page-name"/>use std::{io, str};<br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/><br class="title-page-name"/>// Everything about clients<br class="title-page-name"/>type CollatzMessage = Message&lt;String, Body&lt;String, io::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>pub enum CollatzInput {<br class="title-page-name"/>    Once(String),<br class="title-page-name"/>    Stream(CollatzStream),<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>pub struct CollatzProto;<br class="title-page-name"/><br class="title-page-name"/>pub struct Client {<br class="title-page-name"/>    inner: ClientProxy&lt;CollatzMessage, CollatzMessage, io::Error&gt;,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Client {<br class="title-page-name"/>    pub fn connect(<br class="title-page-name"/>        addr: &amp;SocketAddr,<br class="title-page-name"/>        handle: &amp;Handle,<br class="title-page-name"/>    ) -&gt; Box&lt;Future&lt;Item = Client, Error = io::Error&gt;&gt; {<br class="title-page-name"/>        let ret = TcpClient::new(CollatzProto)<br class="title-page-name"/>            .connect(addr, handle)<br class="title-page-name"/>            .map(|cp| Client { inner: cp });<br class="title-page-name"/><br class="title-page-name"/>        Box::new(ret)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Service for Client {<br class="title-page-name"/>    type Request = CollatzInput;<br class="title-page-name"/>    type Response = CollatzInput;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = Self::Response, Error = <br class="title-page-name"/>    io::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: CollatzInput) -&gt; Self::Future {<br class="title-page-name"/>        Box::new(self.inner.call(req.into()).map(CollatzInput::from))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As always, the first step is to set up extern crates and include everything required. We define a few types that we will use. A <kbd class="calibre11">CollatzMessage</kbd> is a message that our protocol receives; it has a header and a body both of type <kbd class="calibre11">String</kbd>. A <kbd class="calibre11">CollatzInput</kbd> is an input stream for the protocol, which is an enum with two variants: <kbd class="calibre11">Once</kbd> represents the case where we have received data in a non-streaming way, and <kbd class="calibre11">Stream</kbd> is for the second case. The protocol implementation is a unit struct called <kbd class="calibre11">CollatzProto</kbd>. We then define a struct for the client, which has an inner instance of <kbd class="calibre11">ClientProxy</kbd>, the actual client implementation. This takes in three types, the first two being request and response for the whole server, and the last one being for errors. We then implement a connect method for the <kbd class="calibre11">Client</kbd> struct that connects using <kbd class="calibre11">CollatzProto</kbd>, and this returns a future with the connection. The last step is to implement <kbd class="calibre11">Service</kbd> for <kbd class="calibre11">Client</kbd>, and both the input and output for this is of type <kbd class="calibre11">CollatzInput</kbd>, thus we have to transform the output to that type using map on the future. Let us move on to the server; it looks like this:</p>
<pre class="calibre17">//ch7/collatz-streaming/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>// Everything about server<br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>pub struct CollatzStream {<br class="title-page-name"/>    inner: Body&lt;String, io::Error&gt;,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl CollatzStream {<br class="title-page-name"/>    pub fn pair() -&gt; (mpsc::Sender&lt;Result&lt;String, io::Error&gt;&gt;,<br class="title-page-name"/>    CollatzStream) {<br class="title-page-name"/>        let (tx, rx) = Body::pair();<br class="title-page-name"/>        (tx, CollatzStream { inner: rx })<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Stream for CollatzStream {<br class="title-page-name"/>    type Item = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;String&gt;, io::Error&gt; {<br class="title-page-name"/>        self.inner.poll()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>pub struct CollatzCodec {<br class="title-page-name"/>    decoding_head: bool,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Decodes a frame to a byte slice<br class="title-page-name"/>impl Decoder for CollatzCodec {<br class="title-page-name"/>    type Item = Frame&lt;String, String, io::Error&gt;;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt; Result&lt;Option&lt;Self::Item&gt;, io::Error&gt; {<br class="title-page-name"/>        if let Some(n) = buf.as_ref().iter().position(|b| *b == b'\n') {<br class="title-page-name"/>            let line = buf.split_to(n);<br class="title-page-name"/><br class="title-page-name"/>            buf.split_to(1);<br class="title-page-name"/>            return match str::from_utf8(line.as_ref()) {<br class="title-page-name"/>                Ok(s) =&gt; {<br class="title-page-name"/>                    if s == "" {<br class="title-page-name"/>                        let decoding_head = self.decoding_head;<br class="title-page-name"/>                        self.decoding_head = !decoding_head;<br class="title-page-name"/><br class="title-page-name"/>                        if decoding_head {<br class="title-page-name"/>                            Ok(Some(Frame::Message {<br class="title-page-name"/>                                message: s.to_string(),<br class="title-page-name"/>                                body: true,<br class="title-page-name"/>                            }))<br class="title-page-name"/>                        } else {<br class="title-page-name"/>                            Ok(Some(Frame::Body { chunk: None }))<br class="title-page-name"/>                        }<br class="title-page-name"/>                    } else {<br class="title-page-name"/>                        if self.decoding_head {<br class="title-page-name"/>                            Ok(Some(Frame::Message {<br class="title-page-name"/>                                message: s.to_string(),<br class="title-page-name"/>                                body: false,<br class="title-page-name"/>                            }))<br class="title-page-name"/>                        } else {<br class="title-page-name"/>                            Ok(Some(Frame::Body {<br class="title-page-name"/>                                chunk: Some(s.to_string()),<br class="title-page-name"/>                            }))<br class="title-page-name"/>                        }<br class="title-page-name"/>                    }<br class="title-page-name"/>                }<br class="title-page-name"/>                Err(_) =&gt; Err(io::Error::new(io::ErrorKind::Other, <br class="title-page-name"/>                "invalid string")),<br class="title-page-name"/>            };<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        Ok(None)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Encodes a given byte slice to a frame<br class="title-page-name"/>impl Encoder for CollatzCodec {<br class="title-page-name"/>    type Item = Frame&lt;String, String, io::Error&gt;;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    fn encode(&amp;mut self, msg: Self::Item, buf: &amp;mut BytesMut) -&gt;<br class="title-page-name"/>    io::Result&lt;()&gt; {<br class="title-page-name"/>        match msg {<br class="title-page-name"/>            Frame::Message { message, body } =&gt; {<br class="title-page-name"/>                buf.reserve(message.len());<br class="title-page-name"/>                buf.extend(message.as_bytes());<br class="title-page-name"/>            }<br class="title-page-name"/>            Frame::Body { chunk } =&gt; {<br class="title-page-name"/>                if let Some(chunk) = chunk {<br class="title-page-name"/>                    buf.reserve(chunk.len());<br class="title-page-name"/>                    buf.extend(chunk.as_bytes());<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>            Frame::Error { error } =&gt; {<br class="title-page-name"/>                return Err(error);<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        buf.put_u8(b'\n');<br class="title-page-name"/>        Ok(())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: AsyncRead + AsyncWrite + 'static&gt; ClientProto&lt;T&gt; for CollatzProto {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type RequestBody = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type ResponseBody = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    type Transport = Framed&lt;T, CollatzCodec&gt;;<br class="title-page-name"/>    type BindTransport = Result&lt;Self::Transport, io::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn bind_transport(&amp;self, io: T) -&gt; Self::BindTransport {<br class="title-page-name"/>        let codec = CollatzCodec {<br class="title-page-name"/>            decoding_head: true,<br class="title-page-name"/>        };<br class="title-page-name"/><br class="title-page-name"/>        Ok(io.framed(codec))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: AsyncRead + AsyncWrite + 'static&gt; ServerProto&lt;T&gt; for CollatzProto {<br class="title-page-name"/>    type Request = String;<br class="title-page-name"/>    type RequestBody = String;<br class="title-page-name"/>    type Response = String;<br class="title-page-name"/>    type ResponseBody = String;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/><br class="title-page-name"/>    type Transport = Framed&lt;T, CollatzCodec&gt;;<br class="title-page-name"/>    type BindTransport = Result&lt;Self::Transport, io::Error&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn bind_transport(&amp;self, io: T) -&gt; Self::BindTransport {<br class="title-page-name"/>        let codec = CollatzCodec {<br class="title-page-name"/>            decoding_head: true,<br class="title-page-name"/>        };<br class="title-page-name"/><br class="title-page-name"/>        Ok(io.framed(codec))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As expected, a <kbd class="calibre11">CollatzStream</kbd> has a body that is either a string or has resulted in an error. Now, for a streaming protocol, we need to provide an implementation of a function that returns the sender half of the stream; we do this in the <kbd class="calibre11">pair</kbd> function for <kbd class="calibre11">CollatzStream</kbd>. Next, we implement the <kbd class="calibre11">Stream</kbd> trait for our custom stream; the <kbd class="calibre11">poll</kbd> method in this case simply polls the inner <kbd class="calibre11">Body</kbd> for more data. Having set up the stream, we can implement the codec. In here, we will need to maintain a way to know what part of the frame we are processing at this moment. This is done using a boolean called <kbd class="calibre11">decoding_head</kbd> that we flip as we need. We need to implement <kbd class="calibre11">Decoder</kbd> for our codec, and this is pretty much the same as the last few times; just note that we need to keep track of the streaming and non-streaming cases and the boolean defined previously. The <kbd class="calibre11">Encoder</kbd> implementation is the reverse. We also need to bind the protocol implementation to the codec; this is done by implementing <kbd class="calibre11">ClientProto</kbd> and <kbd class="calibre11">ServerProto</kbd> for <kbd class="calibre11">CollatzProto</kbd>. In both cases, we set the boolean to true, as the first thing to be read after receiving the message is the header.</p>
<p class="calibre2">The last step in the stack is to implement the services by implementing the <kbd class="calibre11">Service</kbd> trait for <kbd class="calibre11">CollatzService</kbd>. In that, we read the header and try to parse it as a <kbd class="calibre11">u64</kbd>. If that works fine, we move on to calculating the collatz sequence of that <kbd class="calibre11">u64</kbd> and return the result as a <kbd class="calibre11">CollatzInput::Once</kbd> in a leaf future. In the other case, we iterate over the body and print it on the console. Finally, we return a fixed string to the client. Here is what this looks like:</p>
<pre class="calibre17">//ch7/collatz-streaming/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>pub struct CollatzService;<br class="title-page-name"/><br class="title-page-name"/>// Given an u64, returns it's collatz sequence<br class="title-page-name"/>fn get_sequence(mut n: u64) -&gt; Vec&lt;u64&gt; {<br class="title-page-name"/>    let mut result = vec![];<br class="title-page-name"/>    result.push(n);<br class="title-page-name"/>    while n &gt; 1 {<br class="title-page-name"/>        if n % 2 == 0 {<br class="title-page-name"/>            n /= 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            n = 3 * n + 1;<br class="title-page-name"/>        }<br class="title-page-name"/>        result.push(n);<br class="title-page-name"/>    }<br class="title-page-name"/>    result<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Removes leading and trailing whitespaces from a given line<br class="title-page-name"/>// and tries to parse it as a u64<br class="title-page-name"/>fn clean_line(line: &amp;str) -&gt; Result&lt;u64, &lt;u64 as FromStr&gt;::Err&gt; {<br class="title-page-name"/>    line.trim().parse::&lt;u64&gt;()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl Service for CollatzService {<br class="title-page-name"/>    type Request = CollatzInput;<br class="title-page-name"/>    type Response = CollatzInput;<br class="title-page-name"/>    type Error = io::Error;<br class="title-page-name"/>    type Future = Box&lt;Future&lt;Item = Self::Response, Error = Self::Error&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    fn call(&amp;self, req: Self::Request) -&gt; Self::Future {<br class="title-page-name"/>        match req {<br class="title-page-name"/>            CollatzInput::Once(line) =&gt; {<br class="title-page-name"/>                println!("Server got: {}", line);<br class="title-page-name"/>                let res = get_sequence(clean_line(&amp;line).unwrap());<br class="title-page-name"/>                Box::new(future::done(Ok(CollatzInput::Once<br class="title-page-name"/>                (format!("{:?}", res)))))<br class="title-page-name"/>            }<br class="title-page-name"/>            CollatzInput::Stream(body) =&gt; {<br class="title-page-name"/>                let resp = body.for_each(|line| {<br class="title-page-name"/>                    println!("{}", line);<br class="title-page-name"/>                    Ok(())<br class="title-page-name"/>                }).map(|_| CollatzInput::Once("Foo".to_string()));<br class="title-page-name"/><br class="title-page-name"/>                Box::new(resp) as Box&lt;Future&lt;Item = Self::<br class="title-page-name"/>                Response, Error = io::Error&gt;&gt;<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have also written two conversion helpers from <kbd class="calibre11">CollatzMessage</kbd> to <kbd class="calibre11">CollatzInput</kbd>, and vice versa, by implementing the <kbd class="calibre11">From</kbd> trait accordingly. Like everything else, we will have to deal with the two cases: when the message has a body and when it does not (in other words, the header has arrived but not the rest of the message). Here are those:</p>
<pre class="calibre17">// ch7/collatz-streaming/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>// Converts a CollatzMessage to a CollatzInput<br class="title-page-name"/>impl From&lt;CollatzMessage&gt; for CollatzInput {<br class="title-page-name"/>    fn from(src: CollatzMessage) -&gt; CollatzInput {<br class="title-page-name"/>        match src {<br class="title-page-name"/>            Message::WithoutBody(line) =&gt; CollatzInput::Once(line),<br class="title-page-name"/>            Message::WithBody(_, body) =&gt; CollatzInput::Stream(CollatzStream { inner: body }),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Converts a CollatzInput to a Message&lt;String, Body&gt;<br class="title-page-name"/>impl From&lt;CollatzInput&gt; for Message&lt;String, Body&lt;String, io::Error&gt;&gt; {<br class="title-page-name"/>    fn from(src: CollatzInput) -&gt; Self {<br class="title-page-name"/>        match src {<br class="title-page-name"/>            CollatzInput::Once(line) =&gt; Message::WithoutBody(line),<br class="title-page-name"/>            CollatzInput::Stream(body) =&gt; {<br class="title-page-name"/>                let CollatzStream { inner } = body;<br class="title-page-name"/>                Message::WithBody("".to_string(), inner)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Having set up the server and the client, we will implement our tests as examples, like last time. Here is what they look like:</p>
<pre class="calibre17">// ch7/collatz-streaming/examples/server.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate collatz_streaming as collatz;<br class="title-page-name"/>extern crate futures;<br class="title-page-name"/><br class="title-page-name"/>extern crate tokio_proto;<br class="title-page-name"/><br class="title-page-name"/>use tokio_proto::TcpServer;<br class="title-page-name"/>use collatz::{CollatzProto, CollatzService};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let addr = "0.0.0.0:9999".parse().unwrap();</pre>
<pre class="calibre17">    TcpServer::new(CollatzProto, addr).serve(|| Ok(CollatzService));<br class="title-page-name"/>}</pre>
<p class="calibre2">Here is what the client looks like. There is a bit to digest here, compared to the server:</p>
<pre class="calibre17">// ch7/collatz-streaming/examples/client.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate collatz_streaming as collatz;<br class="title-page-name"/><br class="title-page-name"/>extern crate futures;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_service;<br class="title-page-name"/><br class="title-page-name"/>use collatz::{CollatzInput, CollatzStream};<br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use futures::Sink;<br class="title-page-name"/>use futures::Future;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_service::Service;<br class="title-page-name"/><br class="title-page-name"/>pub fn main() {<br class="title-page-name"/>    let addr = "127.0.0.1:9999".parse().unwrap();<br class="title-page-name"/>    let mut core = Core::new().unwrap();<br class="title-page-name"/>    let handle = core.handle();<br class="title-page-name"/><br class="title-page-name"/>    // Run the client in the event loop<br class="title-page-name"/>    core.run(<br class="title-page-name"/>        collatz::Client::connect(&amp;addr, &amp;handle)<br class="title-page-name"/>            .and_then(|client| {<br class="title-page-name"/>                client.call(CollatzInput::Once("10".to_string()))<br class="title-page-name"/>                    .and_then(move |response| {<br class="title-page-name"/>                        println!("Response: {:?}", response);<br class="title-page-name"/><br class="title-page-name"/>                        let (mut tx, rx) = CollatzStream::pair();<br class="title-page-name"/><br class="title-page-name"/>                        thread::spawn(move || {<br class="title-page-name"/>                            for msg in &amp;["Hello", "world", "!"] {<br class="title-page-name"/>                                tx =<br class="title-page-name"/>                                tx.send(Ok(msg.to_string()))<br class="title-page-name"/>                                .wait().unwrap();<br class="title-page-name"/>                            }<br class="title-page-name"/>                        });<br class="title-page-name"/><br class="title-page-name"/>                        client.call(CollatzInput::Stream(rx))<br class="title-page-name"/>                    })<br class="title-page-name"/>                    .and_then(|response| {<br class="title-page-name"/>                        println!("Response: {:?}", response);<br class="title-page-name"/>                        Ok(())<br class="title-page-name"/>                    })<br class="title-page-name"/>            })<br class="title-page-name"/>    ).unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">We use the <kbd class="calibre11">connect</kbd> method defined earlier to set up connection to the server on a known address and port. We use the <kbd class="calibre11">and_then</kbd> combinator to send a fixed string to the server, and we print the response. At this point, we have transmitted our header and we move on to transmitting the body. This is done by splitting the stream in two halves and using the sender to send a number of strings. A final combinator prints the response and resolves the future. Everything previously is run in an event loop.</p>
<p class="calibre2">This is what a session looks like for the server:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --example server</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/examples/server`<br class="title-page-name"/>Server got: 10<br class="title-page-name"/>Hello<br class="title-page-name"/>world<br class="title-page-name"/>!</pre>
<p class="calibre2">And this is how it looks like for the client:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --example client</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/examples/client`<br class="title-page-name"/>Response: Once("[10, 5, 16, 8, 4, 2, 1]")<br class="title-page-name"/>Response: Once("Foo")</pre>
<p class="calibre2">As expected, the server processed the header before it got the actual body of the request (we know that because we sent the body after sending the header).</p>
<p class="calibre2">Other than what we discussed here, tokio supports a bunch of other features as well. For instance, you can implement a protocol handshake by changing the <kbd class="calibre11">ServerProto</kbd> and <kbd class="calibre11">ClientProto</kbd> implementations to exchange setup messages before constructing the <kbd class="calibre11">BindTransport</kbd> future. This is extremely important, as a lot of network protocols need some form of handshaking to set up a shared state to work with. Note that it is perfectly possible for a protocol be streaming and pipelined, or streaming and multiplexed. For these, an implementation needs to substitute traits from the <span><kbd class="calibre11">streaming::pipeline</kbd> or <kbd class="calibre11">streaming::multiplex</kbd> namespace respectively.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The larger tokio ecosystem</h1>
                
            
            <article>
                
<p class="calibre2">Let us take a look at the current state of the tokio ecosystem. Here are the commonly useful crates in the <kbd class="calibre11">tokio-rs</kbd> GitHub organization, at the time of writing:</p>
<table class="calibre33">
<tbody class="calibre34">
<tr class="calibre35">
<td class="calibre36"><strong class="calibre1">Crate</strong></td>
<td class="calibre36"><strong class="calibre1">Function</strong></td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-minihttp</kbd></td>
<td class="calibre36">Simple HTTP server implementation in tokio; should not be used in production.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-core</kbd></td>
<td class="calibre36">Future-aware networking implementations; the core event loop.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-io</kbd></td>
<td class="calibre36">IO primitives for tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-curl</kbd></td>
<td class="calibre36">A <kbd class="calibre37">libcurl</kbd>-based HTTP client implementation using tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-uds</kbd></td>
<td class="calibre36">Non-blocking unix domain sockets using tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-tls</kbd></td>
<td class="calibre36">TLS and SSL implementation based on tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-service</kbd></td>
<td class="calibre36">Provides the <kbd class="calibre37">Service</kbd> trait that we have used extensively.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-proto</kbd></td>
<td class="calibre36">Provides a framework for building network protocols using tokio; we have used this one extensively.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-socks5</kbd></td>
<td class="calibre36">A SOCKS5 server using tokio, not production-ready.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-middleware</kbd></td>
<td class="calibre36">Collection of middlewares for tokio services; lacks essential services at the moment.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-times</kbd></td>
<td class="calibre36">Timer-related functionality based on tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-line</kbd></td>
<td class="calibre36">Sample-line protocol for demonstrating tokio.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tokio-redis</kbd></td>
<td class="calibre36">Proof-of-concept redis client based on tokio; should not be used in production.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">service-fn</kbd></td>
<td class="calibre36">Provides a function that implements the Service trait for a given closure.</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Note that a number of these are either not updated in a long time or proof-of-concept implementations that should not be used in anything useful. But that is not a problem. A large number of independent utilities have adopted tokio since it was launched, resulting in a vibrant ecosystem. And, in our opinion, that is the true sign of success of any open source project.</p>
<p class="calibre2">Let us look at some commonly used libraries in the preceding list , starting with <kbd class="calibre11">tokio-curl</kbd>. For our example, we will simply download a single file from a known location, write it to local disk, and print out the headers we got back from the server. Because this is a binary, we will set the project up like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin tokio-curl</strong></pre>
<p class="calibre2">Here is what the Cargo setup looks like:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "tokio-curl"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>tokio-curl = "0.1"<br class="title-page-name"/>tokio-core = "0.1"<br class="title-page-name"/>curl = "0.4.8"</pre>
<p class="calibre2"><span>As the <kbd class="calibre11">tokio-curl</kbd> library is a wrapper around the Rust <kbd class="calibre11">curl</kbd> library, we will need to include that as well. </span>Here is the main file:</p>
<pre class="calibre17">// ch7/toki-curl/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate curl;<br class="title-page-name"/>extern crate tokio_core;<br class="title-page-name"/>extern crate tokio_curl;<br class="title-page-name"/><br class="title-page-name"/>use curl::easy::Easy;<br class="title-page-name"/>use tokio_core::reactor::Core;<br class="title-page-name"/>use tokio_curl::Session;<br class="title-page-name"/>use std::io::Write;<br class="title-page-name"/>use std::fs::File;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut core = Core::new().unwrap();<br class="title-page-name"/>    let session = Session::new(core.handle());<br class="title-page-name"/><br class="title-page-name"/>    let mut handle = Easy::new();<br class="title-page-name"/>    let mut file = File::create("foo.zip").unwrap();<br class="title-page-name"/>    handle.get(true).unwrap();<br class="title-page-name"/>    handle.url("http://ipv4.download.thinkbroadband.com/5MB.zip").unwrap();<br class="title-page-name"/>    handle.header_function(|header| {<br class="title-page-name"/>        print!("{}", std::str::from_utf8(header).unwrap());<br class="title-page-name"/>        true<br class="title-page-name"/>    }).unwrap();<br class="title-page-name"/>    handle.write_function(move |data| {<br class="title-page-name"/>        file.write_all(data).unwrap();<br class="title-page-name"/>        Ok(data.len())<br class="title-page-name"/>    }).unwrap();<br class="title-page-name"/><br class="title-page-name"/>    let request = session.perform(handle);<br class="title-page-name"/><br class="title-page-name"/>    let mut response = core.run(request).unwrap();<br class="title-page-name"/>    println!("{:?}", response.response_code());<br class="title-page-name"/>}</pre>
<p class="calibre2">We will use the <kbd class="calibre11">Easy</kbd> API from <kbd class="calibre11">curl</kbd> crate. We start with creating our event loop and HTTP session. We then create a handle that <kbd class="calibre11">libcurl</kbd> will use to process our request. We call the <kbd class="calibre11">get</kbd> method with a bool to indicate that we are interested in doing an HTTP GET. We then pass the URL to the handle. Next, we set two callbacks passed as closures. The first one is called the <kbd class="calibre11">header_function</kbd>; this one shows each of the client-side headers. The second one is called the <kbd class="calibre11">write_function</kbd>, which writes the data we got to our file. Finally, we create a request by calling the <kbd class="calibre11">perform</kbd> function for our session. Lastly, we run the request in our event loop and print out the status code we got back.</p>
<p class="calibre2">Running this does the following:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling tokio-curl v0.1.0 (file:///src/ch7/tokio-curl)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.97 secs<br class="title-page-name"/>     Running `target/debug/tokio-curl`<br class="title-page-name"/>HTTP/1.1 200 OK<br class="title-page-name"/>Server: nginx<br class="title-page-name"/>Date: Mon, 25 Dec 2017 20:16:12 GMT<br class="title-page-name"/>Content-Type: application/zip<br class="title-page-name"/>Content-Length: 5242880<br class="title-page-name"/>Last-Modified: Mon, 02 Jun 2008 15:30:42 GMT<br class="title-page-name"/>Connection: keep-alive<br class="title-page-name"/>ETag: "48441222-500000"<br class="title-page-name"/>Access-Control-Allow-Origin: *<br class="title-page-name"/>Accept-Ranges: bytes<br class="title-page-name"/><br class="title-page-name"/>Ok(200)</pre>
<p class="calibre2">This will also produce a file called <kbd class="calibre11">foo.zip</kbd> in the current directory. You can use a regular file to download the file and compare the SHA sums of both files, to verify that they are indeed the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Conclusion</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was an introduction to one of the most exciting components of the larger Rust ecosystem. Futures and the Tokio ecosystem provide powerful primitives that can be widely used in applications, including networking software. In itself, Futures can be used to model any computation that is otherwise slow and/or depends on an external resource. Coupled with tokio, it can be used to model complex protocol behaviors that are pipelined, or multiplexed, and so on.</p>
<p class="calibre2">Some major drawbacks of using these center around lack of proper documentation and examples. Also, error messages from these applications are often heavily templated and, hence, verbose. Because the Rust compiler itself does not know of the abstractions as such, it often complains about type mismatches, and it is up to the user to reason through deeply nested types. Somewhere down the line, it may make sense to implement a compiler plugin for futures that can translate these errors in more intuitive forms.</p>
<p class="calibre2">In the following chapter, we will look at implementing common security-related primitives in Rust.</p>


            </article>

            
        </section>
    </body></html>