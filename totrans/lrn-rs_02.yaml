- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all programming languages, we need a way to store information within
    our application. This information can be anything and, as with every other language,
    it's stored in a variable. However, unlike every other language, Rust does not
    store data in the same way as (say) C does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, in this chapter we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand variable mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how Rust stores information in a variable, and the types of variable available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how Rust deals with vector variable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how Rust can and cannot manipulate variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how Rust can pass variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at how Rust stores a variable internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike many other languages, Rust defaults to non-mutability of variables. That
    means that variable bindings are actually constants if not explicitly defined
    as mutable. The compiler checks against all variable mutations and refuses to
    accept mutating non-mutable variable bindings.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from one of the C family of languages, a non-mutable can be considered
    to be roughly the same as a `const` type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new variable binding in Rust, we use the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we create a new variable binding called `x` whose content will
    be `1`. The default type for numbers depends on the situation a bit, but usually
    it''s a 32-bit signed integer. If we need a variable that can change, we use this
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, all variables in Rust are non-mutable; therefore, we have to explicitly
    define a variable as being mutable.
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell the compiler that we want x to be an int?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust has a way of informing both the compiler and the developer of the variable
    type. For example, for a 32-bit `int`, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `x` = `1`, a 32-bit signed `int`.
  prefs: []
  type: TYPE_NORMAL
- en: If a variable is defined without the `i32` (or any other value), the compiler
    will decide the type depending on how the value is used, defaulting to `i32`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining other variable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other variable types can be declared in the same way as `int` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much as with other languages, floating point arithmetic can be performed in
    Rust. As with an integer variable, a floating point variable is defined for a
    32-bit `float` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For a 64-bit `float`, it will be defined as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables are literal values. Another way to declare the size would be
    via types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If a type is omitted (for example, let `x` = `3.14`), the variable will be declared
    as a 64-bit floating point variable.
  prefs: []
  type: TYPE_NORMAL
- en: Signed and unsigned integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A signed `int` (one that can have positive or negative values) is defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An unsigned `int` has a `u` instead of `i` in the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, these are number literals, and the same declaration can be made via
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both signed and unsigned `int` values can be 8, 16, 32, or 64-bits long.
  prefs: []
  type: TYPE_NORMAL
- en: Const and static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust has two types of constants: **consts** and **statics**. Consts are sort
    of like aliases: their contents are sort of replaced on the place where they are
    used. The syntax is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Statics are more like variables. They have a global scope of the program, and
    are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: They cannot be altered.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is able to guess the types of local function variables. This is called
    **local type inference**. However, it is only local, so types of statics and consts
    must always be typed out.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the variable value before use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is not enforced in some languages, a variable must have an initial
    value in Rust, even if it is zero. This is good practice, and also helps when
    it comes to debugging since all variables have known contents. If they didn't,
    there'd be a risk of undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined behavior means that what the program does is anyone's guess. For instance,
    if variables did not have initial values, their values would be whatever happens
    to be in memory at the time that the value is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, a string can be defined in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is known as a **string slice**. These will be dealt with in a while.
  prefs: []
  type: TYPE_NORMAL
- en: The second way is to use `String::new();`. This is a String, with a capital
    S. It is allocated in the heap and can grow dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it would be a good idea to break with the current narrative and
    discuss how Rust uses memory, as it will help greatly with explaining a number
    of upcoming topics.
  prefs: []
  type: TYPE_NORMAL
- en: How Rust uses memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The memory occupied by any Rust program is split into two distinct areas: the
    heap and the stack. Simply put, the stack contains primitive variables, while
    the heap stores complex types. As with the mess on my daughter''s bedroom floor,
    a heap can grow and grow until the available memory is exhausted. The stack is
    faster and simpler but may not grow without limits. Every binding in Rust is in
    a stack, but those bindings may refer to things in the heap, and elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: This all relates directly to the string example. The binding `myName` is in
    the stack, and refers to a literal static string, *my name*. That string being
    static means that it is somewhere in memory when the program starts. Its being
    static also means that it cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '`String::new`, on the other hand, creates a String in the heap. It is initially
    empty, but may grow to fill the whole virtual memory space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a growing String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One of the ways of creating Strings is to call the `to_owned` method on a string
    slice, like we have just done. There are other ways, but this is the most recommended
    one because it underlines the ownership issue. We'll get back to that later.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the binding `myStringOne` starts out at 24 characters long, and would
    be allocated at least that size on the heap. The binding `myStringOne` is actually
    a reference to the position on the heap where `myStringOne` lives.
  prefs: []
  type: TYPE_NORMAL
- en: As we add to `myStringOne`, the size it occupies on the heap increases; however,
    the reference to the base position remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime and scope of a variable have to be taken into account. For example,
    if we define a string within part of a function, and then try and access the string
    outside the function, we get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw before diverting onto the heap and stack, we can also define a string
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `String::` tells the compiler that we are going to use the standard library,
    `String`, and we tell the program that we are going to create a mutable String
    and store a reference to it on the stack in something called `myString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic string can be created as either being empty, or with memory preallocated
    to it. For example, say we want to store the words *You''ll never walk alone* (a
    total of 23 bytes), preallocating the space for them. This is how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a performance optimization and is not typically required, since
    Strings grow automatically when they need to. The following does roughly the same
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rust strings are not null-terminated, and consist entirely of valid Unicode.
    Therefore, they can contain null bytes and characters from any language, but they
    may require more bytes than they contain characters.
  prefs: []
  type: TYPE_NORMAL
- en: String slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String slices can be confusing at first sight. We define a string slice like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Coming from more dynamic languages, you might think that we are assigning the
    string `Liverpool` to the variable binding `homeTeam`. That''s not exactly what
    happens, however. The `homeTeam` binding is actually a string slice: a reference
    to a part of the string that actually resides somewhere else.'
  prefs: []
  type: TYPE_NORMAL
- en: The string slice is also not mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will not work in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will not allow this, and will give an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We cannot concatenate the slice directly, since string slices cannot be mutable.
    To do that, we need to first convert the string slice into something that is mutable,
    or build the string with something like the `format!` macro. Let's try them both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like before, the `to_owned()` method takes the slice the method is attached
    to, and converts it to a `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `to_owned()` method is only applied to the first slice. This converts the
    string slice `homeTeam` into a String, and using the `+` operator on a String
    is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this is built and executed, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What's with the warnings?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recommended format that Rust uses is snake case (rather than CamelCase).
    The warnings can be removed if we change the variable name from `homeTeam` to
    `home_team`. It's not fatal, or likely to cause the program to go on a homicidal
    rampage; it's more of a style issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using the format! macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `format!` macro works in a way similar to string formatters in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `{}` in the format strings mark spots for the following parameters. The
    spots are filled in order, so `full_line` will be a concatenation of `home_team`,
    `result`, and `away_team`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding code snippet is compiled and executed, you will see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that we can create a String from a string slice (using `to_owned()`
    or the `format!` macro), or we can create it using `String::new()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two further ways to help build the string: `push` adds a single character
    to the string, and `push_str` adds an `str` to the string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When this last code snippet is compiled and executed, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Code review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code is somewhat different from the code in previous examples
    where we have simply used `to_owned()` to convert the slice to a string. We now
    have to create a mutable string and assign to that rather than just add to the
    end of `full_line` as we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that the slice being converted to string is not mutable; therefore,
    the type created will also be non-mutable. Since you cannot add to a non-mutable
    variable, we could not use the `push` and `push_str` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust allows for variables to be cast differently. This is achieved using the
    `as` keyword. This works in the same way as it does in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also cast to a different type (for example, `float` to `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the effects of precision-losing casts like this one may not be desirable.
    For instance, if you cast a float that''s over the bit size of `i8` to `i8`, the
    number gets truncated to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'An error will occur if the types you are attempting to cast to are not compatible;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Rust does not do implicit casting between primitive types, even when it would
    be safe. That is, if a function expects an `i8` as a parameter, you must cast
    an `i16` value to `i8` before passing it. The reason for this is to achieve the
    maximum type checking and, therefore, reduce the number of potential (and more
    problematic) hidden bugs.
  prefs: []
  type: TYPE_NORMAL
- en: String methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are important in any language. Without them, it becomes difficult to
    communicate with users, and if data is coming from a web service (in the form
    of XML, plain text, or JSON), this data will need to be manipulated. Rust provides
    the developer with a number of methods in the standard library to deal with strings.
    Here''s a table of some useful methods (don''t worry about the types yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **What it does** | **Usage (or example project)** |'
  prefs: []
  type: TYPE_TB
- en: '| `from(&str) -> String` | This method creates a new String from a string slice.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `from_utf8( Vec < u8 > ) -> Result<String, FromUtf8Error>` | This method
    creates a new string buffer from a valid vector of UTF-8 characters. It will fail
    if the vector contains non-UTF8 data. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `with_capacity(usize) -> String` | This method preallocates a String with
    a number of bytes. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `as_bytes -> &[u8]` | This method outputs a String as a byte slice. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `insert(usize, char)` | This method inserts `char` at position `index`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `len -> usize` | This method returns the length of the String in bytes. It
    may therefore be larger than the number of characters in the String. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `is_empty -> bool` | This method returns `true` if the String is empty. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `is_char_boundary(usize) -> bool` | This method returns `true` if a character
    at `index` falls on a Unicode boundary. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Generics and arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those coming from a C# or C++ background, you will no doubt be used to
    generic types (often referred to as having a type `T`); you will be used to seeing
    things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Generics allow defining methods for several types. In its most general form,
    `T` means "any type." The following function, for instance, takes two arguments
    that can be any type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`T`, as has been established, can be of any type. This means that we cannot
    do much with them, since only a few methods are implemented for "any type." For
    instance, if we would like to add these variables together, we would need to restrict
    the generic types somewhat. We would essentially need to tell Rust that "T may
    be of any type, as long as it implements addition." More about this later.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are simple to construct. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays must comply with a number of rules, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The array has a fixed size. It can never grow as it is stored as a continuous
    memory block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the array can only ever be of one type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any type of variable, by default arrays are non-mutable. Even if the
    array is mutable, the overall size cannot be changed. For example, if an array
    has five elements, it cannot be changed to six.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create an array with a type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to create an array a number of times with the same value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will create an array called `number` with `5` elements, all initialized
    to a value of `111`.
  prefs: []
  type: TYPE_NORMAL
- en: Array performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While arrays are useful, they do have a performance hit; as with most operations
    on an array, the Rust runtime will perform bound checks to ensure the program
    does not access the array out of bounds. This prevents classic array overflow
    attacks and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While arrays are simple to use, they have a single big disadvantage: they cannot
    be resized. The vector (`Vec`) acts in a way similar to a `List` in C#. It is
    also a generic type, as `Vec` itself is actually `Vec<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Vec` type is found in the standard library (`std::vec`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a vector, we use something akin to either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `f32` within the `Vec` macro tells the compiler that the type for the vector
    is `f32`. The `f32` can be omitted, as the compiler can determine the type for
    the vector.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a vector with an initial size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with a String, it is possible to create a vector with an initial allocation
    of memory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Creating a vector via an iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to create a vector is via an iterator. This is achieved via the
    `collect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The format for the iterator is very convenient. Instead of the likes of `let
    foo = {0,1,2,3};`, this is shortened to use `..`, which means all numbers between
    *a* and *b* (*b* being excluded - so `0 .. 10` creates a vector containing 0,1,2,3,4,5,6,7,8,9).
    This can be seen in the source example supplied with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing from the vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a similar fashion to string, it is possible to add and remove from the vector
    list using the `push` and `pull` methods. These add or remove from the top of
    the vector stack. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We create the vector list with values from 0 going up to 10 (so the last value
    is 9).
  prefs: []
  type: TYPE_NORMAL
- en: The line `println!("{:?}", my_vec);` outputs the entire contents of `my_vec`.
    `{:?}` is required here due to the type `Vec<i32>` not implementing certain formatting
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: We then push onto the top of the vector list 13 then 21, display the output
    on the screen, and then remove the top-most value on the vector list, and output
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating an array or vector via slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both arrays and vectors can be accessed using a value (such as `my_vec[4]`).
    However, if you want to manipulate a section of the array, then you would take
    a slice from the array. A slice is like a window to a part of the original thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a slice, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A slice also has no predefined size: it can be 2 bytes, or it can be 202 bytes.
    Due to this, the size of the slice is not known at compile time. This is important
    to know, because it prevents certain methods from working.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing values around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have kept everything within a single method. For small
    demonstrations (or for method testing), this is fine. However, for larger applications,
    passing values between methods is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust has two main ways to pass information to other methods: by reference or
    by value. Passing by reference usually implies borrowing, which means that ownership
    is only temporarily given and can be used again after the function call. Passing
    by value implies either a permanent ownership change, which means that the caller
    of a function can no longer access the value, or it might imply copying the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing by value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows how to pass a number between two functions, and to
    receive a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the receiving function''s definition line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As with any programming language, we have to give the function a name, and then
    a parameter list. The parameter names are followed by a colon and the type of
    the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Our function returns a value (this is signified by the `->` symbol) of a particular
    type (in this case, `i32`). The last evaluated thing in the function will be returned
    from the function, provided that you don't accidentally put a semi-colon there.
    An implicit return statement also exists, but it's not required and it's usually
    better style to omit it if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When built and run, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Passing by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable passed by a reference looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We take two variables as references, and return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a value from a reference, the first thing to do is dereference it.
    This is done with the asterisk (`*`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The reference type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A reference is written in one of three ways: `&`, `ref`, or `ref mut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The references are all equivalent here. Note, however, that the preceding code
    doesn't work as it is due to mutable reference rules. Rust allows several immutable
    reference to a thing, but if a mutable reference is taken, no other references
    may exist at the time. Therefore, the last line would not work, since there are
    already two active references to var.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example code, `matrix`, we can see how to use a 2D array and how to
    pass by a reference, with the receiving function calculating the result of a matrix
    multiplication. Let''s examine the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we need to really consider here is the definition line for the `matrix_multiply`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recall how we told a function the name of the variable and the type
    earlier, we said it was `variable_name: variable_type`. The preceding line may
    look very much different, but it really isn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We are passing in a reference to a holding array, which holds references to
    other arrays. The array is defined using `[i32;4]`; therefore, the reference is
    `&[i32;4]`. This is the inner array. The outer array `[i32;4]` is also a reference
    (`&[i32;4]`), which has a size of 4\. Therefore, when we put these together, we
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example shows how to pass by a reference quite nicely, though
    in reality, it is most likely that the compiler will optimize this out to something
    faster for such a small data sample. It does show, however, how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: The golden rule is that what you send over to the function has to marry up with
    what the function is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a great deal in this chapter, and I really encourage you to
    play around creating functions and passing values around.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to continually create new projects every time you create a
    new application, you can create and test your code on the Rust Playground website
    ([https://play.rust-lang.org](https://play.rust-lang.org)). Here you can enter
    your code, hit Run, and see instantly if what you have written works.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering getting information in and out, and
    validating your entries.
  prefs: []
  type: TYPE_NORMAL
