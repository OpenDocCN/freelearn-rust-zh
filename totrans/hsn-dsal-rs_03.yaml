- en: Storing Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the foundation of the previous chapters in place, we can now move on to
    more architectural aspects of algorithms and data structures. Rust—with its ownership
    model—calls for considering lifetimes, memory placement, and mutability in their
    algorithmic design. In this chapter, you can look forward to learning about the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs considering speed and readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing heap and stack variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How immutability influences design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heaps and stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 1](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml),
    *Hello Rust!*, stack variables are preferred thanks to their low overhead and
    speed compared to heap-allocated data, which automatically introduces overhead
    thanks to the necessary heap pointer. For stack variables, Rust''s types even
    allow for zero overhead structures, so no additional metadata is stored. The following
    snippet asserts that there are no additional bytes being used for arrays or user-defined
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, the size of an instance of the `MyStruct` type is always going
    to be three bytes—perfectly suitable for placing it on the stack. Why is that
    good? In short, data locality. Instead of pointer dereferencing, the data is stored
    right at the point of execution, making it easy to cache and fast to access.
  prefs: []
  type: TYPE_NORMAL
- en: Types that don't have predictable sizes (such as `String` instances) require
    heap allocation, just like objects that are wrapped into `Rc`, `Cell`, `RefCell`,
    or `Box` instances. However, heap allocations and access come at a considerable
    cost, as minimizing those typically yields great performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Sized and unsized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the compiler to translate written code into a binary format, it''s necessary
    to know each type''s size. As we discussed earlier, the size is important so that
    we can put other types *on top* when working on the stack, something that is easy
    if the size doesn''t change with respect to the data it contains (a sized type).
    The best example for this is `u32`: it uses 32 bits (or 4 bytes), regardless of
    whether you store `0` or `10000900`.'
  prefs: []
  type: TYPE_NORMAL
- en: This isn't the case when the type is unsized or dynamically sized, the best
    example being a `str`. Depending on the number of characters, this type's size
    will vary considerably, and which is why instances are usually encountered in
    the form of slices.
  prefs: []
  type: TYPE_NORMAL
- en: Slices are Rust's way of providing generic algorithms to all kinds of data types,
    and they will be discussed more in [Chapter 12](04e371f3-13fa-4c73-9329-8074a080785a.xhtml),
    *Algorithms of the Standard Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Slices work around the size issue by storing a fixed-size reference (`&str`)
    to the heap-allocated value, along with its length in bytes. Similar to pointers,
    this is a fixed-size view into a previously-unsized value. Every time a pointer
    of some kind (`&`, `Rc`, `Box`, `Cell`, and so on) is created, the reference is
    stored alongside the length and some (fixed size) metadata. The knowledge of sized
    versus unsized is especially useful when the type is previously unknown—when working
    with Rust's generics, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust supports generics and even allows us to enforce the implementation of
    certain traits. These constraints can either come as a where clause attached to
    the function definition or with a colon in the generic type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the 2018 `impl Trait` syntax simplifies single-trait requirements
    (to do static instead of dynamic dispatch) for input and return parameters, thereby
    eliminating the need for a `Box` or lengthy type constraints (such as `MyTrait`
    in the preceding snippet). Unless multiple trait implementations are required
    (for example, `fn f(x: T) where T: Clone + Debug + MyTrait {}`), the `impl Trait`
    syntax allows us to put them where they matter, which is into the parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with generics, the situation is a bit more complex. Type parameters
    are `Sized` by default (see the preceding snippet), which means that they will
    not match unsized types. To match those as well, the special `?Sized` type constraint
    can be used. This snippet also shows the required change to passing in a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, any type of heap-allocated reference will incur an extra step to access
    the contained value.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An extra step doesn't sound like much, but it has considerable consequences.
    This trade-off for easily sharing ownership across various functions or threads
    removes the ability to put as much data as possible into the CPU's cache, since
    the pointer makes any data locality difficult. Heap allocations themselves are
    expensive operations and reducing those will already provide a major speedup.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the compiler cannot deallocate a boxed value if it's still referenced
    in some places—a problem that occurs especially if the program is large and complex.
    Similar to orphaned objects in C# or Java, a saved `Rc` reference can easily be
    forgotten, creating a memory leak. Therefore, it's recommended to use heap memory
    only when required.
  prefs: []
  type: TYPE_NORMAL
- en: One principle piece of advice that requires a boxed value in Rust is to "favor
    object composition over class inheritance" (Gang of Four 1995:20). In the absence
    of class inheritance, the choice is obviously to use object composition. Considering
    that you should also "program to an interface not to an implementation" (ibid),
    there is often a strong wish to put a reference to a trait inside of a `struct`
    instead of directly working with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To apply this architecture in Rust, the language requires us to put a trait's
    implementation into a `Box<dyn TheTrait>`, making it more difficult to handle,
    test, and reason about. This `trait` object requires the compiler to rely on dynamic
    dispatch, which is considerably slower than the default static dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic dispatch are the two major ways of calling functions in many
    programming languages, including Rust. While for static dispatch functions, locations
    are known at compile time, dynamic dispatch functions are only known at runtime
    and have to be looked up in a **vtable** that points to the actual address. Both
    have their merits, so be intentional with their use.
  prefs: []
  type: TYPE_NORMAL
- en: Other than generics, there is no default solution to this issue. The `impl Trait`
    addition of Rust 2018 alleviates this issue for function parameters and return
    values, but cannot be used for field types.
  prefs: []
  type: TYPE_NORMAL
- en: So far, it looks like the best choice is to use concrete types instead of traits
    to avoid multiple dereference operations—as long as refactoring on change seems
    to be doable. If you create a library, generics are a better way to go for performance
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and cloning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](e07bf37e-f255-42ef-abbb-9f141dc5be61.xhtml), *Hello Rust!,* we
    discussed `Send`, a marker trait that allows a type to be "sent" across multiple
    threads. Something that's similar but less complex is local moving, which commonly
    occurs in a program—for example, when you pass a variable into a function.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and cloning, on the other hand, happen on different occasions. When
    a variable is assigned to another variable, the compiler will typically copy the
    value implicitly, which can be done safely and cheaply for stack-allocated variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`Copy` is an implicit, bitwise copy of the value of a variable. If that variable
    is a pointer, the memory responsibility becomes ambiguous (who takes care of freeing?)
    and compilation will fail. This is where `Clone` comes in. The trait requires
    an explicit implementation of the `clone()` function to provide an appropriate
    copy of the type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloning is always a deep copy of a type—implemented either manually (with the
    `Clone` trait) or by using the `derive` macro. Then, cloning is only a matter
    of invoking the `clone()` function, an operation that is not necessarily cheap.
    The following snippet illustrates these two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The regular usage of these traits and operations is usually intuitive and there
    isn't much that can go wrong. Usually the compiler clearly states the need for
    a `Copy` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended to derive or implement `Copy` wherever possible, but be mindful
    of breaking changes. Adding the trait is a non-intrusive action, whereas removing
    the trait will potentially break other people's code.
  prefs: []
  type: TYPE_NORMAL
- en: While copying and cloning are great for providing ownership to multiple scopes,
    they are required when working with immutable storage.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Garbage collectors simplified mutability considerably and, as a consequence,
    many of these languages don't need a specific modifier for mutability. While this
    garbage collection mechanism comes at the expense of runtime with frequent cleanups,
    not having to care about making variables mutable is very convenient. It lets
    developers focus on the logic they are implementing instead.
  prefs: []
  type: TYPE_NORMAL
- en: So why did Rust (and many functional languages) bring back this concept?
  prefs: []
  type: TYPE_NORMAL
- en: States and reasoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state of an object is essentially the current values that its fields have
    at any given time. Changing this state is done by the object itself via messages
    on defined behavior (called methods) according to object-orientation principles.
    These state changes require mutability.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout their lifetimes, most objects change their states multiple times,
    and since this happens at runtime, we find ourselves often looking at an object's
    debug print in frustration, thinking, "How did this value get here?"
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures remedy this by making it impossible to change their
    contents, so any time you would look at an object, it has exactly the right values.
    It's a known fact that the majority of variables don't need to be mutable, and
    unless there is a resource constraint, creating another instance of the object
    with its new state is recommended. This principle, called **copy-on-write**, improves
    readability for better maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: A popular type that employs copy-on-write is the `String`—in almost any language.
    The type wraps a byte array and interprets it using a provided character set (usually
    UTF-8), and if you modify a character, this array is copied and saved with the
    changes made. This is done so often that `String` allocations are a common performance
    pitfall.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Rust standard library, there is a `Cow` enumeration (`std::borrow::Cow`)
    that lazily clones a contained reference whenever mutation or ownership is requested.
    For a great example, check out the Cow documentation: [https://doc.rust-lang.org/std/borrow/enum.Cow.html](https://doc.rust-lang.org/std/borrow/enum.Cow.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The principle of copy-on-write can also be found in filesystems to create snapshots
    (for example, in ZFS or BRTFS) and provides the benefits of both immutability
    and mutability at the cost of runtime resources. It's a trade-off between maintainability
    and absolute performance. A similar concept is employed by persistent data structures,
    which can be partially or fully persistent and still be immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having code that is easier to reason about and where the state cannot be changed
    is even more important in multithreaded scenarios. This prevents so-called anomalies
    (or side effects) where the state of an object is changed outside a dependent
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Locks are generally made to change the state of a shared object—they secure
    critical sections, which only a single thread can modify at any given time. Other
    threads have to "line up" and wait for the lock to be released to access the part
    as well. In Rust, this is called a **mutex**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locks and mutex zones are bad for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They have to be in the right order (acquired and released).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when a thread panics in a mutex zone?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are hard to integrate seamlessly into the part of the program that they
    protect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a bottleneck for performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability is a simple way to avoid all of these, and there are many immutable
    data structure crates available, including one with persistent data structures
    called **Rust Persistent Data Structures** (**RPDS**) ([https://crates.io/crates/rpds](https://crates.io/crates/rpds)),
    that utilize a copy-on-write approach with versioning to capture state changes.
    Since these changes build on top of each other, threads can fully read one consistent
    object state at a time without having to wait or acquire a lock.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lock-free data structures** are a specialized version of data structures
    that are very challenging to implement. These data structures use atomic operations
    to modify important parts (for example, the head pointer in a stack) and thereby
    achieve excellent performance without locking caveats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistent data structures** are a take on creating data structures that
    are as efficient and mutable as their traditional counterparts, but better suited
    for concurrency. This is achieved by keeping the original data immutable and storing
    versioned change sets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of immutable data is best thought of in the context of functional
    programming. Functional programming is built on the principle of mathematical
    functions. A function is a relation of two sets of data (typically *X* and *Y*),
    where each element of *X* has exactly one element in *Y* that it maps to using
    the *f* function ( in short: *![](img/db4b77af-b0e4-4a71-8788-925b5d520ea8.png)*where
    *![](img/44f9059b-3a25-4d99-ad23-b9c0c48d3edc.png)).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence, the input data, *X*, will not be changed to produce output
    data, *Y*, making it easy to run the *f* function in parallel. The downside is
    the increased cost at runtime: regardless of the operation, whether it''s only
    to flip a bit on the input data or to overhaul everything, the result is always
    a full copy.'
  prefs: []
  type: TYPE_NORMAL
- en: To reduce this inefficiency, the Gang of Four's decorator pattern on *X*'s iterator
    can be used to stack up only the changes and execute them on every call, reducing
    runtime complexity and avoiding multiple copies of the output data. A problem
    that remains is that if the input and the output are large, a lot of memory is
    required. This is a tricky situation and can only be avoided by the programmer
    thinking thoroughly about decomposing the function better.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving one level above the details of code, this chapter discusses considerations
    when designing and using types. Rust's differentiation between stack- and heap-allocated
    variables in code provides a level of control that should be used to improve performance
    and API flexibility. `Sized`, a marker trait for mostly stack-allocated values,
    is the default for generic type parameters and can be relaxed by applying the
    `?Sized` constraint instead.
  prefs: []
  type: TYPE_NORMAL
- en: When working with more object-oriented architectures, trait objects become a
    way to "work with interfaces" instead of specific implementations. However, they
    come at a performance cost, that is, dynamic dispatch, another trade-off between
    maintainability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Other than moving, Rust can copy or clone variables when necessary. Copy performs
    a deep copy in the case of sized values; unsized values require a reference that
    has to be cloned instead. Using these operations is often encountered when working
    with immutable data types in a principle called copy-on-write. Choosing whether
    we are able to reason about the object's state at any given time and avoiding
    data race conditions, but having to create a copy for each change, is another
    important trade-off when designing data structures.
  prefs: []
  type: TYPE_NORMAL
- en: This trade-off will become apparent in the next chapter, where we will start
    working with lists, such as the singly-linked list, doubly-linked list, and the
    dynamic array.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are `Sized` types different from other types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `Clone` differ from `Copy`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the main drawbacks of immutable data structures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can applications benefit from immutable data structures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about an immutable list that you want to work on—how would you distribute
    it across multiple threads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics that are covered in this chapter, check
    out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://cglab.ca/~abeinges/blah/too-many-lists/book/](http://cglab.ca/~abeinges/blah/too-many-lists/book/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://doc.rust-lang.org/std/mem/fn.size_of.html](https://doc.rust-lang.org/std/mem/fn.size_of.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Functional_programming](https://en.wikipedia.org/wiki/Functional_programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Persistent_data_structure](https://en.wikipedia.org/wiki/Persistent_data_structure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
