["```rs\n    let mut my_vector = vec![0, 16, 34, 13, 95];\n    my_vector.push(22);\n    println!(\"{:?}\", my_vector);\n```", "```rs\n    let mut my_vector = vec![73, 55];\n    println!(\n        \"length: {}, capacity: {}\",\n        my_vector.len(),\n        my_vector.capacity()\n    );\n\n    my_vector.push(25);\n    println!(\n        \"length: {}, capacity: {}\",\n        my_vector.len(),\n        my_vector.capacity()\n    );\n\n    my_vector.push(33);\n    my_vector.push(24);\n    println!(\n        \"length: {}, capacity: {}\",\n        my_vector.len(),\n        my_vector.capacity()\n    );\n```", "```rs\nfn change_third(slice: &mut [u32]) {\n    if let Some(item) = slice.get_mut(2) {\n        *item += 1\n    }\n}\n\nfn print_third(slice: &[u32]) {\n    if let Some(item) = slice.get(2) {\n        println!(\"Third element: {}\", item);\n    }\n}\n```", "```rs\nfn main() {\n    let mut my_vector = vec![73, 55, 33];\n    print_third(&my_vector);\n    change_third(&mut my_vector[..]);\n    print_third(&my_vector);\n}\n```", "```rs\nfn change_third(mut slice: Vec<u32>) {\n    if let Some(item) = slice.get_mut(2) {\n        *item += 1\n    }\n}\n```", "```rs\n    change_third(my_vector);\n```", "```rs\nstruct Parent<'p> {\n    age: u8,\n    child: Option<&'p Child>,\n}\n\nstruct Child {\n    age: u8,\n}\n```", "```rs\nfn main() {\n    let child = Child { age: 10 };\n    let parent = Parent {\n        age: 35,\n        child: Some(&child),\n    };\n\n    println!(\"Child's age: {} years.\", parent.child.unwrap().age);\n}\n```", "```rs\n    let mut parent = Parent {\n        age: 35,\n        child: None,\n    };\n\n    {\n        let child = Child { age: 10 };\n        parent.child = Some(&child);\n    }\n\n    println!(\"Child's age: {} years.\", parent.child.unwrap().age);\n```", "```rs\nfn oldest_child(child1: &Child, child2: &Child) -> &Child {\n    if child1.age > child2.age {\n        child1\n    } else {\n        child2\n    }\n}\n```", "```rs\nfn oldest_child<'f>(child1: &'f Child, child2: &'f Child) -> &'f Child {\n    if child1.age > child2.age {\n        child1\n    } else {\n        child2\n    }\n}\n```", "```rs\nstruct Complex {\n    attr1: u8,\n    attr2: u16,\n    attr3: u8,\n}\n```", "```rs\nstruct Complex {\n    attr1: u8,\n    _pad1: u8,\n    attr2: u16,\n    attr3: u8,\n    _pad2: u8,\n}\n```", "```rs\nstruct Complex {\n    attr2: u16,\n    attr1: u8,\n    attr3: u8,\n}\n```", "```rs\n#[repr(C)]\nstruct Complex {\n    attr3: u8,\n    attr2: u16,\n    attr1: u8,\n}\n```", "```rs\n#[repr(packed)]\nstruct Complex {\n    attr3: u8,\n    attr2: u16,\n    attr1: u8,\n}\n```", "```rs\nenum Color {\n    Red,\n    Blue,\n    Green,\n    Other { r: u32, g: u32, b: u32 },\n}\n```", "```rs\npub enum Value {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec<Value>),\n    Object(Map<String, Value>),\n}\n```", "```rs\nenum Color<'c> {\n    Red,\n    Blue,\n    Green,\n    Other(&'c Rgb),\n}\n\nstruct Rgb {\n    r: u32,\n    g: u32,\n    b: u32,\n}\n```", "```rs\nenum Color {\n    Red,\n    Blue,\n    Green,\n    Other(Box<Rgb>),\n}\n```", "```rs\nunion Plant {\n    g: Geranium,\n    c: Carnation,\n}\n\n#[derive(Copy, Clone)]\nstruct Geranium {\n    height: u32,\n}\n\n#[derive(Copy, Clone)]\nstruct Carnation {\n    flowers: u8,\n}\n```", "```rs\nfn main() {\n    let mut my_plant = Plant {\n        c: Carnation { flowers: 15 },\n    };\n    my_plant.g = Geranium { height: 300 };\n    let height = unsafe { my_plant.g }.height;\n\n    println!(\"Height: {}\", height);\n}\n```", "```rs\nuse std::cell::Cell;\n\n#[derive(Copy, Clone)]\nstruct House {\n    bedrooms: u8,\n}\n\nimpl Default for House {\n    fn default() -> Self {\n        House { bedrooms: 1 }\n    }\n}\n\nfn main() {\n    let my_house = House { bedrooms: 2 };\n    let my_dream_house = House { bedrooms: 5 };\n\n    let my_cell = Cell::new(my_house);\n    println!(\"My house has {} bedrooms.\", my_cell.get().bedrooms);\n\n    my_cell.set(my_dream_house);\n    println!(\"My new house has {} bedrooms.\", my_cell.get().bedrooms);\n\n    let my_new_old_house = my_cell.replace(my_house);\n    println!(\n        \"My house has {} bedrooms, it was better with {}\",\n        my_cell.get().bedrooms,\n        my_new_old_house.bedrooms\n    );\n\n    let my_new_cell = Cell::new(my_dream_house);\n\n    my_cell.swap(&my_new_cell);\n    println!(\n        \"Yay! my current house has {} bedrooms! (my new house {})\",\n        my_cell.get().bedrooms,\n        my_new_cell.get().bedrooms\n    );\n\n    let my_final_house = my_cell.take();\n    println!(\n        \"My final house has {} bedrooms, the shared one {}\",\n        my_final_house.bedrooms,\n        my_cell.get().bedrooms\n    );\n}\n```", "```rs\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\nstruct Tree<T> {\n    root: Node<T>,\n}\n\nstruct Node<T> {\n    parent: Option<Weak<Node<T>>>,\n    left: Option<Rc<RefCell<Node<T>>>>,\n    right: Option<Rc<RefCell<Node<T>>>>,\n    value: T,\n}\n```"]