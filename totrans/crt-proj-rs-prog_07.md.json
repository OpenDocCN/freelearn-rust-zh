["```rs\nuse nalgebra::{Point2, Vector2};\nfn main() {\n    let p1: Point2<f32> = Point2::new(4., 7.);\n    let p2: Point2<f32> = Point2::new(10., 16.);\n    let v: Vector2<f32> = Vector2::new(6., 9.);\n\n    assert!(p1.x == 4.);\n    assert!(p1.y == 7.);\n    assert!(v.x == 6.);\n    assert!(v.y == 9.);\n\n    assert!(p1 + v == p2);\n    assert!(p2 - p1 == v);\n    assert!(v + v - v == v);\n    assert!(v == (2\\. * v) / 2.);\n\n    //let _ = p1 + p2;\n    let _ = 2\\. * p1;\n}\n```", "```rs\nggez = \"0.5\"\nnalgebra = \"0.18\"\n```", "```rs\nfn main() -> GameResult {\n    let (context, animation_loop) = &mut ContextBuilder::new\n     (\"slalom\", \"ggez\")\n        .window_setup(conf::WindowSetup::default().title(\"Slalom\"))\n        .window_mode(conf::WindowMode::default().dimensions(SCREEN_WIDTH, \n          SCREEN_HEIGHT))\n        .add_resource_path(\"static\")\n        .build()?;\n    let game = &mut Screen::new(context)?;\n    event::run(context, animation_loop, game)\n}\n```", "```rs\nstruct InputState {\n    to_turn: f32,\n    started: bool,\n}\n```", "```rs\ninput: InputState,\n```", "```rs\nfn key_down_event(\n    &mut self,\n    _ctx: &mut Context,\n    keycode: KeyCode,\n    _keymod: KeyMods,\n    _repeat: bool,\n) {\n    match keycode {\n        KeyCode::Left => { self.input.to_turn = -1.0; }\n        KeyCode::Right => { self.input.to_turn = 1.0; }\n        _ => (),\n    }\n}\n```", "```rs\nfn key_up_event(&mut self, _ctx: &mut Context, keycode: KeyCode, _keymod: KeyMods) {\n    match keycode {\n        KeyCode::Left | KeyCode::Right => {\n            self.input.to_turn = 0.0;\n        }\n        _ => (),\n    }\n}\n```", "```rs\nimpl State for Screen {\n```", "```rs\nimpl EventHandler for Screen {\n```", "```rs\nfn update(&mut self, window: &mut Window) -> Result<()> {\n...\nfn draw(&mut self, window: &mut Window) -> Result<()> {\n```", "```rs\nfn update(&mut self, ctx: &mut Context) -> GameResult {\n...\nfn draw(&mut self, ctx: &mut Context) -> GameResult {\n```", "```rs\nconst STEERING_SPEED: f32 = 110\\. / 180\\. * PI; // in radians/second\nconst MAX_ANGLE: f32 = 75\\. / 180\\. * PI; // in radians\n```", "```rs\nconst DESIRED_FPS: u32 = 25;\nwhile timer::check_update_time(ctx, DESIRED_FPS) {\n    ...\n}\n```", "```rs\nself.steer(self.input.to_turn);\n```", "```rs\nlet now = timer::time_since_start(ctx);\nself.period_in_sec = (now - self.previous_frame_time)\n    .as_millis() as f32 / 1000.;\nself.previous_frame_time = now;\n```", "```rs\ngraphics::clear(ctx, graphics::WHITE);\n```", "```rs\nlet ski = graphics::MeshBuilder::new()\n    .rectangle(\n        DrawMode::fill(),\n        Rect {\n            x: -SKI_WIDTH / 2.,\n            y: SKI_TIP_LEN,\n            w: SKI_WIDTH,\n            h: SKI_LENGTH,\n        },\n        [1., 0., 1., 1.].into(),\n    )\n    .polygon(\n        DrawMode::fill(),\n        &[\n            Point2::new(-SKI_WIDTH / 2., SKI_TIP_LEN),\n            Point2::new(SKI_WIDTH / 2., SKI_TIP_LEN),\n            Point2::new(0., 0.),\n        ],\n        [0.5, 0., 1., 1.].into(),\n    )?\n    .build(ctx)?;\n```", "```rs\ngraphics::draw(\n    ctx,\n    &ski,\n    graphics::DrawParam::new()\n        .dest(Point2::new(\n            SCREEN_WIDTH / 2\\. + self.ski_across_offset,\n            SCREEN_HEIGHT * 15\\. / 16\\. - SKI_LENGTH / 2.\n                - SKI_TIP_LEN,\n        ))\n        .rotation(self.direction),\n)?;\n```", "```rs\ngraphics::present(ctx)?;\ntimer::yield_now();\n```", "```rs\nKeyCode::Space => {\n    self.input.started = true;\n}\nKeyCode::R => {\n    self.input.started = false;\n}\n```", "```rs\nmatch self.mode {\n    Mode::Ready => {\n        if self.input.started {\n            self.mode = Mode::Running;\n        }\n    }\n```", "```rs\nself.forward_speed = (self.forward_speed\n    + ALONG_ACCELERATION * self.period_in_sec * self.direction.cos())\n    * DRAG_FACTOR.powf(self.period_in_sec);\n```", "```rs\nself.ski_across_offset +=\n    self.forward_speed * self.period_in_sec * self.direction.sin();\n```", "```rs\nlet normal_pole = graphics::Mesh::new_circle(\n    ctx,\n    DrawMode::fill(),\n    Point2::new(0., 0.),\n    GATE_POLE_RADIUS,\n    0.05,\n    [0., 0., 1., 1.].into(),\n)?;\nlet finish_pole = graphics::Mesh::new_circle(\n    ctx,\n    DrawMode::fill(),\n    Point2::new(0., 0.),\n    GATE_POLE_RADIUS,\n    0.05,\n    [0., 1., 0., 1.].into(),\n)?;\n```", "```rs\ngraphics::draw(\n    ctx,\n    pole,\n    (Point2::new(SCREEN_WIDTH / 2\\. + gate.0, gates_along_pos),),\n)?;\n```", "```rs\nfont: Font::new(ctx, \"/font.ttf\")?,\nwhoosh_sound: audio::Source::new(ctx, \"/whoosh.ogg\")?,\n```", "```rs\nfn play_sound(sound: &mut audio::Source, volume: f32) {\n    sound.set_volume(volume);\n    let _ = sound.play_detached();\n}\n```", "```rs\nplay_sound(&mut self.bump_sound, 1.);\n```", "```rs\nplay_sound(&mut self.whoosh_sound, self.forward_speed * 0.005);\n```", "```rs\nlet text = graphics::Text::new((elapsed_shown_text, self.font, 16.0));\ngraphics::draw(ctx, &text, (Point2::new(4.0, 4.0), graphics::BLACK))?;\n```", "```rs\nlawn_image: graphics::Image,\n```", "```rs\nlawn_image: graphics::Image::new(ctx, \"/lawn.jpg\")?\n```", "```rs\ngraphics::draw(ctx, &self.lawn_image, lawn_params)?;\n```", "```rs\nenum Mode {\n    Ready,\n    Raising,\n    Lowering,\n}\n```", "```rs\nfn mouse_button_down_event(&mut self, _ctx: &mut Context,\n    button: MouseButton, x: f32, y: f32) {\n    if button == MouseButton::Left {\n        self.mouse_down_at = Some(Point2::new(x, y));\n    }\n}\n\nfn mouse_button_up_event(&mut self, _ctx: &mut Context,\n    button: MouseButton, x: f32, y: f32) {\n    if button == MouseButton::Left {\n        self.mouse_up_at = Some(Point2::new(x, y));\n    }\n}\n```", "```rs\n    mouse_down_at: Option<Point2>,\n    mouse_up_at: Option<Point2>,\n```", "```rs\nstart_time: Option<Duration>,\nactive_mole_column: usize,\nactive_mole_row: usize,\nactive_mole_position: f32,\nn_hit_moles: u32,\nrandom_generator: ThreadRng,\nstart_button: Button,\n```", "```rs\nstruct Button {\n    base_image: Rc<graphics::Image>,\n    bounding_box: Rect,\n    drawable_text: graphics::Text,\n}\n```", "```rs\nfn new(\n    ctx: &mut Context,\n    caption: &str,\n    center: Point2,\n    font: Font,\n    base_image: Rc<graphics::Image>,\n) -> Self {\n```", "```rs\nstart_button: Button::new(\n    ctx,\n    \"Start\",\n    Point2::new(600., 40.),\n    font,\n    button_image.clone(),\n),\n```", "```rs\nmouse::button_pressed(ctx, MouseButton::Left)\n```", "```rs\nrect.contains(mouse::position(ctx))\n```"]