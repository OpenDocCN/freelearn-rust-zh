<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Systems Programming Made Easy</h1>
                </header>
            
            <article>
                
<p>Rust was originally envisioned as a systems programming language in the same way as C (and maybe C++). Although its appeal led to significant growth outside this field (somewhat like C/C++), there are still many features that significantly facilitate working on low-level projects. We suspect that the novelty aspect (as well as the powerful compiler, error messages, and community) led to very interesting projects in that space—such as operating systems. One of them is intermezzOS (<a href="https://intermezzos.github.io/">https://intermezzos.github.io/</a>), an operating system for learning programming (in Rust); another is Redox OS (<a href="https://www.redox-os.org/">https://www.redox-os.org/</a>), a microkernel effort in pure Rust. However, it doesn't stop there—the Rust embedded working group has compiled a list of resources and highlight projects on their GitHub (<a href="https://github.com/rust-embedded/awesome-embedded-rust">https://github.com/rust-embedded/awesome-embedded-rust</a>).</p>
<div class="packt_infobox">Linux is the most widely adopted operating system for embedded devices, but we tried to show the principles without requiring you to run Linux. In order to fully implement, for example, an I2C device driver, <span>macOS and Windows users can use virtual machines with </span>Hyper-V (<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/">https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/</a>)<span>, </span>VirtualBox (<a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>), or<span> </span>Parallels (<a href="https://www.parallels.com/">https://www.parallels.com/</a>)<span>, or rent a machine on the cloud (<a href="https://azure.microsoft.com/en-us/">https://azure.microsoft.com/en-us/</a>). With the exception of the first recipe, the recipes in this chapter</span> work across OSes.</div>
<p>This list is truly awesome, and we are aiming to get you to a place where you can start building embedded drivers and cross-compile them to various CPU architectures. With that in mind, this chapter covers the following topics:</p>
<ul>
<li>Cross-compiling Rust</li>
<li>Implementing device drivers</li>
<li>Reading from these drivers</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compiling Rust</h1>
                </header>
            
            <article>
                
<p>Surprisingly, one of the more challenging aspects of implementing low-level projects is cross-compilation. Thanks to its LLVM underpinnings, <kbd>rustc</kbd> comes with a lot of toolchains for different CPU architectures. However, cross-compiling an application means that its (native) dependencies have to be available for this CPU architecture as well. This is challenging for small projects since it requires lots of management for versions across architectures and grows more and more complex with every added requirement. This is why there have been several tools that relate to this issue. In this recipe, we will explore at a few tools and learn how to use them. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe is highly platform-specific; at the time of writing, cross-compiling Rust on platforms other than Linux is tricky. On macOS and Windows, you can use virtual machines with <span>Hyper-V (</span><a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/">https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/</a><span>)</span><span>, </span><span>VirtualBox (</span><a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a><span>), or</span><span> </span><span>Parallels (</span><a href="https://www.parallels.com/">https://www.parallels.com/</a><span>)</span>, or rent a machine from your favorite cloud provider (<a href="https://azure.microsoft.com/en-us/">https://azure.microsoft.com/en-us/</a>). </p>
<div class="packt_infobox">The <strong>Windows Subsystem for Linux</strong> (<strong>WSL</strong>) on Windows 10 doesn't support Docker at the time of writing. <span>There might be ways around this limitation, but we will leave the required tinkering to our readers. If you find a solution, be sure to share it on our GitHub repository (<a href="https://github.com/PacktPublishing/Rust-Programming-Cookbook">https://github.com/PacktPublishing/Rust-Programming-Cookbook</a>).</span></div>
<p>Then, install Docker (<a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>) and make sure you can run Docker without <strong><kbd><span>sudo</span></kbd></strong> (<a href="https://docs.docker.com/install/linux/linux-postinstall/">https://docs.docker.com/install/linux/linux-postinstall/</a>) to proceed.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With Docker available, take these steps to cross-compile to many targets:</p>
<ol>
<li>Create a project using <kbd>cargo new cross-compile</kbd> for a binary executable and open the folder using VS Code.</li>
<li>Open <kbd>src/main.rs</kbd> and replace the default with the following:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(target_arch = "x86")]<br/>const ARCH: &amp;str = "x86";<br/><br/>#[cfg(target_arch = "x86_64")]<br/>const ARCH: &amp;str = "x64";<br/><br/>#[cfg(target_arch = "mips")]<br/>const ARCH: &amp;str = "mips";<br/><br/>#[cfg(target_arch = "powerpc")]<br/>const ARCH: &amp;str = "powerpc";<br/><br/>#[cfg(target_arch = "powerpc64")]<br/>const ARCH: &amp;str = "powerpc64";<br/><br/>#[cfg(target_arch = "arm")]<br/>const ARCH: &amp;str = "ARM";<br/><br/>#[cfg(target_arch = "aarch64")]<br/>const ARCH: &amp;str = "ARM64";<br/><br/>fn main() {<br/>    println!("Hello, world!");<br/>    println!("Compiled for {}", ARCH);<br/>}</pre>
<ol start="3">
<li>Use <kbd>cargo run</kbd> to see if it works and what architecture you are on:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling cross-compile v0.1.0 (Rust-Cookbook/Chapter09/cross-<br/>   compile)<br/>   Finished dev [unoptimized + debuginfo] target(s) in 0.25s<br/>   Running `target/debug/cross-compile`<br/>   Hello, world!<br/>   Compiled for x64</pre>
<ol start="4">
<li>Let's do some cross-compilation. First, install a tool called cross using <kbd>cargo install cross</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo install cross </strong><br/>   Updating crates.io index<br/>   Installing cross v0.1.14<br/>   Compiling libc v0.2.60<br/>   Compiling cc v1.0.38<br/>   Compiling cfg-if v0.1.9<br/>   Compiling rustc-demangle v0.1.15<br/>   Compiling semver-parser v0.7.0<br/>   Compiling rustc-serialize v0.3.24<br/>   Compiling cross v0.1.14<br/>   Compiling lazy_static v0.2.11<br/>   Compiling semver v0.9.0<br/>   Compiling semver v0.6.0<br/>   Compiling rustc_version v0.2.3<br/>   Compiling backtrace-sys v0.1.31<br/>   Compiling toml v0.2.1<br/>   Compiling backtrace v0.3.33<br/>   Compiling error-chain v0.7.2<br/>    Finished release [optimized] target(s) in 15.64s<br/>   Replacing ~/.cargo/bin/cross<br/>    Replaced package `cross v0.1.14` with `cross v0.1.14` <br/>    (executable `cross`)<br/><strong>$ cross --version</strong><br/>cross 0.1.14<br/>cargo 1.36.0 (c4fcfb725 2019-05-15)</pre>
<ol start="5">
<li>As mentioned in the <kbd>rust-cross</kbd> (<a href="https://github.com/rust-embedded/cross">https://github.com/rust-embedded/cross</a>) repository, start the Docker daemon to run a cross-build for <kbd>ARMv7</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo systemctl start docker</strong><br/><strong>$ cross build --target armv7-unknown-linux-gnueabihf -v</strong><br/>+ "rustup" "target" "list"<br/>+ "cargo" "fetch" "--manifest-path" "/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile/Cargo.toml"<br/>+ "rustc" "--print" "sysroot"<br/>+ "docker" "run" "--userns" "host" "--rm" "--user" "1000:1000" "-e" "CARGO_HOME=/cargo" "-e" "CARGO_TARGET_DIR=/target" "-e" "USER=cm" "-e" "XARGO_HOME=/xargo" "-v" "/home/cm/.xargo:/xargo" "-v" "/home/cm/.cargo:/cargo" "-v" "/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile:/project:ro" "-v" "/home/cm/.rustup/toolchains/stable-x86_64-unknown-linux-gnu:/rust:ro" "-v" "/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile/target:/target" "-w" "/project" "-it" "japaric/armv7-unknown-linux-gnueabihf:v0.1.14" "sh" "-c" "PATH=$PATH:/rust/bin \"cargo\" \"build\" \"--target\" \"armv7-unknown-linux-gnueabihf\" \"-v\""<br/>   Compiling cross-compile v0.1.0 (/project)<br/>     Running `rustc --edition=2018 --crate-name cross_compile src/main.rs --color always --crate-type bin --emit=dep-info,link -C debuginfo=2 -C metadata=a41129d8970184cc -C extra-filename=-a41129d8970184cc --out-dir /target/armv7-unknown-linux-gnueabihf/debug/deps --target armv7-unknown-linux-gnueabihf -C linker=arm-linux-gnueabihf-gcc -C incremental=/target/armv7-unknown-linux-gnueabihf/debug/incremental -L dependency=/target/armv7-unknown-linux-gnueabihf/debug/deps -L dependency=/target/debug/deps`<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.25s</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="6">
<li>If you have a Raspberry Pi 2 (or later), you can then run the binary there:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ scp target/armv7-unknown-linux-gnueabihf/debug/cross-compile alarm@10.0.0.171:~</strong><br/>cross-compile 100% 2410KB 10.5MB/s 00:00<br/><strong>$ ssh alarm@10.0.0.171</strong><br/>Welcome to Arch Linux ARM<br/><br/>     Website: http://archlinuxarm.org<br/>       Forum: http://archlinuxarm.org/forum<br/>         IRC: #archlinux-arm on irc.Freenode.net<br/>Last login: Sun Jul 28 09:07:57 2019 from 10.0.0.46<br/><strong>$ ./cross-compile </strong><br/>Hello, world!<br/>Compiled for ARM</pre>
<p>So, how does <kbd>rust-cross</kbd> compile the code? Why use Docker? Let's look at how it works.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we are creating a simple binary (<em>step 1</em> and <em>step 2</em>) with a conditional compilation that matches the target architecture in order to see if it worked. <em>Step 3</em> should show your architecture (typically <kbd>x64</kbd> or <kbd>x86_64</kbd>); we install the cross-compilation toolkit in <em>step 4</em> to try and get it to run on a Raspberry Pi 2 and above (<em>step 5</em>). After compiling the binary, we transfer it to the device (ARM binaries won't work on <kbd>x86_64</kbd> instruction sets) for execution (<em>step 6</em>). </p>
<div class="packt_infobox">QEMU, a popular virtualization framework, also supports emulating ARM instructions, so a device is not strictly required. Check out their wiki (<a href="https://wiki.qemu.org/Documentation/Platforms/ARM">https://wiki.qemu.org/Documentation/Platforms/ARM</a>) to learn more. </div>
<p>Keep reading if you are interested in more details about cross-compiling an application. If not, feel free to move on to the next recipe.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Cross-compilation is a very specific process where all of the following have to fit together:</p>
<ul>
<li>CPU instruction set, that is, assembler instructions</li>
<li>Compatible libraries for linking (for example, the standard library)</li>
<li>Binary layout</li>
<li>Compatible toolchains (compiler, linker) </li>
</ul>
<p>Thanks to LLVM's architecture and the GNU compiler collection, we do not need to worry much about the CPU instruction set since it is largely provided by default, which is also the reason why it's tricky to run on Windows. As we have seen in many recipes in <a href="ccc55197-effc-4a8a-833f-c8a5607d06d5.xhtml">Chapter 7</a>, <em>Integrating Rust with Other Languages</em>, Windows and macOS use different toolchains, which makes compiling for other CPU instruction sets trickier. Our feeling is that it's easier to work smoothly in a virtualized environment these days instead of setting everything up locally.</p>
<div class="packt_tip">If you are using Fedora or any other SELinux-enabled distribution, the cross-build may fail with a permission error. Right now, the solution is to disable SELinux (<kbd>sudo setenforce 0</kbd>), but a fix<span> </span>is underway (<a href="https://github.com/rust-embedded/cross/issues/112">https://github.com/rust-embedded/cross/issues/112</a>). </div>
<p>Considering the target toolchain,<span> </span><kbd>rustup</kbd><span> </span>allows us to quickly install other targets (<kbd>rustup target add armv7-unknown-linux-gnueabihf</kbd>), yet some other aspects (for example,<span> </span>the C standard library (<a href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a>)) still need to be natively installed. Along with the number of targets available, managing the number of native libraries is going to be a full-time job (we are disregarding the various library versions entirely here).</p>
<p>In an effort to contain these dependencies, versions, and more,<span> </span><kbd>rust-cross</kbd> (<a href="https://github.com/rust-embedded/cross#usage">https://github.com/rust-embedded/cross#usage</a>)<span> </span>(and<span> </span>others (<a href="https://github.com/dlecan/rust-crosscompiler-arm">https://github.com/dlecan/rust-crosscompiler-arm</a>)), use Docker containers that come prepared with a basic set of libraries. Typically, these containers<span> </span>can be customized (<a href="https://github.com/rust-embedded/cross#custom-docker-images">https://github.com/rust-embedded/cross#custom-docker-images</a>)<span> </span>to add any certificates, configurations, libraries, and more you need for your use case. </p>
<p>Equipped with this knowledge, we can move on to the next recipe.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating I2C device drivers</h1>
                </header>
            
            <article>
                
<p class="mce-root">Communicating with devices in Linux happens at different levels. The most basic layer of drivers is the kernel module. Among other things, these modules have unrestricted access to the operating system and, if necessary, provide access to users via interfaces such as block devices. This is where the<span> </span>I2C (<a href="https://learn.sparkfun.com/tutorials/i2c/all">https://learn.sparkfun.com/tutorials/i2c/all</a>) driver offers the as <kbd>/dev/i2c-1</kbd> <span>bus </span>(for example) that you can write to and read from. Using Rust, we can use this interface to create a driver for a sensor device that is connected to that bus. Let's see how that works.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Device drivers can be implemented in a few steps:</p>
<ol>
<li>Create a binary project:<span> </span><kbd>cargo new i2cdevice-drivers</kbd></li>
<li>Open the folder in VS Code and add some code to the <kbd>src/main.rs</kbd><span> </span>file to:</li>
</ol>
<pre style="padding-left: 60px">mod sensor;<br/><br/>use sensor::{Bmx42Device, RawI2CDeviceMock, Thermometer};<br/>use std::thread::sleep;<br/>use std::time::Duration;<br/><br/>fn main() {<br/>    let mut device = Bmx42Device::new(RawI2CDeviceMock::<br/>     new("/dev/i2c-1".into(), 0x5f)).unwrap();<br/>    let pause = Duration::from_secs(1);<br/>    loop {<br/>        println!("Current temperature {} °C", <br/>         device.temp_celsius().unwrap());<br/>        sleep(pause);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li class="mce-root">Next, we are going to implement the actual sen<span>sor driver. Create a</span> file named <kbd>src/sensor.rs</kbd> <span>to implement all aspects of the sensor driver. Let's start by setting up a few basics:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">use std::io;<br/>use rand::prelude::*;<br/><br/>pub trait Thermometer {<br/>    fn temp_celsius(&amp;mut self) -&gt; Result&lt;f32&gt;;<br/>}<br/><br/>type Result&lt;T&gt; = std::result::Result&lt;T, io::Error&gt;;</pre>
<ol start="4">
<li class="mce-root">Now, we add a mock device that represents <span>the bus system:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">#[allow(dead_code)]<br/>pub struct RawI2CDeviceMock {<br/>    path: String,<br/>    device_id: u8,<br/>}<br/><br/><br/>impl RawI2CDeviceMock {<br/>    pub fn new(path: String, device_id: u8) -&gt; RawI2CDeviceMock {<br/>        RawI2CDeviceMock {<br/>            path: path,<br/>            device_id: device_id,<br/>        }<br/>    }<br/><br/>    pub fn read(&amp;self, register: u8) -&gt; Result&lt;u8&gt; {<br/>        let register = register as usize;<br/>        if register == Register::Calib0 as usize {<br/>            Ok(1_u8)<br/>        } else { // register is the data register<br/>            Ok(random::&lt;u8&gt;())<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li class="mce-root">Next, we implement the actual sensor code that <span>the user sees:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">enum Register {<br/>    Calib0 = 0x00,<br/>    Data = 0x01,<br/>}<br/><br/>pub struct Bmx42Device {<br/>    raw: RawI2CDeviceMock,<br/>    calibration: u8,<br/>}<br/><br/>impl Bmx42Device {<br/>    pub fn new(device: RawI2CDeviceMock) -&gt; Result&lt;Bmx42Device&gt; {<br/>        let calib = device.read(Register::Calib0 as u8)?;<br/>        Ok(Bmx42Device {<br/>            raw: device,<br/>            calibration: calib<br/>        })<br/>    }<br/>}</pre>
<ol start="6">
<li class="mce-root">In order to encapsulate the behavior of the sens<span>or into a proper function, let's implement the</span> <kbd>Thermometer</kbd> <span>trait we created at the top of</span> <kbd>sensor.rs</kbd><span>. The way raw data is transformed into a usable temperature is typically stated in a manual or tech specification:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">impl Thermometer for Bmx42Device {<br/>    fn temp_celsius(&amp;mut self) -&gt; Result&lt;f32&gt; {<br/>        let raw_temp = self.raw.read(Register::Data as u8)?;<br/>        Ok(((raw_temp as i8) &lt;&lt; (self.calibration as i8)) as f32 / <br/>        10.0)<br/>    }<br/>}</pre>
<ol start="7">
<li class="mce-root">We also need to adap<span>t the</span> <kbd>Cargo.toml</kbd> <span>configuration to add the random number generator crate:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">[dependencies]<br/>rand = "0.5"</pre>
<ol start="8">
<li class="mce-root">As usual, we want to see the program in a<span>ction. Use</span> <kbd>cargo run</kbd> to see it printing what we pretend to be the temperature <span>(stop it by pressing </span><em>Ctrl + C</em><span>):</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$  cargo run</strong><br/>   Compiling libc v0.2.60<br/>   Compiling rand_core v0.4.0<br/>   Compiling rand_core v0.3.1<br/>   Compiling rand v0.5.6<br/>   Compiling i2cdevice-drivers v0.1.0 (Rust-<br/>   Cookbook/Chapter09/i2cdevice-drivers)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 2.95s<br/>     Running `target/debug/i2cdevice-drivers`<br/>Current temperature -9.4 °C<br/>Current temperature 0.8 °C<br/>Current temperature -1.2 °C<br/>Current temperature 4 °C<br/>Current temperature -3 °C<br/>Current temperature 0.4 °C<br/>Current temperature 5.4 °C<br/>Current temperature 11.6 °C<br/>Current temperature -5.8 °C<br/>Current temperature 0.6 °C<br/>^C⏎</pre>
<p>After implementing this, you are probably curious about why and how this works. Let's see. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we showed how to implement a very simple device driver that is available on a bus such as the I2C (<a href="https://learn.sparkfun.com/tutorials/i2c/all">https://learn.sparkfun.com/tutorials/i2c/all</a>). Since<span> the </span>I2C<span> </span>is a comparatively sophisticated bus (which makes implementing drivers simpler), a driver implements a protocol for reading and write operations to assumed registers and encapsulates them in a nice API. In this recipe, we did not actually use an I2C bus crate to provide the <kbd>struct</kbd> device, since it would impact OS compatibility. </p>
<p>In <em>step 2</em>, we create the main loop to read from the sensor in a very simplistic way (check the <em>Efficiently reading hardware sensors </em><span>recipe),</span> using sleep to control reading speed. In a typical fashion, we instantiate the driver by creating the block device abstraction using the *nix path (<kbd>/dev/i2c-1</kbd>) and the device's hardware address (defined by the manufacturer). </p>
<p>In <em>step 3</em>, we add some constructs to make our lives easier and better structured: the <kbd>Thermometer</kbd> trait is good practice for bundling capabilities together if there are more devices or features on that sensor. Abstracting <kbd>Result</kbd> is a common strategy for reducing code verbosity.</p>
<p>Only in <em>step 4</em> do we create a mock for the bus, providing a read and write function for single bytes. Since we are not actually reading from or writing to a bus, these functions read random numbers and write to nowhere. For an idea of how this is done in real life (for example, reading several bytes at once), check out the real <kbd>i2cdev</kbd> crate (<a href="https://github.com/rust-embedded/rust-i2cdev">https://github.com/rust-embedded/rust-i2cdev</a>). So far, we have only gotten it to work on Linux, however. </p>
<p><em>Step 5</em> creates the abstraction API. Whenever we implement a driver from scratch, we are communicating with the device by writing specific binary commands into predefined registers. This could be to change the power state of the device, to change the sampling rate, or to ask for a particular measurement (if the device has multiple sensors and triggers hardware processes on the actual device). After this write operation, we can then read a specified data registry (all of the addresses and values can be found in the device's specification) to transform the value into something usable (such as °C). This involves things such as shifting bits around, reading several calibration registries, and multiplying with overflows. Any such process varies from sensor to sensor. For a real-life example, check out the <kbd>bmp085</kbd> device driver (<a href="https://github.com/celaus/rust-bmp085">https://github.com/celaus/rust-bmp085</a>), which shows a real-world driver implementation in Rust, and watch a talk on the driver at the following URL: <a href="https://www.youtube.com/watch?v=VMaKQ8_y_6s">https://www.youtube.com/watch?v=VMaKQ8_y_6s</a>.</p>
<p>The following step then shows implementing and getting the actual temperature from the device and creating a usable number from the random number the raw device mock provides. This should be a simplification of what is typically done with raw values to get them into a usable form. </p>
<p>In the last step, we then see how it works and verify that the temperatures is generally spread nicely in realistic values, although with a frightening rate of change.</p>
<p>Let's move on and find out how we can read these sensor values more efficiently than with a pure loop.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Efficiently reading hardware sensors</h1>
                </header>
            
            <article>
                
<p class="mce-root">Creating efficient I/O-based applications is tricky—they have to provide exclusive access to a resource as quickly as possible and as often as required. It's a resource scheduling problem. The basis of solving this type of problem is to handle and queue requests, as with reading a sensor value. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You can use I/O loops to read things efficiently in a few steps:</p>
<ol>
<li>Create a binary project: <kbd>cargo new reading-hardware</kbd>.</li>
<li class="mce-root"><span>Open the folder in VS Code and create a</span> <kbd>src/sensor.rs</kbd> <span>file</span><span> </span><span>to add the code from the <em>Creating I2C device drivers</em></span> recipe<span>:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">use std::io;<br/>use rand::prelude::*;<br/><br/>type Result&lt;T&gt; = std::result::Result&lt;T, io::Error&gt;;<br/><br/>pub trait Thermometer {<br/>    fn temp_celsius(&amp;mut self) -&gt; Result&lt;f32&gt;;<br/>}<br/><br/>enum Register {<br/>    Calib0 = 0x00,<br/>    Data = 0x01,<br/>}</pre>
<ol start="3">
<li style="color: black">Typically, a raw device abstraction is provided by the hardware protocol drivers used. In our case, we mock up such a type:</li>
</ol>
<pre style="color: black;padding-left: 60px">#[allow(dead_code)]<br/>pub struct RawI2CDeviceMock {<br/>    path: String,<br/>    device_id: u8,<br/>}<br/><br/>impl RawI2CDeviceMock {<br/>    pub fn new(path: String, device_id: u8) -&gt; RawI2CDeviceMock {<br/>        RawI2CDeviceMock {<br/>            path: path,<br/>            device_id: device_id,<br/>        }<br/>    }<br/><br/>    pub fn read(&amp;self, register: u8) -&gt; Result&lt;u8&gt; {<br/>        let register = register as usize;<br/>        if register == Register::Calib0 as usize {<br/>            Ok(1_u8)<br/>        } else { // register is the data register<br/>            Ok(random::&lt;u8&gt;())<br/>        }<br/>    }<br/>}</pre>
<ol start="4">
<li style="color: black">For proper encapsulation, it's a good idea to create a <kbd>struct</kbd> that wraps the raw device:</li>
</ol>
<pre style="color: black;padding-left: 60px">pub struct Bmx42Device {<br/>    raw: RawI2CDeviceMock,<br/>    calibration: u8,<br/>}<br/><br/>impl Bmx42Device {<br/>    pub fn new(device: RawI2CDeviceMock) -&gt; Result&lt;Bmx42Device&gt; {<br/>        let calib = device.read(Register::Calib0 as u8)?;<br/>        Ok(Bmx42Device {<br/>            raw: device,<br/>            calibration: calib<br/>        })<br/>    }<br/>}</pre>
<ol start="5">
<li style="color: black">The following is the implementation of the <kbd>Thermometer</kbd> trait:</li>
</ol>
<pre style="color: black;padding-left: 60px">impl Thermometer for Bmx42Device {<br/>    fn temp_celsius(&amp;mut self) -&gt; Result&lt;f32&gt; {<br/>        let raw_temp = self.raw.read(Register::Data as u8)?;<br/>        // converts the result into something usable; from the <br/>        // specification<br/>        Ok(((raw_temp as i8) &lt;&lt; (self.calibration as i8)) as f32 / <br/>         10.0)<br/>    }<br/>}</pre>
<ol start="6">
<li class="mce-root">Now open <kbd>src/main.rs</kbd> <span>and replace the default with something more interesting. Let's start with imports and helper functions:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">mod sensor;<br/>use tokio::prelude::*;<br/>use tokio::timer::Interval;<br/><br/>use sensor::{Bmx42Device, RawI2CDeviceMock, Thermometer};<br/>use std::time::{Duration, UNIX_EPOCH, SystemTime, Instant};<br/>use std::thread;<br/><br/>use std::sync::mpsc::channel;<br/><br/>fn current_timestamp_ms() -&gt; u64 {<br/>    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()<br/>}<br/><br/>#[derive(Debug)]<br/>struct Reading {<br/>    timestamp: u64,<br/>    value: f32<br/>}</pre>
<ol start="7">
<li class="mce-root">Next, we'll add the actual event loop an<span>d the <kbd>main</kbd> function:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><br/>fn main() {<br/>    let mut device = Bmx42Device::new(RawI2CDeviceMock<br/>     ::new("/dev/i2c-1".into(), 0x5f)).unwrap();<br/><br/>    let (sx, rx) = channel();<br/><br/>    thread::spawn(move || {<br/>        while let Ok(reading) = rx.recv() {<br/><br/>            // or batch and save/send to somewhere<br/>            println!("{:?}", reading);<br/>        }<br/>    });<br/>    let task = Interval::new(Instant::now(), Duration<br/>     ::from_secs(1))<br/>        .take(5)<br/>        .for_each(move |_instant| {<br/>            let sx = sx.clone();<br/>            let temp = device.temp_celsius().unwrap();<br/>            let _ = sx.send(Reading {<br/>                timestamp: current_timestamp_ms(),<br/>                value: temp<br/>            });<br/>            Ok(())<br/>        })<br/>        .map_err(|e| panic!("interval errored; err={:?}", e));<br/><br/>    tokio::run(task);<br/>}</pre>
<ol start="8">
<li class="mce-root">For this to work, we should add som<span>e dependencies to</span> <kbd>Cargo.toml</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">[dependencies]<br/>tokio = "0.1"<br/>tokio-timer = "0.2"<br/>rand = "0.5"</pre>
<ol start="9">
<li class="mce-root">In order to finish up the recipe, we also wan<span>t to see it run and print out some mock readings:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo run</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.04s<br/>     Running `target/debug/reading-hardware`<br/>Reading { timestamp: 1564762734, value: -2.6 }<br/>Reading { timestamp: 1564762735, value: 6.6 }<br/>Reading { timestamp: 1564762736, value: -3.8 }<br/>Reading { timestamp: 1564762737, value: 11.2 }<br/>Reading { timestamp: 1564762738, value: 2.4 }</pre>
<p>Great! Let's see how this works.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Instead of the naive busy waiting loop we created in the <em>Creating I2C device drivers</em> recipe, we now use a <kbd>tokio-rs</kbd> stream (effectively an asynchronous iterator) of events on which we can register a handler. Let's see how this more efficient structure is implemented.</p>
<p>First, in <em>step 2</em>, we recreate the sensor code from the <span><em>Creating I2C device drivers</em> recipe in order to have a sensor to use. In short, the code simulates an I2C-connected temperature sensor with a random number generator to show how a bus-connected device driver operates. </span></p>
<p>In <em>step 3</em>, we are preparing to use the driver to read a value and send it to a worker thread using a channel. Therefore, we create a <kbd>Reading</kbd> struct that saves a sensor reading at a certain timestamp. Only in <em>step 4</em> do we create the <kbd>tokio-rs</kbd> task runner and a stream. This stream is a construct that represents an iterator over asynchronous events that need to be handled. Each event corresponds to a timed interval every second, starting now (<kbd>Instant::now()</kbd>), and since we don't want to run forever in this recipe, we limit the number of events to five (<kbd>.take(5)</kbd>)—just as we would with any other iterator. <kbd>tokio::run()</kbd> takes this stream and starts executing the events on its event loop and thread pool, and blocks while there is something to execute. </p>
<div class="packt_infobox">In concurrent applications, the usage of something like <kbd>std::thread::sleep</kbd> is considered an anti-pattern. Why? Because it prevents the entire thread from doing <em>anything</em> while it is sleeping. In fact, the thread pauses and the OS's CPU scheduler context-switches to do some other stuff. Only after <em>at least</em> the specified time does the scheduler rotate the thread back into active mode to continue working. Drivers sometimes require some waiting time (several milliseconds to do the measuring), and <kbd>sleep</kbd> is typically used. Since devices can only be accessed from a single thread, <kbd>sleep()</kbd> is appropriate here.</div>
<p><span>The <kbd>for_each</kbd> closure implements the handler for each event and receives an <kbd>Instant</kbd> instance as a parameter. Inside the closure, we read from the sensor and send it through a channel (</span><a href="https://doc.rust-lang.org/std/sync/mpsc/">https://doc.rust-lang.org/std/sync/mpsc/</a><span>) to a receiving thread that we created earlier—a pattern that we saw in <a href="eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml">Chapter 4</a>, <em>Fearless Concurrency</em>. While we could process the data right away in the handler, pushing it into a queue for processing enables us to create batches and minimize the stream delay. This is especially important when the potential required time to finish processing is unknown, very large (that is, it comprises web requests or other moving parts), or requires extensive error handling (such as exponential backoff (<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/retry">https://docs.microsoft.com/en-us/azure/architecture/patterns/retry</a>)). This will not only separate concerns and make maintenance easier, it also allows us to execute the reading operation more precisely. To visualize this, let's look at the big picture for <em>step 4</em>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/60ed9da9-0221-48e2-bcbe-1a2896c84324.png" style="width:29.83em;height:21.83em;"/></p>
<p>In <em>step 5</em>, we add the required dependencies, and <em>step 6</em> shows the output—take note of the timestamp to see it really does fire every second and the stream is processed in the order they appear.</p>
<p>This concludes our in-depth journey into device drivers; if this was your first foray into the field, you have now learned about de-coupling reading sensor data from processing it; how device drivers are built in the first place; and, once ready, how to get them onto the desired device. In the next chapter, we return to a higher level of abstraction and work on more practical recipes.</p>


            </article>

            
        </section>
    </div></body></html>