- en: Chapter 8. Concurrency and Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。并发与并行
- en: As a modern systems-level programming language, Rust has to have a good story
    for executing code concurrently and parallely on many processors simultaneously.
    And indeed, it does; Rust provides a wide selection of concurrency and parallel
    tools. Its type system is strong enough to write concurrent primitives that have
    properties unlike anything that existed before. Particularly, it can encode a
    wide selection of memory safe parallel abstractions that are also guaranteed to
    be data-race free while not employing a garbage collector. This is mind blowing
    as no other language can do this. All these features are not ingrained in the
    language itself, but they are provided by libraries, so improved or new versions
    can always be built. Developers should choose the tool that is right for the job
    at hand, or they can improve on or develop new tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种现代的系统级编程语言，Rust必须有一个很好的故事来描述如何在多个处理器上同时并发和并行执行代码。确实如此；Rust提供了一系列的并发和并行工具。它的类型系统足够强大，可以编写具有不同于以往任何东西的性质的并发原语。特别是，它可以编码一系列内存安全的并行抽象，同时保证数据竞争自由，而不使用垃圾回收器。这令人震惊，因为没有任何其他语言能够做到这一点。所有这些功能都不是内置于语言本身中的，而是由库提供的，因此可以始终构建改进或新版本。开发者应该选择适合当前任务的工具，或者他们可以改进或开发新的工具。
- en: 'We will discuss the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Concurrency and threads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和线程
- en: Shared mutable state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可变状态
- en: Communication through channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过通道进行通信
- en: Synchronous and asynchronous communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步和异步通信
- en: Concurrency and threads
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和线程
- en: A system is concurrent when several computations are being executed at the same
    time and are potentially interacting with each other. The computations can only
    run in parallel (that is, simultaneously) when they are being executed on different
    cores or processors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个计算同时执行并且可能相互交互时，系统是并发的。只有当这些计算在不同的核心或处理器上执行时，它们才能并行（即同时）运行。
- en: An executing Rust program consists of a collection of native operating system
    (OS) threads; the OS is also responsible for their scheduling. The unit of computation
    in Rust is called a `thread`, which is a type that is defined in the `std::thread`
    module. Each thread has its own stack and local state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在执行的Rust程序由一组原生操作系统（OS）线程组成；操作系统也负责它们的调度。Rust中的计算单元称为`thread`，这是一个在`std::thread`模块中定义的类型。每个线程都有自己的栈和局部状态。
- en: Until now, our Rust programs only had one thread, the `main` thread, corresponding
    with the execution of the `main()` function. However, a Rust program can create
    lots of threads to work simultaneously when this is needed. Each thread (not only
    `main()`) can act as a parent and generate any number of child threads.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Rust程序只有一个线程，即`main`线程，对应于`main()`函数的执行。然而，当需要时，Rust程序可以创建很多线程来同时工作。每个线程（不仅仅是`main()`）都可以作为父线程并生成任意数量的子线程。
- en: 'The following action can be done on the data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在数据上执行以下操作：
- en: It can be shared across threads (refer to the *Shared mutable state through
    atomic types* section)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在线程之间共享（参考*通过原子类型进行共享可变状态*部分）
- en: It can be sent between threads (refer to the *Communication through channels*
    section)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在线程之间传递（参考*通过通道进行通信*部分）
- en: Creating threads
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建线程
- en: 'A `thread` can be created by spawning it; this creates an independent detached
    child thread that can generally outlive its parent. This is demonstrated in the
    following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建一个`thread`来创建线程；这会创建一个独立的、分离的子线程，它通常可以比其父线程存活得更久。这在下述代码片段中得到了演示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `spawn` argument is a closure (here without parameters, so `||`), which
    is scheduled to execute independently from the parent (here, this is the `main()`)
    thread. Note that this is a moving closure, which takes ownership of the variables
    in context. Our closure here is a simple print statement, but in a real example,
    this could be replaced by a heavy and/or time-consuming operation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`参数是一个闭包（这里没有参数，所以是`||`），它被安排独立于父线程（这里，这是`main()`）执行。请注意，这是一个移动闭包，它获取上下文中的变量的所有权。我们这里的闭包是一个简单的打印语句，但在实际示例中，这可以被替换为一个重或耗时的操作。'
- en: 'However, when we execute this code, we normally don''t see any output; why
    does this happen? It turns out that `main()` is a bad parent (as far as threading
    is concerned) and doesn''t wait for its children to end properly; when the end
    of `main()` shuts down the program, it terminates other threads even if they are
    still running. The output of the spawned thread becomes visible if we let `main()`
    pause for a brief moment before it terminates. This can be done with the `thread::sleep_ms`
    method, which takes an unsigned 32-bit integer in milliseconds:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们执行这段代码时，通常不会看到任何输出；这是为什么？结果是`main()`（从线程的角度来看）是一个糟糕的父线程，它不会等待其子线程正确结束；当`main()`的结束关闭程序时，它会终止其他仍在运行的线程。如果我们让`main()`在终止前暂停一下，那么派生线程的输出就会变得可见。这可以通过`thread::sleep_ms`方法实现，该方法接受一个无符号32位整数（以毫秒为单位）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This now prints out: `Hello from the goblin in the spawned thread!`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在会打印出：`Hello from the goblin in the spawned thread!`。
- en: In general, this period of pause is not needed; children threads that are spawned
    can live longer than their parent thread and continue to execute when their parent
    has already stopped.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这个暂停期是不需要的；子线程可以比父线程存活得更久，即使父线程已经停止，子线程也可以继续执行。
- en: 'A better practice in this case, however, is to capture the join handle that
    `spawn` returns in a variable. Calling the `join()` method on `handle` will block
    the parent thread and make it wait until the child thread has finished its execution.
    It returns a `Result` instance; `unwrap()` will take the value from `Ok` and return
    the result of the child thread (which is `()` in this case because it is a print
    statement) or panic in the `Err` case:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，更好的做法是将`spawn`返回的join handle捕获到变量中。在`handle`上调用`join()`方法将阻塞父线程，并使其等待子线程完成执行。它返回一个`Result`实例；`unwrap()`将从`Ok`中获取值并返回子线程的结果（在这种情况下因为是一个打印语句，所以是`()`）或者在`Err`情况下panic。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If no other work has to be done while the child thread is executing, we can
    also write this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在子线程执行期间没有其他工作要做，我们也可以这样写：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we are waiting synchronously for the child thread to finish, so
    there is no good reason to start a new thread.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在同步等待子线程完成，所以没有很好的理由去启动一个新的线程。
- en: Starting a number of threads
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动一定数量的线程
- en: 'Each thread has its own stack and local state, and by default, no data is shared
    between threads unless it is immutable data. Generating threads is a very lightweight
    process since starting tens of thousands of threads only takes a few seconds.
    The following program does just that and prints out the numbers from 0 to 9,999:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的堆栈和局部状态，默认情况下，除非是不可变数据，否则线程之间不共享任何数据。生成线程是一个非常轻量级的过程，因为启动成千上万的线程只需要几秒钟。以下程序就是这样做的，并打印出从0到9,999的数字：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since the numbers are printed in independent threads, the order is not preserved
    in the output; so, for example, it could start with:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数字是在独立的线程中打印的，所以输出中的顺序是不保留的；例如，它可能以以下内容开始：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A question that often arises is: how many threads do I have to spawn? The basic
    rule is that CPU-intensive tasks have the same number of threads as CPU cores.
    This number can be retrieved in Rust by using the `num_cpus` crate. Let''s make
    a new project with `cargo new many_threads --bin`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 常常出现的一个问题是：我需要派生多少个线程？基本规则是，CPU密集型任务的数量与CPU核心的数量相同。这个数字可以通过Rust中的`num_cpus`
    crate来检索。让我们用`cargo new many_threads --bin`创建一个新的项目：
- en: 'Add the crate dependency to `Cargo.toml`:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将crate依赖添加到`Cargo.toml`中：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, change `main.rs` to the following code:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将`main.rs`更改为以下代码：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From within the `many_threads` folder, do a cargo build to install the crate
    and compile the code. Executing the program with cargo run gives the following
    output (dependent on the computer): `The number of cpus in this machine is: 8`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`many_threads`文件夹内，执行cargo build来安装crate并编译代码。使用cargo run执行程序会得到以下输出（取决于计算机）：`The
    number of cpus in this machine is: 8`。'
- en: 'Now, you can start this (or any other) number of threads in a pool. This functionality
    is provided by the `threadpool` crate, which we can get by adding the `threadpool
    = "*"` to the `Cargo.toml` dependency and doing a cargo build. Add the following
    code to the start of the file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在一个池中启动这个（或任何其他）数量的线程。这个功能是由`threadpool` crate提供的，我们可以通过在`Cargo.toml`依赖中添加`threadpool
    = "*"`并执行cargo build来获取它。将以下代码添加到文件的开头：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And, this code to the `main()` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到`main()`函数中：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When executed, the preceding code yields the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述代码时，会得到以下输出：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A thread pool is used for running a number of jobs on a fixed set of parallel
    worker threads; it creates the given number of worker threads and replenishes
    the pool if any thread panics.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池用于在固定的一组并行工作线程上运行多个作业；它创建指定数量的工作线程，并在任何线程崩溃时补充线程池。
- en: Panicking threads
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 崩溃的线程
- en: 'What happens when one of the spawned threads gets into a panic? This causes
    no problem as the threads are isolated from each other; only the panicking thread
    will crash after it frees its resources, but the parent thread is not affected.
    In fact, the parent can test the `is_err` return value from spawn as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个生成的线程进入崩溃状态时会发生什么？由于线程彼此隔离，这不会造成任何问题；崩溃的线程在释放其资源后会崩溃，但父线程不受影响。事实上，父线程可以像以下这样测试spawn的`is_err`返回值：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code prints out:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出如下：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Otherwise, to put it another way, the thread is the unit of failure isolation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，换句话说，线程是失败隔离的单位。
- en: Thread-safety
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全性
- en: 'Traditional programming with threads is very difficult to get right if you
    allow the different threads to work on the same mutable data, the so-called shared
    memory. When two or more threads simultaneously change data, then data corruption
    (also called data racing) can occur due to the unpredictability of the threads''
    scheduling. In general, data (or a type) is said to be thread-safe when its contents
    will not be corrupted by the execution of different threads. Other languages offer
    no such help, but the Rust compiler simply forbids non thread-safe situations
    to occur. The same ownership strategy that pervades Rust to prevent memory safety
    errors also makes you write safe concurrent programs. Consider the following program:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许不同的线程在相同的可变数据上工作，即所谓的共享内存，那么使用线程的传统编程非常难以正确实现。当两个或更多线程同时更改数据时，由于线程调度的不可预测性，可能会发生数据损坏（也称为数据竞态）。一般来说，当其内容不会被不同线程的执行所损坏时，数据（或类型）被认为是线程安全的。其他语言没有提供这样的帮助，但Rust编译器简单地禁止出现非线程安全的情况。贯穿Rust以防止内存安全错误的相同所有权策略也使你能够编写安全的并发程序。考虑以下程序：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our initial `health` is 12, but there are 3 fairies who can double, triple,
    and quadruple our health. We let each of them do this in a different thread, and
    after the threads are finished, we expect a `health` of 288 (which equates to
    12 * 2 * 3 * 4). However, after their magical actions, our `health` is still at
    12, even if we wait long enough to ensure that the threads are finished. Clearly,
    the three threads worked on a copy of our variable and not on the variable itself.
    Rust does not allow the `health` variable to be shared among the threads to prevent
    data corruption. In the next section, we will explore how we can use mutable variables
    that are shared between threads.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始的`健康值`是12，但有3个仙女可以将我们的健康值翻倍、三倍和四倍。我们让她们各自在不同的线程中这样做，线程完成后，我们期望`健康值`达到288（相当于12
    * 2 * 3 * 4）。然而，在她们神奇的行动之后，我们的`健康值`仍然保持在12，即使我们等待足够长的时间以确保线程完成。显然，三个线程是在我们的变量副本上工作，而不是在变量本身上。Rust不允许`健康值`变量在线程间共享，以防止数据损坏。在下一节中，我们将探讨如何使用线程间共享的可变变量。
- en: The shared mutable state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享可变状态
- en: So, how can we make the `not_shared.rs` program give us the correct result?
    Rust provides tools, the so-called atomic types from the `std::sync::atomic` submodule,
    to handle shared mutable state safely. In order to share data, you need to wrap
    the data in some of the sync primitives, such as `Arc`, `Mutex`, `RwLock`, `AtomicUSize`,
    and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何让`not_shared.rs`程序给出正确的结果？Rust提供了工具，即所谓的原子类型，来自`std::sync::atomic`子模块，以安全地处理共享可变状态。为了共享数据，你需要将数据包裹在一些同步原语中，例如`Arc`、`Mutex`、`RwLock`、`AtomicUSize`等等。
- en: 'Basically, the principle of locking is used, which is similar to that used
    by operating systems and database systems—exclusive access to a resource is given
    to the thread that has obtained a lock (which is also called a `mutex` and comes
    from mutually exclusive) on the resource. A lock can only be obtained by one thread
    at a time. In this way, two threads cannot change this resource at the same time,
    so no data races can occur; locking atomicity is enforced when required. When
    the thread that has acquired the lock has done its work, the lock is removed and
    another thread can then work with the data. In Rust, this is done with the generic
    `Mutex<T>` type from the `std::sync` module; `sync` comes from synchronize, which
    is exactly what we want to do with our threads. The `Mutex` ensures that only
    one thread can change the contents of our data at a time. We must make an instance
    of this type by wrapping our data as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里使用的是锁定原理，这与操作系统和数据库系统中使用的原理类似——将资源的独占访问权赋予已获得锁的线程（该锁也称为`mutex`，来源于互斥）。一次只能由一个线程获得锁。这样，两个线程就不能同时更改这个资源，因此不会发生数据竞争；当需要时，强制执行锁定原子性。当获得锁的线程完成其工作后，锁被移除，然后另一个线程可以与数据一起工作。在Rust中，这是通过`std::sync`模块中的泛型`Mutex<T>`类型来实现的；`sync`来源于synchronize，这正是我们想要对线程所做的事情。`Mutex`确保一次只有一个线程可以更改我们数据的内部内容。我们必须通过以下方式创建此类型的实例，将我们的数据包装起来：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, within the `for` loop, immediately after we spawn the new thread, we place
    a lock on the `health` object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`for`循环中，在我们创建新线程后立即，我们对`health`对象施加锁：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The call to `lock()` will return a reference to the value inside the `Mutex`
    and block any other calls to `lock()` until that reference goes out of scope,
    which will happen at the end of the thread closure. Then, the thread does its
    work and the lock is automatically removed. However, we still get an error: `capture
    of moved value: ''data''` message. This means that data cannot be moved to another
    thread multiple times.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对`lock()`的调用将返回`Mutex`内部值的引用，并阻止对`lock()`的任何其他调用，直到该引用超出作用域，这将在线程关闭结束时发生。然后，线程完成其工作，锁自动移除。然而，我们仍然得到一个错误：`捕获已移动值：'data'`消息。这意味着数据不能多次移动到另一个线程。
- en: 'This problem can be solved by using an equivalent of the `Rc` pointer from
    the *Reference counting* section of [Chapter 6](part0056.xhtml#aid-1LCVG2 "Chapter 6. Pointers
    and Memory Safety"), *Pointers and Memory Safety*. Indeed, the situation here
    is very similar; all the threads need a reference to the same data, which is our
    health variable. So, we apply the same techniques from [Chapter 6](part0056.xhtml#aid-1LCVG2
    "Chapter 6. Pointers and Memory Safety"), *Pointers and Memory Safety* here—we
    make an `Rc` pointer to our data, and then we make a `clone()` of the pointer
    for each reference that is needed. However, a simple `Rc` pointer is not thread-safe;
    therefore, we need a special version of it that is thread-safe, the so called
    atomic reference counted pointer or `Arc<T>`. Atomic means that it is safe across
    threads, and it is also generic. So, we envelop our health variable inside an
    `Arc` pointer as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题可以通过使用[第6章](part0056.xhtml#aid-1LCVG2 "第6章。指针和内存安全")中*引用计数*部分的`Rc`指针来解决，*指针和内存安全*。实际上，这里的情况非常相似；所有线程都需要对同一数据的引用，即我们的健康变量。因此，我们在[第6章](part0056.xhtml#aid-1LCVG2
    "第6章。指针和内存安全")中应用了相同的技巧，*指针和内存安全*——我们为我们的数据创建一个`Rc`指针，然后为每个需要的引用创建指针的`clone()`。然而，简单的`Rc`指针不是线程安全的；因此，我们需要一个特殊的版本，即线程安全的版本，所谓的原子引用计数指针或`Arc<T>`。原子意味着它在线程之间是安全的，它也是泛型的。因此，我们将健康变量包裹在一个`Arc`指针中，如下所示：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And, in the `for` loop, we make a new pointer to the `Mutex` with `clone`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`for`循环中，我们使用`clone`创建一个新的指向`Mutex`的指针：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, each thread now works with a copy of the pointer obtained by `clone()`.
    The `Arc` instance will keep track of the number of references to `health`. A
    call to `clone()` will increment the reference count on health. The `mutex` reference
    goes out of scope at the end of the thread closure, which will decrement the reference
    count. `Arc` will free the associated health resource when that reference count
    becomes zero.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个线程现在都使用通过`clone()`获得的指针副本工作。`Arc`实例将跟踪对`health`的引用数量。对`clone()`的调用将增加对健康引用的计数。`mutex`引用在线程关闭结束时超出作用域，这将减少引用计数。当引用计数变为零时，`Arc`将释放相关的健康资源。
- en: Calling `lock()` gives the active thread exclusive access to the data. In principle,
    acquiring the lock might fail, so it returns a `Result<T, E>` object. In the preceding
    code, we assume that everything is okay. The `unwrap()` function is a quick means
    to return a reference to the data, but in the case of a failure, it panics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `lock()` 给活动线程提供对数据的独占访问。原则上，获取锁可能会失败，因此它返回一个 `Result<T, E>` 对象。在上面的代码中，我们假设一切正常。`unwrap()`
    函数是一种快速返回数据引用的方法，但在失败的情况下，它会引发恐慌。
- en: 'Quite a few steps were involved here. So, we will repeat the code in its entirety
    again, but this time, we will provide robust error handling by replacing `unwrap()`.
    Digest each line with the explanations explained earlier:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及了相当多的步骤。因此，我们将再次完整地重复代码，但这次，我们将通过替换 `unwrap()` 提供健壮的错误处理。用前面解释的解释消化每一行：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This prints out:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '( 288 is indeed equal to 12 * 2 * 3 * 4 ). We join the threads to give them
    time to do their work; data is a reference, so we need to dereference it to obtain
    the `health` value:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ( 288 确实等于 12 * 2 * 3 * 4 ). 我们将线程连接起来，以便它们有时间完成工作；数据是一个引用，因此我们需要取消引用它以获取 `health`
    值：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mechanism outlined in the preceding section using a combined `Mutex` and
    `Arc` is advisable when the shared data occupies a significant amount of memory;
    this is because with an `Arc`, the data will no longer be copied for each thread.
    The `Arc` acts as a reference to the shared data and only this reference is shared
    and cloned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分中概述的机制，使用组合的 `Mutex` 和 `Arc`，当共享数据占用大量内存时是可取的；这是因为有了 `Arc`，数据将不再为每个线程复制。`Arc`
    作为共享数据的引用，并且只有这个引用被共享和克隆。
- en: The Sync trait
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步特性
- en: An `Arc<T>` object implements the `Sync` trait (while `Rc` does not), which
    indicates to the compiler that it is safe to use concurrently with multiple threads.
    Any data that has to be shared simultaneously among threads must implement the
    `Sync` trait. A `T` type is `Sync` if there is no possibility of data races when
    the `&T` references are passed between threads; in short `&T` is thread-safe.
    All simple types such as the integer and floating point types are `Sync`, as well
    as all composite types (such as structs, enums, and tuples) built with simple
    types; any type that only contains things that implement `Sync` is automatically
    `Sync`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc<T>` 对象实现了 `Sync` 特性（而 `Rc` 则没有），这向编译器表明它可以安全地在多个线程中并发使用。任何必须同时在多个线程之间共享的数据都必须实现
    `Sync` 特性。如果 `&T` 引用在线程之间传递时没有数据竞争的可能性，则 `T` 类型是 `Sync` 的；简而言之，`&T` 是线程安全的。所有简单类型，如整数和浮点数类型，以及所有由简单类型构建的复合类型（如结构体、枚举和元组）都是
    `Sync`，任何只包含实现 `Sync` 的东西的类型都是自动 `Sync`。'
- en: Communication through channels
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过通道进行通信
- en: 'Data can also be exchanged between threads by passing messages among them.
    This is implemented in Rust by channels, which are like unidirectional pipes that
    connect two threads—data is processed first-in, first-out. Data flows over this
    channel between two end-points, from the `Sender<T>` to the `Receiver<T>`; both
    are generic and take the `T` type of the message to transfer (which obviously
    must be the same for the `Sender` and `Receiver` channels). In this mechanism,
    a copy of the data to be shared is made for the receiving thread, so you shouldn''t
    use this for very large data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以通过在它们之间传递消息在线程之间交换。在 Rust 中，这是通过通道实现的，通道就像连接两个线程的单向管道——数据是先入先出处理的。数据在这两个端点之间通过这个通道流动，从
    `Sender<T>` 到 `Receiver<T>`；两者都是泛型，并接受要传输的消息的 `T` 类型（显然，对于 `Sender` 和 `Receiver`
    通道必须是相同的）。在这个机制中，为接收线程创建要共享的数据的副本，因此你不应该用它来传输非常大的数据：
- en: '![Communication through channels](img/image00184.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![通过通道进行通信](img/image00184.jpeg)'
- en: 'To create a channel, we need to import the `mpsc` submodule from `std::sync`
    (`mpsc` stands for **multi-producer, single-consumer communication** **primitives**)
    and then use the `channel()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个通道，我们需要从 `std::sync` 模块导入 `mpsc` 子模块（`mpsc` 代表 **多生产者，单消费者通信** 原语）然后使用
    `channel()` 方法：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This creates a tuple of endpoints; `tx` (`t` from transmission) is the `Sender`
    and `rx` (`r` from receiver) is the `Receiver`. We have indicated that we will
    send `i32` integers over the channel, but the type annotations are not needed
    if the compiler can deduce the channel's data type from the rest of the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个端点元组；`tx`（来自传输的 `t`）是 `Sender`，`rx`（来自接收器的 `r`）是 `Receiver`。我们已经指出，我们将通过通道发送
    `i32` 整数，但如果编译器可以从代码的其余部分推断出通道的数据类型，则不需要类型注解。
- en: Sending and receiving data
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送和接收数据
- en: 'So, which data types can be sent over a channel? Rust imposes the requirement
    that data to be sent over a channel must implement the `Send` trait, which guarantees
    the safe transfer of ownership between threads. Data that does not implement `Send`
    cannot leave the current thread. An `i32` is `Send` because we can make a copy,
    so let''s do that in the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪些数据类型可以通过通道发送？Rust 强制要求要发送到通道的数据必须实现 `Send` 特性，这保证了线程之间安全地转移所有权。没有实现 `Send`
    的数据不能离开当前线程。`i32` 是 `Send` 的，因为我们可以复制它，所以让我们在下面的代码片段中这样做：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This, of course, prints `10`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会打印 `10`。
- en: 'Here, `tx` is moved inside the closure. A better way to write `tx.send(10).unwrap()`
    is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tx` 被移动到了闭包内部。更好的写法是 `tx.send(10).unwrap()`，如下所示：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will ensure that, in case of a problem, a message is sent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在出现问题时，会发送一条消息。
- en: 'The `send()` is executed by the child thread; it queues a message (a data value;
    here, it is 10) in the channel and does not block. The `recv()` is done by the
    parent thread; it picks a message from the channel and blocks the current thread
    if there are no messages available. (If you need to do this in a non-blocking
    fashion, use `try_recv()`.) If you don''t process the received value, this blocking
    can be written as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 是由子线程执行的；它在通道中排队一个消息（一个数据值；这里，它是 10），并且不会阻塞。`recv()` 是由父线程执行的；它从通道中选取一个消息，如果没有消息可用，它会阻塞当前线程。（如果你需要以非阻塞的方式执行此操作，请使用
    `try_recv()`。）如果你不处理接收到的值，这种阻塞可以写成如下：'
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `send()` and `recv()` operations return a `Result`, which can be of the
    `Ok(value)` type or an `Err` error. Full error-handling is omitted here because
    in the case of `Err`, the channel does not work anymore, and it is better for
    the thread to fail (panic) and stop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 和 `recv()` 操作返回一个 `Result`，可以是 `Ok(value)` 类型或 `Err` 错误。这里省略了完整的错误处理，因为在
    `Err` 的情况下，通道不再工作，并且线程失败（panic）并停止更好。'
- en: 'In a general scenario, we could make a child thread execute a long computation
    and then receive the result in the parent thread as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般场景中，我们可以让子线程执行长时间的计算，然后在父线程中接收结果，如下所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `result` function here has the `Ok(1)` value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `result` 函数具有 `Ok(1)` 的值。
- en: 'An elegant code pattern is shown in the following code snippet where the channel
    is created in a `make_chan()` function, which returns the receiving endpoint for
    the calling code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，展示了优雅的代码模式，其中通道是在 `make_chan()` 函数中创建的，该函数返回调用代码的接收端点：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This prints out: `received message 7`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：`received message 7`。
- en: 'Perform the following exercise:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Construct a `shared_channel.rs` program that lets any number of threads share
    a channel to send in a value and has one receiver that collects all the values.
    As a hint, use `clone()` to give each thread access to the sending `tx` endpoint.
    (Refer to the example code in `Chapter 8/exercises/shared_channel.rs`.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 `shared_channel.rs` 程序，允许任意数量的线程共享一个通道来发送值，并有一个接收器收集所有值。作为一个提示，使用 `clone()`
    给每个线程提供对发送 `tx` 端点的访问。（参考第 8 章的示例代码 `shared_channel.rs`。）
- en: Synchronous and asynchronous communication
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和异步通信
- en: 'The kind of sending channel we used until now is asynchronous; this means that
    it does not block the executing code. Rust also has a synchronous channel type
    called `sync_channel` where the `send()` blocks if its internal buffer becomes
    full—it waits until the parent thread starts receiving the data. In the following
    code, this type of channel is used to send a value of the `Msg` struct over the
    channel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的发送通道是异步的；这意味着它不会阻塞执行代码。Rust 还有一个名为 `sync_channel` 的同步通道类型，其中如果其内部缓冲区已满，`send()`
    会阻塞——它等待父线程开始接收数据。在下面的代码中，这种类型的通道被用来通过通道发送 `Msg` 结构体的值：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Which prints:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, after 3 seconds, prints:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，3秒后，打印：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This clearly shows that the second message could only be sent when the buffer
    was emptied by receiving the first message.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，只有在缓冲区被接收第一条消息清空后，才能发送第二条消息。
- en: 'Perform the following exercise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Explain what happens when the second message is also sent from within the main
    thread and not in a separate thread.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解释当第二个消息也从主线程内部发送而不是在单独的线程中发送时会发生什么。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Rust's lightweight thread processes—how to create
    them, how to let them share data, and how to let them pass data through channels.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Rust 的轻量级线程进程——如何创建它们，如何让它们共享数据，以及如何让它们通过通道传递数据。
- en: In the following chapter, we will have a look at the boundaries—we will see
    how a Rust program can take arguments to work with them. We will also examine
    what we have to do in Rust when we go to so such a low level that the compiler
    cannot guarantee safety anymore and how we can interface with other languages
    such as C.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨边界问题——我们将了解Rust程序如何接受参数并与之交互。我们还将探讨在Rust中，当我们达到如此低级以至于编译器无法保证安全性的情况下，我们需要做什么，以及我们如何与其他语言如C进行接口交互。
