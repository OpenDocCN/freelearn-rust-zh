<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Cargo and Crates</h1>
                </header>
            
            <article>
                
<p>Rust is a rather young language that has been designed from scratch to be a practical and useful tool for programmers. This is a great situation to be in: there are no legacy applications to care about, and many lessons learned from other languages have been incorporated in Rust—especially around tooling.</p>
<p>Integrating and managing third-party packages has been an issue in the past for a lot of languages, and there are a few different approaches out there:</p>
<ul>
<li><strong>NPM</strong>: The package manager for <span>Node</span>, which has been very popular with the JavaScript community</li>
<li><strong>Maven</strong>: Enterprise-grade Java package management, based on the XML format</li>
<li><strong>NuGet</strong>: .NET's package management</li>
<li><strong>PyPI</strong>: The Python package index</li>
</ul>
<p>Each of these has different styles of configuration, naming guidelines, publishing infrastructure, features, plugins, and so on. The Rust team learned from all of these approaches and built their own version: <kbd>cargo</kbd><span>. This chapter will be all about the power of</span> <kbd>cargo</kbd> <span>of how and where to integrate with the wealth of packages (called crates) out there. Whether you are working on your own small library or you are building a large enterprise-grade system,</span> <kbd>cargo</kbd> <span>will be a central piece of the project. By reading this chapter, you can look forward to the following:</span></p>
<ul>
<li>Learning more about <kbd>cargo</kbd>, its configuration, and plugins</li>
<li>Knowing more about the different types of crates</li>
<li>Benchmarking and test integration done in <kbd>cargo</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cargo</h1>
                </header>
            
            <article>
                
<p>The basic Rust tooling is composed of three programs:</p>
<ul>
<li><kbd>cargo</kbd>: The Rust package manager</li>
<li><kbd>rustc</kbd>: The Rust compiler</li>
<li><kbd>rustup</kbd>: The Rust toolchain manager</li>
</ul>
<p>Most users will never touch (or even see) <kbd>rustc</kbd> directly, but will usually use <kbd>rustup</kbd> to install it and then let <kbd>cargo</kbd> orchestrate the compilation<span>.</span></p>
<p>Running <kbd>cargo</kbd> without any arguments reveals the subcommands it provides:</p>
<pre><span><strong>$ cargo</strong><br/><strong>Rust's package manager </strong><br/> <br/><strong>USAGE: </strong><br/><strong> cargo [OPTIONS] [SUBCOMMAND] </strong><br/> <br/><strong>OPTIONS: </strong><br/><strong>    -V, --version           Print version info and exit </strong><br/><strong>        --list              List installed commands </strong><br/><strong>        --explain &lt;CODE&gt;    Run `rustc --explain CODE` </strong><br/><strong>    -v, --verbose           Use verbose output (-vv very verbose/build.rs output) </strong><br/><strong>    -q, --quiet             No output printed to stdout </strong><br/><strong>        --color &lt;WHEN&gt;      Coloring: auto, always, never </strong><br/><strong>        --frozen            Require Cargo.lock and cache are up to date </strong><br/><strong>        --locked            Require Cargo.lock is up to date </strong><br/><strong>    -Z &lt;FLAG&gt;...            Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details </strong><br/><strong>    -h, --help              Prints help information </strong><br/> <br/><strong>Some common cargo commands are (see all commands with --list): </strong><br/><strong>    build       Compile the current project </strong><br/><strong>    check       Analyze the current project and report errors, but don't build object files </strong><br/><strong>    clean       Remove the target directory </strong><br/><strong>    doc         Build this project's and its dependencies' documentation </strong><br/><strong>    new         Create a new cargo project </strong><br/><strong>    init        Create a new cargo project in an existing directory </strong><br/><strong>    run         Build and execute src/main.rs </strong><br/><strong>    test        Run the tests </strong><br/><strong>    bench       Run the benchmarks </strong><br/><strong>    update      Update dependencies listed in Cargo.lock </strong><br/><strong>    search      Search registry for crates </strong><br/><strong>    publish     Package and upload this project to the registry </strong><br/><strong>    install     Install a Rust binary </strong><br/><strong>    uninstall   Uninstall a Rust binary</strong> </span></pre>
<p>There are a few clues here as to what the package manager can do. Other than resolving different types of dependencies for projects, it acts as a test runner for benchmarks and unit/integration tests, and provides access to registries such as <kbd>crates.io</kbd> (<a href="https://crates.io/">https://crates.io/</a>). Many of these properties can be configured in a <kbd>.cargo/config</kbd> file in the TOML (<a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>) syntax, either in your home directory, the project directory, or the hierarchy in between.</p>
<p>The individual properties that can be configured can easily evolve over time, so we'll focus on some core parts.</p>
<p><strong>Local repositories</strong> can be customized with a <kbd>paths</kbd> property (an array of paths) in the root section of the file, whereas any command-line arguments for the <kbd>cargo new</kbd> command can be found in the <kbd>[cargo-new]</kbd> section of the file. If these custom repositories are remote, this can be configured in <kbd>[registry]</kbd> and <kbd>[http]</kbd> for the <kbd>proxy</kbd> address and port, custom certificate authority (<kbd>cainfo</kbd>), or high latencies (<kbd>timeout</kbd>) .</p>
<p>These are handy configurations for enterprise systems with private repositories, or CI builds with shared drives acting as caches. However, there are options to <strong>customize the toolchain</strong>, by letting the user provide some configuration in a <kbd>[target.$triple]</kbd> section (for example, <kbd>[target.wasm32-unknown-unknown]</kbd> to customize a Wasm target). Each of those sections contains the following properties:</p>
<ul>
<li>A <kbd>linker</kbd> specific to the selected triple</li>
<li>Another archiver by customizing <kbd>ar</kbd></li>
<li>A <kbd>runner</kbd> for running the program and associated tests</li>
<li>Flags for the compiler in <kbd>rustflags</kbd></li>
</ul>
<p>Lastly, the <strong>build configuration</strong> is set within the <kbd>[build]</kbd> section, where the number of <kbd>jobs</kbd>, binaries, such as <kbd>rustc</kbd> or <kbd>rustdoc</kbd>, the <kbd>target</kbd> triple, <kbd>rustflags</kbd>, or <kbd>incremental</kbd> compilation can be set. To learn more about configuring <kbd>cargo</kbd> and to obtain a sample of this configuration, go to <a href="https://doc.rust-lang.org/cargo/reference/config.html">https://doc.rust-lang.org/cargo/reference/config.html</a>.</p>
<p>In the next sections, we are going to explore the core of <kbd>cargo</kbd>: the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project configuration</h1>
                </header>
            
            <article>
                
<p>In order to recognize a Rust project, <kbd>cargo</kbd> requires its manifest to be present, where most of the other aspects (metadata, source code location, and so on) can be configured. Once this has been done, building the project will create another file: <kbd>Cargo.lock</kbd>. This file contains the dependency tree of a project with library versions and locations in order to speed up future builds. Both of these files are essential to a Rust project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The manifest – Cargo.toml</h1>
                </header>
            
            <article>
                
<p>The <kbd>Cargo.toml</kbd> file follows—as the name suggests—the TOML structure. It's handwritten and contains metadata about the project as well as dependencies, links to other resources, build profiles, examples, and much more. Most of them are optional and have reasonable defaults. In fact, the <kbd>cargo new</kbd> command generates the minimal version of a manifest:</p>
<div>
<pre>[package]<br/>name = "ch2"<br/>version = "0.1.0"<br/>authors = ["Claus Matzinger"]<br/>edition = "2018"<br/><br/>[dependencies]</pre></div>
<p>There are many more sections and properties, and we will present a few important ones here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Package</h1>
                </header>
            
            <article>
                
<p>This manifest section is all about metadata for the package, such as name, version, and authors, but also a link to the documentation that defaults to the corresponding page (<a href="https://docs.rs/">https://docs.rs/</a>). While many of these fields are there to support <kbd>crates.io</kbd> and display various indicators (categories, badges, repository, homepage, and so on), some fields should be filled regardless of whether they are published there, such as license (especially with open source projects).</p>
<p>Another interesting section is the metadata table in <kbd>package.metadata</kbd>, because it's ignored by <kbd>cargo</kbd>. This means that projects can store their own data in the manifest for project- or publishing-related properties—for example, for publishing on Android's Google Play Store, or information to generate Linux packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiles</h1>
                </header>
            
            <article>
                
<p>When you run <kbd>cargo build</kbd>, <kbd>cargo build --release</kbd>, or <kbd>cargo test</kbd>, <kbd>cargo</kbd> uses profiles to determine individual settings for each stage. While these have reasonable defaults, you might want to customize some settings. The manifest provides these switches with the <kbd>[profile.dev]</kbd>, <kbd>[profile.release]</kbd>, <kbd>[profile.test]</kbd>, and <kbd>[profile.bench]</kbd> sections:</p>
<pre><span class="hljs-section">[profile.release]</span><span> <br/></span><span class="hljs-attr">opt-level</span><span> = </span><span class="hljs-number">3</span><span> <br/></span><span class="hljs-attr">debug</span><span> = </span><span class="hljs-literal">false</span><span> <br/></span><span class="hljs-attr">rpath</span><span> = </span><span class="hljs-literal">false</span><span> <br/></span><span class="hljs-attr">lto</span><span> = </span><span class="hljs-literal">false</span><span> <br/></span><span class="hljs-attr">debug-assertions</span><span> = </span><span class="hljs-literal">false</span><span> <br/></span><span class="hljs-attr">codegen-units</span><span> = </span><span class="hljs-number">16</span><span> <br/></span><span class="hljs-attr">panic</span><span> = </span><span class="hljs-string">'unwind'</span><span> <br/></span><span class="hljs-attr">incremental</span><span> = </span><span class="hljs-literal">false</span><span> <br/></span><span class="hljs-attr">overflow-checks</span><span> = </span><span class="hljs-literal">false</span></pre>
<p>These values are the defaults (as of writing this book) and are already useful for most users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article>
                
<p>This is probably the most important section for most developers. The dependencies section contains a list of values that represent crate names on <kbd>crates.io</kbd> (or your configured private registry) as keys along with the version as values.</p>
<p>Instead of the version string, it's equally possible to provide an inline table as a value that specifies optionality or other fields:</p>
<pre><span class="hljs-attr">[dependencies]<br/></span><span class="hljs-attr">hyper</span><span> = </span><span class="hljs-string">"*"</span><span class="hljs-attr"><br/>rand</span><span> = { version = </span><span class="hljs-string">"0.5"</span><span>, optional = </span><span class="hljs-literal">true</span><span> } </span></pre>
<p>Interestingly, since this is an object, TOML allows us to use it like a section:</p>
<pre><span class="hljs-attr">[dependencies]<br/>hyper</span><span> = </span><span class="hljs-string">"*"</span><span><br/><br/>[dependencies.rand]</span><span class="hljs-attr"><br/></span><span>version = </span><span class="hljs-string">"0.5"<br/></span><span>features = </span><span class="hljs-literal">["stdweb"]</span><span> </span><span> </span></pre>
<p>Since, in the 2018 edition, the <kbd>extern</kbd> crate declarations inside the <kbd>.rs</kbd> files are optional, renaming a dependency can be done inside the <kbd>Cargo.toml</kbd> specification by using the <kbd>package</kbd> property. Then, the specified key can become an alias for this <kbd>package</kbd>, like this:</p>
<pre><span class="hljs-attr">[dependencies]<br/># import in Rust with "use web::*"<br/>web</span><span> = { version = </span><span class="hljs-string">"*", package = "hyper" }</span><span><br/><br/>[dependencies.random] # import in Rust with "use random::*" </span><span class="hljs-attr"><br/></span><span>version = </span><span class="hljs-string">"0.5"<br/>package = "rand"<br/></span><span>features = </span><span class="hljs-literal">["stdweb"]</span><span> </span></pre>
<p>Features are crate-specific strings that include or exclude certain features. In the case of rand (and some others), <kbd>stdweb</kbd> is a feature that allows us to use the crate in Wasm scenarios by leaving out things that would not compile otherwise. Note that these features might be automatically applied when they depend on toolchains.</p>
<p>Something that needs to be specified via those objects is the dependence on a remote Git repository or local path. This is useful for testing a patched version of a library locally without publishing it to <kbd>crates.io</kbd> (<a href="https://crates.io/">https://crates.io/</a>) and having it built by <kbd>cargo</kbd> during the parent's build phase:</p>
<pre><span class="hljs-section">[dependencies]</span><span> <br/></span>hyper = "*"<br/>rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "0.4" }</pre>
<p>Specifying versions with <kbd>cargo</kbd> follows a pattern too. Since any crate is encouraged to follow a semantic versioning scheme (<kbd>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</kbd>), there are operators that include or exclude certain versions (and thereby APIs). For <kbd>cargo</kbd>, those operators are as follows:</p>
<ul>
<li><strong>Tilde</strong> (<kbd>~</kbd>): Only patch increases are allowed.</li>
<li><strong>Caret</strong> (<kbd>^</kbd>): No major update will be done (2.0.1 to 2.1.0 is OK, to 3.0.1 is not!) .</li>
<li><strong>Wildcard</strong> (<kbd>*</kbd>): Allows any version, but it can be used to replace a position.</li>
</ul>
<p>These operators avoid future dependency headaches and introduce a stable API without missing the required updates and fixes.</p>
<div class="packt_infobox">It isn't possible to publish a crate with wildcard dependencies. After all, which version is the target computer supposed to use? This is why <kbd>cargo</kbd> enforces explicit version numbers when running <kbd>cargo publish</kbd>.</div>
<p>There are several ways to work with purpose-specific dependencies. They can either be declared by platform (<kbd>[target.wasm32-unknown-unknown]</kbd>) or by their intention: there is a dependency type, <kbd>[dev-dependencies]</kbd>, for compiling tests, examples, and benchmarks, but there is also a build-only dependency specification, <kbd>[build-dependencies]</kbd>, that will be separated from others.</p>
<p>Once the dependencies are specified, they are resolved and looked up to generate a dependency tree within the project. This is where the <kbd>Cargo.lock</kbd> file comes in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependencies – Cargo.lock</h1>
                </header>
            
            <article>
                
<p>Here is a great quote from the <kbd>cargo</kbd> FAQ (<a href="https://doc.rust-lang.org/cargo/faq.html">https://doc.rust-lang.org/cargo/faq.html</a>) about what the purpose of this file is and what it does:</p>
<div class="packt_quote">The purpose of a Cargo.lock is to describe the state of the world at the time of a successful build. It is then used to provide deterministic builds across whatever machine is building the project by ensuring that the exact same dependencies are being compiled.</div>
<p>This serialized state can easily be transferred across teams or computers. Therefore, should a dependency introduce a bug with a patch update, your build should be <span>largely</span> unaffected unless you run <kbd>cargo update</kbd>. In fact, it's recommended for libraries to commit the <kbd>Cargo.lock</kbd> file to version control to retain a stable, working build. For debugging purposes, it's also quite handy to streamline the dependency tree.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Commands</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> supports a wealth of commands that can be extended easily. It deeply integrates with the project and allows for additional build scripts, benchmarking, testing, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The compile and run commands</h1>
                </header>
            
            <article>
                
<p>As the main build tool, <kbd>cargo</kbd> does compile and run by way of creating and then executing the output binary (usually found in <kbd>target/&lt;profile&gt;/&lt;target-triple&gt;/</kbd>).</p>
<p>What if a library written in a different language is required to precede the Rust build? This is where build scripts come in. As mentioned in the <em>Project configuration</em> section, the manifest provides a field called <kbd>build</kbd> which takes a path or name to a <kbd>build</kbd> script.</p>
<p>The script itself can be a regular Rust binary that generates output in a designated folder, and can even have dependencies specified in <kbd>Cargo.toml</kbd> (<kbd>[build-dependencies]</kbd>, but nothing else). Any required information (target architecture, output, and so on) is passed into the program using environment variables, and any output for <kbd>cargo</kbd> is required to have the <kbd>cargo:key=value</kbd> format. Those are picked up by <kbd>cargo</kbd> to configure further steps. While the most popular is building native dependencies, it's entirely possible to generate code (such as bindings, data access classes, and so on) as well. Read more in the <kbd>cargo</kbd> reference: <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">https://doc.rust-lang.org/cargo/reference/build-scripts.html</a>.</p>
<p>Larger projects will require a more complex structure than a simple <kbd>src/</kbd> folder to contain all the source code, which is why <kbd>cargo</kbd> provides the option to split projects into subprojects, called a workspace. This comes in handy for architectural patterns such as microservices (each service could be a project), or loosely coupling components (clean architecture). To set this up, place each subproject in a subdirectory and create a <kbd>Cargo.toml</kbd> in the workspace that declares its members:</p>
<pre>[workspace] <br/>members = [ "core", "web", "data"]</pre>
<p>This applies any commands run at the top level to every crate in the workspace. Invoking <kbd>cargo test</kbd> will run all types of tests and that can take a long time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>As far as commands go, <kbd>cargo</kbd> supports test and bench to run a crate's tests. These tests are specified in the code by creating a "module" inside a module and annotating it with <kbd>#[cfg(test)]</kbd>. Furthermore, each test also has to be annotated with either <kbd>#[test]</kbd> or <kbd>#[bench]</kbd>, whereas the latter takes an argument to the <kbd>Bencher</kbd>, a benchmark runner class that allows us to collect stats on each run:</p>
<div>
<pre>#![feature(test)] <br/>extern crate test;<br/><br/>pub fn my_add(a: i32, b: i32) -&gt; i32 {<br/>    a + b<br/>}<br/><br/>#[cfg(test)] <br/>mod tests { <br/>    use super::*;<br/>    use test::Bencher;<br/><br/>    #[test] <br/>    fn this_works() { <br/>        assert_eq!(my_add(1, 1), 2);<br/>    }<br/>    <br/>    #[test]<br/>    #[should_panic(expected = "attempt to add with overflow")]<br/>    fn this_does_not_work() {<br/>        assert_eq!(my_add(std::i32::MAX, std::i32::MAX), 0);<br/>    }<br/>    <br/>    #[bench]<br/>    fn how_fast(b: &amp;mut Bencher) {<br/>        b.iter(|| my_add(42, 42))<br/>    }<br/>}</pre></div>
<p>After running <kbd>cargo test</kbd>, the output is as expected:</p>
<pre><strong>Finished dev [unoptimized + debuginfo] target(s) in 0.02s</strong><br/><strong>     Running target/debug/deps/ch2-6372277a4cd95206</strong><br/><br/><strong>running 3 tests</strong><br/><strong>test tests::how_fast ... ok</strong><br/><strong>test tests::this_works ... ok</strong><br/><strong>test tests::this_does_not_work ... ok</strong><br/><br/><strong>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</strong></pre>
<p><span>In this example, the tests are importing and calling a function from its parent module, called</span> <kbd>my_add</kbd><span>. One of the tests even expects a</span> <kbd>panic!</kbd> <span>(caused by an overflow) to be thrown, which is why the</span> <span><kbd>#[should_panic]</kbd> annotation has been added.</span></p>
<p>On top of this, <kbd>cargo</kbd> supports doctests, which is a special form of testing. One of the most tedious things when refactoring is updating the examples in the documentation which is why they are frequently not working. Coming from Python, the doctest is a solution to this dilemma. By running the actual code in a denoted example, doctests makes sure that everything that's printed in the documentation can be executed—creating a black box test at the same time.</p>
<p>Every function in Rust can be annotated using a special docstring—which is used to generate the documentation at DOCS.RS (<a href="https://docs.rs/">https://docs.rs/</a>).</p>
<div class="packt_infobox"><span>doctests are only available for crates of the library type.</span></div>
<p>This documentation has sections (indicated by a markdown header: <kbd>#</kbd>), and if a particular section is called <kbd>Examples</kbd>, any contained code will be compiled and run:</p>
<pre>/// # A new Section<br/>/// this [markdown](https://daringfireball.net/projects/markdown/) is picked up by `Rustdoc` </pre>
<p>We can now add another test to the preceding sample by creating a few lines of documentation:</p>
<div>
<pre><span>/// # A Simple Addition<br/></span><span>/// <br/></span><span>/// Adds two integers.<br/></span><span>/// <br/></span><span>/// # Arguments<br/></span><span>/// <br/></span><span>/// - *a* the first term, needs to be i32<br/></span><span>/// - *b* the second term, also a i32<br/></span><span>/// <br/></span><span>/// ## Returns<br/></span><span>/// The sum of *a* and *b*.<br/></span><span>/// <br/></span><span>/// # Panics<br/></span><span>/// The addition is not done safely, overflows will panic!<br/></span><span>/// <br/></span><span>/// # Examples<br/></span><span>/// <br/></span><span>/// ```rust<br/></span><span>/// assert_eq!(ch2::my_add(1, 1), 2);<br/></span><span>/// ```<br/></span>pub fn my_add(a: i32, b: i32) -&gt; i32 {<br/>    a + b<br/>}<span> </span></pre></div>
<p>The <kbd>cargo test</kbd> command will now run the code in examples as well:</p>
<pre><span><strong>$ cargo test </strong><br/><strong>   Compiling ch2 v0.1.0 (file:///home/cm/workspace/Mine/rust.algorithms.data.structures/code/ch2) </strong><br/><strong>    Finished dev [unoptimized + debuginfo] target(s) in 0.58s                                                                            </strong><br/><strong>     Running target/debug/deps/ch1-8ed0f81f04655fe4 </strong><br/> <br/><strong>running 0 tests </strong><br/> <br/><strong>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out </strong><br/> <br/><strong>     Running target/debug/deps/ch2-3ddb7f7cbab6792d </strong><br/> <br/><strong>running 3 tests </strong><br/><strong>test tests::how_fast ... ok </strong><br/><strong>test tests::this_does_not_work ... ok </strong><br/><strong>test tests::this_works ... ok </strong><br/> <br/><strong>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out </strong><br/> <br/><strong>   Doc-tests ch2 </strong><br/> <br/><strong>running 1 test </strong><br/><strong>test src/lib.rs - my_add (line 26) ... ok </strong><br/> <br/><strong>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</strong></span></pre>
<p>For larger tests or black-box tests, it's also possible (and recommended) to put the tests into a subfolder of the project, called <kbd>tests</kbd>. <kbd>cargo</kbd> will pick this up automatically and run the tests accordingly.</p>
<p>On top of tests, other commands are often required (code metrics, linting, and so on) and recommended. For that, <kbd>cargo</kbd> provides a third-party command interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Third-party subcommands</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> allows the extension of its command-line interface with subcommands. These subcommands are binaries that are called when invoking <kbd>cargo &lt;command&gt;</kbd> (for example, <kbd>cargo clippy</kbd> for the popular linter).</p>
<p>In order to install a new command (for a particular toolchain), run <kbd>cargo +nightly install clippy</kbd>, which will download, compile, and install a crate called <kbd>cargo-clippy</kbd> and then put it into the <kbd>.cargo</kbd> directory in your home folder. In fact, this will work with any binary that is called <kbd>cargo-&lt;something&gt;</kbd> and is executable from any command line. The <kbd>cargo</kbd> project keeps an updated list of some useful subcommands in the repository at <a href="https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands">https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Crates</h1>
                </header>
            
            <article>
                
<p>Rust's modules (crates) can easily be packaged and distributed once all the compilation and testing is done, regardless of whether they are libraries or executables. First, let's take a look at Rust binaries in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rust libraries and binaries</h1>
                </header>
            
            <article>
                
<p>There are executable binaries and libraries in Rust. When these Rust programs use dependencies, they rely on the linker to integrate those so it will work on—at least—the current platform. There are two major types of linking: static and dynamic—both of which are somewhat dependent on the operating system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static and dynamic libraries</h1>
                </header>
            
            <article>
                
<p><span>Generally, Rust dependencies have two types of linking:</span></p>
<ul>
<li><span><strong>Static</strong>: Via the <kbd>rlib</kbd> format.</span></li>
<li><span><strong>Dynamic</strong>: Via shared libraries (<kbd>.so</kbd> or <kbd>.dll</kbd>).</span></li>
</ul>
<p><span>The preference—if a corresponding <kbd>rlib</kbd> can be found—is to link statically and therefore include all dependencies into the output binary, making the file a lot larger</span> <span>(to the dismay of embedded programmers). Therefore, if</span> <span>multiple Rust programs use the same dependency, each comes with its own built-in version. It's all about the context though, since, as Go's success has shown, static linking can simplify complex deployments since only a single file has to be rolled out.</span></p>
<p>There are drawbacks to the static linking approach beyond size: for static libraries, all dependencies have to be of the <kbd>rlib</kbd> type, which is Rust's native package format, and cannot contain a dynamic library since the formats (for example, <kbd>.so</kbd> (dynamic) and <kbd>.a</kbd> (static) on ELF systems) aren't convertible.</p>
<p><span>For Rust, dynamic linking is commonly used for native dependencies, since they are usually available in the operating system and don't need to be included in the package. The Rust compiler can favor this with a <kbd>-C prefer-dynamic</kbd> flag, which will get the compiler to look for the corresponding dynamic libraries first.</span></p>
<p>Therein lies the current strategy of the compiler: depending on the output format (<kbd>--crate-format= rlib</kbd>, <kbd>dylib</kbd>, <kbd>staticlib</kbd>, <kbd>library</kbd>, or <kbd>bin</kbd>), it decides on the best linking type with your influence via flags. However, there is a rule that the output cannot statically link the same library twice, so it won't link two libraries with the same static dependency.</p>
<p>For more information on the topic, we recommend checking out <a href="https://doc.rust-lang.org/reference/linkage.html">https://doc.rust-lang.org/reference/linkage.html</a>. That said, the compiler is usually trustworthy and, unless there is an interoperability goal, <kbd>rustc</kbd> will decide optimally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linking and interoperability</h1>
                </header>
            
            <article>
                
<p>Rust compiles to native code like many other languages, which is great because it expands the available libraries and lets you choose the best technology to solve a problem. "Playing nice with others" has always been a major design goal of Rust.</p>
<p>Interoperability on that level is as simple as declaring the function that you want to import and dynamically linking a library that exports this function. This process is largely automated: the only thing required is to create and declare a build script that compiles the dependency and then tells the linker where the output is located. Depending on what type of library you built, the linker does what is necessary to include it into the Rust program: static or dynamic linking (the default).</p>
<p>If there is only one native library that is to be linked dynamically, the manifest file offers a <kbd>links</kbd> property to specify that. Programmatically, it's very easy to interact with these included libraries by using the Foreign Function Interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FFI</h1>
                </header>
            
            <article>
                
<p>The <strong>Foreign Function Interface</strong> (<strong>FFI</strong>) is Rust's way of calling into other native libraries (and vice versa) using a simple keyword: <kbd>extern</kbd>. By declaring an <kbd>extern</kbd> function, the compiler knows that, either an outside interface needs to be bound via the linker (import) or, that the declared function is to be exported so other languages can make use of it (export).</p>
<p>In addition to the keyword, the compiler and linker have to get a hint of what type of binary layout is expected. That's why the usual <kbd>extern</kbd> declaration looks as follows:</p>
<pre>extern "C" {<br/>    fn imported_function() -&gt; i32;<br/>}<br/><br/>#[no_mangle]<br/>pub extern "C" fn exported_function() -&gt; i32 {<br/>    42<br/>}</pre>
<p>This allows a <kbd>C</kbd> library function to be called from within Rust. However, there's one caveat: the calling part has to be wrapped in an <kbd>unsafe</kbd> section. The Rust compiler cannot guarantee the safety of an external library so it makes sense to be pessimistic about its memory management. The exported function is safe, and by adding the <kbd>#[no_mangle]</kbd> attribute, there is no name mangling, so it can be found using its name.</p>
<p>In order to use libraries for specialized algorithms available in a C/C++ library, there is a tool that generates suitable structures, <kbd>extern "C"</kbd> declarations, and data types, <span>called <kbd>rust-bindgen</kbd></span>. Find out more at <a href="https://github.com/rust-lang-nursery/rust-bindgen">https://github.com/rust-lang-nursery/rust-bindgen</a>. These interoperability capabilities make Rust code available to legacy software or for use in a vastly different context, such as web frontends.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wasm</h1>
                </header>
            
            <article>
                
<p><strong>Wasm</strong>, which <strong>WebAssembly</strong> is now commonly called, is a binary format meant to complement JavaScript that Rust can be compiled to. The format is designed to run as a stack machine inside several sandboxed execution environments (such as web browsers, or the Node.js runtime) for performance-critical applications (<a href="https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/">https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/</a>). While this is—as of this writing—in its early stages, Rust and the <span>Wasm</span> target have been used in real-time frontend settings (such as browser games), and in 2018 there was a dedicated working group seeking to improve this integration.</p>
<p>Similar to other targets, such as ARM, the <span>Wasm</span> target is an LLVM (the compiler technology Rust is built on) backend so it has to be installed using <kbd><span>rustup target add wasm32-unknown-unknown</span></kbd>. Furthermore, it isn't necessary to declare the binary layout (the <kbd>"C"</kbd> in <kbd>extern "C"</kbd>) and a different bindgen tool does the rest: <kbd>wasm-bindgen</kbd>, available at <a href="https://github.com/rustwasm/wasm-bindgen">https://github.com/rustwasm/wasm-bindgen</a>. We highly recommend reading the documentation for more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main repository – crates.io</h1>
                </header>
            
            <article>
                
<p>The <kbd>crates.io</kbd> website (<a href="https://crates.io/">https://crates.io/</a>) provides a huge repository of crates to be used with Rust. Along with discoverability functions, such as <kbd>tags</kbd> and <kbd>search</kbd>, it allows Rust programmers to offer their work to others.</p>
<p>The repository itself provides APIs to interact with and a wealth of documentation pointers for <kbd>cargo</kbd>, crates in general, and so on. The source code is available on GitHub—we recommend checking out the repository for more information: <a href="https://github.com/rust-lang/crates.io">https://github.com/rust-lang/crates.io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing</h1>
                </header>
            
            <article>
                
<p>For developers to get their crate into this repository, <kbd>cargo</kbd> harbors a command: <kbd>cargo publish</kbd>. The command is actually doing more things behind the scenes: first it runs the <kbd>cargo</kbd> package to create a <kbd>*.crate</kbd> file that contains everything that is uploaded. Then it verifies the contents of the package by essentially running <kbd>cargo test</kbd> and checks whether there are any uncommitted files in the local repository. Only if these checks pass does <kbd>cargo</kbd> upload the contents of the <kbd>*.crate</kbd> file to the repository. This requires a valid account on <kbd>crates.io</kbd> (available with your GitHub login) to acquire your personal secret API token, and the crate has to follow certain rules.</p>
<div class="packt_infobox">With the previously-mentioned Wasm target, it's even possible to publish Rust packages to the famous JavaScript package repository: <kbd>npm</kbd> Keep in mind that Wasm support is still very new, but once a crate compiles to Wasm it can be packed into an <kbd>npm</kbd> package using Wasm-pack: <a href="https://github.com/rustwasm/wasm-pack">https://github.com/rustwasm/wasm-pack</a>.</div>
<p><kbd>crates.io</kbd> aspires to be a permanent storage for Rust crates, so there is no "unpublish" button. Versions can be yanked with <kbd>cargo yank</kbd>, but this won't delete any code; it will just prohibit updates to this particular version. Additionally there can be team structures, colorful READMEs, badges, and so on, on your repository's site and we highly recommend you check out the docs on that as well: <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">https://doc.rust-lang.org/cargo/reference/publishing.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><kbd>cargo</kbd> is Rust's package manager and build tool that is configurable with a manifest called <kbd>Cargo.toml</kbd>. The file is used <span>by</span> <kbd>cargo</kbd> <span>to build the desired binary with the specified</span> dependencies, profiles, workspaces, and package metadata. During this process, the package state is saved in a file called <kbd>Cargo.lock</kbd>. Thanks to its LLVM frontend, Rust compiles to native code on various platforms including the web (using Wasm)—thus keeping a high degree of interoperabilty. Successfully-built packages can be published on a repository called <kbd>crates.io</kbd>, a website that is a central hub for available Rust libraries and binaries.</p>
<p>Before we dive into data structures (starting with lists), the next chapter will introduce the ways Rust stores variables and data in memory, whether to copy or to clone, and what sized and unsized types are.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ul>
<li>What does <kbd>cargo</kbd> do?</li>
<li>Does <kbd>cargo</kbd> provide linting support?</li>
<li>In which cases is the <kbd>Cargo.lock</kbd> file important to publish?</li>
<li>What are the requirements to publish to <kbd>crates.io</kbd>?</li>
<li>What is Wasm and why should you care?</li>
<li>How are tests organized in a Rust project?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>You can refer to the following links for more information on the topics covered in this chapter:</p>
<ul>
<li><a href="https://crates.io">https://crates.io</a></li>
<li><a href="https://doc.rust-lang.org/cargo/">https://doc.rust-lang.org/cargo/</a></li>
<li><a href="https://github.com/rustwasm/team">https://github.com/rustwasm/team</a></li>
<li><a href="https://webassembly.org">https://webassembly.org</a></li>
<li><a href="https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/">https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>