- en: Optimization of Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务优化
- en: Optimization is an important part of the microservice development process. With
    optimization, you can increase the performance of a microservice and reduce costs
    for infrastructure and hardware. In this chapter, we will shed light on benchmarking,
    along with some optimization techniques, such as caching, reusing shared data
    with structs without taking ownership, and how you can use a compiler's options
    to optimize a microservice. This chapter will help you to improve the performance
    of your microservices using optimization techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是微服务开发过程中的一个重要部分。通过优化，你可以提高微服务的性能，并降低基础设施和硬件的成本。在本章中，我们将探讨基准测试，以及一些优化技术，例如缓存、使用结构体重用共享数据而不获取所有权，以及如何使用编译器的选项来优化微服务。本章将帮助你通过优化技术来提高你的微服务的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performance-measuring tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测量工具
- en: Techniques of optimizations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化技术
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the examples in this chapter, you need a Rust compiler (version 1.31
    and above) to build the examples for testing and to build the tools you need to
    measure performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例，你需要一个Rust编译器（版本1.31及以上）来构建用于测试的示例，以及构建你需要来测量性能的工具。
- en: 'There are sources of the examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter14).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter14)。
- en: Performance-measuring tools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测量工具
- en: Before you decide to optimize something in a microservice, you have to measure
    its performance. You shouldn't write optimal and fast microservices from the start,
    because not every microservice needs good performance, and if your microservice
    has bottlenecks inside, it will stumble on heavy loads.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你决定在微服务中优化某些内容之前，你必须测量其性能。你不应该一开始就编写最优和快速的微服务，因为并非每个微服务都需要良好的性能，如果你的微服务内部存在瓶颈，它将在高负载下遇到困难。
- en: Let's explore a pair of benchmarking tools. We will explore tools that are written
    in Rust, because they can be simply used to construct your own measuring tool
    if you need to test a special case with extremely high load.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一对基准测试工具。我们将探讨用Rust编写的工具，因为如果你需要测试具有极高负载的特殊情况，它们可以简单地用来构建你自己的测量工具。
- en: Welle
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Welle
- en: Welle is an alternative to the popular **Apache Benchmarking tool** (**ab**)
    that is used to benchmark HTTP servers. It can produce a batch of requests to
    a specified URL and measure the time to response for every request. At the end,
    it collects statistics about the average response time and quantity of failed
    requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Welle是流行的**Apache基准测试工具**（**ab**）的替代品，该工具用于基准测试HTTP服务器。它可以生成一批请求到指定的URL，并测量每个请求的响应时间。最后，它收集关于平均响应时间和失败请求数量的统计数据。
- en: 'To install this tool, use the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此工具，请使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this tool is simple: set a URL to test with a number of requests you
    want to send to a server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具很简单：设置要测试的URL和要发送到服务器的请求数量：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, the tool uses a single thread to send a request and wait for the
    response to send the next request. But you can split requests across more threads
    by setting a `--concurrent-requests` command-line parameter with the number of
    necessary threads.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该工具使用单个线程发送请求并等待响应以发送下一个请求。但你可以通过设置带有所需线程数的`--concurrent-requests`命令行参数来在更多线程之间分割请求。
- en: 'When a measurement is finished, it will print a report similar to this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当测量完成后，它将打印出类似以下报告：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to use a HTTP method other than `GET`, you can set it using the `--method`
    command-line parameter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用除`GET`之外的HTTP方法，你可以使用`--method`命令行参数来设置它。
- en: Drill
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drill
- en: Drill is more complex and lets you perform load tests on microservices. It not
    only sends batches of requests, it also uses a testing script to produce a sequence
    of activities. It helps you to perform a load test that you can use to measure
    performance of the entire application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Drill更为复杂，允许你对微服务进行负载测试。它不仅发送请求批次，还使用测试脚本来生成一系列活动。它帮助你执行一个可以用来测量整个应用程序性能的负载测试。
- en: 'To install `drill`, use the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`drill`，请使用以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After it''s installed, you have to configure the load testing you will perform.
    Create a `benchmark.yml` file and add the following load test script:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你必须配置将要执行的负载测试。创建一个`benchmark.yml`文件并添加以下负载测试脚本：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To start testing using this script, run the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此脚本开始测试，请运行以下命令：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will perform a load test of your microservice by sending HTTP request constructed
    with rules from the script and print a report like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它将通过发送使用脚本中的规则构建的HTTP请求来对你的微服务进行负载测试，并打印出如下报告：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both tools are suitable for testing the performance of your microservices. Welle
    is good for measuring the performance of a single request type if you want to
    optimize the specified handler. Drill is good to produce a complex load to measure
    how much users can be served by an application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具都适合测试你的微服务的性能。如果你想要优化指定的处理器，Welle适合测量单个请求类型的性能。Drill适合生成复杂的负载，以测量应用程序可以服务多少用户。
- en: Let's look at an example in which we add some optimizations and test the difference
    using Welle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，我们添加一些优化，并使用Welle测试差异。
- en: Measuring and optimizing performance
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量和优化性能
- en: 'In this section, we will measure the performance of an example microservice
    compiled with two options: without optimizations, and with optimizations made
    by a compiler. The microservice will send rendered index page to clients. And
    we will use the Welle tool to measure the performance of this microservice to
    see if we can improve it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测量一个使用两种选项编译的示例微服务的性能：没有优化，以及由编译器进行的优化。微服务将向客户端发送渲染后的索引页面。我们将使用Welle工具来测量这个微服务的性能，以查看我们是否可以改进它。
- en: Basic example
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本示例
- en: Let's create a microservice in a new crate based on the `actix-web` crate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在基于`actix-web`crate的新crate中创建一个微服务。
- en: 'Add the following dependencies to `Cargo.toml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到`Cargo.toml`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will construct a tiny server that will render an index page asynchronously
    with the current time, with one-minute precision. As a matter of fact, there is
    a shortcut function that does this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个微型的服务器，该服务器将以一分钟精度异步渲染当前时间索引页面。事实上，有一个快捷函数可以做到这一点：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use the `askama` crate to render the template of the index page and insert
    the current time taken from a shared state it it. For the time value, we use a
    `String` instead of types directly from the `chrono` crate, in order to get a
    value that uses a memory heap:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`askama`crate来渲染索引页面的模板，并从共享状态中插入当前时间。对于时间值，我们使用`String`而不是直接从`chrono`crate中的类型，以便获得使用内存堆的值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For a shared state, we will use a struct with a `last_minute` value, represented
    as a `String` wrapped with a `Mutex`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享状态，我们将使用一个包含`last_minute`值的结构体，该值以`Mutex`包裹的`String`形式表示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you may remember, `Mutex` provides concurrent access to any type for multiple
    threads. It's locked for both reading and writing the value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，`Mutex`为多个线程提供了对任何类型的并发访问。它锁定用于读取和写入值。
- en: 'For the index page, we will use the following handler:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于索引页面，我们将使用以下处理器：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The handler shown in the preceding code block locks the `last_minute` field
    of a `State` instance available in `HttpRequest`. Then we use this value to fill
    the `IndexTemplate` struct and call the `render` method to render the template
    and use the generated value as a body for a new `HttpResponse`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块中显示的处理程序锁定了一个在`HttpRequest`中可用的`State`实例的`last_minute`字段。然后我们使用这个值来填充`IndexTemplate`结构体并调用`render`方法来渲染模板，并将生成的值用作新的`HttpResponse`的正文。
- en: 'We start the application with the `main` function that prepares the `Server`
    instance and spawns a separate thread that updates a shared `State`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`main`函数开始应用程序，该函数准备`Server`实例并启动一个单独的线程来更新共享的`State`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We used the Actix Web framework for this example. You can read more about this
    framework in [Chapter 11](5b7dd2c1-d623-4422-83a7-e05681230ee9.xhtml), *Involving
    Concurrency with Actors and the Actix Crate*. This simple example is ready to
    compile and start. We will also check the performance of this code using the Welle
    tool.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用了Actix Web框架。你可以在第11章中了解更多关于这个框架的信息，*使用Actors和Actix Crate处理并发*。这个简单的示例已经准备好编译和启动。我们还将使用Welle工具检查这段代码的性能。
- en: Performance
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: 'First, we will build and run the code using a standard command without any
    flags:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用标准命令不带任何标志来构建和运行代码：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We build a binary with a lot of debugging information, which can be used with
    LLDB as we did in [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing
    and Debugging Rust Microservices*. A debugging symbol reduces performance, but
    we will check it to compare it with a version without these symbols later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个包含大量调试信息的二进制文件，它可以像我们在[第13章](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml)中做的那样，与LLDB一起使用，进行*测试和调试Rust微服务*。调试符号会降低性能，但我们将检查它，以便与没有这些符号的版本进行比较。
- en: 'Let''s load the running server with `100000` requests from `10` concurrent
    activities. Since our server was bound to port `8080` of `localhost`, we can use
    the `welle` command with the following arguments to measure the performance:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`100000`个请求从`10`个并发活动加载运行中的服务器。由于我们的服务器绑定到了`localhost`的`8080`端口，我们可以使用以下参数的`welle`命令来测量性能：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It takes about 30 seconds (depending on your system) and the tool will print
    the report:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要大约30秒（取决于你的系统）并且工具将打印报告：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the report, you can see that there is an average response time of 300 milliseconds.
    It was a service that was burdened with debugging. Let''s recompile this example
    with optimizations. Set the `--release` flag on the `cargo run` command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告中，你可以看到平均响应时间为300毫秒。这是一个负担了调试的服务。让我们重新编译这个示例，并应用优化。在`cargo run`命令上设置`--release`标志：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command passed the `-C opt-level=3` optimization flag to the `rustc` compiler.
    If you use `cargo` without a `--release` flag, it sets `opt-level` to `2`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`-C opt-level=3`优化标志传递给`rustc`编译器。如果你使用不带`--release`标志的`cargo`，它将`opt-level`设置为`2`。
- en: 'After the server has recompiled and started, we use the Welle tool again with
    the same parameters. It reports the other values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器重新编译并启动后，我们再次使用带有相同参数的Welle工具。它报告了其他值：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the average time taken for a request has been reduced to more
    than 70%. The result is already pretty good. But could we reduce it a little more?
    Let's try to do it with some optimizations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，请求的平均处理时间已经降低到超过70%。结果已经相当不错。但我们能否再降低一些？让我们尝试通过一些优化来实现这一点。
- en: Optimizations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: 'We will try to apply three optimizations to the code we created in the previous
    section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试将三种优化应用到我们在上一节中创建的代码中：
- en: We will try to reduce the blocking of a shared state.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尝试减少共享状态阻塞。
- en: We will reuse a value in a state by reference.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过引用在状态中重用值。
- en: We will add caching of responses.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加响应的缓存。
- en: After we implement them, we will check the performance after the first two improvements,
    and later check it again with caching.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现它们之后，我们将检查第一次两个改进后的性能，然后再次使用缓存进行检查。
- en: 'In the code of this section, we will implement all optimizations gradually,
    step by step, but if you downloaded the example from the GitHub repository of
    this book, you will find the following features in the `Cargo.toml` file of the
    project of this chapter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的代码中，我们将逐步实现所有优化，但如果你从本书的GitHub仓库中下载了示例，你将在本章项目的`Cargo.toml`文件中找到以下特性：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code here uses features to provide you a capability to activate or deactivate
    any optimization separately. We see the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码使用特性为你提供了一个单独激活或禁用任何优化的能力。我们看到以下内容：
- en: '`cache`: activates the caching of requests'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`：激活请求的缓存'
- en: '`rwlock`: uses `RwLock` instead of `Mutex` for `State`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwlock`：使用`RwLock`代替`Mutex`进行`State`'
- en: '`borrow`: reuses a value by reference'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`borrow`：通过引用重用值'
- en: Let's implement all of these optimizations and apply all of them to measure
    differences in the performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现所有这些优化，并将它们全部应用到性能差异的测量中。
- en: State sharing without blocking
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无阻塞状态共享
- en: In the first optimization, we will replace `Mutex` with `RwLock`, because `Mutex` is
    locked for both reading and writing, but `RwLock` allows us to have a single writer
    or multiple readers. It allows you to avoid blocking for reading the value if
    no one updates the value. This applies to our example, as we rarely update a shared
    value, but have to read it from multiple instances of handlers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次优化中，我们将用`RwLock`替换`Mutex`，因为`Mutex`在读取和写入时都会锁定，但`RwLock`允许我们有一个单独的写入者或多个读取者。它允许我们在没有更新值的情况下避免读取值的阻塞。这适用于我们的示例，因为我们很少更新共享值，但必须从多个处理程序实例中读取它。
- en: '`RwLock` is an alternative to `Mutex` that separates readers and writers, but
    the usage of `RwLock` is as simple as `Mutex`. Replace `Mutex` to `RwLock` in
    the `State` struct:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RwLock`是`Mutex`的一个替代品，它将读取者和写入者分开，但`RwLock`的使用与`Mutex`一样简单。在`State`结构中将`Mutex`替换为`RwLock`：'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, we have to replace a creation of the `last_minute` reference counter
    to the corresponding type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须将创建 `last_minute` 引用计数器的类型替换为相应的类型：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the code of the worker, we will use the `write` method of `RwLock` to lock
    the value for writing to set a new time value. Its exclusive lock will block all
    potential readers and writers with a single writer that can change the value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作者的代码中，我们将使用 `RwLock` 的 `write` 方法锁定值以写入并设置新的时间值。它的独占锁将阻塞所有潜在的读取者和写入者，只有一个写入者可以更改值：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the worker will take an exclusive lock once per three seconds, it's a
    small price to pay to increase the amount of simultaneous readers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 `worker` 每三秒会获取一次独占锁，因此增加同时读取的数量是一个小的代价。
- en: 'In the handler, we will use the `read` method to lock `RwLock` for reading:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器中，我们将使用 `read` 方法锁定 `RwLock` 以进行读取：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code won't be blocked by other handlers, excluding the case when a worker
    updates a value. It allows all handlers to work simultaneously.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会被其他处理器阻塞，除非 `worker` 更新值。它允许所有处理器同时工作。
- en: Now we can implement the second improvement—avoid cloning of values and using
    them by references.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现第二个改进——避免值的克隆并通过引用使用它们。
- en: Reusing values by references
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过引用重用值
- en: To render a template of an index page, we use a struct with a `String` field
    and we have to fill the `IndexTemplate` struct to call the `render` method on
    it. But the template needs an ownership for the value and we have to clone it.
    Cloning in turn takes time. To avoid this CPU cost, we can use a reference to
    a value, because if we clone a value that uses a memory heap, we have to allocate
    a new memory space and copy bytes of the value to a new place.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染索引页面的模板，我们使用一个带有 `String` 字段的结构体，并且我们必须填充 `IndexTemplate` 结构体来调用其上的 `render`
    方法。但是模板需要值的所有权，我们必须克隆它。克隆会消耗时间。为了避免这种CPU成本，我们可以使用值的引用，因为如果我们克隆一个使用内存堆的值，我们必须分配新的内存空间并将值的字节复制到新的位置。
- en: 'This is how we can add a reference to a value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以向一个值添加引用的方法：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have added the `'a` lifetime to a struct, because we use a reference inside
    and the struct that can't live longer than the string value we referred to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给一个结构体添加了 `'a` 生命周期，因为我们内部使用了一个引用，而这个结构体不能比我们引用的字符串值活得久。
- en: Using references is not always possible for combinations of `Future` instances,
    because we have to construct a `Future` that generates an `HttpResponse`, but
    lives longer than calling a handler. In this case, you can reuse a value if you
    take ownership of it and use methods such as fold to pass the value through all
    the steps of the combinator's chain. It is valuable for large values, which can
    consume a lot of CPU time, to be cloned.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Future` 实例的组合，使用引用并不总是可能的，因为我们必须构建一个生成 `HttpResponse` 的 `Future`，但它的生命周期比调用处理器要长。在这种情况下，如果你拥有它的所有权并使用如
    fold 这样的方法将值传递到组合器链的所有步骤中，你可以重用这个值。对于可能消耗大量CPU时间的较大值来说，这是很有价值的。
- en: 'Now we can use a reference to the borrowed `last_minute` value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用对借用 `last_minute` 值的引用：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `to_owned` method, which we used before, cloned the value that we put to
    `IndexTemplate`, but we can now use a reference and avoid cloning at all.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 `to_owned` 方法克隆了我们放入 `IndexTemplate` 的值，但现在我们可以使用引用并完全避免克隆。
- en: All we need to do now is implement caching, which can help to avoid template
    rendering.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的就是实现缓存，这有助于避免模板渲染。
- en: Caching
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'We will use a cache to store rendered template and returns it as a response
    for future requests. Ideally, the cache should have a lifetime, because if the
    cache is not updated, then clients won''t see any updates on the page. But for
    our demo application, we won''t reset the cache to make sure it works, because
    our small microservice renders a time and we can see if it''s frozen. Now we will
    add a new field to the `State` struct to keep a rendered template for future responses:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用缓存来存储渲染的模板，并将其作为对后续请求的响应。理想情况下，缓存应该有一个生命周期，因为如果缓存没有更新，那么客户端将看不到页面上的任何更新。但为了我们的演示应用程序，我们不会重置缓存以确保它工作，因为我们的小型微服务渲染时间，我们可以看到它是否冻结。现在我们将向
    `State` 结构体添加一个新字段以保留用于未来响应的渲染模板：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will use `RwLock` because we have to update this value at least once, but
    for values that won't be updated and can be initialized, we can use the `String`
    type without any wrapper for protection from concurrent access, such as `RwLock`
    or `Mutex`. In other words, you can use the `String` type directly if you only
    read it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`RwLock`，因为我们必须至少更新这个值一次，但对于那些不会更新且可以初始化的值，我们可以使用不带任何包装器的`String`类型来保护其免受并发访问，例如`RwLock`或`Mutex`。换句话说，如果你只读取它，可以直接使用`String`类型。
- en: We also have to initialize the value with `None`, because we need to render
    a template once to get the value for caching.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须使用`None`初始化值，因为我们需要渲染一次模板以获取缓存值。
- en: 'Add an empty value to a `State` instance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 向`State`实例添加一个空值：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can use a `cached` value to construct a fast response to the user''s
    request. But you have to take into account that not all the information can be
    shown to every user. The cache can separate values by some information about users,
    for example, it can use location information to get the same cached value for
    users from the same country. The following code improves the `index` handler and
    takes a `cached` value, and if the cached value exists, it is used to produce
    a new `HttpResponse`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用一个`cached`值来构建对用户请求的快速响应。但必须考虑到并非所有信息都可以展示给每个用户。缓存可以根据一些关于用户的信息来分隔值，例如，它可以使用位置信息为来自同一国家的用户获取相同的缓存值。以下代码改进了`index`处理器并接受一个`cached`值，如果缓存值存在，则使用它来生成一个新的`HttpResponse`：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We immediately return a `cached` value because there is a rendered template
    stored and we don''t have to spend time on rendering. But if no value exists,
    we can produce it with the following code and set the `cached` value at the same
    time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即返回一个`cached`值，因为已经存储了一个渲染的模板，我们不需要花费时间在渲染上。但如果不存在值，我们可以使用以下代码生成它，并设置`cached`值：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After this, we keep the original code that returns `HttpResponse` to a client.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将返回`HttpResponse`给客户端的原始代码保留下来。
- en: Now we have implemented and compiled the code with all the optimizations and
    can measure performance of the new version with optimizations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了所有优化并编译了代码，可以测量优化后新版本的性能。
- en: Compilation with optimizations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带优化编译
- en: 'The code included three optimizations. We can use some of them to check the
    difference in performance. First, we will compile the code with `RwLock` and borrow
    the state''s value features. If you use the code from the book''s GitHub repository,
    you can run the necessary optimizations using the `--features` argument with the corresponding
    feature names:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了三个优化。我们可以使用其中一些来检查性能差异。首先，我们将使用`RwLock`编译代码并借用状态值的特性。如果你使用书籍的GitHub仓库中的代码，你可以使用带有相应功能名称的`--features`参数运行必要的优化：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the server is ready, we can start running the same test we used to measure
    performance of this microservice before, with Welle, to measure how many incoming
    requests the optimized version of the server can handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器准备就绪，我们可以使用Welle运行之前用来测量这个微服务性能的相同测试，以测量优化后的服务器版本可以处理多少个传入请求。
- en: 'After testing, the tool will print a report like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，工具将打印出如下报告：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, the application is faster—it takes `79.434` microseconds instead
    of `80.10`. The difference is less than 1%, but it's good for a handler that already
    worked faster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用程序运行得更快——它只需要`79.434`微秒，而不是`80.10`微秒。差异不到1%，但对于已经运行得很快的处理程序来说是个好成绩。
- en: 'Let''s try to activate all the optimizations we implemented, including caching.
    To do this with examples from GitHub, use the following arguments:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试激活我们实现的全部优化，包括缓存。要使用GitHub上的示例这样做，请使用以下参数：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s start testing again once the server is ready. With the same testing
    parameters, we get a better report:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器准备就绪后，让我们再次开始测试。使用相同的测试参数，我们得到了更好的报告：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It takes `78.206` microseconds to get a response for a request from the server.
    It's more than 2% faster than the original version without optimization, which
    takes 80.10 microseconds per request on average.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对请求的响应时间为`78.206`微秒。这比没有优化的原始版本快了2%以上，原始版本平均每个请求需要80.10微秒。
- en: You may think the difference is not very big, but in reality, it is. This is
    a tiny example, but try to imagine the difference of optimizing a handler that
    makes three requests to databases, and renders a 200 KB template with arrays of
    values to insert. For heavy handlers, you can improve performance by 20%, or even
    more. But remember, you should remember the over-optimization is an extreme measure,
    because it makes code harder to develop and add more features without affecting
    achieved performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为差异不大，但事实上，差异很大。这是一个微小的例子，但试着想象一下优化一个处理程序，该处理程序向数据库发出三个请求，并渲染一个包含要插入的值数组的200
    KB模板。对于重型处理程序，你可以通过20%甚至更多的提升来提高性能。但请记住，你应该记住过度优化是一种极端措施，因为它使得代码更难开发，并添加更多功能而不影响已达到的性能。
- en: It's better not to consider any optimization as a daily task, because you may
    spend a lot of time on optimization of short pieces of code to get a 2% performance
    for features your customers don't need.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要将任何优化视为日常任务，因为你可能会花费大量时间优化短小的代码，以获得客户不需要的特性的2%的性能提升。
- en: Optimization techniques
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化技术
- en: In the previous section, we optimized the source code, but there are also alternative
    techniques of optimization by using special compilation flags and third-party
    tools. In this section, we will cover some of these optimization techniques. We
    will talk a little about reducing sizes, benchmarks, and profiling Rust code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们优化了源代码，但还有通过使用特殊的编译标志和第三方工具进行优化的替代技术。在本节中，我们将介绍一些这些优化技术。我们将简要讨论减少大小、基准测试和剖析Rust代码。
- en: Optimization is a creative topic. There is no special recipe for optimization,
    but in this section, we will create a small microservice that generates an index
    page with the current time, and then we will try to optimize it. With this example,
    I hope to show you some optimization ideas for your projects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个富有创造性的主题。没有特殊的优化秘方，但在这个章节中，我们将创建一个小的微服务，该服务生成一个包含当前时间的索引页面，然后我们将尝试对其进行优化。通过这个例子，我希望向你展示一些适合你项目的优化思路。
- en: Link-time optimizations
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接时间优化
- en: 'The compiler does a lot of optimizations automatically during the compilation
    process, but we can also activate some optimizations after the sources compiled.
    This technique called **Link Time Optimizations** (**LTO**) and applied after
    code linked and the whole program available. You can activate this optimization
    for Rust program by adding an extra section to the `Cargo.toml` file in your project:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在编译过程中自动执行许多优化，但我们也可以在源代码编译后激活一些优化。这种技术称为**链接时间优化**（**LTO**），在代码链接和整个程序可用后应用。你可以通过在你的项目中的`Cargo.toml`文件中添加一个额外的部分来为Rust程序激活此优化：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you have already compiled the project with this optimization, force a complete
    rebuild of your project. But this option also takes much more time for compilation.
    This optimization does not necessarily improve the performance, but can help to
    reduce the size of a binary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经用这个优化编译了项目，强制重新构建你的项目。但这个选项也需要更多的时间进行编译。这种优化并不一定能提高性能，但可以帮助减小二进制文件的大小。
- en: If you activate all optimization options, it doesn't mean you have made the
    fastest version of an application. Too many optimizations can reduce the performance
    of a program and you should compare the results with an original version. Most
    often, just using the standard `--release` helps the compiler to produces a binary
    with an optimal balance of compilation speed and performance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你激活了所有优化选项，并不意味着你已经制作了应用最快的版本。过多的优化可能会降低程序的性能，你应该将结果与原始版本进行比较。通常，只使用标准的`--release`选项就能帮助编译器生成一个在编译速度和性能之间达到最佳平衡的二进制文件。
- en: Normal Rust programs use panic macros for unhandled errors and print backtraces.
    For optimization, you can consider turning this off. Let's look at this technique
    in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的Rust程序使用panic宏来处理未处理的错误并打印回溯。对于优化，你可以考虑将其关闭。让我们在下一节中看看这个技术。
- en: Abort instead of panicking
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放弃恐慌
- en: Error-handling code also requires space and can affect performance. If you try
    to write microservices that won't panic, and will try to solve problems, and fail
    only when there's an unsolvable problem, you can consider using aborts (immediate
    termination of the program without unwinding the stack), instead of Rust's `panic`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理代码也需要空间，并可能影响性能。如果你尝试编写不会恐慌、会尝试解决问题并且只有在遇到无法解决的问题时才会失败的微服务，你可以考虑使用abort（立即终止程序而不回绕堆栈），而不是Rust的`panic`。
- en: 'To activate it, add the following to your  `Cargo.toml` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活它，请将以下内容添加到你的`Cargo.toml`文件中：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, if your program fails, it won't make a `panic` and will be stopped immediately
    without printing backtraces.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你的程序失败，它不会引发`panic`，并且会立即停止而不会打印回溯信息。
- en: Aborting is dangerous. If your program will be aborted, it has less chance to
    write logs corectly or deliver spans to distributed tracing. For microservices,
    you can create a separate thread for tracing, and even if the main thread failed, wait
    till all available tracing records will be stored.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是危险的。如果你的程序被中断，它写日志或向分布式跟踪传递span的机会更小。对于微服务，你可以为跟踪创建一个单独的线程，即使主线程失败，也要等待所有可用的跟踪记录被存储。
- en: Sometimes, you not only need to improve the performance, but also have to reduce
    the size of the binary. Let's see how to do it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你不仅需要提高性能，还必须减小二进制文件的大小。让我们看看如何做到这一点。
- en: Reducing the size of binaries
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小二进制文件的大小
- en: 'You may want to reduce the size of binaries. Often it''s not necessary, but
    it may be useful if you have a distributed application that uses some hardware
    with limited space that requires tiny binaries. To reduce the size of your compiled
    application, you can use the `strip` command, which is part of the **binutils**
    package:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要减小二进制文件的大小。通常这并不是必要的，但如果你的分布式应用程序使用了一些空间有限且需要小型二进制文件的硬件，那么这可能会很有用。要减小你编译的应用程序的大小，你可以使用`strip`命令，这是`binutils`包的一部分：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For example, I tried to strip a compiled binary of the microservice we created
    in the *Basic example* section of this chapter. The binary with debugging symbols
    compiled with the `cargo build` command reduced from 79 MB to 12 MB. The version
    compiled with the `--release` flag reduced from 8.5 MB to 4.7 MB.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我尝试从本章*基本示例*部分创建的微服务的编译二进制文件中删除调试符号。使用`cargo build`命令编译的带有调试符号的二进制文件从79 MB减少到12
    MB。使用`--release`标志编译的版本从8.5 MB减少到4.7 MB。
- en: But remember that you can't debug a stripped binary, because the tool will remove
    all necessary information for debugging.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，你不能调试经过`strip`处理的二进制文件，因为工具会移除所有必要的调试信息。
- en: Sometimes, you may want to compare some ideas of optimizations and want to measure
    which one is better. You can use benchmarks for that. Let's look at the benchmark
    feature supplied with `cargo`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要比较一些优化的想法，并测量哪一个更好。你可以使用基准测试来做到这一点。让我们看看`cargo`提供的基准测试功能。
- en: Isolated benchmarks
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立的基准测试
- en: Rust supports benchmark testing out of the box. You can use it to compare the
    performance of different solutions of the same problem or to get to know the time
    of execution of some parts of your application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Rust支持开箱即用的基准测试。你可以用它来比较同一问题的不同解决方案的性能，或者了解应用程序某些部分的执行时间。
- en: 'To use benchmarks, you have to add a function with the `#[bench]` attribute.
    The function expects a mutable reference to the `Bencher` instance. For example,
    let''s compare cloning a `String` with taking a reference to it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基准测试，你必须添加一个带有`#[bench]`属性的函数。该函数期望有一个对`Bencher`实例的可变引用。例如，让我们比较克隆一个`String`与对其取引用：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To benchmark, you have to provide a closure with a code you want to measure
    to the `iter` method of the `Bencher` instance. You also need to add a `test`
    feature with `#![feature(test)]` to testing module and use `extern crate test`
    to import `test` crate to import the `Bencher` type from this module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行基准测试，你必须向`Bencher`实例的`iter`方法提供一个你想要测量的代码闭包。你还需要在测试模块中添加带有`#![feature(test)]`的`test`功能，并使用`extern
    crate test`来导入`test`包，从而从这个模块中导入`Bencher`类型。
- en: The `bench_clone` function has a `String` value and clones it on every measurement
    by `Bencher`. In `bench_ref`, we take a reference to a `String` value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`bench_clone`函数有一个`String`值，并且由`Bencher`在每次测量时克隆它。在`bench_ref`中，我们取一个`String`值的引用。'
- en: 'Now you can start a benchmark test with `cargo`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`cargo`启动基准测试：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It compiles the code for testing (the code items with the `#[cfg(test)]`  attribute
    will be activated) and then runs the benchmarks. For our examples, we have the
    following results:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它会为测试编译代码（带有`#[cfg(test)]`属性的代码项将被激活），然后运行基准测试。对于我们的示例，我们得到了以下结果：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we expected, taking the reference to a `String` takes no time, but the cloning
    of a `String` takes `32` nanoseconds per call of the `clone` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，取`String`的引用不耗时，但`String`的克隆每次调用`clone`方法需要`32`纳秒。
- en: Remember, you can do good benchmark testing for CPU-bound tasks, but not I/O-bound
    tasks, because I/O tasks are more dependent on the quality of hardware and operating
    system performance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以对 CPU 密集型任务进行良好的基准测试，但不能对 I/O 密集型任务进行基准测试，因为 I/O 任务更多地依赖于硬件质量和操作系统性能。
- en: If you want to benchmark the operation of some functions in the running application,
    then you have to use a profiler. Let's try to analyze some code with a profiler.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想基准测试运行应用程序中某些函数的操作，那么您必须使用分析器。让我们尝试使用分析器分析一些代码。
- en: Profiling
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: Benchmark tests are useful for checking a portion of code, but they are not
    suitable for checking the performance of a working application. If you need to
    explore the performance of some of the functions of the code, you have to use
    a profiler.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试对于检查代码的一部分很有用，但它们不适合检查运行应用程序的性能。如果您需要探索代码中某些函数的性能，您必须使用分析器。
- en: Profilers dump information about code and function executions and record the time
    spans during which the code works. There is a profiler in the Rust ecosystem called
    **flame**. Let's explore how to use it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器会导出有关代码和函数执行的信息，并记录代码工作的时间跨度。Rust 生态系统中有一种名为 **flame** 的分析器。让我们探索如何使用它。
- en: 'Profiling takes time and you should use it as a feature to avoid affecting
    performance in production installations. Add the `flame` crate to your project
    and use it as an optional. Add a feature (such as the official examples from the `flamer`
    crate repository; I named the feature `flame_it`) and add the flame dependency
    to it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分析需要时间，您应该将其作为一个功能来避免在生产安装中影响性能。将 `flame` 包添加到您的项目中，并作为可选使用。添加一个功能（例如来自 `flamer`
    包仓库的官方示例；我将其命名为 `flame_it`），并将 `flame` 依赖项添加到其中：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if you want to activate profiling, you have to compile the project with
    the `flame_it` feature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想激活分析，您必须使用 `flame_it` 功能编译项目。
- en: 'Using the `flame` crate is pretty simple and includes three scenarios:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flame` 包非常简单，包括三个场景：
- en: Use the `start` and `end` methods directly.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用 `start` 和 `end` 方法。
- en: Use the `start_guard` method, which creates a `Span` that is used to measure
    execution time. A `Span` instance ends measurement automatically when it's dropped.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `start_guard` 方法，它创建一个用于测量执行时间的 `Span`。当 `Span` 实例被丢弃时，自动结束测量。
- en: Use `span_of` to measure code isolated in a closure.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `span_of` 来测量在闭包中隔离的代码。
- en: 'We will use spans like we did in the `OpenTracing` example in [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing
    and Debugging Rust Microservices*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像在 [第 13 章](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml) 的 `OpenTracing` 示例中所做的那样使用跨度：*测试和调试
    Rust 微服务*：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You don't need to collect spans or send them to `Receiver`, as we did for Jaeger,
    but profiling with `flame` looks like tracing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要收集跨度或将它们发送到 `Receiver`，就像我们为 Jaeger 所做的那样，但使用 `flame` 进行分析看起来像是跟踪。
- en: At the end of the execution, you have to dump a report in the appropriate format,
    such as  HTML or JSON, print it to a console, or write it to a `Writer` instance.
    We used the first three of them. We have implemented the main function and used
    the `start_quard` method to create `Span` instances to measure the execution time
    of some pieces of the code. After this, we will write reports.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行结束时，您必须以适当的格式导出报告，例如 HTML 或 JSON，将其打印到控制台，或写入 `Writer` 实例。我们使用了前三个。我们实现了主函数，并使用
    `start_quard` 方法创建 `Span` 实例来测量一些代码片段的执行时间。之后，我们将编写报告。
- en: 'Compile and run this example with the activated profiling feature:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已激活的分析功能的示例编译并运行此示例：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding command compiles and prints the report to the console:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令编译并打印报告到控制台：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we have created three spans. You can also find two reports
    in files, `out.json` and `out.html`. If you open the HTML report in a browser,
    it renders like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了三个跨度。您也可以在文件中找到两个报告，`out.json` 和 `out.html`。如果您在浏览器中打开 HTML 报告，它将呈现如下：
- en: '![](img/1ec7f264-3641-4908-80e4-9f0bc1cf6c18.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ec7f264-3641-4908-80e4-9f0bc1cf6c18.png)'
- en: In the preceding screenshot, you can see the relative duration of execution
    of every activity of our program. A longer colored block means longer execution
    time. As you can see, profiling is useful for finding a slow section of code that
    you can optimize with other techniques.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到我们程序每个活动的相对执行时间。颜色较深的块表示执行时间较长。如您所见，分析对于找到可以优化其他技术的慢速代码部分很有用。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed optimizations. First, we explored tools for measuring
    performance—Welle, which is an alternative to the classic **Apache Benchmarking
    tool**, and Drill, which uses scripts to perform load tests.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了优化。首先，我们探索了用于测量性能的工具——Welle，它是经典**Apache基准测试工具**的替代品，以及Drill，它使用脚本执行负载测试。
- en: Then we created a tiny microservice and measured its performance. Focusing on
    results, we applied some optimizations to that microservice—we avoided blocking
    a shared state for reading, we reused a value by a reference instead of cloning
    it, and we added the caching of rendered templates. Then we measured the performance
    of the optimized microservice and compared it with the original version.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个微小的微服务并测量了其性能。专注于结果，我们对那个微服务进行了一些优化——我们避免了在读取共享状态时阻塞，我们通过引用重用了一个值而不是克隆它，我们还增加了渲染模板的缓存。然后我们测量了优化后的微服务的性能，并将其与原始版本进行了比较。
- en: In the last section of this chapter, we got acquainted with alternative techniques
    of optimization—using LTO, aborting execution without backtracing instead of panicking,
    reducing the size of a compiled binary, benchmarking small pieces of code, and
    using profiling for your projects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们了解了优化的一些替代技术——使用LTO，在无需回溯的情况下终止执行而不是恐慌，减小编译二进制文件的大小，对代码的小片段进行基准测试，以及使用性能分析为你的项目服务。
- en: In the next chapter, we will look at creating images with Rust microservices
    using Docker to run microservices in containers with preconfigured environments
    to speed up delivery of your product to customers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Docker创建带有Rust微服务的镜像，以在预配置的环境中运行微服务，从而加快产品交付给客户的速度。
