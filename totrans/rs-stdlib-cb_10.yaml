- en: Using Experimental Nightly Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over an inclusive range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning abstract types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering strings efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through an iterator in regular intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This final chapter leads us to the most important experimental features in
    Rust, provided on the newest `nightly` toolchain. As of the time of writing, this
    is `rustc 1.25.0-nightly`. If you are using `rustup` ([https://rustup.rs/](https://rustup.rs/)),
    you can set it as your default toolchain like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These recipes will ensure that you stay ahead in your knowledge of Rust, and
    are ready to use them effectively once they are stabilized, or right now in your
    own unstable apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the recipes in this chapter have varying stability guarantees. Many
    will undergo drastic changes before they land in the `stable` toolchain, and others
    are nearly done. This means that some of the example code provided is expected
    not to work on your newest `nightly`. When this happens, you can find help in
    two places:'
  prefs: []
  type: TYPE_NORMAL
- en: If the feature is still experimental, it will have an entry in *The Unstable
    Book* ([https://doc.rust-lang.org/unstable-book/](https://doc.rust-lang.org/unstable-book/)),
    and a link to the relevant GitHub issue and its surrounding discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the feature has been stabilized, there is a good chance you will find it
    listed in the appendix of *The Rust Programming Language, Second Edition* ([https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html](https://doc.rust-lang.org/stable/book/second-edition/appendix-06-newest-features.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over an inclusive range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin the chapter with a small feature that can make your code a bit more
    readable. The inclusive range syntax (`..=`) will create a range up to a value
    *including* it. This helps you eliminate ugly instances of things like `n .. m+1`
    by rewriting them as `n ..= m`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-ten`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly-created `chapter-ten` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `src` folder, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `inclusive_range.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin inclusive_range`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, the code is the promised rewrite of a snippet in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*; *Accessing collections as iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional range syntax (`n .. m`) is exclusive, meaning that `0 .. 5`
    will only include the numbers 0, 1, 2, 3, and 4\. This is good for uses cases
    where you count up to a length of something, but in our case, we want to iterate
    over the alphabet, including Z [5]. The inclusive range syntax (`n ..= m`) helps
    us by including the last element, so that `0 ..= 5` will yield 0, 1, 2, 3, 4,
    and 5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Accessing collections as iterators* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we used `Box` to create trait objects in order to hide the exact
    implementation returned, and instead only give guarantees about implemented traits?
    That required us to accept some overhead, as a `Box` allocates its resources on
    the heap; however, on the current `nightly`, things are different. You can use
    the `impl trait` syntax introduced in this recipe to return objects as their trait
    directly on the stack, all without boxes. At the moment, this only works for returned
    types, but the syntax is planned to be extended to most places where you could
    write a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `return_abstract.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin return_abstract`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've read [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*; *Boxing data*, this recipe doesn't need much explanation. By
    returning an `impl trait`, we tell the caller of a function to not care about
    the specific struct that is returned, and that its only guarantee about it is
    that it implements some trait. In this sense, abstract return types work like
    the trait objects discussed in the said recipe, with the added bonus of being
    way faster, as they don't have any overhead. This is useful for returning iterators
    [37] and closures [43], which we adapted from the recipe about boxes, but also
    to hide implementation details. Consider our function `create_animal`[32]. A caller
    will only care that it returns a struct that implements `Animal`, but not which
    exact animal. If a `Dog` [7] doesn't prove to be the right thing because of changing
    requirements, you can create a `Cat`, and return that one without touching the
    rest of the code, as it all just depends on `Animal`. This is a form of *dependency
    inversion* ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)).
  prefs: []
  type: TYPE_NORMAL
- en: The `conservative` in `conservative_impl_trait` [1] tells us that this is just
    a part of a bigger feature. At the moment, you can only use it in return types
    of functions. In the future, you'll be able to use it in traits, constraints,
    and bindings as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the recipes in this chapter, this one is probably the most stable, as
    it is being considered for immediate stabilization. The discussion can be found
    at [https://github.com/rust-lang/rust/issues/34511.](https://github.com/rust-lang/rust/issues/34511)
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use abstract return types for some forms of dependency inversion,
    you cannot use them for traditional Java-style factories that return different
    objects depending on a parameter. This is because abstract return types only hide
    the specific struct returned on the outside of the function, but still internally
    rely on a specific return value. Because of this, the following code will not
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While the outside world doesn''t know which animal is going to be returned
    by `create_animal`, the function itself needs a specific return type internally.
    Because the first possible return from our match is an instance of `Cat`, `create_animal`
    assumes that we are going to return no other type. We break that expectation in
    the next line by returning a `Dog`, so the compiler fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eeed4e9-fed8-46e6-bbf9-94318249d556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want this factory to compile, we need to resort back to `Box` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By the way, this is also exactly what Java does under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: For most purposes, you won't need a factory such as the one presented here.
    It is considered more idiomatic to use generics with trait bounds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we have now learned how to return arbitrary closures with no overhead,
    we can combine that with macros that accept any number of parameters ([Chapter
    1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*; *Accepting
    a variable number of arguments*) to create an easy way to chain actions as you
    would be used to in functional languages such as *Haskell*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `compose_functions.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin compose_functions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the usage of `compose!` in main [30 and 34], you should see clearly what
    it does: it takes as many closures as you want, and combines them into a new closure
    that runs them one by one. This is really useful for runtime user-driven functionality
    composition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro is implemented similarly to the standard macro for variable arguments
    from [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*;
    *Accepting a variable number of arguments*, with its edge case being a single
    closure [6]. When encountering more, it will recursively go through them and combine
    them in pairs by calling the helper function `compose_two` [14]. Usually, type
    parameters are written as a single character, but we are using full words for
    them in this recipe for readability reasons, as there are quite a number of types
    involved. The type constraints used should illustrate how the types are used pretty
    well [18 to 20]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`FunOne` is a closure that takes an `Input`, turns it into an `Intermediate`,
    and passes it to `FunTwo`, which returns an `Output`. As you can see from the
    implementation, the only thing we do is call `fun_one` on a value, and then call
    `fun_two` on its returned value [22]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Accepting a variable number of arguments* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering strings efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can filter characters out of a `String` on the stable channel already,
    this requires creating a new `String` with the filtered characters. On `nightly`,
    you can do this in place of the same `String`, helping you a lot with performance
    if you need to perform this kind of action many, many times, or on very large
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `retain_string.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin retain_string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*;
    *Using a Vector*, we learned about `Vec::retain`, which filters a vector in place.
    On the `nightly` toolchain, this functionality has arrived in `String` and works
    the same way, as if a `String` was a `Vec<char>—`which, if you think about it,
    it really is.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of filtering a `String` was always there, but it required
    going over the string as an `Iterator` and creating a new `String` with the filtered
    characters; or worse yet, converting a `String` to a newly-created `Vec<char>`,
    using `retain` on it, and then converting the chars back into another newly-created
    `String`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using a vector* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through an iterator in regular intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wanted to step through data by only looking at every nth item?
    On stable Rust, the best solution to this problem is using the third-party crate
    `itertools` ([https://crates.io/crates/itertools](https://crates.io/crates/itertools)),
    which brings you a whole lot of iterator goodies, or allows you to code the functionality
    yourself; however, you have a built-in `step_by` method doing exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `iterator_step_by.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin iterator_step_by`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe shines when you are being handed an unstructured data stream that
    follows a certain pattern. For example, sometimes some old APIs that don''t use
    JSON, or other programs you might want to interact with, hand you streams of data
    that are grouped by position, like the data we stored in `grouped_stream`[15],
    which follows the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`step_by` lets us parse this structure very easily. It works by handing you
    current element, and then skipping a certain amount of elements on every iteration.
    In our example, we parse `grouped_stream` by first creating an iterator over every
    substring that is not whitespace with `split_whitespace` [17], then, because we
    are only interested in the weights, `skip` the first two elements (`"Aaron"` and
    `"182cm"`), which places our iterator at `"70kg"`. We then tell the iterator to
    only look at every third element from now on with `step_by(3)` [19], resulting
    in us iterating over `"70kg"`, `"90kg"`, and `"83kg"`. Finally, we `collect` the
    elements into a vector [20].'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using a string* and *Accessing collections as iterators* recipes in [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust project has developed a testing crate for the compiler itself. Because
    it includes some quite useful features, most importantly a benchmarker, it is
    accessible on nightly builds as the built-in `test` crate. Because it gets shipped
    with every nightly build, you don't need to add it to your `Cargo.toml` to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The `test` crate is marked unstable because of its tight coupling to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `benchmarking.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo bench`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running benchmarks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bread and butter of the `test` crate is the `Bencher` struct [59]. An instance
    of it is passed automatically to every function annotated with the `#[bench]`
    attribute [63] when running `cargo bench`. Its `iter` method takes a closure [65],
    and runs it multiple times to determine how long one iteration of it takes. While
    doing this, it also discards time measurements that are far off the others to
    eliminate one-off extremes.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful part of the `test` crate is its `black_box` struct [68], which
    wraps any value and tells the compiler and LLVM to not optimize it away, no matter
    what. If we didn't use it in our benchmarks, they might get optimized away and
    result in a rather optimistic and unhelpful measurement of 0 ns/iter, or zero
    nanoseconds per execution of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the tools at our disposal to test out some theories. Remember the
    recursive **Fibonacci** implementation discussed in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Running two operations together*? Well, it is repeated
    here as `slow_fibonacci_recursive`[6].
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation is slow because both calls to `slow_fibonacci_recursive(n
    - 1)` and  `slow_fibonacci_recursive(n - 2)` need to recalculate *all* values
    individually. Worse yet, every call also splits up into a call to `slow_fibonacci_recursive(n
    - 1)` and  `slow_fibonacci_recursive(n - 2)` once more, recalculating everything
    again and again! In terms of *Big O*, this is an efficiency of ![](img/f67731c7-d87b-4a16-aa3c-756bc09bec79.png)
    (proof at [https://stackoverflow.com/a/360773/5903309](https://stackoverflow.com/a/360773/5903309)).
    In comparison, the imperative algorithm, `fibonacci_imperative` [14] is a simple
    loop, so it''s at ![](img/2dafef58-b819-4df9-bb92-6dcbb8defb4e.png). By this theory,
    it should be *a lot* faster than the slow, recursive one. Running `cargo bench`
    lets us verify these assertions easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c2847a-9095-4c00-bdb2-1c84cd3364e1.png)'
  prefs: []
  type: TYPE_IMG
- en: What a difference! On my computer, the slow, recursive implementation is more
    than 7,000 times slower than the imperative one! Surely, we can do better.
  prefs: []
  type: TYPE_NORMAL
- en: '**StackOverflow** user **Boiethios** helpfully provided us with `memoized_fibonacci_recursive`
    at [https://stackoverflow.com/a/49052806/5903309](https://stackoverflow.com/a/49052806/5903309).
    As the name suggests, this implementation uses a concept known as *memoization*.
    This means that the algorithm has some way of passing around already-calculated
    values. An easy way of doing this would be to pass around a `HashMap` with all
    calculated values, but that would again bring its own overhead, as it operates
    on the heap. Instead, we go for the route of *accumulators*. This means that we
    just pass the relevant values directly as parameters, which in our case are `penultimate`,
    which represents the Fibonacci of `n-2`, and `last`, which represents the Fibonacci
    of `n-1`. If you want to read more about these functional concepts, check out
    [http://www.idryman.org/blog/2012/04/14/recursion-best-practices/](http://www.idryman.org/blog/2012/04/14/recursion-best-practices/).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the benchmarks, we can see that we managed to improve the algorithm
    quite a bit with `memoized_fibonacci_recursive`. But it's still a bit slower than
    `fibonacci_imperative`. One of many possible ways to further improve the algorithm
    is by extracting the `n == 1` match that would be checked in every recursive call
    outside, as demonstrated in `fast_fibonacci_recursive` [43], which clocks in at
    a great three nanoseconds per iteration!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our implementation also employs another optimization: *tail call* *optimization*,
    or *TCO* for short. In oversimplified terms, TCO happens when the compiler is
    able to rewrite a recursive algorithm into an imperative one. More generally,
    TCO is when the compiler can compile a recursive call into a form that doesn''t
    add a new stack frame per call, and as a consequence, can''t cause a stack overflow
    (not the website, but the error). For a good discussion on the topic, see [https://stackoverflow.com/questions/310974/what-is-tail-call-optimization](https://stackoverflow.com/questions/310974/what-is-tail-call-optimization).'
  prefs: []
  type: TYPE_NORMAL
- en: Although Rust doesn't support TCO per se (see the RFC at [https://github.com/rust-lang/rfcs/issues/271](https://github.com/rust-lang/rfcs/issues/271)),
    the lower-level LLVM does. It requires the last call of a function to be a call
    to itself. The last line of `inner` [40] is a call to `inner`, so it's eligible
    for TCO.
  prefs: []
  type: TYPE_NORMAL
- en: This is somewhat hard to guarantee in bigger Rust algorithms, though, as objects
    implementing the `Drop` trait will inject a call to `drop()` at the end of a function,
    removing any possibility of TCO.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Running two operations together* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest concept that is still not quite usable yet in Rust is *easy async*.
    One reason for that is a lack of compiler support for certain things, which is
    being worked on right now. One important part of the road to async is *generators*,
    which are implemented similarly to how they're used in C# or Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `generator.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin generator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Generator` is currently defined as any closure that uses the new `yield`
    keyword. When it is executed with `.resume()` [11], it will run until it hits
    a `yield`. If run again, the generator will continue where it left off until it
    reaches another `yield` or encounters a `return`. If there are no more yields
    left in the generator, it will simply return an empty tuple, behaving as if encountering
    `return ();`.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are two scenarios of what a generator does (`yield` vs `return`),
    you have to check the result of `.resume()` every time you use it, as it could
    be `GeneratorState::Yielded` or `GeneratorState::Complete`.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, you can `return` a different type than you `yield`.
    The situation around this is somewhat unclear, as the reason for this quirk is
    the aforementioned convention to `return ();` when running out of yields. Maybe
    the final version of generators in Rust will not rely on this behavior, and only
    allow returning the same type as yielding. You can find the discussion about this
    and more at [https://github.com/rust-lang/rust/issues/43122](https://github.com/rust-lang/rust/issues/43122).
  prefs: []
  type: TYPE_NORMAL
- en: Besides async, another big use case for generators is iterators. So much so
    that the Rust standard library iterators are planned to eventually be rewritten
    with generators. At the moment, the exact way of how this transition should happen
    has not been figured out, so there is no generic implementation of `Iterator for
    Generator`. To work around this, you can create a little wrapper type like we
    did with `GeneratorIterator`[50], which implements `Iterator` for its wrapped
    `Generator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We illustrate how to use it by rewriting the Fibonacci iterator from [Chapter
    2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working with Collections*; *Creating
    an own iterator,* with a generator in the `fibonacci` function [64]. The implementation
    looks pretty clean, doesn''t it? As a reminder, here is how we wrote the original
    implementation using the `Iterator` trait directly, which not only needed a function,
    but also a `struct` and a trait implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating an own iterator* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
