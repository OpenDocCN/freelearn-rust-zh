- en: Application Layer Protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层协议
- en: As we saw in the previous few chapters, two hosts in a network exchange bytes,
    either in a stream or in discrete packets. It is often up to a higher-level application
    to process those bytes to something that makes sense to the application. These
    applications define a new layer of protocol over the transport layer, often called
    application layer protocols. In this chapter, we will look into some of those
    protocols.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中看到的，网络中的两个主机在流或离散的包中交换字节。通常，这些字节的处理工作由高级应用程序来完成，使其对应用程序有意义。这些应用程序在传输层之上定义了一个新的协议层，通常称为应用层协议。在本章中，我们将探讨这些协议中的一些。
- en: 'There are a number of important considerations for designing application layer
    protocols. An implementation needs to know at least the following details:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用层协议时有许多重要的考虑因素。实现需要至少了解以下详细信息：
- en: Is the communication broadcast or point-to-point? In the first case, the underlying
    transport protocol must be UDP. In the second case, it can be either TCP or UDP.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信是广播还是点对点？在前一种情况下，底层传输协议必须是UDP。在后一种情况下，可以是TCP或UDP。
- en: Does the protocol need a reliable transport? If yes, TCP is the only option.
    Otherwise, UDP might be suitable, too.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议需要可靠的传输吗？如果是，TCP是唯一的选择。否则，UDP也可能适用。
- en: Does the application need a byte stream (TCP), or can it work on packet-by-packet
    basis (UDP)?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要字节流（TCP）吗，还是可以按包逐个处理（UDP）？
- en: What signals the end of input between the parties?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双方之间如何表示输入的结束？
- en: What is the data format and encoding used?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的数据格式和编码是什么？
- en: Some very commonly used application layer protocols are DNS (which we studied
    in the previous chapters) and HTTP (which we will study in a subsequent chapter).
    Other than these, a very important application layer toolset commonly used for
    microservice-based architectures is gRPC. Another application layer protocol everyone
    has used at least a few times is SMTP, the protocol that powers email.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些非常常用的应用层协议包括DNS（我们在前面的章节中学习过）和HTTP（我们将在下一章学习）。除此之外，一个非常重要的应用层工具集，常用于基于微服务的架构，是gRPC。另一个每个人至少使用过几次的应用层协议是SMTP，这是电子邮件的协议。
- en: 'In this chapter, we will study the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下主题：
- en: How RPC works. Specifically, we will look at gRPC and write a small server and
    client using the toolkit.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC是如何工作的。具体来说，我们将探讨gRPC，并使用工具包编写一个小的服务器和客户端。
- en: We will take a look at a crate caller `lettre` that can be used to send emails
    programmatically.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将查看一个可以用于发送电子邮件的crate调用`lettre`。
- en: The last topic will be on writing a simple FTP client and a TFTP server in Rust.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个主题将是用Rust编写一个简单的FTP客户端和TFTP服务器。
- en: Introduction to RPC
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC简介
- en: In regular programming, it is often useful to encapsulate frequently used logic
    in a function so that it can be reused in multiple places. With the rise of networked
    and distributed systems, it became necessary to let a common set of operations
    be accessible over a network, so that validated clients can call them. This is
    often called a **Remote Procedure Call** (**RPC**). In [Chapter 4](part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287)*,* *Data
    Serialization, De-Serialization, and Parsing*, we saw a simple example of this
    when a server returned the distance of a given point from the origin. Real world
    RPC has a number of application layer protocols defined, which are far more complex.
    One of the most popular RPC implementations is gRPC, which was initially introduced
    by Google and later moved to an open source model. gRPC offers high performance
    RPC over internet scale networks and is widely used in a number of projects, including
    Kubernetes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规编程中，将常用逻辑封装在函数中通常很有用，这样就可以在多个地方重用。随着网络化和分布式系统的兴起，让一组公共操作可以通过网络访问变得必要，这样经过验证的客户端就可以调用它们。这通常被称为**远程过程调用**（RPC）。在[第4章](part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287)*，*数据序列化、反序列化和解析*中，我们看到了一个简单的例子，当服务器返回给定点与原点的距离时。现实世界的RPC定义了许多应用层协议，这些协议要复杂得多。最受欢迎的RPC实现之一是gRPC，它最初由谷歌引入，后来转为开源模式。gRPC在互联网规模网络上提供高性能RPC，并被广泛应用于许多项目中，包括Kubernetes。
- en: 'Before digging deeper into gRPC, let''s look at protocol buffers, a related
    tool. It is a set of mechanisms to build language and platform neutral exchanging
    structured data between applications. It defines its own **Interface Definition
    Language** (**IDL**) to describe the data format, and a compiler that can take
    that format and generate code to convert to and from it. The IDL also allows for
    defining abstract services: input and output message formats that the compiler
    can use to generate stubs in a given language. We will see an example of a definition
    of a data format in a subsequent example. The compiler has plugins to generate
    output code in a large number of languages, including Rust. In our example, we
    will use such a plugin in a build script to autogenerate Rust modules. Now, gRPC
    uses protocol buffers to define the underlying data and messages. Messages are
    exchanged over HTTP/2 on top of TCP/IP. This mode of communication is often faster
    in practice, since it can make better use of existing connections, and also since
    HTTP/2 supports bidirectional asynchronous connections. gRPC, being an opinionated
    system, makes a lot of assumptions about the considerations we discussed in the
    previous section, on our behalf. Most of these defaults (like HTTP/2 over TCP)
    were chosen because they support the advanced features gRPC offers (like bidirectional
    streaming). Some other defaults, like using `protobuf`, can be swapped for another
    message format implementation.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究gRPC之前，让我们看看相关的工具——协议缓冲区。它是一套机制，用于在应用程序之间构建语言和平台中立的交换结构化数据。它定义了自己的**接口定义语言**（**IDL**）来描述数据格式，以及一个可以将该格式转换为代码并生成代码以进行转换的编译器。IDL还允许定义抽象服务：编译器可以用来生成给定语言的存根的输入和输出消息格式。我们将在后续示例中看到一个数据格式定义的例子。编译器有插件可以生成大量语言的输出代码，包括Rust。在我们的示例中，我们将在构建脚本中使用这样的插件来自动生成Rust模块。现在，gRPC使用协议缓冲区来定义底层数据和消息。消息在TCP/IP之上通过HTTP/2进行交换。在实践中，这种通信模式通常更快，因为它可以更好地利用现有连接，并且HTTP/2支持双向异步连接。gRPC作为一个有偏见的系统，代表我们做出了许多关于我们在上一节讨论的考虑的假设。大多数这些默认值（如HTTP/2通过TCP）都是因为它们支持gRPC提供的先进功能（如双向流）。一些其他默认值，如使用`protobuf`，可以与其他消息格式实现交换。
- en: For our gRPC example, we will build a service that is a lot like Uber. It has
    a central server where clients (cabs) can record their names and locations. And
    then, when a user requests a cab with their location, the server sends back a
    list of cabs near that user. Ideally, this server should have two classes of clients,
    one for cabs and one for users. But for simplicity's sake, we will assume that
    we have only one type of client.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的gRPC示例，我们将构建一个类似于Uber的服务。它有一个中央服务器，客户端（出租车）可以记录他们的名字和位置。然后，当用户请求出租车并给出他们的位置时，服务器会发送一个靠近该用户的出租车列表。理想情况下，这个服务器应该有两个客户端类别，一个用于出租车，一个用于用户。但为了简单起见，我们将假设我们只有一种类型的客户端。
- en: 'Let us start with setting up the project. Like always, we will use Cargo CLI
    to initialize the project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置项目开始。像往常一样，我们将使用Cargo CLI初始化项目：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following script is our build script. It is simply a Rust executable (which
    has a main function) that Cargo builds and runs right before calling the compiler
    on the given project. Note that the default name for this script is `build.rs`,
    and it must be located in the project root. However, these parameters can be configured
    in the Cargo config file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是我们的构建脚本。它只是一个Rust可执行文件（具有主函数），Cargo在调用给定项目的编译器之前构建并运行它。请注意，此脚本的默认名称为`build.rs`，并且它必须位于项目根目录中。然而，这些参数可以在Cargo配置文件中进行配置：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One of the most common use cases for build scripts is code generation (like
    our current project). They can also be used to find and configure native libraries
    on the host, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本最常见的使用案例之一是代码生成（如我们当前的项目）。它们还可以用于在主机上查找和配置本地库等。
- en: 'In the script, we use the `protoc_rust_grpc` crate to generate Rust modules
    from our `proto` file (called `foobar.proto`). We also set the `rust_protobuf`
    flag to make it generate protobuf messages. Note that the `protoc` binary must
    be available in `$PATH` for this to work. This is a part of the protobuf package.
    Follow these steps to install it from the source:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们使用`protoc_rust_grpc`包来从我们的`proto`文件（称为`foobar.proto`）生成Rust模块。我们还设置了`rust_protobuf`标志以使其生成protobuf消息。请注意，`protoc`二进制文件必须在`$PATH`中可用才能正常工作。这是protobuf包的一部分。按照以下步骤从源代码安装它：
- en: 'Download the pre-built binaries from GitHub:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载预构建的二进制文件：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unzip the archive:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩存档：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copy the binary to somewhere in `$PATH`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制文件复制到 `$PATH` 中的某个位置：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This current example has been tested on Ubuntu 16.04 with protoc version 3.5.1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当前示例已在 Ubuntu 16.04 上使用 protoc 版本 3.5.1 进行了测试。
- en: 'Next, we will need the protocol definition, as shown in the following code
    snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要协议定义，如下代码片段所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The proto file starts with a declaration of the version of protobuf IDP spec;
    we will be using version 3\. The package declaration indicates that all the generated
    code will be placed in a Rust module called `foobar`, and all other generated
    code will be placed in a module called `foobar_grpc`. We define a service called `FooBarService`
    that has two RPC functions; `record_cab_location` records the location of a cab,
    given its name and location, and `get_cabs` returns a set of cabs, given a location.
    We will also need to define all associated `protobuf` messages for each of the
    requests and responses. The spec also defines a number of built-in data types
    that closely correspond to those in a programming language (string, float, and
    so on).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: proto 文件以 protobuf IDP 规范版本的声明开始；我们将使用版本 3。包声明表明所有生成的代码都将放置在一个名为 `foobar` 的
    Rust 模块中，所有其他生成的代码都将放置在一个名为 `foobar_grpc` 的模块中。我们定义了一个名为 `FooBarService` 的服务，它有两个
    RPC 函数；`record_cab_location` 记录出租车的位置，给定其名称和位置，而 `get_cabs` 返回一组出租车，给定一个位置。我们还需要为每个请求和响应定义所有相关的
    `protobuf` 消息。规范还定义了多个与编程语言中的数据类型（字符串、浮点数等）紧密对应的自定义数据类型。
- en: 'Having set up everything related to the `protobuf` message formats and functions,
    we can use Cargo to generate actual Rust code. The generated code will be located
    in the `src` directory and will be called `foobar.rs` and `foobar_grpc.rs`. These
    names are automatically assigned by the compiler. The `lib.rs` file should re-export
    those using the pub mod syntax. Note that Cargo build will not modify the `lib.rs`
    file for us; that needs to be done by hand. Let us move on to our server and client.
    Here is what the server will look:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好与 `protobuf` 消息格式和函数相关的一切之后，我们可以使用 Cargo 生成实际的 Rust 代码。生成的代码将位于 `src` 目录中，并命名为
    `foobar.rs` 和 `foobar_grpc.rs`。这些名称由编译器自动分配。`lib.rs` 文件应使用 pub mod 语法重新导出这些模块。请注意，Cargo
    构建不会为我们修改 `lib.rs` 文件；这需要手动完成。让我们继续我们的服务器和客户端。以下是服务器的外观：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that this server is very different from the servers we wrote in previous
    chapters. This is because `grpc::ServerBuilder` encapsulates a lot of the complexity
    in writing servers. `FooBarService` is the service `protobuf` compiler generated
    for us, defined as a trait in the file `foobar_grpc.rs`. As expected, this trait
    has two methods: `record_cab_location` and `get_cabs`. Thus, for our server, we
    will need to implement this trait on a struct and pass that struct to `ServerBuilder`
    to run on a given port.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个服务器与我们之前章节中编写的服务器非常不同。这是因为 `grpc::ServerBuilder` 封装了编写服务器时的大部分复杂性。`FooBarService`
    是为我们生成的 `protobuf` 编译器服务，在 `foobar_grpc.rs` 文件中定义为 trait。正如预期的那样，这个 trait 有两个方法：`record_cab_location`
    和 `get_cabs`。因此，对于我们的服务器，我们需要在一个结构体上实现这个 trait 并将其传递给 `ServerBuilder` 以在指定的端口上运行。
- en: In our toy example, we will not actually record cab locations. A real world
    app would want to put these in a database to be looked up later. Instead, we will
    just print a message saying that we received a new location. We also need to work
    with some boilerplate code here, to make sure all gRPC semantics are fulfilled.
    In the `get_cabs` function, we always return a static list of cabs for all requests.
    Note that since all `protobuf` messages are generated for us, we get a bunch of
    utility functions, like `get_name` and `get_location`, for free. Finally, in the
    `main` function, we pass our server struct to gRPC to create a new server on a
    given port and run it on an infinite loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的玩具示例中，我们实际上不会记录出租车位置。一个真实世界的应用会希望将这些信息存储在数据库中以供以后查询。相反，我们只需打印一条消息，说明我们收到了一个新的位置。我们还需要处理一些样板代码，以确保所有
    gRPC 语义都得到满足。在 `get_cabs` 函数中，我们总是为所有请求返回一个静态的出租车列表。请注意，由于所有 `protobuf` 消息都是为我们生成的，我们免费获得了一些实用函数，如
    `get_name` 和 `get_location`。最后，在 `main` 函数中，我们将我们的服务器结构传递给 gRPC，在指定的端口上创建一个新的服务器并无限循环运行它。
- en: 'Our client is actually defined as a struct in the source generated by the `protobuf`
    compiler. We just need to make sure the client has the same port number we are
    running our server on. We use the `new_plain` method on the client struct and
    pass an address and port to it, along with some default options. We can then call
    the `record_cab_location` and `get_cabs` methods over RPC and process the responses:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端实际上是在由 `protobuf` 编译器生成的源代码中定义为一个结构体。我们只需要确保客户端具有与我们运行服务器相同的端口号。我们使用客户端结构体的
    `new_plain` 方法，并传递一个地址和端口号给它，以及一些默认选项。然后我们可以通过 RPC 调用 `record_cab_location` 和
    `get_cabs` 方法并处理响应：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is how a run of the client will look like. As noted before, this is not
    as dynamic as it should be, since it returns only hardcoded values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端运行的过程如下。如前所述，这并不像应有的那样动态，因为它只返回硬编码的值：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice how it exits right after talking to the server. The server, on the other
    hand, runs in an infinite loop, and does not exit till it gets a signal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它在与服务器通信后立即退出。另一方面，服务器在一个无限循环中运行，直到接收到信号才退出：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Introduction to SMTP
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP 简介
- en: 'Internet email uses a protocol called **Simple Mail Transfer Protocol **(**SMTP**),
    which is an IETF standard. Much like HTTP, it is a simple text protocol over TCP,
    using port `25` by default. In this section, we will look at a small example of
    using `lettre` for sending emails. For this to work, let us set up our project
    first:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网电子邮件使用一种称为 **简单邮件传输协议（SMTP**）的协议，这是一个 IETF 标准。与 HTTP 类似，它是一个简单的基于 TCP 的文本协议，默认使用端口
    `25`。在本节中，我们将查看使用 `lettre` 发送电子邮件的小示例。为了使这成为可能，让我们首先设置我们的项目：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, our `Cargo.toml` file should look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `Cargo.toml` 文件应该看起来像这样：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s say we want to send crash reports for a server automatically. For this
    to work, we need to have an SMTP server running somewhere accessible. We also
    need to have a user who can authenticate using a password set up on that server.
    Having set those up, our code will look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要自动发送服务器的崩溃报告。为了实现这一点，我们需要有一个可访问的 SMTP 服务器在运行。我们还需要有一个用户，可以使用在该服务器上设置的密码进行身份验证。设置好这些后，我们的代码将看起来像这样：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our email is represented by the `CrashReport` struct; as expected, it has a
    `from` email address. The `to` field is a vector of email addresses, enabling
    us to send an email to multiple addresses. We implement a constructor for the
    struct. The crate `lettre` defines a trait called `SendableEmail` that has a bunch
    of properties an SMTP server needs to send an email. For a user-defined email
    to be sendable, it needs to implement that trait. In our case, `CrashReport` needs
    to implement it. We go on to implement all required methods in the trait. At this
    point, a new instance of `CrashReport` should be sendable as an email.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子邮件由 `CrashReport` 结构体表示；正如预期的那样，它有一个 `from` 发件人电子邮件地址。`to` 字段是一个电子邮件地址的向量，使我们能够向多个地址发送电子邮件。我们为该结构体实现了一个构造函数。`lettre`
    包含一个名为 `SendableEmail` 的特质，它具有 SMTP 服务器发送电子邮件所需的一组属性。为了使用户定义的电子邮件可发送，它需要实现该特质。在我们的例子中，`CrashReport`
    需要实现它。我们继续实现特质中所有必需的方法。此时，一个新的 `CrashReport` 实例应该可以作为电子邮件发送。
- en: In our main function, we will need to `auth` against the SMTP server to send
    our emails. We create a transport object which has all of the required info to
    talk to the SMTP server. The username and password can be passed as environment
    variables (or defaults). We then create an instance of our `CrashReport` and use
    the `send` method of the transport to send it. Running this does not output any
    information (if it ran successfully).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们需要对 SMTP 服务器进行 `auth` 以发送我们的电子邮件。我们创建一个包含与 SMTP 服务器通信所需所有信息的传输对象。用户名和密码可以作为环境变量（或默认值）传递。然后我们创建一个
    `CrashReport` 实例，并使用传输对象的 `send` 方法发送它。运行此操作不会输出任何信息（如果它成功运行）。
- en: One might have noticed that the API exposed by `lettre` is not very easy to
    use. This is primarily because the library is largely immature, being at version
    0.7 at the time of writing. Thus, one should expect breaking changes in the API
    till it reaches a 1.0 release.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人已经注意到 `lettre` 暴露的 API 并不容易使用。这主要是因为在撰写本文时，该库在很大程度上还不成熟，处于 0.7 版本。因此，我们应该期待在达到
    1.0 版本之前，API 会发生重大变化。
- en: Introduction to FTP and TFTP
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 和 TFTP 简介
- en: 'Another common application layer protocol is the **File Transfer Protocol**
    (**FTP**). This is a text-based protocol, where the server and clients exchange
    text commands to upload and download files. The Rust ecosystem has a crate called
    rust-ftp to interact with FTP servers programmatically. Let us look at an example
    of its use. We set up our project using Cargo:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的应用层协议是 **文件传输协议**（**FTP**）。这是一个基于文本的协议，其中服务器和客户端通过交换文本命令来上传和下载文件。Rust生态系统有一个名为
    rust-ftp 的crate，可以用来与FTP服务器进行程序性交互。让我们看看它的一个使用示例。我们使用Cargo设置我们的项目：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `Cargo.toml` should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Cargo.toml` 应该看起来像这样：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this example to work, we will need a running FTP server somewhere. Once
    we have set that up and made sure a regular FTP client can connect to it, we can
    move on to our main code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子工作，我们需要一个运行中的FTP服务器。一旦我们设置好并确保常规FTP客户端可以连接到它，我们就可以继续我们的主要代码：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For our example, we will connect to a free public FTP server, located at `ftp.dlptest.com`.
    The credentials for using the server are in this website: [https://dlptest.com/ftp-test/](https://dlptest.com/ftp-test/).
    Our helper function, called `run_ftp`, takes in the address of an FTP server,
    with its username and password as strings. It then connects to the server on port
    `21` (the default port for FTP). It goes on to log in using the given credentials,
    and then prints the current directory (which should be `/`). We then write a file
    there using the `put` function, and, at the end, close our connection to the server.
    In our `main` function, we simply call the helper with the required parameters.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将连接到一个位于 `ftp.dlptest.com` 的免费公共FTP服务器。使用该服务器的凭据位于此网站：[https://dlptest.com/ftp-test/](https://dlptest.com/ftp-test/)。我们称为
    `run_ftp` 的辅助函数接收一个FTP服务器的地址，其中用户名和密码作为字符串。然后它连接到端口号 `21`（FTP的默认端口）。接着使用提供的凭据登录，然后打印当前目录（应该是
    `/`）。然后我们使用 `put` 函数在那里写入文件，最后关闭与服务器的连接。在我们的 `main` 函数中，我们只需调用辅助函数并传入所需的参数。
- en: A thing to note here is the usage of `cursor`; it represents an inmemory buffer
    and provides implementations of `Read`, `Write`, and `Seek` over that buffer.
    The `put` function expects an input that implements `Read`; wrapping our data
    in a `Cursor` automatically does that for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个问题是 `cursor` 的使用；它代表一个内存缓冲区，并提供了在该缓冲区上实现 `Read`、`Write` 和 `Seek` 的方法。`put`
    函数期望一个实现了 `Read` 的输入；将我们的数据包装在 `Cursor` 中会自动为我们完成这一点。
- en: 'Here is what we see on running this example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例时，我们会看到以下内容：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have used an open FTP server in this example. Since this server is not under
    our control, it might be taken offline without notice. If that happens, the example
    will need to be modified to use another server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个公开的FTP服务器。由于这个服务器不在我们的控制之下，它可能会在没有通知的情况下离线。如果发生这种情况，示例需要修改以使用另一个服务器。
- en: 'A protocol closely related to FTP is called **Trivial File Transfer Protocol **(**TFTP**).
    TFTP is text-based, like FTP, but unlike FTP, it is way simpler to implement and
    maintain. It uses UDP for transport and does not provide any authentication primitives.
    Since it is faster and lighter, it is frequently implemented in embedded systems
    and boot protocols, like PXE and BOOTP. Let us look at a simple TFTP server using
    the crate called `tftp_server`. For this example, we will start with Cargo, like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与FTP密切相关的一个协议称为 **简单文件传输协议**（**TFTP**）。TFTP是基于文本的，就像FTP一样，但与FTP不同，它更容易实现和维护。它使用UDP进行传输，并且不提供任何认证原语。由于它更快、更轻量，它经常在嵌入式系统和引导协议（如PXE和BOOTP）中实现。让我们看看使用名为
    `tftp_server` 的crate的简单TFTP服务器。在这个例子中，我们将从Cargo开始，如下所示：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our manifest is very simple and looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清单非常简单，看起来像这样：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our main file will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要文件将看起来像这样：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This can be easily tested on any Unix machine that has a TFTP client installed.
    If we run this on one terminal and run the client on another, we will need to
    connect the client to a localhost on port `69`. We should then be able to download
    a file from the server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何安装了TFTP客户端的Unix机器上轻松测试。如果我们在一个终端上运行此示例，并在另一个终端上运行客户端，我们需要将客户端连接到本地的端口号
    `69`。然后我们应该能够从服务器下载文件。
- en: Running this might require root privileges. If that is the case, use `sudo`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此可能需要root权限。如果是这种情况，请使用 `sudo`。
- en: '**$ sudo ./target/debug/tftp-example**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ sudo ./target/debug/tftp-example**'
- en: 'An example session is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例会话如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built upon what we studied previously. In essence, we moved
    the network stack up to the application layer. We studied some major considerations
    for building application layer protocols. We then looked at RPC, and in particular,
    gRPC, studying how it enables developers to build large-scale networked services.
    We then looked at a Rust crate that can be used to send emails via an SMTP server.
    The last few examples were on writing an FTP client and a TFTP server. Along with
    other application layer protocols covered elsewhere in this book, we should have
    a good standing in understanding these protocols.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基于之前所学的内容进行了扩展。本质上，我们将网络栈提升到了应用层。我们研究了构建应用层协议的一些主要考虑因素。然后我们探讨了RPC，特别是gRPC，研究了它是如何帮助开发者构建大规模网络服务的。接着我们查看了一个可以用于通过SMTP服务器发送电子邮件的Rust
    crate。在本书的其他部分也涵盖了其他应用层协议的情况下，我们应该对这些协议有很好的理解。
- en: HTTP is one text-based application layer protocol that deserves a chapter of
    its own. In the next chapter, we will take a closer look at it and write some
    code to make it work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种基于文本的应用层协议，它值得单独一章来介绍。在下一章中，我们将更深入地研究它，并编写一些代码使其工作。
