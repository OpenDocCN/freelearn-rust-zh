- en: Application Layer Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous few chapters, two hosts in a network exchange bytes,
    either in a stream or in discrete packets. It is often up to a higher-level application
    to process those bytes to something that makes sense to the application. These
    applications define a new layer of protocol over the transport layer, often called
    application layer protocols. In this chapter, we will look into some of those
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of important considerations for designing application layer
    protocols. An implementation needs to know at least the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the communication broadcast or point-to-point? In the first case, the underlying
    transport protocol must be UDP. In the second case, it can be either TCP or UDP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the protocol need a reliable transport? If yes, TCP is the only option.
    Otherwise, UDP might be suitable, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the application need a byte stream (TCP), or can it work on packet-by-packet
    basis (UDP)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What signals the end of input between the parties?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the data format and encoding used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some very commonly used application layer protocols are DNS (which we studied
    in the previous chapters) and HTTP (which we will study in a subsequent chapter).
    Other than these, a very important application layer toolset commonly used for
    microservice-based architectures is gRPC. Another application layer protocol everyone
    has used at least a few times is SMTP, the protocol that powers email.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How RPC works. Specifically, we will look at gRPC and write a small server and
    client using the toolkit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a look at a crate caller `lettre` that can be used to send emails
    programmatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last topic will be on writing a simple FTP client and a TFTP server in Rust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In regular programming, it is often useful to encapsulate frequently used logic
    in a function so that it can be reused in multiple places. With the rise of networked
    and distributed systems, it became necessary to let a common set of operations
    be accessible over a network, so that validated clients can call them. This is
    often called a **Remote Procedure Call** (**RPC**). In [Chapter 4](part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287)*,* *Data
    Serialization, De-Serialization, and Parsing*, we saw a simple example of this
    when a server returned the distance of a given point from the origin. Real world
    RPC has a number of application layer protocols defined, which are far more complex.
    One of the most popular RPC implementations is gRPC, which was initially introduced
    by Google and later moved to an open source model. gRPC offers high performance
    RPC over internet scale networks and is widely used in a number of projects, including
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before digging deeper into gRPC, let''s look at protocol buffers, a related
    tool. It is a set of mechanisms to build language and platform neutral exchanging
    structured data between applications. It defines its own **Interface Definition
    Language** (**IDL**) to describe the data format, and a compiler that can take
    that format and generate code to convert to and from it. The IDL also allows for
    defining abstract services: input and output message formats that the compiler
    can use to generate stubs in a given language. We will see an example of a definition
    of a data format in a subsequent example. The compiler has plugins to generate
    output code in a large number of languages, including Rust. In our example, we
    will use such a plugin in a build script to autogenerate Rust modules. Now, gRPC
    uses protocol buffers to define the underlying data and messages. Messages are
    exchanged over HTTP/2 on top of TCP/IP. This mode of communication is often faster
    in practice, since it can make better use of existing connections, and also since
    HTTP/2 supports bidirectional asynchronous connections. gRPC, being an opinionated
    system, makes a lot of assumptions about the considerations we discussed in the
    previous section, on our behalf. Most of these defaults (like HTTP/2 over TCP)
    were chosen because they support the advanced features gRPC offers (like bidirectional
    streaming). Some other defaults, like using `protobuf`, can be swapped for another
    message format implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: For our gRPC example, we will build a service that is a lot like Uber. It has
    a central server where clients (cabs) can record their names and locations. And
    then, when a user requests a cab with their location, the server sends back a
    list of cabs near that user. Ideally, this server should have two classes of clients,
    one for cabs and one for users. But for simplicity's sake, we will assume that
    we have only one type of client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with setting up the project. Like always, we will use Cargo CLI
    to initialize the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script is our build script. It is simply a Rust executable (which
    has a main function) that Cargo builds and runs right before calling the compiler
    on the given project. Note that the default name for this script is `build.rs`,
    and it must be located in the project root. However, these parameters can be configured
    in the Cargo config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One of the most common use cases for build scripts is code generation (like
    our current project). They can also be used to find and configure native libraries
    on the host, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, we use the `protoc_rust_grpc` crate to generate Rust modules
    from our `proto` file (called `foobar.proto`). We also set the `rust_protobuf`
    flag to make it generate protobuf messages. Note that the `protoc` binary must
    be available in `$PATH` for this to work. This is a part of the protobuf package.
    Follow these steps to install it from the source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the pre-built binaries from GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Unzip the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the binary to somewhere in `$PATH`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This current example has been tested on Ubuntu 16.04 with protoc version 3.5.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need the protocol definition, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The proto file starts with a declaration of the version of protobuf IDP spec;
    we will be using version 3\. The package declaration indicates that all the generated
    code will be placed in a Rust module called `foobar`, and all other generated
    code will be placed in a module called `foobar_grpc`. We define a service called `FooBarService`
    that has two RPC functions; `record_cab_location` records the location of a cab,
    given its name and location, and `get_cabs` returns a set of cabs, given a location.
    We will also need to define all associated `protobuf` messages for each of the
    requests and responses. The spec also defines a number of built-in data types
    that closely correspond to those in a programming language (string, float, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having set up everything related to the `protobuf` message formats and functions,
    we can use Cargo to generate actual Rust code. The generated code will be located
    in the `src` directory and will be called `foobar.rs` and `foobar_grpc.rs`. These
    names are automatically assigned by the compiler. The `lib.rs` file should re-export
    those using the pub mod syntax. Note that Cargo build will not modify the `lib.rs`
    file for us; that needs to be done by hand. Let us move on to our server and client.
    Here is what the server will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that this server is very different from the servers we wrote in previous
    chapters. This is because `grpc::ServerBuilder` encapsulates a lot of the complexity
    in writing servers. `FooBarService` is the service `protobuf` compiler generated
    for us, defined as a trait in the file `foobar_grpc.rs`. As expected, this trait
    has two methods: `record_cab_location` and `get_cabs`. Thus, for our server, we
    will need to implement this trait on a struct and pass that struct to `ServerBuilder`
    to run on a given port.
  prefs: []
  type: TYPE_NORMAL
- en: In our toy example, we will not actually record cab locations. A real world
    app would want to put these in a database to be looked up later. Instead, we will
    just print a message saying that we received a new location. We also need to work
    with some boilerplate code here, to make sure all gRPC semantics are fulfilled.
    In the `get_cabs` function, we always return a static list of cabs for all requests.
    Note that since all `protobuf` messages are generated for us, we get a bunch of
    utility functions, like `get_name` and `get_location`, for free. Finally, in the
    `main` function, we pass our server struct to gRPC to create a new server on a
    given port and run it on an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our client is actually defined as a struct in the source generated by the `protobuf`
    compiler. We just need to make sure the client has the same port number we are
    running our server on. We use the `new_plain` method on the client struct and
    pass an address and port to it, along with some default options. We can then call
    the `record_cab_location` and `get_cabs` methods over RPC and process the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how a run of the client will look like. As noted before, this is not
    as dynamic as it should be, since it returns only hardcoded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how it exits right after talking to the server. The server, on the other
    hand, runs in an infinite loop, and does not exit till it gets a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internet email uses a protocol called **Simple Mail Transfer Protocol **(**SMTP**),
    which is an IETF standard. Much like HTTP, it is a simple text protocol over TCP,
    using port `25` by default. In this section, we will look at a small example of
    using `lettre` for sending emails. For this to work, let us set up our project
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `Cargo.toml` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we want to send crash reports for a server automatically. For this
    to work, we need to have an SMTP server running somewhere accessible. We also
    need to have a user who can authenticate using a password set up on that server.
    Having set those up, our code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our email is represented by the `CrashReport` struct; as expected, it has a
    `from` email address. The `to` field is a vector of email addresses, enabling
    us to send an email to multiple addresses. We implement a constructor for the
    struct. The crate `lettre` defines a trait called `SendableEmail` that has a bunch
    of properties an SMTP server needs to send an email. For a user-defined email
    to be sendable, it needs to implement that trait. In our case, `CrashReport` needs
    to implement it. We go on to implement all required methods in the trait. At this
    point, a new instance of `CrashReport` should be sendable as an email.
  prefs: []
  type: TYPE_NORMAL
- en: In our main function, we will need to `auth` against the SMTP server to send
    our emails. We create a transport object which has all of the required info to
    talk to the SMTP server. The username and password can be passed as environment
    variables (or defaults). We then create an instance of our `CrashReport` and use
    the `send` method of the transport to send it. Running this does not output any
    information (if it ran successfully).
  prefs: []
  type: TYPE_NORMAL
- en: One might have noticed that the API exposed by `lettre` is not very easy to
    use. This is primarily because the library is largely immature, being at version
    0.7 at the time of writing. Thus, one should expect breaking changes in the API
    till it reaches a 1.0 release.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to FTP and TFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common application layer protocol is the **File Transfer Protocol**
    (**FTP**). This is a text-based protocol, where the server and clients exchange
    text commands to upload and download files. The Rust ecosystem has a crate called
    rust-ftp to interact with FTP servers programmatically. Let us look at an example
    of its use. We set up our project using Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Cargo.toml` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example to work, we will need a running FTP server somewhere. Once
    we have set that up and made sure a regular FTP client can connect to it, we can
    move on to our main code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, we will connect to a free public FTP server, located at `ftp.dlptest.com`.
    The credentials for using the server are in this website: [https://dlptest.com/ftp-test/](https://dlptest.com/ftp-test/).
    Our helper function, called `run_ftp`, takes in the address of an FTP server,
    with its username and password as strings. It then connects to the server on port
    `21` (the default port for FTP). It goes on to log in using the given credentials,
    and then prints the current directory (which should be `/`). We then write a file
    there using the `put` function, and, at the end, close our connection to the server.
    In our `main` function, we simply call the helper with the required parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: A thing to note here is the usage of `cursor`; it represents an inmemory buffer
    and provides implementations of `Read`, `Write`, and `Seek` over that buffer.
    The `put` function expects an input that implements `Read`; wrapping our data
    in a `Cursor` automatically does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we see on running this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have used an open FTP server in this example. Since this server is not under
    our control, it might be taken offline without notice. If that happens, the example
    will need to be modified to use another server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A protocol closely related to FTP is called **Trivial File Transfer Protocol **(**TFTP**).
    TFTP is text-based, like FTP, but unlike FTP, it is way simpler to implement and
    maintain. It uses UDP for transport and does not provide any authentication primitives.
    Since it is faster and lighter, it is frequently implemented in embedded systems
    and boot protocols, like PXE and BOOTP. Let us look at a simple TFTP server using
    the crate called `tftp_server`. For this example, we will start with Cargo, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our manifest is very simple and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This can be easily tested on any Unix machine that has a TFTP client installed.
    If we run this on one terminal and run the client on another, we will need to
    connect the client to a localhost on port `69`. We should then be able to download
    a file from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Running this might require root privileges. If that is the case, use `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: '**$ sudo ./target/debug/tftp-example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example session is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built upon what we studied previously. In essence, we moved
    the network stack up to the application layer. We studied some major considerations
    for building application layer protocols. We then looked at RPC, and in particular,
    gRPC, studying how it enables developers to build large-scale networked services.
    We then looked at a Rust crate that can be used to send emails via an SMTP server.
    The last few examples were on writing an FTP client and a TFTP server. Along with
    other application layer protocols covered elsewhere in this book, we should have
    a good standing in understanding these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is one text-based application layer protocol that deserves a chapter of
    its own. In the next chapter, we will take a closer look at it and write some
    code to make it work.
  prefs: []
  type: TYPE_NORMAL
