["```rs\n1    use std::fs::{File, OpenOptions};\n2    use std::io::{self, BufReader, BufWriter, Lines, Write};\n3    use std::io::prelude::*;\n4 \n5    fn main() {\n6      // Create a file and fill it with data\n7      let path = \"./foo.txt\";\n8      println!(\"Writing some data to '{}'\", path);\n9      write_file(path, \"Hello World!\\n\").expect(\"Failed to write to \n        file\");\n10     // Read entire file as a string\n11     let content = read_file(path).expect(\"Failed to read file\");\n12     println!(\"The file '{}' contains:\", path);\n13     println!(\"{}\", content);\n14 \n15     // Overwrite the file\n16     println!(\"Writing new data to '{}'\", path);\n17     write_file(path, \"New content\\n\").expect(\"Failed to write to \n        file\");\n18     let content = read_file(path).expect(\"Failed to read file\");\n19     println!(\"The file '{}' now contains:\", path);\n20     println!(\"{}\", content);\n21 \n22     // Append data to the file\n23     println!(\"Appending data to '{}'\", path);\n24     append_file(path, \"Some more content\\n\").expect(\"Failed to \n        append to file\");\n25     println!(\"The file '{}' now contains:\", path);\n26     // Read file line by line as an iterator\n27     let lines = read_file_iterator(path).expect(\"Failed to read \n        file\");\n28     for line in lines {\n29       println!(\"{}\", line.expect(\"Failed to read line\"));\n30     }\n31 \n32     append_and_read(path, \"Last line in the file, \n        goodbye\").expect(\"Failed to read and write file\");\n       }\n```", "```rs\n37   fn read_file(path: &str) -> io::Result<String> {\n38     // open() opens the file in read-only mode\n39     let file = File::open(path)?;\n40     // Wrap the file in a BufReader\n41     // to read in an efficient way\n42     let mut buf_reader = BufReader::new(file);\n43     let mut content = String::new();\n44     buf_reader.read_to_string(&mut content)?;\n45     Ok(content)\n46   }\n47 \n48   fn read_file_iterator(path: &str) ->\n       io::Result<Lines<BufReader<File>>> {\n49     let file = File::open(path)?;\n50     let buf_reader = BufReader::new(file);\n51     // lines() returns an iterator over lines\n52     Ok(buf_reader.lines())\n53   }\n54 \n55 \n56   fn write_file(path: &str, content: &str) -> io::Result<()> {\n57     // create() opens a file with the standard options\n58     // to create, write and truncate a file\n59     let file = File::create(path)?;\n60     // Wrap the file in a BufReader\n61     // to read in an efficient way\n62     let mut buf_writer = BufWriter::new(file);\n63     buf_writer.write_all(content.as_bytes())?;\n64     Ok(())\n65   }\n66 \n67   fn append_file(path: &str, content: &str) -> io::Result<()> {\n68     // OpenOptions lets you set all options individually\n69     let file = OpenOptions::new().append(true).open(path)?;\n70     let mut buf_writer = BufWriter::new(file);\n71     buf_writer.write_all(content.as_bytes())?;\n72     Ok(())\n73   }\n```", "```rs\n76   fn append_and_read(path: &str, content: &str) -> io::Result<()\n     {\n       let file = \n77       OpenOptions::new().read(true).append(true).open(path)?;\n78     // Passing a reference of the file will not move it\n79     // allowing you to create both a reader and a writer\n80     let mut buf_reader = BufReader::new(&file);\n81     let mut buf_writer = BufWriter::new(&file);\n82 \n83     let mut file_content = String::new();\n84     buf_reader.read_to_string(&mut file_content)?; \n85     println!(\"File before appending:\\n{}\", file_content);\n86 \n87     // Appending will shift your positional pointer\n88     // so you have to save and restore it\n89     let pos = buf_reader.seek(SeekFrom::Current(0))?;\n90     buf_writer.write_all(content.as_bytes())?;\n91     // Flushing forces the write to happen right now\n92     buf_writer.flush()?;\n93     buf_reader.seek(SeekFrom::Start(pos))?;\n94 \n95     buf_reader.read_to_string(&mut file_content)?;\n96     println!(\"File after appending:\\n{}\", file_content);\n97 \n98     Ok(())\n99   }\n```", "```rs\nlet mut buf_reader = BufReader::new(&file);\nlet mut buf_writer = BufWriter::new(&file);\n```", "```rs\nbuf_reader.seek(SeekFrom::Start(pos))?;\n```", "```rs\nbyteorder = \"1.1.0\"\n```", "```rs\n1    extern crate byteorder;\n2    use std::io::{Cursor, Seek, SeekFrom};\n3    use byteorder::{BigEndian, LittleEndian, ReadBytesExt,\n     WriteBytesExt};\n4 \n5    fn main() {\n6      let binary_nums = vec![2, 3, 12, 8, 5, 0];\n7      // Wrap a binary collection in a cursor\n8      // to provide seek functionality\n9      let mut buff = Cursor::new(binary_nums);\n10     let first_byte = buff.read_u8().expect(\"Failed to read\n         byte\");\n11     println!(\"first byte in binary: {:b}\", first_byte);\n12 \n13     // Reading advances the internal position,\n14     // so now we read the second\n15     let second_byte_as_int = buff.read_i8().expect(\"Failed to\n         read byte as int\");\n16     println!(\"second byte as int: {}\", second_byte_as_int);\n17 \n18     // Overwrite the current position\n19     println!(\"Before: {:?}\", buff);\n20     buff.write_u8(123).expect(\"Failed to overwrite a byte\");\n21     println!(\"After: {:?}\", buff);\n22 \n23 \n24     // Set and get the current position\n25     println!(\"Old position: {}\", buff.position());\n26     buff.set_position(0);\n27     println!(\"New position: {}\", buff.position());\n28 \n29     // This also works using the Seek API\n30     buff.seek(SeekFrom::End(0)).expect(\"Failed to seek end\");\n31     println!(\"Last position: {}\", buff.position());\n32 \n33     // Read and write in specific endianness\n34     buff.set_position(0);\n35     let as_u32 = buff.read_u32::<LittleEndian>()\n36       .expect(\"Failed to read bytes\");\n37     println!(\n38       \"First four bytes as u32 in little endian order:\\t{}\",\n39        as_u32\n40     );\n41 \n42     buff.set_position(0);\n43     let as_u32 = buff.read_u32::<BigEndian>().expect(\"Failed to\n         read bytes\");\n44     println!(\"First four bytes as u32 in big endian order:\\t{}\", \n         as_u32);\n45 \n46     println!(\"Before appending: {:?}\", buff);\n47     buff.seek(SeekFrom::End(0)).expect(\"Failed to seek end\");\n48     buff.write_f32::<LittleEndian>(-33.4)\n49       .expect(\"Failed to write to end\");\n50     println!(\"After appending: {:?}\", buff);\n51 \n52     // Read a sequence of bytes into another buffer\n53     let mut read_buffer = [0; 5];\n54     buff.set_position(0);\n55     buff.read_u16_into::<LittleEndian>(&mut read_buffer)\n56       .expect(\"Failed to read all bytes\");\n57     println!(\n58       \"All bytes as u16s in little endian order: {:?}\",\n59        read_buffer\n60     );\n61   }\n```", "```rs\nprintln!(\"first byte in binary: {:b}\", first_byte);\n```", "```rs\n// Read exactly five bytes\nlet mut read_buffer = [0; 5];\nbuff.read_u16_into::<LittleEndian>(&mut read_buffer).expect(\"Failed to fill buffer\");\n```", "```rs\nuse byteorder::{BE, LE, NativeEndian, NetworkEndian};\n```", "```rs\nbyteorder = \"1.1.0\"\n```", "```rs\n1    extern crate byteorder;\n2    use byteorder::{ByteOrder, ReadBytesExt, WriteBytesExt, BE,\n     LE};\n3    use std::fs::File;\n4    use std::io::{self, BufReader, BufWriter, Read};\n5    use std::io::prelude::*;\n6 \n7 \n8    fn main() {\n9      let path = \"./bar.bin\";\n10     write_dummy_protocol(path).expect(\"Failed write file\");\n11     let payload = read_protocol(path).expect(\"Failed to read\n         file\");\n12     print!(\"The protocol contained the following payload: \");\n13     for num in payload {\n14       print!(\"0x{:X} \", num);\n15     }\n16     println!();\n17   }\n```", "```rs\n19    // Write a simple custom protocol\n20    fn write_dummy_protocol(path: &str) -> io::Result<()> {\n21      let file = File::create(path)?;\n22      let mut buf_writer = BufWriter::new(file);\n23 \n24      // Let's say our binary file starts with a magic string\n25      // to show readers that this is our protocoll\n26      let magic = b\"MyProtocol\";\n27      buf_writer.write_all(magic)?;\n28 \n29      // Now comes another magic value to indicate\n30      // our endianness\n31      let endianness = b\"LE\";\n32      buf_writer.write_all(endianness)?;\n33 \n34      // Let's fill it with two numbers in u32\n35      buf_writer.write_u32::<LE>(0xDEAD)?;\n36      buf_writer.write_u32::<LE>(0xBEEF)?;\n37 \n38      Ok(())\n39    }\n```", "```rs\n42   fn read_protocol(path: &str) -> io::Result<Vec<u32>> {\n43     let file = File::open(path)?;\n44     let mut buf_reader = BufReader::new(file);\n45 \n46     // Our protocol has to begin with a certain string\n47     // Namely \"MyProtocol\", which is 10 bytes long\n48     let mut start = [0u8; 10];\n49     buf_reader.read_exact(&mut start)?;\n50     if &start != b\"MyProtocol\" {\n51       return Err(io::Error::new(\n52         io::ErrorKind::Other,\n53         \"Protocol didn't start with the expected magic string\",\n54       ));\n55     }\n56 \n57     // Now comes the endianness indicator\n58     let mut endian = [0u8; 2];\n59     buf_reader.read_exact(&mut endian)?;\n60     match &endian {\n61       b\"LE\" => read_protocoll_payload::<LE, _>(&mut buf_reader),\n62       b\"BE\" => read_protocoll_payload::<BE, _>(&mut buf_reader),\n63       _ => Err(io::Error::new(\n64         io::ErrorKind::Other,\n65         \"Failed to parse endianness\",\n66       )),\n67     }\n68   }\n69 \n70   // Read as much of the payload as possible\n71   fn read_protocoll_payload<E, R>(reader: &mut R) ->\n       io::Result<Vec<u32>>\n72   where\n73   E: ByteOrder,\n74   R: ReadBytesExt,\n75   {\n76     let mut payload = Vec::new();\n77     const SIZE_OF_U32: usize = 4;\n78     loop {\n79     let mut raw_payload = [0; SIZE_OF_U32];\n80     // Read the next 4 bytes\n81     match reader.read(&mut raw_payload)? {\n82     // Zero means we reached the end\n83     0 => return Ok(payload),\n84     // SIZE_OF_U32 means we read a complete number\n85     SIZE_OF_U32 => {\n86       let as_u32 = raw_payload.as_ref().read_u32::<E>()?;\n87       payload.push(as_u32)\n88     }\n89     // Anything else means the last element was not\n90     // a valid u32\n91     _ => {\n92       return Err(io::Error::new(\n93       io::ErrorKind::UnexpectedEof,\n94         \"Payload ended unexpectedly\",\n95       ))\n96     }\n97   }\n98  }\n99 }\n```", "```rs\n// Zero means we reached the end\n0 => return Ok(payload),\n```", "```rs\n// SIZE_OF_U32 means we read a complete number\nSIZE_OF_U32 => {\n    let as_u32 = raw_payload.as_ref().read_u32::<E>()?;\n    payload.push(as_u32)\n}\n```", "```rs\n// Anything else means the last element was not\n// a valid u32\n_ => {\n    return Err(io::Error::new(\n        io::ErrorKind::UnexpectedEof,\n        \"Payload ended unexpectedly\",\n        ))\n    }\n}\n```", "```rs\nconst PROTOCOL_START: &[u8] = b\"MyProtocol\";\n```", "```rs\n     flate2 = \"0.2.20\"\n    ```", "```rs\n1    extern crate flate2;\n2 \n3    use std::io::{self, SeekFrom};\n4    use std::io::prelude::*;\n5 \n6    use flate2::{Compression, FlateReadExt};\n7    use flate2::write::ZlibEncoder;\n8    use flate2::read::ZlibDecoder;\n9 \n10   use std::fs::{File, OpenOptions};\n11   use std::io::{BufReader, BufWriter, Read};\n12 \n13   fn main() {\n14     let bytes = b\"I have a dream that one day this nation will\n         rise up, \\\n15     and live out the true meaning of its creed\";\n16     println!(\"Original: {:?}\", bytes.as_ref());\n17     // Conpress some bytes\n18     let encoded = encode_bytes(bytes.as_ref()).expect(\"Failed to\n         encode bytes\");\n19     println!(\"Encoded: {:?}\", encoded);\n20     // Decompress them again\n21     let decoded = decode_bytes(&encoded).expect(\"Failed to decode\n         bytes\");\n22     println!(\"Decoded: {:?}\", decoded);\n23 \n24     // Open file to compress\n25     let original = File::open(\"ferris.png\").expect(\"Failed to\n         open file\");\n26     let mut original_reader = BufReader::new(original);\n27 \n28     // Compress it\n29     let data = encode_file(&mut original_reader).expect(\"Failed\n         to encode file\");\n30 \n31     // Write compressed file to disk\n32     let encoded = OpenOptions::new()\n33       .read(true)\n34       .write(true)\n35       .create(true)\n36       .open(\"ferris_encoded.zlib\")\n37       .expect(\"Failed to create encoded file\");\n38     let mut encoded_reader = BufReader::new(&encoded);\n39     let mut encoded_writer = BufWriter::new(&encoded);\n40     encoded_writer\n41       .write_all(&data)\n42       .expect(\"Failed to write encoded file\");\n43 \n44 \n45     // Jump back to the beginning of the compressed file\n46     encoded_reader\n47       .seek(SeekFrom::Start(0))\n48       .expect(\"Failed to reset file\");\n49 \n50     // Decompress it\n51     let data = decode_file(&mut encoded_reader).expect(\"Failed to\n         decode file\");\n52 \n53     // Write the decompressed file to disk\n54     let mut decoded =\n         File::create(\"ferris_decoded.png\").expect(\"Failed to create\n           decoded file\");\n55     decoded\n56       .write_all(&data)\n57       .expect(\"Failed to write decoded file\");\n58   }\n```", "```rs\n61   fn encode_bytes(bytes: &[u8]) -> io::Result<Vec<u8>> {\n62     // You can choose your compression algorithm and it's\n         efficiency\n63     let mut encoder = ZlibEncoder::new(Vec::new(),\n         Compression::Default);\n64     encoder.write_all(bytes)?;\n65     encoder.finish()\n66   }\n67 \n68   fn decode_bytes(bytes: &[u8]) -> io::Result<Vec<u8>> {\n69     let mut encoder = ZlibDecoder::new(bytes);\n70     let mut buffer = Vec::new();\n71     encoder.read_to_end(&mut buffer)?;\n72     Ok(buffer)\n73   }\n74 \n75 \n76   fn encode_file(file: &mut Read) -> io::Result<Vec<u8>> {\n77     // Files have a built-in encoder\n78     let mut encoded = file.zlib_encode(Compression::Best);\n79     let mut buffer = Vec::new();\n80     encoded.read_to_end(&mut buffer)?;\n81     Ok(buffer)\n82   }\n83 \n84   fn decode_file(file: &mut Read) -> io::Result<Vec<u8>> {\n85     let mut buffer = Vec::new();\n86     // Files have a built-in decoder\n87     file.zlib_decode().read_to_end(&mut buffer)?;\n88     Ok(buffer)\n89   }\n```", "```rs\nlet mut encoder = ZlibEncoder::new(Vec::new(), Compression::Default);\n```", "```rs\nuse flate2::write::GzEncoder;\nlet mut encoder = GzEncoder::new(Vec::new(), Compression::Default);\n```", "```rs\nlet mut encoded = file.zlib_encode(Compression::Best);\nfile.zlib_decode().read_to_end(&mut buffer)?;\n```", "```rs\nuse std::io::Write;\nfn encode_file_into(file: &mut Read, target: &mut Write) -> io::Result<()> {\n    // Files have a built-in encoder\n    let mut encoded = file.zlib_encode(Compression::Best);\n    io::copy(&mut encoded, target)?;\n    Ok(())\n}\n```", "```rs\n// Compress it\nencode_file_into(&mut original_reader, &mut encoded_writer)\n    .expect(\"Failed to encode file\");\n```", "```rs\nwalkdir = \"2.0.1\"\n```", "```rs\n1    extern crate walkdir;\n2    use walkdir::{DirEntry, WalkDir};\n3 \n4    fn main() {\n5      println!(\"All file paths in this directory:\");\n6      for entry in WalkDir::new(\".\") {\n7        if let Ok(entry) = entry {\n8          println!(\"{}\", entry.path().display());\n9        }\n10     }\n11 \n12     println!(\"All non-hidden file names in this directory:\");\n13     WalkDir::new(\"../chapter_three\")\n14       .into_iter()\n15       .filter_entry(|entry| !is_hidden(entry)) // Look only at \n          non-hidden enthries\n16       .filter_map(Result::ok) // Keep all entries we have access to\n17       .for_each(|entry| {\n18         // Convert the name returned by theOS into a Rust string\n19         // If there are any non-UTF8 symbols in it, replace them \n              with placeholders\n20         let name = entry.file_name().to_string_lossy();\n21           println!(\"{}\", name)\n22       });\n23 \n24       println!(\"Paths of all subdirectories in this directory:\");\n25       WalkDir::new(\".\")\n26         .into_iter()\n27         .filter_entry(is_dir) // Look only at directories\n28         .filter_map(Result::ok) // Keep all entries we have \n            access to\n29         .for_each(|entry| {\n30           let path = entry.path().display();\n31           println!(\"{}\", path)\n32         });\n33 \n34       let are_any_readonly = WalkDir::new(\"..\")\n35         .into_iter()\n36         .filter_map(Result::ok) // Keep all entries we have \n            access to\n37         .filter(|e| has_file_name(e, \"vector.rs\")) // Get the \n            ones with a certain name\n38         .filter_map(|e| e.metadata().ok()) // Get metadata if the \n            OS allows it\n39         .any(|e| e.permissions().readonly()); // Check if at \n            least one entry is readonly\n40       println!(\n41         \"Are any the files called 'vector.rs' readonly? {}\",\n42          are_any_readonly\n43       );\n44 \n45      let total_size = WalkDir::new(\".\")\n46        .into_iter()\n47        .filter_map(Result::ok) // Keep all entries we have access \n           to\n48        .filter_map(|entry| entry.metadata().ok()) // Get metadata\n           if supported\n49        .filter(|metadata| metadata.is_file()) // Keep all files\n50        .fold(0, |acc, m| acc + m.len()); // Accumulate sizes\n51 \n52      println!(\"Size of current directory: {} bytes\", total_size);\n53    }\n```", "```rs\n55   fn is_hidden(entry: &DirEntry) -> bool {\n56     entry\n57       .file_name()\n58       .to_str()\n59       .map(|s| s.starts_with('.'))\n60       .unwrap_or(false) // Return false if the filename is \n          invalid UTF8\n61   }\n62 \n63   fn is_dir(entry: &DirEntry) -> bool {\n64     entry.file_type().is_dir()\n65   }\n66 \n67   fn has_file_name(entry: &DirEntry, name: &str) -> bool {\n68     // Check if file name contains valid unicode\n69     match entry.file_name().to_str() {\n70     Some(entry_name) => entry_name == name,\n71     None => false,\n72   }\n73 }\n```", "```rs\nfor entry in WalkDir::new(\".\") {\n    if let Ok(entry) = entry {\n        println!(\"{}\", entry.path().display());\n    }\n}\n```", "```rs\nglob = \"0.2.11\"\n```", "```rs\n1    extern crate glob;\n2    use glob::{glob, glob_with, MatchOptions};\n3 \n4    fn main() {\n5      println!(\"All all Rust files in all subdirectories:\");\n6      for entry in glob(\"**/*.rs\").expect(\"Failed to read glob\n       pattern\") {\n7        match entry {\n8          Ok(path) => println!(\"{:?}\", path.display()),\n9          Err(e) => println!(\"Failed to read file: {:?}\", e),\n10       }\n11     }\n12 \n13     // Set the glob to be case insensitive and ignore hidden\n          files\n14     let options = MatchOptions {\n15       case_sensitive: false,\n16       require_literal_leading_dot: true,\n17       ..Default::default()\n18     };\n19 \n20 \n21     println!(\n22       \"All files that contain the word \\\"ferris\\\" case\n          insensitive \\\n23        and don't contain an underscore:\"\n24     );\n25     for entry in glob_with(\"*Ferris[!_]*\",\n       &options).expect(\"Failed to read glob pattern\") {\n26       if let Ok(path) = entry {\n27         println!(\"{:?}\", path.display())\n28       }\n29     }\n30   }\n```"]