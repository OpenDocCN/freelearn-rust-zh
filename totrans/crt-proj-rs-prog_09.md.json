["```rs\n// data\nn\n    word 17\nm\n    word 9\nsum\n    word 0\n// code\n    load n\n    add m\n    store sum\n    terminate 0\n```", "```rs\n12\nload 9\nadd 10\nstore 11\nterminate 0\nword 17\nword 9\nword 0\n```", "```rs\n0 = terminate\n1 = load\n2 = store\n3 = add\n```", "```rs\n12\n1: 9\n3: 10\n2: 11\n0: 0\n17\n9\n0\n```", "```rs\nlet mut program: Vec<u16> = vec![12, 1, 9, 3, 10, 2, 11, 0, 0, 17, 9, 0];\n```", "```rs\nfn main() {\n    let mut n: u16 = 6710;\n    let mut digits: [u16; 5] = [0; 5];\n    let mut pos: usize;\n    let number_base: u16 = 10;\n    let ascii_zero: u16 = 48;\n\n    pos = 5;\n    loop {\n        pos -= 1;\n        digits[pos] = ascii_zero + n % number_base;\n        n /= number_base;\n        if n == 0 { break; }\n    }\n    for pos in pos..5 {\n        print!(\"{}\", digits[pos] as u8 as char);\n    }\n}\n```", "```rs\nfn main() {\n    let mut n: u16 = 6710;\n    let mut digits: [u16; 5] = [0; 5];\n    let mut pos: *mut u16;\n    let number_base: u16 = 10;\n    let ascii_zero: u16 = 48;\n    let end = unsafe {\n        (&mut digits[0] as *mut u16).offset(digits.len() as isize)\n    };\n    pos = end;\n    loop {\n        pos = unsafe { pos.offset(-1) };\n        unsafe { *pos = ascii_zero + n % number_base };\n        n /= number_base;\n        if n == 0 { break; }\n    }\n    while pos != end {\n        print!(\"{}\", unsafe { *pos } as u8 as char);\n        pos = unsafe { pos.offset(1) };\n    }\n}\n```", "```rs\nfn main() {\n    let mut ptr_acc: *mut u16; // pointer accumulator\n    let mut acc: u16; // accumulator\n    let mut n: u16 = 6710;\n    let mut digits: [u16; 5] = [0; 5];\n    let mut pos: *mut u16;\n    let number_base: u16 = 10;\n    let ascii_zero: u16 = 48;\n    let one: u16 = 1;\n\n    ptr_acc = unsafe {\n        (&mut digits[0] as *mut u16).offset(digits.len() as isize)\n    };\n    pos = ptr_acc;\n    loop {\n        ptr_acc = pos;\n        ptr_acc = unsafe { ptr_acc.offset(-(one as isize)) };\n        pos = ptr_acc;\n        acc = n;\n        acc %= number_base;\n        acc += ascii_zero;\n        unsafe { *pos = acc };\n        acc = n;\n        acc /= number_base;\n        n = acc;\n        if n == 0 { break; }\n    }\n    for &digit in &digits {\n        print!(\"{}\",\n            if digit == 0 { ' ' }\n            else { digit as u8 as char}\n        );\n    }\n}\n```", "```rs\nn\n    word 6710\ndigits\n    array 5\npos\n    word 0\nnumber_base\n    word 10\nascii_zero\n    word 48\none\n    word 1\n\n    set pos\n    store pos\nbefore_generating_digits\n    load pos\n    subtract one\n    store pos\n    load n\n    remainder number_base\n    add ascii_zero\n    store_indirect pos\n    load n\n    divide number_base\n    store n\n    jump_if_nonzero before_generating_digits\n    set digits\n    output 5\n    terminate 0\n```", "```rs\n0: 43\n1: set 39 // pos\n3: store 39 // pos\n5: before_generating_digits\n5: load 39 // pos\n7: subtract 42 // one\n9: store 39 // pos\n11: load 33 // n\n13: remainder 40 // number_base\n15: add 41 // ascii_zero\n17: store_indirect 39 // pos\n19: load 33 // n\n21: divide 40 // number_base\n23: store 33 // n\n25: jump_if_nonzero 5 // before_generating_digits\n27: set 34 // digits\n29: output 5\n31: terminate 0\n33: n: 6710\n34: digits: 0, 0, 0, 0, 0\n39: pos: 0\n40: number_base: 10\n41: ascii_zero: 48\n42: one: 1\n```", "```rs\n43,\n1, 39,\n3, 39,\n2, 39,\n9, 42,\n3, 39,\n2, 33,\n12, 40,\n8, 41,\n5, 39,\n2, 33,\n11, 40,\n3, 33,\n15, 5,\n1, 34,\n7, 5,\n0, 0,\n6710,\n0, 0, 0, 0, 0,\n0,\n10,\n48,\n1\n```", "```rs\n1: set 39 // pos\n```", "```rs\n1, 39,\n```", "```rs\nfn execute(program: &[u16]) -> u16 {\n    let mut acc: u16 = 0;\n    let mut process = vec![0u16; program[0] as usize];\n    process[..program.len()].copy_from_slice(program);\n    let mut ip = 1;\n    loop {\n        let opcode = process[ip];\n        let operand = process[ip + 1];\n        //println!(\"ip: {} opcode: {} operand: {} acc: {}\",\n        //ip, opcode, operand, acc);\n        ip += 2;\n```", "```rs\nmatch opcode {\n    0 => // terminate\n        { return operand }\n    1 => // set\n        { acc = operand }\n    2 => // load\n        { acc = process[operand as usize] }\n```", "```rs\n9 => // subtract\n    { acc = acc.wrapping_sub(process[operand as usize]) }\n10 => // multiply\n    { acc = acc.wrapping_mul(process[operand as usize]) }\n```", "```rs\n15 => // jump_if_nonzero\n    { if acc != 0 { ip = operand as usize } }\n16 => // jump_if_positive\n    { if (acc as i16) > 0 { ip = operand as usize } }\n```", "```rs\nfn main() {\n    let limit;\n    loop {\n        let mut text = String::new();\n        std::io::stdin()\n            .read_line(&mut text)\n            .expect(\"Cannot read line.\");\n        if let Ok(value) = text.trim().parse::<i16>() {\n            if value >= 2 {\n                limit = value as u16;\n                break;\n            }\n        }\n        println!(\"Invalid number (2..32767). Re-enter:\")\n    }\n\n    let mut primes = vec![0u8; limit as usize];\n    for i in 2..limit {\n        if primes[i as usize] == 0 {\n            let mut j = i + i;\n            while j < limit {\n                primes[j as usize] = 1;\n                j += i;\n            }\n        }\n    }\n\n    for i in 2..limit {\n        if primes[i as usize] == 0 {\n            print!(\"{} \", i);\n        }\n    }\n}\n```", "```rs\n600, // 0:\n// Let the user input the digits of the limit number.\n1, 190, // 1: set digits\n6, 5, // 3: input 5\n// Initialize digit pointer.\n1, 190, // 5: set digits\n3, 195, // 7: store pos \n```", "```rs\nCompiled to prog.c.\n```", "```rs\nCompiled to prog.c.\n100\n 2    3    5    7   11   13   17   19   23   29   31   37   41   43   47   53\n 59   61   67   71   73   79   83   89   97\nReturn code: 0\n40\n 2    3    5    7   11   13   17   19   23   29   31   37\nReturn code: 0\n```", "```rs\ncc prog.c -o prog.exe\n```", "```rs\n./prog.exe\n```", "```rs\n25\n 2    3    5    7   11   13   17   19   23\n```", "```rs\nlet prog = vec![\n    187, 2, // 0: 699\n    // Let the user input the digits of the limit number.\n    1, 28, 1, // 2, 0: set digits\n    6, 5, // 5, 0: input 5\n    // Initialize digit pointer.\n    1, 28, 1, // 7, 0: set digits\n    3, 33, 1, // 10, 0: store pos\n```", "```rs\n0, 0, 0, 0, 0, // 28, 1: digits: array 5\n0, 0, // 33, 1: pos: word 0\n10, 0, // 35, 1: number_base: word 10\n```", "```rs\nlet _ = translator::translate_program_to_c(&prog, \"prog.c\");\n\nlet return_code = emulator::execute_program(&prog).unwrap();\nprintln!(\"\\nReturn code: {}\", return_code);\n\nlet mut parsed_program = parsing_interpreter::parse_program(&prog).unwrap();\nlet return_code = parsing_interpreter::execute_parsed_program(&mut parsed_program);\nprintln!(\"\\nReturn code: {}\", return_code);\n```", "```rs\nfn parse_add(input: &[u8]) -> IResult<&[u8], Instruction> {\n```", "```rs\n#[derive(Debug, Clone, Copy)]\nenum Instruction {\n    Terminate(u8),\n    Set(u16),\n    Load(u16),\n    Store(u16),\n    IndirectLoad(u16),\n    IndirectStore(u16),\n    Input(u8),\n    Output(u8),\n    Add(u16),\n    Subtract(u16),\n    Multiply(u16),\n    Divide(u16),\n    Remainder(u16),\n    Jump(u16),\n    JumpIfZero(u16),\n    JumpIfNonZero(u16),\n    JumpIfPositive(u16),\n    JumpIfNegative(u16),\n    JumpIfNonPositive(u16),\n    JumpIfNonNegative(u16),\n    LoadByte(u16),\n    StoreByte(u16),\n    IndirectLoadByte(u16),\n    IndirectStoreByte(u16),\n    Byte(u8),\n}\n```", "```rs\npreceded(tag(\"\\x08\"), map(le_u16, Instruction::Add))(input)\n```", "```rs\nfn parse_terminate(input: &[u8]) -> IResult<&[u8], Instruction> {\n    preceded(tag(\"\\x00\"), map(le_u8, Instruction::Terminate))(input)\n}\n```", "```rs\nfn parse_instruction(input: &[u8]) -> IResult<&[u8], Instruction> {\n    alt((\n        alt((\n            parse_terminate,\n            parse_set,\n            parse_load,\n            parse_store,\n            parse_indirect_load,\n            parse_indirect_store,\n            parse_input,\n            parse_output,\n            parse_add,\n            parse_subtract,\n            parse_multiply,\n            parse_divide,\n            parse_remainder,\n            parse_jump,\n            parse_jump_if_zero,\n            parse_jump_if_nonzero,\n            parse_jump_if_positive,\n            parse_jump_if_negative,\n            parse_jump_if_nonpositive,\n            parse_jump_if_nonnegative,\n        )),\n        alt((\n            parse_load_byte,\n            parse_store_byte,\n            parse_indirect_load_byte,\n            parse_indirect_store_byte,\n        )),\n    ))(input)\n}\n```", "```rs\nimpl Instruction {\n    pub fn len(self) -> usize {\n        use Instruction::*;\n        match self {\n            Byte(_) => 1,\n            Terminate(_) | Input(_) | Output(_) => 2,\n            _ => 3,\n        }\n    }\n}\n```", "```rs\npub fn execute_program(program: &[u8]) -> Result<u8, ()> {\n    let process_size_parsed: u16 = match get_process_size(program) {\n        Ok(ok) => ok,\n        Err(_) => return Err(()),\n    };\n    let mut process = vec![0u8; process_size_parsed as usize];\n    process[0..program.len()].copy_from_slice(&program);\n    let mut registers = RegisterSet { ip: 2, acc: 0 };\n    loop {\n        let instruction = match parse_instruction(&process[registers.ip as usize..]) {\n            Ok(instruction) => instruction.1,\n            Err(_) => return Err(()),\n        };\n        if let Some(return_code) = execute_instruction(&mut process, &mut registers, instruction) {\n            return Ok(return_code);\n        }\n    }\n}\n```", "```rs\npub struct RegisterSet {\n    ip: u16,\n    acc: u16,\n}\n```", "```rs\nmatch instruction {\n    Terminate(operand) => {\n        r.ip += 2;\n        return Some(operand);\n    }\n    Set(operand) => {\n        r.acc = operand;\n        r.ip += 3;\n    }\n    Load(address) => {\n        r.acc = get_le_word(process, address);\n        r.ip += 3;\n    }\n    Store(address) => {\n        set_le_word(process, address, r.acc);\n        r.ip += 3;\n    }\n```", "```rs\nfn get_le_word(slice: &[u8], address: u16) -> u16 {\n    u16::from(slice[address as usize]) + (u16::from(slice[address as usize + 1]) << 8)\n}\n\nfn set_le_word(slice: &mut [u8], address: u16, value: u16) {\n    slice[address as usize] = value as u8;\n    slice[address as usize + 1] = (value >> 8) as u8;\n}\n\n```", "```rs\n    JumpIfPositive(address) => {\n        if (r.acc as i16) > 0 {\n            r.ip = address;\n        } else {\n            r.ip += 3;\n        }\n    }\n```", "```rs\n    IndirectLoadByte(address) => {\n        r.acc = get_byte(process, get_le_word(process, address));\n        r.ip += 3;\n    }\n```", "```rs\nlet mut parsed_program = vec![Instruction::Byte(0); process_size_parsed];\nlet mut ip = 2;\nloop {\n    match parse_instruction(&program[ip..]) {\n        Ok(instruction) => {\n            parsed_program[ip] = instruction.1;\n            ip += instruction.1.len();\n            if let Instruction::Terminate(_) = instruction.1 {\n                break;\n            }\n        }\n        Err(_) => return Err(()),\n    };\n}\n```", "```rs\nfor ip in ip..program.len() {\n    parsed_program[ip] = Instruction::Byte(program[ip]);\n}\n```", "```rs\nlet mut registers = ParsedRegisterSet { ip: 2, acc: 0 };\nloop {\n    if let Some(return_code) = execute_parsed_instruction(parsed_program, &mut registers) {\n        return return_code;\n    };\n}\n```", "```rs\npub fn translate_program_to_c(program: &[u8], target_path: &str) -> Result<()> {\n```", "```rs\n writeln!(file, \"#include <stdio.h>\")?;\n```", "```rs\nwriteln!(file, \" addr_{}: acc = {};\", *ip, operand)?;\n```", "```rs\nwriteln!(file, \"unsigned char memory[] = {{\")?;\n```", "```rs\nunsigned char memory[];\n```", "```rs\nunsigned short bytes_to_u16_le(unsigned int address)\nvoid u16_to_bytes_le(unsigned int address, unsigned short operand)\n```", "```rs\naddr_10: u16_to_bytes_le(289, acc);\n```", "```rs\nStore(address) => {\n    writeln!(file, \" addr_{}: u16_to_bytes_le({}, acc);\", *ip, address)?;\n    *ip += 3;\n}\n```", "```rs\nFOR DEBUG\nProgram size: 299\nProcess size: 699\n 2: Set(284: 28, 1)\n 5: Input(5)\n 7: Set(284: 28, 1)\n 10: Store(289: 33, 1)\n 13: IndirectLoadByte(289: 33, 1)\n```", "```rs\n 297: Byte(2)\n 298: Byte(0)\n\nFOR ASSEMBLING\nprocess size 699\n 2: set 284\n 5: input 5\n 7: set 284\n 10: store 289\n 13: indirect load byte 289\n```", "```rs\n 297: data byte 2\n 298: data byte 0\n```", "```rs\n    println!(\"FOR DEBUG\");\n    let _ = disassembly_program_for_debug(&prog);\n    println!();\n    println!(\"FOR ASSEMBLING\");\n    let _ = disassembly_program(&prog);\n```", "```rs\nloop {\n    let instruction = parse_instruction(rest)?;\n    println!(\"{:5}: {:?}\", offset, instruction.1);\n    offset += instruction.1.len();\n    rest = instruction.0;\n    if let Terminate(_) = instruction.1 {\n        break;\n    }\n}\nfor byte in rest {\n    let instr = Byte(*byte);\n    println!(\"{:5}: {:?}\", offset, instr);\n    offset += instr.len();\n}\n```", "```rs\n Set(284)\n```", "```rs\n Set(284: 28, 1)\n```", "```rs\n#[derive(Copy, Clone)]\nstruct Word(u16);\n```", "```rs\n#[derive(Debug, Copy, Clone)]\nenum Instruction {\n    Terminate(u8),\n    Set(Word),\n    Load(Word),\n    ...\n```", "```rs\nimpl std::fmt::Debug for Word {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}: {}, {}\", self.0, self.0 as u8, self.0 >> 8)\n    }\n}\n```", "```rs\nfn parse_set(input: &[u8]) -> IResult<&[u8], Instruction> {\n    preceded(tag(\"\\x01\"), map(le_u16, Instruction::Set))(input)\n}\n```", "```rs\nfn parse_set(input: &[u8]) -> IResult<&[u8], Instruction> {\n    preceded(tag(\"\\x01\"), map(le_word, Instruction::Set))(input)\n}\n```", "```rs\nfn le_word(input: &[u8]) -> IResult<&[u8], Word> {\n    le_u16(input).map(|(input, output)| (input, Word(output)))\n}\n```", "```rs\nimpl std::fmt::Display for Instruction {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        use Instruction::*;\n        match self {\n            Terminate(byte) => write!(f, \"terminate {}\", byte),\n            Set(word) => write!(f, \"set {}\", word),\n            Load(word) => write!(f, \"load {}\", word),\n            ...\n            Byte(byte) => write!(f, \"data byte {}\", byte),\n        }\n    }\n}\n```", "```rs\nimpl std::fmt::Display for Word {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n```"]