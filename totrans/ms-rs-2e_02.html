<html><head></head><body>
        

                            
                    <h1 class="header-title">Managing Projects with Cargo</h1>
                
            
            
                
<p>Now that we are familiar with the language and how to write basic programs, we'll level up towards writing practical projects in Rust. For trivial programs that can be contained in a single file, compiling and building them manually is no big deal. In the real world, however, programs are split into multiple files for managing complexity and also have dependencies on other libraries. Compiling all of the source files manually and linking them together becomes a complicated process. For large-scale projects, the manual way is not a scalable solution as there could be hundreds of files and their dependencies. Fortunately, there are tools that automate building of large-scale software projects—package managers. This chapter explores how Rust manages large projects with its dedicated package manager and what features it provides to the developer to enhance their development experience. We will cover the following topics:</p>
<ul>
<li>Package managers</li>
<li>Modules</li>
<li>The Cargo package manager and crates (libraries) as units of compilation</li>
<li>Creating and building projects</li>
<li>Running tests</li>
<li>Cargo subcommands and installing third-party binaries</li>
<li>Editor integrations and setup in Visual Studio code</li>
</ul>
<p>As a final exercise, we'll create imgtool, a trivial command-line tool that can rotate images from the command line using a library, and use Cargo to build and run our program. We have a lot to cover, so let's dive in!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Package managers</h1>
                
            
            
                
<p>"The key to efficient development is to make interesting new mistakes."                                                                                                                                                               </p>
<p class="CDPAlignRight CDPAlign">– <em>Tom Love</em></p>
<p>A real-world software code base is often organized into multiple files and will have many dependencies, and that calls for a dedicated tool for managing them. Package managers are a class of command-line tools that help manage projects of a large size with multiple dependencies. If you come from a Node.js background, you must be familiar with npm/yarn or if you are from Go language, the go tool. They do all the heavy lifting of analyzing the project, downloading the correct versions of dependencies, checking for version conflicts, compiling and linking source files, and much more.</p>
<p>The problem with low-level languages like C/C++ is that they do not ship with a dedicated package manager by default. The C/C++ community have been using the GNU make tool for a long time, which is a language-agnostic build system and has arcane syntax, that puts off many developers. The problem with make is that it does not know what header files are included in your C/C++ sources, so they have to be manually given this information. It has no built-in support for downloading external dependencies, nor does it know about the platform you are running on. Fortunately, this is not the case with Rust as it ships with a dedicated package manager which has more context on the project being managed. What follows is a tour of Cargo, Rust's package manager, which makes it easy to build and maintain Rust projects. But first, we need to dig into Rust's module system a bit more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modules</h1>
                
            
            
                
<p>Before we explore more about Cargo, we need to be familiar with how Rust organizes our code. We had a brief glimpse at modules in the previous chapter. Here, we will cover them in detail. Every Rust program starts with a root module. If you are creating a library, your root module is the lib.rs file. If you are creating an executable, the root module is any file with a main function, usually main.rs. When your code gets large, Rust lets you split it into modules. To provide flexibility in organizing a project, there are multiple ways to create modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Nested modules</h1>
                
            
            
                
<p>The simplest way to create a module is by using the mod {} block within an existing module. Consider the following code:</p>
<pre>// mod_within.rs<br/><br/>mod food {<br/>    struct Cake;<br/>    struct Smoothie;<br/>    struct Pizza;<br/>}<br/><br/>fn main() {<br/>    let eatable = Cake;<br/>}</pre>
<p>We created an inner module named food. To create a module within an existing one, we use the mod keyword, followed by the name of the module, food, followed by a pair of braces. Within braces, we can declare any kind of item or even a nested module. Within our food module, we declared three structs: Cake, Smoothie, and Pizza. In main, we then create a Cake instance from the food module using the path syntax food::Cake. Let's compile this program:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ed900518-78ab-4af7-a095-7c3d2d8fc403.png" style="width:41.92em;height:13.50em;"/></p>
<p>Strange! The compiler does not see any Cake type being defined. Let's do what the compiler says and add use food::Cake:</p>
<pre>// mod_within.rs<br/><br/>mod food {<br/>    struct Cake;<br/>    struct Smoothie;<br/>    struct Pizza;<br/>}<br/><br/>use food::Cake;<br/><br/>fn main() {<br/>    let eatable = Cake;<br/>}</pre>
<p>We added use food::Cake;. To use any item from a module, we have to add a use declaration. Let's try again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bc654e50-0700-4568-945f-acd3aa2ec186.png" style="width:34.83em;height:10.50em;"/></p>
<p>We get another error saying that Cake is private. This brings us to an important aspect about modules, providing privacy. Items within a module are private by default. To use any item from a module, we need to bring the item into scope. This is a two-step process. First, we need to make the item itself public by prefixing our item declaration with the pub keyword. Second, to use the item, we need to add a use statement, as we did previously with use food::Cake.</p>
<p>What comes after the use keyword is the item path in the module. The path to any item within a module is specified using the path syntax, which uses two double colons (::) between item names. The path syntax usually starts with the module name for importing items, though it is also used for importing individual fields of some types, such as enums.</p>
<p>Let's make our Cake public:</p>
<pre>// mod_within.rs<br/><br/>mod food {<br/>    pub struct Cake;<br/>    struct Smoothie;<br/>    struct Pizza;<br/>}<br/><br/>use food::Cake;<br/><br/>fn main() {<br/>    let eatable = Cake;<br/>}</pre>
<p>We added pub before our Cake struct and used it in the root module via use food::Cake. With those changes, our code compiles. It's not apparently clear now as to why one would need to create nested modules like so, but we'll get to see how they are used when we write tests in <a href="16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml">Chapter 3</a>, Tests, Documentation, and Benchmarks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">File as a module</h1>
                
            
            
                
<p>Modules can also be created as files. For instance, for a main.rs file in a directory named foo, we can create a module bar as a file in the same directory as foo/bar.rs. Then in main.rs, we need to tell the compiler of this module, that is, declare the module with mod foo;. This is an extra step when using file-based modules. To demonstrate using a file as a module, we have created a directory named modules_demo, which has the following structure:</p>
<pre>+ modules_demo<br/>└── foo.rs<br/>└── main.rs</pre>
<p>Our foo.rs contains a struct Bar, with its impl block:</p>
<pre>// modules_demo/foo.rs<br/><br/>pub struct Bar;<br/><br/>impl Bar {<br/>    pub fn init() {<br/>        println!("Bar type initialized");<br/>    }<br/>}</pre>
<p>We want to use this module in main.rs. Our main.rs, has the following code:</p>
<pre>// modules_demo/main.rs<br/><br/>mod foo;<br/><br/>use crate::foo::Bar;<br/><br/>fn main() {<br/>    let _bar = Bar::init();<br/>}</pre>
<p>We declare our module, foo, using mod foo;. We then use the Bar struct from the module by writing use crate::foo::Bar. Notice the crate prefix in use crate::foo::Bar; here. There are three ways to use an item from a module depending on the prefix you use:</p>
<p>Absolute imports:</p>
<ul>
<li>crate: An absolute import prefix that refers to the the current crate's root. In the preceding code, this would be the root module, that is, main.rs file. Anything after the crate keyword is resolved from the root module.</li>
</ul>
<p>Relative imports:</p>
<ul>
<li>self: A relative import prefix that refers to an item relative from the current module. This is used when any code wants to refer to its containing module, for example, use self::foo::Bar;. This is mostly used when re-exporting items from a child module to be available from the parent module.</li>
<li>super: A relative import prefix that can use and import an item from the parent module. A child module such as the tests module would use this to import items from the parent module. For example, if a module bar wants to access an item Foo from its parent module foo, it would import it as use super::foo::Foo; in module bar.</li>
</ul>
<p>The third way to create modules, is to organize them as directories.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directory as module</h1>
                
            
            
                
<p>We can also create a directory that represents a module. This approach allows us to have submodules within modules as a file and directory hierarchy. Let's assume that we have a directory,  my_program, that has a module named foo as a file foo.rs. It contains a type called Bar along with foo's functionality. Over time, the Bar APIs have grown in number and we wish to separate them as a submodule. We can model this use case with directory-based modules. </p>
<p>To demonstrate creating modules as directories, we have created a program in a directory named my_program. It has an entry point in main.rs and a directory named foo. This directory now contains a submodule within it named bar.rs.</p>
<p>Following is the structure of the directory my_program:</p>
<pre>+ my_program<br/>└── foo/<br/>    └── bar.rs<br/>└── foo.rs<br/>└── main.rs</pre>
<p>To let Rust know about bar, we also need to create a sibling file named foo.rs alongside the directory foo/. The foo.rs file will contain mod declarations for any submodules created (here bar.rs) within the directory foo/.</p>
<p>Our bar.rs has the following content:</p>
<pre>// my_program/foo/bar.rs<br/><br/>pub struct Bar;<br/><br/>impl Bar {<br/>    pub fn hello() {<br/>        println!("Hello from Bar !");<br/>    }<br/>}</pre>
<p>We have a unit struct Bar having an associated method hello. We want to use this API in main.rs.</p>
<p>Note: In the older Rust 2015 edition, submodules don't need a sibling foo.rs alongside the foo directory, and instead use a mod.rs file within foo to convey to the compiler that the directory is a module. Both of these approaches are supported in Rust 2018 edition.</p>
<p>Next, our foo.rs has the following code:</p>
<pre>// my_program/foo.rs<br/><br/>mod bar;<br/>pub use self::bar::Bar;<br/><br/>pub fn do_foo() {<br/>    println!("Hi from foo!");<br/>}</pre>
<p>We added a declaration of the module bar. Following that, we re-exported the item Bar from the module bar. This requires that Bar is defined as pub. The pub use part is how we  re-export an item from a child module to be available from the parent module. Here, we used the self keyword to reference the module itself. Re-exports are mainly a convenience step when writing use statements, which helps remove the clutter when importing an item that is hidden away in nested submodules.</p>
<p>self is a keyword for relative imports. While it's encouraged to use absolute imports using crate, it is much cleaner to use self when re-exporting items from submodules in the parent module.</p>
<p>Finally main.rs uses both modules as:</p>
<pre>// my_program/main.rs<br/><br/>mod foo;<br/><br/>use foo::Bar;<br/><br/>fn main() {<br/>    foo::do_foo();<br/>    Bar::hello();<br/>}</pre>
<p>Our main.rs declares foo and then imports the struct Bar. We then invoke the method do_foo from foo and also invoke hello on Bar.</p>
<p>There's more to modules than meets the eye and thus we cover some of the details about them in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, Advanced Concepts. With modules explored, let's continue with Cargo.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cargo and crates</h1>
                
            
            
                
<p>When projects get large, a usual practice is to refactor code into smaller, more manageable units as modules or libraries. You also need tools to render documentation for your project, how it should be built, and what libraries it depends on. Furthermore, to support the language ecosystem where developers can share their libraries with the community, an online registry of some sort is often the norm these days.</p>
<p>Cargo is the tool that empowers you to do all these things, and <a href="https://crates.io">https://crates.io</a> is the centralized place for hosting libraries. A library written in Rust is called a crate, and crates.io hosts them for developers to use. Usually, a crate can come from three sources: a local directory, an online Git repository like GitHub, or a hosted crate registry like crates.io. Cargo supports crates from all of these sources.</p>
<p>Let's see Cargo in action. If you ran rustup, as described in the previous chapter, you will already have cargo installed, along with rustc. To see what commands are available to us, we can run cargo without any parameters:</p>
<div><img src="img/b2149843-d325-4fad-8876-4df2fed185a3.png"/></div>
<p>It shows a list of common commands that we can use, along with some flags. Let's use the the new subcommand to create a new Cargo project.</p>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new Cargo project</h1>
                
            
            
                
<p>The cargo new &lt;name&gt; command creates a new project name as a directory. We can get more context on any subcommand by adding a help flag between cargo and the subcommand. We can view documentation for the new subcommand by running cargo help new, as shown in the following screenshot:</p>
<div><img src="img/f0564389-29fe-4a03-b87c-e70d3efaf1fa.png"/></div>
<p>By default, cargo new creates a binary project; the --lib parameter has to be used when creating a library project. Let's try it out by typing cargo new imgtool and taking a look at the directory structure it creates:</p>
<div><img src="img/4e2d11d0-acc7-4dd3-8777-a6f4d733db08.png" style="width:30.83em;height:19.17em;"/></div>
<p>Cargo has created some starter files, Cargo.toml and src/main.rs, with the function main printing Hello World!. For binary crates (executables), Cargo creates a src/main.rs file and for library crates it creates,  src/lib.rs under the src/ directory. </p>
<p>Cargo also initializes a Git repository for new projects with the usual defaults, like preventing the target directory from being checked in with a .gitignore file, and checking in the Cargo.lock file for binary crates and ignoring it in library crates. The default Version Control System (VCS) that's used is Git, which can be changed by passing the --vcs flag to Cargo ( --vcs hg for mercurial). Cargo as of now supports Git, hg (mercurial), pijul (a version control system written in Rust), and fossil. If we want to modify this default behavior, we can pass --vcs none to instruct Cargo to not configure any vcs when creating our project.</p>
<p>Let's take a look at Cargo.toml for the project imgtool that we created. This file defines your project's metadata and dependencies. It's also known as the project's manifest file:</p>
<pre>[package]<br/>name = "imgtool"<br/>version = "0.1.0"<br/>authors = ["creativcoders@gmail.com"]<br/>edition = "2018"<br/><br/>[dependencies]  </pre>
<p>This is the minimal Cargo.toml manifest file needed for a new project. It uses the TOML configuration language, which stands for Tom's Obvious Minimal Language. It is a file format that was created by Tom Preston-Werner. It is reminiscent of standard .INI files, but adds several data types to it, which makes it an ideal modern format for configuration files and simpler than YAML or JSON. We'll keep this file minimal for now and add things to it later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cargo and dependencies</h1>
                
            
            
                
<p>For projects that depend on other libraries, the package manager has to find all of the direct dependencies in the project and also any indirect dependencies, and then compile and link them to the project. Package managers are not just a tool for facilitating dependency resolution; they should also ensure predictable and reproducible builds of a project. Before we cover building and running our project, let's discuss how Cargo manages dependencies and ensures repeatable builds.</p>
<p>A Rust project managed with Cargo has two files through which it does all its magic: Cargo.toml (introduced before) is the file where you, as the developer, write dependencies and their needed versions with SemVer syntax (like 1.3.*), and a lock file called Cargo.lock, which gets generated by Cargo upon building the project and that contains absolute versions (like 1.3.15) of all the immediate dependencies and any indirect dependencies. This lock file is what ensures repeatable builds in binary crates. Cargo minimizes the work it has to do by referring to this lock file for any further changes to the project. As such, it is advised that binary crates include the .lock file in their repository, while library crates can be stateless and don't need to include it.</p>
<p>Dependencies can be updated using the cargo update command. This updates all of your dependencies. For updating a single dependency, we can use cargo update -p &lt;crate-name&gt;. If you update the version of a single crate, Cargo makes sure to only update parts that are related to that crate in the Cargo.lock file and leaves other versions untouched.</p>
<p>Cargo follows the semantic versioning system (SemVer), where your library version is specified in the format of major.minor.patch. These can be described as follows:</p>
<ul>
<li>Major: Is only increased when new breaking changes (including bug fixes) are made to a project.</li>
<li>Minor: Is only increased when new features are added in backward compatible ways.</li>
<li>Patch: Is only increased when bug fixes are made in backward compatible ways and no features are added.</li>
</ul>
<p>For example, you might want to include the serialization library, serde, in your project. At the time of writing this book, the latest version of serde is 1.0.85 , and you probably only care about the major version number. Therefore, you write serde = "1" as the dependency (this translates to 1.x.x in SemVer format) in your Cargo.toml and Cargo will figure it out for you and fix it to 1.0.85 in the lock file. The next time you update Cargo.lock with the cargo update command, this version might get upgraded to whichever is the latest version in the 1.x.x match. If you don't care that much and just want the latest released version of a crate, you can use * as the version, but it's not a recommended practice because it affects the reproducibility of your builds as you might pull in a major version that has breaking changes. Publishing a crate with * as the dependency version is also prohibited.</p>
<p>With that in mind, let's take a look at the cargo build command, which is used to compile, link, and build our project. This command does the following for your project:</p>
<ul>
<li>Runs cargo update for you if you don't yet have a Cargo.lock file and puts the exact versions in the lock file from Cargo.toml</li>
<li>Downloads all of your dependencies that have been resolved in Cargo.lock</li>
<li>Builds all of those dependencies</li>
<li>Builds your project and links it with the dependencies</li>
</ul>
<p> By default, cargo build creates a debug build of your project under the target/debug/ directory. A --release flag can be passed to create an optimized build for production code at the target/release/ directory. The debug build offers faster build time, shortening the feedback loop, while production builds are a bit slower as the compiler runs more optimization passes over your source code. During development, you need to have a shorter feedback time of fix-compile-check. For that, one can use the cargo check command, which results in even shorter compile times. It basically skips the code generation part of the compiler and only runs the source code through the frontend phase, that is, parsing and semantic analysis in the compiler. Another command is cargo run, which performs double duty. It runs cargo build, followed by running your program in the target/debug/ directory. For building/running a release version, you can use cargo run --release . On running Cargo run in our imgtool/ directory, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d0e57dbf-82e0-49e4-b1ef-5fb3bb29458c.png" style="width:33.25em;height:5.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running tests with Cargo</h1>
                
            
            
                
<p>Cargo also supports running tests and benchmarks. In-depth testing and benchmarking is covered in <a href="16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml">Chapter 3</a>, Tests, Documentation, and Benchmarks. In this section, we will go over a brief introduction on how to run tests using Cargo. We'll write tests for a library crate. To work our way through this section, let's create a crate by running cargo new myexponent --lib:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9af491de-efdf-4127-8d0b-b01e07016f2c.png" style="width:27.50em;height:20.58em;"/></p>
<p>A library crate is similar to a binary crate. The difference is that instead of src/main.rs and a main function inside as an entry point, we have src/lib.rs with a trivial test function, it_works, which is marked with a #[test] annotation. We can run the it_works test function right away using cargo test and see it pass:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6b99d64e-4476-42c8-8bfc-f6563fd6962e.png" style="width:44.17em;height:15.92em;"/></p>
<p>Now,  let's try a bit of <strong>Test Driven Development</strong> (<strong>TDD</strong>) with Cargo. We will extend this library by adding a pow function ,with which the users of our library can calculate the exponent for a given number. We'll write a test for this function that initially fails and then fill in the implementation until it works. Here's the new <kbd>src/lib.rs</kbd>, featuring the pow function without any implementation:</p>
<pre>// myexponent/src/lib.rs<br/><br/>fn pow(base: i64, exponent: usize) &gt; i64 { <br/>    unimplemented!();<br/>} <br/><br/>#[cfg(test)] <br/>mod tests { <br/>    use super::pow; <br/>    #[test] <br/>    fn minus_two_raised_three_is_minus_eight() { <br/>        assert_eq!(pow(-2, 3), -8); <br/>    }<br/>}</pre>
<p>Don't worry about the details right now. We have created a single pow function that takes in a base as i64 and a positive exponent as usize, and returns a number that's been raised to the exponent. Under mod tests {, we have a test function called minus_two_raised_three_is_minus_eight that does a single assertion. The assert_eq! macro checks for the equality of the two values that were passed to it. If the left argument is equal to the right argument, the assertion passes; otherwise, it throws an error and the compiler reports the failed test. If we run cargo test, the unit tests obviously fails for pow invocation because we have an unimplemented!() macro invocation there:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/88a4d812-ceea-45d5-972d-451ca723f242.png"/></p>
<p>In brief, unimplemented!() is just a convenient macro to mark unfinished code or code that you wish to implement later, but want the compiler to compile it anyway without giving a type error. Internally, this calls panic! with a message, "not yet implemented". It can be used in cases where you are implementing multiple methods of a trait. For instance, you start implementing one method, but you haven't planned on the implementation for other methods. When compiled, you would get compile errors for the other unimplemented methods if you just placed the function with an empty body. For these methods, we can place an unimplemented!() macro call inside them, just to make the type checker happy and compile for us, and offload the errors at runtime. We will look at more convenient macros like this in <a href="7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml"/><a href="7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml">Chapter 9</a>, Metaprogramming with Macros.</p>
<p>Now, let's fix this problem by implementing a quick and dirty version of the pow function and try again:</p>
<pre>// myexponent/src/lib.rs<br/><br/>pub fn pow(base: i64, exponent: usize) -&gt; i64 {<br/>    let mut res = 1;<br/>    if exponent == 0 {<br/>        return 1;<br/>    }<br/>    for _ in 0..exponent {<br/>        res *= base as i64;<br/>    }<br/>    res<br/>}</pre>
<p>Running Cargo test gives the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4928cbd9-9572-44b0-8832-7c97a5dcf125.png" style="width:37.42em;height:8.25em;"/></p>
<p>This time, the test passes. Well, that's the basics. We'll do more testing in <a href="16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml"/><a href="16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml">Chapter 3</a>, Tests, Documentation, and Benchmarks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running examples with Cargo</h1>
                
            
            
                
<p>To enable users to quickly get started with your crate, it's a good practice to communicate to users how to use your crate with code examples. Cargo standardize this practice, meaning that you can add an examples/ directory within your project root that can contain one or more .rs files, with a main function showing example usage of your crate.</p>
<p>The code under the examples/ directory can be run by using cargo run --examples &lt;file_name&gt;, where the filename is given without the .rs extension. To demonstrate this, we've added an example/ directory for our myexponent crate containing a file named basic.rs:</p>
<pre>// myexponent/examples/basic.rs<br/><br/>use myexponent::pow;<br/><br/>fn main() {<br/>    println!("8 raised to 2 is {}", pow(8, 2));<br/>}</pre>
<p>Under the examples/ directory, we imported our pow function from our myexponent crate. The following is the output upon running cargo run --example basic:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/97bfeda9-d509-426e-be66-512cda194c05.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cargo workspace</h1>
                
            
            
                
<p>Over the course of time, your project has gotten quite large. Now, you are thinking about whether you could split the common parts of your code as separate crates to help manage complexity. Well, a Cargo workspace allows you to do just that. The concept of workspaces is that they allow you to have crates locally in a directory that can share the same Cargo.lock file and a common target or output directory. To demonstrate this, we'll create a new project that incorporates Cargo workspaces. The workspace is nothing but a directory with a Cargo.toml file in it. It doesn't have any [package] section, but has a [workspace] section in it. Let's create a new directory called workspace_demo and add the Cargo.toml file like so:</p>
<pre>mkdir workspace_demo<br/>cd workspace_demo &amp;&amp; touch Cargo.toml</pre>
<p>We then add the workspace section to our Cargo.toml file:</p>
<pre># worspace_demo/Cargo.toml<br/><br/>[workspace]<br/>members = ["my_crate", "app"]</pre>
<p>Within [workspace], the members key is a list of crates within the workspace directory. Now, within the workspace_demo directory, we'll create two crates: my_crate, a library crate and app, a binary crate that uses my_crate.</p>
<p>To keep things simple, my_crate has a public API that simply prints a greeting message:</p>
<pre>// workspace_demo/my_crate/lib.rs<br/><br/>pub fn greet() {<br/>    println!("Hi from my_crate");<br/>}</pre>
<p>Now, from our app crate, we have the main function, which calls the greet function of my_crate:</p>
<pre>// workspace_demo/app/main.rs<br/><br/>fn main() {<br/>    my_crate::greet();<br/>}</pre>
<p>However, we need to let Cargo know about our my_crate dependency. As my_crate is a local crate, we need to specify it as a path dependency in the Cargo.toml file of app, like so:</p>
<pre># workspace_demo/app/Cargo.toml<br/><br/>[package]<br/>name = "app"<br/>version = "0.1.0"<br/>authors = ["creativcoder"]<br/>edition = "2018"<br/><br/>[dependencies]<br/>my_crate = { path = "../my_crate" }</pre>
<p>Now, when we run cargo build, the binary gets generated in the workspace_demo directory's target directory. Accordingly, we can add multiple local crates within the workspace_demo directory. Now, if we want to add a third-party dependency from crates.io, we need to add it in all of the crates where we need it. However, during cargo build, Cargo makes sure to only have a single version for that dependency in the Cargo.lock file. This ensures that third-party dependencies do not get rebuilt and duplicated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending Cargo and tools</h1>
                
            
            
                
<p>Cargo can also be extended to incorporate external tools for enhancing the development experience. It is designed to be as extensible as possible. Developers can create command-line tools and Cargo can invoke them via simple cargo binary-name syntax. In this section, we'll take a look at some of these tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Subcommands and Cargo installation</h1>
                
            
            
                
<p>Custom commands for Cargo fall under the subcommand category. These tools are usually binaries from crates.io, GitHub, or a local project directory, and can be installed by using cargo install &lt;binary crate name&gt; or just cargo install when within a local Cargo project. One such example is the cargo-watch tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">cargo-watch</h1>
                
            
            
                
<p>Cargo-watch helps you shorten your fix, compile, run cycle by automatically building your project in the background whenever you make changes to your code. By default, this just runs Rust's type checker (the cargo check command) and does not undergo the code generation phase (which takes time) and shortens the compile time. A custom command can also be provided instead of cargo check using the -x flag.</p>
<p>We can install cargo-watch by running cargo install cargo-watch, and then within any Cargo project we can run it by invoking cargo watch. Now, whenever we make changes to our project, cargo-watch will run cargo check in the background and recompile the project for us. In the following code, we made a typo and corrected it, and cargo-watch recompiled the project for us:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/90f6a6a7-9790-42d8-b5d2-13d3eba37b50.png"/></p>
<p>This will be a very similar experience if you know about the watchman or nodemon packages from the Node.js ecosystem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">cargo-edit</h1>
                
            
            
                
<p>The cargo-edit subcommand is used to automatically add dependencies to your Cargo.toml file. It can add dependencies of all kinds, including dev dependencies and build dependencies, and also lets you add a specific version of any dependency. It can be installed by running cargo install cargo-edit. This subcommand provides four commands: cargo add, cargo rm, cargo edit, and cargo upgrade.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">cargo-deb</h1>
                
            
            
                
<p>This is another useful community developed subcommand that can create Debian packages (.deb) for the easy distribution of Rust executables on Debian Linux. We can install it by running cargo install cargo-deb. We'll use this tool at the end of this chapter to package our imgtool command-line executable as a .deb package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">cargo-outdated</h1>
                
            
            
                
<p>This command shows the outdated crate dependencies in your Cargo project. This can be installed by running cargo install cargo-outdated. Once installed, you can see the outdated crates (if any) by running cargo outdated within the project directory.</p>
<p>Now, the way these subcommands work seamlessly with Cargo is that developers create these binary crates with a naming convention, such as cargo-[cmd], and when you cargo install that binary crate, Cargo exposes the installed binary to your $PATH variable, which can then be invoked with cargo &lt;cmd&gt; . It's a simple and effective way that's been adopted by Cargo to extend itself with community developed subcommands. There are many other such extensions for Cargo. You can find a list of all community curated subcommands at <a href="https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands">https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands</a> .</p>
<p>cargo install is also used to install any binary crates or executables/applications that are developed in Rust. They are installed in the /home/&lt;user&gt;/.cargo/bin/ directory by default. We'll use this to install our imgtool application—which we will build at the end of this chapter – to make it available system wide.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linting code with clippy</h1>
                
            
            
                
<p>Linting is a practice that helps maintain the quality of your library and have it adhere to standard coding idioms and practices. The de facto linting tool in the Rust ecosystem is clippy. Clippy provides us with a bunch of lints (about 291 at the time of writing this book) to ensure high quality Rust code. In this section, we'll install clippy and try it out on our libawesome library, add some dummy code to it, and see what suggestions we get from clippy. There are various ways of using clippy on your project, but we will use the cargo clippy subcommand way as that's simple. Clippy can perform analysis on code because it's a compiler plugin and has access to a lot of the compiler's internal APIs.</p>
<p>To use clippy, we need to install it by running rustup component add clippy. If you don't have it already, rustup will install it for you. Now, to demonstrate how clippy can point out bad style in our code, we have put some dummy statements within an if condition inside our pow function in the myexponent crate, as follows:</p>
<pre>// myexponent/src/lib.rs<br/><br/>fn pow(base: i64, exponent: usize) -&gt; i64 {<br/>    /////////////////// Dummy code for clippy demo<br/>    let x = true;<br/>    if x == true {<br/>         <br/>    }<br/>    ///////////////////<br/>    let mut res = 1;<br/>    ...<br/>}</pre>
<p>With those lines added, by running cargo clippy in our myexponent directory, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/63b206ea-10ff-42d3-862f-55ab17766869.png"/></p>
<p>Great! Clippy has found a common code style that is redundant, that is, checking for a Boolean value that is either true or false. Alternatively, we could have written the preceding if condition directly as if x {} . There are many more checks that clippy does, and some of them even point out potential mistakes in your code, such as <a href="https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons">https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons.</a> To see all the available lints and various ways of configuring clippy, head over to <a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the manifest file – Cargo.toml</h1>
                
            
            
                
<p>Cargo heavily depends on the project's manifest file, the Cargo.toml file, to get all sorts of information for the project. Let's take a closer look at the structure of this file and what items it can contain. As you saw earlier, cargo new creates an almost empty manifest file, filled with just the necessary fields so that a project can be built. Every manifest file is divided into sections that specify the different properties of a project. We will take a look at the sections that are typically found in a moderate sized Cargo project's manifest file. Here's an imaginary Cargo.toml file from a larger application:</p>
<pre># cargo_manifest_example/Cargo.toml<br/># We can write comments with `#` within a manifest file<br/><br/>[package]<br/>name = "cargo-metadata-example"<br/>version = "1.2.3"<br/>description = "An example of Cargo metadata"<br/>documentation = "https://docs.rs/dummy_crate"<br/>license = "MIT"<br/>readme = "README.md"<br/>keywords = ["example", "cargo", "mastering"]<br/>authors = ["Jack Daniels &lt;jack@danie.ls&gt;", "Iddie Ezzard &lt;iddie@ezzy&gt;"]<br/>build = "build.rs"<br/>edition = "2018"<br/><br/>[package.metadata.settings]<br/>default-data-path = "/var/lib/example"<br/><br/>[features]<br/>default=["mysql"]<br/><br/>[build-dependencies]<br/>syntex = "^0.58"<br/><br/>[dependencies]<br/>serde = "1.0"<br/>serde_json = "1.0"<br/>time = { git = "https://github.com/rust-lang/time", branch = "master" }<br/>mysql = { version = "1.2", optional = true }<br/>sqlite = { version = "2.5", optional = true }</pre>
<p>Let's go through the parts that we haven't explained yet, starting from the [package] section:</p>
<ul>
<li>description: It contains a longer, free-form text field about the project.</li>
<li>license: It contains software license identifiers, as listed in <a href="http://spdx.org/licenses/">http://spdx.org/licenses/</a>.</li>
<li>readme: It allows you to link to a file in your project's repository. This should be shown as the entry point to the project's introduction.</li>
<li>documentation: It contains the link to the crate's documentation if it's a library crate.</li>
<li>keywords: It is a list of single words that helps in discovering your project either through search engines or through the crates.io website.</li>
<li>authors: It lists the project's key authors.</li>
<li>build: It defines a piece of Rust code (typically build.rs) that is compiled and run before the rest of the program is compiled. This is often used to generate code or to build native libraries that the crate depends on.</li>
</ul>
<ul>
<li>edition: This key specifies which edition to use when compiling your project. In our case, we are using the 2018 edition. The previous edition was 2015, which is assumed to be the default if no edition key exists. Note: projects created with the 2018 edition are backward compatible, which means that they can use 2015 crates as dependencies too.</li>
</ul>
<p>Next is [package.metadata.settings]. Typically, Cargo complains about all of the keys and sections that it doesn't know about, but the sections with metadata in them are an exception. They are ignored by Cargo, so they can be used for any configurable key/value pairs you need for your project.</p>
<p>The [features], [dependencies], and [build-dependencies] sections tie in together. A dependency can be declared by version number, as stated in SemVer's guidelines:</p>
<pre>serde = "1.0" </pre>
<p>This means that serde is a mandatory dependency and that we want the newest version, 1.0.*. The actual version will be fixed in Cargo.lock.</p>
<p>Using the caret symbol broadens the version ranges that Cargo is allowed to look for:</p>
<pre>syntex = "^0.58" </pre>
<p>Here, we're saying that we want the latest major version, 0.*.*, which must be at least 0.58.*.</p>
<p>Cargo also allows you to specify dependencies directly to a Git repository, provided that the repository is a project that was created by Cargo and follows the directory structure that Cargo expects. We can specify the dependency from GitHub like so:</p>
<pre>time = { git = "https://github.com/rust-lang/time", branch = "master" } </pre>
<p>This also works for other online Git repositories such as GitLab. Again, the actual version (or in the case of Git, changeset revision) will be fixed in Cargo.lock by the cargo update command.</p>
<p>The manifest also has two optional dependencies, mysql and sqlite:</p>
<pre>mysql = { version = "1.2", optional = true } <br/>sqlite = { version = "2.5", optional = true } </pre>
<p>This means that the program can be built without depending on either. The [features] section contains a list of the default features:</p>
<pre> default = ["mysql"] </pre>
<p>This means that if you do not manually override the feature set when building your program, only mysql, and not sqlite, will be pulled in. An example use of features is when your library has certain optimization tweaks. However, this would be costly on an embedded platform, so the library author can release them as features, which will only be available on capable systems. Another example is when you are building a command-line application and also provide a GUI frontend as an extra feature.</p>
<p>That was a quick brief tour on how to describe a Cargo project using the Cargo.toml manifest file. There's quite a lot more to explore on how to configure your project with Cargo. Take a look at <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">https://doc.rust-lang.org/cargo/reference/manifest.html</a> for more information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a Rust development environment</h1>
                
            
            
                
<p>Rust has decent support for most code editors out there, whether it be vim, Emacs, intellij IDE, Sublime, Atom, or Visual Studio Code. Cargo is also well supported by these editors, and the ecosystem has several tools that enhance the experience, such as the following:</p>
<ul>
<li>rustfmt: It formats code according to conventions that are mentioned in the Rust style guide.</li>
<li>clippy: This warns you of common mistakes and potential code smells. Clippy relies on compiler plugins that are marked as unstable, so it is available with nightly Rust only. With rustup, you can switch to nightly easily.</li>
<li>racer: It can do lookups into Rust standard libraries and provides code completion and tool tips.</li>
</ul>
<p>Among the aforementioned editors, the most mature IDE experience is provided by Intellij IDE and Visual Studio Code (vscode). We will cover setting up the development environment for vscode in this chapter as it is more accessible and lightweight. For vscode, the Rust community has an extension known as rls-vscode, which we'll install here. This extension is consists of the Rust language server (RLS), which uses many of the tools that we listed previously internally. We will be setting it up on Visual Studio Code 1.23.1 (d0182c341) with Ubuntu 16.04.</p>
<p>Installing vscode is beyond the scope of this book. You may look for your operating system's package repositories and go to <a href="https://code.visualstudio.com">https://code.visualstudio.com</a> for more information on the same.</p>
<p>Let's actually open our imgtool application we created at the start of this chapter in vscode:</p>
<pre>cd imgtool<br/>code .            # opens the current directory in vscode</pre>
<p class="mce-root">Once we open our project, vscode recognizes our project automatically as a Rust project and gives us recommendations to download the vscode extension. It will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d3dc2e1-222a-4d19-8430-c530e1ec5962.png"/></p>
<p> If you don't get recommendations, you can always type Rust in the search bar on the top left. We can then click on Install and press Reload on the extension page, which restarts vscode and makes it available for use in our project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/666378c4-6986-4f6c-836e-45b167bde200.png"/></p>
<p>Next time you open the main.rs file in the project and start typing, the extension will kick in and prompt you to install any missing toolchains related to Rust that you can click install. It then starts downloading that toolchain:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/330ecea7-31f3-4978-8e8b-bbfe8f703a11.png"/></p>
<p>After a few minutes, the status will change, like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bd7927bb-7700-40de-8dc7-d6a9de758ba3.png"/></p>
<p>Now, we are good to go.</p>
<p>Note: Since RLS is still in its preview phase, you may experience RLS getting stuck when installing on its first go. By restarting vscode and reinstalling RLS again after removing it, it should work. If it doesn't, feel free to raise an issue on its GitHub page: <a href="https://github.com/rust-lang-nursery/rls-vscode">rls-vscode</a>.</p>
<p>With our imgtool project opened, let's see how RLS responds when we try to import a module:</p>
<div><img src="img/1ab61d99-ff36-49f1-b770-7535b5c90dc6.png"/></div>
<p>As you can see, it performs auto completion for the items that are available in the fs module in the Rust standard library. Finally, let's take a look at how RLS handles formatting code for us. Let's put all of the code on the same line to demonstrate this:</p>
<div><img src="img/fde7a7f9-2ea3-4476-8159-7ea93ab944ca.png"/></div>
<p>Let's save the file. We can then use Ctrl + Shift + I or Ctrl + Shift + P and select Format Document. This will instantly format the document and run cargo check against your code once you hit Save:</p>
<div><img src="img/6b51de7c-4d6d-4819-a93c-879823274426.png"/></div>
<p class="mce-root">For more information on other code editors, Rust has a page called <a href="https://areweideyet.com/">https://areweideyet.com</a> that lists the status of all editors, along with the categories, showing the extent of support they have for the language. Do check them out!</p>
<p>Now, let's continue to implement our imgtool application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a project with Cargo – imgtool</h1>
                
            
            
                
<p>We now have a fairly good understanding of how to manage projects using Cargo. To drive the concepts in, we will build a command-line application that uses a third-party crate. The whole point of this exercise is to become familiar with the usual workflow of building projects by using third-party crates, so we're going to skip over a lot of details about the code we write here. You are encouraged to check out the documentation of the APIs that are used in the code, though.</p>
<p>We'll use a crate called image from crates.io. This crate provides various image manipulation APIs. Our command-line application will be simple; it will take a path to an image file as its argument, rotate it by 90 degrees, and write back to the same file, every time when run.</p>
<p>We'll cd into the imgtool directory, which we created previously. First, we need to tell Cargo that we want to use the image crate. We can use the cargo add image@0.19.0 command to add the image crate with version 0.19.0 from the command line. Here's our updated Cargo.toml file:</p>
<div><pre>[package]<br/>name = "imgtool"<br/>version = "0.1.0"<br/>authors = ["creativcoder"]<br/>edition = "2018"<br/><br/>[dependencies]<br/>image = "0.19.0"</pre></div>
<p>Then, we'll invoke cargo build. This pulls the image crate from crates.io and pulls its dependencies, before finally compiling our project. Once that is done, we are ready to use it in our main.rs file. For our app, we'll provide an image path as an argument. In our main.rs file, we want to read this image's path:</p>
<pre>// imgtool/src/main.rs<br/><br/>use std::env;<br/>use std::path::Path;<br/><br/>fn main() {<br/>    let image_path = env::args().skip(1).next().unwrap();<br/>    let path = Path::new(&amp;image_path);<br/>}</pre>
<p>First, we read the argument that was passed to imgtool by invoking the args() function from the env module. This returns a string as a path to the image file. We then take the image path and create a Path instance out of it. Next comes the rotate functionality that comes from the image crate. Note that if you're running Rust 2015 edition, you will need an additional extern crate image; declaration on top of main.rs for you to be able to access the image crate's APIs. With Rust 2018 edition, this is not needed:</p>
<pre>// imgtool/src/main.rs<br/><br/>use std::env;<br/>use std::path::Path;<br/><br/>fn main() {<br/>    let image_path = env::args().skip(1).next().unwrap();<br/>    let path = Path::new(&amp;image_path);<br/>    let img = image::open(path).unwrap();<br/>    let rotated = img.rotate90();<br/>    rotated.save(path).unwrap();<br/>}</pre>
<p>From the image crate, we use the open function to open our image and store it in img. We then call rotate90 on img. This returns an image buffer as rotated, which we just save back to the original image path by calling save and passing the path. Most of the function calls in the preceding code return a wrapper value called Result, and so we call unwrap() on Result values to tell the compiler that we don't care whether the function call failed, assuming that it has succeeded, and we just want to get the wrapped value from the Result type. We will learn about the Result type and proper error handling methods in <a href="35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml">Chapter 6</a>, Error Handling. For the demo, under the project's asset folder, you will find an image of Ferris the crab (assets/ferris.png). Before running the code, we will see the following image:</p>
<div><img src="img/6ad86620-328b-4554-aa09-40217f42a948.png" style="width:15.33em;height:8.67em;"/></div>
<p>Time to run our application with this image as an argument. Now, there are two ways you can run the imgtool binary and pass the image as an argument:</p>
<ul>
<li>By doing a cargo build and then invoking the binary manually as ./target/debug/imgtool assets/ferris.png.</li>
<li>By directly running cargo run -- assets/ferris.png. The double dashes mark the end of the parameters for Cargo's own arguments. Anything after it is passed to our executable (here, this is imgtool).</li>
</ul>
<p>After running cargo run -- assets/ferris.png, we can see that Ferris has taken a tumble:</p>
<div><img src="img/bd71b4be-3c8c-46c9-8dbc-072785f58c0c.png" style="width:8.00em;height:13.67em;"/></div>
<p>Great! Our application works. We can now install our tool by running cargo install inside our imgtool directory and then use it from anywhere in our terminal. Also, if you are on Ubuntu, we can use the cargo deb subcommand to create a deb package so that you can distribute it to other consumers. Running the cargo deb command produces the .deb file, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3de74bba-7bbf-4ed5-bf79-7ca9a3391488.png"/></p>
<p>Now, it's time for you to explore more in relation to the preceding code:</p>
<ul>
<li>Use the Rust standard library docs at <a href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a> to learn about the unwrap() function in Rust and on what types it is available.</li>
<li>Look for the Path type in the standard library docs to see if you can modify the program to not overwrite the files, and instead create a new file with  _rotated as the new file suffix.</li>
<li>Use the search bar in the documentation page of the image crate (<a href="https://docs.rs/image">https://docs.rs/image</a>) and try finding other rotate methods with different angles, and modify the code to make use of them.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we got acquainted with the standard Rust build tool, Cargo. We took a cursory look at initializing, building, and running tests using Cargo. We also explored tools beyond Cargo that make developer experience smoother and more efficient, such as RLS and clippy. We saw how these tools can be integrated with the Visual Studio Code editor by installing the RLS extension. Finally, we created a small CLI tool to manipulate images by using a third-party crate from Cargo.</p>
<p>In the next chapter, we will be talking about testing, documenting, and benchmarking our code.</p>


            

            
        
    </body></html>