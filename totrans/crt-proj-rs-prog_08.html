<html><head></head><body>
        

                            
                    Using a Parser Combinator for Interpreting and Compiling
                
            
            
                
<p>Rust is a system programming language. A typical task of system programming is processing <em>formal languages</em>. Formal languages are languages specified by well-defined logical rules and used everywhere in computer technology. They can be broadly classified into command, programming, and markup languages.</p>
<p>To process formal languages, the first step is to parse. <strong>Parsing </strong>means analyzing the grammatical structure of a piece of code to check whether it respects the rules of the grammar it is supposed to use, and then, if the grammar is respected, to generate a data structure that describes the structure of the parsed piece of code, in a way that such code can be further processed.</p>
<p>In this chapter, we will see how to process text written in a formal language, starting from the parsing step and proceeding with several possible outcomes—simply checking the grammar, interpreting a program, and translating a program into the Rust language.</p>
<p>To show such features, an extremely simple programming language will be defined, and four tools (syntax checker, semantic checker, interpreter, and translator) will be built around it.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Defining a programming language using a formal grammar</li>
<li>Classifying programming languages into three categories</li>
<li>Learning two popular techniques for building parsers—compiler-compilers and parser combinators</li>
<li>Using a parser combinator library for Rust named <strong>Nom</strong></li>
<li>Processing a source code to check its syntax following a <strong>context-free grammar</strong>, using the Nom library (<kbd>calc_parser</kbd>)</li>
<li class="mce-root">Verifying the consistency of variable declarations and their usage in some source code, and at the same time preparing the required structure for optimal execution of the code (<kbd>calc_analyzer</kbd>)</li>
<li class="mce-root">Executing the preprocessed code, in a process named <strong>inter</strong><strong>pretation</strong> (<kbd>calc_interpreter</kbd>)</li>
<li class="mce-root">Translating the preprocessed code into another programming language, in a process named <strong>compilation </strong>(<kbd>calc_compiler</kbd>); as an example, translation to Rust code will be shown</li>
</ul>
<p>After reading this chapter, you will be able to write the grammar for a simple formal language or understand the grammar for an existing formal language. You will also be able to write an interpreter for any programming language by following its grammar. Also, you will be able to write a translator for a formal language into another formal language, following their grammar.</p>
<h1 id="uuid-c30c527e-7dbf-4ab2-aae8-3c2de4decb8e">Technical requirements</h1>
<p>To read this chapter, knowledge of the preceding chapters is not required. Some knowledge of formal language theory and techniques is useful but not required, because the required knowledge will be explained in this chapter. The Nom library will be used to build such tools, and so it will be described in this chapter.</p>
<p>The complete source code for this chapter is in the <kbd>Chapter08</kbd> folder of the GitHub repository, located at <a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a>.</p>
<h1 id="uuid-74106e3c-37fc-48d0-84a9-f0e4b3bc5392">Project overview</h1>
<p>In this chapter, we will build four projects of increasing complexity, listed as follows:</p>
<ul>
<li>The first project (<kbd>calc_parser</kbd>) will just be a syntax checker for the <kbd>Calc</kbd> language. Actually, it is just a parser, followed by a formatted debugging print of the parsing result.</li>
<li>The second project (<kbd>calc_analyzer</kbd>) uses the parsing result of the first project to add the verification of the consistency of the variable declarations and of their usage, followed by a formatted debugging print of the analysis result.</li>
<li>The third project (<kbd>calc_interpreter</kbd>) uses the analysis result to execute the preprocessed code, in an interactive interpreter.</li>
<li>The fourth project (<kbd>calc_compiler</kbd>) uses the analysis result again to translate the preprocessed code into equivalent Rust code.</li>
</ul>
<h1 id="uuid-816f6102-1de5-48b9-a6f9-57adaddd04ec">Introducing Calc</h1>
<p class="mce-root">To make the following explanations, we will first define a <em>toy</em> programming language that we will name <kbd>Calc</kbd> (from the calculator). A toy programming language is a programming language used to demonstrate or prove something, not designed to develop real-world software. A simple program written in <kbd>Calc</kbd> is shown as follows:</p>
<pre>@first<br/>@second<br/>&gt; first<br/>&gt; second<br/>@sum<br/>sum := first + second<br/>&lt; sum<br/>&lt; first * second</pre>
<p class="mce-root">The preceding program asks the user to type two numbers and then prints the sum and the product of those numbers on the console. Let's examine one statement at a time, as follows:</p>
<ul>
<li>The first two statements (<kbd>@first</kbd> and <kbd>@second</kbd>) declare two variables. Any variable in <kbd>Calc</kbd> represents a 64-bit floating-point number.</li>
<li>The third and fourth statements (<kbd>&gt; first</kbd> and <kbd>&gt; second</kbd>) are input statements. Each of these prints a question mark and waits for the user to type a number and press <em>Enter</em>. Such a number, if valid, is stored in the specified variable. If no number or an invalid number is typed before pressing <em>Enter</em>, the value <kbd>0</kbd> is assigned to the variable.</li>
<li>The fifth statement declares the <kbd>sum</kbd> variable.</li>
<li>The sixth statement (<kbd>sum := first + second</kbd>) is a Pascal-style assignment. It computes the sum of the <kbd>first</kbd> and <kbd>second</kbd> variables and assigns the result to the <kbd>sum</kbd> variable.</li>
<li>The seventh and eight statements perform output. The seventh statement (<kbd>&lt; sum</kbd>) prints on the console the current value of the <kbd>sum</kbd> variable. The eighth statement (<kbd>&lt; first * second</kbd>) computes the multiplication between the current values of the <kbd>first</kbd> and <kbd>second</kbd> variables, and then prints on the console the result of such multiplication.</li>
</ul>
<p class="mce-root"/>
<p>The <kbd>Calc</kbd> language has two other operators—<kbd>-</kbd> (minus) and <kbd>/</kbd> (divide)— to specify subtraction and division, respectively. In addition, the following code shows that the operations can be combined in expressions, and so these are valid assignment statements:</p>
<pre>y := m * x + q<br/>a := a + b - c / d</pre>
<p>Operations are performed left to right, but multiplication and division have higher precedence than addition and subtraction.</p>
<p>In addition to variables, numeric literals are also allowed. So, you can write the following code:</p>
<pre>a := 2.1 + 4 * 5</pre>
<p>This statement assigns <kbd>22.1</kbd> to <kbd>a</kbd>, as multiplication is performed before addition. To force different precedence, parentheses are allowed, as illustrated in the following code snippet:</p>
<pre>a := (2.1 + 4) * 5</pre>
<p>The preceding code snippet assigns <kbd>30.5</kbd> to <kbd>a</kbd>.</p>
<p>In the preceding code snippet, there are no characters that separate a statement from the next one, in addition to the newline characters. Actually, the <kbd>Calc</kbd> language has no symbols used to separate statements, and also, it does not need them. So, the first program should be equivalent to this:</p>
<pre>@first@second&gt;first&gt;second@sum sum:=first+second&lt;sum&lt;first*second</pre>
<p>In the preceding code snippet, there is no ambiguity because the <kbd>@</kbd> character marks the start of a declaration, the <kbd>&gt;</kbd> character marks the start of an input operation, the <kbd>&lt;</kbd> character marks the start of an output operation, and a variable in a location where the current statement does not allow a variable marks the start of an assignment.</p>
<p>To understand this syntax, some grammatical terms must be explained, as follows:</p>
<ul>
<li>The whole text is a <strong>program</strong>.</li>
<li>Any program is a sequence of <strong>statements</strong>. In the first example program, there is exactly one statement for each line.</li>
<li>In some statements, there can be an arithmetic formula that can be evaluated, such as <kbd>a * 3 + 2</kbd>. This formula is an <strong>expression</strong>.</li>
<li>Any expression can contain sums or subtractions of simpler expressions. The simpler expressions that contain neither sums nor subtractions are named <strong>terms</strong>. Therefore, any expression can be a term (if it contains neither sums nor subtractions), or it can be the sum of an expression and a term, or it can be the subtraction of an expression and a term.</li>
<li>Any term can contain multiplications or divisions of simpler expressions. The simpler expressions that contain neither multiplications nor divisions are named <strong>factors</strong>. Therefore, any term can be a factor (if it contains neither multiplications nor divisions), or it can be the multiplication of a term and a factor, or it can be the division of a term and a factor. There are three possible kinds of factors, listed here:
<ul>
<li>Names of variables, named <strong>identifiers</strong></li>
<li>Numerical constants, represented by sequences of digits, named <strong>literals</strong></li>
<li>Full expressions enclosed in parentheses, to force their precedence</li>
</ul>
</li>
</ul>
<p>In the <kbd>Calc</kbd> language, for the sake of simplicity and unlike in most programming languages, digits and underscores are not allowed in identifiers. So, any identifier is a non-empty sequence of letters. Or, put another way, any identifier can be a letter or an identifier followed by a letter. </p>
<p class="mce-root">The syntax of formal languages can be specified by a notation that is known as <strong>Backus–Naur</strong> form. Using this notation, our <kbd>Calc</kbd> language can be specified by the following rules:</p>
<pre>&lt;program&gt; ::= "" | &lt;program&gt; &lt;statement&gt;<br/>&lt;statement&gt; ::= "@" &lt;identifier&gt; | "&gt;" &lt;identifier&gt; | "&lt;" &lt;expr&gt; | &lt;identifier&gt; ":=" &lt;expr&gt;<br/>&lt;expr&gt; ::= &lt;term&gt; | &lt;expr&gt; "+" &lt;term&gt; | &lt;expr&gt; "-" &lt;term&gt;<br/>&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt; "*" &lt;factor&gt; | &lt;term&gt; "/" &lt;factor&gt;<br/>&lt;factor&gt; ::= &lt;identifier&gt; | &lt;literal&gt; | "(" &lt;expr&gt; ")"<br/>&lt;identifier&gt; := &lt;letter&gt; | &lt;identifier&gt; &lt;letter&gt;</pre>
<p>The explanation for all the rules used in the preceding code snippet is described as follows:</p>
<ul>
<li>The first rule specifies that a program is an empty string or a program followed by a statement. This amounts to saying that a program is a list of zero or more statements.</li>
<li>The second rule specifies that a statement is either a <kbd>@</kbd> character followed by an identifier, a <kbd>&gt;</kbd> character followed by an identifier, a <kbd>&lt;</kbd> character followed by an expression, or an identifier followed by the <kbd>:=</kbd> pair of characters and then by an expression.</li>
<li>The third rule specifies that an expression is either a term or an expression followed by the <kbd>+</kbd> character and a term, or an expression followed by the <kbd>-</kbd> character and a term. This amounts to saying that an expression is a term followed by zero or more term items, where a term-item is a <kbd>+</kbd> or a <kbd>-</kbd> operator followed by a term.</li>
<li>Similarly, the fourth rule specifies that a term is either a factor or a term followed by the <kbd>*</kbd> character and a factor, or a term followed by the <kbd>/</kbd> character and a factor. This amounts to saying that a term is a factor followed by zero or more factor items, where a factor-item is a multiply or a divide operator followed by a factor.</li>
<li>The fifth rule specifies that a factor is either an identifier or a literal, or an expression enclosed in parentheses. This rule is satisfied only if the parentheses are correctly paired in code.</li>
<li>The sixth rule specifies that an identifier is a letter or an identifier followed by a letter. This amounts to saying that an identifier is a sequence of one or more letters. This syntax does not specify how case-sensitiveness is handled, but we will assume identifiers are case-sensitive.</li>
</ul>
<p>This syntax leaves undefined what is meant by the <kbd>&lt;letter&gt;</kbd> symbol and by the <kbd>&lt;literal&gt;</kbd> symbol, therefore these are explained here:</p>
<ul>
<li>The <kbd>&lt;letter&gt;</kbd> symbol means any character for which the <kbd>is_alphabetic</kbd> Rust standard library function returns <kbd>true</kbd>.</li>
<li>The <kbd>&lt;literal&gt;</kbd> symbol means any floating-point number. In fact, as we are going to use Rust code to parse it, store it, and handle it, the <kbd>Calc</kbd> definition of <kbd>literal</kbd> is the same as the Rust definition of <kbd>f64</kbd> literals. For example <kbd>-4.56e300</kbd> will be allowed, but <kbd>1_000</kbd> and <kbd>3f64</kbd> will not be allowed.</li>
</ul>
<p>Another simplification has been done regarding white spaces. Spaces, tabs, and newline characters are allowed in all positions of code, except inside an identifier, inside a literal, and inside the <kbd>:=</kbd> symbol. They are optional, but the only position where white space is required is between the ending identifier of a statement and the beginning identifier of an assignment because, otherwise, the two identifiers would merge into one.</p>
<p>In this section, we have defined the syntax of the <kbd>Calc</kbd> language. Such a formal definition is called a <strong>grammar</strong>. It is a very simple grammar, but it is similar to the grammar of real-world programming languages. Having a formal grammar for a language is useful for building software that processes code written in such a language.</p>
<p>Now that we have seen our toy language, we are ready to process code written in it. The first task is to build a syntax checker that verifies the structural validity of any program in this language.</p>
<p class="mce-root"/>
<h1 id="uuid-36357ea3-ace9-4ada-b397-0b924138ef04">Understanding formal languages and their parsers</h1>
<p>As we've seen, a typical task of system programming is processing <em>formal languages</em>. Several kinds of operations are customarily performed in such formal languages. The most typical ones are listed here:</p>
<ul>
<li>To check the syntax validity of a line or of a file</li>
<li>To format a file according to formatting rules</li>
<li>To execute a command written in a command language</li>
<li>To interpret a file written in a programming language—that is, execute it immediately</li>
<li>To compile a file written in a programming language—that is, translate it into another programming language, such as an assembly language or a machine language</li>
<li>To translate a markup file into another markup language</li>
<li>To render a markup file in a browser</li>
</ul>
<p>All these operations have in common the first step of the procedure—parsing. The process of examining a string to extract its structure according to the grammar is called <strong>parsing</strong>. There are at least three kinds of possible parsing techniques, according to the category of the formal language we want to parse. These categories, which we are going to see in this section, are: <strong>regular languages</strong>, <strong>context-free languages</strong>, and <strong>context-dependent languages</strong>.</p>
<h2 id="uuid-18aa5010-3a5d-4e97-aa10-3f266128b4e0">Regular languages</h2>
<p>The category of the simplest languages is that of regular languages, which can be defined using regular expressions.</p>
<p>In the simplest way, a regular expression is a pattern using the following operators between substrings:</p>
<ul>
<li><strong>Concatenation</strong> <strong>(or sequence)</strong>: This means that a substring must follow another substring; for example, <kbd>ab</kbd> means that <kbd>b</kbd> must follow <kbd>a</kbd>.</li>
<li><strong>Alternation</strong> <strong>(or choice)</strong>: This means that a substring can be used instead of another substring; for example, <kbd>a|b</kbd> means that <kbd>a</kbd> or <kbd>b</kbd> can be used alternatively.</li>
<li><strong>Kleene star</strong> <strong>(or repetition)</strong>: This means that a substring can be used zero or more times; for example, <kbd>a*</kbd> means that <kbd>a</kbd> can be used zero, one, two, or more times.</li>
</ul>
<p>To apply such operators, parentheses can be used. So, the following is a regular expression: </p>
<p class="CDPAlignCenter CDPAlign"><em>a(bcd|(ef)*)g</em></p>
<p>This means that a valid string must begin with an <em>a</em>, followed by two possible substrings— one is the string <em>bcd</em> and the other is an empty string or the string <em>ef</em>, or any multiple repetitions of the string <em>ef,</em> and then, there must be <em>g</em>. The following are some strings belonging to such regular languages: </p>
<ul>
<li><em>abcdg</em></li>
<li><em>ag</em></li>
<li><em>aefg</em></li>
<li><em>aefefg</em></li>
<li><em>aefefefg</em></li>
<li><em>aefefefefg</em></li>
</ul>
<p>An advantage of regular languages is that their parsing requires an amount of memory that depends only on the grammar and does not depend on the text being parsed; so, typically, they require little memory even to parse huge texts.</p>
<p>The regex crate is the most popular way to parse regular languages using regular expressions. If you have regular languages to parse, then it is recommended to use such a library. For example, detecting a valid identifier or a valid floating-point number is a regular language parser's job.</p>
<h2 id="uuid-f72867b2-8d18-48a2-a636-8e5016ce389f">Context-free languages</h2>
<p>Since programming languages are not simply regular languages, regular expressions cannot be used to parse them. A typical language feature that does not belong to regular languages is the use of parentheses. Most programming languages allow the <kbd>((5))</kbd> string but not the <kbd>((5)</kbd> string because any open parenthesis must be matched by a closing parenthesis. Such a rule cannot be expressed by a regular expression.</p>
<p>A more general (and so more powerful) category of languages is that of context-free languages. These languages are defined by grammar, as with the one seen in the preceding section on the <kbd>Calc</kbd> language, including the fact that some elements must be matched (such as parentheses, brackets, braces, and quotes).</p>
<p class="mce-root"/>
<p>Differing from regular languages, context-free languages require a variable amount of memory depending on the parsed text. Every time an open parenthesis is encountered, it must be stored somewhere to match it with the corresponding closed parentheses. Although such memory usage is usually quite small and it is accessed in a <strong>Last-In-First-Out</strong> (<strong>LIFO</strong>) fashion (as it would be in a stack data structure), it is quite efficient because no heap allocation is required.</p>
<p>Even context-free languages are enough for real-world usage, though, because real-world languages need to be context-dependent, as explained in the following section.</p>
<h2 id="uuid-a136d0f3-f7a3-4a05-aba0-783e21db8f4d">Context-dependent languages</h2>
<p>Unfortunately, even CFGs are not powerful enough to represent real-world programming languages. The problem lies in the usage of identifiers.</p>
<p>In many programming languages, before using a variable, you must declare it. In any location of the code, only the variables defined up to that point can be used. Such a set of available identifiers is taken as the context in which the next statement is parsed. In many programming languages, such a context contains not only the name of the variable but also its type, and the fact that it surely has already received a value or it may be still uninitialized.</p>
<p>To capture such constraints, context-dependent languages can be defined, though such formalism is quite unwieldy and the resulting grammar is inefficient to parse.</p>
<p>Therefore, the usual way to parse a programming language text is to split parsing into several conceptual passes, as follows:</p>
<ul>
<li class="mce-root"><strong>Pass 1</strong>: Use regular expressions where you can—that is, to parse identifiers, literals, operators, and separators. This pass generates a stream of <em>tokens</em>, where each token represents one of the parsed items. So, for example, any identifier is a different token, while white space and comments are skipped. This pass is usually named <strong>lexical analysis</strong> or <strong>lexing</strong>.</li>
<li><strong>Pass 2</strong>: Use a context-free parser where you can—that is, to apply the grammar rules to the stream of tokens. This pass creates a tree-shaped structure representing the program. This structure is named a <strong>syntax tree</strong>. The tokens are stored as the leaves (that is, terminal nodes) of this tree. This tree can still contain context-dependent errors, such as the usage of an undeclared identifier. This pass is usually named <strong>syntax analysis</strong>.</li>
<li><strong>Pass 3</strong>: Process the syntax tree to associate any variable use with the declaration of such a variable, and possibly check its type. This pass creates a new data structure, named <strong>symbol table</strong>, that describes all the identifiers found in the syntax tree, and it decorates the syntax tree with references to such a symbol table. This pass is usually named <strong>semantic analysis</strong> because it usually also regards type checking.</li>
</ul>
<p>When we have a decorated syntax tree and its relative symbol table, the parsing operation is completed. Now, the developer can perform the following operations with such data structures:</p>
<ul>
<li>Get the syntax errors, in case the code is invalid</li>
<li>Get suggestions about how to improve the code</li>
<li>Get some metrics about the code</li>
<li>Interpret the code (in case the language is a programming language)</li>
<li>Translate the code into another language</li>
</ul>
<p>In this chapter, the following operations will be performed:</p>
<ul>
<li>The lexical analysis pass and the syntax analysis pass will be grouped in a single pass that will process source code and will generate a syntax tree (in the <kbd>calc_parser</kbd> project).</li>
<li>The semantic analysis pass will use the syntax tree generated by the parser to create a symbol table and a decorated syntax tree (in the <kbd>calc_analyser</kbd> project).</li>
<li>The symbol table and the decorated syntax tree will be used to execute the program written in the <kbd>Calc</kbd> language (in the <kbd>calc_interpreter</kbd> project).</li>
<li>The symbol table and the decorated syntax tree will also be used to translate the program into the Rust language (in the <kbd>calc_complier</kbd> project).</li>
</ul>
<p>In this section, we have seen a useful classification of programming languages. Even if every programming language belongs to the context-dependent category, the other categories are still useful because interpreters and compilers use regular grammars and CFGs as a part of their operation.</p>
<p>But before seeing a complete project, let's have a look at the techniques used to build a parser, and in particular, the technique used by the Nom library.</p>
<h1 id="uuid-29876540-3979-4f65-94f6-d4803d505dd2">Using Nom to build parsers</h1>
<p>Before starting to write a parser for the <kbd>Calc</kbd> language, let's have a look at the most popular parsing techniques used for building both interpreters and compilers. This is needed to understand the Nom library, which uses one of these techniques.</p>
<h2 id="uuid-af9677fd-636d-454e-8c5d-bdcd9455996d">Learning about compiler-compilers and parser combinators</h2>
<p>To obtain an extremely fast and flexible parser, you need to build it from scratch. But for decades, an easier approach was used to build parsers by using tools named <strong>compiler-compilers</strong> or <strong>compiler generators</strong>: programs that generate compilers. These programs get input as a decorated specification of the syntax and generate the source code of a parser for such a syntax. These generated source code must then be compiled, together with other source files, to get an executable compiler.</p>
<p>This traditional approach is now somewhat out of fashion and another one has emerged, named <strong>parser combinator</strong>. A parser combinator is a set of functions that allow several parsers to be combined to obtain another parser.</p>
<p>We have seen that any <kbd>Calc</kbd> program is just a sequence of <kbd>Calc</kbd> statements. If we had a parser of single <kbd>Calc</kbd> statements and the ability to apply such a parser in sequence, then we could parse any <kbd>Calc</kbd> program.</p>
<p>We should know that any <kbd>Calc</kbd> statement is either a <kbd>Calc</kbd> declaration, a <kbd>Calc</kbd> assignment, a <kbd>Calc</kbd> input operation, or a <kbd>Calc</kbd> output operation. If we had a parser for each of such statements and the ability to apply any such parsers alternatively, we could parse any <kbd>Calc</kbd> statement. We can go on until we get to single characters (or to tokens if we use the output of a lexical analyzer). So, a parser of a program can be obtained by combining the parsers of its component items.</p>
<p>But what is a parser written in Rust? It is a function that gets a string of source code as input and returns a result. The result can be <kbd>Err</kbd> (if that string couldn't be parsed) or <kbd>Ok</kbd> (containing a data structure representing the parsed item).</p>
<p class="mce-root"/>
<p>So, while normal functions receive data as input and return data as output, our parser combinators receive one or more parsers that have functions as input and return a parser as output. Functions that receive functions as input and return a function as output are named <strong>second-order</strong> <strong>functions</strong> because they process functions instead of data. In computer science, the concept of second-order functions originates from functional languages, and the concept of parser combinators also comes from such languages.</p>
<p>In Rust, second-order functions were not feasible before the 2018 edition, because Rust functions could not return functions without allocating a closure. Therefore, the Nom library (up to version 4) used macros instead of functions as combinators to maintain top performance. When Rust introduced the <kbd>impl Trait</kbd> feature (included in the 2018 edition), an efficient implementation of parser combinators using functions instead of macros became possible. So, version 5 of Nom is entirely based on functions, keeping macros only for backward compatibility.</p>
<p>In the next section, we will see the basic features of the Nom library, which we are going to use to build both an interpreter and a compiler.</p>
<h2 id="uuid-ef3d2714-9562-4c0f-98d4-3ba586aef6a6">Learning the basics of Nom</h2>
<p>The Nom crate is essentially a collection of functions. Most of them are parser combinators—that is, they get one or more parsers as arguments and return a parser as a return value. You can think of them as machines that get one or more parsers as input and emit a combined parser as output.</p>
<p>Some of the Nom function are parsers—that is, they get a sequence of <kbd>char</kbd> values as an argument and return an error if the parse fails, or a data structure representing the parsed text, in the case of success.</p>
<p>Now, we'll see the most basic features of Nom, using very simple programs. In particular, we'll see the following:</p>
<ul>
<li>The <kbd>char</kbd> parser: To parse single fixed characters</li>
<li>The <kbd>alt</kbd> parser combinator: To accept alternative parsers</li>
<li>The <kbd>tuple</kbd> parser combinator: To accept a fixed sequence of parsers</li>
<li>The <kbd>tag</kbd> parser: To parse fixed strings of a character</li>
<li>The <kbd>map</kbd> parser combinator: To transform the output value of parsers</li>
<li>The <kbd>Result::map</kbd> function: To apply more complex transformations on the output of a parser</li>
<li>The <kbd>preceded</kbd>, <kbd>terminated</kbd>, and <kbd>delimited</kbd> parser combinators: To accept a fixed sequence of parsers and discard some of them from the output</li>
<li>The <kbd>take</kbd> parser: To accept a defined number of characters</li>
<li>The <kbd>many1</kbd> parser combinator: To accept a sequence of one or more repetitions of a parser</li>
</ul>
<h3 id="uuid-b66ef134-041e-4e12-ab05-81ce01833159">Parsing an alternative of characters</h3>
<p>As an example of a parser, let's see how to parse an alternative of fixed characters. We want to parse an extremely simple language, a language that has only three words—<em>a</em>, <em>b</em>, and <em>c</em>. Such a parser would succeed only if its input is the string <em>a</em> or the string <em>b</em> or the string <em>c</em>.</p>
<p>If the parsing is successful, we want a couple of things as a result—the remaining input (that is, after the valid part has been processed) and a representation of the processed text. As our words are made up of single characters, we want (as a representation of that) a value of the <kbd>char</kbd> type, containing just the parsed character.</p>
<p>The following snippet is our first code using Nom:</p>
<pre>extern crate nom;<br/>use nom::{branch::alt, character::complete::char, IResult};<br/><br/>fn parse_abc(input: &amp;str) -&gt; IResult&lt;&amp;str, char&gt; {<br/>    alt((char('a'), char('b'), char('c')))(input)<br/>}<br/><br/>fn main() {<br/>    println!("a: {:?}", parse_abc("a"));<br/>    println!("x: {:?}", parse_abc("x"));<br/>    println!("bjk: {:?}", parse_abc("bjk"));<br/>}</pre>
<p>If you compile this program, including the dependency of the Nom crate, and you run it, it should print the following output:</p>
<pre><strong>a: Ok(("", 'a'))</strong><br/><strong>x: Err(Error(("x", Char)))</strong><br/><strong>bjk: Ok(("jk", 'b'))</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We named our parser <kbd>parse_abc</kbd>. It gets a string slice as input and returns a value of the <kbd>IResult&lt;&amp;str, char&gt;</kbd> type. Such a return value type is a kind of <kbd>Result</kbd>. The <kbd>Ok</kbd> case of such a <kbd>Result</kbd> type is a tuple of two values—a string slice containing the remaining input, and a character—that is, the information we got by parsing the text. The <kbd>Err</kbd> case of such a <kbd>Result</kbd> type is defined internally by the Nom crate.</p>
<p>As you can see in the output, the <kbd>parse_abc("a")</kbd> expression returns <kbd>Ok(("", 'a'))</kbd>. This means that when the <kbd>a</kbd> string is parsed, the parsing is successful; no input is left to process, and the character extracted is <kbd>'a'</kbd>.</p>
<p>Instead, the <kbd>parse_abc("x")</kbd> expression returns <kbd>Err(Error(("x", Char)))</kbd>. This means that when the <kbd>x</kbd> string is parsed, the parsing fails; the <kbd>x</kbd> string remains to process, and the kind of error is <kbd>Char</kbd>, meaning that a <kbd>Char</kbd> item was expected. Notice that <kbd>Char</kbd> is a type defined by Nom.</p>
<p>Lastly, the <kbd>parse_abc("bjk")</kbd> expression returns <kbd>Ok(("jk", 'b'))</kbd>. This means that when the string <kbd>bjk</kbd> is parsed, the parsing is successful; the <kbd>jk</kbd> input remains to be processed, and the character extracted is <kbd>'b'</kbd>.</p>
<p>And now, let's see how our parser is implemented. The signature of all parsers built for Nom must have a similar signature, and their body must be a function call that has the function argument as its argument (in this case, <kbd>(input)</kbd>).</p>
<p>The interesting part is <kbd>alt((char('a'), char('b'), char('c')))</kbd>. This expression means that we want to build a parser by combining the three parsers, <kbd>char('a')</kbd>, <kbd>char('b')</kbd>, and <kbd>char('c')</kbd>. The <kbd>char</kbd> function (not to be confused with the Rust type having the same name) is a built-in Nom parser that recognizes the specified character and returns a value of the <kbd>char</kbd> type containing that character. The <kbd>alt</kbd> function (short for alternative) is a parser combinator. It has just one argument, which is a tuple composed of several parsers. The <kbd>alt</kbd> parser chooses one of the specified parsers that match the input.</p>
<p>It's your responsibility to guarantee that there is at most one parser accepting the input, for any given input. Otherwise, the grammar is ambiguous. Here is an example of an ambiguous parser—<kbd>alt((char('a'), char('b'), char('a')))</kbd>. The <kbd>char('a')</kbd> sub-parser is repeated, but this will not be spotted by the Rust compiler.</p>
<p>In the next section, we will see how to parse a sequence of characters.</p>
<p class="mce-root"/>
<h3 id="uuid-6db46165-2f29-4896-a4af-8accbfdfeedf">Parsing a sequence of characters</h3>
<p>Now, let's see another parser, given as follows:</p>
<pre>extern crate nom;<br/>use nom::{character::complete::char, sequence::tuple, IResult};<br/><br/>fn parse_abc_sequence(input: &amp;str)<br/>    -&gt; IResult&lt;&amp;str, (char, char, char)&gt; {<br/>    tuple((char('a'), char('b'), char('c')))(input)<br/>}<br/><br/>fn main() {<br/>    println!("abc: {:?}", parse_abc_sequence("abc"));<br/>    println!("bca: {:?}", parse_abc_sequence("bca"));<br/>    println!("abcjk: {:?}", parse_abc_sequence("abcjk"));<br/>}</pre>
<p>After running it, it should print the following:</p>
<pre><strong>abc: Ok(("", ('a', 'b', 'c')))</strong><br/><strong>bca: Err(Error(("bca", Char)))</strong><br/><strong>abcjk: Ok(("jk", ('a', 'b', 'c')))</strong></pre>
<p>This time, the letters <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>c</kbd> must be in this exact sequence, and a tuple containing these characters is returned by the <kbd>parse_abc_sequence</kbd> function. For the <kbd>abc</kbd> input, there is no remaining input, and the <kbd>('a', 'b', 'c')</kbd> tuple is returned. The <kbd>bca</kbd> input is not accepted, as it starts with a <kbd>b</kbd> character instead of <kbd>a</kbd>. The <kbd>abcjk</kbd> input is accepted, as in the first case, but this time, there is a remaining input.</p>
<p>The combination of parsers is <kbd>tuple((char('a'), char('b'), char('c')))</kbd>. This is similar to the preceding program, but by using the <kbd>tuple</kbd> parser combinator, a parser is obtained that requires that all the specified parsers are satisfied, in their order.</p>
<p>In the next section, we'll see how to parse a fixed string of text.</p>
<h3 id="uuid-97fd37b3-3e39-4bf7-a3a0-a0d6845d8cbd">Parsing a fixed string</h3>
<p>In the <kbd>parse_abc_sequence</kbd> function discussed previously, to recognize the <kbd>abc</kbd> sequence, the <kbd>char</kbd> parser had to be specified three times, and the result was a tuple of <kbd>char</kbd> values.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For longer strings (such as the keywords of a language), this is inconvenient, as they are more easily seen as strings than as sequences of characters. The Nom library also contains a parser for fixed strings, named <kbd>tag</kbd>. The preceding program can be rewritten using this built-in parser, shown in the following code block:</p>
<pre>extern crate nom;<br/>use nom::{bytes::complete::tag, IResult};<br/><br/>fn parse_abc_string(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {<br/>    tag("abc")(input)<br/>}<br/><br/>fn main() {<br/>    println!("abc: {:?}", parse_abc_string("abc"));<br/>    println!("bca: {:?}", parse_abc_string("bca"));<br/>    println!("abcjk: {:?}", parse_abc_string("abcjk"));<br/>}</pre>
<p>It will print the following output:</p>
<pre><strong>abc: Ok(("", "abc"))</strong><br/><strong>bca: Err(Error(("bca", Tag)))</strong><br/><strong>abcjk: Ok(("jk", "abc"))</strong></pre>
<p>Instead of the <kbd>tuple((char('a'), char('b'), char('c')))</kbd> expression, there is now a simple call to <kbd>tag("abc")</kbd>, and the parser returns a string slice, instead of a tuple of <kbd>char</kbd> values.</p>
<p>In the next section, we'll see how to transform the value resulting from a parser to another value, possibly of another type.</p>
<h3 id="uuid-b7c239bb-4d67-457e-bd86-365558ee709c">Mapping parsed items to other objects</h3>
<p>So far, we get as a result just what we found in the input. But often, we want to transform the parsed input before returning its result.</p>
<p>Say that we want to parse alternatively three letters (<kbd>a</kbd>, <kbd>b</kbd>, or <kbd>c</kbd>) but we want, as a result of the parsing, the number <kbd>5</kbd> for the letter <kbd>a</kbd>, the number <kbd>16</kbd> for the letter <kbd>b</kbd>, and the number <kbd>8</kbd> for the letter <kbd>c</kbd>.</p>
<p class="mce-root"/>
<p>So, we want a parser that parses a letter, but, instead of returning that letter, it returns a number, if the parsing is successful. We also want to map the character <kbd>a</kbd> to the number <kbd>5</kbd>, the character <kbd>b</kbd> to the number <kbd>16</kbd>, and the character <kbd>c</kbd> to the number <kbd>8</kbd>. The original result type was <kbd>char</kbd>, while the mapped result type is <kbd>u8</kbd>. The following code block shows the program that performs such a transformation:</p>
<pre>extern crate nom;<br/>use nom::{branch::alt, character::complete::char, combinator::map, IResult};<br/><br/>fn parse_abc_as_numbers(input: &amp;str)<br/>    -&gt; IResult&lt;&amp;str, u8&gt; {<br/>    alt((<br/>        map(char('a'), |_| 5),<br/>        map(char('b'), |_| 16),<br/>        map(char('c'), |_| 8),<br/>    ))(input)<br/>}<br/><br/>fn main() {<br/>    println!("a: {:?}", parse_abc_as_numbers("a"));<br/>    println!("x: {:?}", parse_abc_as_numbers("x"));<br/>    println!("bjk: {:?}", parse_abc_as_numbers("bjk"));<br/>}</pre>
<p>When it runs, it should print the following output:</p>
<pre><strong>a: Ok(("", 5))</strong><br/><strong>x: Err(Error(("x", Char)))</strong><br/><strong>bjk: Ok(("jk", 16))</strong></pre>
<p>For the <kbd>a</kbd> input, <kbd>5</kbd> is extracted. For the <kbd>x</kbd> input, a parse error is obtained. For the <kbd>bjk</kbd> input, <kbd>16</kbd> is extracted, and the <kbd>jk</kbd> string remains as input to be parsed.</p>
<p>The implementation, for each one of the three characters, contains something such as <kbd>map(char('a'), |_| 5)</kbd>. The <kbd>map</kbd> function is another parser combinator that takes a parser and a closure. If the parser matches, then it generates a value. The closure is invoked on such a value, and it returns a transformed value. In this case, the argument of the closure was not needed.</p>
<p>An alternative equivalent implementation of the same parser is given as follows:</p>
<pre>fn parse_abc_as_numbers(input: &amp;str) -&gt; IResult&lt;&amp;str, u8&gt; {<br/>    fn transform_letter(ch: char) -&gt; u8 {<br/>        match ch {<br/>            'a' =&gt; 5,<br/>            'b' =&gt; 16,<br/>            'c' =&gt; 8,<br/>            _ =&gt; 0,<br/>        }<br/>    }<br/>    alt((<br/>        map(char('a'), transform_letter),<br/>        map(char('b'), transform_letter),<br/>        map(char('c'), transform_letter),<br/>    ))(input)<br/>}</pre>
<p>It defines the <kbd>transform_letter</kbd> inner function that applies the transformation and passes just that function as the second argument of the <kbd>map</kbd> combinator.</p>
<p>In the next section, we'll see how to manipulate the output of a parser in a more complex way, as we will be omitting or swapping some fields of the resulting tuple.</p>
<h3 id="uuid-19230063-dd4f-4cd3-bce5-aaf07c32b79f">Creating custom parsing results</h3>
<p>So far, the results of parsing have been determined by the parsers and combinators used in it—if a parser uses the <kbd>tuple</kbd> combinator with three items, the result is a tuple of three items. This is seldom what is desired. For example, we want to either omit some items of the resulting tuple or add a fixed item, or to swap the items.</p>
<p>Assume that we want to parse the <kbd>abc</kbd> string, but in the result we want to omit <kbd>b</kbd>, keeping only <kbd>ac</kbd>. For that purpose, we must postprocess the result of the parsing in the following way:</p>
<pre>extern crate nom;<br/>use nom::{character::complete::char, sequence::tuple, IResult};<br/><br/>fn parse_abc_to_ac(input: &amp;str) -&gt; IResult&lt;&amp;str, (char, char)&gt; {<br/>    tuple((char('a'), char('b'), char('c')))(input)<br/>        .map(|(rest, result)| (rest, (result.0, result.2)))<br/>}<br/><br/>fn main() {<br/>    println!("abc: {:?}", parse_abc_to_ac("abc"));<br/>}</pre>
<p>It will print the following output:</p>
<pre><strong>abc: Ok(("", ('a', 'c')))</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Of course, the result of our parser now contains just a pair—<kbd>(char, char)</kbd>. The postprocessing is seen in the second line of the body. It uses a <kbd>map</kbd> function that is not the one seen in the preceding example; it belongs to the <kbd>Result</kbd> type. Such a method receives a closure that gets the <kbd>Ok</kbd> variant of the result and returns a new <kbd>Ok</kbd> variant with the appropriate types. If the type had been made explicit, then that code would have been as follows:</p>
<pre>.map(|(rest, result): (&amp;str, (char, char, char))|<br/>    -&gt; (&amp;str, (char, char)) {<br/>    (rest, (result.0, result.2))<br/>}</pre>
<p>From the preceding code, the call to <kbd>tuple</kbd> returns a result whose <kbd>Ok</kbd> variant has the <kbd>(&amp;str, (char, char, char))</kbd> type. The first element is the remaining input, assigned to the <kbd>rest</kbd> variable, and the second element is the sequence of parsed <kbd>char</kbd> values, assigned to the <kbd>result</kbd> variable.</p>
<p>Then, we must construct a pair with two items—that is, what we want as the <em>remaining input</em>, and the pair of characters that we want as a <em>result</em>. As a remaining input, we specify the same pair provided by <kbd>tuple</kbd>, while as a result, we specify <kbd>(result.0, result.2)</kbd>—that is, the first and third parsed characters, which will be <kbd>'a'</kbd> and <kbd>'c'</kbd>.</p>
<p>Some of the following cases are quite typical:</p>
<ul>
<li>A sequence of two parsers, needing to keep the result of the first parser and discard the result of the second parser.</li>
<li>A sequence of two parsers, needing to discard the result of the first parser and keep the result of the second parser.</li>
<li>A sequence of three parsers, needing to keep the result of the second parser and discard the results of the first and third parsers. This is typical of parenthesized expressions or quoted text.</li>
</ul>
<p>For these previous cases, the mapping technique can be applied too, but Nom contains some specific combinators, detailed as follows:</p>
<ul>
<li><kbd>preceded(a, b)</kbd>: This keeps only the result of <kbd>b</kbd>. </li>
<li><kbd>terminated(a, b)</kbd>: This keeps only the result of <kbd>a</kbd>. </li>
<li><kbd>delimited(a, b, c)</kbd>: This keeps only the result of <kbd>b</kbd>. </li>
</ul>
<p>In the next section, we'll see how to parse a specified number of characters and return the parsed characters.</p>
<p class="mce-root"/>
<h3 id="uuid-334c8768-00a5-4a97-9248-403b393dabdf">Parsing a variable text</h3>
<p>The parsing we have done so far is of very limited usefulness, as we just checked that the input respected a language, without the possibility of accepting arbitrary text or numbers.</p>
<p>Say we want to parse a text that begins with an <kbd>n</kbd> character followed by two other arbitrary characters, and we want to process only the latter two characters. This can be done with the <kbd>take</kbd> built-in parser, shown in the following code snippet:</p>
<pre>extern crate nom;<br/>use nom::{bytes::complete::take, character::complete::char, sequence::tuple, IResult};<br/><br/>fn parse_variable_text(input: &amp;str)<br/>    -&gt; IResult&lt;&amp;str, (char, &amp;str)&gt; {<br/>    tuple((char('n'), take(2usize)))(input)<br/>}<br/><br/>fn main() {<br/>    println!("nghj: {:?}", parse_variable_text("nghj"));<br/>    println!("xghj: {:?}", parse_variable_text("xghj"));<br/>    println!("ng: {:?}", parse_variable_text("ng"));<br/>}</pre>
<p>It will print the following output:</p>
<pre><strong>nghj: Ok(("j", ('n', "gh")))</strong><br/><strong>xghj: Err(Error(("xghj", Char)))</strong><br/><strong>ng: Err(Error(("g", Eof)))</strong></pre>
<p>The first invocation is a successful one. The <kbd>n</kbd> character is skipped by <kbd>char('n')</kbd>, and two other characters are read by <kbd>take(2usize)</kbd>. This parser reads as many characters as specified by its argument (that must be an unsigned number), and it returns this sequence of bytes as a string slice. To read a single character, just call <kbd>take(1usize)</kbd>, which will return a string slice anyway.</p>
<p>The second invocation fails because the starting <kbd>n</kbd> is missing. The third invocation fails because after the starting <kbd>n</kbd>, there are fewer than two characters, and so the <kbd>Eof</kbd> (short for <strong>End-Of-File</strong>) error is generated.</p>
<p>In the next section, we will see how to parse a sequence of one or more patterns by applying a given parser repeatedly.</p>
<p class="mce-root"/>
<h3 id="uuid-dae915a7-83ed-4143-8ac3-d994c53c47b5">Repeating a parser</h3>
<p>It is quite common to need to parse a sequence of repeated expressions, each recognized by a parser. So, that parser must be applied several times, until it fails. Such repetition is done by a couple of combinators—namely, <kbd>many0</kbd> and <kbd>many1</kbd>.</p>
<p>The former will succeed even if no occurrence of the expression is parsed—that is, it is a zero-or-more combinator. The latter will succeed only if at least one occurrence of the expression is parsed—that is, it is a one-or-more combinator. Let's see how to recognize a sequence of one or more <kbd>abc</kbd> strings, as follows:</p>
<pre>extern crate nom;<br/>use nom::{bytes::complete::take, multi::many1, IResult};<br/><br/>fn repeated_text(input: &amp;str) -&gt; IResult&lt;&amp;str, Vec&lt;&amp;str&gt;&gt; {<br/>    many1(take(3usize))(input)<br/>}<br/><br/>fn main() {<br/>    println!(": {:?}", repeated_text(""));<br/>    println!("ab: {:?}", repeated_text("abc"));<br/>    println!("abcabcabc: {:?}", repeated_text("abcabcabc"));<br/>}</pre>
<p>It will print the following output:</p>
<pre><strong>: Err(Error(("", Eof)))</strong><br/><strong>abc: Ok(("", ["abc"]))</strong><br/><strong>abcabcabcx: Ok(("x", ["abc", "abc", "abc"]))</strong></pre>
<p>The first invocation fails because the empty string does not contain any occurrences of <kbd>abc</kbd>. If the <kbd>many0</kbd> combinator had been used, this invocation would have succeeded.</p>
<p>The two other invocations succeed anyway and return a <kbd>Vec</kbd> of the occurrences found.</p>
<p>In this section, we have presented the most popular parsing techniques: compiler-compilers and parser combinators. They are useful both to build interpreters and compilers. Then, we introduced the Nom parser combinator library that will be used in the rest of this chapter, and also in part of the next chapter. </p>
<p>Now, we have seen enough of Nom to begin to see the first project of this chapter.</p>
<p class="mce-root"/>
<h1 id="uuid-2720e2fd-edce-44b4-8dab-c36b60170b45">The calc_parser project</h1>
<p>This project is a parser of the <kbd>Calc</kbd> language. It is a program that can examine a string and detect if it respects the syntax of the <kbd>Calc</kbd> language, using a context-free parser, and, in such cases, extracts the logical structure of such a string, according to the grammar of the language. Such a structure is often named a <strong>syntax tree </strong>as it has the shape of a tree, and it represents the syntax of the parsed text.</p>
<p>A syntax tree is an internal data structure, and so usually it is not to be seen by a user, nor to be exported. For debugging purposes, though, this program will pretty-print this data structure to the console.</p>
<p>The program built by this project expects a <kbd>Calc</kbd> language file as a command-line argument. In the <kbd>data</kbd> folder of the project, there are two example programs—namely, <kbd>sum.calc</kbd> and <kbd>bad_sum.calc</kbd>.</p>
<p>The first one is <kbd>sum.calc</kbd>, given as follows:</p>
<pre>@a<br/>@b<br/>&gt;a<br/>&gt;b<br/>&lt;a+b</pre>
<p>It declares the two variables <kbd>a</kbd> and <kbd>b</kbd>, then it asks the user to enter values for them, and it prints the sum of their value.</p>
<p>The other program, <kbd>bad_sum.calc</kbd>, is identical to the former, except for the second line—that is, <kbd>@d</kbd>—representing a typo because later on, the undeclared <kbd>b</kbd> variable is used.</p>
<p>To run the project on the first example <kbd>Calc</kbd> program, go into the <kbd>calc_parser</kbd> folder, and type the following:</p>
<pre><strong>cargo run data/sum.calc</strong></pre>
<p>Such a command should print the following text on the console:</p>
<pre>Parsed program: [<br/>    Declaration(<br/>        "a",<br/>    ),<br/>    Declaration(<br/>        "b",<br/>    ),<br/>    InputOperation(<br/>        "a",<br/>    ),<br/>    InputOperation(<br/>        "b",<br/>    ),<br/>    OutputOperation(<br/>        (<br/>            (<br/>                Identifier(<br/>                    "a",<br/>                ),<br/>                [],<br/>            ),<br/>            [<br/>                (<br/>                    Add,<br/>                    (<br/>                        Identifier(<br/>                            "b",<br/>                        ),<br/>                        [],<br/>                    ),<br/>                ),<br/>            ],<br/>        ),<br/>    ),<br/>]</pre>
<p>From the preceding code, first, there is a declaration of the <kbd>"a"</kbd> identifier, then of the <kbd>"b"</kbd> identifier, then an input operation on a variable named <kbd>"a"</kbd>, then one on a variable named <kbd>"b"</kbd>, and then there is an output operation with a lot of parentheses. </p>
<p>The first open parenthesis under <kbd>OutputOperation</kbd> represents the beginning of the expression item that, according to the grammar presented previously, must appear in any output operation statement. Such an expression contains two items—a term and a list of operator-term pairs.</p>
<p>The first term contains two items—a factor and a list of operator-factor pairs. The factor is the <kbd>"a"</kbd> identifier, and the list of operator-factor pairs is empty. Then, let's pass this to the list of operator-term pairs. It contains just one item, in which the operator is <kbd>Add</kbd>, and the term is again a factor followed by a list of operator-factor pairs. The factor is the <kbd>"b"</kbd> identifier, and the list is empty.</p>
<p class="mce-root"/>
<p>If the <kbd>cargo run data/bad_sum.calc</kbd> command runs, no error is detected, as this program only performs a syntax analysis without checking the semantic context. The output is the same, except for the sixth line—that is, <kbd>"d"</kbd> instead of <kbd>"b"</kbd>.</p>
<p>Now, let's examine the source code of the Rust program. The only external crate is <strong>Nom</strong>, a library used just for the lexical and syntax analysis passes (and therefore used by all the projects of this chapter, because all of them need parsing).</p>
<p>There are two source files—<kbd>main.rs</kbd> and <kbd>parser.rs</kbd>. Let's look at the <kbd>main.rs</kbd> source file first.</p>
<h2 id="uuid-239a01bd-70c3-4b08-94ed-00e91f95134a">Understanding the main.rs source file</h2>
<p>The <kbd>main.rs</kbd> source file contains just the <kbd>main</kbd> function and the <kbd>process_file</kbd> function. The <kbd>main</kbd> function just checks if the command line contains an argument and passes it to the <kbd>process_file</kbd> function, together with the path of the executable Rust program.</p>
<p>The <kbd>process_file</kbd> function checks that the command-line argument ends with <kbd>.calc</kbd>—that is, the only expected file type, then it reads the contents of that file into the <kbd>source_code</kbd> string and parses that string by calling <kbd>parser::parse_program(&amp;source_code)</kbd>, contained in the <kbd>parser.rs</kbd> source file.</p>
<p>Such a file is, of course, a parser for the whole program, and so it returns a <kbd>Result</kbd> value. The <kbd>Ok</kbd> variant of such a return value is a pair composed of the remaining code and the syntax tree. The syntax tree is then pretty-printed by the statement given as follows:</p>
<pre>println!("Parsed program: {:#?}", parsed_program);</pre>
<p>When the small <kbd>sum.calc</kbd> file, having only five lines and 17 characters, is processed, this single <kbd>println!</kbd> statement emits the long output shown before, having 35 lines and 604 bytes. Of course, the output is longer for longer programs.</p>
<p>Next, let's look at the <kbd>parser.rs</kbd> source file. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<h2 id="uuid-1567b840-9e75-4920-b75b-7706458e36c2">Learning about the parser.rs source file</h2>
<p>The <kbd>parser.rs</kbd> source file contains a parser function for each syntax element of the grammar of the language. These functions are detailed as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 23.8454%"><strong>Function</strong></td>
<td style="width: 75.3802%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_program</kbd></td>
<td style="width: 75.3802%">This parses a whole <kbd>Calc</kbd> program.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_declaration</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> declaration statement, such as <kbd>@total</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_input_statement</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> input statement, such as <kbd>&gt;addend</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_output_statement</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> output statement, such as  <kbd>&lt;total</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_assignment</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> assignment statement, such as <kbd>total := addend * 2</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_expr</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> expression, such as  <kbd>addend * 2 + val / (incr + 1)</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_term</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> term, such as <kbd>val / (incr + 1)</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_factor</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> factor, such as <kbd>incr</kbd>, or <kbd>4.56e12</kbd>, or <kbd>(incr + 1)</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_subexpr</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> parenthesized expression, such as <kbd>(incr + 1)</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>parse_identifier</kbd></td>
<td style="width: 75.3802%">This parses a <kbd>Calc</kbd> identifier, such as <kbd>addend</kbd>.</td>
</tr>
<tr>
<td style="width: 23.8454%"><kbd>skip_spaces</kbd></td>
<td style="width: 75.3802%">This parses a sequence of zero or more white spaces.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>With respect to the grammar previously declared, some explanation is due—the <kbd>parse_subexpr</kbd> parser has the task to parse the  <kbd>( &lt;expr&gt; )</kbd> sequence, discarding the parentheses and parsing the <kbd>&lt;expr&gt;</kbd> initial expression using <kbd>parse_expr</kbd>. The <kbd>skip_spaces</kbd> function is a parser whose task is to parse zero or more white spaces (spaces, tabs, newline characters), with the purpose of ignoring them.</p>
<p>All the other preceding functions, in the case of success, return a data structure representing the parsed code.</p>
<p>There is no parser for literal numbers, as the built-in <kbd>double</kbd> parser will be used to parse floating-point numbers.</p>
<h3 id="uuid-500eeccd-7786-4ec1-a959-ac2bfdc89b92">Understanding the types needed by the parser</h3>
<p>In this file, in addition to the parsers, several types are defined to represent the structure of the parsed program. The most important type is defined as follows:</p>
<pre>type ParsedProgram&lt;'a&gt; = Vec&lt;ParsedStatement&lt;'a&gt;&gt;;</pre>
<p>The preceding code snippet just says that a parsed program is a vector of parsed statements.</p>
<p>Notice the lifetime specification. To keep the best performance, memory allocation is minimized. Of course, vectors are allocated, but the parsed string is not allocated; they are string slices referencing the input string. Therefore, the syntax tree is dependent on the input string, and its lifetime must be shorter than that of the input string.</p>
<p>The preceding declaration uses the <kbd>ParsedStatement</kbd> type, which is declared in the following way:</p>
<pre>enum ParsedStatement&lt;'a&gt; {<br/>    Declaration(&amp;'a str),<br/>    InputOperation(&amp;'a str),<br/>    OutputOperation(ParsedExpr&lt;'a&gt;),<br/>    Assignment(&amp;'a str, ParsedExpr&lt;'a&gt;),<br/>}</pre>
<p>The preceding code snippet says that a parsed statement can be one of the following:</p>
<ul>
<li>A declaration encapsulating the name of the variable that is being declared</li>
<li>An input statement encapsulating the name of the variable that is going to receive an input value</li>
<li>An output operation encapsulating a parsed expression whose value is going to be printed</li>
<li>An assignment encapsulating the name of the variable that is going to receive a calculated value and a parsed expression, whose value is going to be assigned to the variable</li>
</ul>
<p>This declaration uses the <kbd>ParsedExpr</kbd> type, which is declared as follows:</p>
<pre>type ParsedExpr&lt;'a&gt; = (ParsedTerm&lt;'a&gt;, Vec&lt;(ExprOperator, ParsedTerm&lt;'a&gt;)&gt;);</pre>
<p>From the preceding code snippet, a parsed expression is a pair composed of a parsed term and zero or more pairs, with each pair composed of an expression operator and a parsed term.</p>
<p>An expression operator is defined as <kbd>enum ExprOperator { Add, Subtract }</kbd>, while a parsed term is defined as follows:</p>
<pre>type ParsedTerm&lt;'a&gt; = (ParsedFactor&lt;'a&gt;, Vec&lt;(TermOperator, ParsedFactor&lt;'a&gt;)&gt;);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We can see that a parsed term is a pair composed of a parsed factor and zero or more pairs, with each pair composed of a term operator and a parsed factor. A term operator is defined as <kbd>enum TermOperator { Multiply, Divide }</kbd>, while a parsed factor is defined as follows:</p>
<pre>enum ParsedFactor&lt;'a&gt; {<br/>    Literal(f64),<br/>    Identifier(&amp;'a str),<br/>    SubExpression(Box&lt;ParsedExpr&lt;'a&gt;&gt;),<br/>}</pre>
<p>This declaration says that a parsed factor can be a literal encapsulating a number, or an identifier encapsulating the name of that variable, or a subexpression encapsulating a parsed expression.</p>
<p>Notice the use of <kbd>Box</kbd>. This is required because any parsed expression contains a parsed term that contains a parsed factor of an <kbd>enum</kbd> capable of containing a parsed expression. And so, we have an endless recursion of containment. If we use a <kbd>Box</kbd>, we allocate memory out of the main structure.</p>
<p>So, we have seen all the definitions of the types that will be used by the parser code. Now, let's see the code, in a top-down fashion.</p>
<h3 id="uuid-cb7de5c1-3c0e-428d-ac67-67196acfc8dd">Looking at the parser code</h3>
<p>We can now see the code used to parse a whole program. The following code snippet shows the entry point of the parser:</p>
<pre>pub fn parse_program(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedProgram&gt; {<br/>    many0(preceded(<br/>        skip_spaces,<br/>        alt((<br/>            parse_declaration,<br/>            parse_input_statement,<br/>            parse_output_statement,<br/>            parse_assignment,<br/>        )),<br/>    ))(input)<br/>}</pre>
<p>Notice that its result type is <kbd>ParsedProgram</kbd>, which is a vector of parsed statements.</p>
<p class="mce-root"/>
<p>The body uses the <kbd>many0</kbd> parser combinator to accept zero or more statements (an empty program is considered valid). Actually, to parse a statement, the <kbd>preceded</kbd> combinator is used, to combine two parsers and discard the output of the first one. Its first argument is the <kbd>skip_spaces</kbd> parser, and so it simply skips possible spaces between statements. The second argument is the <kbd>alt</kbd> combinator, to accept alternatively one of the four possible statements.</p>
<p>The <kbd>many0</kbd> combinator generates a vector of objects, with such objects generated by the argument of the combinator. Such arguments generate parsed statements, and so we have the needed vector of parsed statements.</p>
<p>So, to summarize, this function accepts zero or more statements, possibly separated by white spaces. The accepted statements can be declarations, input statements, output statements, or assignments. The value returned by the function in the case of success is a vector whose elements are representations of the parsed statements.</p>
<p>The parser of <kbd>Calc</kbd> declarations is given as follows:</p>
<pre>fn parse_declaration(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedStatement&gt; {<br/>    tuple((char('@'), skip_spaces, parse_identifier))(input)<br/>        .map(|(input, output)| (input, ParsedStatement::Declaration(output.2)))<br/>}</pre>
<p>From the preceding code snippet, a declaration must be a sequence of the <kbd>@</kbd> character, optional spaces, and an identifier; so, the <kbd>tuple</kbd> combinator is used to chain such parsers. However, we are not interested in that initial character nor in those white spaces. We want just the text of the identifier, encapsulated in <kbd>ParsedStatement</kbd>.</p>
<p>Therefore, after applying the <kbd>tuple</kbd>, the result is mapped to a <kbd>Declaration</kbd> object whose argument is the third item generated by the <kbd>tuple</kbd>.</p>
<p>The following code snippet shows the parser of a <kbd>Calc</kbd> input statement:</p>
<pre>fn parse_input_statement(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedStatement&gt; {<br/>    tuple((char('&gt;'), skip_spaces, parse_identifier))(input)<br/>        .map(|(input, output)| (input, ParsedStatement::InputOperation(output.2)))<br/>}</pre>
<p>The parser of a <kbd>Calc</kbd> input statement is quite similar to the preceding parser. It just looks for the <kbd>&gt;</kbd> character and returns an <kbd>InputOperation</kbd> variant that encapsulates the string returned by <kbd>parse_identifier</kbd>.</p>
<p class="mce-root"/>
<p>The following code snippet shows the parser of a <kbd>Calc</kbd> output statement:</p>
<pre>fn parse_output_statement(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedStatement&gt; {<br/>    tuple((char('&lt;'), skip_spaces, parse_expr))(input)<br/>        .map(|(input, output)| (input, ParsedStatement::OutputOperation(output.2)))<br/>}</pre>
<p>Also, the parser from the preceding code is similar to the two preceding parsers. It just looks for the <kbd>&lt;</kbd> character, parses an expression instead of an identifier, and returns an <kbd>OutputOperation</kbd> that encapsulates the parsed expression returned by <kbd>parse_expr</kbd>.</p>
<p>The last kind of <kbd>Calc</kbd> statement is an assignment. Its parser is shown in the following code snippet:</p>
<pre>fn parse_assignment(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedStatement&gt; {<br/>    tuple((<br/>        parse_identifier,<br/>        skip_spaces,<br/>        tag(":="),<br/>        skip_spaces,<br/>        parse_expr,<br/>    ))(input)<br/>    .map(|(input, output)| (input, ParsedStatement::Assignment(output.0, output.4)))<br/>}</pre>
<p>This is somewhat different from the preceding statement's parsers. It chains five parsers—for an identifier, some possible spaces, the <kbd>:=</kbd> string, some possible spaces, and an expression. The result is an <kbd>Assignment</kbd> variant that encapsulates the first and the last parsed items of the tuple—that is, the identifier string and the parsed expression.</p>
<p>We have encountered the use of the expression parser, which is defined as follows:</p>
<pre>fn parse_expr(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedExpr&gt; {<br/>    tuple((<br/>        parse_term,<br/>        many0(tuple((<br/>            preceded(<br/>                skip_spaces,<br/>                alt((<br/>                    map(char('+'), |_| ExprOperator::Add),<br/>                    map(char('-'), |_| ExprOperator::Subtract),<br/>                )),<br/>            ),<br/>            parse_term,<br/>        ))),<br/>    ))(input)<br/>}</pre>
<p>From the preceding code, to parse an expression, a term must first be parsed (<kbd>parse_term</kbd>), and then zero or more (<kbd>many0</kbd>) pairs (<kbd>tuple</kbd>) of an operator and a term (<kbd>parse_term</kbd>). The operator can be preceded by white spaces (<kbd>skip_spaces</kbd>) that must be discarded (<kbd>preceded</kbd>), and it can be alternatively (<kbd>alt</kbd>) a plus character (<kbd>char('+'</kbd>) or a minus character (<kbd>char('-'</kbd>). But we want to replace (<kbd>map</kbd>) such characters with the <kbd>ExprOperator</kbd> values. The resulting object already has the expected type, and so no other <kbd>map</kbd> transformation is needed.</p>
<p>The parser of a term is similar to the parser of an expression. Here it is:</p>
<pre>fn parse_term(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedTerm&gt; {<br/>    tuple((<br/>        parse_factor,<br/>        many0(tuple((<br/>            preceded(<br/>                skip_spaces,<br/>                alt((<br/>                    map(char('*'), |_| TermOperator::Multiply),<br/>                    map(char('/'), |_| TermOperator::Divide),<br/>                )),<br/>            ),<br/>            parse_factor,<br/>        ))),<br/>    ))(input)<br/>}</pre>
<p>The only differences between <kbd>parse_expr</kbd> and <kbd>parse_term</kbd> are the following ones:</p>
<ul>
<li>Where <kbd>parse_expr</kbd> calls <kbd>parse_term</kbd>, <kbd>parse_term</kbd> calls <kbd>parse_factor</kbd>.</li>
<li>Where <kbd>parse_expr</kbd> maps the <kbd>'+'</kbd> character to the <kbd>ExprOperator::Add</kbd> value, and the <kbd>'-'</kbd> character to the <kbd>ExprOperator::Subtract</kbd> value, <kbd>parse_term</kbd> maps the <kbd>'*'</kbd> character to the <kbd>TermOperator::Multiply</kbd> value, and the <kbd>'/'</kbd> character to the <kbd>TermOperator::Divide</kbd> value.</li>
<li>Where <kbd>parse_expr</kbd> has a <kbd>ParsedExpr</kbd> type in the return value type, <kbd>parse_term</kbd> has a <kbd>ParsedTerm</kbd> type. </li>
</ul>
<p>The parser of a factor again follows the relative grammar rule, and the definition of its return type, <kbd>ParsedFactor</kbd>, as illustrated in the following code snippet:</p>
<pre>fn parse_factor(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedFactor&gt; {<br/>    preceded(<br/>        skip_spaces,<br/>        alt((<br/>            map(parse_identifier, ParsedFactor::Identifier),<br/>            map(double, ParsedFactor::Literal),<br/>            map(parse_subexpr, |expr|<br/>                ParsedFactor::SubExpression(Box::new(expr))<br/>            ),<br/>        )),<br/>    )(input)<br/>}</pre>
<p>This parser discards possible initial spaces and then parses alternatively an identifier, a number, or a subexpression. The parser of the number is <kbd>double</kbd>, a Nom built-in function that parses numbers according to the syntax of Rust <kbd>f64</kbd> literals.</p>
<p>All the returned types of these parses are wrong, so, the <kbd>map</kbd> combinator is used to generate their return value. For identifiers, it is enough to cite the <kbd>Identifier</kbd> variant that will be constructed automatically using as an argument the value returned by the <kbd>parse_identifier</kbd> function. An equivalent and more verbose code would be <kbd>map(parse_identifier, |id| ParsedFactor::Identifier(id))</kbd>.</p>
<p>Similarly, literals are converted from the <kbd>f64</kbd> type to the <kbd>ParsedFactor::Literal(f64)</kbd> type, and subexpressions are boxed and encapsulated in a <kbd>SubExpression</kbd> variant.</p>
<p class="mce-root">The parse of the subexpression must just match and discard spaces and parentheses, shown in the following code snippet:</p>
<pre>fn parse_subexpr(input: &amp;str) -&gt; IResult&lt;&amp;str, ParsedExpr&gt; {<br/>    delimited(<br/>        preceded(skip_spaces, char('(')),<br/>        parse_expr,<br/>        preceded(skip_spaces, char(')')),<br/>    )(input)</pre>
<p>The inner <kbd>parse_expr</kbd> parser is the only one that passes its output to the result. To parse an identifier, a built-in parser is used, shown as follows:</p>
<pre>fn parse_identifier(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {<br/>    alpha1(input)<br/>}</pre>
<p>The <kbd>alpha1</kbd> parser returns a string of one or more letters. Digits and other characters are not allowed. Usually, this would not be named <em>parser</em>, but lexical analyzer, or lexer, or scanner, or tokenizer, but Nom makes no distinction.</p>
<p class="mce-root"/>
<p>And lastly, the small parser (or lexer) to process spaces is shown as follows:</p>
<pre>fn skip_spaces(input: &amp;str) -&gt; IResult&lt;&amp;str, &amp;str&gt; {<br/>    let chars = " \t\r\n";<br/>    take_while(move |ch| chars.contains(ch))(input)<br/>}</pre>
<p>It uses a combinator we have not yet seen—<kbd>take_while</kbd>. It receives as argument a closure returning a Boolean (that is, predicate). Such a closure is invoked on any input character. If the closure returns <kbd>true</kbd>, the parser goes on or otherwise stops. So, it returns the maximum sequence of input characters for which the predicate value is <em>true</em>.</p>
<p>In our case, the predicate checks whether the character is contained in a slice of four characters.</p>
<p>So, we have seen all our parsers for the <kbd>Calc</kbd> language. Of course, real-world parsers are much more complex, but the concepts are the same.</p>
<p>In this section, we have seen how the Nom library can be used to parse a program written in the <kbd>Calc</kbd> language, using a CFG. This is preliminary to applying a <strong>context-sensitive grammar</strong> (<strong>CSG</strong>), and then an interpreter or a compiler.</p>
<p>Notice that this program parser considers any sequence of characters to be a valid identifier, without checking whether a variable is defined before being used, or whether a variable is not defined several times. For such checks, further processing must be performed. This will be seen in the next project.</p>
<h1 id="uuid-1aab83e2-5a0c-40d0-bf98-d90e89d6abcf">The calc_analyzer project</h1>
<p>The preceding project followed a CFG to construct a parser. This is very nice, but there is a big problem: the <kbd>Calc</kbd> language is not context-free. In fact, there are two problems, as follows:</p>
<ul>
<li>Any use of a variable in input statements, output statements, and assignments must be preceded by a declaration of that variable.</li>
<li>Any variable must not be declared more than once.</li>
</ul>
<p>Such requirements cannot be expressed in a context-free language.</p>
<p class="mce-root"/>
<p>In addition, <kbd>Calc</kbd> has just one data type—that is, floating-point numbers—but consider if it also had a string type. You can add subtract two numbers, but you cannot subtract two strings. If a variable named <kbd>a</kbd> is declared of type <kbd>number</kbd> and a variable named <kbd>b</kbd> is declared of type <kbd>string</kbd>, you cannot assign <kbd>a</kbd> to <kbd>b</kbd>, or vice versa.</p>
<p>In general, the operations allowed on a variable depend on the type used to declare that variable. And also, this constraint cannot be expressed in a CFG.</p>
<p>Instead of defining a formal <strong>context-dependent grammar</strong> (<strong>CDG</strong>) that would be hard to specify and to parse, the usual path is to define such rules, called <em>semantic</em> rules, in an informal way, and then to postprocess the syntax tree to check the validity of such rules.</p>
<p>Here, we will call the module that performs such semantic checks <kbd>analyzer</kbd> (using a semantic checker that verifies some constraints on variables, such as the fact that they must be defined before being used, and the fact that variables cannot be defined more than once), and <kbd>calc_analyzer</kbd> is the project that adds the module to the parser.</p>
<p>In the next section, we will see the architecture of the <kbd>analyzer</kbd> module.</p>
<h2 id="uuid-443adce9-ef7d-4ba8-97b4-86643ecfac4d">Checking the variables of the parsed program</h2>
<p>The analyzer starts where the parser finished—with a syntax tree containing strings of identifiers, values of literals, and operators. So, it no longer needs the source code. To accomplish its task, it visits such a tree and, every time it encounters a variable declaration, it must ensure that it has not been declared already, while every time it encounters a variable use, it must ensure it has already been declared.</p>
<p>To perform such tasks without wandering around the syntax tree, another data structure is needed. Such a data structure is a collection of the variables already declared so far, while the syntax tree is visited. When a variable declaration is encountered, the analyzer looks in such a collection for a preceding declaration of the same variable; if it is found, it is a double-declaration error; otherwise, an entry is added to the collection.</p>
<p>Also, when a variable use is encountered, the analyzer looks in such a collection for a preceding declaration of the same variable, though this time, if it is not found, it is a missing-declaration error. For our simple language, such a collection contains only variables, but in more complex languages it will contain any kind of identifiers—constants, functions, namespaces, and so on. An alternative name for the identifier is a <strong>symbol</strong>; so, usually, this collection is named <strong>symbol table</strong>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To perform variable checking of a <kbd>Calc</kbd> program, our symbol table just needs to store the names of the variables, although we want our analyzer to perform some other tasks, which will be useful if we want to build an interpreter. An interpreter, when it is running a program, must store the <em>values</em> of the identifiers somewhere, not only their name, and as we already have a collection of variables storing the name of each variable, we can reserve space in the entry of a variable for the value of each variable. This will be useful when we build an interpreter for <kbd>Calc</kbd>.</p>
<p>But that is more than what we can do in the analyzer, in preparation of an interpreter. The interpreter must scan a kind of syntax tree to execute the statements, and when it encounters a variable it must look for its value. The syntax tree generated by the parser contains the identifiers of the variables, not their values, so the interpreter, every time it finds a variable, should search the symbol table for that string.</p>
<p>But we want a fast interpreter, and string lookup is not so fast as using a pointer or an index into an array. So, to prepare for fast interpretation, while the analyzer visits the syntax tree, it replaces every identifier with an index of its position in the symbol table. Well, a string cannot be replaced by a number in Rust, so one possible technique would be to reserve an index field in the syntax tree, and fill that index when the variable is found in the symbol table.</p>
<p>Here, another technique has been chosen. The analyzer, while visiting the syntax tree, constructs a parallel analyzed tree, very similar in structure, but having indexes into the symbol table instead of identifiers. Such a tree, together with the symbol table that reserves space for the values of the variables, will be optimal for interpreting the program.</p>
<p>So, first of all, let's see what is done by this project. Open the <kbd>calc_analyzer</kbd> folder and type the following: <kbd>cargo run data/sum.calc</kbd>.</p>
<p>The following output should appear on the console:</p>
<pre><strong>Symbol table: SymbolTable {</strong><br/><strong>    entries: [</strong><br/><strong>        (</strong><br/><strong>            "a",</strong><br/><strong>            0.0,</strong><br/><strong>        ),</strong><br/><strong>        (</strong><br/><strong>            "b",</strong><br/><strong>            0.0,</strong><br/><strong>        ),</strong><br/><strong>    ],</strong><br/><strong>}</strong><br/><strong>Analyzed program: [</strong><br/><strong>    Declaration(</strong><br/><strong>        0,</strong><br/><strong>    ),</strong><br/><strong>    Declaration(</strong><br/><strong>        1,</strong><br/><strong>    ),</strong><br/><strong>    InputOperation(</strong><br/><strong>        0,</strong><br/><strong>    ),</strong><br/><strong>    InputOperation(</strong><br/><strong>        1,</strong><br/><strong>    ),</strong><br/><strong>    OutputOperation(</strong><br/><strong>        (</strong><br/><strong>            (</strong><br/><strong>                Identifier(</strong><br/><strong>                    0,</strong><br/><strong>                ),</strong><br/><strong>                [],</strong><br/><strong>            ),</strong><br/><strong>            [</strong><br/><strong>                (</strong><br/><strong>                    Add,</strong><br/><strong>                    (</strong><br/><strong>                        Identifier(</strong><br/><strong>                            1,</strong><br/><strong>                        ),</strong><br/><strong>                        [],</strong><br/><strong>                    ),</strong><br/><strong>                ),</strong><br/><strong>            ],</strong><br/><strong>        ),</strong><br/><strong>    ),</strong><br/><strong>]</strong></pre>
<p>The preceding code program, as with the one before that, does not have an output for the user. It parses the source code into a syntax tree, and then analyzes that syntax tree, constructing a symbol table and an analyzed program. The output is just the pretty-print of such data structures.</p>
<p>The first structure dumped is the symbol table. It has two entries—the <kbd>a</kbd> variable, with <kbd>0.0</kbd> as its initial value, and the <kbd>b</kbd> variable, with <kbd>0.0</kbd> as its initial value.</p>
<p>Then, there is the analyzed program that is very similar to the parsed program printed by the previous project. The only differences are that all the occurrences of <kbd>"a"</kbd> are replaced by <kbd>0</kbd>, and all the occurrences of <kbd>"b"</kbd> are replaced by <kbd>1</kbd>. These numbers are the positions of such variables inside the symbol table.</p>
<p class="mce-root"/>
<p>The project extends the preceding project. The <kbd>parser.rs</kbd> source file is identical, and two other files are added—<kbd>symbol_table.rs</kbd> and <kbd>analyzer.rs</kbd>. But let's start with the <kbd>main.rs</kbd> file first.</p>
<h2 id="uuid-0b57ad67-ba29-45bd-a168-1b82ad2daf0e">Understanding the main.rs file</h2>
<p>This file performs all that is done by the preceding project, except the final pretty-print, which is replaced by the following lines:</p>
<pre>    let analyzed_program;<br/>    let mut variables = symbol_table::SymbolTable::new();<br/>    match analyzer::analyze_program(&amp;mut variables, &amp;parsed_program) {<br/>        Ok(analyzed_tree) =&gt; {<br/>            analyzed_program = analyzed_tree;<br/>        }<br/>        Err(err) =&gt; {<br/>            eprintln!("Invalid code in '{}': {}", source_path, err);<br/>            return;<br/>        }<br/>    }<br/><br/>    println!("Symbol table: {:#?}", variables);<br/>    println!("Analyzed program: {:#?}", analyzed_program);</pre>
<p>From the preceding code snippet, the two data structures constructed by the analyzer are first declared—<kbd>analyzed_program</kbd> is the syntax tree with the indexes to the variables, and <kbd>variables</kbd> is the symbol table.</p>
<p>All the analysis is performed by the <kbd>analyze_program</kbd> function. If it succeeds, it will return the analyzed program, and, in the end, the two structures are printed.</p>
<p>Now, let's examine the symbol table (<kbd>symbol_table.rs</kbd>) implementation.</p>
<h2 id="uuid-9d12e690-f7c4-472c-a676-2a1c1b1f6315">Looking at the symbol_table.rs file</h2>
<p>In the <kbd>symbol_table.rs</kbd> file, there is an implementation of the <kbd>SymbolTable</kbd> type, which is a collection of the identifiers found in the source code. Each entry of a symbol table describes a variable. Such an entry must contain at least the name of the variable. In a typed language, it must also contain a representation of the data type of that variable, though <kbd>Calc</kbd> doesn't need that, as it has only one data type.</p>
<p class="mce-root"/>
<p>If the language supports scoping in blocks, functions, classes, or larger structures (compilation units, modules, namespaces, or packages), there must be several symbol tables or a symbol table that specifies such scoping, though <kbd>Calc</kbd> doesn't need that, as it has only one scope.</p>
<p>A symbol table is useful primarily for checking identifiers and for translating code into another language, although it can also be used for interpreting code. When an interpreter is evaluating an expression, it needs to get the current value of the variables used in such an expression. A symbol table can be used to store the current value of any variable and provide such values to the interpreter. So, if you want to support an interpreter, your symbol table should also reserve space for the current values of the defined variables.</p>
<p>In the next project, we will create an interpreter, and so, to support it, here, we add to any entry of our symbol table a field where the current value of the variable is stored. The type of each entry of our symbol table will be <kbd>(String, f64)</kbd>, where the first field is the name of the variable, and the second one is the current value of the variable. This value field will be accessed when interpreting a program.</p>
<p>How can our code access the entries of a symbol table? When analyzing the program, we must search for a string, and so a hash table would offer top performance. However, when interpreting the code, we can replace identifiers with indexes, and so using indexes into a vector would offer top performance. Here, for simplicity, a vector has been chosen, which anyway is good enough if there aren't many variables. So, our definition is given as follows:</p>
<pre>struct SymbolTable {<br/>    entries: Vec&lt;(String, f64)&gt;,<br/>}</pre>
<p>For the <kbd>SymbolTable</kbd> type, three methods are implemented, as shown in the following code snippet:</p>
<pre>fn new() -&gt; SymbolTable<br/>fn insert_symbol(&amp;mut self, identifier: &amp;str) -&gt; Result&lt;usize, String&gt;<br/>fn find_symbol(&amp;self, identifier: &amp;str) -&gt; Result&lt;usize, String&gt;</pre>
<p>The <kbd>new</kbd> method simply creates an empty symbol table.</p>
<p>The <kbd>insert_symbol</kbd> method tries to insert the specified identifier into a symbol table. If there is no identifier with such a name, an entry is added for that name, with zero as the default value, and the <kbd>Ok</kbd> result is the index of the new entry. Otherwise, the <kbd>Error: Identifier '{}' declared several times.</kbd> message is returned in the <kbd>Err</kbd> result.</p>
<p class="mce-root"/>
<p>The <kbd>find_symbol</kbd> method tries to find the specified identifier in the symbol table. If it is found, the <kbd>Ok</kbd> result is the index of the found entry. Otherwise, the <kbd>Error: Identifier '{}' used before having been declared.</kbd> error message is returned in the <kbd>Err</kbd> result.</p>
<p>Now, let's see the analyzer source file.</p>
<h2 id="uuid-23d58f70-b151-42e4-8874-f553bb197891">Glancing at the analyzer.rs file</h2>
<p>As discussed before, the analysis phase reads the hierarchical structure created by the parsing phase and constructs another hierarchical structure, having the <kbd>AnalyzedProgram</kbd> type. So, this module must declare such a <kbd>type</kbd> and all the types it needs, paralleling the <kbd>ParsedProgram</kbd> type, as follows:</p>
<pre class="mce-root">type AnalyzedProgram = Vec&lt;AnalyzedStatement&gt;;</pre>
<p>Any analyzed program is a sequence of analyzed statements, as illustrated in the following code snippet:</p>
<pre>enum AnalyzedStatement {<br/>    Declaration(usize),<br/>    InputOperation(usize),<br/>    OutputOperation(AnalyzedExpr),<br/>    Assignment(usize, AnalyzedExpr),<br/>}<br/><br/></pre>
<p>Any analyzed statement is any one of the following:</p>
<ul>
<li>A declaration referring a variable by index</li>
<li>An input operation referring a variable by index</li>
<li>An output operation containing an analyzed expression</li>
<li>An assignment referring a variable by index and containing an analyzed expression</li>
</ul>
<p>Any analyzed expression is a pair of an analyzed term and a sequence of zero or more pairs of an expression operator and an analyzed term, as illustrated in the following code snippet:</p>
<pre>type AnalyzedExpr = (AnalyzedTerm, Vec&lt;(ExprOperator, AnalyzedTerm)&gt;);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Any analyzed term is a pair of an analyzed factor and a sequence of zero or more pairs of a term operator and an analyzed factor, as illustrated in the following code snippet:</p>
<pre>type AnalyzedTerm = (AnalyzedFactor, Vec&lt;(TermOperator, AnalyzedFactor)&gt;);</pre>
<p>Any analyzed factor is a literal containing a 64-bit floating-point number, or an identifier referring a variable by index, or a subexpression containing a reference to a heap-allocated analyzed expression, as illustrated in the following code snippet:</p>
<pre>pub enum AnalyzedFactor {<br/>Literal(f64),<br/>Identifier(usize),<br/>SubExpression(Box&lt;AnalyzedExpr&gt;),<br/>}</pre>
<p>The entry point of the analyzer is shown in the following code snippet:</p>
<pre>fn analyze_program(variables: &amp;mut SymbolTable, parsed_program: &amp;ParsedProgram)<br/>    -&gt; Result&lt;AnalyzedProgram, String&gt; {<br/>    let mut analyzed_program = AnalyzedProgram::new();<br/>    for statement in parsed_program {<br/>        analyzed_program.push(analyze_statement(variables, statement)?);<br/>    }<br/>    Ok(analyzed_program)<br/>}</pre>
<p>The <kbd>analyze_program</kbd> function, as with all the functions of this module, gets a mutable reference to the symbol table, as they all must, directly or indirectly read and write symbols. In addition, it gets a reference to a parsed program. If the function is successful, it updates the symbol table and it returns an analyzed program; otherwise, it may leave partially updated the symbol table and return an error message.</p>
<p>The body simply creates an empty analyzed program and processes all the parsed statements, by calling <kbd>analyze_statement</kbd>. Any parsed statement is analyzed, and the resulting analyzed statement is added to the analyzed program. For any failing analysis of a statement, the generated error is returned immediately as an error of this function.</p>
<p>So, we need to know how to analyze statements, which is shown as follows:</p>
<pre>fn analyze_statement(<br/>    variables: &amp;mut SymbolTable,<br/>    parsed_statement: &amp;ParsedStatement,<br/>) -&gt; Result&lt;AnalyzedStatement, String&gt; {<br/>    match parsed_statement {<br/>        ParsedStatement::Assignment(identifier, expr) =&gt; {<br/>            let handle = variables.find_symbol(identifier)?;<br/>            let analyzed_expr = analyze_expr(variables, expr)?;<br/>            Ok(AnalyzedStatement::Assignment(handle, analyzed_expr))<br/>        }<br/>        ParsedStatement::Declaration(identifier) =&gt; {<br/>            let handle = variables.insert_symbol(identifier)?;<br/>            Ok(AnalyzedStatement::Declaration(handle))<br/>        }<br/>        ParsedStatement::InputOperation(identifier) =&gt; {<br/>            let handle = variables.find_symbol(identifier)?;<br/>            Ok(AnalyzedStatement::InputOperation(handle))<br/>        }<br/>        ParsedStatement::OutputOperation(expr) =&gt; {<br/>            let analyzed_expr = analyze_expr(variables, expr)?;<br/>            Ok(AnalyzedStatement::OutputOperation(analyzed_expr))<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>analyze_statement</kbd> function matches the received parsed statements against the four kinds of statements, extracting the member of the respective variants.</p>
<p>The identifier contained in declarations should never have been defined, and so it should be absent from the symbol table. Therefore, when processing this kind of statement, this identifier is inserted in the symbol table using the <kbd>let handle = variables.insert_symbol(identifier)?</kbd> Rust statement. If the insertion fails, the error is propagated out of this function. If the insertion succeeds, the position of the symbol is stored in a local variable.</p>
<p>The identifier contained in assignments and in the input operations should have already been defined, and so it should be contained in the symbol table. Therefore, when processing this kind of statement, the identifiers are looked up in the symbol table using the <kbd>let handle = variables.find_symbol(identifier)?</kbd> Rust statement.</p>
<p>The expressions contained in assignments and in output operations are analyzed by the <kbd>let analyzed_expr = analyze_expr(variables, expr)?</kbd> Rust statement. If the analysis fails, the error is propagated out of this function. If the analysis succeeds, the resulting analyzed expression is stored in a local variable. </p>
<p>For any of the four <kbd>Calc</kbd> statement kinds, if no errors have been encountered, the function returns a success result containing the respective analyzed statement variant.</p>
<p>So, we need to know how to analyze expressions, shown as follows:</p>
<pre>fn analyze_expr(<br/>    variables: &amp;mut SymbolTable,<br/>    parsed_expr: &amp;ParsedExpr,<br/>) -&gt; Result&lt;AnalyzedExpr, String&gt; {<br/>    let first_term = analyze_term(variables, &amp;parsed_expr.0)?;<br/>    let mut other_terms = Vec::&lt;(ExprOperator, AnalyzedTerm)&gt;::new();<br/>    for term in &amp;parsed_expr.1 {<br/>        other_terms.push((term.0, analyze_term(variables, &amp;term.1)?));<br/>    }<br/>    Ok((first_term, other_terms))<br/>}</pre>
<p>The received parsed expression is a pair—<kbd>&amp;parsed_expr.0</kbd> is a parsed term and <kbd>&amp;parsed_expr.1</kbd> is a vector of pairs of an expression operator and an analyzed term. We want to construct an analyzed expression that has the same structure.</p>
<p>So, first, the first term is analyzed. Then, an empty list of pairs of an expression operator and an analyzed term is created; this is the analyzed vector. Then, for each item of the parsed vector, an item is constructed and added to the analyzed vector. Lastly, the pair of the first analyzed term and the vector of the other analyzed terms are returned.</p>
<p>So, we need to know how to analyze terms, through the following code:</p>
<pre>fn analyze_term(<br/>    variables: &amp;mut SymbolTable,<br/>    parsed_term: &amp;ParsedTerm,<br/>) -&gt; Result&lt;AnalyzedTerm, String&gt; {<br/>    let first_factor = analyze_factor(variables, &amp;parsed_term.0)?;<br/>    let mut other_factors = Vec::&lt;(TermOperator, AnalyzedFactor)&gt;::new();<br/>    for factor in &amp;parsed_term.1 {<br/>        other_factors.push((factor.0, analyze_factor(variables, <br/>         &amp;factor.1)?));<br/>    }<br/>    Ok((first_factor, other_factors))<br/>}</pre>
<p>The preceding routine is quite similar to the one before that. The first parsed factor is analyzed to get the first analyzed factor, and the other parsed factors are analyzed to get the other analyzed factors.</p>
<p>So, we need to know how to analyze factors. This is shown as follows:</p>
<pre>fn analyze_factor(<br/>    variables: &amp;mut SymbolTable,<br/>    parsed_factor: &amp;ParsedFactor,<br/>) -&gt; Result&lt;AnalyzedFactor, String&gt; {<br/>    match parsed_factor {<br/>        ParsedFactor::Literal(value) =&gt; <br/>         Ok(AnalyzedFactor::Literal(*value)),<br/>        ParsedFactor::Identifier(name) =&gt; {<br/>            Ok(AnalyzedFactor::Identifier(variables.find_symbol(name)?))<br/>        }<br/>        ParsedFactor::SubExpression(expr) =&gt; <br/>         Ok(AnalyzedFactor::SubExpression(<br/>            Box::&lt;AnalyzedExpr&gt;::new(analyze_expr(variables, expr)?),<br/>        )),<br/>    }<br/>}</pre>
<p>The logic of the <kbd>analyze_factor</kbd> function is this:</p>
<ul>
<li>If the parsed factor to analyze is a literal, an analyzed literal is returned, containing the same value.</li>
<li>If it is an identifier, an analyzed identifier is returned, containing the index into the symbol table where the parsed identifier is found. If it is not found, an error is returned.</li>
<li>If the parsed factor to analyze is a subexpression, a subexpression is returned, containing a boxed analyzed expression, obtained by analyzing the parsed expression, if successful. If it fails, an error is returned.</li>
</ul>
<p>So, we have completed the examination of the analyzer module.</p>
<p>In this section, we have seen how the result of the parser created in the previous section can be analyzed, applying a CSG, which is needed to build an interpreter or a compiler. The next project will show us how to use and execute an analyzed program.</p>
<h1 id="uuid-6e7e3de6-0a85-4991-94a1-8b438b5228c0">The calc_interpreter project </h1>
<p>At last, we have reached the project in which we can actually run our <kbd>Calc</kbd> programs.</p>
<p>To run it, enter the <kbd>calc_interpreter</kbd> folder, and type <kbd>cargo run</kbd>. After compilation, the following text will appear on the console:</p>
<pre><strong>* Calc interactive interpreter *</strong><br/><strong>&gt;</strong> </pre>
<p>The first line is an introduction message, and the second one is a prompt. Now, we type the following as an example:</p>
<pre>@a &gt;a @b b := a + 2 &lt;b</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>After you press <em>Ent</em><em>er</em>, this <kbd>Calc</kbd> program is executed. The <kbd>a</kbd> variable is declared, and when the input statement is executed, a question mark will appear on the console. Type <kbd>5</kbd> and press <em>Enter</em>.</p>
<p>The program goes on by declaring the <kbd>b</kbd> variable, assigning to it the value of the <kbd>a + 2</kbd> expression,  and then printing <kbd>7</kbd> as the value of <kbd>b</kbd>. Then, the program finishes, and the prompt reappears.</p>
<p>So, on the screen, there will be the following:</p>
<pre>* Calc interactive interpreter *<br/>&gt; @a &gt;a @b b := a + 2 &lt;b<br/>? 5<br/>7<br/>&gt; </pre>
<p>The interpreter, in addition, has some specific commands to be able to run <kbd>Calc</kbd> programs. If instead of a command, you type <kbd>v</kbd> (for <em>variables</em>) and then <em>Enter</em>, you will see the following:</p>
<pre><strong>&gt; v</strong><br/><strong>Variables:</strong><br/><strong>  a: 5</strong><br/><strong>  b: 7</strong><br/><strong>&gt;</strong> </pre>
<p>This command has dumped the contents of the symbol table, showing all the variables declared so far, with their current value. Now, you can type other <kbd>Calc</kbd> commands, using such variables with their current values.</p>
<p>Another interpreter command is <kbd>c</kbd> (for clear variables), which empties the symbol table. The last one is <kbd>q</kbd> (for quit), which terminates the interpreter.</p>
<p>And how are <kbd>Calc</kbd> commands executed? If you have an analyzed program tree, and the associated symbol table containing space for the value of the variables, it is quite easy. It is enough to apply semantics (that is, a behavior) to any analyzed element, and the program will run by itself.</p>
<p>Also, this project extends the previous project. The <kbd>parser.rs</kbd> and <kbd>analyzer.rs</kbd> source files are identical; some lines are added to the <kbd>symbol_table.rs</kbd> file, and one other file is added—<kbd>executor.rs</kbd>. But let's start with the <kbd>main.rs</kbd> file.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<h2 id="uuid-5fd2ef36-e79a-475b-be57-98f718d893ed" class="mce-root">Learning about the main.rs file</h2>
<p class="mce-root">This file contains two functions in addition to the <kbd>main</kbd> functions—<kbd>run_interpreter</kbd> and <kbd>input_command</kbd>.</p>
<p class="mce-root">The <kbd>main</kbd> function just calls <kbd>run_interpreter</kbd>, as that is the purpose of an interpreter. This function has the following structure:</p>
<pre>fn run_interpreter() {<br/>    eprintln!("* Calc interactive interpreter *");<br/>    let mut variables = symbol_table::SymbolTable::new();<br/>    loop {<br/>        let command = input_command();<br/>        if command.len() == 0 {<br/>            break;<br/>        }<br/><em>        &lt;&lt;process interpreter commands&gt;&gt;</em><br/><em>        &lt;&lt;parse, analyze, and execute the commands&gt;&gt;</em><br/>    }<br/>}</pre>
<p>After printing an introduction message and creating a symbol table, the function enters an endless loop.</p>
<p>The first statement of the loop is a call to the <kbd>input_command</kbd> function, which reads a command from the console (or from a file or a pipe, if the standard input is redirected). Then, if EOF has been reached, the loop is exited, and so is the whole program.</p>
<p>Otherwise, the interpreter-specific commands are handled, and if in the input text there is no such command, it is handled like a <kbd>Calc</kbd> program by parsing it and then analyzing the parsed program, and then executing the analyzed program.</p>
<p>The following code block shows how interpreter commands are implemented:</p>
<pre>match command.trim() {<br/>    "q" =&gt; break,<br/>    "c" =&gt; {<br/>        variables = symbol_table::SymbolTable::new();<br/>        eprintln!("Cleared variables.");<br/>    }<br/>    "v" =&gt; {<br/>        eprintln!("Variables:");<br/>        for v in variables.iter() {<br/>            eprintln!(" {}: {}", v.0, v.1);<br/>        }<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>A <kbd>q</kbd> (quit) command simply breaks out from the loop. A <kbd>c</kbd> (clear) command replaces the symbol table with a new one. A <kbd>v</kbd> (variables) command iterates the symbol table entries, and prints the name and the current value of each of them.</p>
<p>If the input text is not one of such one-letter commands, it is treated by the following code:</p>
<pre>    trimmed_command =&gt; match parser::parse_program(&amp;trimmed_command) {<br/>        Ok((rest, parsed_program)) =&gt; {<br/>            if rest.len() &gt; 0 {<br/>                eprintln!("Unparsed input: `{}`.", rest)<br/>            } else {<br/>                match analyzer::analyze_program(&amp;mut variables, <br/>                 &amp;parsed_program) {<br/>                    Ok(analyzed_program) =&gt; {<br/>                        executor::execute_program(&amp;mut variables, <br/>                          &amp;analyzed_program)<br/>                    }<br/>                    Err(err) =&gt; eprintln!("Error: {}", err),<br/>                }<br/>            }<br/>        }<br/>        Err(err) =&gt; eprintln!("Error: {:?}", err),<br/>    },</pre>
<p>The <kbd>parser::parse_program</kbd> function, if successful, creates a parsed program object. In the case of an error or in the case that some input remains to be parsed, an error message is printed and the command is discarded.</p>
<p>Otherwise, <kbd>analyzer::analyze_program</kbd> uses such a parsed program to create, if successful, an analyzed program object. In the case of error, an error message is printed and the command is discarded.</p>
<p>Lastly, the analyzed program is executed by the call to <kbd>executor::execute_program</kbd>. Now, let's see what has changed in the <kbd>symbol_table.rs</kbd> file.</p>
<h2 id="uuid-4928c7f3-8042-434c-ad87-4c8f3f655faa">Glancing at the symbol_table.rs file</h2>
<p>Three functions having the following signatures have been added to the implementation of the <kbd>SymbolTable</kbd> type:</p>
<pre>pub fn get_value(&amp;self, handle: usize) -&gt; f64<br/>pub fn set_value(&amp;mut self, handle: usize, value: f64)<br/>pub fn iter(&amp;self) -&gt; std::slice::Iter&lt;(String, f64)&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>get_value</kbd> function gets the value of a variable, given its index. The <kbd>set_value</kbd> function sets the value of a variable, given its index and the value to assign. The <kbd>iter</kbd> function returns a read-only iterator on the variables stored in the symbol table. For each variable, a pair of the name and the value is returned.</p>
<p>And next, we see the module that implements the core of the interpreter.</p>
<h2 id="uuid-4660c35f-76a1-4a88-b921-9f1902123aab">Understanding the executor.rs file</h2>
<p>This module does not declare types as it uses only the ones declared in the other modules. The entry point is the function capable of executing whole programs, shown as follows:</p>
<pre>pub fn execute_program(variables: &amp;mut SymbolTable, program: &amp;AnalyzedProgram) {<br/>    for statement in program {<br/>        execute_statement(variables, statement);<br/>    }<br/>}</pre>
<p>It receives a mutable reference to a symbol table and a reference to an analyzed program, and simply calls the <kbd>execute_statement</kbd> function on any statement of that program.</p>
<p>The following code block shows the last function (this is more complex):</p>
<pre>fn execute_statement(variables: &amp;mut SymbolTable, statement: &amp;AnalyzedStatement) {<br/>    match statement {<br/>        AnalyzedStatement::Assignment(handle, expr) =&gt; {<br/>            variables.set_value(*handle, evaluate_expr(variables, expr));<br/>        }<br/>        AnalyzedStatement::Declaration(handle) =&gt; {}<br/>        AnalyzedStatement::InputOperation(handle) =&gt; {<br/>            let mut text = String::new();<br/>            eprint!("? ");<br/>            std::io::stdin()<br/>                .read_line(&amp;mut text)<br/>                .expect("Cannot read line.");<br/>            let value = text.trim().parse::&lt;f64&gt;().unwrap_or(0.);<br/>            variables.set_value(*handle, value);<br/>        }<br/>        AnalyzedStatement::OutputOperation(expr) =&gt; {<br/>            println!("{}", evaluate_expr(variables, expr));<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>According to the kind of statement being used, it performs different actions. For assignments, it calls the <kbd>evaluate_expr</kbd> function to get the value of the associated expression and uses <kbd>set_value</kbd> to assign that value to the associated variable.</p>
<p>For declarations, nothing needs to be done, because the insertion of the variable into the symbol table and its initialization has already been done by the analyzer.</p>
<p>For input operations, a question mark is printed as a prompt, and a line is read and parsed to an <kbd>f64</kbd> number. If the conversion fails, zero is used. The value is then stored into the symbol table as a new value of the variable.</p>
<p>For output operations, the expression is evaluated and the resulting value is printed. The following code shows how to evaluate <kbd>Calc</kbd> expressions:</p>
<pre>fn evaluate_expr(variables: &amp;SymbolTable, expr: &amp;AnalyzedExpr) -&gt; f64 {<br/>    let mut result = evaluate_term(variables, &amp;expr.0);<br/>    for term in &amp;expr.1 {<br/>        match term.0 {<br/>            ExprOperator::Add =&gt; result += evaluate_term(variables, <br/>             &amp;term.1),<br/>            ExprOperator::Subtract =&gt; result -= evaluate_term(variables, <br/>             &amp;term.1),<br/>        }<br/>    }<br/>    result<br/>}</pre>
<p>First, the first term is evaluated by calling the <kbd>evaluate_term</kbd> function, and its value is stored as a provisional result.</p>
<p>Then, for every other term, the term is evaluated and the obtained value is added or subtracted to the provisional result, according to the kind of expression operator being used.</p>
<p>The following code block shows how to evaluate <kbd>Calc</kbd> terms:</p>
<pre>fn evaluate_term(variables: &amp;SymbolTable, term: &amp;AnalyzedTerm) -&gt; f64 {<br/>    let mut result = evaluate_factor(variables, &amp;term.0);<br/>    for factor in &amp;term.1 {<br/>        match factor.0 {<br/>            TermOperator::Multiply =&gt; result *= evaluate_factor(<br/>            variables, &amp;factor.1),<br/>            TermOperator::Divide =&gt; result /= evaluate_factor(<br/>            variables, &amp;factor.1),<br/>        }<br/>    }<br/>    result<br/>}</pre>
<p>The preceding code block shows a function that is similar to the one before it. It uses the <kbd>evaluate_factor</kbd> function to evaluate all the factors of the current term, as illustrated in the following code snippet:</p>
<pre>fn evaluate_factor(variables: &amp;SymbolTable, factor: &amp;AnalyzedFactor) -&gt; f64 {<br/>    match factor {<br/>        AnalyzedFactor::Literal(value) =&gt; *value,<br/>        AnalyzedFactor::Identifier(handle) =&gt; variables.get_value(*handle),<br/>        AnalyzedFactor::SubExpression(expr) =&gt; evaluate_expr(variables, expr),<br/>    }<br/>}</pre>
<p>To evaluate a factor, the <em>kind of factor</em> is taken into account. The value of <kbd>literal</kbd> is just the contained value. The value of <kbd>identifier</kbd> is obtained for the symbol table, by calling <kbd>get_value</kbd>.</p>
<p>The value of <kbd>SubExpression</kbd> is obtained by evaluating the expression contained in it. So, we have seen all that is needed to execute a <kbd>Calc</kbd> program interactively.</p>
<p>In this section, we have seen how the result of the context-sensitive analysis of a <kbd>Calc</kbd> program can be used to interpret that program. Such an interpretation can be interactive, through a <strong>read-eval-print loop</strong> (<strong>REPL</strong>) or by processing a file written in the <kbd>Calc</kbd> language.</p>
<p>In the next project, we will see how to translate a <kbd>Calc</kbd> program into a Rust program.</p>
<h1 id="uuid-6295eb99-81e5-4197-9905-ba4a957c3eed">The calc_compiler project</h1>
<p>Having an analyzed program (and its matching symbol table), it is easy also to create a program that translates it into another language. To avoid introducing a new language, the Rust language has been used here as a target language, but translating to other high-level languages would be no more difficult.</p>
<p>To run it, go into the <kbd>calc_compiler</kbd> folder and type <kbd>cargo run data/sum.calc</kbd>. After compiling the project, the program will print the following:</p>
<pre><strong>Compiled data/sum.calc to data/sum.rs</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>If you go into the <kbd>data</kbd> subfolder, you will find the new <kbd>sum.rs</kbd> file, containing the following code:</p>
<pre>use std::io::Write;<br/><br/>#[allow(dead_code)]<br/>fn input() -&gt; f64 {<br/>    let mut text = String::new();<br/>    eprint!("? ");<br/>    std::io::stderr().flush().unwrap();<br/>    std::io::stdin()<br/>        .read_line(&amp;mut text)<br/>        .expect("Cannot read line.");<br/>    text.trim().parse::&lt;f64&gt;().unwrap_or(0.)<br/>}<br/><br/>fn main() {<br/>    let mut _a = 0.0;<br/>    let mut _b = 0.0;<br/>    _a = input();<br/>    _b = input();<br/>    println!("{}", _a + _b);<br/>}</pre>
<p>If you like, you can compile it using the <kbd>rustc sum.rs</kbd> command, and then you can run the executable generated.</p>
<p>This file is always the same for any <kbd>Calc</kbd> program compiled, up to the line containing <kbd>fn main() {</kbd>. The <kbd>input</kbd> routine is the <kbd>Calc</kbd> runtime library.</p>
<p>The remaining part of the Rust-generated code corresponds to the <kbd>Calc</kbd> statements. Notice that all variables are mutable and initialized to <kbd>0.0</kbd>, and so their type is <kbd>f64</kbd>. The name of the variables begins with an underscore to prevent conflicts with Rust keywords.</p>
<p>Actually, this project also contains the interpreter seen in the preceding project. If you run the project with no command-line argument, an interactive interpreter starts.</p>
<p>Let's see the source code next. Also, this project extends the preceding project. The <kbd>parser.rs</kbd>, <kbd>analyzer.rs</kbd>, and <kbd>executor.rs</kbd> source files are identical; some lines are added to the <kbd>symbol_table.rs</kbd> file, and one other file is added—<kbd>compiler.rs</kbd>.</p>
<p>To the <kbd>symbol_table.rs</kbd> file, only one small function has been added. Its signature is shown as follows:</p>
<pre>pub fn get_name(&amp;self, handle: usize) -&gt; String</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>It allows the name of an identifier to be obtained, given its index.</p>
<p>But let's start with the <kbd>main.rs</kbd> file.</p>
<h2 id="uuid-4a61ea68-b188-45a5-bf0e-37151ff15ab3" class="mce-root">Glancing at the main.rs file</h2>
<p class="mce-root">The <kbd>main</kbd> function begins by examining the command-line arguments. If there are no arguments, the <kbd>run_interpreter</kbd> function is called, identical to that used in the <kbd>calc_interpreter</kbd> project.</p>
<p class="mce-root">Instead, if there is one argument, the <kbd>process_file</kbd> function is called on it. This is similar to that used in the <kbd>calc_analyzer</kbd> project. There are only two differences. One is the insertion of the statement, shown in the following code snippet:</p>
<pre>let target_path = source_path[0..source_path.len() - CALC_SUFFIX.len()].to_string() + ".rs";</pre>
<p>This generates the path of the resulting Rust file. The other is the replacement of the two ending statements, which print the result of the analysis, with the following code:</p>
<pre>match std::fs::write(<br/>    &amp;target_path,<br/>    compiler::translate_to_rust_program(&amp;variables, &amp;analyzed_program),<br/>) {<br/>    Ok(_) =&gt; eprintln!("Compiled {} to {}.", source_path, target_path),<br/>    Err(err) =&gt; eprintln!("Failed to write to file {}: ({})", target_path, err),<br/>}</pre>
<p>This performs the translation into Rust code, obtaining a multiline string, and writes that string into the target file.</p>
<p>So, we need to examine the <kbd>compiler</kbd> module, defined in the <kbd>compiler.rs</kbd> source file.</p>
<h2 id="uuid-3da849e0-984d-443a-b616-72a9f6e395c1">Understanding the compiler.rs file</h2>
<p>This module does not define types, as it uses those defined in the other modules. As with the parser, the analyzer, and the interpreter, it has a function for every language construct, and it performs the translation by visiting the analyzed program tree.</p>
<p class="mce-root"/>
<p>The entry point begins with the following code:</p>
<pre>pub fn translate_to_rust_program(<br/>    variables: &amp;SymbolTable,<br/>    analyzed_program: &amp;AnalyzedProgram,<br/>) -&gt; String {<br/>    let mut rust_program = String::new();<br/>    rust_program += "use std::io::Write;\n";<br/>    ...</pre>
<p>This function, as with all the others in this module, gets immutable references to the symbol table and to the analyzed program. It returns a <kbd>String</kbd> containing Rust code. An empty string is first created, and then the required lines are appended to it.</p>
<p>The final part of this function is shown in the following code block:</p>
<pre>    ...<br/>    for statement in analyzed_program {<br/>        rust_program += " ";<br/>        rust_program += &amp;translate_to_rust_statement(&amp;variables, <br/>         statement);<br/>        rust_program += ";\n";<br/>    }<br/>    rust_program += "}\n";<br/>    rust_program<br/>}</pre>
<p>For any <kbd>Calc</kbd> statement, the <kbd>translate_to_rust_statement</kbd> function is called, and the Rust code returned by it is appended to the string.</p>
<p>The body of the function that translates a <kbd>Calc</kbd> statement into Rust code is shown as follows:</p>
<pre>match analyzed_statement {<br/>    AnalyzedStatement::Assignment(handle, expr) =&gt; format!(<br/>        "_{} = {}",<br/>        variables.get_name(*handle),<br/>        translate_to_rust_expr(&amp;variables, expr)<br/>    ),<br/>    AnalyzedStatement::Declaration(handle) =&gt; {<br/>        format!("let mut _{} = 0.0", variables.get_name(*handle))<br/>    }<br/>    AnalyzedStatement::InputOperation(handle) =&gt; {<br/>        format!("_{} = input()", variables.get_name(*handle))<br/>    }<br/>    AnalyzedStatement::OutputOperation(expr) =&gt; format!(<br/>        "println!(\"{}\", {})",<br/>        "{}",<br/>        translate_to_rust_expr(&amp;variables, expr)<br/>    ),<br/>}</pre>
<p>To translate an assignment, the name of the variable is obtained from the symbol table by calling the <kbd>get_name</kbd> function, and the code corresponding to the expression is obtained by calling the <kbd>translate_to_rust_expr</kbd> function. The same is done for the other statements.</p>
<p>To translate an expression, the following function is used:</p>
<pre>fn translate_to_rust_expr(variables: &amp;SymbolTable, analyzed_expr: &amp;AnalyzedExpr) -&gt; String {<br/>    let mut result = translate_to_rust_term(variables, &amp;analyzed_expr.0);<br/>    for term in &amp;analyzed_expr.1 {<br/>        match term.0 {<br/>            ExprOperator::Add =&gt; {<br/>                result += " + ";<br/>                result += &amp;translate_to_rust_term(variables, &amp;term.1);<br/>            }<br/>            ExprOperator::Subtract =&gt; {<br/>                result += " - ";<br/>                result += &amp;translate_to_rust_term(variables, &amp;term.1);<br/>            }<br/>        }<br/>    }<br/>    result<br/>}</pre>
<p>The terms are translated by calling the <kbd>translate_to_rust_term</kbd> function. The additions and subtractions are translated using the <kbd>" + "</kbd> and <kbd>" - "</kbd> Rust string literals.</p>
<p>The translation of a term is quite similar to that of an expression, but using the term operators and calls to the <kbd>translate_to_rust_factor</kbd> function instead.</p>
<p>The body of this function is defined as follows:</p>
<pre>match analyzed_factor {<br/>    AnalyzedFactor::Literal(value) =&gt; value.to_string() + "f64",<br/>    AnalyzedFactor::Identifier(handle) =&gt; "_".to_string()<br/>    + &amp;variables.get_name(*handle),<br/>    AnalyzedFactor::SubExpression(expr) =&gt; {<br/>        "(".to_string() + &amp;translate_to_rust_expr(variables, expr) + ")"<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>For translating a literal, it is converted to a string and <kbd>"f64"</kbd> is appended to force its type. For translating an identifier, its name is taken from the symbol table. For translating a subexpression, the inner expression is translated, and the result is enclosed in parentheses.</p>
<p>In this section, we have seen how to build a program in Rust that reads a <kbd>Calc</kbd> program and writes an equivalent Rust program. Such a resulting program can then be compiled using the <kbd>rustc</kbd> command.</p>
<h1 id="uuid-50b02088-7ad2-4459-b27e-289ba8c2f28b" class="mce-root">Summary</h1>
<p>In this chapter, we have seen some amount of theory of programming languages and the algorithms used to process them.</p>
<p>In particular, we have seen that the syntax of programming languages can be expressed using a formal grammar. There is a useful classification of formal grammars—regular languages, context-free languages, and context-dependent languages.</p>
<p>Programming languages belong to the third category, but usually, they are first parsed as a regular language by a lexer. The result is parsed as a context-free language by a parser and is then analyzed to keep into account the context-dependent features.</p>
<p class="mce-root">We have seen the most popular techniques to process texts written in a formal language, such as a programming language or a markup language—the compiler-compiler and the parser combinator. In particular, we saw how to use the Nom crate, which is a parser combinator library.</p>
<p>We saw many built-in parsers and parser combinators of Nom, and how to use them to create our own parsers, writing many Rust programs that used Nom to parse simple patterns. We defined the grammar of an extremely simple programming language, which we named <kbd>Calc</kbd>, and we built some tiny programs using it. We built a context-free parser for <kbd>Calc</kbd> that dumped on the console the data structure resulting from such a parsing (<kbd>calc_parser</kbd>).</p>
<p>We built a context-dependent analyzer for <kbd>Calc</kbd> that dumped on the console the data structure resulting from such an analysis (<kbd>calc_analyzer</kbd>). We built an interpreter for <kbd>Calc</kbd>, using the parser and analyzer described in the preceding projects (<kbd>calc_interpreter</kbd>). We built a compiler for <kbd>Calc</kbd> that could be used to translate a <kbd>Calc</kbd> program to an equivalent Rust program (<kbd>calc_compiler</kbd>).</p>
<p class="mce-root">In the next chapter, we will be seeing another use of Nom and of parsing techniques, for processing binary data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<h1 id="uuid-fbc20846-1641-43b9-b349-40a1078d0ac7" class="mce-root">Questions</h1>
<ol>
<li class="mce-root">What are regular languages, context-free languages, and context-dependent languages?</li>
<li class="mce-root">What is the Backus-Naur form to specify the grammar of a language?</li>
<li class="mce-root">What is a compiler-compiler?</li>
<li>What is a parser combinator?</li>
<li class="mce-root">Why did Nom have to use only macros before the 2018 edition of Rust?</li>
<li>What do the <kbd>tuple</kbd>, <kbd>alt</kbd>, and <kbd>map</kbd> functions of the Nom library do?</li>
<li>What are the possible phases of an interpreter of a programming language, without passing through an intermediate language?</li>
<li>What are the possible phases of a compiler?</li>
<li>What is the purpose of a symbol table, when analyzing the use of variables?</li>
<li>What is the purpose of a symbol table, when interpreting a program?</li>
</ol>
<h1 id="uuid-c5055368-9d80-4336-8c75-d73d4d2d2990" class="mce-root">Further reading</h1>
<p class="mce-root">The Nom project can be downloaded from <a href="https://github.com/Geal/nom">https://github.com/Geal/nom</a>. This repository also contains some examples.</p>
<p>There are many textbooks about formal languages and about the software that manipulates them. In particular, you may search Wikipedia for the following terms: compiler-compiler, parser combinator, Backus-Naur form, syntax-directed translation.</p>


            

            
        
    </body></html>