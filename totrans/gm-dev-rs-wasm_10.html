<html><head></head><body>
		<div id="_idContainer103">
			<h1 id="_idParaDest-122"><em class="italic"><a id="_idTextAnchor185"/>Chapter 8</em>: Adding a UI</h1>
			<p>It may appear that we've developed everything we need for a video game, and to some extent, we have, except for that annoyance where we need to hit refresh every time little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) hits a rock. A real game has buttons for a "new game" or "high scores", and in this chapter, we'll be adding that UI. To do so may seem trivial, but event-driven UIs that you might be familiar with from web development are an odd fit with our game loop. To add a simple button, we'll need to make significant changes to our application and even write a little HTML.</p>
			<p>In this chapter, you'll do the following:</p>
			<ul>
				<li>Design a new game button</li>
				<li>Show the button on game over</li>
				<li>Start a new game</li>
			</ul>
			<p>At the end of the chapter, you'll have the framework in place for a more full-featured UI and the skills to make it work.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor186"/>Technical requirements</h1>
			<p>You'll need a few more assets, this time from the <strong class="source-inline">ui</strong> directory in the <strong class="source-inline">assets</strong> download at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. The font is Kenny Future Narrow from <a href="https://www.kenney.nl">https://www.kenney.nl</a>. The button is from <a href="https://www.gameart2d.com/">https://www.gameart2d.com/</a>. Both are CC0-licensed. As before, the final code for this chapter is available on the corresponding branch at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3DrEeNO">https://bit.ly/3DrEeNO</a></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor187"/>Design a new game button</h1>
			<p>When RHB <a id="_idIndexMarker693"/>crashes into a rock, he falls over and… well, let's say he takes a nap. Unfortunately, at that point, the player has to refresh the page to start a new game. In most games, we'd see a series of buttons for a new game and high scores. For now, we'll just put in a new game button that will restart from the beginning. This might seem like a simple task, but in fact, we'll have quite a bit to do.</p>
			<p>First, we need to decide how we want to implement the button. We really have two choices. We can create a button in the engine, which would be a sprite that is rendered to the canvas, the same as everything else, or we can use an HTML button and position it over the canvas. The first option will look right and won't require any traditional web programming, but it <a id="_idIndexMarker694"/>will also require us to detect mouse clicks and handle a button-click animation. In other words, we'd have to implement a button. That's more than we want to implement to get our game working, so we're going to use a traditional HTML button and make it <em class="italic">look</em> like it's a game element.</p>
			<p>So, we're going to write some HTML and CSS, which we can use to make the button look like it's a part of the game engine. Then, we'll add the button to the screen with Rust and handle the click event. That will be the tough part.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor188"/>Preparing a UI </h2>
			<p>Conceptually, our UI will work like a HUD in a FPS or where a button is superimposed over the front <a id="_idIndexMarker695"/>of a game itself. Imagine that there is a perfectly clear pane of glass on top of the game, and the button is a sticker that's stuck to it. This means, in the context of a web page, that we need a div that is the same size and in the same place as the canvas.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This isn't a book on HTML or CSS, so I'm not going to spend much time covering it, other than the canvas we've been using throughout. If web development isn't your forte, don't worry – a quick scan of <a href="https://learnxinyminutes.com/docs/html/">https://learnxinyminutes.com/docs/html/</a> will cover more than enough. We'll also be using a little bit of CSS in this section, and you can get a similar cheat sheet for that syntax at <a href="https://learnxinyminutes.com/docs/css/">https://learnxinyminutes.com/docs/css/</a>.</p>
			<p>We can start rather quickly by updating <strong class="source-inline">index.html</strong> to have the required div, as follows:</p>
			<p class="source-code">&lt;body&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;div id="ui" style="position: absolute"&gt;&lt;/div&gt;</strong></p>
			<p class="source-code">  &lt;canvas id="canvas" tabindex="0" height="600" width="600"&gt;</p>
			<p class="source-code">    Your browser does not support the Canvas.</p>
			<p class="source-code">  &lt;/canvas&gt;</p>
			<p class="source-code">  &lt;script src="index.js"&gt;&lt;/script&gt;</p>
			<p class="source-code">&lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Note that the <strong class="source-inline">ui</strong> div is <strong class="source-inline">position: absolute</strong> so that it doesn't "push" the <strong class="source-inline">canvas</strong> element below it. You <a id="_idIndexMarker696"/>can see how this will work by putting a standard HTML button in the <strong class="source-inline">div</strong> element, as follows:</p>
			<p class="source-code">&lt;div id="ui" style="position: absolute"&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;button&gt;New Game&lt;/button&gt;</strong></p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>This will produce a screen that looks like the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer087">
					<img alt="Figure 8.1 – A New Game button!" src="image/Figure_8.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A New Game button!</p>
			<p>It won't respond very well if you completely shrink the screen horizontally, but the game won't work in that situation, so it should be fine. Now that we have a button, we'll need to make it look like a game element, and for that, we'll need styling. Go ahead and create a file named <strong class="source-inline">styles.css</strong> in the <strong class="source-inline">static</strong> directory, and add a link to it in <strong class="source-inline">index.html</strong>, as follows:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">  &lt;meta charset="UTF-8"&gt;</p>
			<p class="source-code">    &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;link rel="stylesheet" href="styles.css" type="text/css" </strong></p>
			<p class="source-code"><strong class="bold">      media="screen"&gt;</strong></p>
			<p class="source-code">&lt;/head&gt;</p>
			<p>Of course, a link <a id="_idIndexMarker697"/>to an empty file doesn't do much for us. To prove the link is working, go ahead and change the <strong class="source-inline">index.html</strong> file slightly, removing the inline style on the <strong class="source-inline">ui</strong> div so that it looks like <strong class="source-inline">&lt;div id="ui"&gt;</strong>. This will cause the button to push the canvas element down, and your game will likely be slightly off:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer088">
					<img alt="Figure 8.2 – New Game on top" src="image/Figure_8.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – New Game on top</p>
			<p>Now, in the CSS file, you'll want to add a style for that div. It's not really important that this style isn't an inline one, except that this handily checks that our CSS file is being loaded. In the CSS file, insert the following:</p>
			<p class="source-code">#ui {</p>
			<p class="source-code">    position: absolute;</p>
			<p class="source-code">}</p>
			<p>This is a CSS selector for any elements with the <strong class="source-inline">ui</strong> ID and sets their position to <strong class="source-inline">absolute</strong>. If your CSS file is being loaded, then the new game button should be over the top of the canvas again. Later, we'll programmatically add that button in our game code, but for now, we just want it to show up and look right. We'll want to give it a font that looks like <a id="_idIndexMarker698"/>a video game, and a background too. Let's start with the font. In your assets, you'll see there is a directory called <strong class="source-inline">ui</strong>, which contains a file named <strong class="source-inline">kenney_future_narrow-webfont.woff2</strong>. <strong class="bold">WOFF</strong> stands for <strong class="bold">Web Open Font Format</strong> and is <a id="_idIndexMarker699"/>a font format that will work in every modern browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you're unsure whether a feature will work with a browser, and sometimes when you are sure, check <a href="https://caniuse.com/">https://caniuse.com/</a> to double-check. For WOFF files, you can see the results here: <a href="https://caniuse.com/?search=woff">https://caniuse.com/?search=woff</a>.</p>
			<p>Copy <strong class="source-inline">kenney_future_narrow-webfont.woff2</strong> into the <strong class="source-inline">static</strong> directory in your application so that it gets picked up by the build process. Then, you need to specify <strong class="source-inline">@font-face</strong> in CSS so that elements can be rendered in it, which looks like so:</p>
			<p class="source-code">@font-face {</p>
			<p class="source-code">  font-family: 'Ken Future';</p>
			<p class="source-code">  src: url('kenney_future_narrow-webfont.woff2');</p>
			<p class="source-code">}</p>
			<p>What we've done here is load a new font face with the simple name '<strong class="source-inline">Ken Future</strong>' so that we can reference it in other styles, and loaded it via the specified URL. Now, we can change all buttons to use that font with this additional CSS:</p>
			<p class="source-code">button {</p>
			<p class="source-code">    font-family: 'Ken Future';</p>
			<p class="source-code">}</p>
			<p>Now, you should see the button being rendered with a font that looks more like a game, as shown here:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer089">
					<img alt="Figure 8.3 – New Game with the Kenney Future Font" src="image/Figure_8.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – New Game with the Kenney Future Font</p>
			<p>The button <a id="_idIndexMarker700"/>still looks a lot like an HTML button because of that traditional web background. To make it look more like a game button, we'll use a background and CSS Sprites to create a pretty button with rounded corners and hover colors.</p>
			<h3>CSS Sprites </h3>
			<p>As a game developer, you already know what a sprite is; you haven't forgotten <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, already, have you? In the case of <strong class="bold">CSS Sprites</strong>, the term as commonly used <a id="_idIndexMarker701"/>is a bit of a misnomer, as instead of referring to a sprite, it really refers to a sprite sheet.</p>
			<p>Conceptually, CSS Sprites work the same way as rendering them with the canvas. You slice out a chunk of a larger sprite and only render that portion. We'll just do the entire thing in CSS instead of Rust. Since we're using CSS, we can change the background when the mouse is over the button and when it is clicked. This will make the button look correct, and we won't have to write Rust code to have the same effect. Clicking a button is something a browser is very good at, so we'll leverage it.</p>
			<p>We'll use the <strong class="source-inline">Button.svg</strong> file from the <strong class="source-inline">ui</strong> directory in the downloaded assets, so you can copy that file to the <strong class="source-inline">static</strong> directory in your game's project. The SVG file actually contains an entire library of buttons, which looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer090">
					<img alt="Figure 8.4 – The top of Button.svg" src="image/Figure_8.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The top of Button.svg</p>
			<p>We'll want to <a id="_idIndexMarker702"/>slice out the wide blue, green, and yellow buttons to be the background for the button in various states. We'll start by using the <strong class="source-inline">background</strong> attribute in CSS to set the button's background to the SVG file. You'll update the style as follows:</p>
			<p class="source-code">button {</p>
			<p class="source-code">    font-family: 'Ken Future';</p>
			<p class="source-code">   <strong class="bold"> background: -72px -60px url('Button.svg');</strong></p>
			<p class="source-code">}</p>
			<p>The pixel values in <strong class="source-inline">background</strong>, <strong class="source-inline">-72px</strong> and <strong class="source-inline">-60px</strong>, mean taking the background and shifting it <strong class="source-inline">72</strong> pixels to the left and <strong class="source-inline">60</strong> pixels upward to line it up with the blank blue button. You can get those <a id="_idIndexMarker703"/>values in a vector graphics editor such as <strong class="bold">Inkscape</strong>. The <strong class="source-inline">url</strong> value specifies which file to load. Make those changes, and you'll see the button change to have a new background… well, sort of.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 8.5 – The button, but with a cut-off background" src="image/Figure_8.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The button, but with a cut-off background</p>
			<p>As you can see, the background is cut off, so you only get half of it, and the button itself still has some of the effects of a default HTML button. We can get rid of those effects with a little more CSS to remove the border and resize the button to match the background, as shown here:</p>
			<p class="source-code">button {</p>
			<p class="source-code">    font-family: 'Ken Future';</p>
			<p class="source-code">    background: -72px -60px url('Button.svg');</p>
			<p class="source-code">    <strong class="bold">border: none;</strong></p>
			<p class="source-code">    <strong class="bold">width: 82px;</strong></p>
			<p class="source-code">    <strong class="bold">height: 33px;</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> values were plucked from *Inkscape~ again, and that will set the button to be the same size as the button background in the source. As with the sprite sheets we <a id="_idIndexMarker704"/>used earlier, we need to cut out a slice from the original source, so in this case, there is a rectangle starting at <strong class="source-inline">(72, 60)</strong> with a width and height of <strong class="source-inline">82x33</strong>. With those changes, the button now looks like a game button instead of a web button.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 8.6 – A New Game button&#13;&#10;" src="image/Figure_8.6_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – A New Game button</p>
			<p>There are still a few problems. The button now doesn't visually interact with the user, so it just looks like a picture when you click it. We can address that with CSS pseudo-classes for <strong class="source-inline">#active</strong> and <strong class="source-inline">#hover</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some browsers, notably Firefox, will render <strong class="bold">New Game</strong> on one line instead of two.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more <a id="_idIndexMarker705"/>information on pseudo-classes, check the Mozilla documentation here: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes</a>.</p>
			<p>In each pseudo-class, we'll change the background attribute to line up with another background. Again, the numbers were pulled out of Inkscape, with a little tweaking once they were added <a id="_idIndexMarker706"/>to make sure that they lined up. First, we can handle the <strong class="source-inline">hover</strong> style, which is when the mouse is over the image.</p>
			<p>That produces a hover button that looks like this:</p>
			<p class="source-code">button:hover {</p>
			<p class="source-code">    background: -158px -60px url('Button.svg');</p>
			<p class="source-code">}</p>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 8.7 – Hover&#13;&#10;" src="image/Figure_8.7_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Hover</p>
			<p>Then, we'll add the <strong class="source-inline">active</strong> style, which is what the mouse will look like when clicked:</p>
			<p class="source-code">button:active {</p>
			<p class="source-code">    background: -244px -60px url('Button.svg');</p>
			<p class="source-code">}</p>
			<p>That produces a clicked button like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 8.8 – Active" src="image/Figure_8.8_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Active</p>
			<p>The final issue is that our button is really small, for a game anyway, and is positioned at the upper-left corner. Making the button larger the traditional CSS way with width and height is problematic, as shown here when we change the width value:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 8.9 – That is not a button" src="image/Figure_8.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – That is not a button</p>
			<p>Changing the <a id="_idIndexMarker707"/>width or height will mean changing the "slice" that we're taking from the sprite sheet, so we don't want that. What we'll use instead is the CSS <strong class="source-inline">translate</strong> property, with the <strong class="source-inline">scale</strong> function, which looks like so:</p>
			<p class="source-code">button {</p>
			<p class="source-code">    font-family: 'Ken Future';</p>
			<p class="source-code">    background: -72px -60px url('Button.svg');</p>
			<p class="source-code">    border: none;</p>
			<p class="source-code">    width: 82px;</p>
			<p class="source-code">    height: 33px;</p>
			<p class="source-code">    <strong class="bold">transform: scale(1.8);</strong></p>
			<p class="source-code">}</p>
			<p>This gives us a nice large button with the right background, but it's not in the right spot.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 8.10 – The button with the left side cut off" src="image/Figure_8.10_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – The button with the left side cut off</p>
			<p>Now that the button is large and looks like a game button, we just need to put it in the right spot. You can <a id="_idIndexMarker708"/>do that by adding <strong class="source-inline">translate</strong> to the <strong class="source-inline">transform</strong> property, where <strong class="source-inline">translate</strong> is a fancy way of saying <strong class="source-inline">move</strong>. You can see that as follows:</p>
			<p class="source-code">button {</p>
			<p class="source-code">    font-family: 'Ken Future';</p>
			<p class="source-code">    background: -72px -60px url('Button.svg');</p>
			<p class="source-code">    border: none;</p>
			<p class="source-code">    width: 82px;</p>
			<p class="source-code">    height: 33px;</p>
			<p class="source-code">    transform: scale(1.8)<strong class="bold"> translate(150px, 100px);</strong></p>
			<p class="source-code">}</p>
			<p>This will get the new game button into, roughly, the center of the screen.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 8.11 – A New Game button!&#13;&#10;" src="image/Figure_8.11_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – A New Game button!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Centering a <a id="_idIndexMarker709"/>button in a div requires a little more CSS than I want to cover in this book. Since we're positioning things manually, we can go with "good enough" for now. If you're more comfortable with web development, feel free to make it truly perfectly centered. If you're interested in getting the perfect center with Flexbox, take a look here: <a href="https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989">https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989</a>.</p>
			<p>The new game button now shows up, but it doesn't do anything because our code isn't doing anything with <strong class="source-inline">onclick</strong>. It's just a floating button, taunting us with its ineffectiveness. Go ahead and remove the <strong class="source-inline">button</strong> element from <strong class="source-inline">index.html</strong>, but keep <strong class="source-inline">div</strong> with the <strong class="source-inline">ui</strong> ID. Instead, we'll use Rust to dynamically add and remove the button when <a id="_idIndexMarker710"/>we need it and actually handle the clicks. For that, we'll want to make some additions to our <strong class="source-inline">browser</strong> and <strong class="source-inline">engine</strong> modules, so let's d<a id="_idTextAnchor189"/>ig in.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor190"/>Showing the button with Rust</h2>
			<p>We've written HTML to show the button and it looks pretty good, but we'll actually need to show it <a id="_idIndexMarker711"/>and hide it on command. This means interacting with the browser and using the <strong class="source-inline">browser</strong> module. We haven't done this in <a id="_idIndexMarker712"/>a while, so let's refresh our memory on how we translate from the JavaScript we'd write traditionally to the Rust with <strong class="source-inline">web-sys</strong> that we'll be using. First, we'll need code to insert the button into the <strong class="source-inline">ui</strong> div. There are lots of ways to do this; we'll use <strong class="source-inline">insertAdjacentHTML</strong> so that we can just send a string from our code to the screen. In JavaScript, that looks like this:</p>
			<p class="source-code">let ui = document.getElementById("ui");</p>
			<p class="source-code">ui.insertAdjacentHTML("afterbegin", "&lt;button&gt;New Game&lt;/button&gt;");</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can <a id="_idIndexMarker713"/>find the docs for this function at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML">https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML</a>. When it comes to looking up browser <a id="_idIndexMarker714"/>APIs, the <strong class="bold">Mozilla Developer Network</strong> (<strong class="bold">MDN</strong>) is your friend.</p>
			<p>We spent a lot of time translating this kind of code into Rust in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, and <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, but let's refresh our memory and appease any monsters who read books out of order. Any JavaScript function or method is likely to be found in the <strong class="source-inline">web-sys</strong> crate with the name converted from PascalCase to snake_case, and with most of the functions returning <strong class="source-inline">Option</strong>. Frequently, you can just try that out, and it will work. Let's create a new function in <strong class="source-inline">browser</strong> and see whether that's the case, as shown here:</p>
			<p class="source-code">pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    document()</p>
			<p class="source-code">        .and_then(|doc| {</p>
			<p class="source-code">            doc.get_element_by_id("ui")</p>
			<p class="source-code">                .ok_or_else(|| anyhow!("UI element not found"))</p>
			<p class="source-code">        })</p>
			<p class="source-code">        .and_then(|ui| {</p>
			<p class="source-code">            ui.insert_adjacent_html("afterbegin", html)</p>
			<p class="source-code">                .map_err(|err| anyhow!("Could not insert </p>
			<p class="source-code">                    html {:#?}", err))</p>
			<p class="source-code">        })</p>
			<p class="source-code">}</p>
			<p>This <strong class="source-inline">draw_ui</strong> function assumes there is a div with the <strong class="source-inline">ui</strong> ID, just as the <strong class="source-inline">canvas</strong> function assumes an ID of <strong class="source-inline">canvas</strong>. This means it's not <em class="italic">incredibly</em> generic, but we don't need a <a id="_idIndexMarker715"/>more complex solution right now. If we do later, we'll write more functions. As always, we don't want to go too far with some idea of "perfect" code because we've got a game to finish.</p>
			<p>Once again, the Rust <a id="_idIndexMarker716"/>version of the code is much longer, using <strong class="source-inline">and_then</strong> and mapping errors to make sure we handle the error cases instead of just crashing or halting the program as JavaScript would. This is another case where code is aesthetically less pleasing in Rust but, in my opinion, better because it highlights the possible causes of an error. The other function we'll need right away is used to hide the <strong class="source-inline">ui</strong> element, which looks like this in JavaScript:</p>
			<p class="source-code">let ui = document.getElementById("ui");</p>
			<p class="source-code">let firstChild = ui.firstChild;</p>
			<p class="source-code">ui.removeChild(firstChild);</p>
			<p>This function grabs the first child of the <strong class="source-inline">ui</strong> div and removes it with the <strong class="source-inline">removeChild</strong> method. To be completely thorough, we should loop through all the <strong class="source-inline">ui</strong> children and make sure they all get removed, but we don't do that here because we already know there's only one. We also remove the children (and don't just set their visibility to hidden) so that they do not affect the layout, and any event listeners are removed. Once again, you'll want to translate JavaScript to Rust. In this case, <strong class="source-inline">firstChild</strong> becomes the <strong class="source-inline">first_child()</strong> method and <strong class="source-inline">removeChild</strong> becomes <strong class="source-inline">remove_child</strong>, as shown here:</p>
			<p class="source-code">pub fn hide_ui() -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    let ui = document().and_then(|doc| {</p>
			<p class="source-code">        doc.get_element_by_id("ui")</p>
			<p class="source-code">            .ok_or_else(|| anyhow!("UI element not found"))</p>
			<p class="source-code">    })?;</p>
			<p class="source-code">    if let Some(child) = ui.first_child() {</p>
			<p class="source-code">        ui.remove_child(&amp;child)</p>
			<p class="source-code">            .map(|_removed_child| ())</p>
			<p class="source-code">            .map_err(|err| anyhow!("Failed to remove child </p>
			<p class="source-code">                {:#?}", err))</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function <a id="_idIndexMarker717"/>is a little different than <strong class="source-inline">draw_ui</strong>, in part <a id="_idIndexMarker718"/>because <strong class="source-inline">first_child</strong> being missing isn't an error; it just means you called <strong class="source-inline">hide_ui</strong> on an empty UI, and we don't want that to error. That's why we use the <strong class="source-inline">if let</strong> construct and just return an <strong class="source-inline">Ok(())</strong> explicitly if it isn't present. The <strong class="source-inline">ui</strong> div was already empty, so it's fine. In addition, there's that weird call to <strong class="source-inline">map(|_removed_child| ())</strong>, which we call because <strong class="source-inline">remove_child</strong> returns the <strong class="source-inline">Element</strong> being removed. We don't care about it here, so we are, once again, explicitly mapping it to our expected value of unit. Finally, of course, we address the error with <strong class="source-inline">anyhow!</strong>.</p>
			<p>This function <a id="_idIndexMarker719"/>reveals some duplication, so let's go ahead <a id="_idIndexMarker720"/>and refactor it out in the final version, as follows:</p>
			<p class="source-code">pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    <strong class="bold">find_ui()?</strong></p>
			<p class="source-code">        .insert_adjacent_html("afterbegin", html)</p>
			<p class="source-code">        .map_err(|err| anyhow!("Could not insert html </p>
			<p class="source-code">            {:#?}", err))</p>
			<p class="source-code">}</p>
			<p class="source-code">pub fn hide_ui() -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    <strong class="bold">let ui = find_ui()?;</strong></p>
			<p class="source-code">    if let Some(child) = ui.first_child() {</p>
			<p class="source-code">        ui.remove_child(&amp;child)</p>
			<p class="source-code">            .map(|_removed_child| ())</p>
			<p class="source-code">            .map_err(|err| anyhow!("Failed to remove child </p>
			<p class="source-code">                {:#?}", err))</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">fn find_ui() -&gt; Result&lt;Element&gt; {</p>
			<p class="source-code">    document().and_then(|doc| {</p>
			<p class="source-code">        doc.get_element_by_id("ui")</p>
			<p class="source-code">            .ok_or_else(|| anyhow!("UI element not found"))</p>
			<p class="source-code">    })</p>
			<p class="source-code">}</p>
			<p>Here, we've replaced both of the repetitive <strong class="source-inline">document().and_then</strong> calls with calls to <strong class="source-inline">find_ui</strong>, which is a private function that ensures we always get the same error when UI isn't found. It streamlines a little bit of code and makes it possible to use the <strong class="source-inline">try</strong> operator in <strong class="source-inline">draw_ui</strong>. The <strong class="source-inline">find_ui</strong> function returns <strong class="source-inline">Element</strong>, so you need to make sure to import <strong class="source-inline">web_sys::Element</strong>.</p>
			<p>We've got the tools we need to draw the button set up in <strong class="source-inline">browser</strong>. To show our button programmatically, we can just call <strong class="source-inline">browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;")</strong>. That's great, but we can't actually handle doing anything on the button click yet. We have two choices. The first is to create the button with an <strong class="source-inline">onclick</strong> handler such as <strong class="source-inline">browser::draw_ui("&lt;button onclick='myfunc'&gt;New Game&lt;/button&gt;")</strong>. This will require taking a function in our Rust <a id="_idIndexMarker721"/>package and exposing it to the browser. It <a id="_idIndexMarker722"/>would also require some sort of global variable that the function could operate on. If <strong class="source-inline">myfunc</strong> is going to operate on the game state, then it needs access to the game state. We could use something such as an event queue here, and that's a viable approach, but it's not what we'll be doing.</p>
			<p>What we're going to do instead is set the <strong class="source-inline">onclick</strong> variable in Rust code, via the <strong class="source-inline">web-sys</strong> library, to a closure that writes to a channel. Other code can listen to this channel and see whether a click event has happened. This code will be very similar to the code we wrote in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, for handling keyboard input. We'll start with a function in the <strong class="source-inline">engine</strong> module that takes <strong class="source-inline">HtmlElement</strong> and returns <strong class="source-inline">UnboundedReceiver</strong>, as shown here:</p>
			<p class="source-code">pub fn add_click_handler(elem: HtmlElement) -&gt; UnboundedReceiver&lt;()&gt; {</p>
			<p class="source-code">    let (click_sender, click_receiver) = unbounded();</p>
			<p class="source-code">    click_receiver</p>
			<p class="source-code">}</p>
			<p>Don't forget to bring <strong class="source-inline">HtmlElement</strong> into scope with <strong class="source-inline">use web_sys::HtmlElement</strong>. This doesn't do much, and it sure doesn't seem to have anything to do with a click, and it's not obvious why we need an <strong class="source-inline">UnboundedReceiver</strong>. When we add a click handler to the button, we don't want to have to move anything about the game <em class="italic">into</em> the closure. Using a channel here lets us encapsulate the handling of the click and separate it from the reacting to click event. Let's continue by creating the <strong class="source-inline">on_click</strong> handler, as shown here:</p>
			<p class="source-code">pub fn add_click_handler(elem: HtmlElement) -&gt; </p>
			<p class="source-code">    UnboundedReceiver&lt;()&gt; {</p>
			<p class="source-code">    let (<strong class="bold">mut </strong>click_sender, click_receiver) = unbounded();</p>
			<p class="source-code">    <strong class="bold">let on_click = browser::closure_wrap(Box::new(move || {</strong></p>
			<p class="source-code">        <strong class="bold">click_sender.start_send(());</strong></p>
			<p class="source-code">    <strong class="bold">}) as Box&lt;dyn FnMut()&gt;);</strong></p>
			<p class="source-code">    click_receiver</p>
			<p class="source-code">}</p>
			<p>The changes we've made are to make <strong class="source-inline">click_sender</strong> mutable and then move it into the newly <a id="_idIndexMarker723"/>created closure called <strong class="source-inline">on_click</strong>. You may <a id="_idIndexMarker724"/>remember <strong class="source-inline">closure_wrap</strong> from the earlier chapters, which needs to take a heap-allocated closure, in other words a <strong class="source-inline">Box</strong>, which, in this case, will be passed a <strong class="source-inline">mouse</strong> event that we're not using so we can safely skip it. The casting to <strong class="source-inline">Box&lt;dyn FnMut()&gt;</strong> is necessary to appease the compiler and allow this function to be converted into <strong class="source-inline">WasmClosure</strong>. Inside that, we call the sender's <strong class="source-inline">start_send</strong> function and pass it a unit. Since we're not using any other parameters, we can just have the receiver check for any event.</p>
			<p>Finally, we'll need to take this closure and assign it to the <strong class="source-inline">on_click</strong> method on <strong class="source-inline">elem</strong> so that the button actually handles it, which looks as follows:</p>
			<p class="source-code">pub fn add_click_handler(elem: HtmlElement) -&gt; UnboundedReceiver&lt;()&gt; {</p>
			<p class="source-code">    let (mut click_sender, click_receiver) = unbounded();</p>
			<p class="source-code">    let on_click = browser::closure_wrap(Box::new(move || {</p>
			<p class="source-code">        click_sender.start_send(());</p>
			<p class="source-code">    }) as Box&lt;dyn FnMut()&gt;);</p>
			<p class="source-code">    <strong class="bold">elem.set_onclick(Some(on_click.as_ref().unchecked_ref()));</strong></p>
			<p class="source-code">    <strong class="bold">on_click.forget();</strong></p>
			<p class="source-code">    click_receiver</p>
			<p class="source-code">}</p>
			<p>We've added the call to <strong class="source-inline">elem.set_onclick</strong>, which corresponds to <strong class="source-inline">elem.onclick =</strong> in JavaScript. Note how we pass <strong class="source-inline">set_onclick</strong> a <strong class="source-inline">Some</strong> variant because <strong class="source-inline">onclick</strong> itself can be <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong> in JavaScript and, therefore, can be <strong class="source-inline">None</strong> in Rust and is an <strong class="source-inline">Option</strong> type. We then pass it <strong class="source-inline">on_click.as_ref().unchecked_ref()</strong>, which is the pattern we've used several times to turn <strong class="source-inline">Closure</strong> into a function that <strong class="source-inline">web-sys</strong> can use.</p>
			<p>Finally, we also <a id="_idIndexMarker725"/>make sure to forget the <strong class="source-inline">on_click</strong> handler. Without this, when we actually make this callback, the program will crash <a id="_idIndexMarker726"/>because <strong class="source-inline">on_click</strong> hasn't been properly handed off to JavaScript. We've done this a few times, so I won't belabor the point here. Now that we've written all the code, we'll need to show a button and handle the response to it, and we need to integrate it into our game. Let's figure out how to show the button.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor191"/>Show the button on game over </h1>
			<p>We can show and hide the button in the <strong class="source-inline">Game</strong> <strong class="source-inline">update</strong> method by checking on each frame if the <a id="_idIndexMarker727"/>game is over and if the button is present, ensuring that we only show or hide it once, and that would probably work, but I think you can sense the spaghetti code beginning to form if we do that. In general, it's best to avoid too much conditional logic in <strong class="source-inline">update</strong>, as it gets confusing and allows for logic bugs. Instead, we can think of every conditional check that looks like <strong class="source-inline">if (state_is_true)</strong> as two different states of the system. So, if the new game button is shown, that's one game state, and if it isn't, that's another game state. You know what that means – it's ti<a id="_idTextAnchor192"/>me for a state machine.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor193"/>A state machine review</h2>
			<p>In <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>,<em class="italic"> Managing Animations with State Machines</em>, we <a id="_idIndexMarker728"/>converted RHB to <a id="_idIndexMarker729"/>a state machine in order to make it change animations on events easily and, more importantly, correctly. For instance, when we wanted RHB to jump, we went from <strong class="source-inline">Running</strong> to <strong class="source-inline">Jumping</strong> via a typestate method, only changing the state one time and changing the velocity and playing the sound one time. That code is reproduced here for clarity:</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn jump(self) -&gt; RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self</p>
			<p class="source-code">                    .context</p>
			<p class="source-code">                    .reset_frame()</p>
			<p class="source-code">                    .set_vertical_velocity(JUMP_SPEED)</p>
			<p class="source-code">                    .play_jump_sound(),</p>
			<p class="source-code">                _state: Jumping {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p>The typestates <a id="_idIndexMarker730"/>work great, but they are also noisy if we don't need <a id="_idIndexMarker731"/>that kind of functionality. That's why in that same chapter, we chose to model our game itself as a simple <strong class="source-inline">enum</strong>, like so:</p>
			<p class="source-code">pub enum WalkTheDog {</p>
			<p class="source-code">    Loading,</p>
			<p class="source-code">    Loaded(Walk),</p>
			<p class="source-code">}</p>
			<p>This is going to change significantly because we now have a problem that necessitates a state machine. When RHB is knocked out, the game is over, and the new game button should appear. That's a side effect that needs to happen once, on a change of state, the perfect use case for our state machine. Unfortunately, refactoring to a state machine is going to require a not insignificant amount of code because our current method for implementing state machines is elegant but a little noisy. In addition, there's actually two state machines at work here, which is not obvious at first. The first is the one we see at the <a id="_idIndexMarker732"/>beginning, moving from <strong class="source-inline">Loading</strong> to <strong class="source-inline">Loaded</strong>, which you <a id="_idIndexMarker733"/>can think of as when you don't have <strong class="source-inline">Walk</strong> and when you do. The second is the state machine of <strong class="source-inline">Walk</strong> itself, which moves from <strong class="source-inline">Ready</strong> to <strong class="source-inline">Walking</strong> to <strong class="source-inline">GameOver</strong>. You can visualize it like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="" src="image/Figure_8.12_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Nested state machines</p>
			<p>As you can see, we have two state machines here, one going from <strong class="source-inline">Loading</strong> to <strong class="source-inline">Loaded</strong> and the other representing the three game states of <strong class="source-inline">Ready</strong>, <strong class="source-inline">Walking</strong>, and <strong class="source-inline">GameOver</strong>. There is a third state machine, not pictured, the famous <strong class="source-inline">RedHatBoyStateMachine</strong> that manages the <strong class="source-inline">RedHatBoy</strong> animations. A couple of the states pictured mimic the states in <strong class="source-inline">RedHatBoyStateMachine</strong>, where <strong class="source-inline">Idle</strong> is <strong class="source-inline">Ready</strong> and <strong class="source-inline">Walking</strong> is <strong class="source-inline">Running</strong>, so there is a temptation to move <strong class="source-inline">RedHatBoyStateMachine</strong> into <strong class="source-inline">WalkTheDogStateMachine</strong>. This could work, but remember that <strong class="source-inline">Walk</strong> doesn't have a "jumping" state and so, by doing that, you'll need to <a id="_idIndexMarker734"/>start checking a Boolean, and the modeling starts to break down. It's best to accept the similarity because the game is heavily dependent <a id="_idIndexMarker735"/>on what RHB is doing, but treat <strong class="source-inline">RedHatBoyStateMachine</strong> as having more fine-grained states. What <em class="italic">does</em> work is turning <strong class="source-inline">Loading</strong> and <strong class="source-inline">Loaded</strong> into <strong class="source-inline">Option</strong>. Specifically, we'll model our game like so:</p>
			<p class="source-code">struct WalkTheDogGame {</p>
			<p class="source-code">    machine: Option&lt;WalkTheDogStateMachine&gt;</p>
			<p class="source-code">}</p>
			<p>This code isn't meant to be written anywhere yet; it's just here for clarity. There's a big advantage to using <strong class="source-inline">Option</strong> here, and it has to do with the way our <strong class="source-inline">update</strong> function works. For clarity, I'm going to reproduce a section of our game loop here:</p>
			<p class="source-code">let mut keystate = KeyState::new();</p>
			<p class="source-code">*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {</p>
			<p class="source-code">    process_input(&amp;mut keystate, &amp;mut keyevent_receiver);</p>
			<p class="source-code">    game_loop.accumulated_delta += (perf – </p>
			<p class="source-code">        game_loop.last_frame) as f32;</p>
			<p class="source-code">    while game_loop.accumulated_delta &gt; FRAME_SIZE {</p>
			<p class="source-code">        <strong class="bold">game.update(&amp;keystate);</strong></p>
			<p class="source-code">        game_loop.accumulated_delta -= FRAME_SIZE;</p>
			<p class="source-code">    }</p>
			<p>The key part here is the <strong class="source-inline">game.update</strong> line, which performs a mutable borrow on the <strong class="source-inline">game</strong> object instead of moving it into <strong class="source-inline">update</strong>. This is because once <strong class="source-inline">game</strong> is owned by <strong class="source-inline">FnMut</strong>, it can't be moved out. Trying to actually leads to this compiler error:</p>
			<p class="source-code">error[E0507]: cannot move out of `*game`, as `game` is a captured variable in an `FnMut` closure</p>
			<p>Mutable borrows such as this are tricky because they can make it more challenging to navigate the <a id="_idIndexMarker736"/>borrow checker as you proceed down the call stack. In this case, it becomes a problem if we try to implement another state machine in <a id="_idIndexMarker737"/>the same manner as <strong class="source-inline">RedHatBoyStateMachine</strong>. In our state machine implementation, each <strong class="source-inline">typestate</strong> method consumes the machine and returns a new one. Now, let's imagine that we are modeling the entire game as <strong class="source-inline">enum</strong>, like so:</p>
			<p class="source-code">enumWalkTheDogGame {</p>
			<p class="source-code">    Loading,</p>
			<p class="source-code">    Loaded(Walk),</p>
			<p class="source-code">    Walking(Walk),</p>
			<p class="source-code">    GameOver(Walk)</p>
			<p class="source-code">}</p>
			<p>In order to make this work with the mutable borrow in <strong class="source-inline">update</strong>, we would have to clone the entire game on every state change because the <strong class="source-inline">from</strong> function couldn't take ownership of it. In other words, the closure in our <strong class="source-inline">game.update</strong> function <em class="italic">lends</em> <strong class="source-inline">game</strong> to the <strong class="source-inline">update</strong> function. This can't turn around and <em class="italic">give</em> it to the <strong class="source-inline">from</strong> function – it doesn't own it! Doing so requires cloning the entire game, potentially on every frame!</p>
			<p>Modeling the game as holding an optional <strong class="source-inline">WalkTheDogStateMachine</strong> has two advantages:</p>
			<ul>
				<li>We can call <strong class="source-inline">take</strong> on <strong class="source-inline">Option</strong> to get ownership of the state machine.</li>
				<li>The type reflects that the state machine isn't available until the game is loaded.<p class="callout-heading">Note</p><p class="callout">There are, naturally, many ways to model our game type, and some of them are going to be better than the one we'll choose here. However, before you start trying to do a "simpler" version of this type, let me warn you that I tried several different variations on this solution and ultimately found using <strong class="source-inline">Option</strong> to be the most straightforward choice. Several other implementations either ended with complex borrowing or unnecessary cloning. Be wary, but also be brave. You may find a better way than I did!</p></li>
			</ul>
			<p>Before we <a id="_idIndexMarker738"/>dig into the actual implementation, which is fairly long, let's go <a id="_idIndexMarker739"/>over the design we're implementing.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 8.13 – Before" src="image/Figure_8.13_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Before</p>
			<p>It's pretty simple, but it doesn't do all that we need it to. Now, let's redesign the state machine.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer100">
					<img alt="Figure 8.14 – After&#13;&#10;" src="image/Figure_8.14_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – After</p>
			<p>Yeah, that's <a id="_idIndexMarker740"/>a lot more code, and it doesn't even reflect the details <a id="_idIndexMarker741"/>of the implementation, or the <strong class="source-inline">From</strong> traits we write to make it easy to convert between the <strong class="source-inline">enum</strong> values and structs. Writing some macros to handle state machine boilerplate is out of the scope of this book, but it's not a bad idea. You might wonder why every state holds its own <strong class="source-inline">Walk</strong> instance when every single state has it, and that's because we're going to change <strong class="source-inline">Walk</strong> on the transitions and the individual states don't have easy access to the parent <strong class="source-inline">WalkTheDogState</strong> container data. However, where possible, we'll move common data out of <strong class="source-inline">Walk</strong> and into <strong class="source-inline">WalkTheDogState</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This section has a lot of code, and the snippets tend to only show a few lines at a time so that it's not too much to process. However, as you're following along, you may wish to reorganize the code to be easier to find. For instance, I prefer to work top-down in the <strong class="source-inline">game</strong> module, with constants at the top followed by the "biggest" <strong class="source-inline">struct</strong>, which is <strong class="source-inline">WalkTheDog</strong> in this case, followed by any code it depends on, so that the call stack flows down the page. This is how <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a> is organized. You're also welcome to start breaking this up into more files. I won't, to make it easier to explain in book form.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor194"/>Redesigning to a state machine </h2>
			<p>In a true refactoring, we would make sure the game was in a running state after each change, but our <a id="_idIndexMarker742"/>changes are going to cause cascading compiler errors, meaning we're going to be broken for a while, so this change isn't <a id="_idIndexMarker743"/>truly a refactoring but more of a redesign. When you make this kind of change, you should absolutely get to a compiling state as quickly as possible and stay there as long as possible, but while I did that when writing this chapter, I'm not going to put you through all the intermediate steps. We'll move forward as if we know in advance that our design is going to work because we do this time, but don't try this at home. If you're a regular Git user, now is an excellent time to create a branch, just in case.</p>
			<p>We'll start by replacing this code in the <strong class="source-inline">game</strong> module:</p>
			<p class="source-code">pub enum WalkTheDog {</p>
			<p class="source-code">    Loading,</p>
			<p class="source-code">    Loaded(Walk),</p>
			<p class="source-code">}</p>
			<p>We'll replace it with the following:</p>
			<p class="source-code">pub struct WalkTheDog {</p>
			<p class="source-code">    machine: Option&lt;WalkTheDogStateMachine&gt;,</p>
			<p class="source-code">}</p>
			<p>This will cause compiler errors all over the place. This is the section where we'll take the shortcut of letting the compiler be broken temporarily while we implement the state machine, if only to make sure this chapter isn't a thousand pages long. So, if you're uncomfortable working with a broken code base for a long time, that's good – just trust that I was <em class="italic">brilliant</em> and got this all right on the first try. Pretend – it'll be okay.</p>
			<p>Since we're psychic and know exactly how this design is going to work out, we can go and push ahead, knowing that eventually, everything will come together without errors. This first change is exactly what we discussed earlier – <strong class="source-inline">enum WalkTheDog</strong> becomes a struct holding its <strong class="source-inline">machine</strong> instance, which is an <strong class="source-inline">optional</strong> field. Currently, <strong class="source-inline">WalkTheDogStateMachine</strong> doesn't exist, so we'll add that next, like so:</p>
			<p class="source-code">enum WalkTheDogStateMachine {</p>
			<p class="source-code">    Ready(WalkTheDogState&lt;Ready&gt;),</p>
			<p class="source-code">    Walking(WalkTheDogState&lt;Walking&gt;),</p>
			<p class="source-code">    GameOver(WalkTheDogState&lt;GameOver&gt;),</p>
			<p class="source-code">}</p>
			<p>When we <a id="_idIndexMarker744"/>implement a state machine in Rust, we <a id="_idIndexMarker745"/>need <strong class="source-inline">enum</strong> as a container for states so that <strong class="source-inline">WalkTheDog</strong> doesn't need to be a generic <strong class="source-inline">struct</strong>. We've moved the compiler errors down because there is no <strong class="source-inline">WalkTheDogState</strong> and no states defined. Let's do that next:</p>
			<p class="source-code">struct WalkTheDogState&lt;T&gt; {</p>
			<p class="source-code">    _state: T,</p>
			<p class="source-code">    walk: Walk,</p>
			<p class="source-code">}</p>
			<p class="source-code">struct Ready;</p>
			<p class="source-code">struct Walking;</p>
			<p class="source-code">struct GameOver;</p>
			<p>Right now, the various typestates, <strong class="source-inline">Ready</strong>, <strong class="source-inline">Walking</strong>, and <strong class="source-inline">GameOver</strong>, don't store any data. This will change a little as we go on, but all of the typestates have <strong class="source-inline">Walk</strong> so that they can be saved in the common <strong class="source-inline">WalkTheDogState</strong> struct. Now that we've created the state machine, we need to look at where the old version of <strong class="source-inline">WalkTheDog</strong> was used. The first is in the small <strong class="source-inline">impl</strong> block for <strong class="source-inline">WalkTheDog</strong>, in the old code where we created <strong class="source-inline">enum</strong>, like so:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog::Loading {}</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That's not going to work, and it's not compiling, so instead, let's replace it with an empty <strong class="source-inline">WalkTheDog</strong> instance, as shown here:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    pub fn new() -&gt; Self {</p>
			<p class="source-code">        WalkTheDog { machine: None }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This change <a id="_idIndexMarker746"/>replaces the old, and not used, <strong class="source-inline">enum</strong> with <strong class="source-inline">machine</strong> set to <strong class="source-inline">None</strong>. You can now think of <strong class="source-inline">None</strong> as the <strong class="source-inline">Loading</strong> state, and <a id="_idIndexMarker747"/>when a machine is present, you are <strong class="source-inline">Loaded</strong>. Speaking of loading, the next logical place to make changes is in the <strong class="source-inline">Game</strong> implementation for <strong class="source-inline">WalkTheDog</strong>. Looking at the <strong class="source-inline">initialize</strong> function that we've been in so many times, you'll see a compiler error here:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        <strong class="bold">match self</strong> {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p>The <strong class="source-inline">match self</strong> line is not going to work anymore because <strong class="source-inline">self</strong> isn't <strong class="source-inline">enum</strong>. What we need to do instead is match <strong class="source-inline">machine</strong>, and if it's <strong class="source-inline">None</strong>, then load the new machine, and if it's present, then use <strong class="source-inline">Err</strong> in the same way we do now because <strong class="source-inline">initialize</strong> was somehow called twice. We can start by replacing both halves of the <strong class="source-inline">match</strong> statement, so the match should start as follows:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        <strong class="bold">match self.machine</strong> {</p>
			<p class="source-code">            <strong class="bold">None </strong>=&gt; {</p>
			<p>Look closely <a id="_idIndexMarker748"/>to see that we now match on <strong class="source-inline">self.machine</strong>, and we match against <strong class="source-inline">None</strong>. Before we dig into the <strong class="source-inline">None</strong> match arm, let's <a id="_idIndexMarker749"/>quickly change the match on <strong class="source-inline">WalkTheDog::Loaded(_)</strong>, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self.machine {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            Some(_) =&gt; Err(anyhow!("Error: Game is already  </p>
			<p class="source-code">                initialized!")),</p>
			<p>This simply changes <strong class="source-inline">WalkTheDog::Loaded</strong> to <strong class="source-inline">Some</strong>, using the same error message.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In order to get clearer error messages, you can <strong class="source-inline">#[derive(Debug)]</strong> on the <strong class="source-inline">WalkTheDog</strong> struct. Doing that has cascading effects because everything it depends on also has to <strong class="source-inline">#[derive(Debug)]</strong>, so we won't do that here, but it's a good idea, especially if you're running into issues here.</p>
			<p>Now that both halves of the match properly match an <strong class="source-inline">Option</strong> type, we need to modify <strong class="source-inline">initialization</strong> to return the proper type. At the bottom of the <strong class="source-inline">None</strong> branch, you will want to create a state machine like the one shown here, right before returning the value:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self.machine {</p>
			<p class="source-code">            None =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                let timeline = </p>
			<p class="source-code">                    rightmost(&amp;starting_obstacles);</p>
			<p class="source-code">                let machine = WalkTheDogStateMachine</p>
			<p class="source-code">                    ::Ready(WalkTheDogState {</p>
			<p class="source-code">                    _state: Ready,</p>
			<p class="source-code">                    walk: Walk {</p>
			<p class="source-code">                        boy: rhb,</p>
			<p class="source-code">                        backgrounds: [</p>
			<p class="source-code">                            Image::new(background.clone(), </p>
			<p class="source-code">                                Point { x: 0, y: 0 }),</p>
			<p class="source-code">                            Image::new(</p>
			<p class="source-code">                                background,</p>
			<p class="source-code">                                Point {</p>
			<p class="source-code">                                    x: background_width,</p>
			<p class="source-code">                                    y: 0,</p>
			<p class="source-code">                                },</p>
			<p class="source-code">                            ),</p>
			<p class="source-code">                        ],</p>
			<p class="source-code">                        obstacles: starting_obstacles,</p>
			<p class="source-code">                        obstacle_sheet: sprite_sheet,</p>
			<p class="source-code">                        stone,</p>
			<p class="source-code">                        timeline,</p>
			<p class="source-code">                    },</p>
			<p class="source-code">                });</p>
			<p class="source-code">                ...</p>
			<p>This is very similar to the code before; the construction of <strong class="source-inline">Walk</strong> is unchanged, but it's obscured <a id="_idIndexMarker750"/>by all the state machine noise. We are binding the <strong class="source-inline">machine</strong> variable to <strong class="source-inline">WalkTheDogStateMachine::Ready</strong> with the <a id="_idIndexMarker751"/>initialized <strong class="source-inline">WalkTheDogState </strong>instance, which, in turn, sets its internal <strong class="source-inline">_state</strong> value to <strong class="source-inline">Ready</strong>, and with the state getting to have  <strong class="source-inline">Walk</strong>. It's noisy, and after we get this file back to compiling, we'll do true refactoring to make that line a little cleaner, but put a pin in that for now.</p>
			<p>Now, we made it so that <strong class="source-inline">initialize</strong> returns a new <strong class="source-inline">Result&lt;Box&lt;dyn Game&gt;&gt;</strong> a while back, so we'll need to return a new <strong class="source-inline">Game</strong> instance next. So, right after adding <strong class="source-inline">machine</strong>, add the following:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self.machine {</p>
			<p class="source-code">            None =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                 Ok(Box::new(WalkTheDog {</p>
			<p class="source-code">                    machine: Some(machine),</p>
			<p class="source-code">                }))</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Given that <strong class="source-inline">initialize</strong> takes <strong class="source-inline">self</strong> and doesn't really use it, it's debatable whether it should be in the <strong class="source-inline">Game</strong> trait. Creating a separate trait, such as <strong class="source-inline">Initializer</strong>, will require a lot of modifications and is an exercise for the reader.</p>
			<p>This takes care of making sure <strong class="source-inline">initialize</strong> returns a game with a machine in the right state. We have two more big trait methods, <strong class="source-inline">update</strong> and <strong class="source-inline">draw</strong>, to take care of, and <strong class="source-inline">update</strong> is filled <a id="_idTextAnchor195"/>with compiler errors, so let's do that next.</p>
			<h3>Spreading update into the state machine</h3>
			<p>The <strong class="source-inline">update</strong> function is filled with compiler errors, is the core of the game's behavior, and has an <a id="_idIndexMarker752"/>additional challenge. Instinctively, you might think you can modify the beginning of the function like so:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let Some(machine) = self.machine {</p>
			<p class="source-code">            ...</p>
			<p>The <strong class="source-inline">if let Some(machine) = self.machine</strong> line will eventually fail to compile with the error:</p>
			<p class="source-code">error[E0507]: cannot move out of `self.machine.0` which is behind a mutable reference</p>
			<p class="source-code">   --&gt;src/game.rs:676:32</p>
			<p class="source-code">    |</p>
			<p class="source-code">676 |         if let Some(machine) = self.machine {</p>
			<p class="source-code">    |                     -------    ^^^^^^^^^^^^ help: consider borrowing here: `&amp;self.machine`</p>
			<p>Now, you may try, as I did, to fix this by changing the line to <strong class="source-inline">if let Some(machine) = &amp;mut self.machine</strong>. This will work until you try to implement a transition on <strong class="source-inline">WalkTheDogState</strong>. Because you have a borrowed machine, you'll also have a borrowed state when you later match on the state, as with the following example:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState)</p>
			<p class="source-code">        if let Some(machine) = &amp;mut self.machine {</p>
			<p class="source-code">            match machine {</p>
			<p class="source-code">                WalkTheDogStateMachine::Ready(state) =&gt; {</p>
			<p>Here, the <strong class="source-inline">state</strong> value is borrowed, unlike in most other cases where the match arms take ownership <a id="_idIndexMarker753"/>of the value, and it's not instantly obvious. It will be if we write a transition from <strong class="source-inline">Ready</strong> to <strong class="source-inline">Walking</strong>. In order to write <strong class="source-inline">state._state.run_right()</strong> and get to <strong class="source-inline">Walking</strong>, your transition will need to look like this in order to compile:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    fn start_running(<strong class="bold">&amp;mut self</strong>) -&gt; WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">        self.run_right();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Walking,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Note that we are transitioning from <strong class="source-inline">&amp;mut WalkTheDogState&lt;Ready&gt;&gt;</strong> to <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong>, which is an odd conversion and a hint that this is wrong. What you can't see is that this code won't compile. Returning the new <strong class="source-inline">WalkTheDogState</strong> with <strong class="source-inline">walk</strong> is a move that we cannot do because <strong class="source-inline">state</strong> is borrowed. The <strong class="source-inline">start_running</strong> method doesn't own <strong class="source-inline">state</strong>, so it can't take ownership of <strong class="source-inline">state.walk</strong> and, therefore, can't return the new instance. The workaround for this is to clone the entire <strong class="source-inline">Walk</strong> each time we transition, but there's no need for that inefficiency. We can, instead, take ownership of <strong class="source-inline">machine</strong> all the way back up in the <strong class="source-inline">Game</strong> implementation, through the aptly named <strong class="source-inline">take</strong> function. Instead of using a mutable borrow on the machine, we'll call <strong class="source-inline">take</strong>, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let Some(machine) = self.machine.take() {</p>
			<p>This is the same code as earlier, but instead, we call the <strong class="source-inline">take</strong> method on <strong class="source-inline">Option&lt;WalkTheDogStateMachine&gt;</strong>. This replaces the state machine in <strong class="source-inline">self</strong> with <strong class="source-inline">None</strong> and binds the existing <strong class="source-inline">machine</strong> to the variable in <strong class="source-inline">if let Some(machine)</strong>. Now, inside that scope, we have complete ownership of <strong class="source-inline">machine</strong> and can do whatever we like to it, before eventually calling <strong class="source-inline">replace</strong> on the state machine in <strong class="source-inline">self</strong> to move it back in at the end of this function. It's a little awkward, but it gets around <a id="_idIndexMarker754"/>mutable borrows. It <em class="italic">also</em> introduces a potential error in that when control exits the <strong class="source-inline">update</strong> function, <strong class="source-inline">machine</strong> could still be set to <strong class="source-inline">None</strong>, effectively halting the game by accident. In order to prevent that from happening, before we continue updating this function, we'll add <strong class="source-inline">assert</strong> just outside the <strong class="source-inline">if let</strong> statement, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let Some(machine) = self.machine.take() {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">        }</p>
			<p class="source-code">        assert!(self.machine.is_some());</p>
			<p>Unfortunately, this is a runtime error, not a compile-time one, but it's going to let us know right away whether we mess up the next section. This <strong class="source-inline">assert</strong> may be overkill, because we are going to dramatically reduce the amount of code inside the <strong class="source-inline">if let</strong> block; in fact, it will be just one line. First, we'll add a call to a non-existent function called <strong class="source-inline">update</strong> on our state machine, as follows:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let Some(machine) = self.machine.take() {</p>
			<p class="source-code">            self.machine.replace(machine.<strong class="bold">update</strong>(keystate));</p>
			<p class="source-code">            if keystate.is_pressed("ArrowRight") {</p>
			<p>Immediately after <strong class="source-inline">if let Some(machine)</strong>, add the <strong class="source-inline">self.machine.replace(machine.update(keystate))</strong> line. All the code below <strong class="source-inline">replace</strong> in the <strong class="source-inline">if let</strong> block is going to become part of various <strong class="source-inline">update</strong> functions in the implemented states, so what you'll want to do is either cut and paste that code <a id="_idIndexMarker755"/>to some place you can get it, or just comment it out. Next, we'll create <strong class="source-inline">impl</strong> on <strong class="source-inline">WalkTheDogStateMachine</strong> with this new <strong class="source-inline">update</strong> method, which will return the new state. An empty version of that will look like this:</p>
			<p class="source-code">impl WalkTheDogStateMachine {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; Self {</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, you can call that from the the <strong class="source-inline">update</strong> method in <strong class="source-inline">Game</strong>, which looks like this:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let Some(machine) = self.machine.take() {</p>
			<p class="source-code">            self.machine.replace(machine.update(keystate));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        assert!(self.machine.is_some());</p>
			<p class="source-code">    }</p>
			<p>The <strong class="source-inline">update</strong> method in <strong class="source-inline">WalkTheDogStateMachine</strong> is a little empty, and we should probably put some code in it. We could call <strong class="source-inline">match self</strong> in the update, and then write the behavior for each state in this <strong class="source-inline">update</strong> function, calling things such as <strong class="source-inline">state._state.walk.boy.run_right()</strong>, which would work but it is hideous. Instead, we'll match on <strong class="source-inline">self</strong> and then delegate to the individual <strong class="source-inline">state</strong> types. This will result in a pretty redundant <strong class="source-inline">match</strong> statement, as shown here:</p>
			<p class="source-code">impl WalkTheDogStateMachine {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; Self {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDogStateMachine::Ready(state) </p>
			<p class="source-code">                =&gt;state.update(keystate).into(),</p>
			<p class="source-code">            WalkTheDogStateMachine::Walking(state) </p>
			<p class="source-code">                =&gt;state.update(keystate).into(),</p>
			<p class="source-code">            WalkTheDogStateMachine::GameOver(state) </p>
			<p class="source-code">               =&gt;state.update().into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We saw a <a id="_idIndexMarker756"/>variation of this pattern before in <strong class="source-inline">RedHatBoyStateMachine</strong>, where we have to match on each variant of <strong class="source-inline">enum</strong> in order to delegate to the state, and unfortunately, there's not a great way around it. Fortunately, it's small. This little <strong class="source-inline">match</strong> statement won't compile because none of the <strong class="source-inline">typestates</strong> types have an <strong class="source-inline">update</strong> method. In fact, there are no implementations for the typestates at all. Let's continue our delegation by creating placeholder implementations for all three of them, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; </p>
			<p class="source-code">        WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; </p>
			<p class="source-code">        WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    fn update(self) -&gt; WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>It's worth <a id="_idIndexMarker757"/>refreshing our memory on how typestates work. A typestate is a structure that is generic over a state. So <strong class="source-inline">WalkTheDogState&lt;T&gt;</strong> is the structure, and we implement transitions between states by adding methods to implementations of <strong class="source-inline">WalkTheDogState&lt;T&gt;</strong>, where <strong class="source-inline">T</strong> is one of the concrete states. These placeholders all just return <strong class="source-inline">self</strong>, so <strong class="source-inline">update</strong> isn't doing anything yet. Look closely and you'll notice that <strong class="source-inline">GameOver</strong> doesn't take <strong class="source-inline">KeyState</strong> because it won't need it.</p>
			<p>The <strong class="source-inline">update</strong> method on <strong class="source-inline">WalkTheDogStateMachine</strong> tries to use <strong class="source-inline">into</strong> to convert each typestate back into <strong class="source-inline">enum</strong>, but we haven't written those yet. Recalling <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, again, we need to implement <strong class="source-inline">From</strong> to convert back from the various states to the <strong class="source-inline">enum</strong> type. These are implemented here:</p>
			<p class="source-code">impl From&lt;WalkTheDogState&lt;Ready&gt;&gt; for WalkTheDogStateMachine {</p>
			<p class="source-code">    fn from(state: WalkTheDogState&lt;Ready&gt;) -&gt; Self {</p>
			<p class="source-code">        WalkTheDogStateMachine::Ready(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl From&lt;WalkTheDogState&lt;Walking&gt;&gt; for WalkTheDogStateMachine {</p>
			<p class="source-code">    fn from(state: WalkTheDogState&lt;Walking&gt;) -&gt; Self {</p>
			<p class="source-code">        WalkTheDogStateMachine::Walking(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl From&lt;WalkTheDogState&lt;GameOver&gt;&gt; for WalkTheDogStateMachine {</p>
			<p class="source-code">    fn from(state: WalkTheDogState&lt;GameOver&gt;) -&gt; Self {</p>
			<p class="source-code">        WalkTheDogStateMachine::GameOver(state)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is <a id="_idIndexMarker758"/>boilerplate just to get things started, but it demonstrates how each of these works. The <strong class="source-inline">update</strong> method on <strong class="source-inline">WalkTheDogStateMachine</strong> uses <strong class="source-inline">match</strong> to get the <strong class="source-inline">state</strong> value on each variant. Then, the <strong class="source-inline">update</strong> method is called on the various typestates. Each <strong class="source-inline">update</strong> method returns the state it transitions into, although right now, they all return <strong class="source-inline">self</strong>. Finally, back in the <strong class="source-inline">update</strong> method on <strong class="source-inline">WalkTheDogStateMachine</strong>s, we call <strong class="source-inline">into</strong> to convert the typestate back into an <strong class="source-inline">enum</strong> variant. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might remember that for <strong class="source-inline">RedHatBoyStateMachine</strong>, we used a transition function and an <strong class="source-inline">Event</strong> <strong class="source-inline">enum</strong> to advance the state machine. The new <strong class="source-inline">WalkTheDogStateMachine</strong> enum has fewer events, so additional complexity isn't necessary.</p>
			<p>It's time to think about what each state should actually do. Previously, every one of these states was kind of shoved together in the <strong class="source-inline">Game</strong> <strong class="source-inline">update</strong> method – for instance, the following old code:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">            if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">                walk.boy.run_right();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            if keystate.is_pressed("Space") {</p>
			<p class="source-code">                walk.boy.jump();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            if keystate.is_pressed("ArrowDown") {</p>
			<p class="source-code">                walk.boy.slide();</p>
			<p class="source-code">            }</p>
			<p>In the old <a id="_idIndexMarker759"/>system, if the game was <strong class="source-inline">Loaded</strong>, then <strong class="source-inline">boy</strong> could <strong class="source-inline">run_right</strong> if you pressed the <strong class="source-inline">ArrowRight</strong> button and could jump if you pressed <strong class="source-inline">Space</strong>. This worked fine, but it's worth noting the following:</p>
			<ul>
				<li>The <strong class="source-inline">run_right</strong> function does nothing if RHB is already running.</li>
				<li>The <strong class="source-inline">jump</strong> and <strong class="source-inline">slide</strong> functions do nothing if RHB isn't running.</li>
			</ul>
			<p>We handle this quite well in our <strong class="source-inline">RedHatBoyStateMachine</strong>, and will continue to do so, but what this reveals is that once RHB starts moving to the right, we don't really care if the player has pushed the <strong class="bold">ArrowRight</strong> button, and we don't really care if they push it again. Similarly, if the player hasn't pressed <strong class="bold">ArrowRight</strong>, there's no real reason to check whether they pressed <strong class="bold">Space</strong> or <strong class="bold">ArrowDown</strong>. This all fits well with our new <strong class="source-inline">WalkTheDogStateMachine</strong>. When the game is <strong class="source-inline">Ready</strong>, we'll check whether the user has hit <strong class="source-inline">ArrowRight</strong> and transition the state. Otherwise, we'll just stay in the same state.</p>
			<p>We can modify <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong> to reflect this new reality. The first change to the function will be to do that check, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; <strong class="bold">ReadyEndState</strong> {</p>
			<p class="source-code">        if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">            ReadyEndState::Complete(<strong class="bold">self.start_running()</strong>)</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            ReadyEndState::Continue(self)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There's one <a id="_idIndexMarker760"/>type and one method that doesn't exist, so this code does not compile yet. The transition of <strong class="source-inline">start_running</strong> doesn't exist yet, although we discussed writing something like it. We also don't have the <strong class="source-inline">ReadyEndState</strong> type. Let's address that second one first.</p>
			<p>We used this pattern earlier for any <strong class="source-inline">typestate</strong> method that can return more than one state, such as the <strong class="source-inline">update</strong> method on <strong class="source-inline">Jumping</strong> or <strong class="source-inline">Sliding</strong>. We create a new <strong class="source-inline">enum</strong> that can represent either of the return states. In the case of the <strong class="source-inline">update</strong> method for <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong>, the game can either still be <strong class="source-inline">Ready</strong> at the end of an update (<strong class="source-inline">ReadyEndState::Continue</strong>) or be done and transitioning to <strong class="source-inline">Walking</strong> (<strong class="source-inline">ReadyEndState::Complete</strong>).</p>
			<p>Let's start by implementing the <strong class="source-inline">From</strong> trait to convert from <strong class="source-inline">ReadyEndState</strong> to <strong class="source-inline">WalkTheDogStateMachine</strong>:</p>
			<p class="source-code">enum ReadyEndState {</p>
			<p class="source-code">    Complete(WalkTheDogState&lt;Walking&gt;),</p>
			<p class="source-code">    Continue(WalkTheDogState&lt;Ready&gt;),</p>
			<p class="source-code">}</p>
			<p class="source-code">impl From&lt;ReadyEndState&gt; for WalkTheDogStateMachine {</p>
			<p class="source-code">    fn from(state: ReadyEndState) -&gt; Self {</p>
			<p class="source-code">        match state {</p>
			<p class="source-code">            ReadyEndState::Complete(walking) =&gt; </p>
			<p class="source-code">                walking.into(),</p>
			<p class="source-code">            ReadyEndState::Continue(ready) =&gt; ready.into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is some <a id="_idIndexMarker761"/>boilerplate that you've seen before. We have two states for <strong class="source-inline">ReadyEndState</strong> because there are two states that the <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong> <strong class="source-inline">update</strong> method can end in. In order to get from <strong class="source-inline">ReadyEndState</strong> to <strong class="source-inline">WalkTheDogStateMachine</strong>, we create a <strong class="source-inline">From</strong> trait and match on both variants of <strong class="source-inline">ReadyEndState</strong> and extract their fields from them. Those are both typestates, <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong> and <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong>, respectively, so we use their <strong class="source-inline">into</strong> methods to convert them into the <strong class="source-inline">WalkTheDogStateMachine</strong> type. Those traits were already written earlier. </p>
			<p>The call to <strong class="source-inline">self.start_running</strong> is still not going to work because we haven't written it yet! What happens when the player hits <strong class="bold">ArrowRight</strong>? RedHatBoy starts walking! Remember that to transition from one state to another, we write a <strong class="source-inline">typestate</strong> method named after the transition, which looks like so:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn start_running(mut self) -&gt; WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">        self.run_right();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Walking,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>Let's refresh our memory on these. Every <strong class="source-inline">state</strong> transition is written as a method on the various typestates – in this case, <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong>, where the source state is <strong class="source-inline">self</strong> and the return value is the destination state. Here, we transition from <strong class="source-inline">Ready</strong> to <strong class="source-inline">Walking</strong> by writing a method called <strong class="source-inline">start_running</strong>.</p>
			<p>The actual <a id="_idIndexMarker762"/>implementation isn't doing much. We start by calling <strong class="source-inline">self.run_right</strong>, which doesn't exist yet, so we have to write it. After sending RHB running, we transition into the <strong class="source-inline">Walking</strong> state by returning a new <strong class="source-inline">WalkTheDogState</strong> instance with <strong class="source-inline">_state</strong> of <strong class="source-inline">Walking</strong>. Take a close look at the function signature for <strong class="source-inline">start_running</strong> and you'll notice it takes <strong class="source-inline">mut state</strong>. This means taking exclusive ownership over <strong class="source-inline">self</strong>, which we can do because we have complete ownership of everything in the state. That is one of the reasons we created <strong class="source-inline">Option&lt;WalkTheDogStateMachine&gt;</strong> originally! However, it's not obvious why we take <strong class="source-inline">mut state</strong> here instead of <strong class="source-inline">state</strong>, in part because <strong class="source-inline">run_right</strong> doesn't exist. When we add our new delegation method, that should become clear, so let's do that right now with the following code:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn run_right(&amp;mut self) {</p>
			<p class="source-code">        self.walk.boy.run_right();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function on <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong> calls <strong class="source-inline">run_right</strong> on <strong class="source-inline">boy</strong> through its walk field. The <strong class="source-inline">run_right</strong> method on <strong class="source-inline">boy</strong> requires a mutable borrow, and that's why we require a mutable borrow on the previous delegate. It's also why we needed to take <strong class="source-inline">mut state</strong> in the <strong class="source-inline">start_running()</strong> method earlier. You can't mutably borrow something that isn't mutable in the first place.</p>
			<p>In order to <a id="_idIndexMarker763"/>keep the code clean, we're doing a little more delegation now than we were earlier. This makes our methods smaller and easier to understand, but the trade-off is that the behavior will be spread across multiple places. I think in the end, this will make our code easier to think about, because we won't have to consider too much code at any one time, so the trade-off is worth it. We'll have to be careful that we don't lose track of any of our original <a id="_idTextAnchor196"/>code as we break it up into chunks and spread it around.</p>
			<h3>Re-implementing draw</h3>
			<p>Now, we've removed all the compiler errors in the original <strong class="source-inline">update</strong> method, in part by removing a large <a id="_idIndexMarker764"/>chunk of its functionality, and we can continue by updating the <strong class="source-inline">Walking</strong> state to ensure that it's working, but I believe that's a long time without any meaningful feedback from the game. After all, at this point, the game doesn't compile and doesn't draw. How do we know anything is working? Let's instead take a moment and update the <strong class="source-inline">Game</strong> <strong class="source-inline">draw</strong> method so that we can actually get the code to compile again and see how it's working.</p>
			<p>The <strong class="source-inline">draw</strong> method will <a id="_idIndexMarker765"/>start by taking a page from the <strong class="source-inline">update</strong> method and replacing its current implementation with a delegation to <strong class="source-inline">WalkTheDogStateMachine</strong>, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        renderer.clear(&amp;Rect::new(Point { x: 0, y: 0 }, </p>
			<p class="source-code">            600, 600));</p>
			<p class="source-code">        if let Some(machine) = &amp;self.machine {</p>
			<p class="source-code">            machine.draw(renderer);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There are two things that are a little different from the changes we made to update. The first is that we only borrow <strong class="source-inline">self.machine</strong> because we don't need mutable access. We also still clear the screen at the top of <strong class="source-inline">draw</strong>. That happens on every state change, so there's <a id="_idIndexMarker766"/>no reason to not just do it then. Besides, it will help us debug if we make any mistakes, since the screen will turn white.</p>
			<p>Let's continue the delegation by adding a <strong class="source-inline">draw</strong> method to <strong class="source-inline">WalkTheDogStateMachine</strong> that can extract the state from each case for drawing, as shown here:</p>
			<p class="source-code">impl WalkTheDogStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDogStateMachine::Ready(state) =&gt; </p>
			<p class="source-code">                state.draw(renderer),</p>
			<p class="source-code">            WalkTheDogStateMachine::Walking(state) =&gt; </p>
			<p class="source-code">                state.draw(renderer),</p>
			<p class="source-code">            WalkTheDogStateMachine::GameOver(state) =&gt; </p>
			<p class="source-code">                state.draw(renderer),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is virtually identical to the <strong class="source-inline">update</strong> method we wrote earlier, except on a borrowed <strong class="source-inline">self</strong> instead of consuming <strong class="source-inline">self</strong>. The rest is just delegations to the various states. Unlike update, every state draws in the exact same way, so we can fill those in with one method, as shown here:</p>
			<p class="source-code">impl&lt;T&gt; WalkTheDogState&lt;T&gt; {</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        self.walk.draw(renderer);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Any state <a id="_idIndexMarker767"/>will delegate <strong class="source-inline">draw</strong> to <strong class="source-inline">Walk</strong> because the drawing doesn't actually change based on state. We can finally go ahead and re-implement the <strong class="source-inline">draw</strong> method, this time on <strong class="source-inline">Walk</strong>, as shown here:</p>
			<p class="source-code">impl Walk {</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        self.backgrounds.iter().for_each(|background| {</p>
			<p class="source-code">            background.draw(renderer);</p>
			<p class="source-code">        });</p>
			<p class="source-code">        self.boy.draw(renderer);</p>
			<p class="source-code">        self.obstacles.iter().for_each(|obstacle| {</p>
			<p class="source-code">            obstacle.draw(renderer);</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>This code is not new, but I don't blame you if you forgot it. It's our old <strong class="source-inline">draw</strong> code from <a href="B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating an Endless Runner</em>, only with the <strong class="source-inline">walk</strong> variable replaced by <strong class="source-inline">self</strong>. The rest is identical.</p>
			<p>At this point, you'll notice something exciting – the code compiles again! But if you look closely at the game, you'll see that it's a little static.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 8.15 – Stand very still…." src="image/Figure_8.15_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Stand very still….</p>
			<p>Red Hat <a id="_idIndexMarker768"/>Boy has stopped animating! He doesn't do his little idle animation because we're not calling <strong class="source-inline">update</strong> like we used to; it's almost time to go back to fixing the <strong class="source-inline">update</strong> method.</p>
			<h3>Refactoring initialize</h3>
			<p>Before we <a id="_idIndexMarker769"/>proceed with restoring functionality, you might remember that I said the creation of <strong class="source-inline">WalkTheDogStateMachine</strong> was "obscured by all the state machine noise." Specifically, it looked like this:</p>
			<p class="source-code">                let machine = WalkTheDogStateMachine</p>
			<p class="source-code">                    ::Ready(WalkTheDogState {</p>
			<p class="source-code">                    _state: Ready,</p>
			<p class="source-code">                    walk: Walk {</p>
			<p>To create <strong class="source-inline">WalkTheDogStateMachine</strong> required creating its <strong class="source-inline">Ready</strong> variant and passing a <strong class="source-inline">WalkTheDog</strong> state with its <strong class="source-inline">_state</strong> variable set to <strong class="source-inline">Ready</strong>. In addition to being noisy, it requires you to remember the correct initial state of the state machine. That's what constructors are for!</p>
			<p>Let's create <a id="_idIndexMarker770"/>a constructor for <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong>, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    fn new(walk: Walk) -&gt; WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Ready,</p>
			<p class="source-code">            walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>This makes it easier to create a new typestate of <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong>; accepting <strong class="source-inline">Walk</strong>, it needs to be valid. Let's also make it easier to create the entire machine, with a smaller constructor:</p>
			<p class="source-code">impl WalkTheDogStateMachine {</p>
			<p class="source-code">    fn new(walk: Walk) -&gt; Self {</p>
			<p class="source-code">        WalkTheDogStat<a id="_idTextAnchor197"/>eMachine</p>
			<p class="source-code">            ::Ready(WalkTheDogState::new(walk))</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>This constructor creates the entire machine with the right state and passes it <strong class="source-inline">Walk</strong>. Now that we've made these helper methods, we can make the change to the original initialize method, making it a little bit easier to read by using the <strong class="source-inline">WalkTheDogStateMachine</strong> constructor:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self.machine {</p>
			<p class="source-code">            None =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                <strong class="bold">let machine = WalkTheDogStateMachine</strong></p>
			<p class="source-code"><strong class="bold">                    ::new(Walk {</strong></p>
			<p class="source-code">                    boy: rhb,</p>
			<p class="source-code">                    ...</p>
			<p>It's a small <a id="_idIndexMarker771"/>change, but makes it both easier to read and safer, too. Doing the right thing, creating <strong class="source-inline">WalkTheDogStateMachine</strong> in the <strong class="source-inline">Ready</strong> state is easy to do, and creating it in the wrong state is not. </p>
			<p>Now that we've finished that little digression, we can go back to finishing the update method as planned.</p>
			<h3>Finishing update</h3>
			<p>This <a id="_idIndexMarker772"/>segment of the <em class="italic">original</em> <strong class="source-inline">update</strong> function in <strong class="source-inline">Game</strong> reveals what is missing from our current code:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            if keystate.is_pressed("ArrowDown") {</p>
			<p class="source-code">                walk.boy.slide();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            <strong class="bold">walk.boy.update();</strong></p>
			<p class="source-code">            ...</p>
			<p>Immediately after all the checks for button presses, we were updating <strong class="source-inline">boy</strong>. Let's go ahead <a id="_idIndexMarker773"/>and add that to our new version of the <strong class="source-inline">update</strong> function in the <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong> implementation, like so:</p>
			<p class="source-code">impl WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">    fn update(<strong class="bold">mut </strong>self, keystate: &amp;KeyState) -&gt; </p>
			<p class="source-code">        ReadyEndState {</p>
			<p class="source-code">        <strong class="bold">self.walk.boy.update();</strong></p>
			<p class="source-code">        if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">            ReadyEndState::Complete(self.start_running())</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            ReadyEndState::Continue(self)</p>
			<p class="source-code">        }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p>There are two changes here, so don't forget to change <strong class="source-inline">update</strong> to accept <strong class="source-inline">mut self</strong> now instead of <strong class="source-inline">self</strong>. It's hiding there in the function signature. Also, we've added a call to <strong class="source-inline">self.walk.boy.update()</strong> to start updating the boy again.</p>
			<p>Do that and you'll see RHB idling again, ready to start chasing down his invisible dog. But if you hit the right arrow, RHB freezes, one frame into his running animation. That is not what we want, and intriguingly, there are no errors in the console log because no exceptions are being thrown. It's just that the <strong class="source-inline">Walking</strong> state doesn't do anything in its <strong class="source-inline">update</strong> function. We can restore that code by putting back some of the code we earlier commented out/copied/deleted into the <strong class="source-inline">Walking</strong> state of the game, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(mut self, keystate: &amp;KeyState) -&gt; </p>
			<p class="source-code">        WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">        if keystate.is_pressed("Space") {</p>
			<p class="source-code">            self.walk.boy.jump();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        if self.walk.timeline &lt; TIMELINE_MINIMUM {</p>
			<p class="source-code">            self.walk.generate_next_segment();</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            self.walk.timeline += <strong class="bold">walking_speed</strong>;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong>, we've modified the <strong class="source-inline">update</strong> method to take a <strong class="source-inline">mut self</strong> and then restored most of the old <strong class="source-inline">Game</strong> <strong class="source-inline">update</strong> code. Rather than showing the entire method, I've just reproduced the beginning and end of the code snippet <a id="_idIndexMarker774"/>and elided the middle; you can safely cut and paste all the original code. There are a few changes to make the code fit its new location. Where the original code would read <strong class="source-inline">walk.boy</strong>, it now reads <strong class="source-inline">self.walk.boy</strong>. I also took the opportunity to rename <strong class="source-inline">velocity</strong>, which is a little vague, to <strong class="source-inline">walking_speed</strong> to clarify that it refers to how fast RHB walks. The final change we've made is taking out the <strong class="source-inline">if keystate.is_pressed("ArrowRight")</strong> code because there's no reason to check for that keypress anymore. Lastly, we return <strong class="source-inline">self</strong> because there's not yet any way to transition out of <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong>. If you do this all correctly, you'll find that your code compiles and runs! In fact, as of this moment, all of the behavior is restored, including the problem where we have to refresh to start a new game. How about we finally add a new game button right now, huh?</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor198"/>Start a new Game </h1>
			<p>If you remember our originally planned behavior, and I don't blame you if you don't, we wanted to <a id="_idIndexMarker775"/>draw a new game button on the screen when RHB crashed and fell over. Then, when it's clicked, we want to start a new game. For that to happen, we'll need to do the following:</p>
			<ol>
				<li>Check whether <strong class="source-inline">RedHatBoyStateMachine</strong> is <strong class="source-inline">KnockedOut</strong>, and if so, transition from <strong class="source-inline">Walking</strong> to <strong class="source-inline">GameOver</strong>.</li>
				<li>On that transition, draw the new game button.</li>
				<li>Add an <strong class="source-inline">onclick</strong> handler so that when the button is clicked, we transition back to <strong class="source-inline">Ready</strong> with a new <strong class="source-inline">Walk</strong> instance.</li>
				<li>On the transition to <strong class="source-inline">Ready</strong>, hide the button and restart the game.</li>
			</ol>
			<p>All the code we wrote before was to make that change easier. Let's see whether we were right about that:</p>
			<ol>
				<li value="1">Transition from <strong class="source-inline">Walking</strong> to <strong class="source-inline">GameOver</strong>.</li>
			</ol>
			<p>To transition from <strong class="source-inline">Walking</strong> to <strong class="source-inline">GameOver</strong>, we need to return the <strong class="source-inline">GameOver</strong> state from the <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong> <strong class="source-inline">update</strong> method, but when should we do that? We'll need to see whether the <em class="italic">boy</em> is knocked out and then make the change. We don't have that capability yet, so we'll need to create it, and let's work top-down, as we have been this entire chapter. First, we'll change the <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong> <strong class="source-inline">update</strong> method to check the non-existing method:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(mut self, keystate: &amp;KeyState) -&gt; </p>
			<p class="source-code">        <strong class="bold">WalkingEndState</strong> {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        if self.walk.timeline &lt; TIMELINE_MINIMUM {</p>
			<p class="source-code">            self.walk.generate_next_segment()</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            self.walk.timeline += walking_speed;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        <strong class="bold">if self.walk.knocked_out() {</strong></p>
			<p class="source-code">            <strong class="bold">WalkingEndState::Complete(self.end_game())</strong></p>
			<p class="source-code">        <strong class="bold">} else {</strong></p>
			<p class="source-code">            <strong class="bold">WalkingEndState::Continue(self)</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, instead <a id="_idIndexMarker776"/>of always returning the <strong class="source-inline">Walking</strong> state, we return <strong class="source-inline">WalkingEndState</strong>, which doesn't exist yet but will mimic the pattern we used in the <strong class="source-inline">update</strong> method on on <strong class="source-inline">WalkTheDogState&lt;Ready&gt;</strong>. When the current state is <strong class="source-inline">knocked_out</strong>, we will return the <strong class="source-inline">Complete</strong> variant holding an instance of the <strong class="source-inline">WalkTheDogState&lt;GameOver&gt;</strong> type. That will be the state returned from the <strong class="source-inline">end_game</strong> transition, which is also not written yet. Otherwise, we'll return <strong class="source-inline">Continue</strong> with the current <strong class="source-inline">WalkTheDogState&lt;Walking&gt;</strong> state as its field. That's two functions that don't exist yet, <strong class="source-inline">knocked_out</strong> and <strong class="source-inline">end_game</strong>, along with a brand-new type. You can create the <strong class="source-inline">WalkingEndState</strong> type and its corresponding <strong class="source-inline">From</strong> trait to convert it into <strong class="source-inline">WalkTheDogStateMachine</strong> right now by following the same pattern we did for <strong class="source-inline">ReadyEndState</strong>. I won't reproduce that code here. We'll proceed from there by getting <strong class="source-inline">knocked_out</strong> working, which <a id="_idIndexMarker777"/>is going to be delegated from <strong class="source-inline">Walk</strong> to <strong class="source-inline">RedHatBoyStateMachine</strong> with some delegations in between:</p>
			<p class="source-code">impl Walk {</p>
			<p class="source-code">    fn knocked_out(&amp;self) -&gt; bool {</p>
			<p class="source-code">        self.boy.knocked_out()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn knocked_out(&amp;self) -&gt; bool {</p>
			<p class="source-code">        self.state_machine.knocked_out()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn knocked_out(&amp;self) -&gt; bool {</p>
			<p class="source-code">        matches!(self, RedHatBoyStateMachine</p>
			<p class="source-code">            ::KnockedOut(_))</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We could pass <strong class="source-inline">WalkTheDogState</strong> to <strong class="source-inline">RedHatBoyStateMachine</strong> here to get the new state and follow the OO guideline of "tell, don't ask", but sometimes, you just want to check a Boolean. Here, we ask the <strong class="source-inline">Walking</strong> state, which asks <strong class="source-inline">RedHatBoy</strong> and finally <strong class="source-inline">RedHatBoyStateMachine</strong> whether it is knocked out. <strong class="source-inline">RedHatBoyStateMachine</strong> uses the handy <strong class="source-inline">matches!</strong> macro to check <strong class="source-inline">self</strong> against an <strong class="source-inline">enum</strong> variant, and return whether or not they match. Now that we can check whether Red Hat Boy is knocked out, we have just one compiler error – <strong class="source-inline">no method named `end_game` found for struct `WalkTheDogState`</strong>. </p>
			<p>It's time <a id="_idIndexMarker778"/>to implement the <strong class="source-inline">end_game</strong> transition method, which will represent our transition. We can start by implementing the transition to do nothing other than move <strong class="source-inline">walk</strong> from <strong class="source-inline">Walking</strong> to <strong class="source-inline">GameOver</strong>, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: GameOver,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>This returns us to a compiled state and means that when RHB crashes and is knocked out, the game is in the <strong class="source-inline">GameOver</strong> state. However, it does nothing, so it's time for <em class="italic">step 2</em> – draw the new game button.</p>
			<ol>
				<li value="2">Draw the new game button.</li>
			</ol>
			<p>Many pages ago, I said: "To show our button programmatically, we can just call <strong class="source-inline">browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;")</strong>." But when do we call it? Well, we call it now, right before creating the new state:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">        <strong class="bold">browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;");</strong>        </p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: GameOver,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>If you add this one line of code to the transition, you'll see the new game button we wrote <a id="_idIndexMarker779"/>way back at the beginning when our RHB crashes into a rock. There's a warning on this line because we don't handle the result of <strong class="source-inline">draw_ui</strong>, which we'll ignore for the moment.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">onclick</strong> handler to the button.</li>
			</ol>
			<p>In order to add the click handler to the button, we need to get a reference to the element we just drew. We don't have that, as the <strong class="source-inline">insert_adjacent_html</strong> function doesn't provide it, so we'll need to find the button we just added to the screen so that we can attach an event handler to it. We've used <strong class="source-inline">get_element_by_id</strong> twice before on <strong class="source-inline">document</strong>, so it's probably time to write a wrapper function in the <strong class="source-inline">browser</strong> module, as shown here:</p>
			<p class="source-code">pub fn find_html_element_by_id(id: &amp;str) -&gt; Result&lt;HtmlElement&gt; {</p>
			<p class="source-code">    document()</p>
			<p class="source-code">        .and_then(|doc| {</p>
			<p class="source-code">            doc.get_element_by_id(id)</p>
			<p class="source-code">                .ok_or_else(|| anyhow!("Element with </p>
			<p class="source-code">                    id {} not found", id))</p>
			<p class="source-code">        })</p>
			<p class="source-code">        .and_then(|element| {</p>
			<p class="source-code">            element</p>
			<p class="source-code">                .dyn_into::&lt;HtmlElement&gt;()</p>
			<p class="source-code">                .map_err(|err| anyhow!("Could not cast </p>
			<p class="source-code">                    into HtmlElement {:#?}", err))</p>
			<p class="source-code">        })</p>
			<p class="source-code">}</p>
			<p>We've made a slight change to the way we've been finding elements in this function. Normally, we want <strong class="source-inline">HtmlElement</strong>, not a generic <strong class="source-inline">Element</strong> type, so in this function, we've <a id="_idIndexMarker780"/>gone ahead and added a call to <strong class="source-inline">dyn_into</strong> to make the conversion. Therefore, this function first gets the document, then gets the element, and finally, converts it into the <strong class="source-inline">HtmlElement</strong> type, all while normalizing the errors with <strong class="source-inline">anyhow!</strong>.</p>
			<p>Now that we have a way to find the element, we can return to the transition in <strong class="source-inline">game</strong>, find the newly added new game button, and then add a click handler to it, as shown in the following code:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">        let receiver = browser::draw_ui("&lt;button id='new_game'&gt;New Game&lt;/button&gt;")</p>
			<p class="source-code">            <strong class="bold">.and_then(|_unit| browser::</strong></p>
			<p class="source-code"><strong class="bold">                find_html_element_by_id("new_game"))</strong></p>
			<p class="source-code">            <strong class="bold">.map(|element| engine::</strong></p>
			<p class="source-code"><strong class="bold">                add_click_handler(element))</strong></p>
			<p class="source-code">            <strong class="bold">.unwrap();</strong></p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: GameOver,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>We've reproduced the entire transition trait here, but there are three changes. The first is <a id="_idIndexMarker781"/>that we've added <strong class="source-inline">id</strong> to the new game button; naturally, that's <strong class="source-inline">new_game</strong>. Then, we find the element in the document in the <strong class="source-inline">and_then</strong> block and use <strong class="source-inline">map</strong> to take that element and pass it to the recently created <strong class="source-inline">add_click_handler</strong> function. Now, we've got a small problem. We will need <strong class="source-inline">receiver</strong> to get click messages when they happen, but the <strong class="source-inline">add_click_handler</strong> function returns <strong class="source-inline">Result</strong> with <strong class="source-inline">UnboundedReceiver</strong>. The challenge is that the <strong class="source-inline">end_game</strong> function doesn't return <strong class="source-inline">Result</strong>. In <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>, we'll investigate how to debug this kind of condition, but for now, we'll just grit our teeth and add <strong class="source-inline">unwrap</strong>.</p>
			<p>Now that we have <strong class="source-inline">receiver</strong> that will get a message whenever the player clicks <strong class="bold">New Game</strong>, we need to do something with it. We'll need to check it in the <strong class="source-inline">update</strong> function for the <strong class="source-inline">GameOver</strong> state and when we receive the event transition to the <strong class="source-inline">Ready</strong> state. That's going to mean adding the receiver to the <strong class="source-inline">GameOver</strong> struct, as follows:</p>
			<p class="source-code">struct GameOver {</p>
			<p class="source-code">    new_game_event: UnboundedReceiver&lt;()&gt;,</p>
			<p class="source-code">}</p>
			<p>This will prompt you to add the <strong class="source-inline">use</strong> declaration for <strong class="source-inline">futures::channel::mpsc::UnboundedReceiver</strong>. Now that <strong class="source-inline">GameOver</strong> <strong class="source-inline">struct</strong> has the <a id="_idIndexMarker782"/>field, we'll need to pass it along in the transition, as shown here:</p>
			<p class="source-code">impl WalkTheDogState&lt;Walking&gt; {</p>
			<p class="source-code">    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">        <strong class="bold">let receiver = </strong>browser::draw_ui("&lt;button </p>
			<p class="source-code"><strong class="bold">            </strong>id=<strong class="bold">'new_game'</strong>&gt;New Game&lt;/button&gt;")</p>
			<p class="source-code">            .and_then(|_unit| browser::</p>
			<p class="source-code">                find_html_element_by_id("new_game"))</p>
			<p class="source-code">            .map(|element| engine::</p>
			<p class="source-code">                add_click_handler(element))</p>
			<p class="source-code">            .unwrap();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: GameOver {</p>
			<p class="source-code">                <strong class="bold">new_game_event: receiver,</strong></p>
			<p class="source-code">            },</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>This is the final change to this method, and it's just adding the field to <strong class="source-inline">GameOver</strong>. Interestingly it's the first time we've added a field to any of our state structures, but it's something you're likely to do more of over time as you extend this game. Various states have data that's unique to them, and they belong in the <strong class="source-inline">state</strong> struct.</p>
			<p>It's time to return to the <strong class="source-inline">WalkTheDogState&lt;GameOver&gt;</strong> implementation and its <strong class="source-inline">update</strong> method, which currently just returns the <strong class="source-inline">GameOver</strong> state, leaving the game in that state forever. Instead, we'll want to check whether the new game event has <a id="_idIndexMarker783"/>happened (because the button was clicked) and then return the <strong class="source-inline">Ready</strong> state to start over again. That small bit of code is reproduced here:</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    fn update(mut self) -&gt; GameOverEndState {</p>
			<p class="source-code">        if self._state.new_game_pressed() {</p>
			<p class="source-code">            GameOverEndState::Complete(self.new_game())</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            GameOverEndState::Continue(self)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">impl GameOver {</p>
			<p class="source-code">    fn new_game_pressed(&amp;mut self) -&gt; bool {</p>
			<p class="source-code">        matches!(self.new_game_event.try_next(), </p>
			<p class="source-code">            Ok(Some(())))       </p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">WalkTheDogState&lt;GameOver&gt;</strong> implementation, we check the state to see whether the new game button has been pressed, and if it has, we return the <strong class="source-inline">GameOverEndState::Complete</strong> variant; otherwise, we return the <strong class="source-inline">GameOverEndState::Continue</strong> variant. This is the same pattern we've used in every other update method, and you can go ahead and reproduce the <strong class="source-inline">GameOverEndState</strong> enum and its corresponding <strong class="source-inline">From</strong> trait to convert the type to a <strong class="source-inline">WalkTheDogStateMachine</strong> enum. That code is not reproduced here, but remember that if you get stuck, you can find the sample code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a>. </p>
			<p>In the <strong class="source-inline">GameOver</strong> implementation, we have the details to check whether <strong class="source-inline">new_game_event</strong>, corresponding to the player's click, has happened. Calling <strong class="source-inline">try_next</strong> will return <strong class="source-inline">Result</strong> immediately, without blocking, or <strong class="source-inline">Ok</strong> if the channel is still open, regardless of whether anything is in it. Remember that we are running at 60 frames per second and cannot use the blocking calls. Finally, we use the handy matches! macro to check whether the channel was successfully sent a message of <strong class="source-inline">unit</strong>, or Ok(Some(())). If the event is there, <strong class="bold">New Game</strong> has been pressed, and the function returns <strong class="source-inline">true</strong>. </p>
			<p>This code <a id="_idIndexMarker784"/>doesn't compile because we don't have a transition written from <strong class="source-inline">GameOver</strong> to <strong class="source-inline">Ready</strong>, which is what we'll write in the next step.</p>
			<ol>
				<li value="4">Restart the game on <strong class="bold">New Game</strong>.</li>
			</ol>
			<p>Restarting the game will mean doing two things on the <strong class="source-inline">new_game</strong> transition. The first is hiding the button or "UI," and the second is recreating <strong class="source-inline">Walk</strong> from scratch. The first is actually easier, so we'll start with that:</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        browser::hide_ui();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Ready,</p>
			<p class="source-code">            walk: self.walk,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is another transition, this time from <strong class="source-inline">GameOver</strong> to <strong class="source-inline">Ready</strong>, with the side effect of <a id="_idIndexMarker785"/>hiding the UI. It then moves to a new state with the same walk we ended with, which is not quite what we want.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer102">
					<img alt="Figure 8.16 – I hit New Game – run, boy, run!" src="image/Figure_8.16_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – I hit New Game – run, boy, run!</p>
			<p>The button is hidden but RHB is still knocked out. Moving from <strong class="source-inline">GameOver</strong> to <strong class="source-inline">Ready</strong> means creating a new <strong class="source-inline">Walk</strong> instance from the old one, so the game starts over. This is a bit of a challenge because we no longer have access to the various images and sprite sheets we used to create <strong class="source-inline">Walk</strong> and <strong class="source-inline">RedHatBoy</strong> in the first place. What we'll do is clone those from an existing one, via a constructor function on the <strong class="source-inline">Walk</strong> implementation. We won't call this <strong class="source-inline">clone</strong> because that term means <a id="_idIndexMarker786"/>an identical copy, whereas this is really a reset. You can see the implementation here:</p>
			<p class="source-code">impl Walk {</p>
			<p class="source-code">    fn reset(walk: Self) -&gt; Self {</p>
			<p class="source-code">        let starting_obstacles =</p>
			<p class="source-code">            stone_and_platform(walk.stone.clone(), </p>
			<p class="source-code">                walk.obstacle_sheet.clone(), 0);</p>
			<p class="source-code">        let timeline = rightmost(&amp;starting_obstacles);</p>
			<p class="source-code">        Walk {</p>
			<p class="source-code">            boy: walk.boy,</p>
			<p class="source-code">            backgrounds: walk.backgrounds,</p>
			<p class="source-code">            obstacles: starting_obstacles,</p>
			<p class="source-code">            obstacle_sheet: walk.obstacle_sheet,</p>
			<p class="source-code">            stone: walk.stone,</p>
			<p class="source-code">            timeline,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">reset</strong> function consumes <strong class="source-inline">Walk</strong> and returns a new one. It recreates <strong class="source-inline">starting_obstacles</strong> the same way they are created in <strong class="source-inline">initialize</strong>, and then recalculates <strong class="source-inline">timeline</strong>. Then, it constructs a new <strong class="source-inline">Walk</strong>, moving all the values from <strong class="source-inline">Walk</strong> except <strong class="source-inline">starting_obstacles</strong> and <strong class="source-inline">timeline</strong>. This function is not quite right though, as it will reset <strong class="source-inline">Walk</strong> but leave <strong class="source-inline">boy</strong> in its <strong class="source-inline">KnockedOut</strong> state. We'll need a similar <strong class="source-inline">reset</strong> function for <strong class="source-inline">boy</strong>, as shown here:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn reset(boy: Self) -&gt; Self {</p>
			<p class="source-code">        RedHatBoy::new(</p>
			<p class="source-code">            boy.sprite_sheet,</p>
			<p class="source-code">            boy.image,</p>
			<p class="source-code">            boy.state_machine.context().audio.clone(),</p>
			<p class="source-code">            boy.state_machine.context().jump_sound.clone(),</p>
			<p class="source-code">        )</p>
			<p class="source-code">    }</p>
			<p>Writing <strong class="source-inline">reset</strong> on <strong class="source-inline">RedHatBoy</strong> is a lot easier than it was on <strong class="source-inline">Walk</strong> because we created a constructor function, <strong class="source-inline">new</strong>, for <strong class="source-inline">RedHatBoy</strong> a long time ago. We should do <a id="_idIndexMarker787"/>the same for <strong class="source-inline">Walk</strong>, but that refactoring is up to you. Keep in mind that for this to compile, the <strong class="source-inline">audio</strong> and <strong class="source-inline">jump_sound</strong> fields on <strong class="source-inline">RedHatBoyContext</strong> need to be public. </p>
			<p>Now that we have a <strong class="source-inline">reset</strong> function for <strong class="source-inline">RedHatBoy</strong>, we can use it in the <strong class="source-inline">Walk</strong> <strong class="source-inline">reset</strong> function, like so:</p>
			<p class="source-code">impl Walk {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn reset(walk: Self) -&gt; Self {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        Walk {</p>
			<p class="source-code">            boy: RedHatBoy::reset(walk.boy),</p>
			<p class="source-code">            ...</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We also need to call this in the original transition from <strong class="source-inline">GameOver</strong> to <strong class="source-inline">Ready</strong>, as follows:</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        browser::hide_ui();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Ready,</p>
			<p class="source-code">            walk: Walk::reset(self.walk),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you <a id="_idIndexMarker788"/>do all that, you'll find that when you click the new game button, the game resets and the player is back at the start. You should be able to hit the right arrow key and start walking again. You <em class="italic">should</em>, but it doesn't work because we haven't accounted for one feature of the UI – the focus.</p>
			<ol>
				<li value="5">Focus!</li>
			</ol>
			<p>It turns out there's one more thing to do when we click the new game button to make the game ready to play again. When the game was started, we set up the canvas to have the focus so that it would receive keyboard input. We did this with the <strong class="source-inline">tabIndex</strong> field in the original HTML. When the player clicks <strong class="bold">New Game</strong>, they transfer the focus to the button and then hide the button, which means nothing will get the keyboard events we are listening to. You can see this effect by clicking <strong class="bold">New Game</strong> and then clicking the canvas after the button disappears. If you click the canvas, it regains the focus, and you can play the game again.</p>
			<p>We can transfer the focus back to the canvas automatically in the <strong class="source-inline">hide_ui</strong> function of the <strong class="source-inline">browser</strong> module. It's debatable whether it belongs here, since you may <a id="_idIndexMarker789"/>have cases where you want to hide the UI but not reset the focus, but our game doesn't have that case, so I think we're safe. This change is here:</p>
			<p class="source-code">pub fn hide_ui() -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    let ui = find_ui()?;</p>
			<p class="source-code">    if let Some(child) = ui.first_child() {</p>
			<p class="source-code">        ui.remove_child(&amp;child)</p>
			<p class="source-code">            .map(|_removed_child| ())</p>
			<p class="source-code">            .map_err(|err| anyhow!("Failed to remove </p>
			<p class="source-code">                child {:#?}", err))</p>
			<p class="source-code">            <strong class="bold">.and_then(|_unit| {</strong></p>
			<p class="source-code">                <strong class="bold">canvas()?</strong></p>
			<p class="source-code">                    <strong class="bold">.focus()</strong></p>
			<p class="source-code">                    <strong class="bold">.map_err(|err| anyhow!("Could not </strong></p>
			<p class="source-code"><strong class="bold">                        set focus to canvas! </strong></p>
			<p class="source-code"><strong class="bold">                            {:#?}", err))</strong></p>
			<p class="source-code">            })</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>After the first call to <strong class="source-inline">map_err</strong> for removing the child, we've added a second <strong class="source-inline">and_then</strong> call, which takes <strong class="source-inline">unit</strong> from the earlier <strong class="source-inline">map</strong> call, promptly ignores it, and then <a id="_idIndexMarker790"/>requests <strong class="source-inline">focus</strong> on <strong class="source-inline">canvas</strong>. The error from the <strong class="source-inline">focus</strong> call doesn't return an <strong class="source-inline">anyhow!</strong> type, so the compiler complains, and we fix that with a <strong class="source-inline">map_err</strong> call. The <strong class="source-inline">focus</strong> function is a JavaScript function we call through <strong class="source-inline">web-sys</strong>, which is documented on the MDN (<a href="https://mzl.la/30YGOMm">https://mzl.la/30YGOMm</a>).</p>
			<p>With that change, you can click <strong class="bold">New Game</strong> and start another try. We did it!</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor199"/>Pre-loading</h2>
			<p>You might notice that the button visibly loads when it shows up on screen – that is to say that <a id="_idIndexMarker791"/>the image and font aren't downloaded to the browser yet, so it doesn't appear instantaneously. This is standard behavior for web browsers. In order to make sure that you don't have to wait for an entire page worth of images, fonts, and other assets to load before you see a page, browsers will load assets lazily. This is so common that your eyes may not have noticed it when the <strong class="bold">New Game</strong> button appeared, but it doesn't look right in an interactive application. Fortunately, there's a quick way we can fix it. We can tell the browser to preload the <strong class="source-inline">Button.svg</strong> and the <strong class="source-inline">kenney_future_narrow-webfont.woff2</strong> assets immediately when the page is loaded so that when the button appears, it's instantaneous. Open the <strong class="source-inline">index.html</strong> file and make the changes shown here:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">  &lt;meta charset="UTF-8"&gt;</p>
			<p class="source-code">  &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;</p>
			<p class="source-code">  &lt;link rel="stylesheet" href="styles.css" type="text/css" </p>
			<p class="source-code">      media=</p>
			<p class="source-code">  "screen"&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;link rel="preload" as="image" href="Button.svg"&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;link rel="preload" as="font" href=</strong></p>
			<p class="source-code"><strong class="bold">  "kenney_future_narrow-webfont.woff2"&gt;</strong></p>
			<p class="source-code">&lt;/head&gt;</p>
			<p>The <strong class="source-inline">link</strong> tag with the <strong class="source-inline">preload</strong> attribute will preload assets before rendering the page. You'll want to minimize this behavior generally because you don't want the user to have to <a id="_idIndexMarker792"/>wait a very long time with a blank screen, and if you were to make a very large game with many assets, you should probably use a more flexible solution in code with a loading screen. Our game is small right now, so this works pe<a id="_idTextAnchor200"/>rfectly well. With this change, the new game button not only appears but is snappy.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor201"/>Summary</h1>
			<p>You can look at the end of this chapter in two ways. The first might be to say, "All that for a button?", and you would have a point. After all, our UI is only one new game button, and while that's true, we actually covered quite a bit. We have integrated the DOM into our app via <strong class="source-inline">web-sys</strong> and have, in turn, adjusted our game to handle it. By utilizing the DOM, we were able to leverage the browser for behavior such as clicks and hovers, without having to detect where within the canvas the mouse was and creating clickable areas. You can now create far more complex UIs using tools such as CSS Grid and Flexbox, so if you are familiar with web development, which you've been doing for this entire book, so you are, you'll be able to make quality UIs for your games. If you're looking for some place to start, try adding a score to this game. You can increment the score in the update, and show it at the end menu, or at the right corner during the game, or both! I look forward to seeing it.</p>
			<p>With that, we will move on from new feature development to making sure that our current features work, and work fast. It's now time to start doing some testing and debugging, so we'll dive into that in the next chapter.</p>
		</div>
	</body></html>