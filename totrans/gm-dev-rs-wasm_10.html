<html><head></head><body>
		<div><h1 id="_idParaDest-122"><em class="italic"><a id="_idTextAnchor185"/>Chapter 8</em>: Adding a UI</h1>
			<p>It may appear that we've developed everything we need for a video game, and to some extent, we have, except for that annoyance where we need to hit refresh every time little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) hits a rock. A real game has buttons for a "new game" or "high scores", and in this chapter, we'll be adding that UI. To do so may seem trivial, but event-driven UIs that you might be familiar with from web development are an odd fit with our game loop. To add a simple button, we'll need to make significant changes to our application and even write a little HTML.</p>
			<p>In this chapter, you'll do the following:</p>
			<ul>
				<li>Design a new game button</li>
				<li>Show the button on game over</li>
				<li>Start a new game</li>
			</ul>
			<p>At the end of the chapter, you'll have the framework in place for a more full-featured UI and the skills to make it work.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor186"/>Technical requirements</h1>
			<p>You'll need a few more assets, this time from the <code>ui</code> directory in the <code>assets</code> download at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. The font is Kenny Future Narrow from <a href="https://www.kenney.nl">https://www.kenney.nl</a>. The button is from <a href="https://www.gameart2d.com/">https://www.gameart2d.com/</a>. Both are CC0-licensed. As before, the final code for this chapter is available on the corresponding branch at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3DrEeNO">https://bit.ly/3DrEeNO</a></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor187"/>Design a new game button</h1>
			<p>When RHB <a id="_idIndexMarker693"/>crashes into a rock, he falls over and… well, let's say he takes a nap. Unfortunately, at that point, the player has to refresh the page to start a new game. In most games, we'd see a series of buttons for a new game and high scores. For now, we'll just put in a new game button that will restart from the beginning. This might seem like a simple task, but in fact, we'll have quite a bit to do.</p>
			<p>First, we need to decide how we want to implement the button. We really have two choices. We can create a button in the engine, which would be a sprite that is rendered to the canvas, the same as everything else, or we can use an HTML button and position it over the canvas. The first option will look right and won't require any traditional web programming, but it <a id="_idIndexMarker694"/>will also require us to detect mouse clicks and handle a button-click animation. In other words, we'd have to implement a button. That's more than we want to implement to get our game working, so we're going to use a traditional HTML button and make it <em class="italic">look</em> like it's a game element.</p>
			<p>So, we're going to write some HTML and CSS, which we can use to make the button look like it's a part of the game engine. Then, we'll add the button to the screen with Rust and handle the click event. That will be the tough part.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor188"/>Preparing a UI </h2>
			<p>Conceptually, our UI will work like a HUD in a FPS or where a button is superimposed over the front <a id="_idIndexMarker695"/>of a game itself. Imagine that there is a perfectly clear pane of glass on top of the game, and the button is a sticker that's stuck to it. This means, in the context of a web page, that we need a div that is the same size and in the same place as the canvas.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This isn't a book on HTML or CSS, so I'm not going to spend much time covering it, other than the canvas we've been using throughout. If web development isn't your forte, don't worry – a quick scan of <a href="https://learnxinyminutes.com/docs/html/">https://learnxinyminutes.com/docs/html/</a> will cover more than enough. We'll also be using a little bit of CSS in this section, and you can get a similar cheat sheet for that syntax at <a href="https://learnxinyminutes.com/docs/css/">https://learnxinyminutes.com/docs/css/</a>.</p>
			<p>We can start rather quickly by updating <code>index.html</code> to have the required div, as follows:</p>
			<pre>&lt;body&gt;
<strong class="bold">  &lt;div id="ui" style="position: absolute"&gt;&lt;/div&gt;</strong>
  &lt;canvas id="canvas" tabindex="0" height="600" width="600"&gt;
    Your browser does not support the Canvas.
  &lt;/canvas&gt;
  &lt;script src="img/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>Note that the <code>ui</code> div is <code>position: absolute</code> so that it doesn't "push" the <code>canvas</code> element below it. You <a id="_idIndexMarker696"/>can see how this will work by putting a standard HTML button in the <code>div</code> element, as follows:</p>
			<pre>&lt;div id="ui" style="position: absolute"&gt;
<strong class="bold">  &lt;button&gt;New Game&lt;/button&gt;</strong>
&lt;/div&gt;</pre>
			<p>This will produce a screen that looks like the following:</p>
			<div><div><img alt="Figure 8.1 – A New Game button!" src="img/Figure_8.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A New Game button!</p>
			<p>It won't respond very well if you completely shrink the screen horizontally, but the game won't work in that situation, so it should be fine. Now that we have a button, we'll need to make it look like a game element, and for that, we'll need styling. Go ahead and create a file named <code>styles.css</code> in the <code>static</code> directory, and add a link to it in <code>index.html</code>, as follows:</p>
			<pre>&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;
<strong class="bold">    &lt;link rel="stylesheet" href="styles.css" type="text/css" </strong>
<strong class="bold">      media="screen"&gt;</strong>
&lt;/head&gt;</pre>
			<p>Of course, a link <a id="_idIndexMarker697"/>to an empty file doesn't do much for us. To prove the link is working, go ahead and change the <code>index.html</code> file slightly, removing the inline style on the <code>ui</code> div so that it looks like <code>&lt;div id="ui"&gt;</code>. This will cause the button to push the canvas element down, and your game will likely be slightly off:</p>
			<div><div><img alt="Figure 8.2 – New Game on top" src="img/Figure_8.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – New Game on top</p>
			<p>Now, in the CSS file, you'll want to add a style for that div. It's not really important that this style isn't an inline one, except that this handily checks that our CSS file is being loaded. In the CSS file, insert the following:</p>
			<pre>#ui {
    position: absolute;
}</pre>
			<p>This is a CSS selector for any elements with the <code>ui</code> ID and sets their position to <code>absolute</code>. If your CSS file is being loaded, then the new game button should be over the top of the canvas again. Later, we'll programmatically add that button in our game code, but for now, we just want it to show up and look right. We'll want to give it a font that looks like <a id="_idIndexMarker698"/>a video game, and a background too. Let's start with the font. In your assets, you'll see there is a directory called <code>ui</code>, which contains a file named <code>kenney_future_narrow-webfont.woff2</code>. <strong class="bold">WOFF</strong> stands for <strong class="bold">Web Open Font Format</strong> and is <a id="_idIndexMarker699"/>a font format that will work in every modern browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you're unsure whether a feature will work with a browser, and sometimes when you are sure, check <a href="https://caniuse.com/">https://caniuse.com/</a> to double-check. For WOFF files, you can see the results here: <a href="https://caniuse.com/?search=woff">https://caniuse.com/?search=woff</a>.</p>
			<p>Copy <code>kenney_future_narrow-webfont.woff2</code> into the <code>static</code> directory in your application so that it gets picked up by the build process. Then, you need to specify <code>@font-face</code> in CSS so that elements can be rendered in it, which looks like so:</p>
			<pre>@font-face {
  font-family: 'Ken Future';
  src: url('kenney_future_narrow-webfont.woff2');
}</pre>
			<p>What we've done here is load a new font face with the simple name '<code>Ken Future</code>' so that we can reference it in other styles, and loaded it via the specified URL. Now, we can change all buttons to use that font with this additional CSS:</p>
			<pre>button {
    font-family: 'Ken Future';
}</pre>
			<p>Now, you should see the button being rendered with a font that looks more like a game, as shown here:</p>
			<div><div><img alt="Figure 8.3 – New Game with the Kenney Future Font" src="img/Figure_8.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – New Game with the Kenney Future Font</p>
			<p>The button <a id="_idIndexMarker700"/>still looks a lot like an HTML button because of that traditional web background. To make it look more like a game button, we'll use a background and CSS Sprites to create a pretty button with rounded corners and hover colors.</p>
			<h3>CSS Sprites </h3>
			<p>As a game developer, you already know what a sprite is; you haven't forgotten <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, already, have you? In the case of <strong class="bold">CSS Sprites</strong>, the term as commonly used <a id="_idIndexMarker701"/>is a bit of a misnomer, as instead of referring to a sprite, it really refers to a sprite sheet.</p>
			<p>Conceptually, CSS Sprites work the same way as rendering them with the canvas. You slice out a chunk of a larger sprite and only render that portion. We'll just do the entire thing in CSS instead of Rust. Since we're using CSS, we can change the background when the mouse is over the button and when it is clicked. This will make the button look correct, and we won't have to write Rust code to have the same effect. Clicking a button is something a browser is very good at, so we'll leverage it.</p>
			<p>We'll use the <code>Button.svg</code> file from the <code>ui</code> directory in the downloaded assets, so you can copy that file to the <code>static</code> directory in your game's project. The SVG file actually contains an entire library of buttons, which looks like this:</p>
			<div><div><img alt="Figure 8.4 – The top of Button.svg" src="img/Figure_8.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The top of Button.svg</p>
			<p>We'll want to <a id="_idIndexMarker702"/>slice out the wide blue, green, and yellow buttons to be the background for the button in various states. We'll start by using the <code>background</code> attribute in CSS to set the button's background to the SVG file. You'll update the style as follows:</p>
			<pre>button {
    font-family: 'Ken Future';
   <strong class="bold"> background: -72px -60px url('Button.svg');</strong>
}</pre>
			<p>The pixel values in <code>background</code>, <code>-72px</code> and <code>-60px</code>, mean taking the background and shifting it <code>72</code> pixels to the left and <code>60</code> pixels upward to line it up with the blank blue button. You can get those <a id="_idIndexMarker703"/>values in a vector graphics editor such as <code>url</code> value specifies which file to load. Make those changes, and you'll see the button change to have a new background… well, sort of.</p>
			<div><div><img alt="Figure 8.5 – The button, but with a cut-off background" src="img/Figure_8.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The button, but with a cut-off background</p>
			<p>As you can see, the background is cut off, so you only get half of it, and the button itself still has some of the effects of a default HTML button. We can get rid of those effects with a little more CSS to remove the border and resize the button to match the background, as shown here:</p>
			<pre>button {
    font-family: 'Ken Future';
    background: -72px -60px url('Button.svg');
    <strong class="bold">border: none;</strong>
    <strong class="bold">width: 82px;</strong>
    <strong class="bold">height: 33px;</strong>
}</pre>
			<p>The <code>width</code> and <code>height</code> values were plucked from *Inkscape~ again, and that will set the button to be the same size as the button background in the source. As with the sprite sheets we <a id="_idIndexMarker704"/>used earlier, we need to cut out a slice from the original source, so in this case, there is a rectangle starting at <code>(72, 60)</code> with a width and height of <code>82x33</code>. With those changes, the button now looks like a game button instead of a web button.</p>
			<div><div><img alt="Figure 8.6 – A New Game button&#13;&#10;" src="img/Figure_8.6_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – A New Game button</p>
			<p>There are still a few problems. The button now doesn't visually interact with the user, so it just looks like a picture when you click it. We can address that with CSS pseudo-classes for <code>#active</code> and <code>#hover</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some browsers, notably Firefox, will render <strong class="bold">New Game</strong> on one line instead of two.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more <a id="_idIndexMarker705"/>information on pseudo-classes, check the Mozilla documentation here: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes</a>.</p>
			<p>In each pseudo-class, we'll change the background attribute to line up with another background. Again, the numbers were pulled out of Inkscape, with a little tweaking once they were added <a id="_idIndexMarker706"/>to make sure that they lined up. First, we can handle the <code>hover</code> style, which is when the mouse is over the image.</p>
			<p>That produces a hover button that looks like this:</p>
			<pre>button:hover {
    background: -158px -60px url('Button.svg');
}</pre>
			<div><div><img alt="Figure 8.7 – Hover&#13;&#10;" src="img/Figure_8.7_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Hover</p>
			<p>Then, we'll add the <code>active</code> style, which is what the mouse will look like when clicked:</p>
			<pre>button:active {
    background: -244px -60px url('Button.svg');
}</pre>
			<p>That produces a clicked button like this:</p>
			<div><div><img alt="Figure 8.8 – Active" src="img/Figure_8.8_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Active</p>
			<p>The final issue is that our button is really small, for a game anyway, and is positioned at the upper-left corner. Making the button larger the traditional CSS way with width and height is problematic, as shown here when we change the width value:</p>
			<div><div><img alt="Figure 8.9 – That is not a button" src="img/Figure_8.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – That is not a button</p>
			<p>Changing the <a id="_idIndexMarker707"/>width or height will mean changing the "slice" that we're taking from the sprite sheet, so we don't want that. What we'll use instead is the CSS <code>translate</code> property, with the <code>scale</code> function, which looks like so:</p>
			<pre>button {
    font-family: 'Ken Future';
    background: -72px -60px url('Button.svg');
    border: none;
    width: 82px;
    height: 33px;
    <strong class="bold">transform: scale(1.8);</strong>
}</pre>
			<p>This gives us a nice large button with the right background, but it's not in the right spot.</p>
			<div><div><img alt="Figure 8.10 – The button with the left side cut off" src="img/Figure_8.10_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – The button with the left side cut off</p>
			<p>Now that the button is large and looks like a game button, we just need to put it in the right spot. You can <a id="_idIndexMarker708"/>do that by adding <code>translate</code> to the <code>transform</code> property, where <code>translate</code> is a fancy way of saying <code>move</code>. You can see that as follows:</p>
			<pre>button {
    font-family: 'Ken Future';
    background: -72px -60px url('Button.svg');
    border: none;
    width: 82px;
    height: 33px;
    transform: scale(1.8)<strong class="bold"> translate(150px, 100px);</strong>
}</pre>
			<p>This will get the new game button into, roughly, the center of the screen.</p>
			<div><div><img alt="Figure 8.11 – A New Game button!&#13;&#10;" src="img/Figure_8.11_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – A New Game button!</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Centering a <a id="_idIndexMarker709"/>button in a div requires a little more CSS than I want to cover in this book. Since we're positioning things manually, we can go with "good enough" for now. If you're more comfortable with web development, feel free to make it truly perfectly centered. If you're interested in getting the perfect center with Flexbox, take a look here: <a href="https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989">https://webdesign.tutsplus.com/tutorials/how-to-create-perfectly-centered-text-with-flexbox--cms-27989</a>.</p>
			<p>The new game button now shows up, but it doesn't do anything because our code isn't doing anything with <code>onclick</code>. It's just a floating button, taunting us with its ineffectiveness. Go ahead and remove the <code>button</code> element from <code>index.html</code>, but keep <code>div</code> with the <code>ui</code> ID. Instead, we'll use Rust to dynamically add and remove the button when <a id="_idIndexMarker710"/>we need it and actually handle the clicks. For that, we'll want to make some additions to our <code>browser</code> and <code>engine</code> modules, so let's d<a id="_idTextAnchor189"/>ig in.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor190"/>Showing the button with Rust</h2>
			<p>We've written HTML to show the button and it looks pretty good, but we'll actually need to show it <a id="_idIndexMarker711"/>and hide it on command. This means interacting with the browser and using the <code>browser</code> module. We haven't done this in <a id="_idIndexMarker712"/>a while, so let's refresh our memory on how we translate from the JavaScript we'd write traditionally to the Rust with <code>web-sys</code> that we'll be using. First, we'll need code to insert the button into the <code>ui</code> div. There are lots of ways to do this; we'll use <code>insertAdjacentHTML</code> so that we can just send a string from our code to the screen. In JavaScript, that looks like this:</p>
			<pre>let ui = document.getElementById("ui");
ui.insertAdjacentHTML("afterbegin", "&lt;button&gt;New Game&lt;/button&gt;");</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can <a id="_idIndexMarker713"/>find the docs for this function at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML">https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML</a>. When it comes to looking up browser <a id="_idIndexMarker714"/>APIs, the <strong class="bold">Mozilla Developer Network</strong> (<strong class="bold">MDN</strong>) is your friend.</p>
			<p>We spent a lot of time translating this kind of code into Rust in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, and <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, but let's refresh our memory and appease any monsters who read books out of order. Any JavaScript function or method is likely to be found in the <code>web-sys</code> crate with the name converted from PascalCase to snake_case, and with most of the functions returning <code>Option</code>. Frequently, you can just try that out, and it will work. Let's create a new function in <code>browser</code> and see whether that's the case, as shown here:</p>
			<pre>pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {
    document()
        .and_then(|doc| {
            doc.get_element_by_id("ui")
                .ok_or_else(|| anyhow!("UI element not found"))
        })
        .and_then(|ui| {
            ui.insert_adjacent_html("afterbegin", html)
                .map_err(|err| anyhow!("Could not insert 
                    html {:#?}", err))
        })
}</pre>
			<p>This <code>draw_ui</code> function assumes there is a div with the <code>ui</code> ID, just as the <code>canvas</code> function assumes an ID of <code>canvas</code>. This means it's not <em class="italic">incredibly</em> generic, but we don't need a <a id="_idIndexMarker715"/>more complex solution right now. If we do later, we'll write more functions. As always, we don't want to go too far with some idea of "perfect" code because we've got a game to finish.</p>
			<p>Once again, the Rust <a id="_idIndexMarker716"/>version of the code is much longer, using <code>and_then</code> and mapping errors to make sure we handle the error cases instead of just crashing or halting the program as JavaScript would. This is another case where code is aesthetically less pleasing in Rust but, in my opinion, better because it highlights the possible causes of an error. The other function we'll need right away is used to hide the <code>ui</code> element, which looks like this in JavaScript:</p>
			<pre>let ui = document.getElementById("ui");
let firstChild = ui.firstChild;
ui.removeChild(firstChild);</pre>
			<p>This function grabs the first child of the <code>ui</code> div and removes it with the <code>removeChild</code> method. To be completely thorough, we should loop through all the <code>ui</code> children and make sure they all get removed, but we don't do that here because we already know there's only one. We also remove the children (and don't just set their visibility to hidden) so that they do not affect the layout, and any event listeners are removed. Once again, you'll want to translate JavaScript to Rust. In this case, <code>firstChild</code> becomes the <code>first_child()</code> method and <code>removeChild</code> becomes <code>remove_child</code>, as shown here:</p>
			<pre>pub fn hide_ui() -&gt; Result&lt;()&gt; {
    let ui = document().and_then(|doc| {
        doc.get_element_by_id("ui")
            .ok_or_else(|| anyhow!("UI element not found"))
    })?;
    if let Some(child) = ui.first_child() {
        ui.remove_child(&amp;child)
            .map(|_removed_child| ())
            .map_err(|err| anyhow!("Failed to remove child 
                {:#?}", err))
    } else {
        Ok(())
    }
}</pre>
			<p>This function <a id="_idIndexMarker717"/>is a little different than <code>draw_ui</code>, in part <a id="_idIndexMarker718"/>because <code>first_child</code> being missing isn't an error; it just means you called <code>hide_ui</code> on an empty UI, and we don't want that to error. That's why we use the <code>if let</code> construct and just return an <code>Ok(())</code> explicitly if it isn't present. The <code>ui</code> div was already empty, so it's fine. In addition, there's that weird call to <code>map(|_removed_child| ())</code>, which we call because <code>remove_child</code> returns the <code>Element</code> being removed. We don't care about it here, so we are, once again, explicitly mapping it to our expected value of unit. Finally, of course, we address the error with <code>anyhow!</code>.</p>
			<p>This function <a id="_idIndexMarker719"/>reveals some duplication, so let's go ahead <a id="_idIndexMarker720"/>and refactor it out in the final version, as follows:</p>
			<pre>pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {
    <strong class="bold">find_ui()?</strong>
        .insert_adjacent_html("afterbegin", html)
        .map_err(|err| anyhow!("Could not insert html 
            {:#?}", err))
}
pub fn hide_ui() -&gt; Result&lt;()&gt; {
    <strong class="bold">let ui = find_ui()?;</strong>
    if let Some(child) = ui.first_child() {
        ui.remove_child(&amp;child)
            .map(|_removed_child| ())
            .map_err(|err| anyhow!("Failed to remove child 
                {:#?}", err))
    } else {
        Ok(())
    }
}
fn find_ui() -&gt; Result&lt;Element&gt; {
    document().and_then(|doc| {
        doc.get_element_by_id("ui")
            .ok_or_else(|| anyhow!("UI element not found"))
    })
}</pre>
			<p>Here, we've replaced both of the repetitive <code>document().and_then</code> calls with calls to <code>find_ui</code>, which is a private function that ensures we always get the same error when UI isn't found. It streamlines a little bit of code and makes it possible to use the <code>try</code> operator in <code>draw_ui</code>. The <code>find_ui</code> function returns <code>Element</code>, so you need to make sure to import <code>web_sys::Element</code>.</p>
			<p>We've got the tools we need to draw the button set up in <code>browser</code>. To show our button programmatically, we can just call <code>browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;")</code>. That's great, but we can't actually handle doing anything on the button click yet. We have two choices. The first is to create the button with an <code>onclick</code> handler such as <code>browser::draw_ui("&lt;button onclick='myfunc'&gt;New Game&lt;/button&gt;")</code>. This will require taking a function in our Rust <a id="_idIndexMarker721"/>package and exposing it to the browser. It <a id="_idIndexMarker722"/>would also require some sort of global variable that the function could operate on. If <code>myfunc</code> is going to operate on the game state, then it needs access to the game state. We could use something such as an event queue here, and that's a viable approach, but it's not what we'll be doing.</p>
			<p>What we're going to do instead is set the <code>onclick</code> variable in Rust code, via the <code>web-sys</code> library, to a closure that writes to a channel. Other code can listen to this channel and see whether a click event has happened. This code will be very similar to the code we wrote in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, for handling keyboard input. We'll start with a function in the <code>engine</code> module that takes <code>HtmlElement</code> and returns <code>UnboundedReceiver</code>, as shown here:</p>
			<pre>pub fn add_click_handler(elem: HtmlElement) -&gt; UnboundedReceiver&lt;()&gt; {
    let (click_sender, click_receiver) = unbounded();
    click_receiver
}</pre>
			<p>Don't forget to bring <code>HtmlElement</code> into scope with <code>use web_sys::HtmlElement</code>. This doesn't do much, and it sure doesn't seem to have anything to do with a click, and it's not obvious why we need an <code>UnboundedReceiver</code>. When we add a click handler to the button, we don't want to have to move anything about the game <em class="italic">into</em> the closure. Using a channel here lets us encapsulate the handling of the click and separate it from the reacting to click event. Let's continue by creating the <code>on_click</code> handler, as shown here:</p>
			<pre>pub fn add_click_handler(elem: HtmlElement) -&gt; 
    UnboundedReceiver&lt;()&gt; {
    let (<strong class="bold">mut </strong>click_sender, click_receiver) = unbounded();
    <strong class="bold">let on_click = browser::closure_wrap(Box::new(move || {</strong>
        <strong class="bold">click_sender.start_send(());</strong>
    <strong class="bold">}) as Box&lt;dyn FnMut()&gt;);</strong>
    click_receiver
}</pre>
			<p>The changes we've made are to make <code>click_sender</code> mutable and then move it into the newly <a id="_idIndexMarker723"/>created closure called <code>on_click</code>. You may <a id="_idIndexMarker724"/>remember <code>closure_wrap</code> from the earlier chapters, which needs to take a heap-allocated closure, in other words a <code>Box</code>, which, in this case, will be passed a <code>mouse</code> event that we're not using so we can safely skip it. The casting to <code>Box&lt;dyn FnMut()&gt;</code> is necessary to appease the compiler and allow this function to be converted into <code>WasmClosure</code>. Inside that, we call the sender's <code>start_send</code> function and pass it a unit. Since we're not using any other parameters, we can just have the receiver check for any event.</p>
			<p>Finally, we'll need to take this closure and assign it to the <code>on_click</code> method on <code>elem</code> so that the button actually handles it, which looks as follows:</p>
			<pre>pub fn add_click_handler(elem: HtmlElement) -&gt; UnboundedReceiver&lt;()&gt; {
    let (mut click_sender, click_receiver) = unbounded();
    let on_click = browser::closure_wrap(Box::new(move || {
        click_sender.start_send(());
    }) as Box&lt;dyn FnMut()&gt;);
    <strong class="bold">elem.set_onclick(Some(on_click.as_ref().unchecked_ref()));</strong>
    <strong class="bold">on_click.forget();</strong>
    click_receiver
}</pre>
			<p>We've added the call to <code>elem.set_onclick</code>, which corresponds to <code>elem.onclick =</code> in JavaScript. Note how we pass <code>set_onclick</code> a <code>Some</code> variant because <code>onclick</code> itself can be <code>null</code> or <code>undefined</code> in JavaScript and, therefore, can be <code>None</code> in Rust and is an <code>Option</code> type. We then pass it <code>on_click.as_ref().unchecked_ref()</code>, which is the pattern we've used several times to turn <code>Closure</code> into a function that <code>web-sys</code> can use.</p>
			<p>Finally, we also <a id="_idIndexMarker725"/>make sure to forget the <code>on_click</code> handler. Without this, when we actually make this callback, the program will crash <a id="_idIndexMarker726"/>because <code>on_click</code> hasn't been properly handed off to JavaScript. We've done this a few times, so I won't belabor the point here. Now that we've written all the code, we'll need to show a button and handle the response to it, and we need to integrate it into our game. Let's figure out how to show the button.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor191"/>Show the button on game over </h1>
			<p>We can show and hide the button in the <code>Game</code> <code>update</code> method by checking on each frame if the <a id="_idIndexMarker727"/>game is over and if the button is present, ensuring that we only show or hide it once, and that would probably work, but I think you can sense the spaghetti code beginning to form if we do that. In general, it's best to avoid too much conditional logic in <code>update</code>, as it gets confusing and allows for logic bugs. Instead, we can think of every conditional check that looks like <code>if (state_is_true)</code> as two different states of the system. So, if the new game button is shown, that's one game state, and if it isn't, that's another game state. You know what that means – it's ti<a id="_idTextAnchor192"/>me for a state machine.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor193"/>A state machine review</h2>
			<p>In <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>,<em class="italic"> Managing Animations with State Machines</em>, we <a id="_idIndexMarker728"/>converted RHB to <a id="_idIndexMarker729"/>a state machine in order to make it change animations on events easily and, more importantly, correctly. For instance, when we wanted RHB to jump, we went from <code>Running</code> to <code>Jumping</code> via a typestate method, only changing the state one time and changing the velocity and playing the sound one time. That code is reproduced here for clarity:</p>
			<pre>    impl RedHatBoyState&lt;Running&gt; {
        ...
        pub fn jump(self) -&gt; RedHatBoyState&lt;Jumping&gt; {
            RedHatBoyState {
                context: self
                    .context
                    .reset_frame()
                    .set_vertical_velocity(JUMP_SPEED)
                    .play_jump_sound(),
                _state: Jumping {},
            }
        }</pre>
			<p>The typestates <a id="_idIndexMarker730"/>work great, but they are also noisy if we don't need <a id="_idIndexMarker731"/>that kind of functionality. That's why in that same chapter, we chose to model our game itself as a simple <code>enum</code>, like so:</p>
			<pre>pub enum WalkTheDog {
    Loading,
    Loaded(Walk),
}</pre>
			<p>This is going to change significantly because we now have a problem that necessitates a state machine. When RHB is knocked out, the game is over, and the new game button should appear. That's a side effect that needs to happen once, on a change of state, the perfect use case for our state machine. Unfortunately, refactoring to a state machine is going to require a not insignificant amount of code because our current method for implementing state machines is elegant but a little noisy. In addition, there's actually two state machines at work here, which is not obvious at first. The first is the one we see at the <a id="_idIndexMarker732"/>beginning, moving from <code>Loading</code> to <code>Loaded</code>, which you <a id="_idIndexMarker733"/>can think of as when you don't have <code>Walk</code> and when you do. The second is the state machine of <code>Walk</code> itself, which moves from <code>Ready</code> to <code>Walking</code> to <code>GameOver</code>. You can visualize it like this:</p>
			<div><div><img alt="" src="img/Figure_8.12_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Nested state machines</p>
			<p>As you can see, we have two state machines here, one going from <code>Loading</code> to <code>Loaded</code> and the other representing the three game states of <code>Ready</code>, <code>Walking</code>, and <code>GameOver</code>. There is a third state machine, not pictured, the famous <code>RedHatBoyStateMachine</code> that manages the <code>RedHatBoy</code> animations. A couple of the states pictured mimic the states in <code>RedHatBoyStateMachine</code>, where <code>Idle</code> is <code>Ready</code> and <code>Walking</code> is <code>Running</code>, so there is a temptation to move <code>RedHatBoyStateMachine</code> into <code>WalkTheDogStateMachine</code>. This could work, but remember that <code>Walk</code> doesn't have a "jumping" state and so, by doing that, you'll need to <a id="_idIndexMarker734"/>start checking a Boolean, and the modeling starts to break down. It's best to accept the similarity because the game is heavily dependent <a id="_idIndexMarker735"/>on what RHB is doing, but treat <code>RedHatBoyStateMachine</code> as having more fine-grained states. What <em class="italic">does</em> work is turning <code>Loading</code> and <code>Loaded</code> into <code>Option</code>. Specifically, we'll model our game like so:</p>
			<pre>struct WalkTheDogGame {
    machine: Option&lt;WalkTheDogStateMachine&gt;
}</pre>
			<p>This code isn't meant to be written anywhere yet; it's just here for clarity. There's a big advantage to using <code>Option</code> here, and it has to do with the way our <code>update</code> function works. For clarity, I'm going to reproduce a section of our game loop here:</p>
			<pre>let mut keystate = KeyState::new();
*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {
    process_input(&amp;mut keystate, &amp;mut keyevent_receiver);
    game_loop.accumulated_delta += (perf – 
        game_loop.last_frame) as f32;
    while game_loop.accumulated_delta &gt; FRAME_SIZE {
        <strong class="bold">game.update(&amp;keystate);</strong>
        game_loop.accumulated_delta -= FRAME_SIZE;
    }</pre>
			<p>The key part here is the <code>game.update</code> line, which performs a mutable borrow on the <code>game</code> object instead of moving it into <code>update</code>. This is because once <code>game</code> is owned by <code>FnMut</code>, it can't be moved out. Trying to actually leads to this compiler error:</p>
			<pre>error[E0507]: cannot move out of `*game`, as `game` is a captured variable in an `FnMut` closure</pre>
			<p>Mutable borrows such as this are tricky because they can make it more challenging to navigate the <a id="_idIndexMarker736"/>borrow checker as you proceed down the call stack. In this case, it becomes a problem if we try to implement another state machine in <a id="_idIndexMarker737"/>the same manner as <code>RedHatBoyStateMachine</code>. In our state machine implementation, each <code>typestate</code> method consumes the machine and returns a new one. Now, let's imagine that we are modeling the entire game as <code>enum</code>, like so:</p>
			<pre>enumWalkTheDogGame {
    Loading,
    Loaded(Walk),
    Walking(Walk),
    GameOver(Walk)
}</pre>
			<p>In order to make this work with the mutable borrow in <code>update</code>, we would have to clone the entire game on every state change because the <code>from</code> function couldn't take ownership of it. In other words, the closure in our <code>game.update</code> function <em class="italic">lends</em> <code>game</code> to the <code>update</code> function. This can't turn around and <em class="italic">give</em> it to the <code>from</code> function – it doesn't own it! Doing so requires cloning the entire game, potentially on every frame!</p>
			<p>Modeling the game as holding an optional <code>WalkTheDogStateMachine</code> has two advantages:</p>
			<ul>
				<li>We can call <code>take</code> on <code>Option</code> to get ownership of the state machine.</li>
				<li>The type reflects that the state machine isn't available until the game is loaded.<p class="callout-heading">Note</p><p class="callout">There are, naturally, many ways to model our game type, and some of them are going to be better than the one we'll choose here. However, before you start trying to do a "simpler" version of this type, let me warn you that I tried several different variations on this solution and ultimately found using <code>Option</code> to be the most straightforward choice. Several other implementations either ended with complex borrowing or unnecessary cloning. Be wary, but also be brave. You may find a better way than I did!</p></li>
			</ul>
			<p>Before we <a id="_idIndexMarker738"/>dig into the actual implementation, which is fairly long, let's go <a id="_idIndexMarker739"/>over the design we're implementing.</p>
			<div><div><img alt="Figure 8.13 – Before" src="img/Figure_8.13_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Before</p>
			<p>It's pretty simple, but it doesn't do all that we need it to. Now, let's redesign the state machine.</p>
			<div><div><img alt="Figure 8.14 – After&#13;&#10;" src="img/Figure_8.14_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – After</p>
			<p>Yeah, that's <a id="_idIndexMarker740"/>a lot more code, and it doesn't even reflect the details <a id="_idIndexMarker741"/>of the implementation, or the <code>From</code> traits we write to make it easy to convert between the <code>enum</code> values and structs. Writing some macros to handle state machine boilerplate is out of the scope of this book, but it's not a bad idea. You might wonder why every state holds its own <code>Walk</code> instance when every single state has it, and that's because we're going to change <code>Walk</code> on the transitions and the individual states don't have easy access to the parent <code>WalkTheDogState</code> container data. However, where possible, we'll move common data out of <code>Walk</code> and into <code>WalkTheDogState</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This section has a lot of code, and the snippets tend to only show a few lines at a time so that it's not too much to process. However, as you're following along, you may wish to reorganize the code to be easier to find. For instance, I prefer to work top-down in the <code>game</code> module, with constants at the top followed by the "biggest" <code>struct</code>, which is <code>WalkTheDog</code> in this case, followed by any code it depends on, so that the call stack flows down the page. This is how <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a> is organized. You're also welcome to start breaking this up into more files. I won't, to make it easier to explain in book form.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor194"/>Redesigning to a state machine </h2>
			<p>In a true refactoring, we would make sure the game was in a running state after each change, but our <a id="_idIndexMarker742"/>changes are going to cause cascading compiler errors, meaning we're going to be broken for a while, so this change isn't <a id="_idIndexMarker743"/>truly a refactoring but more of a redesign. When you make this kind of change, you should absolutely get to a compiling state as quickly as possible and stay there as long as possible, but while I did that when writing this chapter, I'm not going to put you through all the intermediate steps. We'll move forward as if we know in advance that our design is going to work because we do this time, but don't try this at home. If you're a regular Git user, now is an excellent time to create a branch, just in case.</p>
			<p>We'll start by replacing this code in the <code>game</code> module:</p>
			<pre>pub enum WalkTheDog {
    Loading,
    Loaded(Walk),
}</pre>
			<p>We'll replace it with the following:</p>
			<pre>pub struct WalkTheDog {
    machine: Option&lt;WalkTheDogStateMachine&gt;,
}</pre>
			<p>This will cause compiler errors all over the place. This is the section where we'll take the shortcut of letting the compiler be broken temporarily while we implement the state machine, if only to make sure this chapter isn't a thousand pages long. So, if you're uncomfortable working with a broken code base for a long time, that's good – just trust that I was <em class="italic">brilliant</em> and got this all right on the first try. Pretend – it'll be okay.</p>
			<p>Since we're psychic and know exactly how this design is going to work out, we can go and push ahead, knowing that eventually, everything will come together without errors. This first change is exactly what we discussed earlier – <code>enum WalkTheDog</code> becomes a struct holding its <code>machine</code> instance, which is an <code>optional</code> field. Currently, <code>WalkTheDogStateMachine</code> doesn't exist, so we'll add that next, like so:</p>
			<pre>enum WalkTheDogStateMachine {
    Ready(WalkTheDogState&lt;Ready&gt;),
    Walking(WalkTheDogState&lt;Walking&gt;),
    GameOver(WalkTheDogState&lt;GameOver&gt;),
}</pre>
			<p>When we <a id="_idIndexMarker744"/>implement a state machine in Rust, we <a id="_idIndexMarker745"/>need <code>enum</code> as a container for states so that <code>WalkTheDog</code> doesn't need to be a generic <code>struct</code>. We've moved the compiler errors down because there is no <code>WalkTheDogState</code> and no states defined. Let's do that next:</p>
			<pre>struct WalkTheDogState&lt;T&gt; {
    _state: T,
    walk: Walk,
}
struct Ready;
struct Walking;
struct GameOver;</pre>
			<p>Right now, the various typestates, <code>Ready</code>, <code>Walking</code>, and <code>GameOver</code>, don't store any data. This will change a little as we go on, but all of the typestates have <code>Walk</code> so that they can be saved in the common <code>WalkTheDogState</code> struct. Now that we've created the state machine, we need to look at where the old version of <code>WalkTheDog</code> was used. The first is in the small <code>impl</code> block for <code>WalkTheDog</code>, in the old code where we created <code>enum</code>, like so:</p>
			<pre>impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog::Loading {}
    }
}</pre>
			<p>That's not going to work, and it's not compiling, so instead, let's replace it with an empty <code>WalkTheDog</code> instance, as shown here:</p>
			<pre>impl WalkTheDog {
    pub fn new() -&gt; Self {
        WalkTheDog { machine: None }
    }
}</pre>
			<p>This change <a id="_idIndexMarker746"/>replaces the old, and not used, <code>enum</code> with <code>machine</code> set to <code>None</code>. You can now think of <code>None</code> as the <code>Loading</code> state, and <a id="_idIndexMarker747"/>when a machine is present, you are <code>Loaded</code>. Speaking of loading, the next logical place to make changes is in the <code>Game</code> implementation for <code>WalkTheDog</code>. Looking at the <code>initialize</code> function that we've been in so many times, you'll see a compiler error here:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        <strong class="bold">match self</strong> {
            WalkTheDog::Loading =&gt; {</pre>
			<p>The <code>match self</code> line is not going to work anymore because <code>self</code> isn't <code>enum</code>. What we need to do instead is match <code>machine</code>, and if it's <code>None</code>, then load the new machine, and if it's present, then use <code>Err</code> in the same way we do now because <code>initialize</code> was somehow called twice. We can start by replacing both halves of the <code>match</code> statement, so the match should start as follows:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        <strong class="bold">match self.machine</strong> {
            <strong class="bold">None </strong>=&gt; {</pre>
			<p>Look closely <a id="_idIndexMarker748"/>to see that we now match on <code>self.machine</code>, and we match against <code>None</code>. Before we dig into the <code>None</code> match arm, let's <a id="_idIndexMarker749"/>quickly change the match on <code>WalkTheDog::Loaded(_)</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self.machine {
            ...
            Some(_) =&gt; Err(anyhow!("Error: Game is already  
                initialized!")),</pre>
			<p>This simply changes <code>WalkTheDog::Loaded</code> to <code>Some</code>, using the same error message.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In order to get clearer error messages, you can <code>#[derive(Debug)]</code> on the <code>WalkTheDog</code> struct. Doing that has cascading effects because everything it depends on also has to <code>#[derive(Debug)]</code>, so we won't do that here, but it's a good idea, especially if you're running into issues here.</p>
			<p>Now that both halves of the match properly match an <code>Option</code> type, we need to modify <code>initialization</code> to return the proper type. At the bottom of the <code>None</code> branch, you will want to create a state machine like the one shown here, right before returning the value:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self.machine {
            None =&gt; {
                ...
                let timeline = 
                    rightmost(&amp;starting_obstacles);
                let machine = WalkTheDogStateMachine
                    ::Ready(WalkTheDogState {
                    _state: Ready,
                    walk: Walk {
                        boy: rhb,
                        backgrounds: [
                            Image::new(background.clone(), 
                                Point { x: 0, y: 0 }),
                            Image::new(
                                background,
                                Point {
                                    x: background_width,
                                    y: 0,
                                },
                            ),
                        ],
                        obstacles: starting_obstacles,
                        obstacle_sheet: sprite_sheet,
                        stone,
                        timeline,
                    },
                });
                ...</pre>
			<p>This is very similar to the code before; the construction of <code>Walk</code> is unchanged, but it's obscured <a id="_idIndexMarker750"/>by all the state machine noise. We are binding the <code>machine</code> variable to <code>WalkTheDogStateMachine::Ready</code> with the <a id="_idIndexMarker751"/>initialized <code>WalkTheDogState </code>instance, which, in turn, sets its internal <code>_state</code> value to <code>Ready</code>, and with the state getting to have  <code>Walk</code>. It's noisy, and after we get this file back to compiling, we'll do true refactoring to make that line a little cleaner, but put a pin in that for now.</p>
			<p>Now, we made it so that <code>initialize</code> returns a new <code>Result&lt;Box&lt;dyn Game&gt;&gt;</code> a while back, so we'll need to return a new <code>Game</code> instance next. So, right after adding <code>machine</code>, add the following:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self.machine {
            None =&gt; {
                ...
                 Ok(Box::new(WalkTheDog {
                    machine: Some(machine),
                }))</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Given that <code>initialize</code> takes <code>self</code> and doesn't really use it, it's debatable whether it should be in the <code>Game</code> trait. Creating a separate trait, such as <code>Initializer</code>, will require a lot of modifications and is an exercise for the reader.</p>
			<p>This takes care of making sure <code>initialize</code> returns a game with a machine in the right state. We have two more big trait methods, <code>update</code> and <code>draw</code>, to take care of, and <code>update</code> is filled <a id="_idTextAnchor195"/>with compiler errors, so let's do that next.</p>
			<h3>Spreading update into the state machine</h3>
			<p>The <code>update</code> function is filled with compiler errors, is the core of the game's behavior, and has an <a id="_idIndexMarker752"/>additional challenge. Instinctively, you might think you can modify the beginning of the function like so:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let Some(machine) = self.machine {
            ...</pre>
			<p>The <code>if let Some(machine) = self.machine</code> line will eventually fail to compile with the error:</p>
			<pre>error[E0507]: cannot move out of `self.machine.0` which is behind a mutable reference
   --&gt;src/game.rs:676:32
    |
676 |         if let Some(machine) = self.machine {
    |                     -------    ^^^^^^^^^^^^ help: consider borrowing here: `&amp;self.machine`</pre>
			<p>Now, you may try, as I did, to fix this by changing the line to <code>if let Some(machine) = &amp;mut self.machine</code>. This will work until you try to implement a transition on <code>WalkTheDogState</code>. Because you have a borrowed machine, you'll also have a borrowed state when you later match on the state, as with the following example:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState)
        if let Some(machine) = &amp;mut self.machine {
            match machine {
                WalkTheDogStateMachine::Ready(state) =&gt; {</pre>
			<p>Here, the <code>state</code> value is borrowed, unlike in most other cases where the match arms take ownership <a id="_idIndexMarker753"/>of the value, and it's not instantly obvious. It will be if we write a transition from <code>Ready</code> to <code>Walking</code>. In order to write <code>state._state.run_right()</code> and get to <code>Walking</code>, your transition will need to look like this in order to compile:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    fn start_running(<strong class="bold">&amp;mut self</strong>) -&gt; WalkTheDogState&lt;Walking&gt; {
        self.run_right();
        WalkTheDogState {
            _state: Walking,
            walk: self.walk,
        }
    }
}</pre>
			<p>Note that we are transitioning from <code>&amp;mut WalkTheDogState&lt;Ready&gt;&gt;</code> to <code>WalkTheDogState&lt;Walking&gt;</code>, which is an odd conversion and a hint that this is wrong. What you can't see is that this code won't compile. Returning the new <code>WalkTheDogState</code> with <code>walk</code> is a move that we cannot do because <code>state</code> is borrowed. The <code>start_running</code> method doesn't own <code>state</code>, so it can't take ownership of <code>state.walk</code> and, therefore, can't return the new instance. The workaround for this is to clone the entire <code>Walk</code> each time we transition, but there's no need for that inefficiency. We can, instead, take ownership of <code>machine</code> all the way back up in the <code>Game</code> implementation, through the aptly named <code>take</code> function. Instead of using a mutable borrow on the machine, we'll call <code>take</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let Some(machine) = self.machine.take() {</pre>
			<p>This is the same code as earlier, but instead, we call the <code>take</code> method on <code>Option&lt;WalkTheDogStateMachine&gt;</code>. This replaces the state machine in <code>self</code> with <code>None</code> and binds the existing <code>machine</code> to the variable in <code>if let Some(machine)</code>. Now, inside that scope, we have complete ownership of <code>machine</code> and can do whatever we like to it, before eventually calling <code>replace</code> on the state machine in <code>self</code> to move it back in at the end of this function. It's a little awkward, but it gets around <a id="_idIndexMarker754"/>mutable borrows. It <em class="italic">also</em> introduces a potential error in that when control exits the <code>update</code> function, <code>machine</code> could still be set to <code>None</code>, effectively halting the game by accident. In order to prevent that from happening, before we continue updating this function, we'll add <code>assert</code> just outside the <code>if let</code> statement, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let Some(machine) = self.machine.take() {
            ...
        }
        assert!(self.machine.is_some());</pre>
			<p>Unfortunately, this is a runtime error, not a compile-time one, but it's going to let us know right away whether we mess up the next section. This <code>assert</code> may be overkill, because we are going to dramatically reduce the amount of code inside the <code>if let</code> block; in fact, it will be just one line. First, we'll add a call to a non-existent function called <code>update</code> on our state machine, as follows:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let Some(machine) = self.machine.take() {
            self.machine.replace(machine.<strong class="bold">update</strong>(keystate));
            if keystate.is_pressed("ArrowRight") {</pre>
			<p>Immediately after <code>if let Some(machine)</code>, add the <code>self.machine.replace(machine.update(keystate))</code> line. All the code below <code>replace</code> in the <code>if let</code> block is going to become part of various <code>update</code> functions in the implemented states, so what you'll want to do is either cut and paste that code <a id="_idIndexMarker755"/>to some place you can get it, or just comment it out. Next, we'll create <code>impl</code> on <code>WalkTheDogStateMachine</code> with this new <code>update</code> method, which will return the new state. An empty version of that will look like this:</p>
			<pre>impl WalkTheDogStateMachine {
    fn update(self, keystate: &amp;KeyState) -&gt; Self {
    }
}</pre>
			<p>Now, you can call that from the the <code>update</code> method in <code>Game</code>, which looks like this:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let Some(machine) = self.machine.take() {
            self.machine.replace(machine.update(keystate));
        }
        assert!(self.machine.is_some());
    }</pre>
			<p>The <code>update</code> method in <code>WalkTheDogStateMachine</code> is a little empty, and we should probably put some code in it. We could call <code>match self</code> in the update, and then write the behavior for each state in this <code>update</code> function, calling things such as <code>state._state.walk.boy.run_right()</code>, which would work but it is hideous. Instead, we'll match on <code>self</code> and then delegate to the individual <code>state</code> types. This will result in a pretty redundant <code>match</code> statement, as shown here:</p>
			<pre>impl WalkTheDogStateMachine {
    fn update(self, keystate: &amp;KeyState) -&gt; Self {
        match self {
            WalkTheDogStateMachine::Ready(state) 
                =&gt;state.update(keystate).into(),
            WalkTheDogStateMachine::Walking(state) 
                =&gt;state.update(keystate).into(),
            WalkTheDogStateMachine::GameOver(state) 
               =&gt;state.update().into(),
        }
    }
}</pre>
			<p>We saw a <a id="_idIndexMarker756"/>variation of this pattern before in <code>RedHatBoyStateMachine</code>, where we have to match on each variant of <code>enum</code> in order to delegate to the state, and unfortunately, there's not a great way around it. Fortunately, it's small. This little <code>match</code> statement won't compile because none of the <code>typestates</code> types have an <code>update</code> method. In fact, there are no implementations for the typestates at all. Let's continue our delegation by creating placeholder implementations for all three of them, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    fn update(self, keystate: &amp;KeyState) -&gt; 
        WalkTheDogState&lt;Ready&gt; {
        self
    }
}
impl WalkTheDogState&lt;Walking&gt; {
    fn update(self, keystate: &amp;KeyState) -&gt; 
        WalkTheDogState&lt;Walking&gt; {
        self
    }
}
impl WalkTheDogState&lt;GameOver&gt; {
    fn update(self) -&gt; WalkTheDogState&lt;GameOver&gt; {
        self
    }
}</pre>
			<p>It's worth <a id="_idIndexMarker757"/>refreshing our memory on how typestates work. A typestate is a structure that is generic over a state. So <code>WalkTheDogState&lt;T&gt;</code> is the structure, and we implement transitions between states by adding methods to implementations of <code>WalkTheDogState&lt;T&gt;</code>, where <code>T</code> is one of the concrete states. These placeholders all just return <code>self</code>, so <code>update</code> isn't doing anything yet. Look closely and you'll notice that <code>GameOver</code> doesn't take <code>KeyState</code> because it won't need it.</p>
			<p>The <code>update</code> method on <code>WalkTheDogStateMachine</code> tries to use <code>into</code> to convert each typestate back into <code>enum</code>, but we haven't written those yet. Recalling <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, again, we need to implement <code>From</code> to convert back from the various states to the <code>enum</code> type. These are implemented here:</p>
			<pre>impl From&lt;WalkTheDogState&lt;Ready&gt;&gt; for WalkTheDogStateMachine {
    fn from(state: WalkTheDogState&lt;Ready&gt;) -&gt; Self {
        WalkTheDogStateMachine::Ready(state)
    }
}
impl From&lt;WalkTheDogState&lt;Walking&gt;&gt; for WalkTheDogStateMachine {
    fn from(state: WalkTheDogState&lt;Walking&gt;) -&gt; Self {
        WalkTheDogStateMachine::Walking(state)
    }
}
impl From&lt;WalkTheDogState&lt;GameOver&gt;&gt; for WalkTheDogStateMachine {
    fn from(state: WalkTheDogState&lt;GameOver&gt;) -&gt; Self {
        WalkTheDogStateMachine::GameOver(state)
    }
}</pre>
			<p>This is <a id="_idIndexMarker758"/>boilerplate just to get things started, but it demonstrates how each of these works. The <code>update</code> method on <code>WalkTheDogStateMachine</code> uses <code>match</code> to get the <code>state</code> value on each variant. Then, the <code>update</code> method is called on the various typestates. Each <code>update</code> method returns the state it transitions into, although right now, they all return <code>self</code>. Finally, back in the <code>update</code> method on <code>WalkTheDogStateMachine</code>s, we call <code>into</code> to convert the typestate back into an <code>enum</code> variant. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might remember that for <code>RedHatBoyStateMachine</code>, we used a transition function and an <code>Event</code> <code>enum</code> to advance the state machine. The new <code>WalkTheDogStateMachine</code> enum has fewer events, so additional complexity isn't necessary.</p>
			<p>It's time to think about what each state should actually do. Previously, every one of these states was kind of shoved together in the <code>Game</code> <code>update</code> method – for instance, the following old code:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            if keystate.is_pressed("ArrowRight") {
                walk.boy.run_right();
            }
            if keystate.is_pressed("Space") {
                walk.boy.jump();
            }
            if keystate.is_pressed("ArrowDown") {
                walk.boy.slide();
            }</pre>
			<p>In the old <a id="_idIndexMarker759"/>system, if the game was <code>Loaded</code>, then <code>boy</code> could <code>run_right</code> if you pressed the <code>ArrowRight</code> button and could jump if you pressed <code>Space</code>. This worked fine, but it's worth noting the following:</p>
			<ul>
				<li>The <code>run_right</code> function does nothing if RHB is already running.</li>
				<li>The <code>jump</code> and <code>slide</code> functions do nothing if RHB isn't running.</li>
			</ul>
			<p>We handle this quite well in our <code>RedHatBoyStateMachine</code>, and will continue to do so, but what this reveals is that once RHB starts moving to the right, we don't really care if the player has pushed the <code>WalkTheDogStateMachine</code>. When the game is <code>Ready</code>, we'll check whether the user has hit <code>ArrowRight</code> and transition the state. Otherwise, we'll just stay in the same state.</p>
			<p>We can modify <code>WalkTheDogState&lt;Ready&gt;</code> to reflect this new reality. The first change to the function will be to do that check, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    fn update(self, keystate: &amp;KeyState) -&gt; <strong class="bold">ReadyEndState</strong> {
        if keystate.is_pressed("ArrowRight") {
            ReadyEndState::Complete(<strong class="bold">self.start_running()</strong>)
        } else {
            ReadyEndState::Continue(self)
        }
    }
}</pre>
			<p>There's one <a id="_idIndexMarker760"/>type and one method that doesn't exist, so this code does not compile yet. The transition of <code>start_running</code> doesn't exist yet, although we discussed writing something like it. We also don't have the <code>ReadyEndState</code> type. Let's address that second one first.</p>
			<p>We used this pattern earlier for any <code>typestate</code> method that can return more than one state, such as the <code>update</code> method on <code>Jumping</code> or <code>Sliding</code>. We create a new <code>enum</code> that can represent either of the return states. In the case of the <code>update</code> method for <code>WalkTheDogState&lt;Ready&gt;</code>, the game can either still be <code>Ready</code> at the end of an update (<code>ReadyEndState::Continue</code>) or be done and transitioning to <code>Walking</code> (<code>ReadyEndState::Complete</code>).</p>
			<p>Let's start by implementing the <code>From</code> trait to convert from <code>ReadyEndState</code> to <code>WalkTheDogStateMachine</code>:</p>
			<pre>enum ReadyEndState {
    Complete(WalkTheDogState&lt;Walking&gt;),
    Continue(WalkTheDogState&lt;Ready&gt;),
}
impl From&lt;ReadyEndState&gt; for WalkTheDogStateMachine {
    fn from(state: ReadyEndState) -&gt; Self {
        match state {
            ReadyEndState::Complete(walking) =&gt; 
                walking.into(),
            ReadyEndState::Continue(ready) =&gt; ready.into(),
        }
    }
}</pre>
			<p>This is some <a id="_idIndexMarker761"/>boilerplate that you've seen before. We have two states for <code>ReadyEndState</code> because there are two states that the <code>WalkTheDogState&lt;Ready&gt;</code> <code>update</code> method can end in. In order to get from <code>ReadyEndState</code> to <code>WalkTheDogStateMachine</code>, we create a <code>From</code> trait and match on both variants of <code>ReadyEndState</code> and extract their fields from them. Those are both typestates, <code>WalkTheDogState&lt;Ready&gt;</code> and <code>WalkTheDogState&lt;Walking&gt;</code>, respectively, so we use their <code>into</code> methods to convert them into the <code>WalkTheDogStateMachine</code> type. Those traits were already written earlier. </p>
			<p>The call to <code>self.start_running</code> is still not going to work because we haven't written it yet! What happens when the player hits <code>typestate</code> method named after the transition, which looks like so:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    ...
    fn start_running(mut self) -&gt; WalkTheDogState&lt;Walking&gt; {
        self.run_right();
        WalkTheDogState {
            _state: Walking,
            walk: self.walk,
        }
    }</pre>
			<p>Let's refresh our memory on these. Every <code>state</code> transition is written as a method on the various typestates – in this case, <code>WalkTheDogState&lt;Ready&gt;</code>, where the source state is <code>self</code> and the return value is the destination state. Here, we transition from <code>Ready</code> to <code>Walking</code> by writing a method called <code>start_running</code>.</p>
			<p>The actual <a id="_idIndexMarker762"/>implementation isn't doing much. We start by calling <code>self.run_right</code>, which doesn't exist yet, so we have to write it. After sending RHB running, we transition into the <code>Walking</code> state by returning a new <code>WalkTheDogState</code> instance with <code>_state</code> of <code>Walking</code>. Take a close look at the function signature for <code>start_running</code> and you'll notice it takes <code>mut state</code>. This means taking exclusive ownership over <code>self</code>, which we can do because we have complete ownership of everything in the state. That is one of the reasons we created <code>Option&lt;WalkTheDogStateMachine&gt;</code> originally! However, it's not obvious why we take <code>mut state</code> here instead of <code>state</code>, in part because <code>run_right</code> doesn't exist. When we add our new delegation method, that should become clear, so let's do that right now with the following code:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    ...
    fn run_right(&amp;mut self) {
        self.walk.boy.run_right();
    }
}</pre>
			<p>This function on <code>WalkTheDogState&lt;Ready&gt;</code> calls <code>run_right</code> on <code>boy</code> through its walk field. The <code>run_right</code> method on <code>boy</code> requires a mutable borrow, and that's why we require a mutable borrow on the previous delegate. It's also why we needed to take <code>mut state</code> in the <code>start_running()</code> method earlier. You can't mutably borrow something that isn't mutable in the first place.</p>
			<p>In order to <a id="_idIndexMarker763"/>keep the code clean, we're doing a little more delegation now than we were earlier. This makes our methods smaller and easier to understand, but the trade-off is that the behavior will be spread across multiple places. I think in the end, this will make our code easier to think about, because we won't have to consider too much code at any one time, so the trade-off is worth it. We'll have to be careful that we don't lose track of any of our original <a id="_idTextAnchor196"/>code as we break it up into chunks and spread it around.</p>
			<h3>Re-implementing draw</h3>
			<p>Now, we've removed all the compiler errors in the original <code>update</code> method, in part by removing a large <a id="_idIndexMarker764"/>chunk of its functionality, and we can continue by updating the <code>Walking</code> state to ensure that it's working, but I believe that's a long time without any meaningful feedback from the game. After all, at this point, the game doesn't compile and doesn't draw. How do we know anything is working? Let's instead take a moment and update the <code>Game</code> <code>draw</code> method so that we can actually get the code to compile again and see how it's working.</p>
			<p>The <code>draw</code> method will <a id="_idIndexMarker765"/>start by taking a page from the <code>update</code> method and replacing its current implementation with a delegation to <code>WalkTheDogStateMachine</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        renderer.clear(&amp;Rect::new(Point { x: 0, y: 0 }, 
            600, 600));
        if let Some(machine) = &amp;self.machine {
            machine.draw(renderer);
        }
    }
}</pre>
			<p>There are two things that are a little different from the changes we made to update. The first is that we only borrow <code>self.machine</code> because we don't need mutable access. We also still clear the screen at the top of <code>draw</code>. That happens on every state change, so there's <a id="_idIndexMarker766"/>no reason to not just do it then. Besides, it will help us debug if we make any mistakes, since the screen will turn white.</p>
			<p>Let's continue the delegation by adding a <code>draw</code> method to <code>WalkTheDogStateMachine</code> that can extract the state from each case for drawing, as shown here:</p>
			<pre>impl WalkTheDogStateMachine {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        match self {
            WalkTheDogStateMachine::Ready(state) =&gt; 
                state.draw(renderer),
            WalkTheDogStateMachine::Walking(state) =&gt; 
                state.draw(renderer),
            WalkTheDogStateMachine::GameOver(state) =&gt; 
                state.draw(renderer),
        }
    }
}</pre>
			<p>This is virtually identical to the <code>update</code> method we wrote earlier, except on a borrowed <code>self</code> instead of consuming <code>self</code>. The rest is just delegations to the various states. Unlike update, every state draws in the exact same way, so we can fill those in with one method, as shown here:</p>
			<pre>impl&lt;T&gt; WalkTheDogState&lt;T&gt; {
    fn draw(&amp;self, renderer: &amp;Renderer) {
        self.walk.draw(renderer);
    }
}</pre>
			<p>Any state <a id="_idIndexMarker767"/>will delegate <code>draw</code> to <code>Walk</code> because the drawing doesn't actually change based on state. We can finally go ahead and re-implement the <code>draw</code> method, this time on <code>Walk</code>, as shown here:</p>
			<pre>impl Walk {
    fn draw(&amp;self, renderer: &amp;Renderer) {
        self.backgrounds.iter().for_each(|background| {
            background.draw(renderer);
        });
        self.boy.draw(renderer);
        self.obstacles.iter().for_each(|obstacle| {
            obstacle.draw(renderer);
        });
    }
    ...
}</pre>
			<p>This code is not new, but I don't blame you if you forgot it. It's our old <code>draw</code> code from <a href="B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating an Endless Runner</em>, only with the <code>walk</code> variable replaced by <code>self</code>. The rest is identical.</p>
			<p>At this point, you'll notice something exciting – the code compiles again! But if you look closely at the game, you'll see that it's a little static.</p>
			<div><div><img alt="Figure 8.15 – Stand very still…." src="img/Figure_8.15_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Stand very still….</p>
			<p>Red Hat <a id="_idIndexMarker768"/>Boy has stopped animating! He doesn't do his little idle animation because we're not calling <code>update</code> like we used to; it's almost time to go back to fixing the <code>update</code> method.</p>
			<h3>Refactoring initialize</h3>
			<p>Before we <a id="_idIndexMarker769"/>proceed with restoring functionality, you might remember that I said the creation of <code>WalkTheDogStateMachine</code> was "obscured by all the state machine noise." Specifically, it looked like this:</p>
			<pre>                let machine = WalkTheDogStateMachine
                    ::Ready(WalkTheDogState {
                    _state: Ready,
                    walk: Walk {</pre>
			<p>To create <code>WalkTheDogStateMachine</code> required creating its <code>Ready</code> variant and passing a <code>WalkTheDog</code> state with its <code>_state</code> variable set to <code>Ready</code>. In addition to being noisy, it requires you to remember the correct initial state of the state machine. That's what constructors are for!</p>
			<p>Let's create <a id="_idIndexMarker770"/>a constructor for <code>WalkTheDogState&lt;Ready&gt;</code>, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    fn new(walk: Walk) -&gt; WalkTheDogState&lt;Ready&gt; {
        WalkTheDogState {
            _state: Ready,
            walk,
        }
    }
    ...</pre>
			<p>This makes it easier to create a new typestate of <code>WalkTheDogState&lt;Ready&gt;</code>; accepting <code>Walk</code>, it needs to be valid. Let's also make it easier to create the entire machine, with a smaller constructor:</p>
			<pre>impl WalkTheDogStateMachine {
    fn new(walk: Walk) -&gt; Self {
        WalkTheDogStat<a id="_idTextAnchor197"/>eMachine
            ::Ready(WalkTheDogState::new(walk))
    }
    ...</pre>
			<p>This constructor creates the entire machine with the right state and passes it <code>Walk</code>. Now that we've made these helper methods, we can make the change to the original initialize method, making it a little bit easier to read by using the <code>WalkTheDogStateMachine</code> constructor:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self.machine {
            None =&gt; {
                ...
                <strong class="bold">let machine = WalkTheDogStateMachine</strong>
<strong class="bold">                    ::new(Walk {</strong>
                    boy: rhb,
                    ...</pre>
			<p>It's a small <a id="_idIndexMarker771"/>change, but makes it both easier to read and safer, too. Doing the right thing, creating <code>WalkTheDogStateMachine</code> in the <code>Ready</code> state is easy to do, and creating it in the wrong state is not. </p>
			<p>Now that we've finished that little digression, we can go back to finishing the update method as planned.</p>
			<h3>Finishing update</h3>
			<p>This <a id="_idIndexMarker772"/>segment of the <em class="italic">original</em> <code>update</code> function in <code>Game</code> reveals what is missing from our current code:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            if keystate.is_pressed("ArrowDown") {
                walk.boy.slide();
            }
            <strong class="bold">walk.boy.update();</strong>
            ...</pre>
			<p>Immediately after all the checks for button presses, we were updating <code>boy</code>. Let's go ahead <a id="_idIndexMarker773"/>and add that to our new version of the <code>update</code> function in the <code>WalkTheDogState&lt;Ready&gt;</code> implementation, like so:</p>
			<pre>impl WalkTheDogState&lt;Ready&gt; {
    fn update(<strong class="bold">mut </strong>self, keystate: &amp;KeyState) -&gt; 
        ReadyEndState {
        <strong class="bold">self.walk.boy.update();</strong>
        if keystate.is_pressed("ArrowRight") {
            ReadyEndState::Complete(self.start_running())
        } else {
            ReadyEndState::Continue(self)
        }
}
...</pre>
			<p>There are two changes here, so don't forget to change <code>update</code> to accept <code>mut self</code> now instead of <code>self</code>. It's hiding there in the function signature. Also, we've added a call to <code>self.walk.boy.update()</code> to start updating the boy again.</p>
			<p>Do that and you'll see RHB idling again, ready to start chasing down his invisible dog. But if you hit the right arrow, RHB freezes, one frame into his running animation. That is not what we want, and intriguingly, there are no errors in the console log because no exceptions are being thrown. It's just that the <code>Walking</code> state doesn't do anything in its <code>update</code> function. We can restore that code by putting back some of the code we earlier commented out/copied/deleted into the <code>Walking</code> state of the game, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    ...
    fn update(mut self, keystate: &amp;KeyState) -&gt; 
        WalkTheDogState&lt;Walking&gt; {
        if keystate.is_pressed("Space") {
            self.walk.boy.jump();
        }
        ...
        if self.walk.timeline &lt; TIMELINE_MINIMUM {
            self.walk.generate_next_segment();
        } else {
            self.walk.timeline += <strong class="bold">walking_speed</strong>;
        }
        self
    }
}</pre>
			<p>In <code>WalkTheDogState&lt;Walking&gt;</code>, we've modified the <code>update</code> method to take a <code>mut self</code> and then restored most of the old <code>Game</code> <code>update</code> code. Rather than showing the entire method, I've just reproduced the beginning and end of the code snippet <a id="_idIndexMarker774"/>and elided the middle; you can safely cut and paste all the original code. There are a few changes to make the code fit its new location. Where the original code would read <code>walk.boy</code>, it now reads <code>self.walk.boy</code>. I also took the opportunity to rename <code>velocity</code>, which is a little vague, to <code>walking_speed</code> to clarify that it refers to how fast RHB walks. The final change we've made is taking out the <code>if keystate.is_pressed("ArrowRight")</code> code because there's no reason to check for that keypress anymore. Lastly, we return <code>self</code> because there's not yet any way to transition out of <code>WalkTheDogState&lt;Walking&gt;</code>. If you do this all correctly, you'll find that your code compiles and runs! In fact, as of this moment, all of the behavior is restored, including the problem where we have to refresh to start a new game. How about we finally add a new game button right now, huh?</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor198"/>Start a new Game </h1>
			<p>If you remember our originally planned behavior, and I don't blame you if you don't, we wanted to <a id="_idIndexMarker775"/>draw a new game button on the screen when RHB crashed and fell over. Then, when it's clicked, we want to start a new game. For that to happen, we'll need to do the following:</p>
			<ol>
				<li>Check whether <code>RedHatBoyStateMachine</code> is <code>KnockedOut</code>, and if so, transition from <code>Walking</code> to <code>GameOver</code>.</li>
				<li>On that transition, draw the new game button.</li>
				<li>Add an <code>onclick</code> handler so that when the button is clicked, we transition back to <code>Ready</code> with a new <code>Walk</code> instance.</li>
				<li>On the transition to <code>Ready</code>, hide the button and restart the game.</li>
			</ol>
			<p>All the code we wrote before was to make that change easier. Let's see whether we were right about that:</p>
			<ol>
				<li value="1">Transition from <code>Walking</code> to <code>GameOver</code>.</li>
			</ol>
			<p>To transition from <code>Walking</code> to <code>GameOver</code>, we need to return the <code>GameOver</code> state from the <code>WalkTheDogState&lt;Walking&gt;</code> <code>update</code> method, but when should we do that? We'll need to see whether the <em class="italic">boy</em> is knocked out and then make the change. We don't have that capability yet, so we'll need to create it, and let's work top-down, as we have been this entire chapter. First, we'll change the <code>WalkTheDogState&lt;Walking&gt;</code> <code>update</code> method to check the non-existing method:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    ...
    fn update(mut self, keystate: &amp;KeyState) -&gt; 
        <strong class="bold">WalkingEndState</strong> {
        ...
        if self.walk.timeline &lt; TIMELINE_MINIMUM {
            self.walk.generate_next_segment()
        } else {
            self.walk.timeline += walking_speed;
        }
        <strong class="bold">if self.walk.knocked_out() {</strong>
            <strong class="bold">WalkingEndState::Complete(self.end_game())</strong>
        <strong class="bold">} else {</strong>
            <strong class="bold">WalkingEndState::Continue(self)</strong>
        <strong class="bold">}</strong>
    }
}</pre>
			<p>Now, instead <a id="_idIndexMarker776"/>of always returning the <code>Walking</code> state, we return <code>WalkingEndState</code>, which doesn't exist yet but will mimic the pattern we used in the <code>update</code> method on on <code>WalkTheDogState&lt;Ready&gt;</code>. When the current state is <code>knocked_out</code>, we will return the <code>Complete</code> variant holding an instance of the <code>WalkTheDogState&lt;GameOver&gt;</code> type. That will be the state returned from the <code>end_game</code> transition, which is also not written yet. Otherwise, we'll return <code>Continue</code> with the current <code>WalkTheDogState&lt;Walking&gt;</code> state as its field. That's two functions that don't exist yet, <code>knocked_out</code> and <code>end_game</code>, along with a brand-new type. You can create the <code>WalkingEndState</code> type and its corresponding <code>From</code> trait to convert it into <code>WalkTheDogStateMachine</code> right now by following the same pattern we did for <code>ReadyEndState</code>. I won't reproduce that code here. We'll proceed from there by getting <code>knocked_out</code> working, which <a id="_idIndexMarker777"/>is going to be delegated from <code>Walk</code> to <code>RedHatBoyStateMachine</code> with some delegations in between:</p>
			<pre>impl Walk {
    fn knocked_out(&amp;self) -&gt; bool {
        self.boy.knocked_out()
    }
    ...
}
impl RedHatBoy {
    ...
    fn knocked_out(&amp;self) -&gt; bool {
        self.state_machine.knocked_out()
    }
    ...
}
impl RedHatBoyStateMachine {
    ...
    fn knocked_out(&amp;self) -&gt; bool {
        matches!(self, RedHatBoyStateMachine
            ::KnockedOut(_))
    }
}</pre>
			<p>We could pass <code>WalkTheDogState</code> to <code>RedHatBoyStateMachine</code> here to get the new state and follow the OO guideline of "tell, don't ask", but sometimes, you just want to check a Boolean. Here, we ask the <code>Walking</code> state, which asks <code>RedHatBoy</code> and finally <code>RedHatBoyStateMachine</code> whether it is knocked out. <code>RedHatBoyStateMachine</code> uses the handy <code>matches!</code> macro to check <code>self</code> against an <code>enum</code> variant, and return whether or not they match. Now that we can check whether Red Hat Boy is knocked out, we have just one compiler error – <code>no method named `end_game` found for struct `WalkTheDogState`</code>. </p>
			<p>It's time <a id="_idIndexMarker778"/>to implement the <code>end_game</code> transition method, which will represent our transition. We can start by implementing the transition to do nothing other than move <code>walk</code> from <code>Walking</code> to <code>GameOver</code>, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {
        WalkTheDogState {
            _state: GameOver,
            walk: self.walk,
        }
    }
    ...</pre>
			<p>This returns us to a compiled state and means that when RHB crashes and is knocked out, the game is in the <code>GameOver</code> state. However, it does nothing, so it's time for <em class="italic">step 2</em> – draw the new game button.</p>
			<ol>
				<li value="2">Draw the new game button.</li>
			</ol>
			<p>Many pages ago, I said: "To show our button programmatically, we can just call <code>browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;")</code>." But when do we call it? Well, we call it now, right before creating the new state:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {
        <strong class="bold">browser::draw_ui("&lt;button&gt;New Game&lt;/button&gt;");</strong>        
        WalkTheDogState {
            _state: GameOver,
            walk: self.walk,
        }
    }
    ...</pre>
			<p>If you add this one line of code to the transition, you'll see the new game button we wrote <a id="_idIndexMarker779"/>way back at the beginning when our RHB crashes into a rock. There's a warning on this line because we don't handle the result of <code>draw_ui</code>, which we'll ignore for the moment.</p>
			<ol>
				<li value="3">Add the <code>onclick</code> handler to the button.</li>
			</ol>
			<p>In order to add the click handler to the button, we need to get a reference to the element we just drew. We don't have that, as the <code>insert_adjacent_html</code> function doesn't provide it, so we'll need to find the button we just added to the screen so that we can attach an event handler to it. We've used <code>get_element_by_id</code> twice before on <code>document</code>, so it's probably time to write a wrapper function in the <code>browser</code> module, as shown here:</p>
			<pre>pub fn find_html_element_by_id(id: &amp;str) -&gt; Result&lt;HtmlElement&gt; {
    document()
        .and_then(|doc| {
            doc.get_element_by_id(id)
                .ok_or_else(|| anyhow!("Element with 
                    id {} not found", id))
        })
        .and_then(|element| {
            element
                .dyn_into::&lt;HtmlElement&gt;()
                .map_err(|err| anyhow!("Could not cast 
                    into HtmlElement {:#?}", err))
        })
}</pre>
			<p>We've made a slight change to the way we've been finding elements in this function. Normally, we want <code>HtmlElement</code>, not a generic <code>Element</code> type, so in this function, we've <a id="_idIndexMarker780"/>gone ahead and added a call to <code>dyn_into</code> to make the conversion. Therefore, this function first gets the document, then gets the element, and finally, converts it into the <code>HtmlElement</code> type, all while normalizing the errors with <code>anyhow!</code>.</p>
			<p>Now that we have a way to find the element, we can return to the transition in <code>game</code>, find the newly added new game button, and then add a click handler to it, as shown in the following code:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {
        let receiver = browser::draw_ui("&lt;button id='new_game'&gt;New Game&lt;/button&gt;")
            <strong class="bold">.and_then(|_unit| browser::</strong>
<strong class="bold">                find_html_element_by_id("new_game"))</strong>
            <strong class="bold">.map(|element| engine::</strong>
<strong class="bold">                add_click_handler(element))</strong>
            <strong class="bold">.unwrap();</strong>
        WalkTheDogState {
            _state: GameOver,
            walk: self.walk,
        }
    }</pre>
			<p>We've reproduced the entire transition trait here, but there are three changes. The first is <a id="_idIndexMarker781"/>that we've added <code>id</code> to the new game button; naturally, that's <code>new_game</code>. Then, we find the element in the document in the <code>and_then</code> block and use <code>map</code> to take that element and pass it to the recently created <code>add_click_handler</code> function. Now, we've got a small problem. We will need <code>receiver</code> to get click messages when they happen, but the <code>add_click_handler</code> function returns <code>Result</code> with <code>UnboundedReceiver</code>. The challenge is that the <code>end_game</code> function doesn't return <code>Result</code>. In <a href="B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing, Debugging, and Performance</em>, we'll investigate how to debug this kind of condition, but for now, we'll just grit our teeth and add <code>unwrap</code>.</p>
			<p>Now that we have <code>receiver</code> that will get a message whenever the player clicks <code>update</code> function for the <code>GameOver</code> state and when we receive the event transition to the <code>Ready</code> state. That's going to mean adding the receiver to the <code>GameOver</code> struct, as follows:</p>
			<pre>struct GameOver {
    new_game_event: UnboundedReceiver&lt;()&gt;,
}</pre>
			<p>This will prompt you to add the <code>use</code> declaration for <code>futures::channel::mpsc::UnboundedReceiver</code>. Now that <code>GameOver</code> <code>struct</code> has the <a id="_idIndexMarker782"/>field, we'll need to pass it along in the transition, as shown here:</p>
			<pre>impl WalkTheDogState&lt;Walking&gt; {
    fn end_game(self) -&gt; WalkTheDogState&lt;GameOver&gt; {
        <strong class="bold">let receiver = </strong>browser::draw_ui("&lt;button 
<strong class="bold">            </strong>id=<strong class="bold">'new_game'</strong>&gt;New Game&lt;/button&gt;")
            .and_then(|_unit| browser::
                find_html_element_by_id("new_game"))
            .map(|element| engine::
                add_click_handler(element))
            .unwrap();
        WalkTheDogState {
            _state: GameOver {
                <strong class="bold">new_game_event: receiver,</strong>
            },
            walk: self.walk,
        }
    }</pre>
			<p>This is the final change to this method, and it's just adding the field to <code>GameOver</code>. Interestingly it's the first time we've added a field to any of our state structures, but it's something you're likely to do more of over time as you extend this game. Various states have data that's unique to them, and they belong in the <code>state</code> struct.</p>
			<p>It's time to return to the <code>WalkTheDogState&lt;GameOver&gt;</code> implementation and its <code>update</code> method, which currently just returns the <code>GameOver</code> state, leaving the game in that state forever. Instead, we'll want to check whether the new game event has <a id="_idIndexMarker783"/>happened (because the button was clicked) and then return the <code>Ready</code> state to start over again. That small bit of code is reproduced here:</p>
			<pre>impl WalkTheDogState&lt;GameOver&gt; {
    fn update(mut self) -&gt; GameOverEndState {
        if self._state.new_game_pressed() {
            GameOverEndState::Complete(self.new_game())
        } else {
            GameOverEndState::Continue(self)
        }
    }
}
impl GameOver {
    fn new_game_pressed(&amp;mut self) -&gt; bool {
        matches!(self.new_game_event.try_next(), 
            Ok(Some(())))       
    }
}</pre>
			<p>In the <code>WalkTheDogState&lt;GameOver&gt;</code> implementation, we check the state to see whether the new game button has been pressed, and if it has, we return the <code>GameOverEndState::Complete</code> variant; otherwise, we return the <code>GameOverEndState::Continue</code> variant. This is the same pattern we've used in every other update method, and you can go ahead and reproduce the <code>GameOverEndState</code> enum and its corresponding <code>From</code> trait to convert the type to a <code>WalkTheDogStateMachine</code> enum. That code is not reproduced here, but remember that if you get stuck, you can find the sample code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_8</a>. </p>
			<p>In the <code>GameOver</code> implementation, we have the details to check whether <code>new_game_event</code>, corresponding to the player's click, has happened. Calling <code>try_next</code> will return <code>Result</code> immediately, without blocking, or <code>Ok</code> if the channel is still open, regardless of whether anything is in it. Remember that we are running at 60 frames per second and cannot use the blocking calls. Finally, we use the handy matches! macro to check whether the channel was successfully sent a message of <code>unit</code>, or Ok(Some(())). If the event is there, <code>true</code>. </p>
			<p>This code <a id="_idIndexMarker784"/>doesn't compile because we don't have a transition written from <code>GameOver</code> to <code>Ready</code>, which is what we'll write in the next step.</p>
			<ol>
				<li value="4">Restart the game on <strong class="bold">New Game</strong>.</li>
			</ol>
			<p>Restarting the game will mean doing two things on the <code>new_game</code> transition. The first is hiding the button or "UI," and the second is recreating <code>Walk</code> from scratch. The first is actually easier, so we'll start with that:</p>
			<pre>impl WalkTheDogState&lt;GameOver&gt; {
    ...
    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {
        browser::hide_ui();
        WalkTheDogState {
            _state: Ready,
            walk: self.walk,
        }
    }
}</pre>
			<p>This is another transition, this time from <code>GameOver</code> to <code>Ready</code>, with the side effect of <a id="_idIndexMarker785"/>hiding the UI. It then moves to a new state with the same walk we ended with, which is not quite what we want.</p>
			<div><div><img alt="Figure 8.16 – I hit New Game – run, boy, run!" src="img/Figure_8.16_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – I hit New Game – run, boy, run!</p>
			<p>The button is hidden but RHB is still knocked out. Moving from <code>GameOver</code> to <code>Ready</code> means creating a new <code>Walk</code> instance from the old one, so the game starts over. This is a bit of a challenge because we no longer have access to the various images and sprite sheets we used to create <code>Walk</code> and <code>RedHatBoy</code> in the first place. What we'll do is clone those from an existing one, via a constructor function on the <code>Walk</code> implementation. We won't call this <code>clone</code> because that term means <a id="_idIndexMarker786"/>an identical copy, whereas this is really a reset. You can see the implementation here:</p>
			<pre>impl Walk {
    fn reset(walk: Self) -&gt; Self {
        let starting_obstacles =
            stone_and_platform(walk.stone.clone(), 
                walk.obstacle_sheet.clone(), 0);
        let timeline = rightmost(&amp;starting_obstacles);
        Walk {
            boy: walk.boy,
            backgrounds: walk.backgrounds,
            obstacles: starting_obstacles,
            obstacle_sheet: walk.obstacle_sheet,
            stone: walk.stone,
            timeline,
        }
    }
    ...
}</pre>
			<p>The <code>reset</code> function consumes <code>Walk</code> and returns a new one. It recreates <code>starting_obstacles</code> the same way they are created in <code>initialize</code>, and then recalculates <code>timeline</code>. Then, it constructs a new <code>Walk</code>, moving all the values from <code>Walk</code> except <code>starting_obstacles</code> and <code>timeline</code>. This function is not quite right though, as it will reset <code>Walk</code> but leave <code>boy</code> in its <code>KnockedOut</code> state. We'll need a similar <code>reset</code> function for <code>boy</code>, as shown here:</p>
			<pre>impl RedHatBoy {
    ...
    fn reset(boy: Self) -&gt; Self {
        RedHatBoy::new(
            boy.sprite_sheet,
            boy.image,
            boy.state_machine.context().audio.clone(),
            boy.state_machine.context().jump_sound.clone(),
        )
    }</pre>
			<p>Writing <code>reset</code> on <code>RedHatBoy</code> is a lot easier than it was on <code>Walk</code> because we created a constructor function, <code>new</code>, for <code>RedHatBoy</code> a long time ago. We should do <a id="_idIndexMarker787"/>the same for <code>Walk</code>, but that refactoring is up to you. Keep in mind that for this to compile, the <code>audio</code> and <code>jump_sound</code> fields on <code>RedHatBoyContext</code> need to be public. </p>
			<p>Now that we have a <code>reset</code> function for <code>RedHatBoy</code>, we can use it in the <code>Walk</code> <code>reset</code> function, like so:</p>
			<pre>impl Walk {
    ...
    fn reset(walk: Self) -&gt; Self {
        ...
        Walk {
            boy: RedHatBoy::reset(walk.boy),
            ...
        }
    }
}</pre>
			<p>We also need to call this in the original transition from <code>GameOver</code> to <code>Ready</code>, as follows:</p>
			<pre>impl WalkTheDogState&lt;GameOver&gt; {
    ...
    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {
        browser::hide_ui();
        WalkTheDogState {
            _state: Ready,
            walk: Walk::reset(self.walk),
        }
    }
}</pre>
			<p>If you <a id="_idIndexMarker788"/>do all that, you'll find that when you click the new game button, the game resets and the player is back at the start. You should be able to hit the right arrow key and start walking again. You <em class="italic">should</em>, but it doesn't work because we haven't accounted for one feature of the UI – the focus.</p>
			<ol>
				<li value="5">Focus!</li>
			</ol>
			<p>It turns out there's one more thing to do when we click the new game button to make the game ready to play again. When the game was started, we set up the canvas to have the focus so that it would receive keyboard input. We did this with the <code>tabIndex</code> field in the original HTML. When the player clicks <strong class="bold">New Game</strong>, they transfer the focus to the button and then hide the button, which means nothing will get the keyboard events we are listening to. You can see this effect by clicking <strong class="bold">New Game</strong> and then clicking the canvas after the button disappears. If you click the canvas, it regains the focus, and you can play the game again.</p>
			<p>We can transfer the focus back to the canvas automatically in the <code>hide_ui</code> function of the <code>browser</code> module. It's debatable whether it belongs here, since you may <a id="_idIndexMarker789"/>have cases where you want to hide the UI but not reset the focus, but our game doesn't have that case, so I think we're safe. This change is here:</p>
			<pre>pub fn hide_ui() -&gt; Result&lt;()&gt; {
    let ui = find_ui()?;
    if let Some(child) = ui.first_child() {
        ui.remove_child(&amp;child)
            .map(|_removed_child| ())
            .map_err(|err| anyhow!("Failed to remove 
                child {:#?}", err))
            <strong class="bold">.and_then(|_unit| {</strong>
                <strong class="bold">canvas()?</strong>
                    <strong class="bold">.focus()</strong>
                    <strong class="bold">.map_err(|err| anyhow!("Could not </strong>
<strong class="bold">                        set focus to canvas! </strong>
<strong class="bold">                            {:#?}", err))</strong>
            })
    } else {
        Ok(())
    }
}</pre>
			<p>After the first call to <code>map_err</code> for removing the child, we've added a second <code>and_then</code> call, which takes <code>unit</code> from the earlier <code>map</code> call, promptly ignores it, and then <a id="_idIndexMarker790"/>requests <code>focus</code> on <code>canvas</code>. The error from the <code>focus</code> call doesn't return an <code>anyhow!</code> type, so the compiler complains, and we fix that with a <code>map_err</code> call. The <code>focus</code> function is a JavaScript function we call through <code>web-sys</code>, which is documented on the MDN (<a href="https://mzl.la/30YGOMm">https://mzl.la/30YGOMm</a>).</p>
			<p>With that change, you can click <strong class="bold">New Game</strong> and start another try. We did it!</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor199"/>Pre-loading</h2>
			<p>You might notice that the button visibly loads when it shows up on screen – that is to say that <a id="_idIndexMarker791"/>the image and font aren't downloaded to the browser yet, so it doesn't appear instantaneously. This is standard behavior for web browsers. In order to make sure that you don't have to wait for an entire page worth of images, fonts, and other assets to load before you see a page, browsers will load assets lazily. This is so common that your eyes may not have noticed it when the <code>Button.svg</code> and the <code>kenney_future_narrow-webfont.woff2</code> assets immediately when the page is loaded so that when the button appears, it's instantaneous. Open the <code>index.html</code> file and make the changes shown here:</p>
			<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;
  &lt;link rel="stylesheet" href="styles.css" type="text/css" 
      media=
  "screen"&gt;
  <strong class="bold">&lt;link rel="preload" as="image" href="Button.svg"&gt;</strong>
  <strong class="bold">&lt;link rel="preload" as="font" href=</strong>
<strong class="bold">  "kenney_future_narrow-webfont.woff2"&gt;</strong>
&lt;/head&gt;</pre>
			<p>The <code>link</code> tag with the <code>preload</code> attribute will preload assets before rendering the page. You'll want to minimize this behavior generally because you don't want the user to have to <a id="_idIndexMarker792"/>wait a very long time with a blank screen, and if you were to make a very large game with many assets, you should probably use a more flexible solution in code with a loading screen. Our game is small right now, so this works pe<a id="_idTextAnchor200"/>rfectly well. With this change, the new game button not only appears but is snappy.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor201"/>Summary</h1>
			<p>You can look at the end of this chapter in two ways. The first might be to say, "All that for a button?", and you would have a point. After all, our UI is only one new game button, and while that's true, we actually covered quite a bit. We have integrated the DOM into our app via <code>web-sys</code> and have, in turn, adjusted our game to handle it. By utilizing the DOM, we were able to leverage the browser for behavior such as clicks and hovers, without having to detect where within the canvas the mouse was and creating clickable areas. You can now create far more complex UIs using tools such as CSS Grid and Flexbox, so if you are familiar with web development, which you've been doing for this entire book, so you are, you'll be able to make quality UIs for your games. If you're looking for some place to start, try adding a score to this game. You can increment the score in the update, and show it at the end menu, or at the right corner during the game, or both! I look forward to seeing it.</p>
			<p>With that, we will move on from new feature development to making sure that our current features work, and work fast. It's now time to start doing some testing and debugging, so we'll dive into that in the next chapter.</p>
		</div>
	</body></html>