<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing the Engine of the Music Player</h1>
                
            
            
                
<p class="calibre3">In the previous chapter, we implemented the user interface of the music player, but it is unable to play any music. We'll tackle that challenge in this chapter. We'll create the engine of the music player so that it can play MP3 files. To do this, we'll need to use threads so that playing a song does not freeze the interface, so it will be a good opportunity to learn about concurrency in Rust.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">MP3 decoder</li>
<li class="calibre11">Threads</li>
<li class="calibre11">Mutex and Mutex guards</li>
<li class="calibre11">Send/Sync traits</li>
<li class="calibre11">RAII</li>
<li class="calibre11">Thread safety</li>
<li class="calibre11">Interior mutability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing the dependencies</h1>
                
            
            
                
<p class="calibre3">For this chapter, we'll need two libraries: <kbd class="calibre14">pulseaudio</kbd> and <kbd class="calibre14">libmad</kbd>.</p>
<p class="calibre3">The former will be used to play the music, while the latter is for decoding MP3 files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing dependencies on Linux</h1>
                
            
            
                
<p class="calibre3">On Linux, these dependencies can be installed through the package manager of your distribution.</p>
<p class="calibre3">On Ubuntu (or other Debian derivatives):</p>
<pre class="calibre23"><strong class="calibre5">sudo apt-get install libmad0-dev libpulse-dev</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing dependencies on Mac</h1>
                
            
            
                
<p class="calibre3">On OSX, the required dependencies can be installed through the system package manager, as follows:</p>
<pre class="calibre23"><strong class="calibre5">brew install libmad pulseaudio</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing dependencies on Windows</h1>
                
            
            
                
<p class="calibre3">On Windows, run the following command in a MSYS2 shell:</p>
<pre class="calibre23"><strong class="calibre5">pacman -S mingw-w64-libmad</strong></pre>
<p class="calibre3">Think, click the link to download the zip file from this page: <a href="https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/" class="calibre13">https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/</a> (When the book was written, the link for the current version was <a href="http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip" class="calibre13">http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip</a>). Then, follow the same instructions as the ones from <a href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>, <em class="calibre21">Starting with SDL</em>, to use the library from Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Decoding MP3 files</h1>
                
            
            
                
<p class="calibre3">We'll start this chapter by learning how to decode an MP3 file to a format suitable to be played by the operating system using the <kbd class="calibre14">simplemad</kbd> crate, a binding for <kbd class="calibre14">libmad</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding dependencies</h1>
                
            
            
                
<p class="calibre3">Let's add the following to <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre22">crossbeam = "^0.3.0"
pulse-simple = "^1.0.0"
simplemad = "^0.8.1"</pre>
<p class="calibre3">We also added the <kbd class="calibre14">pulse-simple</kbd> and <kbd class="calibre14">crossbeam</kbd> crates because we'll need them later. The former will be used to play the songs with <kbd class="calibre14">pulseaudio</kbd> and the latter will be used to implement the event loop of the music player engine.</p>
<p class="calibre3">We also need to add the following statements in <kbd class="calibre14">main.rs</kbd>:</p>
<pre class="calibre22">extern crate crossbeam;
extern crate pulse_simple;
extern crate simplemad;

mod mp3;</pre>
<p class="calibre3">In addition to the <kbd class="calibre14">extern crate</kbd> statements, we have a <kbd class="calibre14">mod</kbd> statement since we'll create a new module for the MP3 decoder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing an MP3 decoder</h1>
                
            
            
                
<p class="calibre3">We're now ready to create this new module. Create a new <kbd class="calibre14">mp3.rs</kbd> file with the following content:</p>
<pre class="calibre22">use std::io::{Read, Seek, SeekFrom};
use std::time::Duration;

use simplemad;</pre>
<p class="calibre3">We start this module with some import statements as usual. The important one is <kbd class="calibre14">simplemad</kbd>, which will be used to decode the frames of an MP3 file:</p>
<pre class="calibre22">pub struct Mp3Decoder&lt;R&gt; where R: Read {
    reader: simplemad::Decoder&lt;R&gt;,
    current_frame: simplemad::Frame,
    current_frame_channel: usize,
    current_frame_sample_pos: usize,
    current_time: u64,
}</pre>
<p class="calibre3">We saw in <a href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, that we can add trait bounds to generic parameters in a function. We can also add them to the generic parameters of a type. Here we see an alternative syntax using a <kbd class="calibre14">where</kbd> clause. The previous structure declaration is the same as the following:</p>
<pre class="calibre22">pub struct Mp3Decoder&lt;R: Read&gt; {
    // …
}</pre>
<p class="calibre3">The <kbd class="calibre14">where</kbd> clause is useful when we have a lot a generic parameters.</p>
<p class="calibre3">This structure contains information about the current frame and time as well as the decoder itself, which comes from the <kbd class="calibre14">simplemad</kbd> crate. This <kbd class="calibre14">Decoder</kbd> also requires a generic parameter that implements the <kbd class="calibre14">Read</kbd> trait, so we just use our own <kbd class="calibre14">R</kbd> parameter since we specified that it must implement this trait.</p>
<p class="calibre3">Before we move on to the constructor of this type, we'll implement a couple of <kbd class="calibre14">utility</kbd> functions. Let's start with a function that converts <kbd class="calibre14">Duration</kbd> to a number of milliseconds (this function will go in the <kbd class="calibre14">main.rs</kbd> file since we'll use it in another module):</p>
<pre class="calibre22">fn to_millis(duration: Duration) -&gt; u64 {
    duration.as_secs() * 1000 + duration.subsec_nanos() as u64 / 1_000_000
}</pre>
<p class="calibre3">Here, we simply multiply the number of seconds by <kbd class="calibre14">1,000</kbd> and divide the number of nanoseconds by <kbd class="calibre14">1,000,000</kbd>. This function requires you to add an import statement for <kbd class="calibre14">Duration</kbd>:</p>
<pre class="calibre22">use std::time::Duration;</pre>
<p class="calibre3">Next, we'll write a function to check whether a stream of data is an MP3 file:</p>
<pre class="calibre22">fn is_mp3&lt;R&gt;(mut data: R) -&gt; bool where R: Read + Seek {
    let stream_pos = data.seek(SeekFrom::Current(0)).unwrap();
    let is_mp3 = simplemad::Decoder::decode(data.by_ref()).is_ok();
    data.seek(SeekFrom::Start(stream_pos)).unwrap();
    is_mp3
}</pre>
<p class="calibre3">To do so, we try to decode the stream and if the result is <kbd class="calibre14">Ok</kbd>, then the data is an MP3 file. We then go back to the beginning of the file before returning whether it is an MP3 file or not.</p>
<p class="calibre3">The next function we'll need is one to decode the next frame of an MP3 file:</p>
<pre class="calibre22">fn next_frame&lt;R: Read&gt;(decoder: &amp;mut simplemad::Decoder&lt;R&gt;) -&gt; simplemad::Frame {
    decoder.filter_map(|f| f.ok()).next()
        .unwrap_or_else(|| {
            simplemad::Frame {
                bit_rate: 0,
                layer: Default::default(),
                mode: Default::default(),
                sample_rate: 44100,
                samples: vec![Vec::new()],
                position: Duration::from_secs(0),
                duration: Duration::from_secs(0),
            }
        })
}</pre>
<p class="calibre3">Here, we simply get the next frame from the decoder and flatten the <kbd class="calibre14">Option&lt;Result&lt;Frame&gt;&gt;</kbd> to <kbd class="calibre14">Option&lt;Frame&gt;</kbd> by calling <kbd class="calibre14">and_then(Result::ok)</kbd>. If there's no frame, we return a default frame.</p>
<p class="calibre3">Now, let's implement the constructor of our MP3 decoder:</p>
<pre class="calibre22">impl&lt;R&gt; Mp3Decoder&lt;R&gt; where R: Read + Seek {
    pub fn new(mut data: R) -&gt; Result&lt;Mp3Decoder&lt;R&gt;, R&gt; {
        if !is_mp3(data.by_ref()) {
            return Err(data);
        }

        let mut reader = simplemad::Decoder::decode(data).unwrap();

        let current_frame = next_frame(&amp;mut reader);
        let current_time = to_millis(current_frame.duration);

        Ok(Mp3Decoder {
            reader,
            current_frame,
            current_frame_channel: 0,
            current_frame_sample_pos: 0,
            current_time,
        })
    }
}</pre>
<p class="calibre3">You need to add an import statement at the top of this file to be able to use the <kbd class="calibre14">to_millis</kbd> function, which is in the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">use to_millis;</pre>
<p class="calibre3">Since the <kbd class="calibre14">use</kbd> statements are relative to the root of the crate, we only need to write the function name because this function is at the crate's root.</p>
<p class="calibre3">The constructor first checks whether the stream contains MP3 data, if not, we return an error. Otherwise, we create a <kbd class="calibre14">Decoder</kbd> from the <kbd class="calibre14">simplemad</kbd> crate. Then, we read the first frame and get its time in milliseconds.</p>
<p class="calibre3">Next, we write two methods to get the current time and the rate of the MP3 file:</p>
<pre class="calibre23">    pub fn current_time(&amp;self) -&gt; u64 {
        self.current_time
    }

    pub fn samples_rate(&amp;self) -&gt; u32 {
        self.current_frame.sample_rate
    }</pre>
<p class="calibre3">These methods are to be added in the <kbd class="calibre14">impl Mp3Decoder</kbd> block. The last method to be added to this structure is a method to compute the duration of a song:</p>
<pre class="calibre23">    pub fn compute_duration(mut data: R) -&gt; Option&lt;Duration&gt; {
        if !is_mp3(data.by_ref()) {
            return None;
        }

        let decoder = simplemad::Decoder::decode_headers(data).unwrap();
        Some(decoder.filter_map(|frame| {
            match frame {
                Ok(frame) =&gt; Some(frame.duration),
                Err(_) =&gt; None,
            }
        })
            .sum())
    }</pre>
<p class="calibre3">Here we create an associated function: it first checks whether it is MP3 data. Here, instead of using <kbd class="calibre14">Decoder::decode()</kbd>, we use <kbd class="calibre14">Decoder::decode_headers()</kbd> because we only need the frame duration and it is faster to only decode the headers. The <kbd class="calibre14">decoder</kbd> is an iterator and we call <kbd class="calibre14">filter_map()</kbd> on it. As you saw in <a target="_blank" href="part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 2</a>, <em class="calibre21">Starting with SDL</em>, <kbd class="calibre14">filter_map()</kbd> transforms and filters the elements of an iterator. Transforming a value is done by returning <kbd class="calibre14">Some(new_value)</kbd>, while filtering out a value is done by returning <kbd class="calibre14">None</kbd>. After that, we call <kbd class="calibre14">sum()</kbd> on the resulting iterator to get the sum of all the durations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting the frame samples</h1>
                
            
            
                
<p class="calibre3">The only remaining feature needed for our MP3 decoder is to be able to iterate over the samples. We'll first write a function to get the next sample:</p>
<pre class="calibre22">fn next_sample&lt;R: Read&gt;(decoder: &amp;mut Mp3Decoder&lt;R&gt;) -&gt; Option&lt;i16&gt; {
    if decoder.current_frame.samples[0].len() == 0 {
        return None;
    }

    // getting the sample and converting it from fixed step to i16
    let sample = decoder.current_frame.samples[decoder.current_frame_channel] <br class="calibre6"/>    [decoder.current_frame_sample_pos];
    let sample = sample.to_i32() + (1 &lt;&lt; (28 - 16));
    let sample = if sample &gt;= 0x10000000 { 0x10000000 - 1 } else if sample &lt;=  <br class="calibre6"/>    -0x10000000 { -0x10000000 } else { sample };
    let sample = sample &gt;&gt; (28 + 1 - 16);
    let sample = sample as i16;

    decoder.current_frame_channel += 1;

    if decoder.current_frame_channel &lt; decoder.current_frame.samples.len() {
        return Some(sample);
    }

    decoder.current_frame_channel = 0;
    decoder.current_frame_sample_pos += 1;

    if decoder.current_frame_sample_pos &lt; decoder.current_frame.samples[0].len() {
        return Some(sample);
    }

    decoder.current_frame = next_frame(&amp;mut decoder.reader);
    decoder.current_frame_channel = 0;
    decoder.current_frame_sample_pos = 0;
    decoder.current_time += to_millis(decoder.current_frame.duration);

    return Some(sample);
}</pre>
<p class="calibre3">This function is doing some bit shifting to get the sample and then fetch the next frame. We're now ready to implement an iterator that will use this function:</p>
<pre class="calibre22">impl&lt;R&gt; Iterator for Mp3Decoder&lt;R&gt; where R: Read {
    type Item = i16;

    fn next(&amp;mut self) -&gt; Option&lt;i16&gt; {
        next_sample(self)
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (self.current_frame.samples[0].len(), None)
    }
}</pre>
<p class="calibre3">As you can see, we can implement our own iterator by implementing the <kbd class="calibre14">Iterator</kbd> trait. The only required method is <kbd class="calibre14">next()</kbd>. By implementing this simple method, we get a whole bunch of features because this trait has a lot of default methods. The <kbd class="calibre14">type Item</kbd> is also required. We implement the <kbd class="calibre14">size_hint()</kbd> method, even though it is an optional one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing music</h1>
                
            
            
                
<p class="calibre3">With the MP3 decoder done, we're now ready to play some music. We'll create a new module, called player, which we will add at the top of <kbd class="calibre14">main.rs</kbd>:</p>
<pre class="calibre22">mod player;</pre>
<p class="calibre3">We'll start this module by creating a new <kbd class="calibre14">player.rs</kbd> file with the following import statements:</p>
<pre class="calibre22">use std::fs::File;
use std::io::BufReader;
use std::path::{Path, PathBuf};
use std::sync::{Arc, Condvar, Mutex};
use std::thread;

use crossbeam::sync::SegQueue;
use pulse_simple::Playback;

use mp3::Mp3Decoder;
use self::Action::*;</pre>
<p class="calibre3">We'll also create some constants:</p>
<pre class="calibre22">const BUFFER_SIZE: usize = 1000;
const DEFAULT_RATE: u32 = 44100<a class="calibre67">;</a></pre>
<p class="calibre3">The buffer size is the number of samples we'll decode and play to avoid having slowdowns when playing the song and also to avoid using 100% of the CPU by constantly reading and decoding the data at the same time as playing. The default rate will be used when we cannot find one in the MP3 file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Event loop</h1>
                
            
            
                
<p class="calibre3">To simplify the development of our playing engine, we'll use the concept of an event loop. Some actions will be sent to the thread playing the music through this event loop. For instance, we will be able to emit a <kbd class="calibre14">Load("file.mp3")</kbd> event, the thread will decode this MP3 file, and start playing it. Another example of an event is <kbd class="calibre14">Stop</kbd>, which will stop playing and unload the data.</p>
<p class="calibre3">Let's create an enumeration for the possible actions:</p>
<pre class="calibre22">enum Action {
    Load(PathBuf),
    Stop,
}</pre>
<p class="calibre3">We're now ready to create the structure of the event loop:</p>
<pre class="calibre22">#[derive(Clone)]
struct EventLoop {
    queue: Arc&lt;SegQueue&lt;Action&gt;&gt;,
    playing: Arc&lt;Mutex&lt;bool&gt;&gt;,
}</pre>
<p class="calibre3">There's a lot of unknown stuff in this structure, so let's break it down.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Atomic reference counting</h1>
                
            
            
                
<p class="calibre3">First of all, we use the <kbd class="calibre14">Arc</kbd> type. It is similar to the <kbd class="calibre14">Rc</kbd> type that we used in the previous chapter, in that it is a type providing reference counting. The difference between these two types is that <kbd class="calibre14">Arc</kbd> uses atomic operations to increment its counter. By being atomic, it is safe to be used by multiple threads while <kbd class="calibre14">Rc</kbd> cannot be safely used across threads (and the compiler prevents us from trying to do so). The standard library provides these two types so that you can choose the cost you want to pay. If you don't need to share a reference-counted value with multiple threads, choose <kbd class="calibre14">Rc</kbd> as it is more efficient than <kbd class="calibre14">Arc</kbd>. If you try to send an <kbd class="calibre14">Rc</kbd> to another thread, the compiler will trigger an error:</p>
<pre class="calibre23"><strong class="calibre5">error[E0277]: the trait bound `std::rc::Rc&lt;i32&gt;: std::marker::Send` is not satisfied in `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc&lt;i32&gt;]`
 --&gt; src/main.rs:6:5
  |
6 |     thread::spawn(move || {
  |     ^^^^^^^^^^^^^ `std::rc::Rc&lt;i32&gt;` cannot be sent between threads safely
  |
  = help: within `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc&lt;i32&gt;]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;i32&gt;`
  = note: required because it appears within the type `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc&lt;i32&gt;]`
  = note: required by `std::thread::spawn`</strong></pre>
<p class="calibre3">In this case, you'll need to switch to an <kbd class="calibre14">Arc</kbd>. This error will make more sense when we see what the <kbd class="calibre14">Send</kbd> trait is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mutual exclusion</h1>
                
            
            
                
<p class="calibre3">In the <kbd class="calibre14">playing</kbd> field, the <kbd class="calibre14">Arc</kbd> contains a <kbd class="calibre14">Mutex</kbd>. A mutex provides mutual exclusion, meaning that it allows us to lock its inner value (in this case, a <kbd class="calibre14">bool</kbd>) preventing other threads from manipulating the same value at the same time. It prevents data races, which is a cause of undefined behavior, by preventing concurrent reads and writes on a value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Send trait</h1>
                
            
            
                
<p class="calibre3">But how can the compiler prevent us from doing data races? This is thanks to the <kbd class="calibre14">Send</kbd> and <kbd class="calibre14">Sync</kbd> marker traits. A type that implements the <kbd class="calibre14">Send</kbd> trait is safe to be sent to another thread. As you may have guessed, <kbd class="calibre14">Rc</kbd> does not implement <kbd class="calibre14">Send</kbd>. Since it does not use atomic operations to increment its counter, if two threads were to increment it at the same time, that would be a data race.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sync trait</h1>
                
            
            
                
<p class="calibre3">Let's discuss the second of these marker traits: <kbd class="calibre14">Sync</kbd>. A type that implements the <kbd class="calibre14">Sync</kbd> trait is safe to be shared with multiple threads. An example of a <kbd class="calibre14">Sync</kbd> type is <kbd class="calibre14">Mutex</kbd>. It is safe because the only way to get a value from <kbd class="calibre14">Mutex</kbd> is to lock it, which is mutually exclusive (another thread cannot access the same value at the same time).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lock-free data structures</h1>
                
            
            
                
<p class="calibre3">The only remaining type to explain is <kbd class="calibre14">SegQueue</kbd>, from the <kbd class="calibre14">crossbeam</kbd> crate. This type is a lock-free queue, meaning that it can be used concurrently by multiple threads without a lock. The implementation of lock-free data structures is beyond the scope of this book, but it suffices to say that it uses atomic operations behind the scenes so that we don't need to use a <kbd class="calibre14">Mutex</kbd> to mutate this value in mutable threads at the same time. We still need to wrap this queue in an <kbd class="calibre14">Arc</kbd> to be able to share it with multiple threads.</p>
<p class="calibre3">We're using a lock-free data structure because we'll be constantly checking whether there's a new element in this queue while possibly adding new elements to this queue from another thread. If we were to use <kbd class="calibre14">Mutex&lt;VecDeque&lt;Action&gt;&gt;</kbd>, it would be less efficient because calling <kbd class="calibre14">lock()</kbd> on <kbd class="calibre14">Mutex</kbd> waits if the lock is held by another thread.</p>
<p class="calibre3">Let's get back to our event loop. Let's add a constructor for <kbd class="calibre14">EventLoop</kbd>:</p>
<pre class="calibre22">impl EventLoop {
    fn new() -&gt; Self {
        EventLoop {
            queue: Arc::new(SegQueue::new()),
            playing: Arc::new(Mutex::new(false)),
        }
    }
}</pre>
<p class="calibre3">This constructor simply creates the queue and the Boolean wrapped in a <kbd class="calibre14">Mutex</kbd>.</p>
<p class="calibre3">Before we use it, we'll create a <kbd class="calibre14">State</kbd> structure that will contain various data shared between the GUI thread and the music player thread, put this code in the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">struct State {
    stopped: bool,
}</pre>
<p class="calibre3">Also, add a <kbd class="calibre14">state</kbd> field in the <kbd class="calibre14">App</kbd> structure:</p>
<pre class="calibre22">struct App {
    adjustment: Adjustment,
    cover: Image,
    playlist: Rc&lt;Playlist&gt;,
    state: Arc&lt;Mutex&lt;State&gt;&gt;,
    toolbar: MusicToolbar,
    window: Window,
}</pre>
<p class="calibre3">This requires a new import statement:</p>
<pre class="calibre22">use std::sync::{Arc, Mutex};</pre>
<p class="calibre3">Since this value will be shared with another thread, we need to wrap it in <kbd class="calibre14">Arc&lt;Mutex&gt;</kbd>. Then, in the constructor, create this value and assign it to this new field, while also sending it to the <kbd class="calibre14">Playlist</kbd> constructor:</p>
<pre class="calibre22">impl App {
    fn new() -&gt; Self {
        // …

        let state = Arc::new(Mutex::new(State {
            stopped: true,
        }));

        let playlist = Rc::new(Playlist::new(state.clone()));

        // …

        let app = App {
            adjustment,
            cover,
            playlist,
            state,
            toolbar,
            window,
        };

        // …
    }
}</pre>
<p class="calibre3">Let's update the <kbd class="calibre14">Playlist</kbd> constructor:</p>
<pre class="calibre22">impl Playlist {
    pub(crate) fn new(state: Arc&lt;Mutex&lt;State&gt;&gt;) -&gt; Self {
        let model = ListStore::new(&amp;[
            Pixbuf::static_type(),
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Pixbuf::static_type(),
        ]);
        let treeview = TreeView::new_with_model(&amp;model);
        treeview.set_hexpand(true);
        treeview.set_vexpand(true);

        Self::create_columns(&amp;treeview);

        Playlist {
            model,
            player: Player::new(state.clone()),
            treeview,
        }
    }
}</pre>
<p class="calibre3">The structure requires a new field, so let's add it:</p>
<pre class="calibre22">pub struct Playlist {
    model: ListStore,
    player: Player,
    treeview: TreeView,
}</pre>
<p class="calibre3">This also needs new import statements:</p>
<pre class="calibre22">use std::sync::{Arc, Mutex};

use State;
use player::Player;</pre>
<p class="calibre3">We use the <kbd class="calibre14">pub(crate)</kbd> syntax to silent an error. Since we're using a private type (<kbd class="calibre14">State</kbd>) in a public method, the compiler throws an error. This syntax means that the function is public to the other modules of the crate, but other crates cannot access it. Here, we only send the <kbd class="calibre14">state</kbd> to the <kbd class="calibre14">Player</kbd> constructor, which we will implement right away.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing music</h1>
                
            
            
                
<p class="calibre3">We'll create a new <kbd class="calibre14">Player</kbd> structure to wrap the event loop. The player will be usable from the main thread to control the music. Here's the structure itself:</p>
<pre class="calibre22">pub struct Player {
    app_state: Arc&lt;Mutex&lt;super::State&gt;&gt;,
    event_loop: EventLoop,
}</pre>
<p class="calibre3">And here's the start of its constructor:</p>
<pre class="calibre22">impl Player {
    pub(crate) fn new(app_state: Arc&lt;Mutex&lt;super::State&gt;&gt;) -&gt; Self {
        let event_loop = EventLoop::new();

        {
            let app_state = app_state.clone();
            let event_loop = event_loop.clone();
            thread::spawn(move || {
                // …
            });
        }

        Player {
            app_state,
            event_loop,
        }
    }
}</pre>
<p class="calibre3">We start by creating a new event loop. Then, we start a new thread. We used a new scope to avoid having to rename the variables that will be sent to the thread because these variables are used in the initialization of the structure at the end of the constructor. Again, we need to use a <kbd class="calibre14">move</kbd> closure because we're sending a copy of the event loop and the application state to the thread.</p>
<p class="calibre3">Let's see the first part of the thread's closure:</p>
<pre class="calibre22">thread::spawn(move || {
    let mut buffer = [[0; 2]; BUFFER_SIZE];
    let mut playback = Playback::new("MP3", "MP3 Playback", None,<br class="calibre6"/>    DEFAULT_RATE);
    let mut source = None;
    loop {
        if let Some(action) = event_loop.queue.try_pop() {
            match action {
                Load(path) =&gt; {
                    let file = File::open(path).unwrap();
                    source = Some(Mp3Decoder::new(BufReader::new(file)).unwrap());
                    let rate = source.as_ref().map(|source| <br class="calibre6"/>                     source.samples_rate()).unwrap_or(DEFAULT_RATE);
                    playback = Playback::new("MP3", "MP3 Playback", <br class="calibre6"/>                     None, rate);
                    app_state.lock().unwrap().stopped = false;
                },
                Stop =&gt; {},
            }
        }
        // …
    }
});</pre>
<p class="calibre3">We start by creating a buffer to contain the samples to be played. Then we'll create a <kbd class="calibre14">Playback</kbd>, which is an object that will allow us to play music on the hardware. We'll also create a <kbd class="calibre14">source</kbd> variable that will contain an <kbd class="calibre14">Mp3Decoder</kbd>. We then start an infinite loop and try to get the first element in the queue: if there's an element in the queue, <kbd class="calibre14">Some(action)</kbd> is returned. That's why we used <kbd class="calibre14">if let</kbd> to pattern match against the result of this method call. We then match against the action to see which action it is: if it is a <kbd class="calibre14">Load</kbd> action, we open the file with the specified path and create an <kbd class="calibre14">Mp3Decoder</kbd> with a buffered reader of this file. We then try to get the sample rate of the song and create a new <kbd class="calibre14">Playback</kbd> with this rate. We'll handle the <kbd class="calibre14">Stop</kbd> action later.</p>
<p class="calibre3">Finally, we see our first use of <kbd class="calibre14">Mutex</kbd>:</p>
<pre class="calibre22">app_state.lock().unwrap().stopped = false;</pre>
<p class="calibre3">Let's rewrite it in another way to see what's going on:</p>
<pre class="calibre22">let mut guard = app_state.lock().unwrap();
guard.stopped = false;</pre>
<p class="calibre3">We first call <kbd class="calibre14">lock()</kbd>, which returns a <kbd class="calibre14">Result&lt;MutexGuard&lt;T&gt;, PoisonError&lt;MutexGuard&lt;T&gt;&gt;&gt;</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mutex guard</h1>
                
            
            
                
<p class="calibre3">A mutex guard is a scoped lock: this means that the mutex will be automatically unlocked when going out of scope. It is a nice way to ensure that users will use a <kbd class="calibre14">Mutex</kbd> and won't forget to unlock it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">RAII</h1>
                
            
            
                
<p class="calibre3">But how does it work behind the scene? Rust uses the idiom of <strong class="calibre5">Resource Acquisition Is Initialization</strong>(<strong class="calibre5">RAII)</strong> for short. With this idiom, a resource is allocated in the constructor and released in its destructor. In Rust, destructors are implemented by the <kbd class="calibre14">Drop</kbd> trait. So, to get back to mutex guards, the mutex is unlocked when the destructor of <kbd class="calibre14">MutexGuard</kbd> is called, so, as in the previous example, when the <kbd class="calibre14">guard</kbd> variable goes out of scope.</p>
<p class="calibre3">Let's get back to our infinite loop:</p>
<pre class="calibre22">loop {
    if let Some(action) = event_loop.queue.try_pop() {
        // …
    } else if *event_loop.playing.lock().unwrap() {
        let mut written = false;
        if let Some(ref mut source) = source {
            let size = iter_to_buffer(source, &amp;mut buffer);
            if size &gt; 0 {
                playback.write(&amp;buffer[..size]);
                written = true;
            }
        }

        if !written {
            app_state.lock().unwrap().stopped = true;
            *event_loop.playing.lock().unwrap() = false;
            source = None;
        }
    }
}</pre>
<p class="calibre3">Here, we check whether the playing value is true (again using the <kbd class="calibre14">lock().unwrap()</kbd> trick). We must use a <kbd class="calibre14">*</kbd> to access the value of a <kbd class="calibre14">MutexGuard</kbd> because it implements <kbd class="calibre14">Deref</kbd>. That means we don't have direct access to the underlying value. But since it implements the <kbd class="calibre14">Deref</kbd> trait, we can access it by dereferencing the guard (with a <kbd class="calibre14">*</kbd>). We didn't need this trick before because we accessed a field and Rust automatically dereferences fields.</p>
<p class="calibre3">We then create a <kbd class="calibre14">written</kbd> variable that will be <kbd class="calibre14">true</kbd> if the player was able to play a sample. If it was unable to play one, this means the song came to an end. In this case, we set the <kbd class="calibre14">stopped</kbd> value to <kbd class="calibre14">true</kbd> and <kbd class="calibre14">playing</kbd> to <kbd class="calibre14">false</kbd>.</p>
<p class="calibre3">To play the samples, we call <kbd class="calibre14">iter_to_buffer</kbd>, which will take the value from the decoder (which is an <kbd class="calibre14">Iterator</kbd>) and write them to the buffer. Afterward, it will write the buffer to the <kbd class="calibre14">playback</kbd> in order to play the samples on your sound card.</p>
<p class="calibre3">Let's look at this <kbd class="calibre14">iter_to_buffer</kbd> function:</p>
<pre class="calibre22">fn iter_to_buffer&lt;I: Iterator&lt;Item=i16&gt;&gt;(iter: &amp;mut I, buffer: &amp;mut [[i16; 2]; BUFFER_SIZE]) -&gt; usize {
    let mut iter = iter.take(BUFFER_SIZE);
    let mut index = 0;
    while let Some(sample1) = iter.next() {
        if let Some(sample2) = iter.next() {
            buffer[index][0] = sample1;
            buffer[index][1] = sample2;
        }
        index += 1;
    }
    index
}</pre>
<p class="calibre3">We start by taking <kbd class="calibre14">BUFFER_SIZE</kbd> elements from the iterator and add them to the buffer two at a time (for two channels). We then return the number of elements written to the buffer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the music player</h1>
                
            
            
                
<p class="calibre3">We're now ready to use our music engine. Let's add a couple of new methods to <kbd class="calibre14">Playlist</kbd>.</p>
<p class="calibre3">Let's start with a method to get the path of the selection:</p>
<pre class="calibre23">    fn selected_path(&amp;self) -&gt; Option&lt;String&gt; {
        let selection = self.treeview.get_selection();
        if let Some((_, iter)) = selection.get_selected() {
            let value = self.model.get_value(&amp;iter, PATH_COLUMN as i32);
            return value.get::&lt;String&gt;();
        }
        None
    }</pre>
<p class="calibre3">We start by getting the selection, then we get the iterator for the selection. From the iterator, we can get the value at the specified column to get the path. We can now add a method to load the selected song:</p>
<pre class="sourcecode">    pub fn play(&amp;self) -&gt; bool {
        if let Some(path) = self.selected_path() {
            self.player.load(&amp;path);
            true
        } else {
            false
        }
    }</pre>
<p class="calibre3">If there's a selected song, we load it into the music engine. We return true if a song was loaded.</p>
<p class="calibre3">We'll now use this method in the event handler of the play button:</p>
<pre class="calibre22">impl App {
    pub fn connect_toolbar_events(&amp;self) {
        // …

        let playlist = self.playlist.clone();
        let play_image = self.toolbar.play_image.clone();
        let cover = self.cover.clone();
        let state = self.state.clone();
        self.toolbar.play_button.connect_clicked(move |_| {
            if state.lock().unwrap().stopped {
                if playlist.play() {
                    set_image_icon(&amp;play_image, PAUSE_ICON);
                    set_cover(&amp;cover, &amp;playlist);
                }
            } else {
                set_image_icon(&amp;play_image, PLAY_ICON);
            }
        });

        // …
    }
}</pre>
<p class="calibre3">We create a copy of the <kbd class="calibre14">playlist</kbd> variable because it is moved into the closure. In the latter, we then call the <kbd class="calibre14">play()</kbd> method we created just before. We only change the image of the button and show the cover if a song starts to play.</p>
<p class="calibre3">You can now try the music player: open an MP3 file, click play, and you should hear the song. Let's continue to develop the software since many features are missing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pausing and resuming the song</h1>
                
            
            
                
<p class="calibre3">We'll start by adding a field indicating whether the player is in pause or not. This field will be changed by methods such as <kbd class="calibre14">play</kbd> or <kbd class="calibre14">resume</kbd>. However, remember that our <kbd class="calibre14">Playlist</kbd> is wrapped in an <kbd class="calibre14">Rc</kbd>, so that we can use it in different places, namely in the event handlers. Also, remember that Rust forbids mutation when there are mutable references to a value. How can we update this field while still using a reference-counted pointer? One way is to use interior mutability.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Interior mutability</h1>
                
            
            
                
<p class="calibre3">Interior mutability is a concept granting mutable an inner value of a type with an immutable reference. Is this safe to do? Yes, totally, because we need to respect certain constraints. One way to have interior mutability is to wrap our <kbd class="calibre14">Cell</kbd> type. The constraint of this type is that if we want to get the value from the <kbd class="calibre14">Cell</kbd> from an immutable reference, the wrapped type must implement the <kbd class="calibre14">Copy</kbd> trait. We'll see the other commonly-used type for interior mutability later in this chapter. For now, let's add our field to the <kbd class="calibre14">Player</kbd> type:</p>
<pre class="calibre22">use std::cell::Cell;

pub struct Player {
    app_state: Arc&lt;Mutex&lt;super::State&gt;&gt;,
    event_loop: EventLoop,
    paused: Cell&lt;bool&gt;,
}</pre>
<p class="calibre3">Let's update the construction of the structure:</p>
<pre class="calibre22">impl Player {
    pub(crate) fn new(app_state: Arc&lt;Mutex&lt;super::State&gt;&gt;) -&gt; Self {
        // …

        Player {
            app_state,
            event_loop,
            paused: Cell::new(false),
        }
    }
}</pre>
<p class="calibre3">We can now add a method to check whether the music is paused or not:</p>
<pre class="calibre23">    pub fn is_paused(&amp;self) -&gt; bool {
        self.paused.get()
    }</pre>
<p class="calibre3">Here, we need to call <kbd class="calibre14">Cell::get()</kbd> to get a copy of the inner value. We can now add methods to play and resume the song:</p>
<pre class="calibre23">    pub fn pause(&amp;self) {
        self.paused.set(true);
        self.app_state.lock().unwrap().stopped = true;
        self.set_playing(false);
    }

    pub fn resume(&amp;self) {
        self.paused.set(false);
        self.app_state.lock().unwrap().stopped = false;
        self.set_playing(true);
    }</pre>
<p class="calibre3">Here we see that we need to call <kbd class="calibre14">Cell::set()</kbd> to update the value of the <kbd class="calibre14">Cell</kbd>. We can do that even though we only have an immutable reference and, once again, it is completely safe to do so. Then, we update the <kbd class="calibre14">stopped</kbd> field of the application state because the click handler for the play button will use it to decide whether we want to play or resume the music. We also call <kbd class="calibre14">set_playing()</kbd> to indicate to the player thread whether it needs to continue playing the song or not. This method is defined as such:</p>
<pre class="calibre23">    fn set_playing(&amp;self, playing: bool) {
        *self.event_loop.playing.lock().unwrap() = playing;
        let (ref lock, ref condition_variable) = *self.event_loop.condition_variable;
        let mut started = lock.lock().unwrap();
        *started = playing;
        if playing {
            condition_variable.notify_one();
        }
    }</pre>
<p class="calibre3">It sets the <kbd class="calibre14">playing</kbd> variable and then notifies the player thread to wake it up if <kbd class="calibre14">playing</kbd> is <kbd class="calibre14">true</kbd>.</p>
<p class="calibre3">We'll now add a <kbd class="calibre14">pause()</kbd> method to our <kbd class="calibre14">Playlist</kbd> type that will call the <kbd class="calibre14">pause()</kbd> method we've just created when the user clicks pause:</p>
<pre class="calibre23">    pub fn pause(&amp;self) {
        self.player.pause();
    }</pre>
<p class="calibre3">To use it, we'll update the click handler of the play button:</p>
<pre class="calibre22">self.toolbar.play_button.connect_clicked(move |_| {
    if state.lock().unwrap().stopped {
        if playlist.play() {
            set_image_icon(&amp;play_image, PAUSE_ICON);
            set_cover(&amp;cover, &amp;playlist);
        }
    } else {
        <strong class="calibre5">playlist.pause();</strong>
        set_image_icon(&amp;play_image, PLAY_ICON);
    }
});</pre>
<p class="calibre3">We added the call to pause in the <kbd class="calibre14">else</kbd> block.</p>
<p class="calibre3">We now want to update the <kbd class="calibre14">play()</kbd> method. Now that we can pause the song, there are two new cases to consider for this method:</p>
<ul class="calibre10">
<li class="calibre11">If the song is playing, we want to pause it.</li>
<li class="calibre11">If the song is paused, we either want to resume the song if the same one is selected or start a new song if another one is selected.</li>
</ul>
<p class="calibre3">That's why we need a new field in our <kbd class="calibre14">Playlist</kbd> structure:</p>
<pre class="calibre22">pub struct Playlist {
    current_song: RefCell&lt;Option&lt;String&gt;&gt;,
    model: ListStore,
    player: Player,
    treeview: TreeView,
}</pre>
<p class="calibre3">We added a field that will contain the path of the currently playing song. Here we wrap the <kbd class="calibre14">Option&lt;String&gt;</kbd> into a <kbd class="calibre14">RefCell</kbd>, which is another way to have interior mutability. We cannot use a <kbd class="calibre14">Cell</kbd> because the <kbd class="calibre14">String</kbd> type does not implement the <kbd class="calibre14">Copy</kbd> trait. So, what is the difference between <kbd class="calibre14">Cell</kbd> and <kbd class="calibre14">RefCell</kbd>? The <kbd class="calibre14">RefCell</kbd> type will check the borrowing rules at runtime: if two borrows happen at the same time, it will panic. We have to be careful when using <kbd class="calibre14">RefCell</kbd>: it is better to have compile-time borrowing checks if possible. But when using <kbd class="calibre14">gtk-rs</kbd>, we sometimes need to share a mutable state with the event handler and the best way to do that is to use <kbd class="calibre14">RefCell</kbd>.</p>
<p class="calibre3">In the next chapter, we'll learn how to use a library that abstracts the state management so that you won't need to use <kbd class="calibre14">RefCell</kbd> and you won't get any <kbd class="calibre14">panic</kbd> at runtime. This requires a new import statement:</p>
<pre class="calibre22">use std::cell::RefCell;</pre>
<p class="calibre3">We need to update the constructor to initialize this value:</p>
<pre class="calibre22">impl Playlist {
    pub(crate) fn new(state: Arc&lt;Mutex&lt;State&gt;&gt;) -&gt; Self {
        // …

        Playlist {
            current_song: RefCell::new(None),
            model,
            player: Player::new(state.clone()),
            treeview,
        }
    }
}</pre>
<p class="calibre3">There's one more method to add in <kbd class="calibre14">Playlist</kbd> before we move on to update the <kbd class="calibre14">play()</kbd> method:</p>
<pre class="calibre23">    pub fn path(&amp;self) -&gt; Option&lt;String&gt; {
        self.current_song.borrow().clone()
    }</pre>
<p class="calibre3">This method returns a copy of the current song path. Since the field is a <kbd class="calibre14">RefCell</kbd>, we need to call <kbd class="calibre14">borrow()</kbd> in order to get access to the inner value. This method returns the equivalent of an immutable reference. We'll soon see how to have a mutable reference. As with <kbd class="calibre14">Mutex</kbd>, the borrow is lexical and the borrow will end at the end of the function. We're now ready to update the <kbd class="calibre14">play()</kbd> method:</p>
<pre class="calibre23">    pub fn play(&amp;self) -&gt; bool {
        if let Some(path) = self.selected_path() {
            if self.player.is_paused() &amp;&amp; Some(&amp;path) == <br class="calibre6"/>             self.path().as_ref() {
                self.player.resume();
            } else {
                self.player.load(&amp;path);
                *self.current_song.borrow_mut() = Some(path.into());
            }
            true
        } else {
            false
        }
    }</pre>
<p class="calibre3">We call <kbd class="calibre14">resume()</kbd> if the song was paused and if the selected path is the same as the currently playing song path. If this condition is <kbd class="calibre14">false</kbd>, we load the specified path and save this path in our field. To do so, we call <kbd class="calibre14">borrow_mut()</kbd> to get a mutable reference. Once again, we need to prefix the expression with <kbd class="calibre14">*</kbd> so that <kbd class="calibre14">DerefMut::deref_mut()</kbd> gets called. Run the project and you'll see that you can pause and resume the song.</p>
<p class="calibre3">Let's now add a way to stop the song. We'll start by adding a method to the <kbd class="calibre14">Player</kbd>, as usual:</p>
<pre class="calibre23">    pub fn stop(&amp;self) {
        self.paused.set(false);
        self.app_state.lock().unwrap().stopped = true;
        self.emit(Stop);
        self.set_playing(false);
    }</pre>
<p class="calibre3">We first set the <kbd class="calibre14">paused</kbd> field to <kbd class="calibre14">false</kbd> so that the playlist won't try to resume the song the next time the play button is clicked. We then set the <kbd class="calibre14">stopped</kbd> field to <kbd class="calibre14">true</kbd>, this will cause the next click of this button to play the song instead of trying to pause it. We then emit the <kbd class="calibre14">Stop</kbd> action to the event loop and indicate to the engine thread that it should not play music anymore.</p>
<p class="calibre3">The <kbd class="calibre14">emit</kbd> method is very simple:</p>
<pre class="calibre22">fn emit(&amp;self, action: Action) {
    self.event_loop.queue.push(action);
}</pre>
<p class="calibre3">It simply pushes the <kbd class="calibre14">action</kbd> in the queue of the event loop.</p>
<p class="calibre3">Let's now handle this <kbd class="calibre14">Stop</kbd> event:</p>
<pre class="calibre22">Stop =&gt; {
    source = None;
},</pre>
<p class="calibre3">We only reset the source to <kbd class="calibre14">None</kbd> because we won't need it anymore.</p>
<p class="calibre3">Then, we're ready to add a <kbd class="calibre14">stop()</kbd> method to the <kbd class="calibre14">Playlist</kbd>:</p>
<pre class="calibre23">    pub fn stop(&amp;self) {
        *self.current_song.borrow_mut() = None;
        self.player.stop();
    }</pre>
<p class="calibre3">We first reset the <kbd class="calibre14">current_song</kbd> field to <kbd class="calibre14">None</kbd> in such a way that the next call to <kbd class="calibre14">play()</kbd> won't attempt to resume the song. We then call the <kbd class="calibre14">stop()</kbd> method we created earlier.</p>
<p class="calibre3">We're now ready to use this new method by creating a new event handler for the stop button, add this code to the <kbd class="calibre14">connect_toolbar_events()</kbd> method:</p>
<pre class="calibre23">    let playlist = self.playlist.clone();
    let play_image = self.toolbar.play_image.clone();
    let cover = self.cover.clone();
    self.toolbar.stop_button.connect_clicked(move |_| {
        playlist.stop();
        cover.hide();
        set_image_icon(&amp;play_image, PLAY_ICON);
    });</pre>
<p class="calibre3">So, when we click stop, we call the <kbd class="calibre14">Playlist::stop()</kbd> method in order to stop playing the music. We also hide the cover and set back the play button to show the play icon. You can now try again in the music player to see this new feature in action.</p>
<p class="calibre3">Now let's add the actions for the two remaining buttons: previous and next.</p>
<p class="calibre3">We first need to create a new method in the <kbd class="calibre14">Playlist</kbd>:</p>
<pre class="calibre23">    pub fn next(&amp;self) -&gt; bool {
        let selection = self.treeview.get_selection();
        let next_iter =
            if let Some((_, iter)) = selection.get_selected() {
                if !self.model.iter_next(&amp;iter) {
                    return false;
                }
                Some(iter)
            }
            else {
                self.model.get_iter_first()
            };
        if let Some(ref iter) = next_iter {
            selection.select_iter(iter);
            self.play();
        }
        next_iter.is_some()
    }</pre>
<p class="calibre3">We start by getting the selection. Then we check whether an item is selected: in this case, we try to get the item after the selection. Otherwise, we get the first item on the list. Then, if we were able to get an item, we select it and start playing the song. We return whether we changed the selection or not.</p>
<p class="calibre3">The <kbd class="calibre14">previous()</kbd> method is similar:</p>
<pre class="calibre23">    pub fn previous(&amp;self) -&gt; bool {
        let selection = self.treeview.get_selection();
        let previous_iter =
            if let Some((_, iter)) = selection.get_selected() {
                if !self.model.iter_previous(&amp;iter) {
                    return false;
                }
                Some(iter)
            }
            else {
                self.model.iter_nth_child(None, max(0, <br class="calibre6"/>                 self.model.iter_n_children(None) <br class="calibre6"/>                - 1))
            };
        if let Some(ref iter) = previous_iter {
            selection.select_iter(iter);
            self.play();
        }
        previous_iter.is_some()
    }</pre>
<p class="calibre3">However, there's no <kbd class="calibre14">get_iter_last()</kbd> method, so we get the last element with <kbd class="calibre14">iter_nth_child()</kbd>.</p>
<p class="calibre3">This requires a new import statement to be added at the top of the file:</p>
<pre class="calibre22">use std::cmp::max;</pre>
<p class="calibre3">With these new methods, we're ready to handle the click events for the buttons. Let's start with the next button:</p>
<pre class="calibre22">let playlist = self.playlist.clone();
let play_image = self.toolbar.play_image.clone();
let cover = self.cover.clone();
self.toolbar.next_button.connect_clicked(move |_| {
    if playlist.next() {
        set_image_icon(&amp;play_image, PAUSE_ICON);
        set_cover(&amp;cover, &amp;playlist);
    }
});</pre>
<p class="calibre3">We simply call the <kbd class="calibre14">next()</kbd> method we just created and if a new song was selected, we update the icon of the play button and show the new cover. The previous button handler is exactly the same except that we call <kbd class="calibre14">previous()</kbd> instead:</p>
<pre class="calibre22">let playlist = self.playlist.clone();
let play_image = self.toolbar.play_image.clone();
let cover = self.cover.clone();
self.toolbar.previous_button.connect_clicked(move |_| {
    if playlist.previous() {
        set_image_icon(&amp;play_image, PAUSE_ICON);
        set_cover(&amp;cover, &amp;playlist);
    }
});</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Showing the progression of the song</h1>
                
            
            
                
<p class="calibre3">It would be nice to see the cursor moving when the song plays. Let's tackle this challenge right now.</p>
<p class="calibre3">We'll start by adding a method to our <kbd class="calibre14">Player</kbd> to get the duration of a song:</p>
<pre class="calibre22">use std::time::Duration;

    pub fn compute_duration&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; <br class="calibre6"/>     Option&lt;Duration&gt; {
        let file = File::open(path).unwrap();
        Mp3Decoder::compute_duration(BufReader::new(file))
    }</pre>
<p class="calibre3">We simply call the <kbd class="calibre14">compute_duration()</kbd> method we created earlier. Next, we'll modify the <kbd class="calibre14">Playlist</kbd> to call this function. But before we do so, we'll modify the <kbd class="calibre14">State</kbd> type from the <kbd class="calibre14">main</kbd> module to include additional information:</p>
<pre class="calibre22">use std::collections::HashMap;

struct State {
    current_time: u64,
    durations: HashMap&lt;String, u64&gt;,
    stopped: bool,
}</pre>
<p class="calibre3">We added a <kbd class="calibre14">current_time</kbd> field, which will contain how much time elapsed since the song started playing. We also store the duration of the songs in a <kbd class="calibre14">HashMap</kbd> so that we only compute it once for each path. We now need to update the initialization of the <kbd class="calibre14">State</kbd> in the <kbd class="calibre14">App</kbd> constructor:</p>
<pre class="calibre22">let current_time = 0;
let durations = HashMap::new();
let state = Arc::new(Mutex::new(State {
    current_time,
    durations,
    stopped: true,
}))<a class="calibre67">;</a></pre>
<p class="calibre3">Let's go back to the <kbd class="calibre14">Playlist</kbd>. It will now contain the <kbd class="calibre14">State</kbd> in its structure:</p>
<pre class="calibre22">pub struct Playlist {
    current_song: RefCell&lt;Option&lt;String&gt;&gt;,
    model: ListStore,
    player: Player,
    state: Arc&lt;Mutex&lt;State&gt;&gt;,
    treeview: TreeView,
}</pre>
<p class="calibre3">This should be reflected in its constructor:</p>
<pre class="calibre22">Playlist {
    current_song: RefCell::new(None),
    model,
    player: Player::new(state.clone()),
    state,
    treeview,
}</pre>
<p class="calibre3">Here, the <kbd class="calibre14">state</kbd> field was added. We'll now add a method that will compute the duration in another thread:</p>
<pre class="calibre22">use std::thread;
use to_millis;

    fn compute_duration(&amp;self, path: &amp;Path) {
        let state = self.state.clone();
        let path = path.to_string_lossy().to_string();
        thread::spawn(move || {
            if let Some(duration) = Player::compute_duration(&amp;path)<br class="calibre6"/>            {
                let mut state = state.lock().unwrap();
                state.durations.insert(path, to_millis(duration));
            }
        });
    }</pre>
<p class="calibre3">In the thread's closure, we compute the duration and when it's done, we lock the state to insert the duration in the <kbd class="calibre14">HashMap</kbd>. We compute the duration in another thread because it can take time and we don't want to block the user interface during this computation. We now call this method in <kbd class="calibre14">Playlist::add()</kbd>:</p>
<pre class="sourcecode">    pub fn add(&amp;self, path: &amp;Path) {
        self.compute_duration(path);

        // …
    }</pre>
<p class="calibre3">We'll update the <kbd class="calibre14">Adjustment</kbd> so that its upper value is <kbd class="calibre14">0.0</kbd> in the beginning:</p>
<pre class="calibre22">let adjustment = Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</pre>
<p class="calibre3">This is to avoid seeing the cursor moving too quickly when the duration is not yet computed.</p>
<p class="calibre3">Finally, we'll add the code to update the UI in the <kbd class="calibre14">App::connect_events()</kbd> method:</p>
<pre class="calibre22">use gtk::{AdjustmentExt, Continue};
use toolbar::{set_image_icon, PAUSE_ICON, PLAY_ICON};

    fn connect_events(&amp;self) {
        let playlist = self.playlist.clone();
        let adjustment = self.adjustment.clone();
        let state = self.state.clone();
        let play_image = self.toolbar.play_image.clone();
        gtk::timeout_add(100, move || {
            let state = state.lock().unwrap();
            if let Some(path) = playlist.path() {
                if let Some(&amp;duration) = state.durations.get(&amp;path) <br class="calibre6"/>                {
                    adjustment.set_upper(duration as f64);
                }
            }
            if state.stopped {
                set_image_icon(&amp;play_image, PLAY_ICON);
            } else {
                set_image_icon(&amp;play_image, PAUSE_ICON);
            }
            adjustment.set_value(state.current_time as f64);
            Continue(true)
        });
    }</pre>
<p class="calibre3">The <kbd class="calibre14">gtk::timeout_add()</kbd> method will be run every 100 milliseconds as long as its closure returns <kbd class="calibre14">Continue(false)</kbd>. This closure starts by checking whether the duration is in the <kbd class="calibre14">HashMap</kbd>, and sets the upper value of the cursor as this duration. If the value is not in the <kbd class="calibre14">HashMap</kbd>, it means it wasn't computed yet. After that, we check whether the <kbd class="calibre14">stopped</kbd> field is true, that means the song ended and the engine thread is no longer playing it. In this case, we want to show the play icon. If the song is still playing, we show the pause icon. Finally, we set the current value of the cursor from the <kbd class="calibre14">current_time</kbd> field.</p>
<p class="calibre3">The cursor will now move automatically as the song plays. Here's how the player looks now:</p>
<div><img src="img/00038.jpeg" class="calibre36"/><br class="calibre6"/>
<em class="calibre21">Figure 6.1</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Improving CPU usage</h1>
                
            
            
                
<p class="calibre3">One issue you may have noticed is that when no song is playing, the software will use 100% of the CPU. This is because of the infinite loop in the music engine thread. It will do nothing except loop when the song is paused or when there's no song to play. Let's now fix this issue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Condition variable</h1>
                
            
            
                
<p class="calibre3">What we want to do is to make the thread sleep when it has nothing to do. We also want to be able to wake the thread up from the main thread. This is exactly what condition variables are for. So, let's add one to our engine. We'll start by adding a <kbd class="calibre14">condition_variable</kbd> field to the <kbd class="calibre14">EventLoop</kbd>:</p>
<pre class="calibre22">struct EventLoop {
    condition_variable: Arc&lt;(Mutex&lt;bool&gt;, Condvar)&gt;,
    queue: Arc&lt;SegQueue&lt;Action&gt;&gt;,
    playing: Arc&lt;Mutex&lt;bool&gt;&gt;,
}</pre>
<p class="calibre3">A condition variable is usually used together with a Boolean value (wrapped in a <kbd class="calibre14">Mutex</kbd>). We need to rewrite the constructor of <kbd class="calibre14">EventLoop</kbd> to initialize this new field:</p>
<pre class="calibre22">impl EventLoop {
    fn new() -&gt; Self {
        EventLoop {
            condition_variable: Arc::new((Mutex::new(false), Condvar::new())),
            queue: Arc::new(SegQueue::new()),
            playing: Arc::new(Mutex::new(false)),
        }
    }
}</pre>
<p class="calibre3">Next, we need to block the thread when it has nothing to do. Here's the start of the new code of the thread in <kbd class="calibre14">Player::new()</kbd>:</p>
<pre class="calibre22">{
    let app_state = app_state.clone();
    let event_loop = event_loop.clone();
    let condition_variable = event_loop.condition_variable.clone();
    thread::spawn(move || {
        let block = || {
            let (ref lock, ref condition_variable) = <br class="calibre6"/>             *condition_variable;
            let mut started = lock.lock().unwrap();
            *started = false;
            while !*started {
                started =<br class="calibre6"/>                 condition_variable.wait(started).unwrap();
            }
        };</pre>
<p class="calibre3">We create a copy of the condition variable and we move this copy into the thread. Then, in the beginning of the closure, we lock the Boolean value associated with the condition variable to set it to <kbd class="calibre14">false</kbd>. Afterward, we loop: while this value is <kbd class="calibre14">false</kbd>, we block the current thread. We created a closure instead of a normal function because normal functions cannot capture values. The following code is the same as before:</p>
<pre class="calibre23">        let mut buffer = [[0; 2]; BUFFER_SIZE];
        let mut playback = Playback::new("MP3", "MP3 Playback", None, <br class="calibre6"/>         DEFAULT_RATE);
        let mut source = None;
        loop {
            if let Some(action) = event_loop.queue.try_pop() {
                match action {
                    Load(path) =&gt; {
                        let file = File::open(path).unwrap();
                        source = <br class="calibre6"/>                         Some(Mp3Decoder::new(BufReader::new(file)).unwrap());
                        let rate = source.as_ref().map(|source| <br class="calibre6"/>                         source.samples_rate()).unwrap_or(DEFAULT_RATE);
                        playback = Playback::new("MP3", "MP3 Playback", <br class="calibre6"/>                         None, rate);
                        app_state.lock().unwrap().stopped = false;
                    },
                    Stop =&gt; {
                        source = None;
                    },
                }
            } else if *event_loop.playing.lock().unwrap() {
                let mut written = false;
                if let Some(ref mut source) = source {
                    let size = iter_to_buffer(source, &amp;mut buffer);
                    if size &gt; 0 {
                        app_state.lock().unwrap().current_time = <br class="calibre6"/>                         source.current_time();
                        playback.write(&amp;buffer[..size]);
                        written = true;
                    }
                }</pre>
<p class="calibre3">But the rest of the closure is a bit different:</p>
<pre class="calibre22">                if !written {
                    app_state.lock().unwrap().stopped = true;
                    *event_loop.playing.lock().unwrap() = false;
                    source = None;
                    block();
                }
            } else {
                block();
            }
        }
    });
}</pre>
<p class="calibre3">If the player was unable to play song (that is, the song came into an end), we call the closure to block the thread. We also block the thread if the player is paused. With the condition variable, the software stopped using 100% CPU.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Showing the song's current time</h1>
                
            
            
                
<p class="calibre3">Currently, we only display the progression of the song. The user has no way to know the duration and for how many seconds the song has been playing. Let's fix that by adding labels that will show the current time and the duration.</p>
<p class="calibre3">We'll need two new import statements in the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">use gtk::{Label, LabelExt};</pre>
<p class="calibre3">We'll also add two <kbd class="calibre14">label</kbd> in our <kbd class="calibre14">App</kbd> structure:</p>
<pre class="calibre22">struct App {
    adjustment: Adjustment,
    cover: Image,
    current_time_label: Label,
    duration_label: Label,
    playlist: Rc&lt;Playlist&gt;,
    state: Arc&lt;Mutex&lt;State&gt;&gt;,
    toolbar: MusicToolbar,
    window: Window,
}</pre>
<p class="calibre3">One <kbd class="calibre14">label</kbd> for the current time and the other for the duration. Since we want to show the different <kbd class="calibre14">label</kbd> on the right of the cursor, we'll create a horizontal box, this code should be added in <kbd class="calibre14">App::new()</kbd>:</p>
<pre class="calibre22">let hbox = gtk::Box::new(Horizontal, 10);
vbox.add(&amp;hbox);

let adjustment = Adjustment::new(0.0, 0.0, 10.0, 0.0, 0.0, 0.0);
let scale = Scale::new(Horizontal, &amp;adjustment);
scale.set_draw_value(false);
scale.set_hexpand(true);
hbox.add(&amp;scale);</pre>
<p class="calibre3">The <kbd class="calibre14">Scale</kbd> widget is now added to <kbd class="calibre14">hbox</kbd> instead of <kbd class="calibre14">vbox</kbd>. And we call <kbd class="calibre14">set_hexpand()</kbd> so that the widget takes as much horizontal space as possible.</p>
<p class="calibre3">We're now ready to create our <kbd class="calibre14">label</kbd>'s:</p>
<pre class="calibre22">let current_time_label = Label::new(None);
hbox.add(&amp;current_time_label);

let slash_label = Label::new("/");
hbox.add(&amp;slash_label);

let duration_label = Label::new(None);
duration_label.set_margin_right(10);
hbox.add(&amp;duration_label);</pre>
<p class="calibre3">We create three <kbd class="calibre14">label</kbd>; the third one being a separator. We set a right margin to the last <kbd class="calibre14">label</kbd> so that it is not too close to the border of the window. Further, in the <kbd class="calibre14">App</kbd> constructor, we need to update the initialization of the structure:</p>
<pre class="calibre22">let app = App {
    adjustment,
    cover,
    current_time_label,
    duration_label,
    playlist,
    state,
    toolbar,
    window,
}<a class="calibre67">;</a></pre>
<p class="calibre3">We added the two <kbd class="calibre14">label</kbd>.</p>
<p class="calibre3">We'll create a function to convert a number of milliseconds to a <kbd class="calibre14">String</kbd> of the <kbd class="calibre14">minute:second</kbd> format:</p>
<pre class="calibre22">fn millis_to_minutes(millis: u64) -&gt; String {
    let mut seconds = millis / 1_000;
    let minutes = seconds / 60;
    seconds %= 60;
    format!("{}:{:02}", minutes, seconds)
}</pre>
<p class="calibre3">In this function, we first convert the milliseconds to seconds by dividing by one thousand. We then get the number of minutes by dividing the seconds by <kbd class="calibre14">60</kbd>. Afterward, we compute the number of seconds that are not included in the minutes with the modulo operation. Finally, we format the minutes and seconds as a <kbd class="calibre14">String</kbd>. As you can see, we used a special <kbd class="calibre14">{:02}</kbd> formatter. The <kbd class="calibre14">2</kbd> means that we want to print the number as two characters, even if the number is less than 0. The <kbd class="calibre14">0</kbd> after the colon indicates that we want to prepend <kbd class="calibre14">0</kbd> instead of spaces.</p>
<p class="calibre3">With this new function, we can rewrite the timer to update (in the method <kbd class="calibre14">App::connect_events()</kbd>) the <kbd class="calibre14">label</kbd>'s:</p>
<pre class="calibre22">let current_time_label = self.current_time_label.clone();
let duration_label = self.duration_label.clone();
let playlist = self.playlist.clone();
let adjustment = self.adjustment.clone();
let state = self.state.clone();
let play_image = self.toolbar.play_image.clone();
gtk::timeout_add(100, move || {
    let state = state.lock().unwrap();
    if let Some(path) = playlist.path() {
        if let Some(&amp;duration) = state.durations.get(&amp;path) {
            adjustment.set_upper(duration as f64);
            duration_label.set_text(&amp;millis_to_minutes(duration));
        }
    }
    if state.stopped {
        set_image_icon(&amp;play_image, PLAY_ICON);
    } else {
        set_image_icon(&amp;play_image, PAUSE_ICON);
        current_time_label.set_text(&amp;millis_to_minutes(state.current_time));
    }
    adjustment.set_value(state.current_time as f64);
    Continue(true)
});</pre>
<p class="calibre3">Here are the changes from the previous version. When we get the duration, we update the duration <kbd class="calibre14">label</kbd>. And when the song is not stopped (that is, when it is playing), we update the current time <kbd class="calibre14">label</kbd>.</p>
<p class="calibre3">We need to change the stop button handler so that it resets the text of these <kbd class="calibre14">label</kbd>'s.</p>
<p class="calibre3">Finally, we can update the handler:</p>
<pre class="calibre22">let current_time_label = self.current_time_label.clone();
let duration_label = self.duration_label.clone();
let playlist = self.playlist.clone();
let play_image = self.toolbar.play_image.clone();
let cover = self.cover.clone();
self.toolbar.stop_button.connect_clicked(move |_| {
    current_time_label.set_text("");
    duration_label.set_text("");
    playlist.stop();
    cover.hide();
    set_image_icon(&amp;play_image, PLAY_ICON);
});</pre>
<p class="calibre3">We clone the widgets to move them into the closure and set the text of the <kbd class="calibre14">label</kbd>'s to the empty string.</p>
<p class="calibre3">Here's the result you should see when running the application:</p>
<div><img src="img/00039.jpeg" class="calibre68"/></div>
<div><em class="calibre21">Figure 6.2</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Loading and saving the playlist</h1>
                
            
            
                
<p class="calibre3">We have the ability to create a playlist in our music player, but we cannot save a playlist to a file in order to be able to load one later. Let's add this feature to our project.</p>
<p class="calibre3">We'll save the playlist in the <kbd class="calibre14">m3u</kbd> file format and to handle this format, we'll use the <kbd class="calibre14">m3u</kbd> crate. So let's add it to our <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">m3u = "^1.0.0"</pre>
<p class="calibre3">Add this line to the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">extern crate m3u;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Saving a playlist</h1>
                
            
            
                
<p class="calibre3">We'll start by adding a button to save the playlist. First, we add a field in the <kbd class="calibre14">MusicToolbar</kbd> structure for the button:</p>
<pre class="calibre22">pub struct MusicToolbar {
    open_button: ToolButton,
    next_button: ToolButton,
    play_button: ToolButton,
    pub play_image: Image,
    previous_button: ToolButton,
    quit_button: ToolButton,
    remove_button: ToolButton,
    save_button: ToolButton,
    stop_button: ToolButton,
    toolbar: Toolbar,
}</pre>
<p class="calibre3">And in the constructor, we'll create this button:</p>
<pre class="calibre22">impl MusicToolbar {
    pub fn new() -&gt; Self {
        let toolbar = Toolbar::new();

        let (open_button, _) = new_tool_button("document-open");
        toolbar.add(&amp;open_button);

        let (save_button, _) = new_tool_button("document-save");
        toolbar.add(&amp;save_button);

        toolbar.add(&amp;SeparatorToolItem::new());

        // …

        let toolbar = MusicToolbar {
            open_button,
            next_button,
            play_button,
            play_image,
            previous_button,
            quit_button,
            remove_button,
            save_button,
            stop_button,
            toolbar
        };

        toolbar
    }
}</pre>
<p class="calibre3">Next, we'll add a <kbd class="calibre14">save</kbd> method in the <kbd class="calibre14">Playlist</kbd> structure:</p>
<pre class="calibre22">use std::fs::File;

use m3u;

    pub fn save(&amp;self, path: &amp;Path) {
        let mut file = File::create(path).unwrap();
        let mut writer = m3u::Writer::new(&amp;mut file);

        let mut write_iter = |iter: &amp;TreeIter| {
            let value = self.model.get_value(&amp;iter, PATH_COLUMN as<br class="calibre6"/>              i32);
            let path = value.get::&lt;String&gt;().unwrap();
            writer.write_entry(&amp;m3u::path_entry(path)).unwrap();
        };

        if let Some(iter) = self.model.get_iter_first() {
            write_iter(&amp;iter);
            while self.model.iter_next(&amp;iter) {
                write_iter(&amp;iter);
            }
        }
    }</pre>
<p class="calibre3">Here, we first create a <kbd class="calibre14">m3u::Writer</kbd> with a <kbd class="calibre14">File</kbd> that we've created. This writer will be used to write the entry to the file. We create a closure that gets the path from an iterator of our <kbd class="calibre14">TreeView</kbd> and writes this path to the file. We chose to create a closure to avoid repeating the code, as we'll need this code twice. After that, we get the first iterator and write its contents before looping until there's no more row in the view.</p>
<p class="calibre3">We're now ready to call this code. First, we'll create a function in the module toolbar to show a save file dialog. It is similar to the <kbd class="calibre14">show_open_dialog()</kbd> function we wrote in the previous chapter:</p>
<pre class="calibre22">fn show_save_dialog(parent: &amp;ApplicationWindow) -&gt; Option&lt;PathBuf&gt; {
    let mut file = None;
    let dialog = FileChooserDialog::new(Some("Choose a destination <br class="calibre6"/>     M3U playlist  <br class="calibre6"/>    file"), Some(parent), FileChooserAct    ion::Save);
    let filter = FileFilter::new();
    filter.add_mime_type("audio/x-mpegurl");
    filter.set_name("M3U playlist file");
    dialog.set_do_overwrite_confirmation(true);
    dialog.add_filter(&amp;filter);
    dialog.add_button("Cancel", RESPONSE_CANCEL);
    dialog.add_button("Save", RESPONSE_ACCEPT);
    let result = dialog.run();
    if result == RESPONSE_ACCEPT {
        file = dialog.get_filename();
    }
    dialog.destroy();
    file
}</pre>
<p class="calibre3">Here, we use the <kbd class="calibre14">FileChooserAction::Save</kbd> type instead of <kbd class="calibre14">FileChooserAction::Open</kbd>. We use a different filter and mime type. We also call <kbd class="calibre14">set_do_overwrite_confirmation()</kbd> which is very important. It will ask for a confirmation if the user asks to overwrite a file. The rest of the function is exactly the same as the one to open a file, except that the <kbd class="calibre14">label</kbd> of the button is now <kbd class="calibre14">Save</kbd>.</p>
<p class="calibre3">We can now use this function in the event handler of the save button:</p>
<pre class="calibre22">let parent = self.window.clone();
let playlist = self.playlist.clone();
self.toolbar.save_button.connect_clicked(move |_| {
    let file = show_save_dialog(&amp;parent);
    if let Some(file) = file {
        playlist.save(&amp;file);
    }
});</pre>
<p class="calibre3">We simply call the function <kbd class="calibre14">show_save_dialog()</kbd> and give the resulting file to the <kbd class="calibre14">Playlist::save()</kbd> method. You can now try to save a playlist in the application:</p>
<div><img src="img/00040.jpeg" class="calibre36"/></div>
<div><em class="calibre21">Figure 6.3</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Loading a playlist</h1>
                
            
            
                
<p class="calibre3">We can save playlists, but still cannot load them. Let's start by adding a <kbd class="calibre14">load()</kbd> method to <kbd class="calibre14">Playlist</kbd>:</p>
<pre class="calibre23">    pub fn load(&amp;self, path: &amp;Path) {
        let mut reader = m3u::Reader::open(path).unwrap();
        for entry in reader.entries() {
            if let Ok(m3u::Entry::Path(path)) = entry {
                self.add(&amp;path);
            }
        }
    }</pre>
<p class="calibre3">Here, we create a <kbd class="calibre14">m3u::Reader</kbd> with the specified path. We loop over the entry and if we were able to retrieve a <kbd class="calibre14">m3u::Entry::Path</kbd>, we add it to the playlist widget.</p>
<p class="calibre3">We'll now modify the open dialog to allow selecting <kbd class="calibre14">M3U</kbd> files:</p>
<pre class="calibre22">fn show_open_dialog(parent: &amp;ApplicationWindow) -&gt; Option&lt;PathBuf&gt; {
    let mut file = None;
    let dialog = FileChooserDialog::new(Some("Select an MP3 audio file"), <br class="calibre6"/>    Some(parent), FileChooserAction::Open);

    let mp3_filter = FileFilter::new();
    mp3_filter.add_mime_type("audio/mp3");
    mp3_filter.set_name("MP3 audio file");
    dialog.add_filter(&amp;mp3_filter);

    let m3u_filter = FileFilter::new();
    m3u_filter.add_mime_type("audio/x-mpegurl");
    m3u_filter.set_name("M3U playlist file");
    dialog.add_filter(&amp;m3u_filter);

    dialog.add_button("Cancel", RESPONSE_CANCEL);
    dialog.add_button("Accept", RESPONSE_ACCEPT);
    let result = dialog.run();
    if result == RESPONSE_ACCEPT {
        file = dialog.get_filename();
    }
    dialog.destroy();
    file
}</pre>
<p class="calibre3">We'll now change the open button event handler to select which action to do depending on the file type:</p>
<pre class="sourcecode">impl App {
    pub fn connect_toolbar_events(&amp;self) {
        let parent = self.window.clone();
        let playlist = self.playlist.clone();
        self.toolbar.open_button.connect_clicked(move |_| {
            let file = show_open_dialog(&amp;parent);
            if let Some(file) = file {
                if let Some(ext) = file.extension() {
                    match ext.to_str().unwrap() {
                        "mp3" =&gt; playlist.add(&amp;file),
                        "m3u" =&gt; playlist.load(&amp;file),
                        extension =&gt; {
                            let dialog = <br class="calibre6"/>                             MessageDialog::new(Some(&amp;parent),  <br class="calibre6"/>                             DialogFlags::empty(), MessageType::Error,
                                ButtonsType::Ok, &amp;format!("Cannot open <br class="calibre6"/>                                 file with <br class="calibre6"/>                                 extension .{}", extension));
                            dialog.run();
                            dialog.destroy();
                        },
                    }
                }
            }
        });

        // …
    }
}</pre>
<p class="calibre3">This requires a couple of new import statements:</p>
<pre class="calibre22">use gtk::{
    ButtonsType,
    DialogFlags,
    MessageDialog,
    MessageType,
};</pre>
<p class="calibre3">This new event handler now checks the file extension, if it is <kbd class="calibre14">mp3</kbd>, it will call the <kbd class="calibre14">Playlist::add()</kbd> method as we were doing earlier. If it is <kbd class="calibre14">m3u</kbd>, we call our new <kbd class="calibre14">Playlist::load()</kbd> method. Otherwise, we show an error message to the user:</p>
<div><img src="img/00041.jpeg" class="calibre69"/></div>
<div><em class="calibre21">Figure 6.4</em></div>
<p class="calibre3">You can now try to load a playlist in our music player, don't forget to change the filter in order to see M3U files in the dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using gstreamer for playback</h1>
                
            
            
                
<p class="calibre3">Implementing an engine to play music was a good exercise to learn about threading. However, for a real program, you could simply use <kbd class="calibre14">gstreamer</kbd> for the music playback. So, let's see how to use this library in our music player.</p>
<p class="calibre3">Remove the following dependencies in your <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre22">crossbeam = "^0.3.0"
pulse-simple = "^1.0.0"
simplemad = "^0.8.1"</pre>
<p class="calibre3">And remove their corresponding <kbd class="calibre14">extern crate</kbd> statements. We can also remove the <kbd class="calibre14">mp3</kbd> and <kbd class="calibre14">player</kbd> modules as we'll use <kbd class="calibre14">gstreamer</kbd> instead. Now, we can add our dependencies for <kbd class="calibre14">gstreamer</kbd>:</p>
<pre class="calibre22">gstreamer = "^0.9.1"
gstreamer-player = "^0.9.0"</pre>
<p class="calibre3">And add their corresponding <kbd class="calibre14">extern crate</kbd> statements:</p>
<pre class="calibre22">extern crate gstreamer as gst;
extern crate gstreamer_player as gst_player;</pre>
<p class="calibre3">At the beginning of the <kbd class="calibre14">main</kbd> function, we need to initialize <kbd class="calibre14">gstreamer</kbd>:</p>
<pre class="calibre22">gst::init().expect("gstreamer initialization failed");</pre>
<p class="calibre3">We no longer need our <kbd class="calibre14">State</kbd> structure, so we remove it and the <kbd class="calibre14">state</kbd> field in the <kbd class="calibre14">App</kbd> structure. And now, we can update our <kbd class="calibre14">playlist</kbd> module. First, let's add a few <kbd class="calibre14">use</kbd> statements:</p>
<pre class="calibre22">use gst::{ClockTime, ElementExt};
use gst_player;
use gtk::Cast;</pre>
<p class="calibre3">We remove the <kbd class="calibre14">state</kbd> field and update the <kbd class="calibre14">player</kbd> one in the <kbd class="calibre14">Playlist</kbd> structure:</p>
<pre class="calibre22">pub struct Playlist {
    current_song: RefCell&lt;Option&lt;String&gt;&gt;,
    model: ListStore,
    player: gst_player::Player,
    treeview: TreeView,
}</pre>
<p class="calibre3">The <kbd class="calibre14">Playlist</kbd> constructor does not need the <kbd class="calibre14">state</kbd> anymore:</p>
<pre class="calibre22">impl Playlist {
    pub(crate) fn new() -&gt; Self {
        let model = ListStore::new(&amp;[
            Pixbuf::static_type(),
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Pixbuf::static_type(),
        ]);
        let treeview = TreeView::new_with_model(&amp;model);
        treeview.set_hexpand(true);
        treeview.set_vexpand(true);

        Self::create_columns(&amp;treeview);

        let dispatcher = gst_player::PlayerGMainContextSignalDispatcher::new(None);
        let player = gst_player::Player::new(None,<br class="calibre6"/>        Some(&amp;dispatcher.upcast:: <br class="calibre6"/>        &lt;gst_player::PlayerSignalDispatcher&gt;<br class="calibre6"/>        ()));

        Playlist {
            current_song: RefCell::new(None),
            model,
            player,
            treeview,
        }
    }
}</pre>
<p class="calibre3">Here, we create the <kbd class="calibre14">Player</kbd> from the <kbd class="calibre14">gstreamer</kbd> crate. We need to remove the <kbd class="calibre14">compute_duration()</kbd> method and all its uses because we'll use <kbd class="calibre14">gstreamer</kbd> to get the song's duration:</p>
<pre class="sourcecode">    pub fn get_duration(&amp;self) -&gt; ClockTime {
        self.player.get_duration()
    }

    pub fn get_current_time(&amp;self) -&gt; ClockTime {
        self.player.get_position()
    }

    pub fn is_playing(&amp;self) -&gt; bool {
        self.player.get_pipeline()
            .map(|element| element.get_state(gst::CLOCK_TIME_NONE).1 == <br class="calibre6"/>             gst::State::Playing)
            .unwrap_or(false)
    }</pre>
<p class="calibre3">Here, we create a few methods that will be useful to show the time and when the song is playing. Finally, we can update the <kbd class="calibre14">play()</kbd> method to use <kbd class="calibre14">gstreamer</kbd> instead:</p>
<pre class="sourcecode">    pub fn play(&amp;self) -&gt; bool {
        if self.selected_path() == self.player.get_uri() {
            self.player.play();
            return false;
        }
        if let Some(path) = self.selected_path() {
            let uri = format!("file://{}", path);
            self.player.set_uri(&amp;uri);
            self.player.play();
            true
        } else {
            false
        }
    }</pre>
<p class="calibre3">Let's go back to the <kbd class="calibre14">main</kbd> module to update the creation of the playlist:</p>
<pre class="calibre22">let playlist = Rc::new(Playlist::new());</pre>
<p class="calibre3">One more thing to update is the code to show the current time:</p>
<pre class="calibre22">gtk::timeout_add(100, move || {
    let duration = playlist.get_duration();
    adjustment.set_upper(duration.nanoseconds().unwrap_or(0) as<br class="calibre6"/>    f64);
    duration_label.set_text(&amp;format!("{:.0}", duration));

    let current_time = playlist.get_current_time();
    if !playlist.is_playing() {
        set_image_icon(&amp;play_image, PLAY_ICON);
    } else {
        set_image_icon(&amp;play_image, PAUSE_ICON);
        current_time_label.set_text(&amp;format!("{:.0}", <br class="calibre6"/>         current_time));
    }
    adjustment.set_value(current_time.nanoseconds().unwrap_or(0) as f64);
    Continue(true)
});</pre>
<p class="calibre3">We now use the methods we created a bit earlier and some from <kbd class="calibre14">gstreamer</kbd>.</p>
<p class="calibre3">Finally, we update the <kbd class="calibre14">toolbar</kbd> module. First, the <kbd class="calibre14">play_button</kbd> event handler:</p>
<pre class="calibre22">self.toolbar.play_button.connect_clicked(move |_| {
    if !playlist.is_playing() {
        if playlist.play() {
            set_image_icon(&amp;play_image, PAUSE_ICON);
            set_cover(&amp;cover, &amp;playlist);
        }
    } else {
        playlist.pause();
        set_image_icon(&amp;play_image, PLAY_ICON);
    }
});</pre>
<p class="calibre3">We now use the <kbd class="calibre14">is_playing()</kbd> method instead of the <kbd class="calibre14">state</kbd>. Let's also remove the <kbd class="calibre14">FileFilter</kbd> from the <kbd class="calibre14">show_open_dialog()</kbd> function because <kbd class="calibre14">gstreamer</kbd> supports more formats than just <kbd class="calibre14">MP3</kbd>. And to be able to open them, we need to update the <kbd class="calibre14">open_button</kbd> event handler:</p>
<pre class="calibre22">self.toolbar.open_button.connect_clicked(move |_| {
    let file = show_open_dialog(&amp;parent);
    if let Some(file) = file {
        if let Some(ext) = file.extension() {
            match ext.to_str().unwrap() {
                "mp3" | "ogg" =&gt; playlist.add(&amp;file),
                "m3u" =&gt; playlist.load(&amp;file),
                extension =&gt; {
                    let dialog = MessageDialog::new(Some(&amp;parent), <br class="calibre6"/>                     DialogFlags::empty(), MessageType::Error,
                      ButtonsType::Ok, &amp;format!("Cannot open file <br class="calibre6"/>                       with extension . {}", extension));
                    dialog.run();
                    dialog.destroy();
                },
            }
        }
    }
});</pre>
<p class="calibre3">Here, we only added the <kbd class="calibre14">ogg</kbd> format, but you can also add other formats.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">This chapter started by showing you how to decode MP3 data with the <kbd class="calibre14">simplemad</kbd> crate. You then learned how to write a music engine, this showed you how to use threads and different threading objects such as <kbd class="calibre14">Mutex</kbd>, lock-free data structures, and condition variables. You also learned how Rust can ensure thread safety. You also saw how to mutable the fields of a value when you have an immutable reference with interior mutability. During the whole chapter, we added the missing features to the music player such as play, pause, previous, and next song.</p>
<p class="calibre3">In the next chapter, we'll improve the modularity of the music player by rewriting it with the <kbd class="calibre14">relm</kbd> crate.</p>


            

            
        
    </body></html>