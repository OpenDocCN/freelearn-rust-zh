- en: Finding Stuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The issue with searching for *something* is always directly related to the
    space in which you are searching. You will certainly have experienced looking
    for your keys in your house: the search space contains anything from jackets worn
    the previous day to the sock drawer into which the key might have slipped the
    last time you did the washing. Upon finding the item (and after a lot of wasted
    time spent running up and down stairs and searching in various rooms), you then
    swear to keep things tidier in the future....'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have encountered this issue more often than we are comfortable with admitting,
    but it illustrates a fundamental issue that we can solve algorithmically without
    any particular order to build on. In this chapter, we''ll explore how to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding items in an unordered array of chaos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a trade-off between preparation and search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the best
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The search domain is present on various levels of abstraction: finding a word
    in a body of text is typically more complex than simply calling the `contains()`
    function, and if there are several results, which is the one that was searched
    for? This entire class of problem is summed up under the umbrella of **information
    retrieval**, where problems of ranking, indexing, understanding, storing, and
    searching are solved in order to retrieve the optimum result (for all definitions).
    This chapter focuses only on the latter part, where we actually look through a
    collection of items (for example, an index) in order to find a match.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we will compare items directly (*a == b*) to determine closeness,
    rather than using something such as a distance - or locally-sensitive hashing
    function. These can be found in more specific domains such as a fuzzy search or
    matching bodies of text, which is a field of its own. To learn more about hashing,
    please check out [Chapter 6](95653045-6e1c-4ef7-bd0c-8e45b1ccfa1d.xhtml), *Exploring
    Maps and Sets* or the *Further reading* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off with the most naive implementation, let's look at linear searches.
  prefs: []
  type: TYPE_NORMAL
- en: Linear searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linear searching is a fancy name for something that we do in almost every program
    and our everyday lives: going through a collection of items to find the first
    match. There is no need for any preprocessing or similar steps; the collection
    can be used as-is, which means that standard libraries commonly provide a generic
    implementation already. In Rust''s case, the iterator trait offers this feature
    with functions called `position()` (or `rposition()`), `find()`, `filter()`, or
    even `any()`. `fold()` can also be used to find the thing you are looking for.
    The following is a diagram of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0e2e878-c1f8-48ee-a94f-b4222c8b5f1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fundamentally, however, it''s a loop over each item that either exits or collects
    all items where a predicate (an evaluation function that takes in an item of a
    type to return a Boolean value) matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm obviously exhibits *O(n)* runtime complexity, growing with the
    collection size. Iterating over 10,000 items will take a while, even if the predicate
    executes quickly, so how can this strategy be improved?
  prefs: []
  type: TYPE_NORMAL
- en: Jump search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going linearly over a collection one-by-one is only efficient if you are already
    close to a potential match, but it is very hard to determine—what does *close
    to a match* mean? In unordered collections, this is indeed impossible to know
    this since any item can follow. Consequently, what about sorting the collection
    first? As discussed in [Chapter 9](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml),
    *Ordering Things*, sorting at quasi-linear runtime complexity can be significantly
    faster than going over each item of a long collection past a certain size.
  prefs: []
  type: TYPE_NORMAL
- en: 'A jump search makes use of knowing about the range it jumps over, not unlike
    a skip list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb372dc5-b290-4553-92cf-5d71d9621ef3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After sorting, a search can be significantly faster and a number of elements
    can be skipped in order to search in a linear fashion once the algorithm is close
    to a match. How many elements can be skipped at each jump? This is something to
    be tested, but first here is the code that does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The API expects a pre-sorted slice, which means that sorting, strictly speaking,
    is not part of the algorithm's runtime. Without the sorting, the runtime complexity
    might be something around *O(n / k + k)*, with k being the step size, which can
    be reduced to *O(n)* in a worst-case scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Including the sorting mechanism, the sorting algorithm will trump the search's
    runtime complexity easily, raising it to *O(n log n)*. While various choices for
    the jumps can improve the absolute runtime of this search algorithm by a significant
    amount, it will not perform as well as something like a tree structure. Binary
    searching as a strategy achieves that nicely, however.
  prefs: []
  type: TYPE_NORMAL
- en: Binary searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary trees greatly reduce the number of comparison operations by creating
    branches from the collection, just like a binary tree would. This creates a tree
    on-the-fly, resulting in superior search performance. The significance is predictability,
    which allows us to build the tree and provides the options for what branch the
    algorithm can expect the result in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary search, just like a jump search, requires the incoming slice to be
    ordered for it to work. Then the algorithm splits the array in half and chooses
    the side that will most likely contain the item. Once there are two collections,
    the behavior is very similar to that of a binary tree walk, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a76371f-cf74-4e75-915c-3c4793b9bf10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, given that the sorting effort trumps the algorithm''s runtime complexity,
    it''s that of the sorting algorithm that will be considered the outcome: *O(n
    log n)*. However, we should also be interested in the real performance, if the
    collection is already sorted; it''s significantly lower! First, let''s look at
    some code to make this easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the recursive implementation of the algorithm would have worked too, though
    it is not significantly shorter it harbors the risk of a stack overflow, hence
    the iterative approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing a pivot (center) element, the algorithm has to determine the
    collection for the next iteration by one of the following three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The left part containing smaller values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right chunk with larger values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not at all; the pivot element is the result too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tree-like behavior allows for a great runtime complexity of *O(log n)*,
    since the number of items searched keeps halving until the desired element has
    been found. However, how does all this compare?
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three approaches differ somewhat, with the binary search being the established
    state-of-the-art type algorithm. In fact, it can be used on any Rust slices (if
    they are sorted, of course) and used to find whatever is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing these algorithms is tricky: a linear search works well on unordered
    datasets and is the only way to search those if sorting is not an option. If sorting
    is an option, then a binary search is faster by a large margin (`asc` is the sorting
    direction: ascending):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When plotted, the difference is clearly visible, with the linear search showing
    its linear characteristics. Taking the absolute runtime out of the game will show
    the runtime complexity as well, as demonstrated in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25c07135-7660-498b-8709-5bfab286bfee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chart shows the relative behavior of each algorithm in order to show its
    runtime complexities: a binary search with *O(log n)*, a linear search with *O(n)*,
    and a jump search, which is almost linear because of the parameter choice (the
    jump size is one-third of the length of the array):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ab2b266-cb10-45c6-b21a-adbece5d85bd.png)'
  prefs: []
  type: TYPE_IMG
- en: And that is it—a short introduction to search algorithms. Typically, it's more
    about the data, and having some way to sort beforehand creates a powerful opportunity
    to quickly find the item you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Search, as a part of the information retrieval (among others) process, is an
    elementary way of finding something independently of the data structure being
    used. There are three popular types of algorithm: linear search, jump search,
    and binary search. Completely different approaches (such as locally-sensitive
    hashing) have been discussed in an earlier chapter about maps and sets, but they
    still need a mechanism to compare quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A linear search is the least complex approach: iterate over a collection and
    compare the items with the element that is to be found. This has also been implemented
    in Rust''s iterator and exhibits *O(n)* runtime complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: Jump searches are superior. By operating on a sorted collection, they can use
    a step size that is greater than 1 (like a linear search) in order to skip to
    the required parts faster by checking whether the relevant section has already
    passed. While faster in absolute terms, the worst-case runtime complexity is still
    *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: The (at the time of writing) fastest approach is a binary search, which also
    operates on a sorted collection and repeatedly splits the desired sections in
    half to work with a tree-like strategy. In fact, the runtime complexity of the
    algorithm itself is *O(log n)* as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore some more exotic algorithms: backtracking,
    random number generation, and more!'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is information retrieval?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do modern search engines and databases use simple search algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do linear searches have *O(n)* runtime complexity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a jump search do better than a linear search?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a binary search and why is it comparable to a tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter: [https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357/8643](https://www.aaai.org/ocs/index.php/AAAI/AAAI14/paper/view/8357).'
  prefs: []
  type: TYPE_NORMAL
