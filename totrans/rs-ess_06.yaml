- en: Chapter 6. Pointers and Memory Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is probably the most important chapter of this book. Here, we describe
    in detail the unique way in which the Rust borrow-checker mechanism detects problems
    at compile time to prevent memory safety errors. This is fundamental to everything
    else in Rust as the language is focused on these concepts of ownership and borrowing.
    Some of the material has already been discussed earlier, but here, we will strengthen
    that foundation. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and references
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ownership and borrowing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out and experimenting with the examples is the key here as there are
    many concepts that you may not be familiar with yet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and references
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *The stack and the heap* section of [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types* gave us the
    basic information that we needed to understand memory layout of Rust. Let's recap
    the information and fill in some gaps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The stack and the heap
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program starts, by default a 2 MB chunk of memory called the stack is
    granted to it. The program will use its stack to store all its local variables
    and function parameters; for example, an `i32` variable takes 4 bytes of the stack.
    When our program calls a function, a new stack frame is allocated to it. Through
    this mechanism, the stack knows the order in which the functions are called so
    that the functions return correctly to the calling code and possibly return values
    as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically sized types, such as strings or arrays, can't be stored on the stack.
    For these values, a program can request memory space on its heap, so this is a
    potentially much bigger piece of memory than the stack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When possible, stack allocation is preferred over heap allocation because accessing
    the stack is a lot more efficient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All variables in a Rust code have a lifetime. Suppose we declare an `n` variable
    with the let `n = 42u32;` binding. Such a value is valid from where it is declared
    to when it is no longer referenced, which is called the lifetime of the variable.
    This is illustrated in the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The lifetime of `n` ends when `main()` ends; in general, the start and end of
    a lifetime happen in the same scope. The words lifetime and scope are synonymous,
    but we generally use the word lifetime to refer to the extent of a reference.
    As in other languages, local variables or parameters declared in a function do
    not exist anymore after the function has finished executing; in Rust, we say that
    their lifetime has ended. This is the case for the `m` and `o` variables in the
    preceding code snippet, which are only known in the `life` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the lifetime of a variable declared in a nested block is restricted
    to that block, like `phi` in the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Trying to use `phi` when its lifetime is over results in an error: `unresolved
    name ''phi''`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of a value can be indicated in the code by an annotation, for example
    `'a`, which reads as lifetime where `a` is simply an indicator; it could also
    be written as `'b`, `'n`, or `'life`. It's common to see single letters being
    used to represent lifetimes. In the preceding example, an explicit lifetime indication
    was not necessary since there were no references involved. All values tagged with
    the same lifetime have the same maximum lifetime. We already know this notation
    from `'static`, which, as we saw in the *Global constants* section of [Chapter
    2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using Variables and Types"), *Using Variables
    and Types*, is the lifetime of things that last for the entire length of the program,
    so only use `'static` when you need the value that long.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have a `transform` function that explicitly declares
    the lifetime of its `s` parameter to be `''a`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the `<''a>` indication after the name of the function. In nearly all cases,
    this explicit indication is not needed because the compiler is smart enough to
    deduce the lifetimes, so we can simply write this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an example where even when we indicate a lifetime specifier `''a`,
    the compiler does not allow our code. Let''s suppose that we define a `Magician`
    struct as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will get an error message if we try to construct the following function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The error message is error: `''mag'' does not live long enough`. Why does this
    happen? The lifetime of the `mag` value ends when the `return_magician` function
    ends, but this function nevertheless tries to return a reference to the `Magician`
    value, which no longer exists. Such an invalid reference is known as a *dangling
    pointer*. This is a situation that would clearly lead to errors and cannot be
    allowed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The lifespan of a pointer must always be shorter than or equal to than that
    of the value which it points to, thus avoiding dangling (or null) references.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, the decision to determine whether the lifetime of an object
    has ended is complicated, but in almost all cases, the borrow checker does this
    for us automatically by inserting lifetime annotations in the intermediate code;
    so, we don't have to do it. This is known as *lifetime elision*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: For example, when working with structs, we can safely assume that the struct
    instance and its fields have the same lifetime. Only when the borrow checker is
    not completely sure, we need to indicate the lifetime explicitly; however, this
    happens only on rare occasions, mostly when references are returned.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'One example is when we have a struct with fields that are references. The following
    code snippet explains this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This won''t compile and will give us the following error: `missing lifetime
    specifier [E0106]`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we have to change the code as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This specifies that both the struct and the fields have the lifetime as `'a`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Explain why the following code won''t compile:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Answer the same question for this code snippet as well:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Copying values and the Copy trait
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the code that we discussed in earlier section (see `Chapter 6/code/lifetimes.rs`)
    the value of `n` is copied to a new location each time `n` is assigned via a new
    `let` binding or passed as a function argument:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At a certain moment in the program''s execution, we would have four memory
    locations that contain the copied value `42`, which we can visualize as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Copying values and the Copy trait](img/image00180.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Each value disappears (and its memory location is freed) when the lifetime of
    its corresponding variable ends, which happens at the end of the function or code
    block in which it is defined. Nothing much can go wrong with this *Copy* behavior,
    in which the value (its bits) is simply copied to another location on the stack.
    Many built-in types, such as `u32` and `i64`, work similar to this, and this copy-value
    behavior is defined in Rust as the `Copy` trait, which `u32` and `i64` implement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also implement the `Copy` trait for your own type, provided all of
    its fields or items implement `Copy`. For example, the `MagicNumber` struct, which
    contains a field of the `u64` type, can have the same behavior. There are two
    ways to indicate this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to explicitly name the `Copy` implementation as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Otherwise, we can annotate it with a `Copy` attribute:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This now means that we can create two different copies, `mag` and `mag2`, of
    a `MagicNumber` by assignment:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They are copies because they have different memory addresses (the values shown
    will differ at each execution):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `(*const` function is a so-called raw pointer; refer to [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries* for
    more details about it). A type that does not implement the `Copy` trait is called
    non-copyable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to accomplish this is by letting `MagicNumber` implement the `Clone`
    trait:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can use `clone() mag` into a different object called `mag3`, effectively
    making a copy as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`mag3` is a new pointer referencing a new copy of the value of `mag`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `n` variable in the `let n = 42i32;` binding is stored on the stack. Values
    on the stack or the heap can be accessed by pointers. A pointer is a variable
    that contains the memory address of some value. To access the value it points
    to, dereference the pointer with `*`. This happens automatically in simple cases
    such as in `println!` or when a pointer is given as a parameter to a method. For
    example, in the following code, `m` is a pointer containing the address of `n`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This prints out the following output, which differs for each program run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, why do we need pointers? When we work with dynamically allocated values,
    such as a `String`, that can change in size, the memory address of that value
    is not known at compile time. Due to this, the memory address needs to be calculated
    at runtime. So, to be able to keep track of it, we need a pointer for it whose
    value will change when the location of `String` in memory changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The compiler automatically takes care of the memory allocation of pointers and
    the freeing up of memory when their lifetime ends. You don't have to do this yourself
    like in C/C++, where you could mess up by freeing memory at the wrong moment or
    at multiple times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The incorrect use of pointers in languages such as C++ leads to all kinds of
    problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: However, Rust enforces a strong set of rules at compile time called the borrow
    checker, so we are protected against them. We have already seen them in action,
    but from here onwards, we'll explain the logic behind their rules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Pointers can also be passed as arguments to functions, and they can be returned
    from functions, but the compiler severely restricts their usage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'When passing a pointer value to a function, it is always better to use the
    reference-dereference `&*` mechanism, as shown in this example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rust has many kinds of pointers, which we will explore in this chapter. All
    pointers (except raw pointers, which are discussed in [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries*)
    are guaranteed to be non-null (that is, they point to a valid location in the
    memory) and are automatically cleaned up.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our previous example, `m`, which had the `&n` value, is the simplest form
    of pointer, and it is called a reference (or borrowed pointer); `m` is a reference
    to the stack-allocated `n` variable and has the `&i32` type because it points
    to a value of the `i32` type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, when `n` is a value of the `T` type, then the `&n` reference is
    of the `&T` type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Here, `n` is immutable, so `m` is also immutable; for example, if you try to
    change the value of `n` through `m` with `*m = 7;` you will get a `cannot assign
    to immutable borrowed content '*m'` error. Contrary to C, Rust does not let you
    change an immutable variable via its pointer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is no danger of changing the value of `n` through a reference,
    multiple references to an immutable value are allowed; they can only be used to
    read the value, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It prints out as described earlier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We could represent this situation in the memory as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![References](img/image00181.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: It is clear that working with pointers such as this or in much more complex
    situations necessitates much stricter rules than the `Copy` behavior. For example,
    the memory can only be freed when there are no variables or pointers associated
    with it anymore. And when the value is mutable, can it be changed through any
    of its pointers? These stricter rules, described by the ownership and borrowing
    system discussed in the next section, are enforced by the compiler.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Mutable references do exist, and they are declared as `let m = &mut n`. However,
    `n` also has to be a mutable value. When `n` is immutable, the compiler rejects
    the `m` mutable reference binding with the error, `cannot borrow immutable local
    variable 'n' as mutable`. This makes sense since immutable variables cannot be
    changed even when you know their memory location.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate, in order to change a value through a reference, both the variable
    and its reference have to be mutable, as shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will print: `The value of u is now 3.15`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now, the value at the memory location of `u` is changed to `3.15`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that we now cannot change (or even print) that value anymore
    by using the `u: u = u * 2.0;` variable gives us a compiler error: `cannot assign
    to ''u'' because it is borrowed` (we explain why this is so in the *Ownership
    and Borrowing* section of this chapter). We say that borrowing a variable (by
    making a reference to it) freezes that variable; the original `u` variable is
    frozen (and no longer usable) until the reference goes out of scope.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we can only have one mutable reference: `let w = &mut u;` which
    results in the error: `cannot borrow ''u'' as mutable more than once at a time`.
    The compiler even adds the following note to the previous code line with: `let
    v = &mut u;` note: ``previous borrow of ''u'' occurs here; the mutable borrow
    prevents subsequent moves, borrows, or modification of `u` until the borrow ends``.
    This is logical; the compiler is (rightfully) concerned that a change to the value
    of `u` through one reference might change its memory location because `u` might
    change in size, so it will not fit anymore within its previous location and would
    have to be relocated to another address. This would render all other references
    to `u` as invalid, and even dangerous, because through them we might inadvertently
    change another variable that has taken up the previous location of `u`!'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutable value can also be changed by passing its address as a mutable reference
    to a function, as shown in this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the function `add_three_to_magic` declared as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To summarize, when `n` is a mutable value of the `T` type, then only one mutable
    reference to it (of the `&mut T` type) can exist at any time. Through this reference,
    the value can be changed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using ref in a match
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to get a reference to a matched variable inside a `match` function,
    use the `ref` keyword, as shown in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which prints out:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `r` variable inside the `match` has the `&i32` type. In other words, the
    `ref` keyword creates a reference for use in the pattern. If you need a mutable
    reference, use `ref mut`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`内部的`r`变量具有`&i32`类型。换句话说，`ref`关键字创建了一个用于模式的引用。如果你需要一个可变引用，请使用`ref mut`。'
- en: 'We can also use `ref` to get a reference to a field of a struct or tuple in
    a destructuring via a `let` binding. For example, while reusing the `Magician`
    struct, we can extract the name of `mag` by using `ref` and then return it from
    the match:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ref`通过`let`绑定在解构中获取结构体或元组的字段的引用。例如，在重用`Magician`结构体时，我们可以通过使用`ref`提取`mag`的名字，然后从`match`中返回它：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Which prints: `The magician''s name is Gandalf`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果为：`The magician's name is Gandalf`.
- en: References are the most common pointer type and have the most possibilities;
    other pointer types should only be applied in very specific use cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是最常见的指针类型，并且具有最多的可能性；其他指针类型应该只应用于非常特定的用例。
- en: Ownership and borrowing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权和借用
- en: In the previous section, the word *borrowed* was mentioned in most error messages.
    What's this all about? What is the logic behind this borrow-checker mechanism?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，大多数错误信息中提到了“借用”。这究竟是怎么回事？这个借用检查机制背后的逻辑是什么？
- en: 'Every program, whatever it does, whether reading data from a database or making
    a computation, is concerned with handling resources. The most common resource
    in a program is the memory space allocated to its variables. Other resources could
    be files, network connections, database connections, and so on. Every resource
    is given a name when we make a binding to it with `let`; in Rust''s language,
    we say that the resource gets an owner, for example, in the following code snippet,
    `klaatu` owns a piece of memory that is taken up by the `Alien` struct instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序，无论它做什么，无论是从数据库读取数据还是进行计算，都涉及到处理资源。程序中最常见的资源是分配给其变量的内存空间。其他资源可能是文件、网络连接、数据库连接等等。当我们用`let`绑定一个资源时，每个资源都会被赋予一个名称；在Rust语言中，我们说资源获得了一个所有者，例如，在以下代码片段中，`klaatu`拥有由`Alien`结构体实例占据的一块内存：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Only the owner can change the object it points to, and there can only be one
    owner at a time, because the owner is responsible for freeing the object's resources.
    When a reference goes out of scope, it will not deallocate the underlying memory,
    because the reference is not the owner of the value. This makes sense; if an object
    could have many owners, its resources could be freed more than once, which would
    lead to problems. When the owner's lifetime has passed, the compiler frees the
    memory automatically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 只有所有者才能更改它所指向的对象，并且一次只能有一个所有者，因为所有者负责释放对象的资源。当一个引用超出作用域时，它不会释放底层内存，因为引用不是值的所有者。这很有道理；如果一个对象可以有多个所有者，它的资源可能会被多次释放，这会导致问题。当所有者的生命周期结束时，编译器会自动释放内存。
- en: 'The owner can move the ownership of the object to another variable as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者可以将对象的拥有权移动到另一个变量，如下所示：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the ownership has moved from `klaatu` to `kl2`, but no data is actually
    copied. The original owner `klaatu` cannot be used anymore:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有权已从`klaatu`移动到`kl2`，但实际上没有数据被复制。原始所有者`klaatu`不能再使用了：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It gives the compiler error as: `use of moved value ''klaatu.planet''`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它会给出编译器错误：`use of moved value 'klaatu.planet'`。
- en: On the other hand, we can borrow the resource by making a (in this example mutable)
    reference `kl2` to `klaatu` with `let kl2 = &mut klaatu;`. A borrow is a temporary
    reference that passes the address of the data structure through `&`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过创建一个（在这个例子中是可变的）引用`kl2`到`klaatu`来借用资源，使用`let kl2 = &mut klaatu;`。借用是一个通过`&`传递数据结构地址的临时引用。
- en: 'Now, `kl2` can change the object, for instance, when our alien loses a tentacle
    in a battle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`kl2`可以更改对象，例如，当我们的外星人在战斗中失去一个触手时：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This prints out: `Venus – 14`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：`Venus – 14`。
- en: 'However, we will get an error message if we try to change the alien''s planet
    through the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试通过以下代码更改外星人的星球，将会得到一个错误信息：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The error message is `error:` ``cannot assign to `klaatu.planet` because it
    is borrowed;`` it was indeed borrowed by `kl2`. Similar to everyday life, while
    an object is borrowed, the owner does not have access to it as it is no longer
    in their possession. In order to change the resource, `klaatu` needs to own it,
    without the resource being borrowed at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust even explains this to us with the note that it adds: `borrow of ''klaatu.planet''
    occurs here ownership.rs:8 let kl2 = &mut klaatu;`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `kl2` borrows the resource, Rust also even forbids us to access the instance
    with its former name, `klaatu`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The compiler then throws this error message: `error: cannot borrow ''klaatu.planet''
    as immutable because ''klaatu'' is also borrowed as mutable`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: When a resource is moved or borrowed, the previous owner can no longer use it.
    This prevents the memory problem that is known as a dangling pointer, which is
    the use of a pointer that points to an invalid memory location.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'But here is a revelation: if we isolate the borrowing by `kl2` in its own block,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The former problems have disappeared! After the block, we can now do for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This prints:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why does this happen? Because after the closing `}` of the code block in which
    `kl2` was bound, its lifetime ended. The borrowing was over (a borrow has to end
    sometime) and `klaatu` reclaimed full ownership, and thus the right to change.
    When the compiler detects that the lifetime of the original owner, `klaatu` ,
    has eventually ended, the memory occupied by the struct instance is automatically
    freed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is a general rule in Rust; whenever an object goes out of scope
    and it doesn't have an owner anymore, its destructor is automatically called and
    the resources owned by it are freed so that there can never be any memory (or
    other resource) leaks. In other words, Rust obeys the **Resource Acquisition Is
    Initialization** (**RAII**) rule. For more information, go to [http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As we experimented in the *References* section, a resource can be immutably
    borrowed many times, but while it is immutably borrowed, the original data can't
    be mutably borrowed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to move a resource (and transfer the ownership) is to pass it as
    an argument to a function; try this out in the following exercise:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Examine the situation (`let kl2 = &klaatu;`) when `kl2` is not a mutable reference.
    Can you change the instance through `kl2`? Can you change the instance through
    `klaatu`? Explain the error with what you know about ownership and borrowing (refer
    to `Chapter 6/exercises/ownership3.rs`).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will happen in the previous program if we do `let klaatuc = klaatu;` before
    we define the `let kl2 = &klaatu;` binding?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine if you can change the mutability of a resource by moving from an immutable
    owner to a mutable owner.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our `Alien` struct, write a `grow_a_tentacle` method that increases the
    number of tentacles by one (refer to `Chapter 6/exercises/grow_a_tentacle.rs`).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another pointer type in Rust is called the boxed pointer, `Box<T>`, which can
    be defined for a value of a generic `T` type. A box is a non-copyable value. This
    pointer type is used to allocate objects on the heap. For example, here we allocate
    an `Alien` value on the heap by using the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `a1` variable is the only owner of this memory resource that may read from
    and write to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a reference to the value pointed to by the box pointer, and if
    both the original box and this new reference are mutable, we can change the object
    through this reference:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After such a borrowing, the usual ownership rules as specified earlier hold,
    since `a1` no longer has access, not even for reading:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also use this mechanism to put simple values on the heap as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As always, `n` points by default to an immutable value and any attempt to change
    this with:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Provokes the error: `cannot assign to immutable ''Box'' content ''*n''`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reference can also point to the dereferenced `Box` value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following example, we again see a boxed value pointed to by `n`, but
    the ownership of the value is now given to a mutable pointer, `m`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By dereferencing `m` and assigning a new value to `m`, this value is entered
    into the memory location that was originally pointed to by `n`. Of course, `n`
    cannot be used anymore; we get the error: `use of moved value: ''n'' message because
    n is no longer the owner of the value`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example where the ownership has clearly has moved from `a1`
    to `a2`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: No data being copied here, except the address of the struct value. After the
    move, `a1` can no longer be used to access the data, and `a2` is responsible for
    freeing the memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'If `a2` is given as an argument to a function such as `use_alien` in the following
    code snippet, `a2` also gives up the ownership, which is then transferred to the
    function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This prints out: `An alien from planet Mars is freed`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, when `use_alien()` has finished executing, the memory allocation for
    that value is freed. However, in general, you must always let your function take
    a simple reference as a parameter (in a similar way to the `square` function explained
    earlier), rather than take a parameter of the `Box` type. We could improve our
    example by calling a `use_alien2` function as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And calling it with: `use_alien2(&*a2);`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, your program may need to manipulate a recursive data structure that
    refers to itself, as shown in the following struct:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This represents a list of lists of bytes. The `rec_list` function is either
    a `Some<Box<Recurs>>` function containing a `Box` pointer to another list or a
    `None` value, which means that the list of lists ends there. Since the number
    of items in this list (and thus its size) is only known at runtime such structures
    must be always constructed as a `Box` type. For other use cases, you must prefer
    references over Boxes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need several references to an immutable value at the same time;
    this is also called shared ownership. `Box<T>` can't help us out here because
    this type has a single owner by definition. For this, Rust provides the generic
    reference counted box, `Rc<T>`, where multiple references can share the same resource.
    The `std::rc` module provides a way to share ownership of the same value between
    different `Rc` pointers; the value remains alive as long as there is least one
    pointer referencing it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have aliens that have a number of tentacles. Each
    `Tentacle` has to indicate to which `Alien` it belongs; besides this, it also
    has other properties (such as a degree of poison), so we define it also as a struct.
    A first attempt at this could be the following code, which however does not compile
    (from `Chapter 6/code/refcount_not_good.rs`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The compiler gives the following error for the line in the for loop: `error:
    use of moved value ''dhark'' - note: ''dhark'' moved here because it has type
    ''Alien'', which is non-copyable`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When it is defined, each `Alien Tentacle` seemingly tries to make a copy of
    the `Alien` instance as its owner, which makes no sense and is not allowed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct version defines the owner in the `Tentacle` struct to have the
    `Rc<Alien>` type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This prints the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We envelop our `Alien` instance in an `Rc<T>` type with `Rc::new(dhark)`. Applying
    the `clone()` method on this `Rc` object provides each `Tentacle` with its own
    reference to the `Alien` object. Note that `clone()` here copies the `Rc` pointer,
    not the `Alien` struct. We also annotate the structs with `#[derive(Debug)]` so
    that we can print out their instances through a `println!("{:?}", t);`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If we want mutability inside our `Rc` type, we have to either use a *Cell* pointer
    if the value implements the *Copy* trait or a *RefCell* pointer. Both these smart
    pointers are found in the `std:cell` module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Rc` pointer type can only be used inside one thread of execution.
    If you need shared ownership across multiple threads, you need to use the `Arc<T>`
    pointer (short for **atomic reference counted box**), which is the thread-safe
    counterpart of `Rc` (refer to the *Atomic reference counting* section of [Chapter
    8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency and Parallelism"), *Concurrency
    and Parallelism*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: An overview of pointers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following table, we summarize the different pointers used in Rust. `T`
    represents a generic type. We haven't yet encountered the `Arc`, `*const`, and
    `*mut` pointers, but they are included here for completeness.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '| Pointers | Pointer names | Description |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `&T` | Reference | This allows one or more references to read `T`. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `&mut T` | Mutable reference | This allows a single reference to read and
    write `T`. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `Box<T>` | Box | This is a heap-allocated `T` with a single owner that may
    read and write `T`. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `Rc<T>` | Rc pointer | This is a heap-allocated `T` with many readers. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `Arc<T>` | Arc pointer | This is like `Rc<T>`, but enables safe mutable sharing
    across threads (refer to [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*). |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `*const T` | Raw pointer | This allows unsafe read access to `T` (refer to
    [Chapter 9](part0069.xhtml#aid-21PMQ1 "Chapter 9. Programming at the Boundaries"),
    *Programming at the Boundaries*). |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `*mut T` | Mutable raw pointer | This allows unsafe read and write access
    to `T` (refer to [Chapter 9](part0069.xhtml#aid-21PMQ1 "Chapter 9. Programming
    at the Boundaries"), *Programming at the Boundaries*). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned the intelligence behind the Rust compiler, which
    is embodied in the principles of ownership, moving values, and borrowing. We saw
    the different pointers that Rust advocates: references, boxes, and reference counters.
    Now that we have a grasp on how this all works together, we will understand the
    errors, warnings, and messages the compiler may throw at us in a much better way.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will expose the bigger units of code organization
    in code, such as modules and crates, and how we can write macros to make coding
    less repetitive.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
