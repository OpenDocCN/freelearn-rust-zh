- en: Chapter 6. Pointers and Memory Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。指针和内存安全
- en: 'This is probably the most important chapter of this book. Here, we describe
    in detail the unique way in which the Rust borrow-checker mechanism detects problems
    at compile time to prevent memory safety errors. This is fundamental to everything
    else in Rust as the language is focused on these concepts of ownership and borrowing.
    Some of the material has already been discussed earlier, but here, we will strengthen
    that foundation. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本书最重要的章节。在这里，我们详细描述了Rust借用检查器机制如何以独特的方式在编译时检测问题，以防止内存安全错误。这对于Rust中的其他一切是基本的，因为该语言专注于这些所有权和借用概念。一些材料已经在前面讨论过，但在这里，我们将加强这个基础。我们将涵盖以下主题：
- en: Pointers and references
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针和引用
- en: Ownership and borrowing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有权和借用
- en: Boxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架
- en: Reference counting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数
- en: Trying out and experimenting with the examples is the key here as there are
    many concepts that you may not be familiar with yet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试和实验示例是关键，因为可能有许多你还不熟悉的概念。
- en: Pointers and references
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针和引用
- en: The *The stack and the heap* section of [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types* gave us the
    basic information that we needed to understand memory layout of Rust. Let's recap
    the information and fill in some gaps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](part0023.xhtml#aid-LTSU1 "第2章。使用变量和类型")的*堆栈和堆*部分，*使用变量和类型*为我们提供了理解Rust内存布局所需的基本信息。让我们回顾一下这些信息，并填补一些空白。'
- en: The stack and the heap
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈和堆
- en: When a program starts, by default a 2 MB chunk of memory called the stack is
    granted to it. The program will use its stack to store all its local variables
    and function parameters; for example, an `i32` variable takes 4 bytes of the stack.
    When our program calls a function, a new stack frame is allocated to it. Through
    this mechanism, the stack knows the order in which the functions are called so
    that the functions return correctly to the calling code and possibly return values
    as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，默认情况下会授予它一个2MB的内存块，称为堆栈。程序将使用其堆栈来存储所有其局部变量和函数参数；例如，一个`i32`变量占用堆栈的4个字节。当我们的程序调用一个函数时，会为其分配一个新的堆栈帧。通过这种机制，堆栈知道函数调用的顺序，以便函数能够正确地返回调用代码，并可能返回值。
- en: Dynamically sized types, such as strings or arrays, can't be stored on the stack.
    For these values, a program can request memory space on its heap, so this is a
    potentially much bigger piece of memory than the stack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 动态大小的类型，如字符串或数组，不能存储在堆栈上。对于这些值，程序可以在其堆上请求内存空间，因此这比堆栈大得多。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When possible, stack allocation is preferred over heap allocation because accessing
    the stack is a lot more efficient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，堆栈分配比堆分配更受欢迎，因为访问堆栈要高效得多。
- en: Lifetimes
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'All variables in a Rust code have a lifetime. Suppose we declare an `n` variable
    with the let `n = 42u32;` binding. Such a value is valid from where it is declared
    to when it is no longer referenced, which is called the lifetime of the variable.
    This is illustrated in the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust代码中的所有变量都有生命周期。假设我们使用`let n = 42u32;`绑定声明一个`n`变量。这样的值从声明的地方开始有效，直到它不再被引用，这被称为变量的生命周期。以下代码片段说明了这一点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The lifetime of `n` ends when `main()` ends; in general, the start and end of
    a lifetime happen in the same scope. The words lifetime and scope are synonymous,
    but we generally use the word lifetime to refer to the extent of a reference.
    As in other languages, local variables or parameters declared in a function do
    not exist anymore after the function has finished executing; in Rust, we say that
    their lifetime has ended. This is the case for the `m` and `o` variables in the
    preceding code snippet, which are only known in the `life` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`的生命周期在`main()`结束时结束；一般来说，生命周期的开始和结束发生在相同的范围内。生命周期和范围是同义词，但我们通常使用“生命周期”一词来指代引用的范围。与其他语言一样，在函数中声明的局部变量或参数在函数执行完毕后不再存在；在Rust中，我们说它们的生命周期已经结束。这是前面代码片段中`m`和`o`变量的情况，它们只在`life`函数中是已知的。'
- en: 'Likewise, the lifetime of a variable declared in a nested block is restricted
    to that block, like `phi` in the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，嵌套块中声明的变量的生命周期被限制在该块内，就像以下示例中的`phi`一样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Trying to use `phi` when its lifetime is over results in an error: `unresolved
    name ''phi''`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当`phi`的生命周期结束时尝试使用它会导致错误：`未解析的名称 'phi'`。
- en: The lifetime of a value can be indicated in the code by an annotation, for example
    `'a`, which reads as lifetime where `a` is simply an indicator; it could also
    be written as `'b`, `'n`, or `'life`. It's common to see single letters being
    used to represent lifetimes. In the preceding example, an explicit lifetime indication
    was not necessary since there were no references involved. All values tagged with
    the same lifetime have the same maximum lifetime. We already know this notation
    from `'static`, which, as we saw in the *Global constants* section of [Chapter
    2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using Variables and Types"), *Using Variables
    and Types*, is the lifetime of things that last for the entire length of the program,
    so only use `'static` when you need the value that long.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中可以通过注解来指示值的生命周期，例如`'a`，它读作生命周期，其中`a`只是一个指示符；它也可以写成`'b`、`'n`或`'life`。用单个字母表示生命周期是很常见的。在先前的示例中，由于没有涉及引用，因此不需要显式地指示生命周期。所有标记有相同生命周期的值都具有相同的最大生命周期。我们已经从`'static`这个符号中了解到这一点，正如我们在第2章的*全局常量*部分所看到的，*使用变量和类型*，它是整个程序持续存在的对象的生存周期，因此只有在你需要这么长时间值的时候才使用`'static`。
- en: 'In the following example, we have a `transform` function that explicitly declares
    the lifetime of its `s` parameter to be `''a`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个显式声明其`s`参数生命周期为`'a`的`transform`函数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the `<''a>` indication after the name of the function. In nearly all cases,
    this explicit indication is not needed because the compiler is smart enough to
    deduce the lifetimes, so we can simply write this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数名称后面的`<'a>`指示。在几乎所有情况下，这种显式指示都是不必要的，因为编译器足够智能，可以推断出生命周期，因此我们可以简单地写成这样：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an example where even when we indicate a lifetime specifier `''a`,
    the compiler does not allow our code. Let''s suppose that we define a `Magician`
    struct as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，即使我们指示了生命周期指定符`'a`，编译器也不允许我们的代码。让我们假设我们定义了一个`Magician`结构体如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will get an error message if we try to construct the following function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试构造以下函数，我们将得到一个错误信息：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The error message is error: `''mag'' does not live long enough`. Why does this
    happen? The lifetime of the `mag` value ends when the `return_magician` function
    ends, but this function nevertheless tries to return a reference to the `Magician`
    value, which no longer exists. Such an invalid reference is known as a *dangling
    pointer*. This is a situation that would clearly lead to errors and cannot be
    allowed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息是错误：`'mag'的生命周期不足以长`。为什么会这样？`mag`值的生命周期在`return_magician`函数结束时结束，但这个函数仍然试图返回一个指向`Magician`值的引用，而这个值已经不存在了。这种无效的引用被称为*悬垂指针*。这是一个明显会导致错误的情况，不允许发生。
- en: The lifespan of a pointer must always be shorter than or equal to than that
    of the value which it points to, thus avoiding dangling (or null) references.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的生存期必须始终短于或等于它所指向的值的生存期，从而避免悬垂（或空）引用。
- en: In some situations, the decision to determine whether the lifetime of an object
    has ended is complicated, but in almost all cases, the borrow checker does this
    for us automatically by inserting lifetime annotations in the intermediate code;
    so, we don't have to do it. This is known as *lifetime elision*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，确定一个对象的生命周期何时结束的决策可能很复杂，但在几乎所有情况下，借用检查器都会通过在中间代码中插入生命周期注解自动为我们完成这项工作；因此，我们不必这样做。这被称为*生命周期省略*。
- en: For example, when working with structs, we can safely assume that the struct
    instance and its fields have the same lifetime. Only when the borrow checker is
    not completely sure, we need to indicate the lifetime explicitly; however, this
    happens only on rare occasions, mostly when references are returned.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当与结构体一起工作时，我们可以安全地假设结构体实例及其字段具有相同的生命周期。只有在借用检查器不确定的情况下，我们才需要显式地指示生命周期；然而，这种情况很少发生，通常发生在返回引用时。
- en: 'One example is when we have a struct with fields that are references. The following
    code snippet explains this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是我们有一个具有引用字段的`struct`。以下代码片段解释了这一点：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This won''t compile and will give us the following error: `missing lifetime
    specifier [E0106]`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，并给出以下错误：`缺少生命周期指定符 [E0106]`。
- en: 'Therefore, we have to change the code as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须按照以下方式更改代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This specifies that both the struct and the fields have the lifetime as `'a`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了结构和字段都具有`'a`的生命周期。
- en: 'Perform the following exercise:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: 'Explain why the following code won''t compile:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解释为什么以下代码无法编译：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Answer the same question for this code snippet as well:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个代码片段也要回答相同的问题：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Copying values and the Copy trait
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制值和 `Copy` 特性
- en: 'In the code that we discussed in earlier section (see `Chapter 6/code/lifetimes.rs`)
    the value of `n` is copied to a new location each time `n` is assigned via a new
    `let` binding or passed as a function argument:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论的代码中（见 `Chapter 6/code/lifetimes.rs`），每次通过新的 `let` 绑定或作为函数参数赋值给 `n` 时，`n`
    的值都会被复制到一个新的位置：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At a certain moment in the program''s execution, we would have four memory
    locations that contain the copied value `42`, which we can visualize as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中的某个时刻，我们会拥有四个包含复制值 `42` 的内存位置，我们可以这样可视化：
- en: '![Copying values and the Copy trait](img/image00180.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![复制值和 `Copy` 特性](img/image00180.jpeg)'
- en: Each value disappears (and its memory location is freed) when the lifetime of
    its corresponding variable ends, which happens at the end of the function or code
    block in which it is defined. Nothing much can go wrong with this *Copy* behavior,
    in which the value (its bits) is simply copied to another location on the stack.
    Many built-in types, such as `u32` and `i64`, work similar to this, and this copy-value
    behavior is defined in Rust as the `Copy` trait, which `u32` and `i64` implement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值在它对应的变量的生命周期结束时消失（并且其内存位置被释放），这发生在定义它的函数或代码块的末尾。这种 *Copy* 行为（其中值（其位）被简单地复制到栈上的另一个位置）不会出现太多错误。许多内置类型，如
    `u32` 和 `i64`，与此类似，这种复制值的行为在 Rust 中定义为 `Copy` 特性，而 `u32` 和 `i64` 实现了该特性。
- en: 'You can also implement the `Copy` trait for your own type, provided all of
    its fields or items implement `Copy`. For example, the `MagicNumber` struct, which
    contains a field of the `u64` type, can have the same behavior. There are two
    ways to indicate this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类型的所有字段或项目都实现了 `Copy`，你也可以为你的类型实现 `Copy` 特性。例如，包含 `u64` 类型字段的 `MagicNumber`
    结构体可以具有相同的行为。有两种方式来表示这一点：
- en: 'One way is to explicitly name the `Copy` implementation as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是将 `Copy` 实现显式命名为以下内容：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Otherwise, we can annotate it with a `Copy` attribute:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们可以用 `Copy` 属性来注释它：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This now means that we can create two different copies, `mag` and `mag2`, of
    a `MagicNumber` by assignment:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过赋值创建两个不同的 `MagicNumber` 的副本，`mag` 和 `mag2`：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They are copies because they have different memory addresses (the values shown
    will differ at each execution):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是复制的，因为它们有不同的内存地址（显示的值将在每次执行时不同）：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `(*const` function is a so-called raw pointer; refer to [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries* for
    more details about it). A type that does not implement the `Copy` trait is called
    non-copyable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*const` 函数是一个所谓的原始指针；有关更多详细信息，请参阅 [第 9 章](part0069.xhtml#aid-21PMQ1 "第 9
    章。在边界编程")，*在边界编程*。没有实现 `Copy` 特性的类型被称为不可复制的。'
- en: 'Another way to accomplish this is by letting `MagicNumber` implement the `Clone`
    trait:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的另一种方法是让 `MagicNumber` 实现了 `Clone` 特性：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can use `clone() mag` into a different object called `mag3`, effectively
    making a copy as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `clone()` 将 `mag` 复制到另一个名为 `mag3` 的不同对象中，从而有效地创建一个副本如下：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`mag3` is a new pointer referencing a new copy of the value of `mag`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`mag3` 是一个新指针，它引用了 `mag` 值的新副本。'
- en: Pointers
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针
- en: 'The `n` variable in the `let n = 42i32;` binding is stored on the stack. Values
    on the stack or the heap can be accessed by pointers. A pointer is a variable
    that contains the memory address of some value. To access the value it points
    to, dereference the pointer with `*`. This happens automatically in simple cases
    such as in `println!` or when a pointer is given as a parameter to a method. For
    example, in the following code, `m` is a pointer containing the address of `n`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `let n = 42i32;` 绑定中的 `n` 变量存储在栈上。栈或堆上的值可以通过指针访问。指针是一个包含某个值内存地址的变量。要访问它指向的值，需要使用
    `*` 解引用指针。这在简单的案例中是自动发生的，例如在 `println!` 或将指针作为方法参数时。例如，在以下代码中，`m` 是一个包含 `n` 地址的指针：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This prints out the following output, which differs for each program run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出以下输出，每次程序运行的结果都不同：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, why do we need pointers? When we work with dynamically allocated values,
    such as a `String`, that can change in size, the memory address of that value
    is not known at compile time. Due to this, the memory address needs to be calculated
    at runtime. So, to be able to keep track of it, we need a pointer for it whose
    value will change when the location of `String` in memory changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要指针呢？当我们处理可以改变大小的动态分配值，例如`String`时，该值的内存地址在编译时是未知的。因此，内存地址需要在运行时计算。因此，为了能够跟踪它，我们需要一个指针，其值将在`String`在内存中的位置改变时发生变化。
- en: The compiler automatically takes care of the memory allocation of pointers and
    the freeing up of memory when their lifetime ends. You don't have to do this yourself
    like in C/C++, where you could mess up by freeing memory at the wrong moment or
    at multiple times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动处理指针的内存分配和在其生命周期结束时释放内存。你不需要像在C/C++中那样自己来做这件事，在那里你可能会在错误的时间或多次释放内存。
- en: The incorrect use of pointers in languages such as C++ leads to all kinds of
    problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++等语言中，指针的不正确使用会导致各种问题。
- en: However, Rust enforces a strong set of rules at compile time called the borrow
    checker, so we are protected against them. We have already seen them in action,
    but from here onwards, we'll explain the logic behind their rules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Rust在编译时强制实施一套称为借用检查器的严格规则，因此我们得到了保护。我们已经在实际操作中看到了它们，但从现在开始，我们将解释其规则背后的逻辑。
- en: Pointers can also be passed as arguments to functions, and they can be returned
    from functions, but the compiler severely restricts their usage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 指针也可以作为函数的参数传递，并且可以从函数中返回，但编译器对其使用有严格的限制。
- en: 'When passing a pointer value to a function, it is always better to use the
    reference-dereference `&*` mechanism, as shown in this example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当将指针值传递给函数时，始终最好使用引用-解引用`&*`机制，如下例所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rust has many kinds of pointers, which we will explore in this chapter. All
    pointers (except raw pointers, which are discussed in [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries*)
    are guaranteed to be non-null (that is, they point to a valid location in the
    memory) and are automatically cleaned up.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有许多种指针，我们将在本章中探讨。所有指针（除了在第9章（part0069.xhtml#aid-21PMQ1 "第9章。边界编程"）中讨论的原始指针外，*边界编程*）都保证为非空（即它们指向内存中的有效位置）并且会自动清理。
- en: References
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用
- en: In our previous example, `m`, which had the `&n` value, is the simplest form
    of pointer, and it is called a reference (or borrowed pointer); `m` is a reference
    to the stack-allocated `n` variable and has the `&i32` type because it points
    to a value of the `i32` type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，具有`&n`值的`m`是最简单的指针形式，它被称为引用（或借用指针）；`m`是栈分配的`n`变量的引用，并且具有`&i32`类型，因为它指向`i32`类型的值。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In general, when `n` is a value of the `T` type, then the `&n` reference is
    of the `&T` type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当`n`是`T`类型的值时，则`&n`引用是`&T`类型。
- en: Here, `n` is immutable, so `m` is also immutable; for example, if you try to
    change the value of `n` through `m` with `*m = 7;` you will get a `cannot assign
    to immutable borrowed content '*m'` error. Contrary to C, Rust does not let you
    change an immutable variable via its pointer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n`是不可变的，所以`m`也是不可变的；例如，如果你尝试通过`m`使用`*m = 7;`来改变`n`的值，你会得到一个`cannot assign
    to immutable borrowed content '*m'`错误。与C不同，Rust不允许你通过指针改变不可变变量。
- en: 'Since there is no danger of changing the value of `n` through a reference,
    multiple references to an immutable value are allowed; they can only be used to
    read the value, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过引用改变`n`的值没有危险，因此允许对不可变值有多个引用；它们只能用来读取值，例如：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It prints out as described earlier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它会按照前面描述的方式打印出来：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We could represent this situation in the memory as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种情况在内存中表示如下：
- en: '![References](img/image00181.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![引用](img/image00181.jpeg)'
- en: It is clear that working with pointers such as this or in much more complex
    situations necessitates much stricter rules than the `Copy` behavior. For example,
    the memory can only be freed when there are no variables or pointers associated
    with it anymore. And when the value is mutable, can it be changed through any
    of its pointers? These stricter rules, described by the ownership and borrowing
    system discussed in the next section, are enforced by the compiler.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，与这种或更复杂的情况一起工作需要比 `Copy` 行为更严格的规则。例如，只有当没有变量或指针与它关联时，才能释放内存。当值是可变的，是否可以通过其任何指针来更改它？这些更严格的规则，由下一节讨论的所有权和借用系统描述，由编译器强制执行。
- en: Mutable references do exist, and they are declared as `let m = &mut n`. However,
    `n` also has to be a mutable value. When `n` is immutable, the compiler rejects
    the `m` mutable reference binding with the error, `cannot borrow immutable local
    variable 'n' as mutable`. This makes sense since immutable variables cannot be
    changed even when you know their memory location.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可变引用确实存在，并且它们声明为 `let m = &mut n`。然而，`n` 也必须是可变值。当 `n` 是不可变的，编译器会因错误 `cannot
    borrow immutable local variable 'n' as mutable` 而拒绝 `m` 可变引用绑定。这很有道理，因为即使你知道它们的内存位置，不可变变量也不能更改。
- en: 'To reiterate, in order to change a value through a reference, both the variable
    and its reference have to be mutable, as shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了通过引用更改值，变量及其引用都必须是可变的，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will print: `The value of u is now 3.15`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：`u 的值现在是 3.15`。
- en: Now, the value at the memory location of `u` is changed to `3.15`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，变量 `u` 的内存位置中的值已更改为 `3.15`。
- en: 'However, note that we now cannot change (or even print) that value anymore
    by using the `u: u = u * 2.0;` variable gives us a compiler error: `cannot assign
    to ''u'' because it is borrowed` (we explain why this is so in the *Ownership
    and Borrowing* section of this chapter). We say that borrowing a variable (by
    making a reference to it) freezes that variable; the original `u` variable is
    frozen (and no longer usable) until the reference goes out of scope.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，请注意，我们现在不能再通过使用 `u: u = u * 2.0;` 变量来更改（甚至打印）该值，因为编译器会报错：`cannot assign
    to ''u'' because it is borrowed`（我们将在本章的 *所有权和借用* 部分解释原因）。我们说通过引用变量（通过对其创建引用）会冻结该变量；原始的
    `u` 变量被冻结（并且不再可用），直到引用超出作用域。'
- en: 'In addition, we can only have one mutable reference: `let w = &mut u;` which
    results in the error: `cannot borrow ''u'' as mutable more than once at a time`.
    The compiler even adds the following note to the previous code line with: `let
    v = &mut u;` note: ``previous borrow of ''u'' occurs here; the mutable borrow
    prevents subsequent moves, borrows, or modification of `u` until the borrow ends``.
    This is logical; the compiler is (rightfully) concerned that a change to the value
    of `u` through one reference might change its memory location because `u` might
    change in size, so it will not fit anymore within its previous location and would
    have to be relocated to another address. This would render all other references
    to `u` as invalid, and even dangerous, because through them we might inadvertently
    change another variable that has taken up the previous location of `u`!'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只能有一个可变引用：`let w = &mut u;` 这会导致错误：`cannot borrow 'u' as mutable more than
    once at a time`。编译器甚至会在之前的代码行上添加以下注释：`let v = &mut u;` 注释：`previous borrow of
    'u' occurs here; the mutable borrow prevents subsequent moves, borrows, or modification
    of 'u' until the borrow ends`。这是合乎逻辑的；编译器（正确地）担心通过一个引用对 `u` 值的更改可能会改变它的内存位置，因为
    `u` 可能会改变大小，所以它不再适合其之前的位置，并必须重新定位到另一个地址。这将使所有其他对 `u` 的引用都无效，甚至危险，因为通过它们我们可能会无意中更改另一个变量，该变量已经占据了
    `u` 之前的位置！
- en: 'A mutable value can also be changed by passing its address as a mutable reference
    to a function, as shown in this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可变值也可以通过将它的地址作为可变引用传递给函数来更改，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the function `add_three_to_magic` declared as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `add_three_to_magic` 声明如下：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To summarize, when `n` is a mutable value of the `T` type, then only one mutable
    reference to it (of the `&mut T` type) can exist at any time. Through this reference,
    the value can be changed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当 `n` 是 `T` 类型的可变值时，任何时候只能存在一个对该值的可变引用（`&mut T` 类型）。通过这个引用，可以更改值。
- en: Using ref in a match
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在匹配中使用 ref
- en: 'If you want to get a reference to a matched variable inside a `match` function,
    use the `ref` keyword, as shown in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 `match` 函数内部获取匹配变量的引用，请使用 `ref` 关键字，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which prints out:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印出：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `r` variable inside the `match` has the `&i32` type. In other words, the
    `ref` keyword creates a reference for use in the pattern. If you need a mutable
    reference, use `ref mut`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`内部的`r`变量具有`&i32`类型。换句话说，`ref`关键字创建了一个用于模式的引用。如果你需要一个可变引用，请使用`ref mut`。'
- en: 'We can also use `ref` to get a reference to a field of a struct or tuple in
    a destructuring via a `let` binding. For example, while reusing the `Magician`
    struct, we can extract the name of `mag` by using `ref` and then return it from
    the match:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ref`通过`let`绑定在解构中获取结构体或元组的字段的引用。例如，在重用`Magician`结构体时，我们可以通过使用`ref`提取`mag`的名字，然后从`match`中返回它：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Which prints: `The magician''s name is Gandalf`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果为：`The magician's name is Gandalf`.
- en: References are the most common pointer type and have the most possibilities;
    other pointer types should only be applied in very specific use cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是最常见的指针类型，并且具有最多的可能性；其他指针类型应该只应用于非常特定的用例。
- en: Ownership and borrowing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权和借用
- en: In the previous section, the word *borrowed* was mentioned in most error messages.
    What's this all about? What is the logic behind this borrow-checker mechanism?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，大多数错误信息中提到了“借用”。这究竟是怎么回事？这个借用检查机制背后的逻辑是什么？
- en: 'Every program, whatever it does, whether reading data from a database or making
    a computation, is concerned with handling resources. The most common resource
    in a program is the memory space allocated to its variables. Other resources could
    be files, network connections, database connections, and so on. Every resource
    is given a name when we make a binding to it with `let`; in Rust''s language,
    we say that the resource gets an owner, for example, in the following code snippet,
    `klaatu` owns a piece of memory that is taken up by the `Alien` struct instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序，无论它做什么，无论是从数据库读取数据还是进行计算，都涉及到处理资源。程序中最常见的资源是分配给其变量的内存空间。其他资源可能是文件、网络连接、数据库连接等等。当我们用`let`绑定一个资源时，每个资源都会被赋予一个名称；在Rust语言中，我们说资源获得了一个所有者，例如，在以下代码片段中，`klaatu`拥有由`Alien`结构体实例占据的一块内存：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Only the owner can change the object it points to, and there can only be one
    owner at a time, because the owner is responsible for freeing the object's resources.
    When a reference goes out of scope, it will not deallocate the underlying memory,
    because the reference is not the owner of the value. This makes sense; if an object
    could have many owners, its resources could be freed more than once, which would
    lead to problems. When the owner's lifetime has passed, the compiler frees the
    memory automatically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 只有所有者才能更改它所指向的对象，并且一次只能有一个所有者，因为所有者负责释放对象的资源。当一个引用超出作用域时，它不会释放底层内存，因为引用不是值的所有者。这很有道理；如果一个对象可以有多个所有者，它的资源可能会被多次释放，这会导致问题。当所有者的生命周期结束时，编译器会自动释放内存。
- en: 'The owner can move the ownership of the object to another variable as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者可以将对象的拥有权移动到另一个变量，如下所示：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the ownership has moved from `klaatu` to `kl2`, but no data is actually
    copied. The original owner `klaatu` cannot be used anymore:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有权已从`klaatu`移动到`kl2`，但实际上没有数据被复制。原始所有者`klaatu`不能再使用了：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It gives the compiler error as: `use of moved value ''klaatu.planet''`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它会给出编译器错误：`use of moved value 'klaatu.planet'`。
- en: On the other hand, we can borrow the resource by making a (in this example mutable)
    reference `kl2` to `klaatu` with `let kl2 = &mut klaatu;`. A borrow is a temporary
    reference that passes the address of the data structure through `&`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过创建一个（在这个例子中是可变的）引用`kl2`到`klaatu`来借用资源，使用`let kl2 = &mut klaatu;`。借用是一个通过`&`传递数据结构地址的临时引用。
- en: 'Now, `kl2` can change the object, for instance, when our alien loses a tentacle
    in a battle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`kl2`可以更改对象，例如，当我们的外星人在战斗中失去一个触手时：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This prints out: `Venus – 14`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：`Venus – 14`。
- en: 'However, we will get an error message if we try to change the alien''s planet
    through the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试通过以下代码更改外星人的星球，将会得到一个错误信息：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The error message is `error:` ``cannot assign to `klaatu.planet` because it
    is borrowed;`` it was indeed borrowed by `kl2`. Similar to everyday life, while
    an object is borrowed, the owner does not have access to it as it is no longer
    in their possession. In order to change the resource, `klaatu` needs to own it,
    without the resource being borrowed at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息是`error:` ``cannot assign to `klaatu.planet` because it is borrowed;``它确实被`kl2`借用了。类似于日常生活，当一个对象被借用时，所有者无法访问它，因为它不再在他们手中。为了更改资源，`klaatu`需要拥有它，同时资源没有被同时借用。
- en: 'Rust even explains this to us with the note that it adds: `borrow of ''klaatu.planet''
    occurs here ownership.rs:8 let kl2 = &mut klaatu;`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Rust甚至通过添加注释来向我们解释这一点：`borrow of 'klaatu.planet' occurs here ownership.rs:8
    let kl2 = &mut klaatu;`。
- en: 'Since `kl2` borrows the resource, Rust also even forbids us to access the instance
    with its former name, `klaatu`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`kl2`借用了资源，Rust甚至禁止我们使用其旧名称`klaatu`来访问实例：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The compiler then throws this error message: `error: cannot borrow ''klaatu.planet''
    as immutable because ''klaatu'' is also borrowed as mutable`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，编译器会抛出这个错误信息：`error: cannot borrow ''klaatu.planet'' as immutable because
    ''klaatu'' is also borrowed as mutable`。'
- en: When a resource is moved or borrowed, the previous owner can no longer use it.
    This prevents the memory problem that is known as a dangling pointer, which is
    the use of a pointer that points to an invalid memory location.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个资源被移动或借用时，原始所有者将无法再使用它。这防止了被称为悬垂指针的内存问题，即使用指向无效内存位置的指针。
- en: 'But here is a revelation: if we isolate the borrowing by `kl2` in its own block,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个启示：如果我们通过`kl2`将其借用隔离在其自己的代码块中，如下所示：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The former problems have disappeared! After the block, we can now do for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的问题已经消失了！在代码块之后，我们现在可以例如这样做：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This prints:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why does this happen? Because after the closing `}` of the code block in which
    `kl2` was bound, its lifetime ended. The borrowing was over (a borrow has to end
    sometime) and `klaatu` reclaimed full ownership, and thus the right to change.
    When the compiler detects that the lifetime of the original owner, `klaatu` ,
    has eventually ended, the memory occupied by the struct instance is automatically
    freed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？因为当`kl2`被绑定在代码块中，并且该代码块的`}`闭合后，它的生命周期就结束了。借用结束（借用必须在某时结束）并且`klaatu`重新获得了全部所有权，因此拥有了更改的权利。当编译器检测到原始所有者`klaatu`的生命周期最终结束时，结构体实例所占用的内存会自动释放。
- en: In fact, this is a general rule in Rust; whenever an object goes out of scope
    and it doesn't have an owner anymore, its destructor is automatically called and
    the resources owned by it are freed so that there can never be any memory (or
    other resource) leaks. In other words, Rust obeys the **Resource Acquisition Is
    Initialization** (**RAII**) rule. For more information, go to [http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是Rust中的一个通用规则；每当一个对象超出作用域并且不再有所有者时，它的析构函数会自动被调用，它所拥有的资源会被释放，这样就不会有任何内存（或其他资源）泄漏。换句话说，Rust遵循**资源获取即初始化**（**RAII**）规则。更多信息，请访问[http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)。
- en: As we experimented in the *References* section, a resource can be immutably
    borrowed many times, but while it is immutably borrowed, the original data can't
    be mutably borrowed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*引用*部分所实验的，一个资源可以被不可变地借用多次，但在它被不可变地借用期间，原始数据不能被可变地借用。
- en: 'Another way to move a resource (and transfer the ownership) is to pass it as
    an argument to a function; try this out in the following exercise:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 移动资源（并转移所有权）的另一种方式是将它作为参数传递给一个函数；在下面的练习中尝试一下：
- en: Examine the situation (`let kl2 = &klaatu;`) when `kl2` is not a mutable reference.
    Can you change the instance through `kl2`? Can you change the instance through
    `klaatu`? Explain the error with what you know about ownership and borrowing (refer
    to `Chapter 6/exercises/ownership3.rs`).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`kl2`不是可变引用的情况下的情况（`let kl2 = &klaatu;`）。你能通过`kl2`更改实例吗？你能通过`klaatu`更改实例吗？用你所知道的关于所有权和借用的知识解释错误（参考`Chapter
    6/exercises/ownership3.rs`）。
- en: What will happen in the previous program if we do `let klaatuc = klaatu;` before
    we define the `let kl2 = &klaatu;` binding?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在定义`let kl2 = &klaatu;`绑定之前做`let klaatuc = klaatu;`会发生什么？
- en: Examine if you can change the mutability of a resource by moving from an immutable
    owner to a mutable owner.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你是否可以通过从一个不可变所有者移动到一个可变所有者来更改资源的可变性。
- en: For our `Alien` struct, write a `grow_a_tentacle` method that increases the
    number of tentacles by one (refer to `Chapter 6/exercises/grow_a_tentacle.rs`).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的 `Alien` 结构体，编写一个 `grow_a_tentacle` 方法，该方法通过一个增加触手的数量（参看 `Chapter 6/exercises/grow_a_tentacle.rs`）。
- en: Boxes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒子
- en: 'Another pointer type in Rust is called the boxed pointer, `Box<T>`, which can
    be defined for a value of a generic `T` type. A box is a non-copyable value. This
    pointer type is used to allocate objects on the heap. For example, here we allocate
    an `Alien` value on the heap by using the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的另一种指针类型称为盒子指针，`Box<T>`，它可以定义一个泛型 `T` 类型的值。盒子是一个不可复制的值。这种指针类型用于在堆上分配对象。例如，在这里我们通过以下代码在堆上分配一个
    `Alien` 值：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `a1` variable is the only owner of this memory resource that may read from
    and write to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`a1` 变量是这个可能被读取和写入的内存资源的唯一拥有者。'
- en: 'We can make a reference to the value pointed to by the box pointer, and if
    both the original box and this new reference are mutable, we can change the object
    through this reference:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引用由盒子指针指向的值，如果原始盒子和这个新的引用都是可变的，我们可以通过这个引用来更改对象：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After such a borrowing, the usual ownership rules as specified earlier hold,
    since `a1` no longer has access, not even for reading:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这样的借用之后，通常的拥有权规则如前所述仍然适用，因为 `a1` 已经无法访问，甚至无法读取：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also use this mechanism to put simple values on the heap as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这种机制将简单值放在堆上，如下所示：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As always, `n` points by default to an immutable value and any attempt to change
    this with:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，`n` 默认指向一个不可变值，任何尝试通过以下方式更改此值的尝试：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Provokes the error: `cannot assign to immutable ''Box'' content ''*n''`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致错误：`无法分配给不可变的 'Box' 内容 '*n'`。
- en: 'Another reference can also point to the dereferenced `Box` value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个引用也可以指向解引用的 `Box` 值：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following example, we again see a boxed value pointed to by `n`, but
    the ownership of the value is now given to a mutable pointer, `m`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们再次看到由 `n` 指向的盒子值，但现在值的拥有权已经给了可变指针 `m`：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By dereferencing `m` and assigning a new value to `m`, this value is entered
    into the memory location that was originally pointed to by `n`. Of course, `n`
    cannot be used anymore; we get the error: `use of moved value: ''n'' message because
    n is no longer the owner of the value`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '通过解引用 `m` 并将新值赋给 `m`，这个值被输入到原本由 `n` 指向的内存位置。当然，`n` 不能再使用了；我们得到错误信息：`use of
    moved value: ''n''`，因为 `n` 已不再是该值的拥有者。'
- en: 'Here is another example where the ownership has clearly has moved from `a1`
    to `a2`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，拥有权已经从 `a1` 移动到 `a2`：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: No data being copied here, except the address of the struct value. After the
    move, `a1` can no longer be used to access the data, and `a2` is responsible for
    freeing the memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有复制任何数据，只是复制了结构值地址。移动后，`a1` 无法再用来访问数据，`a2` 负责释放内存。
- en: 'If `a2` is given as an argument to a function such as `use_alien` in the following
    code snippet, `a2` also gives up the ownership, which is then transferred to the
    function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `a2` 作为参数传递给函数，如以下代码片段中的 `use_alien` 函数，`a2` 也会放弃拥有权，然后该拥有权被传递给函数：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This prints out: `An alien from planet Mars is freed`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出：`来自火星的外星人被释放了`。
- en: 'Indeed, when `use_alien()` has finished executing, the memory allocation for
    that value is freed. However, in general, you must always let your function take
    a simple reference as a parameter (in a similar way to the `square` function explained
    earlier), rather than take a parameter of the `Box` type. We could improve our
    example by calling a `use_alien2` function as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当 `use_alien()` 执行完毕后，该值的内存分配被释放。然而，通常，你必须始终让你的函数接受一个简单的引用作为参数（类似于前面解释的
    `square` 函数），而不是接受 `Box` 类型的参数。我们可以通过以下方式调用 `use_alien2` 函数来改进我们的示例：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And calling it with: `use_alien2(&*a2);`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 并且通过以下方式调用它：`use_alien2(&*a2);`。
- en: 'Sometimes, your program may need to manipulate a recursive data structure that
    refers to itself, as shown in the following struct:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的程序可能需要操作一个递归数据结构，该结构指向自身，如下面的 struct 所示：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This represents a list of lists of bytes. The `rec_list` function is either
    a `Some<Box<Recurs>>` function containing a `Box` pointer to another list or a
    `None` value, which means that the list of lists ends there. Since the number
    of items in this list (and thus its size) is only known at runtime such structures
    must be always constructed as a `Box` type. For other use cases, you must prefer
    references over Boxes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个字节列表的列表。`rec_list`函数要么是一个包含指向另一个列表的`Box`指针的`Some<Box<Recurs>>`函数，要么是一个`None`值，这意味着列表的列表在这里结束。由于这个列表（及其大小）的数量只在运行时才知道，因此这些结构必须始终作为`Box`类型构造。对于其他用例，你必须优先选择引用而不是盒子。
- en: Reference counting
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数
- en: Sometimes, you need several references to an immutable value at the same time;
    this is also called shared ownership. `Box<T>` can't help us out here because
    this type has a single owner by definition. For this, Rust provides the generic
    reference counted box, `Rc<T>`, where multiple references can share the same resource.
    The `std::rc` module provides a way to share ownership of the same value between
    different `Rc` pointers; the value remains alive as long as there is least one
    pointer referencing it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要同时引用一个不可变值；这也被称为共享所有权。`Box<T>`在这里帮不上忙，因为这个类型按照定义只有一个所有者。为此，Rust提供了通用的引用计数盒，`Rc<T>`，其中多个引用可以共享相同的资源。`std::rc`模块提供了一种在不同`Rc`指针之间共享相同值所有权的方法；只要至少有一个指针引用它，该值就会保持活跃。
- en: 'In the following example, we have aliens that have a number of tentacles. Each
    `Tentacle` has to indicate to which `Alien` it belongs; besides this, it also
    has other properties (such as a degree of poison), so we define it also as a struct.
    A first attempt at this could be the following code, which however does not compile
    (from `Chapter 6/code/refcount_not_good.rs`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有拥有多个触手的异形。每个`Tentacle`必须表明它属于哪个`Alien`；除此之外，它还有其他属性（例如毒性的程度），因此我们也将其定义为结构体。这个尝试的第一步可能是以下代码，然而它无法编译（来自`Chapter
    6/code/refcount_not_good.rs`）：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The compiler gives the following error for the line in the for loop: `error:
    use of moved value ''dhark'' - note: ''dhark'' moved here because it has type
    ''Alien'', which is non-copyable`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '编译器在for循环的行给出了以下错误：`error: use of moved value ''dhark'' - note: ''dhark'' moved
    here because it has type ''Alien'', which is non-copyable`。'
- en: When it is defined, each `Alien Tentacle` seemingly tries to make a copy of
    the `Alien` instance as its owner, which makes no sense and is not allowed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被定义时，每个`Alien Tentacle`似乎都试图复制一个`Alien`实例作为其所有者，这是没有意义且不被允许的。
- en: 'The correct version defines the owner in the `Tentacle` struct to have the
    `Rc<Alien>` type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的版本在`Tentacle`结构体中定义所有者为`Rc<Alien>`类型：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This prints the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出以下内容：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We envelop our `Alien` instance in an `Rc<T>` type with `Rc::new(dhark)`. Applying
    the `clone()` method on this `Rc` object provides each `Tentacle` with its own
    reference to the `Alien` object. Note that `clone()` here copies the `Rc` pointer,
    not the `Alien` struct. We also annotate the structs with `#[derive(Debug)]` so
    that we can print out their instances through a `println!("{:?}", t);`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Rc::new(dhark)`将`Alien`实例包裹在`Rc<T>`类型中。对这个`Rc`对象应用`clone()`方法为每个`Tentacle`提供对`Alien`对象的独立引用。注意，这里的`clone()`复制的是`Rc`指针，而不是`Alien`结构体。我们还使用`#[derive(Debug)]`注解结构体，这样我们就可以通过`println!("{:?}",
    t);`打印出它们的实例。
- en: If we want mutability inside our `Rc` type, we have to either use a *Cell* pointer
    if the value implements the *Copy* trait or a *RefCell* pointer. Both these smart
    pointers are found in the `std:cell` module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`Rc`类型内部实现可变性，我们必须要么使用实现了`*Copy*`特质的值的`*Cell*`指针，要么使用`*RefCell*`指针。这两个智能指针都位于`std:cell`模块中。
- en: However, the `Rc` pointer type can only be used inside one thread of execution.
    If you need shared ownership across multiple threads, you need to use the `Arc<T>`
    pointer (short for **atomic reference counted box**), which is the thread-safe
    counterpart of `Rc` (refer to the *Atomic reference counting* section of [Chapter
    8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency and Parallelism"), *Concurrency
    and Parallelism*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Rc`指针类型只能用于单个执行线程中。如果你需要在多个线程之间共享所有权，你需要使用`Arc<T>`指针（简称**原子引用计数盒**），它是`Rc`的线程安全版本（参考[第8章](part0065.xhtml#aid-1TVKI2
    "第8章。并发与并行")的*原子引用计数*部分，*并发与并行*）。
- en: An overview of pointers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针概述
- en: In the following table, we summarize the different pointers used in Rust. `T`
    represents a generic type. We haven't yet encountered the `Arc`, `*const`, and
    `*mut` pointers, but they are included here for completeness.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，我们总结了 Rust 中使用的不同指针。`T` 代表一个泛型类型。我们尚未遇到 `Arc`、`*const` 和 `*mut` 指针，但为了完整性，它们也被包括在内。
- en: '| Pointers | Pointer names | Description |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | 指针名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `&T` | Reference | This allows one or more references to read `T`. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `&T` | 引用 | 这允许一个或多个引用读取 `T`。 |'
- en: '| `&mut T` | Mutable reference | This allows a single reference to read and
    write `T`. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `&mut T` | 可变引用 | 这允许对 `T` 进行单个引用的读取和写入。 |'
- en: '| `Box<T>` | Box | This is a heap-allocated `T` with a single owner that may
    read and write `T`. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Box<T>` | Box | 这是一个具有单个所有者且可以读取和写入 `T` 的堆分配 `T`。 |'
- en: '| `Rc<T>` | Rc pointer | This is a heap-allocated `T` with many readers. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `Rc<T>` | Rc 指针 | 这是一个具有多个读者的堆分配 `T`。 |'
- en: '| `Arc<T>` | Arc pointer | This is like `Rc<T>`, but enables safe mutable sharing
    across threads (refer to [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*). |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `Arc<T>` | Arc 指针 | 这类似于 `Rc<T>`，但允许线程之间安全地可变共享（参考[第8章](part0065.xhtml#aid-1TVKI2
    "第8章。并发与并行")，*并发与并行*）。 |'
- en: '| `*const T` | Raw pointer | This allows unsafe read access to `T` (refer to
    [Chapter 9](part0069.xhtml#aid-21PMQ1 "Chapter 9. Programming at the Boundaries"),
    *Programming at the Boundaries*). |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `*const T` | 原始指针 | 这允许对 `T` 进行不安全地读取访问（参考[第9章](part0069.xhtml#aid-21PMQ1
    "第9章。边界编程")，*边界编程*）。 |'
- en: '| `*mut T` | Mutable raw pointer | This allows unsafe read and write access
    to `T` (refer to [Chapter 9](part0069.xhtml#aid-21PMQ1 "Chapter 9. Programming
    at the Boundaries"), *Programming at the Boundaries*). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `*mut T` | 可变原始指针 | 这允许对 `T` 进行不安全地读取和写入访问（参考[第9章](part0069.xhtml#aid-21PMQ1
    "第9章。边界编程")，*边界编程*）。 |'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned the intelligence behind the Rust compiler, which
    is embodied in the principles of ownership, moving values, and borrowing. We saw
    the different pointers that Rust advocates: references, boxes, and reference counters.
    Now that we have a grasp on how this all works together, we will understand the
    errors, warnings, and messages the compiler may throw at us in a much better way.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Rust 编译器的智慧，这体现在所有权、移动值和借用原则中。我们看到了 Rust 所倡导的不同指针：引用、boxed 和引用计数器。现在我们已经掌握了这一切是如何协同工作的，我们将以更好的方式理解编译器可能会抛出的错误、警告和信息。
- en: In the following chapter, we will expose the bigger units of code organization
    in code, such as modules and crates, and how we can write macros to make coding
    less repetitive.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示代码中更大的代码组织单元，如模块和 crate，以及我们如何编写宏来减少代码的重复性。
