<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Advanced Rust Tools and Libraries</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Rust Tools and Libraries</h1>
                </header>
            
            <article>
                
<p>We will cover the following recipes in this chapter:</p>
<ul>
<li>Setting up rustup</li>
<li>Setting up rustfmt</li>
<li>Setting up rust-clippy</li>
<li>Setting up and testing with Servo</li>
<li>Generating random numbers</li>
<li>Writing lines to a file</li>
<li>Parsing unstructured JSON</li>
<li>Parsing URL from a string</li>
<li>Decompressing a tarball</li>
<li>Compressing a directory to a tarball</li>
<li>Finding file extensions recursively</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn about the various Rust tools, such as rustfmt and rustup, that help us write better production level Rust code, catch errors, and also provide us with the equipment to do extreme experimentation with different versions of the Rust compiler. Apart from these tools, we will set up and understand the Servo project, which is a state-of-the-art browsing engine that contributes a lot to the design of the Rust language. The last few recipes of this chapter will take the readers through the different ground-level libraries in Rust that contribute a lot to faster project development, by providing the developer with various common operations and functionalities out of the box.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up rustup</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the different options available with the rustup tool that enable us to run the Rust applications in different versions and many more related functionalities.</p>
<p>The rustup tool is the official Rust language installer for rustc, Cargo, and other standard tools to Cargo's <kbd>bin</kbd> directory. <span>On Unix, it is located at</span> <kbd>$HOME/.cargo/bin</kbd> <span>and on Windows at</span> <kbd>%USERPROFILE%\.cargo\bin</kbd><span>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will need to set up the rustup tool in order to perform the different activities of this recipe.</p>
<p>Follow the steps to install the rustup tool:</p>
<ol>
<li>Check for the version of the Rust compiler:</li>
</ol>
<pre><strong>      rustc --version</strong>
</pre>
<ol start="2">
<li>If we are able to get an output such as <kbd>rustc 1.18.0 (03fc9d622 2017-06-06)</kbd>, this means that the rustup tool is set up. The version number may change according to the stable version last downloaded in the system.</li>
<li>If you are not able to get the compiler version, follow the installation recipes from <a href="rs-cb_ch01.html">Chapter 1</a>, <em>Let's Make System Programming Great Again</em>, or run the following command in the Terminal:</li>
</ol>
<pre><strong>      curl https://sh.rustup.rs -sSf | sh</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Update the stable version of Rust to the latest version:</li>
</ol>
<pre><strong>      rustup update stable</strong>
</pre>
<ol start="2">
<li>Update the <kbd>rustup</kbd> tool to the latest version:</li>
</ol>
<pre><strong>      rustup self update</strong>
</pre>
<ol start="3">
<li>Install the <kbd>nightly</kbd> toolkit version of the Rust compiler:</li>
</ol>
<pre><strong>      rustup install nightly</strong>
</pre>
<ol start="4">
<li>Run the <kbd>nightly</kbd> version of Rust without changing the default version of Rust:</li>
</ol>
<pre><strong>      rustup run nightly rustc --version</strong>
</pre>
<ol start="5">
<li>Change the <kbd>default</kbd> version of the Rust compiler to the <kbd>nightly</kbd> version:</li>
</ol>
<pre><strong>      rustup default nightly</strong>
</pre>
<ol start="6">
<li>Update the <kbd>nightly</kbd> version of Rust:</li>
</ol>
<pre>      rustup update
</pre>
<ol start="7">
<li>This will update both the stable and nightly versions of the Rust compiler.</li>
</ol>
<p>We should get the following output on execution of the rustup tool:</p>
<ul>
<li>On installation of the nightly version:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="379" width="564" src="images/a3a9d203-88ab-41ae-b234-c3b59abda0ad.png"/></div>
<ul>
<li>Setting nightly as the default version:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="81" width="592" src="images/b37e7382-d0bf-4f7b-b9a2-5046a88c437e.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root"><kbd>rustup</kbd> is a toolchain multiplexer that installs and manages many Rust toolchains, and all of them are present in a single set of tools located at <kbd>~/.cargo/bin</kbd>. As we run examples, <kbd>rustup</kbd> provides mechanisms to easily change the active toolchain, such as <kbd>rustc</kbd> and <kbd>cargo</kbd> at <kbd>~/.cargo/bin</kbd>, by reconfiguring the locations in the background.</p>
<p class="mce-root">When <kbd>rustup</kbd> is installed for the first time, the compiler rustc will be present in <kbd>$HOME/.cargo/bin/rustc</kbd>, which, by default, is the stable version. If you later change the default toolchain to nightly with commands such as <kbd>rustup install nightly</kbd> and <kbd>rustup default nightly</kbd>, the location will change and the nightly compiler will run instead of the stable one.</p>
<p class="mce-root">The <kbd>rustup update</kbd> command basically helps us fetch the latest version of the compiler. Rust is distributed on three different release channels: stable, beta, and nightly. rustup is configured to use the stable channel by default, which represents the latest release of Rust and is released every six weeks.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up rustfmt</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps by which one can set up and use the <kbd>rustfmt</kbd> tool in their day-to-day Rust project development. <kbd>rustfmt</kbd> is a tool for formatting the Rust code according to standard style guidelines of the Rust language. It is an open source project and welcomes contribution from the Rust community members. The style guides are decided by the Rust <span><strong>request for comments</strong> (<strong>RFC</strong></span>) procedure, which is an open discussion about the Rust language changes, such as feature requests, bug fixes, and documentation. This is a very important character trait for a programming language as it gives more authority to the developer community than the company that originated the language.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will follow the steps to set up the tool:</p>
<ol>
<li>Install the nightly version of the Rust compiler:</li>
</ol>
<pre><strong>      rustup install nightly</strong>
</pre>
<ol start="2">
<li>Set up the Rust compiler version to the nightly toolchain:</li>
</ol>
<pre><strong>      rustup default nightly</strong>
</pre>
<ol start="3">
<li>Create a new Rust project using Cargo and install the <kbd>rustfmt</kbd> tool:</li>
</ol>
<pre><strong>      cargo new --bin sample_rust_project</strong><br/><br/><strong>      cd sample_rust_project </strong><br/><br/><strong>      cargo install rustfmt-nightly</strong>
</pre>
<p>You should get the following output on installing the <kbd>rustfmt</kbd> tool if everything works fine without any errors:</p>
<div class="CDPAlignCenter CDPAlign"><img height="511" width="610" src="images/ca353f50-a1ad-468b-9b99-2a5fc7164b39.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information, but the catch here is that we purposefully impose incorrect indentations:</li>
</ol>
<pre>        //-- #########################<br/>            //-- Task: Testing cargo fmt features<br/>            //-- Author: Vigneshwer.D<br/>          //-- Version: 1.0.0<br/>           //-- Date: 04 May 17<br/>          //-- ######################### 
</pre>
<ol start="3">
<li>Define the <kbd>main</kbd> function with some random spacing and style:</li>
</ol>
<pre>        fn main() {<br/>          println!("Hello, world!");<br/>        } 
</pre>
<ol start="4">
<li>Now, run <kbd>rustfmt</kbd> to fix the style issues of the code:</li>
</ol>
<pre><strong>      cargo fmt</strong>
</pre>
<p>You should get the following output on successfully executing the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="279" width="552" src="images/fbc45fd6-f502-4718-9d7f-231ffce4253d.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we basically introduce the <kbd>rustfmt</kbd> tool that helps us follow the correct style guide implied by the Rust programming language in an automated manner, where the developer can freely use the tool to follow style standards.</p>
<p>From the output of the <kbd>main.rs</kbd> file, we can see that the wrong indentation in the code was automatically corrected and overwritten in the <kbd>main.rs</kbd> file with the <kbd>cargo fmt</kbd> command, and that a backup of the previous code was saved in the <kbd>main.rs.bk</kbd> file.</p>
<p>There are various modes in which we can run the <kbd>rustfmt</kbd> tool, as follows:</p>
<ul>
<li><kbd>replace</kbd>: This is the default selection that overwrites the original files and creates backup files after formatting; <kbd>cargo fmt</kbd> uses <kbd>--write-mode=replace</kbd> by default.</li>
<li><kbd>overwrite</kbd>: This option basically changes the original files without creating a backup of the previous code.</li>
<li><kbd>display</kbd>: This option basically prints the formatted files to <kbd>stdout</kbd>, that shows the changes made in the terminal screen.</li>
<li><kbd>diff</kbd>: This option prints the difference between the original files and formatted files to <kbd>stdout</kbd>. This will also exit with an error code if there are any differences.</li>
<li><kbd>checkstyle</kbd>: This option will output the lines that need to be corrected as a checkstyle XML file that can be used with tools such as Jenkins.</li>
</ul>
<p>In order to use these write modes, we need to install the <kbd>rustfmt</kbd> tool by source, where we clone the main GitHub repository and install from the source with the following code:</p>
<pre><strong>cargo install --path</strong> 
</pre>
<p>This enables us to run formatting commands on any Rust files with various modes, such as the following example:</p>
<pre><strong>rustfmt main.rs</strong><br/><br/><strong>rustfmt --write-mode=overwrite main.rs</strong>
</pre>
<div class="packt_tip">It is a good practice to run the <kbd>rustfmt</kbd> tool before building the project so that we can maintain code standards without much effort. The ideal way to do this is to configure the <kbd>rustfmt</kbd> tool in your favorite text editor and have the <kbd>rustfmt</kbd> commands as a part of the build process.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up rust-clippy</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps to use the rust-clippy tool. The tool basically helps the developer to catch common mistakes and improves your Rust project code by having a collection of lints. The Clippy tool currently works with the latest Rust nightly for now. Since this is a tool for helping the developer of a library or an application to write better code, it is recommended not to include Clippy as a hard dependency and it is mostly used as an optional dependency.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the steps to install the rust-clippy tool:</p>
<ol>
<li>Change the default compiler to the nightly version:</li>
</ol>
<pre><strong>      rustup default nightly</strong>
</pre>
<ol start="2">
<li>Set up rust-clippy as an optional dependency by making a modification in the <kbd>Cargo.toml</kbd> file:</li>
</ol>
<pre>        [dependencies]<br/>        clippy = {version = "*", optional = true}<br/><br/>        [features]<br/>        default = []
</pre>
<ol start="3">
<li>The <kbd>Cargo.toml</kbd> file will look similar to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="136" width="485" src="images/29a1e415-d742-42a5-918b-36ccf82ec62a.png"/></div>
<ol start="4">
<li>Install Clippy from the Cargo tool:</li>
</ol>
<pre><strong>      cargo install clippy</strong>
</pre>
<ol start="5">
<li>Set up Clippy as a compiler plugin, by adding Clippy as a dependency to the <kbd>Cargo.toml</kbd> file:</li>
</ol>
<pre>        [dependencies]<br/>        clippy = "*"
</pre>
<ol start="6">
<li>The <kbd>Cargo.toml</kbd> file will look similar to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="98" width="468" src="images/075f4f4e-05bc-44aa-aaac-f8b61a350f2d.png"/></div>
<ol start="7">
<li>Set up a new project for experimenting with the rust-clippy tool:</li>
</ol>
<pre><strong>      cargo new --bin sample_rust_project</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Testing rust-clippy tool<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 28 April 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a <kbd>main</kbd> function, and copy and paste the code:</li>
</ol>
<pre>        fn main(){<br/>        let x = Some(1u8);<br/>        match x {<br/>          Some(y) =&gt; println!("{:?}", y),<br/>          _ =&gt; ()<br/>        }<br/>        }
</pre>
<ol start="4">
<li>Copy and paste the code snippet above the <kbd>main</kbd> function at the beginning of the code to use rust-clippy as an optional dependency:</li>
</ol>
<pre>      #![cfg_attr(feature="clippy", feature(plugin))]<br/><br/>      #![cfg_attr(feature="clippy", plugin(clippy))]
</pre>
<ol start="5">
<li>Run Clippy with the command <kbd>cargo build --features "clippy"</kbd>.</li>
<li>For running Clippy as a subcommand, run the following command:</li>
</ol>
<pre><strong>        cargo clippy</strong>
</pre>
<ol start="7">
<li>Copy paste the code snippet above the <kbd>main</kbd> function at the beginning of the code to use rust-clippy as a compiler plugin:</li>
</ol>
<pre>        #![feature(plugin)]<br/>        #![plugin(clippy)]
</pre>
<ol start="8">
<li>When we run the <kbd>cargo run</kbd> command, Cargo will install Clippy and show a warning.</li>
</ol>
<p>We will get the following output for the preceding three different methods:</p>
<ul>
<li>Running Clippy as an optional dependency:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="479" width="661" src="images/31a85060-fade-4988-b54c-1f6d59edd0bd.png"/></div>
<ul>
<li>Running Clippy as a Cargo subcommand:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="183" width="690" src="images/fc17f038-c23f-496d-8ae8-41c5fb123394.png"/></div>
<ul>
<li>Running Clippy as a compiler plugin:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="701" src="images/235b2653-561c-4474-b65d-0ac7a3929134.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you learned the methods by which you can use the Clippy tool to catch the different lints in the code and get suggestions to improve them.</p>
<p>When we use Clippy as an optional dependency, we set the optional flag as <kbd>true</kbd> when mentioning Clippy as a dependency in the <kbd>Cargo.toml</kbd> file. In the feature section, we have a default set of optional packages. Most of the time, developers will want to use these packages, but they are strictly optional. In addition to manipulations in the configuration file, we have to enable the <kbd>#[cfg_attr]</kbd> attribute that generally works with <span><kbd>#[cfg_attr(condition, attribute)]</kbd>, where it allows us to compile the Rust script <kbd>main.rs</kbd> if the condition is true; that is, if the condition is <kbd>true</kbd>, it's equivalent to <kbd>#[attribute]</kbd>, and if the condition is <kbd>false</kbd>, it does not proceed.</span></p>
<p>The <kbd>cargo clippy</kbd> command is the easiest way to run the Clippy tool as it does not require any manipulations in the configuration or code.</p>
<p>In the third way, we add the <kbd>clippy</kbd> dependency in the <kbd>Cargo.toml</kbd> file without mentioning it as a feature and loading it as a compiler plugin. We do syntax extension by calling <kbd>#![feature(plugin)]</kbd> and <kbd>#![plugin(clippy)]</kbd>.</p>
<div class="packt_infobox">rustc can load compiler plugins, which are user-provided libraries that extend the compiler's behavior with new syntax extensions, lint checks, and so on. There are around 200 lints and this is a growing number configured with the rust-clippy tool that helps developers write better Rust code.</div>
<p>A good place to use the tool would be to have the <kbd>cargo clippy</kbd> command in the CI script processes for the project before building the projects, similar to the <kbd>rustfmt</kbd> tool.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up and testing with Servo</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will set up the Servo browser in our systems and test the performance of a website in it.</p>
<p class="mce-root">Servo is a parallel browser engine project sponsored by Mozilla and written in Rust. The Servo project aims to achieve better parallelism, security, modularity, and performance. In short, Servo is a modern, high-performance browser engine designed for both application and embedded use.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will need to install the following dependencies in our systems to run the Servo browser:</p>
<ol>
<li>Open the Terminal and install the following packages:</li>
</ol>
<pre><strong>      sudo apt install git curl freeglut3-dev autoconf libx11-dev \</strong><br/><strong>      libfreetype6-dev libgl1-mesa-dri libglib2.0-dev xorg-dev \</strong><br/><strong>      gperf g++ build-essential cmake virtualenv python-pip \</strong><br/><strong>      libssl1.0-dev libbz2-dev libosmesa6-dev libxmu6 libxmu-dev \</strong><br/><strong>      libglu1-mesa-dev libgles2-mesa-dev libegl1-mesa-dev libdbus-1-dev</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement the build of the Servo project:</p>
<ol>
<li>Open the Terminal, and clone the Servo project from GitHub:</li>
</ol>
<pre><strong>      git clone https://github.com/servo/servo</strong>
</pre>
<ol start="2">
<li>Enter the project, and build the browser in the development mode:</li>
</ol>
<pre><strong>      cd servo</strong><br/><strong>      ./mach build --dev</strong>
</pre>
<ol start="3">
<li>To ensure that the project is built correctly, run a small test:</li>
</ol>
<pre><strong>      ./mach run tests/html/about-mozilla.html</strong>
</pre>
<ol start="4">
<li>For benchmarking, performance testing, and other real-world scenarios, add the <kbd>--release</kbd> flag to create an optimized build:</li>
</ol>
<pre><strong>      ./mach build --release</strong><br/><strong>      ./mach run --release tests/html/about-mozilla.html</strong>
</pre>
<ol start="5">
<li>For running a website in the Servo project, use the following code:</li>
</ol>
<pre><strong>      ./mach run [url] </strong><br/><strong>      ex: ./mach run https://www.google.com</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you learned to set up the Servo browser engine and run websites in the engine. Servo is a prototype web browser engine written in the Rust language. It is currently developed on 64-bit macOS, 64-bit Linux, and Android.</p>
<p>Servo is built with Cargo and it uses Mozilla's Mach tools to orchestrate the build and other tasks. We run a URL in Servo with <kbd>./mach run https://www.google.com</kbd>.</p>
<div class="packt_infobox">There are lots of Mach commands we can use for building and hacking. You can list them with <kbd>./mach --help</kbd>.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generating random numbers</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>rand</kbd> crate to generate random numbers within a range provided, which in this recipe is 1 to 10. The rand crate is a very important library used in various scientific operations.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the following steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_rand</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_rand &amp;&amp; cd sample_rand</strong>
</pre>
<ol start="2">
<li>Install the cargo-edit tool that allows you to add and remove dependencies by modifying your <kbd>Cargo.toml</kbd>:</li>
</ol>
<pre><strong>      cargo install cargo-edit</strong>
</pre>
<ol start="3">
<li>Install the <kbd>rand</kbd> dependency:</li>
</ol>
<pre><strong>      cargo add rand</strong>
</pre>
<ol start="4">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="6">
<li>This step will print <kbd>hello world</kbd> as output, as we have not yet made any modifications to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: To generate a random number between the range of 0 to 10<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Copy paste the following code snippet to the <kbd>main.rs</kbd> file after the code header:</li>
</ol>
<pre>        extern crate rand;<br/>        use rand::Rng;<br/>        fn main() {<br/>          let mut rng = rand::thread_rng();<br/>          println!("{}", rng.gen_range(0, 10));<br/>        }
</pre>
<ol start="4">
<li>Save the file and run the project by following the next command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="142" width="616" src="images/ea8dc213-2434-4a28-bfe1-2f05c0e4f201.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we print a random number from a range provided by the developer, which in our case is a value between 0 and 10; we use the <kbd>rand</kbd> library for performing this option.</p>
<p>We import the <kbd>rand</kbd> library with the <kbd>extern crate</kbd> command and use the <kbd>rand::rng</kbd> module that provides us with the <kbd>gen_range</kbd> method. The <kbd>gen_range</kbd> method takes two arguments as input that are lower and higher bound values of the range in which it is supposed to predict a random number. In the case of interchanging the position, it would panic.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing lines to a file</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>std</kbd> crate, which is the Rust standard library providing various modules and functionalities. We will use the filesystem capabilities of the crate to write a three-line message to a file, and then read it back, one line at a time.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_file</kbd>, and enter the directory:</li>
</ol>
<pre><strong>        cargo new --bin sample_file &amp;&amp; cd sample_file</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd> crate dependency:</li>
</ol>
<pre><strong>        cargo add error-chain</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print a <kbd>hello world</kbd> as output, as we have not yet made any modifications to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: File system experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types, after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        use std::fs::File;<br/>        use std::io::{Write, BufReader, BufRead};<br/>        error_chain! {<br/>          foreign_links {<br/>            Io(std::io::Error);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copying and pasting the following code snippet with the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre>        fn run() -&gt; Result&lt;()&gt; {<br/>          let path = "lines.txt";<br/>          let mut output = File::create(path)?;<br/>          write!(output, "Rust\nis\nFun")?;<br/>          let input = File::open(path)?;<br/>          let buffered = BufReader::new(input);<br/>          for line in buffered.lines() {<br/>            println!("{}", line?);<br/>          }<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by running the command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="125" width="724" src="images/6c836a9f-9a97-4b57-91f0-5ba19124f5b5.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we write a three-line message to a file, <kbd>lines.txt</kbd>. We assign the string <kbd>lines.txt</kbd> to a variable named path, which we pass as an argument to <kbd>File::create(path)</kbd> that creates the file, and we assign it to a variable <kbd>output</kbd>. Using the <kbd>write!</kbd> macro, we write a string <kbd>"Rust\n\nFun"</kbd> to the mutable <kbd>output</kbd> variable.</p>
<p>We read the file, then read back with <kbd>File::open(path)</kbd> and assign it to the <kbd>input</kbd> variable. We create a variable named <kbd>buffered</kbd> that stores the content of the file; we then read each line of the file with the <kbd>Lines</kbd> iterator created by <kbd>BufRead::lines</kbd> using a <kbd>for</kbd> loop and print it.</p>
<div class="packt_infobox">BufRead is a trait, and the most common way to get one is from a BufReader that is constructed from some type that implements <kbd>Read</kbd>; here, a file. The file is opened for writing with <kbd>File::create</kbd> and for reading with <kbd>File::open</kbd>.</div>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error-handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> type that acts like a <em>real</em> <kbd>main</kbd> function. We use the <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from the <kbd>error-chain</kbd> crate to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parsing unstructured JSON</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>serde_json</kbd> crate that provides various modules and functionalities for serializing and deserializing unstructured JSON. We will use the encoding capabilities to parse JSON to a type of the caller's choice.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_json</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_json &amp;&amp; cd sample_json</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd> and <kbd>serde_json</kbd> crates dependencies:</li>
</ol>
<pre><strong>      cargo add error-chain serde_json</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print <kbd>hello world</kbd> as output, as we have not yet made any modifications to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Encoding experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types, after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        error_chain! {<br/>          foreign_links {<br/>            Json(serde_json::Error);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copying and pasting the following code snippet with the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre>        #[macro_use]<br/>        extern crate serde_json;<br/>        use serde_json::Value;<br/>        fn run() -&gt; Result&lt;()&gt; {<br/>          let j = r#"{<br/>            "userid": 103609,<br/>            "verified": true,<br/>            "access_privileges": [<br/>              "user",<br/>              "admin"<br/>            ]<br/>          }"#;<br/>          let parsed: Value = serde_json::from_str(j)?;<br/>          let expected = json!({<br/>            "userid": 103609,<br/>            "verified": true,<br/>            "access_privileges": [<br/>              "user",<br/>              "admin"<br/>            ]<br/>          });<br/>          assert_eq!(parsed, expected);<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by running the following next command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/f175f09e-35b4-4ee1-9778-5ce78d7504ee.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we use the <kbd>serde_json</kbd> crate that provides us with a <kbd>from_str</kbd> function that allows the developer to parse <kbd>&amp;str</kbd> of JSON into a type of the caller's choice. We assign a string format of JSON to the <kbd>j</kbd> variable, after which we call <kbd>serde_json::from_str(j)</kbd> and assign the output to a variable named <kbd>parsed</kbd>. The unstructured JSON is parsed into a universal <kbd>serde_json::Value</kbd> type that represents any valid JSON data.</p>
<p class="mce-root">We then compare, with the <kbd>assert_eq!</kbd> macro, the value of the parsed <kbd>&amp;str</kbd> of JSON with what we expect the parsed value to be. The expected value is declared using the <kbd>json!</kbd> macro.</p>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> that acts like a <em>real</em> <kbd>main</kbd> function. We use the <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from the <kbd>error-chain</kbd> to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parsing URL from a string</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>url</kbd> crate that provides various modules and functionalities for networking capabilities. We will use the <kbd>parse</kbd> functionality of the crate to take a string input and convert it into the URL format after validation.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the following steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_url</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_url &amp;&amp; cd sample_url</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd> and <kbd>url</kbd> crates dependencies:</li>
</ol>
<pre><strong>      cargo add error-chain url</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print <kbd>hello world</kbd> as output, as we have not yet made any modifications to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Url experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types, after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        error_chain! {<br/>          foreign_links {<br/>            UrlParse(url::ParseError);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copying and pasting the following code snippet with the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre>        extern crate url;<br/>        use url::Url;<br/>        fn run() -&gt; Result&lt;()&gt; {<br/>          let s = "https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open";<br/>          let parsed = Url::parse(s)?;<br/>          println!("The path part of the URL is: {}", parsed.path());<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="71" width="627" src="images/84994bd7-9ce6-4dbb-affb-42be6f0790a2.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we use the <kbd>parse</kbd> method of the <kbd>url</kbd> crate to validate and parse a <kbd>&amp;str</kbd> from the data into a <kbd>Url</kbd> struct. The input string will be transformed into <kbd>Result&lt;Url, ParseError&gt;</kbd> on the method's return value.</p>
<p class="mce-root">We create a variable named <kbd>s</kbd> and assign it to the URL that we want to parse; the value is sent to the method with <kbd>Url::parse(s)</kbd>. Once the URL has been parsed, it can be used with all methods on the URL type. Finally we print the path part of the <kbd>parsed</kbd> variable that stores the return value of the <kbd>parse</kbd> method.</p>
<div class="mce-root packt_infobox">The URL in this code parses successfully, but swapping it out for a malformed URL will print a message containing an explanation of what went wrong.</div>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> that acts like a <em>real</em> <kbd>main</kbd> function. We use the <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from <kbd>error-chain</kbd> to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Decompressing a tarball</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>tar</kbd> and <kbd>flate2</kbd> crates that provide various modules and functionalities for compression capabilities. We will extract the contents of a tar file named <kbd>archive.tar.gz</kbd> in the current working directory.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the following steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_decom</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_decom &amp;&amp; cd sample_decom</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd>, <kbd>tar</kbd>, and <kbd>flate2</kbd> crates dependencies:</li>
</ol>
<pre><strong>      cargo add error-chain tar flate2</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print <kbd>hello world</kbd> as output, as we have not yet made any modifications to the source code.</li>
<li>Create a sample file, TAR it, and delete it for using it in the recipe:</li>
</ol>
<pre>        touch sample_file1.txt &amp;&amp; tar -cvzf archieve.tar.gz<br/>        sample_file1.txt &amp;&amp; rm sample_file1.txt  
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: tar experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types, after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        error_chain! {<br/>          foreign_links {<br/>            Io(std::io::Error);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copying and pasting the following code snippet with the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre>        extern crate flate2;<br/>        extern crate tar;<br/>        use std::fs::File;<br/>        use flate2::read::GzDecoder;<br/>        use tar::Archive;<br/>        fn run() -&gt; Result&lt;()&gt; {<br/>          let path = "archive.tar.gz";<br/>          // Open a compressed tarball<br/>          let tar_gz = File::open(path)?;<br/>          // Decompress it<br/>          let tar = GzDecoder::new(tar_gz)?;<br/>          // Load the archive from the tarball<br/>          let mut archive = Archive::new(tar);<br/>          // Unpack the archive inside curent working directory<br/>          archive.unpack(".")?;<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<p><img src="images/4e020f5e-eee5-4e96-8e27-957f5a469150.png"/></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we open the file using the <kbd>File::open(path)</kbd> method and assign it to the <kbd>tar_gz</kbd> variable; the <kbd>path</kbd> variable contains the string value, which is the location of the <kbd>archive.tar.gz</kbd> file. We then decompress the <kbd>tar_gz</kbd> file using the <kbd>flate2</kbd> crate with the <kbd>flate2::read::GzDecoder::new(tar_gz)</kbd> command, and assign its return value to the <kbd>tar</kbd> variable. We extract the files with the <kbd>tar::Archive::unpack</kbd> method by first creating a variable <kbd>archive</kbd> by calling <kbd>Archive::new(tar)</kbd> which loads the archive, and then we get all the files from a compressed tarball named <kbd>archive.tar.gz</kbd> located in the current working directory by calling <kbd>archive.unpack(".")</kbd>.</p>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> that acts like a <em>real</em> <kbd>main</kbd> function. We use <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from the <kbd>error-chain</kbd> to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compressing a directory to a tarball</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>tar</kbd> and <kbd>flate2</kbd> crates that provide various modules and functionalities for compression capabilities. We will compress the contents of a directory which, in this recipe, is the current directory to a TAR file named <kbd>archive.tar.gz</kbd> in the same directory.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the following steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_com</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_com &amp;&amp; cd sample_com</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd>, <kbd>tar</kbd>, and <kbd>flate2</kbd> crates dependencies:</li>
</ol>
<pre><strong>      cargo add error-chain tar flate2</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print <kbd>hello world</kbd> as output as we have not yet made any modification to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: tar experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        error_chain! {<br/>          foreign_links {<br/>            Io(std::io::Error);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copy pasting the following code snippet the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre>        extern crate tar;<br/>        extern crate flate2;<br/>        use std::fs::File;<br/>        use flate2::Compression;<br/>        use flate2::write::GzEncoder;<br/>        fn run() -&gt; Result&lt;()&gt; {<br/>          let tar_gz = File::create("archive.tar.gz")?;<br/>          let enc = GzEncoder::new(tar_gz, Compression::Default);<br/>          let mut tar = tar::Builder::new(enc);<br/>          tar.append_dir_all("./backup", "../sample_com")?;<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by following the command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="128" width="527" src="images/667f1c43-f74c-4e56-b504-84a5f7397c7a.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we compress the source code directory into <kbd>archive.tar.gz</kbd>. We create a file with <kbd>File::create("archive.tar.gz")</kbd> and assign it to the <kbd>tar_gz</kbd> variable. We then wrap it using <kbd>flate2::write::GzEncoder</kbd> and <kbd>tar::Builder</kbd>. Lastly, we add the contents of the <kbd>../sample_com</kbd> directory recursively into the archive under <kbd>./backup</kbd> with <kbd>Builder::append_dir_all</kbd>.</p>
<div class="packt_infobox"><kbd>flate2::write::GzEncoder</kbd> is responsible for transparently compressing the data prior to writing it to <kbd>archive.tar.gz</kbd>.</div>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> that acts like a <em>real</em> <kbd>main</kbd> function. We use the <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from the <kbd>error-chain</kbd> to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding file extensions recursively</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the <kbd>glob</kbd> crate that provides various modules and functionalities for filesystem capabilities. We will recursively find all PNG files in the current directory.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow the following steps to set up the project and install the dependencies:</p>
<ol>
<li>Create a new binary project named <kbd>sample_ext</kbd>, and enter the directory:</li>
</ol>
<pre><strong>      cargo new --bin sample_ext &amp;&amp; cd sample_ext</strong>
</pre>
<ol start="2">
<li>Install the <kbd>error_chain</kbd> and <kbd>glob</kbd> crates dependencies:</li>
</ol>
<pre><strong>      cargo add error-chain glob</strong>
</pre>
<ol start="3">
<li><kbd>cargo add crate_name</kbd> automatically adds the latest version of the dependency to the <kbd>Cargo.toml</kbd> file.</li>
<li>Install the dependency by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<ol start="5">
<li>This step will print <kbd>hello world</kbd> as outputs, as we have not yet made any modifications to the source code.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: glob experiments<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 04 May 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Create the <kbd>error_chain!</kbd> macro to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the standard library error types, after the code header:</li>
</ol>
<pre class="mce-root">        #[macro_use]<br/>        extern crate error_chain;<br/>        error_chain! {<br/>          foreign_links {<br/>            Glob(glob::GlobError);<br/>            Pattern(glob::PatternError);<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>run</kbd> method and the <kbd>quick_main!</kbd> macro by copying and pasting the following code snippet with the <kbd>error_chain!</kbd> macro:</li>
</ol>
<pre class="mce-root">        extern crate glob;<br/>        use glob::glob;<br/>        fn run() -&gt; Result&lt;()&gt; {<br/>          for entry in glob("**/*.png")? {<br/>            println!("{}", entry?.display());<br/>          }<br/>          Ok(())<br/>        }<br/>        quick_main!(run);
</pre>
<ol start="5">
<li>Save the file and run the project by running the following command:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We should get the following output on execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="85" width="500" src="images/94f80ece-72d7-4a70-a9bb-bf39077ce598.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will recursively find all PNG files in the current directory. We use the iteration with a <kbd>for</kbd> loop with different entries of the <kbd>glob("**/*.png")</kbd> method that returns us all the <kbd>.png</kbd> file extensions in the current directory. We have a <kbd>**</kbd> pattern that matches the current directory and all subdirectories.</p>
<div class="packt_tip">We can also use the <kbd>**</kbd> pattern for any directory, not just the current one. For example, <kbd>/media/**/*.png</kbd> will match all PNGs in media and its subdirectories. For other file extensions, change <kbd>.png</kbd> to the desired one.</div>
<p>The <kbd>error-chain</kbd> crate is a library for consistent and reliable error handling that makes it easier to take full advantage of Rust's powerful error-handling features, without the overhead of maintaining boilerplate error types and conversions. It implements a strategy for defining your own error types, as well as conversions from others' error types.</p>
<p>The basic pattern we use here has a function named <kbd>run()</kbd> that produces a <kbd>Result</kbd> that acts like a <em>real</em> <kbd>main</kbd> function. We use the <kbd>error-chain</kbd> crate to make <kbd>?</kbd> work within <kbd>run</kbd>. This is using the <kbd>error_chain!</kbd> macro from the <kbd>error-chain</kbd> to define a custom <kbd>Error</kbd> and <kbd>Result</kbd> type, along with automatic conversions from the crate error types. The automatic conversions make the <kbd>?</kbd> operator work. The <kbd>quick_main!</kbd> macro generates the actual <kbd>main</kbd> function and prints out the error if it occurs during the course of execution.</p>
<p>We return <kbd>Ok(())</kbd> to the <kbd>quick_run!</kbd> macro to ensure that the program is executed successfully without any errors.</p>


            </article>

            
        </section>
    </div>
</body>
</html>