- en: Rust Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust最佳实践
- en: Rust is a powerful language, but a few things easily avoidable with practice
    can make your life really hard when starting. This chapter aims to show you some
    good practices and tips.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种强大的语言，但通过实践可以轻松避免的一些事情，在开始时可能会让你的生活变得非常困难。本章旨在向你展示一些良好的实践和技巧。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Best practices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: API tips and improvements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API小贴士和改进
- en: Usage tips
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小贴士
- en: Code readability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可读性
- en: Now let's go!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始吧！
- en: Rust best practices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust最佳实践
- en: Let's start with some basics (and maybe obvious) things.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本（也许很明显）的事情开始。
- en: Slices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: First, a little recap; a slice is a constant view over an array, and `&[T]`
    is the constant view of a `Vec<T>`, whereas `&str` is the constant view of a `String`
    (just like `Path` is the constant view of a `PathBuf` and `OsStr` is the constant
    view of an `OsString`). Now that you have this in mind, let's continue!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下；切片是对数组的常量视图，`&[T]` 是 `Vec<T>` 的常量视图，而 `&str` 是 `String` 的常量视图（就像
    `Path` 是 `PathBuf` 的常量视图，`OsStr` 是 `OsString` 的常量视图）。现在你有了这个概念，让我们继续吧！
- en: 'When a function expects a constant argument of type `Vec` or `String`, then
    always write them as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数期望 `Vec` 或 `String` 类型的常量参数时，总是这样写：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead of:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead of:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You might be wondering why this is the case. So, let''s imagine your function
    displays your `Vec` as ASCII characters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么会这样。所以，让我们想象一下你的函数以ASCII字符显示你的 `Vec`：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now you just want to print a part of your `Vec`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只想打印出你的 `Vec` 的一部分：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if the `print_as_ascii` only accepted references on `Vec`, you''d have
    to make a (useless) allocation, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `print_as_ascii` 只接受 `Vec` 的引用，你就必须进行一个（无用的）分配，如下所示：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: API tips and improvements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API小贴士和改进
- en: 'When writing a public API (either for you or other users), a few tips can really
    make everyone''s life easier. This is where generics kick in. Let''s start with
    `Option` arguments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写公共API（无论是为你还是其他用户）时，一些小贴士真的可以让每个人的生活变得更轻松。这正是泛型发挥作用的地方。让我们从 `Option` 参数开始：
- en: Explaining the Some function
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 Some 函数
- en: 'Generally, when a function expects an `Option` argument, it looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个函数期望一个 `Option` 参数时，它看起来是这样的：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And you call it as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用它：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, what if I told you that you could get rid of the `Some`? Nice, right?
    Well, this is actually pretty easy:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我说你可以去掉 `Some`，怎么样？不错，对吧？实际上，这实际上非常简单：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And you can now call it as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以这样调用它：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Better! However, to make users'' lives easier, it''ll require a bit more code
    for whoever''s writing the function. You can''t use `arg` as it is; you need to
    add an extra step. Before, you''d just do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更好！然而，为了让用户的生活变得更轻松，编写函数的人需要写更多的代码。你不能直接使用 `arg`；你需要添加一个额外的步骤。以前，你只是这样做：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you''ll need to add an `.into` call before being able to use `arg`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在能够使用 `arg` 之前添加一个 `.into` 调用：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And that's it. As we said before, it doesn't require much and makes users' lives
    easier, so why not do it?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。正如我们之前所说的，这不需要太多，而且让用户的生活变得更轻松，所以为什么不这样做呢？
- en: Using the Path function
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Path 函数
- en: Just like the previous section, this will show you some tips to make your API
    more comfortable to use by *auto-converting* it into a `Path`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个部分一样，这将向你展示一些小贴士，使你的API通过 *自动转换* 为 `Path` 来使用起来更舒适。
- en: 'So, let''s take an example with a function receiving a `Path` as an argument:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们用一个接收 `Path` 作为参数的函数的例子来说明：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There''s nothing new in here. You can call this function just like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的。你可以像这样调用这个函数：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The annoying thing, here, is that you have to build the `Path` yourself before
    sending it to the function. This is way too annoying, but we can do better!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里令人烦恼的是，你必须自己构建 `Path` 然后才能将其发送到函数。这太烦人了，但我们能做得更好！
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And that''s it... You can now call the function as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样...你现在可以这样调用函数：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And just like for the `Into` trait, you need to add one line of code in order
    to make it work:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于 `Into` 特质一样，你需要添加一行代码才能使其工作：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And that''s it! Now, as long as the given type implements `AsRef<Path>`, you
    can just send it like that. For information, here''s a (non-exhaustive) list of
    types implementing this trait:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，只要给定的类型实现了 `AsRef<Path>`，你就可以这样发送。为了信息，这里是一个（非详尽的）实现了此特质的类型列表：
- en: '`OsStr` / `OsString`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OsStr` / `OsString`'
- en: '`&str` / `String`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&str` / `String`'
- en: '`Path` (yes, `Path` implements `AsRef<Path>` as well!) / `PathBuf`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path`（是的，`Path` 也实现了 `AsRef<Path>`！）/ `PathBuf`'
- en: '`Iter`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iter`'
- en: This is already quite a lot, so you should be able to do it pretty easily!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很多了，所以你应该能够很容易地做到这一点！
- en: Usage tips
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用技巧
- en: Now that you've seen few examples about how some small tips can make users'
    code more beautiful, how about we see some others things that might make *your*
    code better?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些关于如何通过一些小技巧使用户的代码更美观的例子，那么我们来看看可能使 *你的* 代码更好的其他一些事情。
- en: Builder pattern
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建者模式
- en: A builder pattern is meant to be able to *build* a final object through multiple
    calls that can be chained. An excellent example is the `OpenOptions` type in the
    Rust standard library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式旨在能够通过多个可以链式调用的调用来 *构建* 一个最终对象。Rust 标准库中的 `OpenOptions` 类型是一个很好的例子。
- en: It's strongly recommended you use `OpenOptions` when you need to play with `File`!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要玩转 `File` 时，强烈建议你使用 `OpenOptions`！
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To make such APIs, you have two ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这样的 API，你有两种方法：
- en: Playing with mutable borrows
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转可变借用
- en: Playing with moves
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转移动语义
- en: Let's start with the mutable borrows!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可变借用开始！
- en: Playing with mutable borrows
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转可变借用
- en: 'The first one works just like `OpenOptions`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子工作方式与 `OpenOptions` 相同：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you wonder about `self.0`, just remember that it's how you access a tuple
    field.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 `self.0`，只需记住这是你访问元组字段的方式。
- en: 'And then you can call it as follow:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按照以下方式调用它：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is the first way to do it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是做这件事的第一种方法。
- en: You'll note that you need to add an *ending* method so that you can transform
    your mutable borrow into an object (otherwise, you'll have a borrow issue).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你需要添加一个 *结束* 方法，这样你就可以将你的可变借用转换为对象（否则，你将有一个借用问题）。
- en: Let's now take a look at the second way to do it!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看做这件事的第二种方法！
- en: Playing with moves
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转移动语义
- en: 'Instead of taking `&mut` every time, we''ll directly take the object''s ownership
    every time:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再每次都取 `&mut`，而是每次直接获取对象的拥有权：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, there''s no more need for the *ending* method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就不再需要 *结束* 方法了：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I generally prefer this way of doing builder patterns but it's more of a personal
    opinion than a thoughtful decision. Pick whichever seems to fit the best in your
    situation!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常更喜欢这种方式来做构建者模式，但这更多的是个人意见，而不是经过深思熟虑的决定。选择在你所处的情境中看起来最合适的方式！
- en: Code readability
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码可读性
- en: We'll now talk about Rust's syntax itself. A few things can improve the code
    readability and are important to know. Let's start with big numbers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论 Rust 的语法本身。一些事情可以提高代码的可读性，并且很重要。让我们从大数字开始。
- en: Big number formatting
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大数字格式化
- en: 'It''s not uncommon to see huge constant numbers in code, such as this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中看到巨大的常量数字并不罕见，例如：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, this is quite difficult to read for us (human brains aren''t very
    efficient at parsing such numbers). In Rust, you can insert `_` characters into
    numbers without any problem:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对我们来说（人类大脑在解析这样的数字方面效率不高）相当难以阅读。在 Rust 中，你可以在数字中插入 `_` 字符而不会出现任何问题：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A lot better, right?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很好了，对吧？
- en: Specifying types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定类型
- en: The Rust compiler can automatically detect the type of a variable in most cases.
    However, for people reading the code, it's not always obvious what a code returns.
    An example? Sure!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器在大多数情况下可以自动检测变量的类型。然而，对于阅读代码的人来说，并不总是很明显代码返回了什么。举个例子？当然可以！
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After reading the code carefully, you'll guess that `x` is a `String`. However,
    you needed to read all those closures to get it and even then, are you really
    sure of the type?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读代码后，你会猜到 `x` 是一个 `String`。然而，你需要阅读所有那些闭包才能得到它，即使如此，你真的确定类型吗？
- en: 'In such cases, it''s strongly recommended to just add the type annotation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，强烈建议你只添加类型注解：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It doesn't cost much and allows readers (including you) to go through the code
    so much faster.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不花费太多，并且允许读者（包括你自己）更快地阅读代码。
- en: Matching
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配
- en: 'It''s common to use pattern matching through `match` blocks in Rust. However,
    it''s often a better solution to use `if let` conditions. Let''s take a simple
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，通常使用 `match` 块通过模式匹配。然而，使用 `if let` 条件通常是一个更好的解决方案。让我们用一个简单的例子来说明：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let''s say you want to perform an action only when you get `Ok`. With a
    `match`, you would do this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想在得到 `Ok` 时执行一个动作。使用 `match`，你会这样做：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Not really an issue, right? Now let''s see it with an `if let`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个问题，对吧？现在让我们用 `if let` 来看看：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that's it. It basically makes the code a little shorter, while improving
    readability a lot. Whenever you just need to get one value, it's often a better
    solution to use `if let` instead of `match`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。它基本上使代码变得更短，同时大大提高了可读性。当你只需要获取一个值时，通常使用 `if let` 而不是 `match` 是更好的解决方案。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this last chapter, you should have a good overview of good practices in Rust.
    Keep in mind that good code is easy to read and well commented. Even complex features
    can be a lot simpler to understand with well-made documentation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一章的最后部分，你应该对 Rust 中的良好实践有一个全面的了解。请记住，良好的代码易于阅读且注释详尽。即使复杂的特性，在制作良好的文档后也会变得容易理解得多。
