- en: Rust Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a powerful language, but a few things easily avoidable with practice
    can make your life really hard when starting. This chapter aims to show you some
    good practices and tips.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API tips and improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Rust best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with some basics (and maybe obvious) things.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, a little recap; a slice is a constant view over an array, and `&[T]`
    is the constant view of a `Vec<T>`, whereas `&str` is the constant view of a `String`
    (just like `Path` is the constant view of a `PathBuf` and `OsStr` is the constant
    view of an `OsString`). Now that you have this in mind, let's continue!
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function expects a constant argument of type `Vec` or `String`, then
    always write them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering why this is the case. So, let''s imagine your function
    displays your `Vec` as ASCII characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you just want to print a part of your `Vec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the `print_as_ascii` only accepted references on `Vec`, you''d have
    to make a (useless) allocation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: API tips and improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing a public API (either for you or other users), a few tips can really
    make everyone''s life easier. This is where generics kick in. Let''s start with
    `Option` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Some function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, when a function expects an `Option` argument, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And you call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what if I told you that you could get rid of the `Some`? Nice, right?
    Well, this is actually pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can now call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Better! However, to make users'' lives easier, it''ll require a bit more code
    for whoever''s writing the function. You can''t use `arg` as it is; you need to
    add an extra step. Before, you''d just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll need to add an `.into` call before being able to use `arg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. As we said before, it doesn't require much and makes users' lives
    easier, so why not do it?
  prefs: []
  type: TYPE_NORMAL
- en: Using the Path function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the previous section, this will show you some tips to make your API
    more comfortable to use by *auto-converting* it into a `Path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take an example with a function receiving a `Path` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing new in here. You can call this function just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The annoying thing, here, is that you have to build the `Path` yourself before
    sending it to the function. This is way too annoying, but we can do better!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it... You can now call the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like for the `Into` trait, you need to add one line of code in order
    to make it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it! Now, as long as the given type implements `AsRef<Path>`, you
    can just send it like that. For information, here''s a (non-exhaustive) list of
    types implementing this trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OsStr` / `OsString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&str` / `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path` (yes, `Path` implements `AsRef<Path>` as well!) / `PathBuf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is already quite a lot, so you should be able to do it pretty easily!
  prefs: []
  type: TYPE_NORMAL
- en: Usage tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've seen few examples about how some small tips can make users'
    code more beautiful, how about we see some others things that might make *your*
    code better?
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A builder pattern is meant to be able to *build* a final object through multiple
    calls that can be chained. An excellent example is the `OpenOptions` type in the
    Rust standard library.
  prefs: []
  type: TYPE_NORMAL
- en: It's strongly recommended you use `OpenOptions` when you need to play with `File`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To make such APIs, you have two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with mutable borrows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the mutable borrows!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with mutable borrows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first one works just like `OpenOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you wonder about `self.0`, just remember that it's how you access a tuple
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then you can call it as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the first way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that you need to add an *ending* method so that you can transform
    your mutable borrow into an object (otherwise, you'll have a borrow issue).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the second way to do it!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of taking `&mut` every time, we''ll directly take the object''s ownership
    every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there''s no more need for the *ending* method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I generally prefer this way of doing builder patterns but it's more of a personal
    opinion than a thoughtful decision. Pick whichever seems to fit the best in your
    situation!
  prefs: []
  type: TYPE_NORMAL
- en: Code readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now talk about Rust's syntax itself. A few things can improve the code
    readability and are important to know. Let's start with big numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Big number formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s not uncommon to see huge constant numbers in code, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is quite difficult to read for us (human brains aren''t very
    efficient at parsing such numbers). In Rust, you can insert `_` characters into
    numbers without any problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A lot better, right?
  prefs: []
  type: TYPE_NORMAL
- en: Specifying types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler can automatically detect the type of a variable in most cases.
    However, for people reading the code, it's not always obvious what a code returns.
    An example? Sure!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After reading the code carefully, you'll guess that `x` is a `String`. However,
    you needed to read all those closures to get it and even then, are you really
    sure of the type?
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, it''s strongly recommended to just add the type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't cost much and allows readers (including you) to go through the code
    so much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s common to use pattern matching through `match` blocks in Rust. However,
    it''s often a better solution to use `if let` conditions. Let''s take a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s say you want to perform an action only when you get `Ok`. With a
    `match`, you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Not really an issue, right? Now let''s see it with an `if let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. It basically makes the code a little shorter, while improving
    readability a lot. Whenever you just need to get one value, it's often a better
    solution to use `if let` instead of `match`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this last chapter, you should have a good overview of good practices in Rust.
    Keep in mind that good code is easy to read and well commented. Even complex features
    can be a lot simpler to understand with well-made documentation.
  prefs: []
  type: TYPE_NORMAL
