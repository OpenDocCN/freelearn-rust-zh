["```rs\nrustc --version \ncargo --version\n```", "```rs\n#![feature(try_trait)]\n```", "```rs\nrustup toolchain install nightly\n```", "```rs\nrustup default nightly\n```", "```rs\nrustup override set nightly\n```", "```rs\nrustup run nightly rustc –-version\n```", "```rs\nrustup default stable\n```", "```rs\nrustup show\n```", "```rs\nrustup update\n```", "```rs\n    --bin flag is to tell Cargo to generate a package that, when compiled, would produce a binary crate (executable).`first-program` is the name of the package given. You can specify a name of your choice.\n    ```", "```rs\n    [package]  \n    name = \"first-program\"  \n    version = \"0.1.0\"  \n    authors = [<your email>]  \n    edition = \"2018\"\n    ```", "```rs\n    fn main() {\n        println!(\"Hello, world!\");\n    }\n    ```", "```rs\n    target in the project root and creates a binary crate (executable) with the same name as the package name (first-program, in our case) in the location target/debug.\n    ```", "```rs\n    cargo run\n    ```", "```rs\n    Hello, world!  \n    [[bin]]\n    name = \"new-first-program\" \n    path = \"src/main.rs\"\n    ```", "```rs\n    new-first-program in the target/debug folder. You will see Hello, world! printed to your console.\n    ```", "```rs\n    [[bin]]  \n    name = \"new-first-program\"  \n    path = \"src/main.rs\"  \n    [[bin]]  \n    name = \"new-second-program\"  \n    path = \"src/second.rs\"\n    ```", "```rs\n    fn main() {\n        println!(\"Hello, for the second time!\");\n    }\n    ```", "```rs\n    cargo run --bin new-second-program\n    ```", "```rs\n cargo new --lib my-first-lib\n```", "```rs\n├── Cargo.toml\n├── src\n│   └── lib.rs\n```", "```rs\npub fn hello_from_lib(message: &str) {\n    println!(\"Printing Hello {} from library\",message);\n}\n```", "```rs\ncargo build \n```", "```rs\nuse my_first_lib::hello_from_lib;\nfn main() {\n    println!(\"Going to call library function\");\n    hello_from_lib(\"Rust system programmer\");\n}\n```", "```rs\ncargo run  --bin mymain \n```", "```rs\n[[bin]]  \nname = \"mymain\"  \npath = \"src/mymain.rs\"\n```", "```rs\ncargo new deps-example && cd deps-example\n```", "```rs\n[dependencies]  \nchrono = \"0.4.0\"\n```", "```rs\n    [dependencies]     \n     cratename = { version = \"2.1\", registry = \"alternate-\n         registry-name\" }\n    ```", "```rs\nuse chrono::Utc;\nfn main() {\n    println!(\"Hello, time now is {:?}\", Utc::now());\n}\n```", "```rs\nfn main() {\n    println!(\"Hello, time now is {:?}\", chrono::Utc::now());\n}\n```", "```rs\nuse chrono as time;\nfn main() {\n    println!(\"Hello, time now is {:?}\", time::Utc::now());\n}\n```", "```rs\ncargo new test-example && cd test-example\n```", "```rs\nuse std::process;\nfn main() {\n    println!(\"{}\", get_process_id());\n}\nfn get_process_id() -> u32 {\n    process::id()\n}\n```", "```rs\n#[test]\nfn test_if_process_id_is_returned() {\n    assert!(get_process_id() > 0);\n}\n```", "```rs\n#[test]\nfn test_if_process_id_is_returned() {\n    assert_ne!(get_process_id(), 0, \"There is error in code\");\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::get_process_id;\n    #[test]\n    fn test_if_process_id_is_returned() {\n        assert_ne!(get_process_id(), 0, \"There is \n            error in code\");\n    }\n}\n```", "```rs\ncargo new --lib integ-test-example && cd integ-test-example\n```", "```rs\nuse std::process;\npub fn get_process_id() -> u32 {\n    process::id()\n}\n```", "```rs\nuse integ_test_example;\n#[test]\nfn test1() {\n    assert_ne!(integ_test_example::get_process_id(), 0, \"Error \n        in code\");\n}\n```", "```rs\ncargo test —- testfunction1, testfunction2\n```", "```rs\nuse integ_test_example;\n#[test]\nfn files_test1() {\n    assert_ne!(integ_test_example::get_process_id(),0,\"Error \n        in code\");\n}\n#[test]\nfn files_test2() {\n    assert_eq!(1+1, 2);\n}\n#[test]\nfn process_test1() {\n    assert!(true);\n}\n```", "```rs\n#[test]\n#[ignore]\nfn process_test1() {\n    assert!(true);\n}\n```", "```rs\ncargo test —- --ignored\n```", "```rs\ncargo test -- --test-threads=1\n```", "```rs\n//! This is a library that contains functions related to \n//! dealing with processes,  \n//! and makes these tasks more convenient.  \nuse std::process;\n/// This function gets the process ID of the current \n/// executable. It returns a non-zero  number  \npub fn get_process_id() -> u32 {\n    process::id()\n}\n```", "```rs\n# Docs for integ-test-example crate\n\nThis is a project to test `rustdoc`.\n[Here is a link!](https://www.rust-lang.org)\n// Function signature\npub fn get_process_id() -> u32 {}\n```", "```rs\n// Example\n```", "```rs\n```", "```rs\nrustdoc doc/itest.md\n```", "```rs\n//! Integration-test-example crate\n//!\n//! This is a library that contains functions related to \n//! dealing with processes\n//! , and makes these tasks more convenient.\nuse std::process;\n/// This function gets the process id of the current \n/// executable. It returns a non-zero number\n/// ```", "```rs\npub fn get_process_id() -> u32 {\n    process::id()\n}\n```"]