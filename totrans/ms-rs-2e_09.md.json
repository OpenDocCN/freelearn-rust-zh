["```rs\n// c_macros.c\n\n#include <stdio.h> \n\n#define SWITCH(a, b) { temp = b; b = a; a = temp; } \n\nint main() { \n    int x=1; \n    int y=2; \n    int temp = 3; \n\n    SWITCH(x, y); \n    printf(\"x is now %d. y is now %d. temp is now %d\\n\", x, y, temp); \n}\n```", "```rs\nx is now 2\\. y is now 1\\. temp is now 2\n```", "```rs\n// c_macros_rust.rs\n\nmacro_rules! switch {\n    ($a:expr, $b:expr) => {\n        temp = $b; $b = $a; $a = temp;\n    };\n}\n\nfn main() { \n    let x = 1; \n    let y = 2; \n    let temp = 3;\n    switch!(x, y);\n}\n```", "```rs\nprintln(\"The result of 1 + 1 is {}\", 1 + 1); \nprintln!(\"The result of 1 + 1 is {}\"); \n```", "```rs\n// print_formatting.rs\n\nuse std::collections::HashMap;\n\nfn main() {\n    let a = 3669732608;\n    println!(\"{:p}\", &a);\n    println!(\"{:x}\", a);\n\n    // pretty printing\n    let mut map = HashMap::new();\n    map.insert(\"foo\", \"bar\");\n    println!(\"{:#?}\", map);\n}\n```", "```rs\nerror[E0277]: the trait bound `{integer}: std::fmt::Pointer` is not satisfied\n --> print_formatting.rs:7:22\n  |\n7 |     println!(\"{:p}\", a);\n  |                      ^ the trait `std::fmt::Pointer` is not implemented for `{integer}`\n```", "```rs\nlet mut input = String::new();\nio::stdin().read_line(&mut input).unwrap();\n```", "```rs\n// first_macro.rs\n\nfn main() {\n    let mut input = String::new();\n    scanline!(input);\n    println!(\"{:?}\", input);\n}\n```", "```rs\nerror: cannot find macro `scanline!` in this scope\n --> first_macro.rs:5:5\n  |\n5 |     scanline!(input);\n  |     ^^^^^^^^\n\nerror: aborting due to previous error\n```", "```rs\n// first_macro.rs\n\nuse std::io::stdin;\n\n// A convenient macro to read input as string into a buffer\nmacro_rules! scanline {\n    ($x:expr) => ({\n        stdin().read_line(&mut $x).unwrap();\n        $x.trim();\n    });\n}\n```", "```rs\nio::stdin().read_line(&mut $x).unwrap();\n```", "```rs\n// first_macro.rs\n\nuse std::io;\n\n// A convenient macro to read input as string into a buffer\nmacro_rules! scanline {\n    ($x:expr) => ({\n        io::stdin().read_line(&mut $x).unwrap();\n    });\n}\n\nfn main() {\n    let mut input = String::new();\n    scanline!(input);\n    println!(\"I read: {:?}\", input);\n}\n```", "```rs\nio::stdin().read_line(&mut input).unwrap();\n```", "```rs\n$ Alice\nI read: \"Alice\\n\"\n```", "```rs\n// first_macro.rs\n\nmacro_rules! scanline {\n    ($x:expr) => ({\n        io::stdin().read_line(&mut $x).unwrap();\n    });\n    () => ({\n        let mut s = String::new();\n        stdin().read_line(&mut s).unwrap();\n        s\n    });\n}\n```", "```rs\n// first_macro.rs\n\nfn main() {\n    let mut input = String::new();\n    scanline!(input);\n    println!(\"Hi {}\",input);\n    let a = scanline!();\n    println!(\"Hi {}\", a);\n}\n```", "```rs\n{ silly; things; } \n```", "```rs\nvec![1, 2, 3];\nvec![9, 8, 7, 6, 5, 4];\n```", "```rs\nmacro_rules! vec {\n    ($elem:expr; $n:expr) => (\n        $crate::vec::from_elem($elem, $n)\n    );\n    ($($x:expr),*) => (\n        <[_]>::into_vec(box [$($x),*])\n    );\n    ($($x:expr,)*) => (vec![$($x),*])\n}\n```", "```rs\n($($x:expr),*)\n($($x:expr,)*)\n```", "```rs\n($($x:expr),*) => (<[_]>::into_vec(box [$($x),*])); \n```", "```rs\nlet my_map = map! {\n    1 => 2,\n    2 => 3\n};\n```", "```rs\n// macro_map/lib.rs\n\n#[macro_export]\nmacro_rules! map {\n    // todo\n}\n```", "```rs\nmacro_rules! map {\n    ( $( $k:expr => $v:expr ),* ) => {\n        {\n            let mut map = ::std::collections::HashMap::new();\n            $(\n                map.insert($k, $v);\n            )*\n            map\n        }\n    };\n}\n```", "```rs\n// macro_map/lib.rs\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_map_macro() {\n        let a = map! {\n            \"1\" => 1,\n            \"2\" => 2\n        };\n\n        assert_eq!(a[\"1\"], 1);\n        assert_eq!(a[\"2\"], 2);\n    }\n}\n```", "```rs\nrunning 1 test\ntest tests::test_map_macro ... ok\n```", "```rs\nhttp://duckduckgo.com GET => 200\nhttp://httpbin.org/post POST => 200, \"key\" => \"value\"\n```", "```rs\n# http_tester/Cargo.toml\n\n[dependencies]\nreqwest = \"0.9.5\"\n```", "```rs\n// http_tester/src/lib.rs\n\n#[macro_export]\nmacro_rules! http_test { \n    ($url:tt GET => $code:expr) => { \n        let request = reqwest::get($url).unwrap(); \n        println!(\"Testing GET {} => {}\", $url, $code);\n        assert_eq!(request.status().as_u16(), $code); \n    }; \n    ($url:tt POST => $code:expr, $($k:expr => $v:expr),*) => {\n        let params = [$(($k, $v),)*];\n        let client = reqwest::Client::new();\n        let res = client.post($url)\n            .form(&params)\n            .send().unwrap();\n        println!(\"Testing POST {} => {}\", $url, $code); \n        assert_eq!(res.status().as_u16(), $code);\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_http_verbs() {\n        http_test!(\"http://duckduckgo.com\" GET => 200);\n        http_test!(\"http://httpbin.org/post\" POST => 200, \"hello\" => \"world\", \"foo\" => \"bar\");\n    }\n}\n```", "```rs\nrunning 1 test\ntest tests::test_http_verbs ... ok\n```", "```rs\nerror: no rules expected the token `DELETE`\n```", "```rs\n        language = HELLO recipient;\n        recipient = <String>;\n```", "```rs\n        HELLO world!\n        HELLO Rustaceans!\n```", "```rs\n# into_map_demo/Cargo.toml\n\n[dependencies]\ninto_map = { path = \"into_map\" }\ninto_map_derive = { path = \"into_map_derive\" }\n```", "```rs\n// into_map_demo/src/main.rs\n\nuse into_map_derive::IntoMap;\n\n#[derive(IntoMap)]\nstruct User {\n    name: String,\n    id: usize,\n    active: bool\n}\n\nfn main() {\n    let my_bar = User { name: \"Alice\".to_string(), id: 35, active: false };\n    let map = my_bar.into_map();\n    println!(\"{:?}\", map);\n}\n```", "```rs\n// into_map_demo/into_map/src/lib.rs\n\nuse std::collections::BTreeMap;\n\npub trait IntoMap {\n    fn into_map(&self) -> BTreeMap<String, String>;\n}\n```", "```rs\n# into_map_demo/into_map_derive/src/Cargo.toml\n\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = { version = \"0.15.22\", features = [\"extra-traits\"] }\nquote = \"0.6.10\"\ninto_map = { path=\"../into_map\" }\n```", "```rs\nimpl IntoMap for User {\n    fn into_map(&self) -> BTreeMap<String, String> {\n        let mut map = BTreeMap::new();\n        map.insert(\"name\".to_string(), self.name.to_string());\n        map.insert(\"id\".to_string(), self.id.to_string());\n        map.insert(\"active\".to_string(), self.active.to_string());\n        map\n    }\n}\n```", "```rs\nmap.insert(field_name, field_value);\n```", "```rs\n// into_map_demo/into_map_derive/src/lib.rs\n\nextern crate proc_macro;\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, Fields};\n\n#[proc_macro_derive(IntoMap)]\npub fn into_map_derive(input: TokenStream) -> TokenStream {\n    let mut insert_tokens = vec![];\n    let parsed_input: DeriveInput = parse_macro_input!(input);\n    let struct_name = parsed_input.ident;\n    match parsed_input.data {\n        Data::Struct(s) => {\n            if let Fields::Named(named_fields) = s.fields {\n                let a = named_fields.named;\n                for i in a {\n                    let field = i.ident.unwrap();\n                    let insert_token = quote! {\n                        map.insert(\n                            stringify!(#field).to_string(),\n                            self.#field.to_string()\n                        );\n                    };\n                    insert_tokens.push(insert_token);\n                }\n            }\n        }\n        other => panic!(\"IntoMap is not yet implemented for: {:?}\", other),\n    }\n```", "```rs\nmap.insert(\n    stringify!(#field).to_string(),\n    self.#field.to_string()\n);\ninsert_tokens.push(insert_token);\n```", "```rs\n    let tokens = quote! {\n        use std::collections::BTreeMap;\n        use into_map::IntoMap;\n\n        impl IntoMap for #struct_name {\n            /// Converts the given struct into a dynamic map\n            fn into_map(&self) -> BTreeMap<String, String> {\n                let mut map = BTreeMap::new();\n                #(#insert_tokens)*\n                map\n            }\n        }\n    };\n\n    proc_macro::TokenStream::from(tokens)\n}\n```", "```rs\n// into_map_demo/src/main.rs\n\nuse into_map_derive::IntoMap;\n\n#[derive(IntoMap)]\nstruct User {\n    name: String,\n    id: usize,\n    active: bool\n}\n\nfn main() {\n    let my_bar = User { name: \"Alice\".to_string(), id: 35, active: false };\n    let map = my_bar.into_map();\n    println!(\"{:?}\", map);\n}\n```", "```rs\n{\"active\": \"false\", \"id\": \"35\", \"name\": \"Alice\"}\n```"]