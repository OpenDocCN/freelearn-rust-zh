["```rs\n        //-- #########################\n        //-- Task: Implementing panic \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        // function which checks if the strings are same or not\n        fn compare_stmt(stmt: &str) {\n          // Check if the statements are same or not \n          if stmt == \"Another book\" { \n            panic!(\"Rust Cookbook is not selected!!!!\"); \n          }\n\n          println!(\"Statements is {}!!!!!\", stmt);\n        }\n\n```", "```rs\n        // Execution starts here\n        fn main() {\n         compare_stmt(\"Rust Cookbook\");\n         compare_stmt(\"Another book\");\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing Option\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        // All arguments are handled explicitly using `match`.\n        fn compare_stmt_match(input: Option<&str>) {\n          // Specify a course of action for each case.\n          match input {\n            Some(\"Rust CookBook\") => println!(\"Rust CookBook \n            was selected\"),\n            Some(inner) => println!(\"Rust CookBook not\n            selected\"),\n            None => println!(\"No input provided\"),\n          }\n        }\n\n```", "```rs\n        // All arguments are handled implicitly using `unwrap`.\n        fn compare_stmt_unwrap(input: Option<&str>) {\n          // `unwrap` returns a `panic` when it receives a\n          `None`     value\n          let inside_val = input.unwrap();\n          if inside_val == \"Another Book\" { panic!(\"Rust\n          CookBook is not selected\"); }\n\n          println!(\"I love {}s!!!!!\", inside_val);\n        }\n\n```", "```rs\n        // main execution starts here\n        fn main() {\n          let Desired_Book = Some(\"Rust CookBook\");\n          let Another_Book = Some(\"Another Book\");\n          let Empty_value = None;\n\n          compare_stmt_match(Desired_Book);\n          compare_stmt_match(Another_Book);\n          compare_stmt_match(Empty_value);\n\n          println!(\"*********************\");\n\n          let Rand_Book = Some(\"Random Book\");\n          let No_val = None;\n\n          compare_stmt_unwrap(Rand_Book);\n          compare_stmt_unwrap(No_val);\n        }\n\n```", "```rs\n        enum Option<T> {\n          None,\n          Some(T),\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing map \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        #![allow(dead_code)]\n\n        #[derive(Debug)] enum Food { Apple, Carrot, Potato }\n\n        #[derive(Debug)] struct Peeled(Food);\n        #[derive(Debug)] struct Chopped(Food);\n        #[derive(Debug)] struct Cooked(Food);\n\n```", "```rs\n        fn peel(food: Option<Food>) -> Option<Peeled> {\n          match food {\n            Some(food) => Some(Peeled(food)),\n            None => None,\n          }\n        }\n\n```", "```rs\n        fn chop(peeled: Option<Peeled>) -> Option<Chopped> {\n          match peeled {\n            Some(Peeled(food)) => Some(Chopped(food)),\n            None => None,\n          }\n        }\n\n```", "```rs\n        fn cook(chopped: Option<Chopped>) -> Option<Cooked> {\n          chopped.map(|Chopped(food)| Cooked(food))\n        }\n\n```", "```rs\n        fn process(food: Option<Food>) -> Option<Cooked> {\n          food.map(|f| Peeled(f))\n          .map(|Peeled(f)| Chopped(f))\n          .map(|Chopped(f)| Cooked(f))\n        }\n\n```", "```rs\n        fn eat(food: Option<Cooked>) {\n          match food {\n            Some(food) => println!(\"Mmm. I love {:?}\", food),\n            None => println!(\"Oh no! It wasn't edible.\"),\n          }\n        }\n\n```", "```rs\n        fn main() {\n          let apple = Some(Food::Apple);\n          let carrot = Some(Food::Carrot);\n          let potato = None;\n\n          let cooked_apple = cook(chop(peel(apple)));\n          let cooked_carrot = cook(chop(peel(carrot)));\n          let cooked_potato = process(potato);\n\n          eat(cooked_apple);\n          eat(cooked_carrot);\n          eat(cooked_potato);\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing and_then \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        #![allow(dead_code)]\n\n        #[derive(Debug)] enum Food { CordonBleu, Steak, Sushi}\n        #[derive(Debug)] enum Day { Monday, Tuesday, Wednesday}\n\n```", "```rs\n        fn have_ingredients(food: Food) -> Option<Food> {\n          match food {\n            Food::Sushi => None,\n            _ => Some(food),\n          }\n        }\n\n```", "```rs\n        fn have_recipe(food: Food) -> Option<Food> {\n          match food {\n            Food::CordonBleu => None,\n            _ => Some(food),\n          }\n        }\n\n```", "```rs\n        fn cookable(food: Food) -> Option<Food> {\n          have_ingredients(food).and_then(have_recipe)\n        }\n\n```", "```rs\n        fn eat(food: Food, day: Day) {\n          match cookable(food) {\n            Some(food) => println!(\"Yay! On {:?} we get to eat\n            {:?}.\", day, food),\n            None => println!(\"Oh no. We don't get to eat on \n            {:?}?\", day),\n          }\n        }\n\n```", "```rs\n        fn main() {\n          let (cordon_bleu, steak, sushi) = (Food::CordonBleu,\n          Food::Steak, Food::Sushi);\n\n          eat(cordon_bleu, Day::Monday);\n          eat(steak, Day::Tuesday);\n          eat(sushi, Day::Wednesday);\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing map for Result \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n use std::num::ParseIntError;\n\n```", "```rs\n        fn double_number(number_str: &str) -> Result<i32,\n        ParseIntError> {\n          match number_str.parse::<i32>() {\n            Ok(n) => Ok(2 * n),\n            Err(e) => Err(e),\n          }\n        }\n\n```", "```rs\n        fn double_number_map(number_str: &str) -> Result<i32,\n        ParseIntError> {\n          number_str.parse::<i32>().map(|n| 2 * n)\n        }\n\n```", "```rs\n        fn print(result: Result<i32, ParseIntError>) {\n          match result {\n          Ok(n) => println!(\"n is {}\", n),\n          Err(e) => println!(\"Error: {}\", e),\n          }\n        }\n\n```", "```rs\n        fn main() {\n          // This still presents a reasonable answer.\n          let twenty = double_number(\"10\");\n          print(twenty);\n\n          // The following now provides a much more helpful\n          error message.\n          let tt = double_number_map(\"t\");\n          print(tt);\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing aliases \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n use std::num::ParseIntError;\n\n```", "```rs\n        type AliasedResult<T> = Result<T, ParseIntError>;\n\n```", "```rs\n        fn double_number(number_str: &str) -> AliasedResult<i32> {\n         number_str.parse::<i32>().map(|n| 2 * n)\n        }\n\n```", "```rs\n        fn print(result: AliasedResult<i32>) {\n         match result {\n         Ok(n) => println!(\"n is {}\", n),\n         Err(e) => println!(\"Error: {}\", e),\n         }\n        }\n\n```", "```rs\n        fn main() {\n         print(double_number(\"10\"));\n         print(double_number(\"t\"));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Handling multiple errors\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        type Result<T> = std::result::Result<T, String>;\n\n```", "```rs\n        fn double_first(vec: Vec<&str>) -> Result<i32> {\n          vec.first()\n          .ok_or(\"Please use a vector with at least one\n          element.\".to_owned())\n          .and_then(|s| s.parse::<i32>()\n          .map_err(|e| e.to_string())\n          .map(|i| 2 * i))\n        }\n\n```", "```rs\n        fn print(result: Result<i32>) {\n          match result {\n            Ok(n) => println!(\"The first doubled is {}\", n),\n            Err(e) => println!(\"Error: {}\", e),\n          }\n        }\n\n```", "```rs\n        fn main() {\n          let empty = vec![];\n          let strings = vec![\"tofu\", \"93\", \"18\"];\n\n          print(double_first(empty));\n          print(double_first(strings));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing early returns\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        type Result<T> = std::result::Result<T, String>;\n\n```", "```rs\n        fn double_first(vec: Vec<&str>) -> Result<i32> {\n          let first = match vec.first() {\n            Some(first) => first,\n            None => return Err(\"Please use a vector with at\n            least\n            one element.\".to_owned())\n          };\n\n          match first.parse::<i32>() {\n            Ok(i) => Ok(2 * i),\n            Err(e) => Err(e.to_string()),\n          }\n        }\n\n```", "```rs\n        fn print(result: Result<i32>) {\n          match result {\n            Ok(n) => println!(\"The first doubled is {}\", n),\n            Err(e) => println!(\"Error: {}\", e),\n          }\n        }\n\n```", "```rs\n        fn main() {\n          let empty = vec![];\n          let strings = vec![\"tofu\", \"93\", \"18\"];\n\n          print(double_first(empty));\n          print(double_first(strings));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing try!\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        type Result<T> = std::result::Result<T, String>;\n\n```", "```rs\n        fn double_first(vec: Vec<&str>) -> Result<i32> {\n          let first = try!(vec.first()\n          .ok_or(\"Please use a vector with at least one               \n          element.\".to_owned()));\n\n          let value = try!(first.parse::<i32>()\n          .map_err(|e| e.to_string()));\n\n          Ok(2 * value)\n        }\n\n```", "```rs\n        fn print(result: Result<i32>) {\n         match result {\n         Ok(n) => println!(\"The first doubled is {}\", n),\n         Err(e) => println!(\"Error: {}\", e),\n         }\n        }\n\n```", "```rs\n        fn main() {\n         let empty = vec![];\n         let strings = vec![\"tofu\", \"93\", \"18\"];\n\n         print(double_first(empty));\n         print(double_first(strings));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Defining your own error type\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        use std::num::ParseIntError;\n        use std::fmt;\n\n        type Result<T> = std::result::Result<T, CustomError>;\n\n```", "```rs\n        #[derive(Debug)]\n        enum CustomError {\n         EmptyVec,\n         Parse(ParseIntError),\n        }\n\n```", "```rs\n        impl fmt::Display for CustomError {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n         CustomError::EmptyVec =>\n         write!(f, \"please use a vector with at least one\n         element\"),\n         // This is a wrapper, so defer to the underlying\n         types' implementation of `fmt`.\n         CustomError::Parse(ref e) => e.fmt(f),\n         }\n         }\n        }\n\n```", "```rs\n        fn double_val(vec: Vec<&str>) -> Result<i32> {\n          vec.first()\n          // Change the error to our new type.\n         .ok_or(CustomError::EmptyVec)\n         .and_then(|s| s.parse::<i32>()\n         // Update to the new error type here also.\n         .map_err(CustomError::Parse)\n         .map(|i| 2 * i))\n       }\n\n```", "```rs\n        fn print(result: Result<i32>) {\n         match result {\n         Ok(n) => println!(\"The first doubled is {}\", n),\n         Err(e) => println!(\"Error: {}\", e),\n         }\n        }\n\n```", "```rs\n        fn main() {\n         let numbers = vec![\"93\", \"18\"];\n         let empty = vec![];\n         let strings = vec![\"tofu\", \"93\", \"18\"];\n\n         print(double_val(numbers));\n         print(double_val(empty));\n         print(double_val(strings));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing Boxing\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        use std::error;\n        use std::fmt;\n        use std::num::ParseIntError;\n\n        type Result<T> = std::result::Result<T,         Box<error::Error>>;\n\n```", "```rs\n        #[derive(Debug)]\n        enum CustomError {\n         EmptyVec,\n         Parse(ParseIntError),\n        }\n\n```", "```rs\n        impl From<ParseIntError> for CustomError {\n         fn from(err: ParseIntError) -> CustomError {\n         CustomError::Parse(err)\n         }\n        }\n\n```", "```rs\n        impl fmt::Display for CustomError {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n         CustomError::EmptyVec =>\n         write!(f, \"please use a vector with at least one element\"),\n         CustomError::Parse(ref e) => e.fmt(f),\n         }\n         }\n        }\n\n```", "```rs\n        impl error::Error for CustomError {\n         fn description(&self) -> &str {\n         match *self {\n         CustomError::EmptyVec => \"empty vectors not allowed\",\n         CustomError::Parse(ref e) => e.description(),\n         }\n         }\n\n         fn cause(&self) -> Option<&error::Error> {\n         match *self {\n         CustomError::EmptyVec => None,\n         CustomError::Parse(ref e) => Some(e),\n         }\n         }\n        }\n\n```", "```rs\n        fn double_val(vec: Vec<&str>) -> Result<i32> {\n          let first = try!(vec.first().ok_or(CustomError::EmptyVec));\n          let parsed = try!(first.parse::<i32>());\n\n          Ok(2 * parsed)\n        }\n\n```", "```rs\n        fn print(result: Result<i32>) {\n         match result {\n         Ok(n) => println!(\"The first doubled is {}\", n),\n         Err(e) => println!(\"Error: {}\", e),\n         }\n        }\n\n```", "```rs\n        fn main() {\n         let numbers = vec![\"93\", \"18\"];\n         let empty = vec![];\n         let strings = vec![\"tofu\", \"93\", \"18\"];\n\n         print(double_val(numbers));\n         print(double_val(empty));\n         print(double_val(strings));\n        }\n\n```"]