- en: Building Web Applications with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 构建 Web 应用程序
- en: In this chapter, we'll explore building web applications with Rust. We'll get
    to know the benefits of a static type system and the speed of a compiled language
    when building web applications with it. We'll also explore Rust's strongly typed
    HTTP libraries and build a URL shortener as an exercise. Following that, we'll
    look at a very popular framework called Actix-web and build a bookmark API server
    with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用 Rust 构建网络应用。我们将了解使用静态类型系统构建网络应用时的好处，以及编译语言的速度。我们还将探索 Rust 的强类型
    HTTP 库，并通过练习构建一个 URL 缩短器。在此之后，我们将研究一个非常流行的框架 Actix-web，并使用它构建一个书签 API 服务器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Web applications in Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 中的网络应用
- en: Building a URL shortener with Hyper Crate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hyper Crate 构建 URL 缩短器
- en: The need for web frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络框架的需求
- en: Understanding the Actix-web framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Actix-web 框架
- en: Building an HTTP Rest API using Actix-web
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Actix-web 构建 HTTP Rest API
- en: Web applications in Rust
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 中的网络应用
- en: '*"The most important property of a program is whether it accomplishes the intention
    of its user." *'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*"程序最重要的属性是它是否实现了用户的意图。"*'
- en: – *C. A. R. Hoare*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: – *C. A. R. 霍尔*
- en: It's rare for a low-level language to enable developers to write web applications
    with it while providing thekind of high-level ergonomics that dynamic languages
    do. With Rust, it's quite the opposite. Developing web applications with Rust
    is a similar experience one might expect from dynamic languages such as Ruby or
    Python, due to its high-level abstractions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 低级语言通常难以同时让开发者使用它编写网络应用并提供动态语言那样的高级人机工程学。然而，使用 Rust 则恰恰相反。用 Rust 开发网络应用与动态语言如
    Ruby 或 Python 的体验相似，这得益于其高级抽象。
- en: Web applications developed in dynamic languages can only get you so far though.
    A lot of developers find to what, as their code base reaches about a 100,000 lines
    of code, they start seeing the brittle nature of dynamic languages. With every
    small change you make, you need to have tests in place to let you know what parts
    of the application are affected. As the application grows, it becomes a whack-a-mole
    situation in terms of testing and updating.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在动态语言中开发的网络应用可以走得很远，但许多开发者发现，当他们的代码库达到大约 10 万行代码时，他们开始看到动态语言的脆弱本质。随着你做的每一个小改动，你都需要有测试来告诉你应用程序的哪些部分受到影响。随着应用程序的增长，在测试和更新方面，它变成了一个打地鼠的情况。
- en: Building web applications in a statically typed language such as Rust is another
    level of experience. Here, you get compile-time checks on your code, thus reducing
    the amount of unit tests you have to write by a large amount. You don't have the
    overhead of a language runtime such as an interpreter either, as is the case with
    dynamic languages that run a GC along with your application. Web applications
    written in a statically typed language can be compiled as a single static binary
    that can be deployed with minimal setup needed. Besides, you get speed and accuracy
    guarantees from the type system and there is a lot of help from the compiler during
    code refactoring. Rust gives you all of these guarantees, along with the same
    high-level feel of dynamic languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Rust 这样的静态类型语言中构建网络应用是另一种层次的经验。在这里，你可以在代码编译时进行检查，从而大大减少你需要编写的单元测试数量。你也不需要像动态语言那样运行时（如运行
    GC 的解释器）的开销。使用静态类型语言编写的网络应用可以编译为一个单一的静态二进制文件，只需最少的设置即可部署。此外，你从类型系统中获得速度和准确性的保证，并且在代码重构期间，编译器提供了大量帮助。Rust
    给你所有这些保证，同时保持了动态语言的高层感觉。
- en: Web applications primarily sit on the application layer protocol and speak the
    HTTP protocol. HTTP is a stateless protocol where each message is either a request
    or a response from the client or the server. A message in the HTTP protocol consists
    of a header and a payload. The header provides context for the kind of HTTP message,
    such as its origin or the length of the payload, while the payload contains the
    actual data. HTTP is a text-based protocol, and we generally use libraries to
    do the hard work of parsing strings as proper HTTP messages. These libraries are
    further used to build high-level abstractions on top of them, such as a web framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用主要位于应用层协议之上，并使用HTTP协议进行通信。HTTP是一种无状态协议，其中每个消息要么是客户端或服务器发送的请求，要么是响应。HTTP协议中的消息由头部和有效负载组成。头部提供了HTTP消息的上下文信息，例如其来源或有效负载的长度，而有效负载包含实际数据。HTTP是一种基于文本的协议，我们通常使用库来执行将字符串解析为适当的HTTP消息的繁重工作。这些库进一步用于在其之上构建高级抽象，例如Web框架。
- en: To speak HTTP in Rust, we have the `hyper` crate, which we'll explore next.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们使用`hyper`crate来使用HTTP，我们将在下一节中对其进行探讨。
- en: Typed HTTP with Hyper
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyper的强类型HTTP
- en: 'The **hyper** crate can parse HTTP messages, and has an elegant design with
    focus on strongly typed APIs. It is designed as a type-safe abstraction for raw
    HTTP requests, as opposed to a common theme in HTTP libraries: describing everything
    as strings. For example, HTTP status codes in Hyper are defined as enums, for
    example, the type `StatusCode`. The same goes for pretty much everything that
    can be strongly typed, such as HTTP methods, MIME types, HTTP headers, and so
    on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`hyper`crate可以解析HTTP消息，并具有优雅的设计，专注于强类型API。它被设计为原始HTTP请求的类型安全抽象，与HTTP库中的常见主题相反：将一切描述为字符串。例如，Hyper中的HTTP状态码被定义为枚举，例如，类型`StatusCode`。对于几乎所有可以强类型化的内容，例如HTTP方法、MIME类型、HTTP头部等，都是如此。'
- en: Hyper has both client and server functionality split into separate modules.
    The client side allows you to build and make HTTP requests with a configurable
    request body, headers, and other low-level configurations. The server side allows
    you to open a listening socket and attach request handlers to it. However, it
    does not include any request route handler implementation – that is left to web
    frameworks. It is designed to be used as a foundational crate to build higher-level
    web frameworks. It uses the same `tokio` and `futures` async abstractions under
    the hood and thus is very performant.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper将客户端和服务器功能分别拆分为独立的模块。客户端允许你使用可配置的请求体、头部和其他低级配置来构建和发送HTTP请求。服务器端允许你打开监听套接字并将其请求处理器附加到它。然而，它不包括任何请求路由处理器实现——这留给了Web框架。它被设计成作为构建更高层次Web框架的基础crate。它底层使用相同的`tokio`和`futures`异步抽象，因此性能非常出色。
- en: 'At its core, Hyper has the concept  `Service` trait concept:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Hyper具有`Service`特质概念：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Service` trait represents a type that handles HTTP requests that are sent
    from any client and returns a `Response`, which is a future. The core API of this
    trait that types need to implement is the `call` method, which takes in a `Request` that's
    parameterized over a generic type `Body` and returns a `Future` that resolves
    to a `Response`, which is parameterized over the associated type `ResBody`. We
    don't need to manually implement this trait, as hyper includes a bunch of factory
    methods that can implement the `Service` trait for you. You simply need to provide
    a function that takes HTTP requests and returns responses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service`特质代表一种处理来自任何客户端发送的HTTP请求并返回`Response`（一个future）的类型。该特质的核心API，类型需要实现的是`call`方法，它接受一个参数化泛型类型`Body`的`Request`，并返回一个解析为参数化关联类型`ResBody`的`Response`的`Future`。我们不需要手动实现这个特质，因为Hyper包含一系列可以为你实现`Service`特质的工厂方法。你只需要提供一个函数，该函数接受HTTP请求并返回响应。'
- en: In the following section, we'll explore both the client and server APIs of hyper.
    Let's start by exploring the server APIs by building a URL shortener from scratch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨hyper的客户端和服务器API。让我们从从头开始构建URL缩短器来探索服务器API。
- en: Hyper server APIs – building a URL shortener
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyper服务器API——构建URL缩短器
- en: 'In this section, we''ll build a URL shortener server that exposes a `/shorten`
    endpoint. This endpoint accepts a `POST` request, with the body containing the
    URL to be shortened. Let''s fire up a new project by running `cargo new hyperurl`
    with the following dependencies in `Cargo.toml`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个URL缩短服务器，该服务器公开一个`/shorten`端点。此端点接受一个包含要缩短的URL的`POST`请求。让我们通过运行`cargo
    new hyperurl`并使用以下依赖项在`Cargo.toml`中启动一个新的项目：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll name our URL shortening server, **hyperurl**. A URL shortener service
    is a service that provides the functionality to create a shorter URL for any given
    URL. When you have a really long URL, it becomes tedious to share it with someone.
    A lot of URL shortening services exist today, such as *bit.ly*. If you have used
    Twitter, users use short URL in tweets quite often, to save space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的URL缩短服务器为**hyperurl**。URL缩短服务是一种提供为任何给定URL创建更短URL的功能的服务。当你有一个非常长的URL时，与某人分享它变得很麻烦。今天存在许多URL缩短服务，例如*bit.ly*。如果你使用过Twitter，用户在推文中经常使用短URL，以节省空间。
- en: 'Here''s our initial implementation in `main.rs`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`main.rs`中的初始实现：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `main`, we create a `Server` instance and bind it to our loopback address
    and port string `"127.0.0.1:3002"`. This returns a builder instance on which we
    call `serve` before passing in the function `url_service` which implements the
    `Service` trait. The function `url_service` maps a `Request` to a future of `Response`. `service_fn`
    is a factory function that has the following signature:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，我们创建了一个`Server`实例，并将其绑定到我们的回环地址和端口号字符串`"127.0.0.1:3002"`。这返回了一个builder实例，我们在其中调用`serve`，然后传递实现`Service`特质的函数`url_service`。函数`url_service`将`Request`映射到`Response`的future。`service_fn`是一个具有以下签名的工厂函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, F needs to be a Fn closure that
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，F需要是一个Fn闭包，
- en: 'Our function `url_service` implements the `Service` trait. Next, let''s see
    the code in `service.rs`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`url_service`函数实现了`Service`特质。接下来，让我们看看`service.rs`中的代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This module exposes a single function `url_service`, which implements the `Service`
    trait. Our `url_service` method implements the method `call` by taking in a req
    of the `Request<Body>` type and returns a future that is behind a `Box`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块公开一个名为`url_service`的单个函数，它实现了`Service`特质。我们的`url_service`方法通过接受一个`Request<Body>`类型的req并返回一个位于`Box`之后的future来实现`call`方法。
- en: 'Next, is our `shortener` module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的`shortener`模块：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `shorten_url` function takes in a URL to shorten as a `&str`. It then computes
    the SHA-256 hash of the URL and truncates it to a string of length five. This
    is obviously not how a real URL shortener works and is not a scalable solution
    either. However, it's fine for our demonstration purposes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`shorten_url`函数接受一个要缩短的URL作为`&str`。然后它计算URL的SHA-256哈希值并将其截断为长度为五的字符串。这显然不是真正的URL缩短器的工作方式，也不是一个可扩展的解决方案。然而，对于我们的演示目的来说，这已经足够了。
- en: 'Let''s take this for a spin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '![](img/f550a241-244e-4c30-ac50-b0d294eddb26.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f550a241-244e-4c30-ac50-b0d294eddb26.png)'
- en: Our server is running. At this point we can either send requests POST through
    curl. We'll do this the other way by building a command-line client for sending
    URLs to shorten this server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器正在运行。在这个时候，我们可以通过curl发送POST请求。我们将通过构建一个用于向此服务器发送URL以缩短的命令行客户端来实现这一点。
- en: While Hyper is recommended for complex HTTP applications, it's quite cumbersome
    every time to create a handler service, register it, and run it in a runtime.
    Often, for to build smaller tools such as a CLI application that needs to make
    a couple of `GET` requests, this becomes overkill. Fortunately, we have another
    opinionated wrapper over hyper called the `reqwest` crate. As the name suggests,
    it is inspired by Python's Requests library. We'll use this to build our hyperurl
    client that sends URL shorten requests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Hyper 推荐用于复杂的HTTP应用程序，但每次创建处理程序服务、注册它并在运行时中运行它都相当繁琐。通常，为了构建需要执行几个`GET`请求的小型工具，如CLI应用程序，这会显得有些过度。幸运的是，我们有一个名为`reqwest`的hyper的包装器，它具有自己的观点。正如其名所示，它受到了Python的Requests库的启发。我们将使用它来构建我们的hyperurl客户端，该客户端发送URL缩短请求。
- en: hyper as a client – building a URL shortener client
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hyper作为客户端 – 构建URL缩短客户端
- en: Now that we have our URL shortener service ready, let's explore the client side
    of hyper. Although we can build a web UI that we can use for shortening URLs,
    we'll keep it simple and build a **Command-Line Interface (CLI)** tool. The CLI
    can be used to pass any URL that needs to be shortened. In response, we'll get
    back the shortened URL from our hyperurl server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 URL 缩短服务，让我们探索 hyper 的客户端。尽管我们可以构建一个用于缩短 URL 的 Web UI，但我们将保持简单，并构建一个
    **命令行界面 (CLI)** 工具。CLI 可以用来传递任何需要缩短的 URL。作为回应，我们将从我们的 hyperurl 服务器获得缩短后的 URL。
- en: While hyper is recommended for building complex web applications, a lot of setup
    is involved every time you need to create a handler service, register it, and
    run it in a runtime instance. When building smaller tools, such as a CLI application
    that needs to make a few GET requests, all of these steps become overkill. Fortunately,
    we have a convenient wrapper crate over hyper called **reqwest** that abstracts
    hyper's client APIs. As the name suggests, it is inspired by Python's Requests
    library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 hyper 推荐用于构建复杂网络应用程序，但每次需要创建处理程序服务、注册它并在运行时实例中运行它时，都需要进行大量设置。当构建较小的工具，如需要执行几个
    GET 请求的 CLI 应用程序时，所有这些步骤都显得过于繁琐。幸运的是，我们有一个方便的 hyper 包装 crate，名为 **reqwest**，它抽象了
    hyper 的客户端 API。正如其名所示，它受到了 Python 的 Requests 库的启发。
- en: 'Let''s create a new project by running `cargo new shorten` with the following
    dependencies in our `Cargo.toml` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 `Cargo.toml` 文件中添加以下依赖项来运行 `cargo new shorten` 创建一个新的项目：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To build the CLI tool, we'll use the `quicli` framework, which is a collection
    of high- quality crates that help build CLI tools. The `structopt` crate is used
    along with `quicli`, while the `serde` crate is used by the `structopt` crate
    for the derive macro. To make `POST` requests to our hyperurl server, we'll use
    the `reqwest` crate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 CLI 工具，我们将使用 `quicli` 框架，这是一个高质量crate的集合，有助于构建 CLI 工具。`structopt` crate
    与 `quicli` 一起使用，而 `serde` crate 则用于 `structopt` crate 的 derive 宏。为了向我们的 hyperurl
    服务器发送 `POST` 请求，我们将使用 `reqwest` crate。
- en: 'Our `main.rs` has the following code inside it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main.rs` 文件内部有以下代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With our hyperurl server still running, we''ll open a new terminal window and
    invoke shorten with `cargo run -- --url https://rust-lang.org`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 hyperurl 服务器仍然运行的情况下，我们将打开一个新的终端窗口，并使用 `cargo run -- --url https://rust-lang.org`
    调用 shorten：
- en: '![](img/93a8e603-0cea-4082-81a8-be8d91fec8bc.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93a8e603-0cea-4082-81a8-be8d91fec8bc.png)'
- en: 'Let''s head over to a browser with the shortened URL, that is, `http://127.0.0.1:3002/abf27`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到浏览器，使用缩短后的 URL，即 `http://127.0.0.1:3002/abf27`：
- en: '![](img/548e4c05-76d0-4567-9af3-1952a6c01582.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/548e4c05-76d0-4567-9af3-1952a6c01582.png)'
- en: Having explored hyper, let's get a bit more high level. In the next section,
    we'll explore Actix-web, a fast web application framework based on the actor model
    implementation in the `actix` crate. But, first let's talk about why we need web
    frameworks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 hyper 之后，让我们提高一点层次。在下一节中，我们将探索基于 `actix` 包中actor模型实现的快速网络应用程序框架 Actix-web。但是，首先让我们谈谈为什么我们需要网络框架。
- en: Web frameworks
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络框架
- en: Before we begin exploring `actix-web`, we need to get some motivation as to
    why we need web frameworks in the first place. The web, as many of us know, is
    a complex, evolving space. There are lots of details to take care of when writing
    web applications. You need to set up routing rules and authentication policies.
    On top of that, as applications evolve, there are best practices and similar patterns
    that one will have to repeat implementing, if you're not using a web framework.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索 `actix-web` 之前，我们需要了解一些动机，即为什么我们最初需要网络框架。正如我们许多人所知，网络是一个复杂且不断发展的空间。在编写网络应用程序时，有许多细节需要处理。你需要设置路由规则和认证策略。除此之外，随着应用程序的发展，还有一些最佳实践和类似的模式，如果你不使用网络框架，你将不得不重复实现。
- en: It's quite tedious having to reinvent these foundational attributes of web applications
    every time you want to build a web application yourself. A concrete example is
    when you are providing different routes in your application. In a web application
    built from scratch, you would have to parse the resource path from the request, do
    some matching on it, and act on the request. A web framework automates the matching
    of routes and route handlers by providing DSLs to allow you to configure routing
    rules in a cleaner way. Web frameworks also abstract all the best practices, common
    patterns, and idioms around building web applications, and give developers a head
    start, allowing them to focus on their business logic rather than reinventing
    solutions for problems that has already been solved.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每次自己构建网络应用程序时，都需要重新发明这些网络应用程序的基础属性，这相当繁琐。一个具体的例子是，当你在应用程序中提供不同的路由时。在一个从头开始构建的网络应用程序中，你必须从请求中解析资源路径，对其进行一些匹配，并对请求采取行动。网络框架通过提供
    DSLs 自动化路由和路由处理程序的匹配，允许你以更干净的方式配置路由规则。网络框架还抽象了围绕构建网络应用程序的所有最佳实践、常见模式和惯例，为开发者提供一个先发优势，使他们能够专注于业务逻辑，而不是重新发明已经解决的问题的解决方案。
- en: The Rust community has seen a lot of web frameworks in the works, lately such
    as Tower, Tide, Rocket, `actix-web`, Gotham, and so on. At the time of writing
    this book, the most feature-rich and active frameworks are Rocket and `actix-web`.
    While Rocket is quite concise and a polished framework, it requires a nightly
    version of the Rust compiler. This restriction will soon be removed, though, as
    the APIs that Rocket depends on get stabilized. Its direct competitor at the moment
    is `actix-web`, which runs on stable Rust and is quite close to the ergonomics
    that are provided by the Rocket framework. We will be covering `actix-web` next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 社区最近出现了很多正在开发中的网络框架，如 Tower、Tide、Rocket、`actix-web`、Gotham 等。在撰写本书时，功能最丰富且最活跃的框架是
    Rocket 和 `actix-web`。虽然 Rocket 非常简洁且是一个完善的框架，但它需要 Rust 编译器的 nightly 版本。不过，随着 Rocket
    所依赖的 API 的稳定，这个限制很快就会被移除。目前它的直接竞争对手是 `actix-web`，它运行在稳定的 Rust 上，并且与 Rocket 框架提供的用户体验非常接近。接下来我们将介绍
    `actix-web`。
- en: Actix-web basics
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actix-web 基础
- en: The Actix-web framework builds upon the actor model that's implemented by the
    actix crate, which we already covered in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. Actix-web advertises itself as a small, fast, and pragmatic
    HTTP web framework. It's primarily an asynchronous framework that relies internally
    on tokio and the futures crate but also provides a synchronous API and both of
    these APIs can be composed together seamlessly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Actix-web 框架建立在 actix crate 实现的actor模型之上，我们已经在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)“高级概念”中介绍过。Actix-web
    自称是一个小巧、快速且实用的 HTTP 网络框架。它主要是一个异步框架，内部依赖于 tokio 和 futures crate，同时也提供了同步 API，并且这两个
    API 可以无缝组合。
- en: The entry point of any web application written using `actix-web` is the `App`
    struct. On an `App` instance, we can configure various route handlers and middlewares.
    We can also initialize our `App` with any state that we need to maintain across
    a request response. The route handlers that are provided on `App` implement the
    `Handler` trait and are simply functions that map a request to a response. They
    can also include request filters, which can forbid access to a particular route
    based on a predicate.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `actix-web` 编写的任何网络应用程序的入口点是 `App` 结构体。在 `App` 实例上，我们可以配置各种路由处理程序和中间件。我们还可以使用任何需要跨请求/响应维护的状态初始化我们的
    `App`。`App` 上提供的路由处理程序实现了 `Handler` 特性，它们只是将请求映射到响应的函数。它们还可以包括请求过滤器，根据谓词禁止对特定路由的访问。
- en: Actix-web internally spawns a number of worker threads, each with its own tokio
    runtime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Actix-web 内部会启动多个工作线程，每个线程都有自己的 tokio 运行时。
- en: That's the basics out of the way, so let's dive right in, and go through the
    implementation of a REST API server using Actix-web.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念介绍完毕，现在让我们直接进入主题，通过 Actix-web 实现一个 REST API 服务器。
- en: Building a bookmarks API using Actix-web
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Actix-web 构建 Bookmarks API
- en: We'll create a REST API server that allows you to store bookmarks and links
    to any blog or website that you wish to read later. We'll name our server `linksnap`**.**
    Let's create a new project by running `cargo new linksnap`. In this implementation,
    we won't be using a database for persistence for any link that is sent to our
    API, and will simply use an in-memory `HashMap` to store our entries. This means
    that every time our server restarts, all of the stored bookmarks will get removed.
    In [Chapter 14](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml), *Interacting with
    Databases in Rust*, we'll integrate a database with `linksnap`, which will allow
    us to persist bookmarks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个REST API服务器，允许您存储您希望稍后阅读的任何博客或网站的收藏夹和链接。我们将我们的服务器命名为 `linksnap`**。**
    让我们通过运行 `cargo new linksnap` 创建一个新的项目。在这个实现中，我们不会为发送到我们的API的任何链接使用数据库进行持久化，而将简单地使用内存中的
    `HashMap` 来存储我们的条目。这意味着每次我们的服务器重启时，所有存储的收藏夹都将被删除。在 [第14章](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml)，*在Rust中与数据库交互*，我们将集成数据库与
    `linksnap`，这将允许我们持久化收藏夹。
- en: 'Under the `linksnap/` directory, we have the following contents in `Cargo.toml`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `linksnap/` 目录下，`Cargo.toml` 中有以下内容：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll implement the following endpoints in our API server:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的API服务器中实现以下端点：
- en: '`/links` is a `GET` method that retrieves a list of all links stored on the
    server.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/links` 是一个 `GET` 方法，用于检索服务器上存储的所有链接列表。'
- en: '`/add` is a `POST` method that stores an entry of the link and returns a type
    `LinkId` as a response. This can be used to remove the link from the server.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/add` 是一个 `POST` 方法，用于存储链接条目并返回一个类型为 `LinkId` 的响应。这可以用来从服务器上删除链接。'
- en: '`/rm` is a `DELETE` method that removes a link with a given `LinkId`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/rm` 是一个 `DELETE` 方法，用于删除具有给定 `LinkId` 的链接。'
- en: 'We have divided our server implementation into three modules:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的服务器实现分为三个模块：
- en: '`links`: This module provides the `Links` and `Link` types, which represent
    a collection of links and a link, respectively'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`：此模块提供了 `Links` 和 `Link` 类型，分别代表链接集合和单个链接。'
- en: '`route_handlers`: This module contains all of our route handlers'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route_handlers`：此模块包含我们所有的路由处理器。'
- en: '`state`: This module contains the implementation of an actor and all the messages
    it can receive on our `Db` struct.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：此模块包含了一个actor的实现以及它可以在我们的 `Db` 结构体上接收的所有消息。'
- en: 'An example flow of our app from the user request to the actor goes like this
    on the `/links` endpoint:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户请求到actor的示例流程在 `/links` 端点如下：
- en: '![](img/2978326f-60f9-403f-899e-390953d59425.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2978326f-60f9-403f-899e-390953d59425.png)'
- en: 'Let''s go through the implementation, starting by looking at the contents in
    `main.rs`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 `main.rs` 中的内容来了解实现：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In `main`, we first call `init_env`, which sets up our environment for getting
    logs from the server, turns on the `RUST_BACKTRACE` variable for printing a detailed
    trace of any error, and initializes our logger by invoking `env_logger::init()`.We
    then create our System actor which is the parent actor for all actors in the actor
    model. We then create our server state by calling `State::init()` and store it
    in `state`. This encapsulates our in-memory database actor type `Db` in `state.rs`.
    We'll go through this later.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，我们首先调用 `init_env`，这为我们设置从服务器获取日志的环境，打开 `RUST_BACKTRACE` 变量以打印任何错误的详细跟踪，并通过调用
    `env_logger::init()` 初始化我们的日志记录器。然后我们创建我们的系统actor，它是actor模型中所有actor的父actor。然后我们通过调用
    `State::init()` 创建我们的服务器状态并将其存储在 `state` 中。这将在 `state.rs` 中封装我们的内存数据库actor类型 `Db`。我们稍后会详细介绍。
- en: We then create our `App` instance within a closure by calling `App::with_state`,
    thereby passing in our clone of our application `state`. The `clone` call on state
    is important here, as we need to have a single shared state across multiple actix
    worker threads. Actix-web internally spawns multiple threads with new App instances
    to handle requests, and each invocation of this state will have its own copy of
    the application state. If we don't share a reference to a single source of truth,
    then each `App` will have its own copy of the `HashMap` entries, which we don't
    want.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `App::with_state` 在闭包中创建我们的 `App` 实例，从而传递我们的应用程序 `state` 的克隆。这里的 `clone`
    调用很重要，因为我们需要在多个actix工作线程之间共享单个共享状态。Actix-web内部使用新的App实例启动多个线程来处理请求，并且每次调用此状态都将有自己的应用程序状态副本。如果我们不共享单个真相来源的引用，那么每个
    `App` 都将有自己的 `HashMap` 条目副本，这是我们不想看到的。
- en: Next, we chain on our `App` with the method `middleware` by passing in a `Logger`.
    This will log any requests when a client hits one of our provisioned endpoints.
    We then add a bunch of `route` method calls. The `route` method takes an `HTTP`
    path as a string, an HTTP method, and a `handler` function that maps an `HttpRequest`
    to a `HttpResponse`. We'll explore `handler` functions later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过传递一个 `Logger` 来使用 `middleware` 方法将我们的 `App` 链接起来。这样，当客户端击中我们配置的任何一个端点时，都会记录任何请求。然后我们添加了一堆
    `route` 方法调用。`route` 方法接受一个作为字符串的 `HTTP` 路径，一个 HTTP 方法，以及一个将 `HttpRequest` 映射到
    `HttpResponse` 的 `handler` 函数。我们稍后会探讨 `handler` 函数。
- en: With our `App` instance configured and stored in `web_app`, we pass it to `server::new()`,
    followed by binding it to the address string `"127.0.0.1:8080"`. We then call
    `start` to start the app in a new `Arbiter` instance, which is simply a new thread.
    According to actix, an `Arbiter` is a thread where actors are run and can access
    the event loop. Finally, we run our system actor by calling `system.run()`. The
    `run` method internally spins up a `tokio` runtime and starts all the arbiter
    threads.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置并存储 `web_app` 实例后，我们将其传递给 `server::new()`，然后将其绑定到地址字符串 `"127.0.0.1:8080"`。然后我们调用
    `start` 来在一个新的 `Arbiter` 实例中启动应用，这只是一个新的线程。根据 actix，`Arbiter` 是运行 actors 并可以访问事件循环的线程。最后，我们通过调用
    `system.run()` 来运行我们的系统 actor。`run` 方法内部启动一个 `tokio` 运行时并启动所有 arbiter 线程。
- en: 'Next, let''s look at our route handlers in `route_handlers.rs`. This module
    defines all kinds of routes that are available in our server implementation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `route_handlers.rs` 中的路由处理器。此模块定义了我们服务器实现中可用的所有类型的路由：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we have a bunch of imports followed by a couple of helper types defined.
    `ResponseFuture` is a convenient type alias for a boxed `Future` which resolves
    to an `HttpResponse`. We then have a helper macro named `server_err!`, which returns
    an `actix_web::error` type with the given description. We use this macro as a
    convenient way to return error whenver any of our client request processing fails.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一堆导入，然后定义了几个辅助类型。`ResponseFuture` 是一个方便的类型别名，用于一个解析为 `HttpResponse` 的装箱
    `Future`。然后我们有一个名为 `server_err!` 的辅助宏，它返回一个带有给定描述的 `actix_web::error` 类型。我们使用这个宏作为在客户端请求处理失败时返回错误的方便方式。
- en: 'Next, we have our simplest router handler for handling get requests on the
    `/` endpoint:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们拥有处理 `/` 端点 get 请求的最简单路由处理器：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `index` function takes an  `HttpRequest` and simply returns a `HttpResponse`
    constructed from a string. The `HttpRequest` type can be parameterized over any
    type. By default, it is a `()`. For our route handlers, we have parameterized
    it over our `State` type. This `State` encapsulates our in-memory database, which
    is implemented as an actor. `State` is a wrapper over `Addr<Db>`, which is an
    address to our `Db` actor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 函数接受一个 `HttpRequest` 并简单地返回一个由字符串构造的 `HttpResponse`。`HttpRequest` 类型可以参数化任何类型。默认情况下，它是一个
    `()`。对于我们的路由处理器，我们将其参数化为我们的 `State` 类型。这个 `State` 封装了我们的内存数据库，该数据库作为 actor 实现。`State`
    是 `Addr<Db>` 的包装器，它是我们的 `Db` actor 的地址。'
- en: 'This is a reference to our in-memory database. We''ll use this to send messages
    to our in-memory database to insert, remove, or get links. We''ll explore those
    APIs later. Let''s look at some other handlers that are in the same file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对我们内存数据库的引用。我们将使用它来向我们的内存数据库发送消息以插入、删除或获取链接。我们稍后会探讨这些 API。让我们看看同一文件中的其他处理器：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `add_link` function handles `POST` requests for adding a link. This handler
    expects a JSON body of this format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `add_link` 函数处理添加链接的 `POST` 请求。此处理器期望一个具有以下格式的 JSON 主体：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, we first get the request body as JSON by calling `req.json()`.
    This returns a future. We then map any error originated from the json method to
    an actix compatible error using the `from_err` method. The `json` method can extract
    typed information from a request's payload, thereby returning a `JsonBody<T>`
    future. This `T` is inferred by the next method chain `and_then` as `AddLink`
    where we take the parsed value and send it to our `Db` actor. Sending a message
    to our actor can fail, so if this happens, we again match on the returned value.
    In the case of `Ok`, we reply with an empty HTTP response of success, otherwise
    we fail with our `server_err!` macro passing in an error description.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先通过调用`req.json()`获取请求体作为JSON。这返回一个future。然后我们使用`from_err`方法将来自json方法的任何错误映射到与actix兼容的错误。`json`方法可以从请求的有效负载中提取类型化信息，因此返回一个`JsonBody<T>`
    future。这个`T`由下一个方法链`and_then`推断为`AddLink`，我们将解析的值发送到我们的`Db`演员。向我们的演员发送消息可能会失败，所以如果发生这种情况，我们再次匹配返回的值。在`Ok`的情况下，我们回复一个空的HTTP成功响应，否则我们使用`server_err!`宏传递错误描述来失败。
- en: 'Next, we have our `"/links"` endpoint:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`"/links"`端点：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `links` handler simply sends a `GetLinks` message to the `Db` actor and
    returns the received response before sending it back to the client using the `body`
    method. We then have our `rm_link` handler, which is defined as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`links`处理程序简单地发送一个`GetLinks`消息到`Db`演员，并在使用`body`方法将其发送回客户端之前返回接收到的响应。然后我们有我们的`rm_link`处理程序，其定义如下：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To remove a link, we need to pass the link ID (an `i32`) as a query parameter.
    The `rm_link` method extracts the query parameters into a `RmLink` type using
    the convenient `Query::extract` method, which takes in the `HttpRequest` instance.
    Next, we get a reference to our `Db` actor and send an  `RmLink` message to it
    with the ID. We return the reply as a string by constructing the `HttpRespnse`
    with the `body` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个链接，我们需要将链接ID（一个`i32`）作为查询参数传递。`rm_link`方法使用方便的`Query::extract`方法将查询参数提取到`RmLink`类型中，该方法接受一个`HttpRequest`实例。接下来，我们获取对`Db`演员的引用，并向其发送一个带有ID的`RmLink`消息。我们通过使用`HttpRespnse`的`body`方法构造返回的字符串来返回回复。
- en: 'Here''s our `State` and `Db` types in `state.rs`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`State`和`Db`类型在`state.rs`中的定义：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we have set our `DB_THREADS` to a value of `3` which we have chosen arbitrarily.
    We'll have a thread pool through which we'll be making requests to the in-memory
    database. In this case, we could have also used a normal actor, but since we'll
    be integrating it with our database in [Chapter 14](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml),
    *Interacting with Databases in Rust*, we have chosen the `SyncArbiter` thread.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`DB_THREADS`设置为`3`这个值，这是我们任意选择的。我们将通过一个线程池来向内存数据库发送请求。在这种情况下，我们也可以使用一个普通的演员，但由于我们将在[第14章](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml)“使用Rust与数据库交互”中将其与数据库集成，我们选择了`SyncArbiter`线程。
- en: Next, we have the `Db` struct definition that wraps the `Links` type in a thread
    safe wrapper of `Arc<Mutex<Links>`. We then implement the `Actor` trait on it,
    where in we specify the associated type `Context` as `SyncContext<Self>`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`Db`结构体定义，它将`Links`类型封装在一个线程安全的包装器`Arc<Mutex<Links>>`中。然后我们在其上实现`Actor`特质，其中我们指定关联类型`Context`为`SyncContext<Self>`。
- en: We then have a `State` struct definition which is a `Addr<Db>`, i.e., a handle
    to an instance of the `Db` actor. We also have two methods on State - `init` which
    creates a new `State` instance and `get` which returns a reference to the handle
    to the `Db` actor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`State`结构体定义，它是一个`Addr<Db>`，即对`Db`演员实例的句柄。我们还在`State`上定义了两个方法 - `init`用于创建一个新的`State`实例，`get`用于返回对`Db`演员句柄的引用。
- en: 'Next, we have a bunch of message types that will be sent to our `Db` actor.
    Our `Db` is an actor and will receive three messages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一系列将要发送到我们的`Db`演员的消息类型。我们的`Db`是一个演员，将接收三个消息：
- en: '**GetLinks**: This is sent by the `/links` route handler to retrieve all links
    stored on the server. It is defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetLinks**：这是由`/links`路由处理程序发送的，用于检索服务器上存储的所有链接。它定义如下：'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First is the `GetLinks` message, which is sent to the `Db` actor from the `/links`
    route handler. To make this an actor message, we'll implement the `Message` trait
    for it. The `Message` trait defines an associated type `Result`, which is the
    type returned from the handler of the message. Next, we implement the `Handler`
    trait that is parameterized over the message `GetLinks` for the `Db` actor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 `GetLinks` 消息，它是由 `/links` 路由处理器发送到 `Db` actor 的。为了使这成为一个actor消息，我们将为它实现
    `Message` 特性。`Message` 特性定义了一个关联类型 `Result`，这是消息处理器的返回类型。接下来，我们为 `Db` actor 实现了参数化于消息
    `GetLinks` 的 `Handler` 特性。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We implement the `Message` trait for it, which returns the string of all the
    links as the response.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为它实现了 `Message` 特性，它返回所有链接的字符串作为响应。
- en: '**AddLink**: This is sent by the `/add` route handler on any new link that''s
    sent by the client. It is defined as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddLink**：这是由 `/add` 路由处理器在客户端发送的任何新链接时发送的。它定义如下：'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Th `AddLink` type performs a double duty. With the `Serialize` and `Deserialize`
    traits implemented, it acts as a type that can be extracted from the incoming
    json response body in the `add_link` route. Second, it also implements the `Message`
    trait, which we can send to our `Db` actor.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddLink` 类型具有双重功能。当实现了 `Serialize` 和 `Deserialize` 特性时，它作为一个可以从 `add_link`
    路由的入站json响应体中提取的类型。其次，它还实现了 `Message` 特性，我们可以将其发送到我们的 `Db` actor。'
- en: '**RmLink**: This is sent by the `/rm` route handler. It is defined as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**RmLink**：这是由 `/rm` 路由处理器发送的。它定义如下：'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is the message sent when one wants to remove a link entry. It takes the
    RmLink message and forwards it
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当想要删除链接条目时发送的消息。它接收RmLink消息并将其转发
- en: 'We can insert a link with the following curl command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下curl命令插入一个链接：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To view the inserted links, we can issue:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看插入的链接，我们可以发出：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To remove a link, given its Id, we can send a DELETE request using curl as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个链接，给定其Id，我们可以使用curl发送一个DELETE请求，如下所示：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a lot about building web applications with Rust
    and how easy it is to get started, given the high-quality crates that are available
    to us. Being a compiled language, web applications written in Rust are many times
    smaller than other frameworks that are written in dynamic languages. Most of the
    web framework space is dominated by interpreted dynamic languages that can hog
    a lot of CPU but aren't very resource-efficient. However, people use them because
    web applications are very convenient to write with them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Rust构建Web应用程序的很多内容，以及鉴于我们可用的优质crate，开始使用是多么容易。作为一个编译型语言，用Rust编写的Web应用程序通常比用动态语言编写的其他框架小得多。大多数Web框架空间由可以占用大量CPU但资源效率不高的解释型动态语言主导。然而，人们使用它们，因为使用它们编写Web应用程序非常方便。
- en: Web applications that are written with Rust take up a lot less space at runtime.
    Rust also takes up less memory during runtime, as no interpreter is needed, as
    is the case with dynamic languages. With Rust, you get the best of both worlds,
    that is, the same feel of dynamic languages while at the same time being performant,
    like C. This is a great deal for the web.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用Rust编写的Web应用程序在运行时占用的空间要小得多。Rust在运行时也占用更少的内存，因为不需要解释器，这与动态语言的情况一样。使用Rust，你可以同时获得动态语言的感受和C语言的性能。这对Web来说是一笔大交易。
- en: In the next chapter, we'll explore how Rust can talk to databases and add data
    persistence to our `read_list` server by using a type-safe **Object Relational
    Mapper (ORM)** library called **diesel***.*
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rust如何与数据库通信，并通过使用名为 **diesel** 的类型安全 **对象关系映射器 (ORM)** 库来为我们的 `read_list`
    服务器添加数据持久性。
