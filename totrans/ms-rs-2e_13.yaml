- en: Building Web Applications with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explore building web applications with Rust. We'll get
    to know the benefits of a static type system and the speed of a compiled language
    when building web applications with it. We'll also explore Rust's strongly typed
    HTTP libraries and build a URL shortener as an exercise. Following that, we'll
    look at a very popular framework called Actix-web and build a bookmark API server
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a URL shortener with Hyper Crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Actix-web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an HTTP Rest API using Actix-web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web applications in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"The most important property of a program is whether it accomplishes the intention
    of its user." *'
  prefs: []
  type: TYPE_NORMAL
- en: – *C. A. R. Hoare*
  prefs: []
  type: TYPE_NORMAL
- en: It's rare for a low-level language to enable developers to write web applications
    with it while providing thekind of high-level ergonomics that dynamic languages
    do. With Rust, it's quite the opposite. Developing web applications with Rust
    is a similar experience one might expect from dynamic languages such as Ruby or
    Python, due to its high-level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications developed in dynamic languages can only get you so far though.
    A lot of developers find to what, as their code base reaches about a 100,000 lines
    of code, they start seeing the brittle nature of dynamic languages. With every
    small change you make, you need to have tests in place to let you know what parts
    of the application are affected. As the application grows, it becomes a whack-a-mole
    situation in terms of testing and updating.
  prefs: []
  type: TYPE_NORMAL
- en: Building web applications in a statically typed language such as Rust is another
    level of experience. Here, you get compile-time checks on your code, thus reducing
    the amount of unit tests you have to write by a large amount. You don't have the
    overhead of a language runtime such as an interpreter either, as is the case with
    dynamic languages that run a GC along with your application. Web applications
    written in a statically typed language can be compiled as a single static binary
    that can be deployed with minimal setup needed. Besides, you get speed and accuracy
    guarantees from the type system and there is a lot of help from the compiler during
    code refactoring. Rust gives you all of these guarantees, along with the same
    high-level feel of dynamic languages.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications primarily sit on the application layer protocol and speak the
    HTTP protocol. HTTP is a stateless protocol where each message is either a request
    or a response from the client or the server. A message in the HTTP protocol consists
    of a header and a payload. The header provides context for the kind of HTTP message,
    such as its origin or the length of the payload, while the payload contains the
    actual data. HTTP is a text-based protocol, and we generally use libraries to
    do the hard work of parsing strings as proper HTTP messages. These libraries are
    further used to build high-level abstractions on top of them, such as a web framework.
  prefs: []
  type: TYPE_NORMAL
- en: To speak HTTP in Rust, we have the `hyper` crate, which we'll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Typed HTTP with Hyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **hyper** crate can parse HTTP messages, and has an elegant design with
    focus on strongly typed APIs. It is designed as a type-safe abstraction for raw
    HTTP requests, as opposed to a common theme in HTTP libraries: describing everything
    as strings. For example, HTTP status codes in Hyper are defined as enums, for
    example, the type `StatusCode`. The same goes for pretty much everything that
    can be strongly typed, such as HTTP methods, MIME types, HTTP headers, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: Hyper has both client and server functionality split into separate modules.
    The client side allows you to build and make HTTP requests with a configurable
    request body, headers, and other low-level configurations. The server side allows
    you to open a listening socket and attach request handlers to it. However, it
    does not include any request route handler implementation – that is left to web
    frameworks. It is designed to be used as a foundational crate to build higher-level
    web frameworks. It uses the same `tokio` and `futures` async abstractions under
    the hood and thus is very performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, Hyper has the concept  `Service` trait concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Service` trait represents a type that handles HTTP requests that are sent
    from any client and returns a `Response`, which is a future. The core API of this
    trait that types need to implement is the `call` method, which takes in a `Request` that's
    parameterized over a generic type `Body` and returns a `Future` that resolves
    to a `Response`, which is parameterized over the associated type `ResBody`. We
    don't need to manually implement this trait, as hyper includes a bunch of factory
    methods that can implement the `Service` trait for you. You simply need to provide
    a function that takes HTTP requests and returns responses.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll explore both the client and server APIs of hyper.
    Let's start by exploring the server APIs by building a URL shortener from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Hyper server APIs – building a URL shortener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll build a URL shortener server that exposes a `/shorten`
    endpoint. This endpoint accepts a `POST` request, with the body containing the
    URL to be shortened. Let''s fire up a new project by running `cargo new hyperurl`
    with the following dependencies in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll name our URL shortening server, **hyperurl**. A URL shortener service
    is a service that provides the functionality to create a shorter URL for any given
    URL. When you have a really long URL, it becomes tedious to share it with someone.
    A lot of URL shortening services exist today, such as *bit.ly*. If you have used
    Twitter, users use short URL in tweets quite often, to save space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our initial implementation in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main`, we create a `Server` instance and bind it to our loopback address
    and port string `"127.0.0.1:3002"`. This returns a builder instance on which we
    call `serve` before passing in the function `url_service` which implements the
    `Service` trait. The function `url_service` maps a `Request` to a future of `Response`. `service_fn`
    is a factory function that has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, F needs to be a Fn closure that
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function `url_service` implements the `Service` trait. Next, let''s see
    the code in `service.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This module exposes a single function `url_service`, which implements the `Service`
    trait. Our `url_service` method implements the method `call` by taking in a req
    of the `Request<Body>` type and returns a future that is behind a `Box`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, is our `shortener` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our `shorten_url` function takes in a URL to shorten as a `&str`. It then computes
    the SHA-256 hash of the URL and truncates it to a string of length five. This
    is obviously not how a real URL shortener works and is not a scalable solution
    either. However, it's fine for our demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f550a241-244e-4c30-ac50-b0d294eddb26.png)'
  prefs: []
  type: TYPE_IMG
- en: Our server is running. At this point we can either send requests POST through
    curl. We'll do this the other way by building a command-line client for sending
    URLs to shorten this server.
  prefs: []
  type: TYPE_NORMAL
- en: While Hyper is recommended for complex HTTP applications, it's quite cumbersome
    every time to create a handler service, register it, and run it in a runtime.
    Often, for to build smaller tools such as a CLI application that needs to make
    a couple of `GET` requests, this becomes overkill. Fortunately, we have another
    opinionated wrapper over hyper called the `reqwest` crate. As the name suggests,
    it is inspired by Python's Requests library. We'll use this to build our hyperurl
    client that sends URL shorten requests.
  prefs: []
  type: TYPE_NORMAL
- en: hyper as a client – building a URL shortener client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our URL shortener service ready, let's explore the client side
    of hyper. Although we can build a web UI that we can use for shortening URLs,
    we'll keep it simple and build a **Command-Line Interface (CLI)** tool. The CLI
    can be used to pass any URL that needs to be shortened. In response, we'll get
    back the shortened URL from our hyperurl server.
  prefs: []
  type: TYPE_NORMAL
- en: While hyper is recommended for building complex web applications, a lot of setup
    is involved every time you need to create a handler service, register it, and
    run it in a runtime instance. When building smaller tools, such as a CLI application
    that needs to make a few GET requests, all of these steps become overkill. Fortunately,
    we have a convenient wrapper crate over hyper called **reqwest** that abstracts
    hyper's client APIs. As the name suggests, it is inspired by Python's Requests
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project by running `cargo new shorten` with the following
    dependencies in our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To build the CLI tool, we'll use the `quicli` framework, which is a collection
    of high- quality crates that help build CLI tools. The `structopt` crate is used
    along with `quicli`, while the `serde` crate is used by the `structopt` crate
    for the derive macro. To make `POST` requests to our hyperurl server, we'll use
    the `reqwest` crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main.rs` has the following code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With our hyperurl server still running, we''ll open a new terminal window and
    invoke shorten with `cargo run -- --url https://rust-lang.org`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93a8e603-0cea-4082-81a8-be8d91fec8bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s head over to a browser with the shortened URL, that is, `http://127.0.0.1:3002/abf27`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/548e4c05-76d0-4567-9af3-1952a6c01582.png)'
  prefs: []
  type: TYPE_IMG
- en: Having explored hyper, let's get a bit more high level. In the next section,
    we'll explore Actix-web, a fast web application framework based on the actor model
    implementation in the `actix` crate. But, first let's talk about why we need web
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Web frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin exploring `actix-web`, we need to get some motivation as to
    why we need web frameworks in the first place. The web, as many of us know, is
    a complex, evolving space. There are lots of details to take care of when writing
    web applications. You need to set up routing rules and authentication policies.
    On top of that, as applications evolve, there are best practices and similar patterns
    that one will have to repeat implementing, if you're not using a web framework.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite tedious having to reinvent these foundational attributes of web applications
    every time you want to build a web application yourself. A concrete example is
    when you are providing different routes in your application. In a web application
    built from scratch, you would have to parse the resource path from the request, do
    some matching on it, and act on the request. A web framework automates the matching
    of routes and route handlers by providing DSLs to allow you to configure routing
    rules in a cleaner way. Web frameworks also abstract all the best practices, common
    patterns, and idioms around building web applications, and give developers a head
    start, allowing them to focus on their business logic rather than reinventing
    solutions for problems that has already been solved.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust community has seen a lot of web frameworks in the works, lately such
    as Tower, Tide, Rocket, `actix-web`, Gotham, and so on. At the time of writing
    this book, the most feature-rich and active frameworks are Rocket and `actix-web`.
    While Rocket is quite concise and a polished framework, it requires a nightly
    version of the Rust compiler. This restriction will soon be removed, though, as
    the APIs that Rocket depends on get stabilized. Its direct competitor at the moment
    is `actix-web`, which runs on stable Rust and is quite close to the ergonomics
    that are provided by the Rocket framework. We will be covering `actix-web` next.
  prefs: []
  type: TYPE_NORMAL
- en: Actix-web basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Actix-web framework builds upon the actor model that's implemented by the
    actix crate, which we already covered in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. Actix-web advertises itself as a small, fast, and pragmatic
    HTTP web framework. It's primarily an asynchronous framework that relies internally
    on tokio and the futures crate but also provides a synchronous API and both of
    these APIs can be composed together seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: The entry point of any web application written using `actix-web` is the `App`
    struct. On an `App` instance, we can configure various route handlers and middlewares.
    We can also initialize our `App` with any state that we need to maintain across
    a request response. The route handlers that are provided on `App` implement the
    `Handler` trait and are simply functions that map a request to a response. They
    can also include request filters, which can forbid access to a particular route
    based on a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Actix-web internally spawns a number of worker threads, each with its own tokio
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: That's the basics out of the way, so let's dive right in, and go through the
    implementation of a REST API server using Actix-web.
  prefs: []
  type: TYPE_NORMAL
- en: Building a bookmarks API using Actix-web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create a REST API server that allows you to store bookmarks and links
    to any blog or website that you wish to read later. We'll name our server `linksnap`**.**
    Let's create a new project by running `cargo new linksnap`. In this implementation,
    we won't be using a database for persistence for any link that is sent to our
    API, and will simply use an in-memory `HashMap` to store our entries. This means
    that every time our server restarts, all of the stored bookmarks will get removed.
    In [Chapter 14](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml), *Interacting with
    Databases in Rust*, we'll integrate a database with `linksnap`, which will allow
    us to persist bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `linksnap/` directory, we have the following contents in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll implement the following endpoints in our API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/links` is a `GET` method that retrieves a list of all links stored on the
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/add` is a `POST` method that stores an entry of the link and returns a type
    `LinkId` as a response. This can be used to remove the link from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/rm` is a `DELETE` method that removes a link with a given `LinkId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have divided our server implementation into three modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`links`: This module provides the `Links` and `Link` types, which represent
    a collection of links and a link, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route_handlers`: This module contains all of our route handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: This module contains the implementation of an actor and all the messages
    it can receive on our `Db` struct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example flow of our app from the user request to the actor goes like this
    on the `/links` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2978326f-60f9-403f-899e-390953d59425.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go through the implementation, starting by looking at the contents in
    `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In `main`, we first call `init_env`, which sets up our environment for getting
    logs from the server, turns on the `RUST_BACKTRACE` variable for printing a detailed
    trace of any error, and initializes our logger by invoking `env_logger::init()`.We
    then create our System actor which is the parent actor for all actors in the actor
    model. We then create our server state by calling `State::init()` and store it
    in `state`. This encapsulates our in-memory database actor type `Db` in `state.rs`.
    We'll go through this later.
  prefs: []
  type: TYPE_NORMAL
- en: We then create our `App` instance within a closure by calling `App::with_state`,
    thereby passing in our clone of our application `state`. The `clone` call on state
    is important here, as we need to have a single shared state across multiple actix
    worker threads. Actix-web internally spawns multiple threads with new App instances
    to handle requests, and each invocation of this state will have its own copy of
    the application state. If we don't share a reference to a single source of truth,
    then each `App` will have its own copy of the `HashMap` entries, which we don't
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we chain on our `App` with the method `middleware` by passing in a `Logger`.
    This will log any requests when a client hits one of our provisioned endpoints.
    We then add a bunch of `route` method calls. The `route` method takes an `HTTP`
    path as a string, an HTTP method, and a `handler` function that maps an `HttpRequest`
    to a `HttpResponse`. We'll explore `handler` functions later.
  prefs: []
  type: TYPE_NORMAL
- en: With our `App` instance configured and stored in `web_app`, we pass it to `server::new()`,
    followed by binding it to the address string `"127.0.0.1:8080"`. We then call
    `start` to start the app in a new `Arbiter` instance, which is simply a new thread.
    According to actix, an `Arbiter` is a thread where actors are run and can access
    the event loop. Finally, we run our system actor by calling `system.run()`. The
    `run` method internally spins up a `tokio` runtime and starts all the arbiter
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at our route handlers in `route_handlers.rs`. This module
    defines all kinds of routes that are available in our server implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we have a bunch of imports followed by a couple of helper types defined.
    `ResponseFuture` is a convenient type alias for a boxed `Future` which resolves
    to an `HttpResponse`. We then have a helper macro named `server_err!`, which returns
    an `actix_web::error` type with the given description. We use this macro as a
    convenient way to return error whenver any of our client request processing fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our simplest router handler for handling get requests on the
    `/` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `index` function takes an  `HttpRequest` and simply returns a `HttpResponse`
    constructed from a string. The `HttpRequest` type can be parameterized over any
    type. By default, it is a `()`. For our route handlers, we have parameterized
    it over our `State` type. This `State` encapsulates our in-memory database, which
    is implemented as an actor. `State` is a wrapper over `Addr<Db>`, which is an
    address to our `Db` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a reference to our in-memory database. We''ll use this to send messages
    to our in-memory database to insert, remove, or get links. We''ll explore those
    APIs later. Let''s look at some other handlers that are in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `add_link` function handles `POST` requests for adding a link. This handler
    expects a JSON body of this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we first get the request body as JSON by calling `req.json()`.
    This returns a future. We then map any error originated from the json method to
    an actix compatible error using the `from_err` method. The `json` method can extract
    typed information from a request's payload, thereby returning a `JsonBody<T>`
    future. This `T` is inferred by the next method chain `and_then` as `AddLink`
    where we take the parsed value and send it to our `Db` actor. Sending a message
    to our actor can fail, so if this happens, we again match on the returned value.
    In the case of `Ok`, we reply with an empty HTTP response of success, otherwise
    we fail with our `server_err!` macro passing in an error description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our `"/links"` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `links` handler simply sends a `GetLinks` message to the `Db` actor and
    returns the received response before sending it back to the client using the `body`
    method. We then have our `rm_link` handler, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To remove a link, we need to pass the link ID (an `i32`) as a query parameter.
    The `rm_link` method extracts the query parameters into a `RmLink` type using
    the convenient `Query::extract` method, which takes in the `HttpRequest` instance.
    Next, we get a reference to our `Db` actor and send an  `RmLink` message to it
    with the ID. We return the reply as a string by constructing the `HttpRespnse`
    with the `body` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `State` and `Db` types in `state.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we have set our `DB_THREADS` to a value of `3` which we have chosen arbitrarily.
    We'll have a thread pool through which we'll be making requests to the in-memory
    database. In this case, we could have also used a normal actor, but since we'll
    be integrating it with our database in [Chapter 14](059e4aef-2091-490e-9358-2b8dd620c1f0.xhtml),
    *Interacting with Databases in Rust*, we have chosen the `SyncArbiter` thread.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `Db` struct definition that wraps the `Links` type in a thread
    safe wrapper of `Arc<Mutex<Links>`. We then implement the `Actor` trait on it,
    where in we specify the associated type `Context` as `SyncContext<Self>`.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a `State` struct definition which is a `Addr<Db>`, i.e., a handle
    to an instance of the `Db` actor. We also have two methods on State - `init` which
    creates a new `State` instance and `get` which returns a reference to the handle
    to the `Db` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a bunch of message types that will be sent to our `Db` actor.
    Our `Db` is an actor and will receive three messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GetLinks**: This is sent by the `/links` route handler to retrieve all links
    stored on the server. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First is the `GetLinks` message, which is sent to the `Db` actor from the `/links`
    route handler. To make this an actor message, we'll implement the `Message` trait
    for it. The `Message` trait defines an associated type `Result`, which is the
    type returned from the handler of the message. Next, we implement the `Handler`
    trait that is parameterized over the message `GetLinks` for the `Db` actor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We implement the `Message` trait for it, which returns the string of all the
    links as the response.
  prefs: []
  type: TYPE_NORMAL
- en: '**AddLink**: This is sent by the `/add` route handler on any new link that''s
    sent by the client. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Th `AddLink` type performs a double duty. With the `Serialize` and `Deserialize`
    traits implemented, it acts as a type that can be extracted from the incoming
    json response body in the `add_link` route. Second, it also implements the `Message`
    trait, which we can send to our `Db` actor.
  prefs: []
  type: TYPE_NORMAL
- en: '**RmLink**: This is sent by the `/rm` route handler. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the message sent when one wants to remove a link entry. It takes the
    RmLink message and forwards it
  prefs: []
  type: TYPE_NORMAL
- en: 'We can insert a link with the following curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the inserted links, we can issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a link, given its Id, we can send a DELETE request using curl as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a lot about building web applications with Rust
    and how easy it is to get started, given the high-quality crates that are available
    to us. Being a compiled language, web applications written in Rust are many times
    smaller than other frameworks that are written in dynamic languages. Most of the
    web framework space is dominated by interpreted dynamic languages that can hog
    a lot of CPU but aren't very resource-efficient. However, people use them because
    web applications are very convenient to write with them.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications that are written with Rust take up a lot less space at runtime.
    Rust also takes up less memory during runtime, as no interpreter is needed, as
    is the case with dynamic languages. With Rust, you get the best of both worlds,
    that is, the same feel of dynamic languages while at the same time being performant,
    like C. This is a great deal for the web.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore how Rust can talk to databases and add data
    persistence to our `read_list` server by using a type-safe **Object Relational
    Mapper (ORM)** library called **diesel***.*
  prefs: []
  type: TYPE_NORMAL
