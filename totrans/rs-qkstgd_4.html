<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making Decisions by Pattern Matching</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>We already saw Rust's <kbd>if</kbd> expressions, but those make decisions based on data values. Rust is a very type-conscious language, and so it's very important to be able to make decisions based on data types as well. Rust's</span> <kbd><span>match</span></kbd> <span>and</span> <kbd><span>if let</span></kbd> <span>expressions let us do that, comparing complex data types and allowing us to extract data values for further processing.</span></p>
<p>In this chapter, we're going to do the following:</p>
<ul>
<li>Learn how to use pattern matching in the context of variable assignment using the <kbd>let</kbd> statement</li>
<li>Take what we've learned about pattern matching and apply it to decision making with the <kbd>if let</kbd> expression</li>
<li>Use the <kbd>match</kbd> expression to choose exactly one of many possible patterns</li>
<li>Use don't care values in pattern matching</li>
<li>See how borrowing interacts with pattern matching</li>
<li>Learn how to match complex, nested data structures</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variable assignment with pattern matching</h1>
                </header>
            
            <article>
                
<p>We've seen many times how to assign a variable in Rust: we do something like <kbd>let x = y;</kbd>, which tells Rust to create a new variable named <kbd>x</kbd> and move or copy the value stored in <kbd>y</kbd> into it, as appropriate to the data type.</p>
<p>However, that's actually just a simplified case of what Rust is really doing, which is matching a pattern to a value and extracting data values from that matched pattern to store in the target variables, as in the following example:</p>
<pre>pub struct DemoStruct {<br/> pub id: u64,<br/> pub name: String,<br/> pub probability: f64,<br/>}<br/>// ...<br/>let source1 = DemoStruct { id: 31, name: String::from("Example Thing"), probability: 0.42 };<br/><br/>let DemoStruct{ id: x, name: y, probability: z } = source1;</pre>
<p>Okay, what just happened? First of all, we have a structure definition. We've seen those before, and the only new thing here is that we're using the <kbd>String</kbd> data type.</p>
<div class="packt_infobox"><kbd>String</kbd> has an interesting relationship with <kbd>str</kbd>. When we're using <kbd>str</kbd>, we almost always actually use a borrow such as <kbd>&amp;str</kbd> or <kbd>&amp;'static str</kbd>, rather than plain <kbd>str</kbd>. That's because plain <kbd>str</kbd> doesn't have a fixed size in the stack, which makes a lot of the things we'd want to do impossible to compile. So, we use <kbd>&amp;str</kbd> instead, which does have a fixed size. <em>But</em>, using a reference as a contained value in a data structure also opens the door to all sorts of lifetime-based restrictions, so we don't really want to use <kbd>pub name: &amp;str</kbd> here. Fortunately, we can use <kbd>String</kbd> instead.<kbd>String</kbd> can masquerade as an <kbd>&amp;str</kbd> when we need it to, but it's not actually a borrow, so the ownership is straightforward. It is, however, slightly less efficient to use, so the general rule is to use <kbd>String</kbd> when it solves a problem and use <kbd>&amp;str</kbd> the rest of the time.</div>
<p>After that, we create a new data value with the <kbd>DemoStruct</kbd> type, with its three contained values. We've seen that before, too.</p>
<p>What on Earth are we doing in the last line of the example? <kbd>DemoStruct{ id: x, name: y, probability: z }</kbd> is a pattern. We're telling Rust that we expect the assigned value to be a <kbd>DemoStruct</kbd>, and that its contained values should in turn be matched with the <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> sub-patterns.</p>
<p>When we use a variable name as a pattern, it matches any value and that value is assigned to that name, which is what is happening here. It's also what's happening with a simple <kbd>let x = 5</kbd>. So, <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> end up being new variables containing the values that were previously stored in <kbd>source.id</kbd>, <kbd>source.name</kbd>, and <kbd>source.probability</kbd>, respectively.</p>
<p>We didn't have to use variable names for the sub-patterns, though. We could, for example, have tried this:</p>
<pre>DemoStruct{ id: 31, name: y, probability: z } = source1;</pre>
<p>If we do that, however, the compiler will report an error. The error is not because <kbd>31</kbd> is an invalid pattern. It's a perfectly good pattern and even happens to match the value we would actually find. The compiler will refuse to compile it, though, because it doesn't match all of the possibilities for the source value, and Rust doesn't allow <kbd>let</kbd> statements that might fail just because a variable's value got changed. Imagine of all the trouble that it could cause!</p>
<div class="packt_tip">The Rust compiler refers to being able to handle all of the possibilities when pattern matching as <strong>covering</strong>.</div>
<p>For patterns that might or might not match the input value, we can use <kbd>if let</kbd> expressions instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using if let expressions to test whether a pattern matches</h1>
                </header>
            
            <article>
                
<p>Using pattern matching to unpack values into multiple variables can be useful, but using pattern matching to make decisions is where this functionality really shines, as in the following example:</p>
<pre>let source2 = DemoStruct { id: 35, name: String::from("Another Thing"), probability: 0.42 };<br/>let source3 = DemoStruct { id: 63, name: String::from("Super Thing"), probability: 0.99 };<br/><br/>if let DemoStruct { id: 63, name: y, probability: z } = source2 {<br/>    println!("When id is 63, name is {} and probability is {}", y, z);<br/>}<br/><br/>if let DemoStruct { id: 63, name: y, probability: z } = source3 {<br/>    println!("When id is 63, name is {} and probability is {}", y, z);<br/>}</pre>
<p>Here, we've defined two more variables containing <kbd>DemoStruct</kbd> values, and then used pattern matching to pull them back apart and assign their contained values to individual variables. This time, though, we did it in an <kbd>if let</kbd> expression instead of a <kbd>let</kbd> expression. That makes a world of difference, because now the pattern doesn't have to cover the whole domain of possible input values. If the pattern matches, the <kbd>if let</kbd> expression runs the code in its block. If the pattern doesn't match, then the <kbd>if let</kbd> expression doesn't run the code. It's conditional.</p>
<p>Since the pattern doesn't have to cover the domain, it means we can use <kbd>63</kbd> as a pattern to match against the <kbd>id</kbd> value, and there's nothing wrong with that. The same principle applies to more complex patterns or any pattern that only matches a subset of the values that might be represented by the data type it's matched against.</p>
<p>We can combine <kbd>if let</kbd> with normal <kbd>if</kbd> and <kbd>else</kbd> expressions, to create more complex decision-making structures, in a couple of ways.</p>
<p>First, we can put an <kbd>if let</kbd> expression inside the block of an <kbd>if</kbd>, <kbd>else if</kbd>, or <kbd>else</kbd> expression, and vice versa. That comes naturally, since there's nothing unusual about those block expressions—no special restrictions are placed on them just because they're inside a conditional expression.</p>
<p>Second, we can combine <kbd>if let</kbd> or <kbd>else if let</kbd> into the same chain of options as <kbd>if</kbd>, <kbd>else if</kbd>, and <kbd>else</kbd>. That looks like this:</p>
<pre>    if false {<br/> println!("This never happens");<br/> }<br/> else if let DemoStruct{ id: 35, name: y, probability: z } = source4 {<br/> println!("When id is 35, name is {} and probability is {}", y, z);<br/> }<br/> else if let DemoStruct{ id: 36, name: y, probability: z } = source4 {<br/> println!("When id is 36, name is {} and probability is {}", y, z);<br/> }<br/> else {<br/> println!("None of the conditions matched");<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The chain has to start with an <kbd>if</kbd> or <kbd>if let</kbd> expression (whichever one we need), and can then have any number of <kbd>else if</kbd> or <kbd>else if let</kbd>, and finally an <kbd>else if</kbd> expression we need one.</p>
<p class="mce-root">We're still just pulling data values out of our structures with the pattern matching, though. We can do more when the pattern is matched against other kinds of data type. An important one is the <kbd>Result</kbd> data type we've talked about previously. Remember that <kbd>Result</kbd> can be either <kbd>Ok</kbd> or <kbd>Err</kbd>, and either way it contains a value, either a result value or an error value of some sort. We saw before how to use the <kbd>?</kbd> or assorted functions to deal with <kbd>Result</kbd>, but we can also handle it with pattern matching, and that's often going to be the way we'll choose.</p>
<p>So, here's a function that constructs a <kbd>DemoStruct</kbd> value for us, but it only does it if the <kbd>id</kbd> value we ask for is even (the remainder when divided by two is zero). This function gives us a <kbd>Result</kbd> containing the created <kbd>DemoStruct</kbd> value or an error message:</p>
<pre>pub fn might_fail(id: u64) -&gt; Result&lt;DemoStruct, &amp;'static str&gt; {<br/>    if id % 2 == 0 {<br/>     Ok(DemoStruct { id: id, name: String::from("An Even Thing"), probability: 0.2})<br/> }<br/> else {<br/> Err("Only even numbers are allowed")<br/> }<br/>}</pre>
<p>If we then call that function, we can use pattern matching to figure out if it succeeded or failed:</p>
<pre>    if let Ok(x) = might_fail(37) {<br/>        println!("Odd succeeded, name is {}", x.name);<br/>    }<br/><br/>    if let Ok(x) = might_fail(38) {<br/>        println!("Even succeeded, name is {}", x.name);<br/>    }</pre>
<p>Here, we're calling <kbd>might_fail</kbd> twice, once with an odd number as the parameter value, and once with an even one. Both times, we use pattern matching to check whether the result is <kbd>Ok</kbd> and assign the contained value to a variable called <kbd>x</kbd> if it is.</p>
<p><kbd>Ok</kbd> is not a data structure and neither is <kbd>Err</kbd>. We'll learn more about what they are in the next chapter. The point for now is that pattern matching gives us a simple way to check whether <kbd>Result</kbd> represents a success or a failure, and to handle one or both cases easily.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using match to choose one of several patterns</h1>
                </header>
            
            <article>
                
<p>You might have noticed in our previous example that we did not handle the case where the function returned an error value. In part, that's because handling that situation with <kbd>if let</kbd> is a little bit awkward. We could do this:</p>
<pre>if let Ok(x) = might_fail(39) {<br/>    println!("Odd succeeded, name is {}", x.name);<br/>}<br/>else if let Err(x) = might_fail(39) {<br/>    println!("Odd failed, message is '{}'", x);<br/>}</pre>
<p>But that runs the function twice when it doesn't have to, so it's inefficient. We could fix that by doing this:</p>
<pre><span>let result = might_fail(39);</span><br/>if let Ok(x) = result {<br/>    println!("Odd succeeded, name is {}", x.name);<br/>}<br/>else if let Err(x) = result {<br/>    println!("Odd failed, message is '{}'", x);<br/>}</pre>
<p class="mce-root">That's better, but variables are for storing information and we don't really need the <kbd>result</kbd> value anymore once we've checked for the success or failure of the function, so there's no reason to keep storing it.</p>
<p>We can use a <kbd>match</kbd> expression for situations like this, for the best results:</p>
<pre>match might_fail(39) {<br/>    Ok(x) =&gt; { println!("Odd succeeded, name is {}", x.name) }<br/>    Err(x) =&gt; { println!("Odd failed, message is '{}'", x) }<br/>}</pre>
<p>A <kbd>match</kbd> expression matches a single value (in this case, the result of calling <kbd>might_fail(39)</kbd>) against multiple patterns, until it finds a pattern that successfully matches the value, then runs the code block associated with that particular pattern. The patterns are matched from top to bottom so, normally, we put the most specific patterns first and the most generic patterns last.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Individual patterns in a <kbd>match</kbd> expression don't have to cover all of the possibilities for the value, but all of them together need to. If <kbd>Result</kbd> had three possibilities instead of two (</p>
<p class="mce-root"/>
<p><kbd>Ok</kbd>, <kbd>Err</kbd>, and a hypothetical <kbd>Dunno</kbd>, for example), then our previous match expression would not compile, because we hadn't told it what to do in the case of <kbd>Dunno</kbd>.</p>
<div class="packt_tip"><span>That's a difference from a series of </span><kbd>if let</kbd><span> and </span><kbd>el</kbd></div>
<div class="packt_tip"><kbd>se if let</kbd><span>, which are free to ignore as many possibilities as they want. If we use <kbd>match</kbd>, the compiler will tell us if we've missed a possibility, so we should always use <kbd>match</kbd> when we intend to handle all of the options. On the other hand, <kbd>if let</kbd> is for cherry-picking one or a few special cases.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using don't care in patterns</h1>
                </header>
            
            <article>
                
<p>Sometimes, the trick that variable's names have of matching any value in a pattern would be useful, but we don't actually need the information that would be stored in the variable. For example, we might not care about the error value when matching <kbd>Result</kbd>, just the fact that there was an error. In that situation, we can use an <kbd>_</kbd> symbol to indicate <em>I don't care what this value is</em>:</p>
<pre>match might_fail(39) {<br/>    Ok(x) =&gt; { println!("Odd succeeded, name is {}", x.name) }<br/>    Err(_) =&gt; { println!("Odd failed! Woe is me.") }<br/>}</pre>
<p>That's the reason why <kbd>_</kbd> by itself can not be used as a variable name: it has a special meaning of its own. We can match <kbd>_</kbd> against any data value of any data type, even multiple times in the same expression, and the matched values will simply be ignored.</p>
<p>Matching a value to <kbd>_</kbd> does not even move or copy the value. When we tell the compiler that we don't care about a value, it believes us. However, there's an intermediate level between a full variable and a <em>don't care.</em> If we start a variable name with an <kbd>_</kbd> but continue on after that with a valid variable name, the named variable isn't a <em>don't car</em>e but it <em>is</em> exempt from some compiler warnings.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For example, normally, the compiler would warn us if we received a value into a variable but then did nothing with it. Putting an <kbd>_</kbd> at the start of the variable name means the compiler will not complain about that. Where <kbd>_</kbd> by itself means <em>I don't care about this value</em>, starting a variable name with <kbd>_</kbd> means <em>it's okay if I don't use this value.</em></p>
<div class="packt_tip">A common use for that is when we are designing for the future. We might anticipate that a function parameter or structure member will be useful in the future, so we put it in now, but don't use it yet. If we prefix the name with <kbd>_</kbd>, the compiler won't yell at us about it. Then, when the time comes to actually use it, we remove the <kbd>_</kbd> so we benefit from all of the compiler's checks.</div>
<p>In the previous example, we used <kbd>_</kbd> to match against the error value, meaning we don't care what the error value actually is, as long as it's an error. However, <kbd>_</kbd> can match <em>anything</em>, which means we can also do this:</p>
<pre>    match might_fail(39) {<br/>        Ok(x) =&gt; { println!("Odd succeeded, name is {}", x.name) }<br/>        _ =&gt; { println!("If none of the above patterns match, _ certainly will") }<br/>    }</pre>
<p>Here, the last pattern in our <kbd>match</kbd> is an <kbd>_</kbd>, which matches anything while capturing no data at all. This is very much like putting <kbd>else</kbd> at the end of an <kbd>if</kbd> chain. Any match expression containing an <kbd>_</kbd> pattern automatically covers the entire space of possible values, too, which means that, as long as there <em>is</em> a reasonable fallback action to take when none of the more precise patterns match, Rust won't complain to us that we're not covering all of the possibilities.</p>
<div class="packt_tip">By the way, if we put a plain <kbd>_</kbd> pattern anywhere but at the bottom of the <kbd>match</kbd> expression, Rust will warn us. This is a good thing, because any patterns under it will never, ever get a chance to match.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Moving and borrowing in pattern matches</h1>
                </header>
            
            <article>
                
<p>When we match a pattern that contains variables, the matching data values are moved into the variables (unless their data type has the <kbd>Copy</kbd> trait). For example, this will cause the compiler to report an error, even though at first glance it seems reasonable, especially for people who are used to other programming languages:</p>
<pre>let source5 = DemoStruct { id: 40, name: String::from("A Surprising Thing"), probability: 0.93 };<br/><br/>if let DemoStruct {id: 41, name: x, probability: _} = source5 {<br/>    println!("Extracted name: {}", x);<br/>}<br/><br/>println!("source5.name is {}", source5.name);</pre>
<p>The problem is that, after the <kbd>if let</kbd>, <kbd>source5.name</kbd> does not (or at least might not) contain a value anymore, because that value was moved to the <kbd>x</kbd> variable. The compiler can't be sure that the final <kbd>println!</kbd> command will always be valid, which is a problem because it happens whether the <kbd>if let</kbd> block gets run or not.</p>
<p>Can we borrow the value in <kbd>if let</kbd>, instead of moving it? That way, future uses of the value would still be valid. The answer is yes, but there's a problem we need to get a handle on. We can try this:</p>
<pre>let source5 = DemoStruct { id: 40, name: String::from("A Surprising Thing"), probability: 0.93 };<br/><br/>if let DemoStruct {id: 41, name: &amp;x, probability: _} = source5 {<br/>    println!("Extracted name: {}", x);<br/>}<br/><br/>println!("source5.name is {}", source5.name);</pre>
<p>But what we find is that the compiler complains that it expected <kbd>String</kbd> in the pattern, and found a reference instead. That's because using an <kbd>&amp;</kbd> in the pattern this way doesn't mean we want to borrow the value; it means we expect the value to <em>already be a borrow</em> in the source data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To tell Rust that we want to borrow a value that is matched by a variable in a pattern, we need to use a new keyword: <kbd>ref</kbd>. That looks like this:</p>
<pre>let source5 = DemoStruct { id: 40, name: String::from("A Surprising Thing"), probability: 0.93 };<br/><br/>if let DemoStruct {id: 41, name: ref x, probability: _} = source5 {<br/>    println!("Extracted name: {}", x);<br/>}<br/><br/>println!("source5.name is {}", source5.name);</pre>
<p>At last, the compiler is happy, and so are we. The value in <kbd>source5.name</kbd> is not a borrow, but when we match <kbd>source5</kbd> to our pattern, we borrow it into the <kbd>x</kbd> variable, which means it is <em>not</em> moved out of <kbd>source5</kbd>, and the final <kbd>println!</kbd> will always work.</p>
<p>The <kbd>ref</kbd> keyword and the <kbd>&amp;</kbd> symbol are closely related. These two lines of code do exactly the same thing:</p>
<pre>let ref borrowed1 = source5;<br/>let borrowed2 = &amp;source5;</pre>
<p>The difference between them is syntactic: we apply the <kbd>ref</kbd> keyword to the variable where the borrow <em>will be stored</em>, while we apply the <kbd>&amp;</kbd> symbol to the variable where the value to be borrowed <em>is already stored</em>. We choose which one to use based on which end of the borrow we're writing, and we don't need both.</p>
<p>In fact, using both creates a borrow <em>of a borrow</em> of the original value, which is not usually what we want. The Rust compiler can automatically dereference any number of layers of borrowing in order to find the value it needs for a function parameter, so something like this works fine without causing any errors:</p>
<pre>pub fn borrow_demostruct(x: &amp;DemoStruct) {<br/>    println!("Borrowed {}", x.name);<br/>}</pre>
<pre>let ref borrowed_borrow = &amp;source5;<br/>borrow_demostruct(borrowed_borrow);</pre>
<p>The compiler sees that the <kbd>borrow_demostruct</kbd> function wants a borrow of <kbd>DemoStruct</kbd>, and that the value we're trying to send it is a borrow of a borrow of a <kbd>DemoStruct</kbd>, so it dereferences that value once and passes that to the function parameter. Everything works.</p>
<div class="packt_tip"><em>What does a borrow of a borrow</em> means? Well, first of all, we had a <kbd>DemoStruct</kbd> value. Then, we borrowed it, giving us an <kbd>&amp;DemoStruct</kbd> value. Then, we borrowed <em>that</em> value, giving us an <kbd>&amp;&amp;DemoStruct</kbd> value.</div>
<p>However, the computer had to put in a little more effort than was necessary to achieve the same result. Multiple levels of borrowing should only be used when they solve a problem, because using them when we don't need them is just wasteful.</p>
<p>Also, <kbd>&amp;&amp;DemoStruct</kbd> is not actually the same data type as <kbd>&amp;DemoStruct</kbd>, despite the fact that the Rust compiler can figure out how to treat the former as the latter when it's used as a function parameter. Sometimes, that matters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Matching tuples and other more complex patterns</h1>
                </header>
            
            <article>
                
<p>Matching simple patterns is very useful, but there's more that we can do. Patterns can be more complex, consisting of representations of several layers of nested data structures and other data types. Patterns can assign to a variable name while still looking deeper into the structure to make sure the contained information matches what we want. Or patterns can be simplified, checking only a few parts of the data structure and ignoring the rest.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Nested patterns</h1>
                </header>
            
            <article>
                
<p>We can use pattern matching to pull a value out of a complex data structure. As long as the pattern matches the data value, it doesn't matter how complex the pattern and value are. If we want to match a tuple of tuples and extract one particular value from one of the inner tuples, we can do it like this:</p>
<pre>let (_, (_, x, _, _), _) = ((5, 6, 7), (8, 9, 10, 11), (12, 13, 14, 15));<br/>println!("x is {}", x);</pre>
<p>This pattern matches any tuple of three elements, where the second element is a nested tuple of four elements, and stores the second element of that nested tuple in the <kbd>x</kbd><span> variable</span>, then prints out the value of <kbd>x</kbd>.</p>
<p>We could have been even more specific, and replaced some of those <kbd>_</kbd> with more detailed sub-patterns to match. That would have given us a pattern that paid more attention to the first and/or last elements out the outer tuple, or the other elements of the inner tuple.</p>
<p>We can use the same technique to dig into other data types, too; it's not limited to tuples. For example, earlier we used pattern matching to check whether a function had succeeded or failed to run properly:</p>
<pre>match might_fail(39) {<br/>    Ok(x) =&gt; { println!("Odd succeeded, name is {}", x.name) }<br/>    Err(_) =&gt; { println!("Odd failed! Woe is me.") }<br/>}</pre>
<p class="mce-root">In that code, we just match the success value to the <kbd>x</kbd><span> </span><span>variable</span><span>, but what if we wanted to handle things differently depending on the details of the success value? We can do that by making the contained value match a more detailed sub-pattern:</span></p>
<pre>match might_fail(38) {<br/>    Ok(DemoStruct {id: 38, name: ref name, probability: _}) =&gt; {<br/>        println!("Even succeeded with the proper id: name is {}", name)<br/>    }<br/>    Ok(DemoStruct {id: ref id, name: ref name, probability: _}) =&gt; {<br/>        println!("Even succeeded with the wrong id: id is {}, name is {}", id, name)<br/>    }<br/>    Err(_) =&gt; { println!("Even failed! Woe is me.") }<br/>}</pre>
<p>Here, we have a pattern that matches when the function returns a success <em>and</em> the success values is a <kbd>DemoStruct</kbd> with the proper ID, a second pattern that matches when the function return a success and the success value is a <kbd>DemoStruct</kbd> no matter what the ID is, and a third pattern that matches any error the function might return.</p>
<p>The first pattern matches the expected case. If it doesn't match, the second pattern matches, allowing us to deal with an unexpected result that is still technically reported as a success. If neither of those patterns match, the third one handles explicit errors.</p>
<div class="packt_tip">If we compile this example, it works fine, but the compiler warns us that the <kbd>name:</kbd> in the first pattern and the <kbd>id:</kbd> and <kbd>name:</kbd> in the second pattern are redundant. That's because, when we are initializing a data structure or data structure pattern in Rust, we can leave out the destination name if it's the same as the source name. In other words, the second pattern could have been written like <kbd><span>Ok(DemoStruct {ref id, ref name, probability: _})</span></kbd> and Rust still would have understood it, because <kbd>id</kbd> and <kbd>name</kbd> are the names of two of the structure's contained variables. The redundancy warning is just telling us that we wrote more than we needed to.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storing a matched value and comparing it to a pattern</h1>
                </header>
            
            <article>
                
<p>Normally, we either use a variable name to match part of a data value, or we use a structural pattern to check that it's the right "shape" and use variable names inside that structural pattern to match and extract the parts of it we're interested in.</p>
<p>We can do both at the same time, though, by using the <kbd>@</kbd> symbol:</p>
<pre>if let (1, x @ (_, _), _) = (1, (2, 3), (4, 5, 6)) {<br/>    println!("matched x to {:?}", x);<br/>}</pre>
<p>So, here we have a pattern that matches a 3-tuple that has <kbd>1</kbd> as its first item, a 2-tuple as its second item, and anything as its third item, and stores the second item (which it has confirmed is a 2-tuple) in a variable called <kbd>x</kbd>. The variable name to store into came before the <kbd>@</kbd>, and the pattern to check the match against came after.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ignoring most of a data structure</h1>
                </header>
            
            <article>
                
<p>Some data structures contains a great many data values, and it would be inconvenient to have to go through and list each one of them in each pattern we want to match against. Fortunately, Rust has a shorthand syntax that means <em>everything else is a don't care.</em></p>
<p>To do that, we can include <kbd>..</kbd> at the end of the pattern, like so:</p>
<pre>if let DemoStruct {id: 40, ..} = source5 {<br/>    println!("id is 40, don't care about the rest");<br/>}</pre>
<p>That has the same effect as listing out all of the structure's contained variables, <em>except</em> the ones we've explicitly described in the pattern, and matching each one to an <kbd>_</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gotchas</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are some seemingly reasonable things we might try to do with pattern matching that don't work as we might expect. We're going to take a look at those, and work out what they're actually doing and why Rust works that way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Not all values can be matched against a literal pattern</h1>
                </header>
            
            <article>
                
<p>In all of our examples so far, when we matched <kbd>DemoStruct</kbd> in a pattern, we matched <kbd>probability</kbd> to a variable or to <kbd>_</kbd>. That's because <kbd>probability</kbd> is a floating point number, which means that two values that are functionally identical might not compare as exactly equal. </p>
<p>If we try to use a floating-point literal in a pattern (in Rust 1.29), we see a warning like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d802e4d9-ae92-440e-be76-4bd0f24fff56.png" width="1339" height="185"/></p>
<p>It's just a warning but, as the warning says, it's going to become an error as Rust evolves. We should treat it as an error, regardless, because the pattern will likely not work properly even though it (currently) compiles.</p>
<p>The reason for that, in this case, is that floating point numbers are approximate. They have to fit into a finite number of bits, so they have to be rounded sometimes. That can result in numbers that should be identical in a purely mathematical sense being different because their representations differ in the least significant bits. The least significant bits usually make such a tiny difference that rounding errors don't much matter, but they can throw off an equality comparison.</p>
<p>The upshot is that if we try to use a literal in a pattern that isn't safe to use, Rust will warn us or give us an error. As usual, Rust isn't willing to let a potential problem go unremarked.</p>
<p>If we need to do something like this, we can use match guards to work around the limitation. We're about to learn about them, so keep reading!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Patterns assign values to variable names</h1>
                </header>
            
            <article>
                
<p>When we use a variable name in a pattern, it matches any value and the matched value is stored in the variable. That means that if we were to try this:</p>
<pre>let x = 5;<br/>let source6 = DemoStruct {id: 7, name: String::from("oops"), probability: 0.26};<br/>if let DemoStruct { id: x, name: _, probability: _ } = source6 {<br/>    println!("The pattern matched, x is {}", x);<br/>}</pre>
<p>We do not get a pattern that compares the <kbd>source6.id</kbd> value to the value of <kbd>x</kbd> (five in this case), we don't get what we expect.</p>
<p>Instead, we get an error saying that the pattern is irrefutable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/26141fa5-0377-47e6-b6f0-27d06a006fe6.png" width="836" height="231"/></p>
<div class="packt_tip">Irrefutable <span>means the pattern will never fail to match, which is a problem in an </span><kbd>if let</kbd> expression.</div>
<p>If we try a similar pattern that it is refutable, but still uses the <kbd>x</kbd> variable, the program compiles, but the pattern matches when we didn't want it to:</p>
<pre>let x = 5;<br/>let source6 = DemoStruct {id: 7, name: String::from("oops"), probability: 0.26};<br/>if let DemoStruct { id: 7, name: x, probability: _ } = source6 {<br/>    println!("The pattern matched, x is {}", x);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Both of these situations arise because of a rule we already talked about: variable names used in patterns match any value, and store the matched value into a new variable with the given name. If we think about it, that implies that if there's already a variable with that name, its current value doesn't matter.</p>
<p>That doesn't mean we're entirely out of luck, though. We can use an extension of the <kbd>match</kbd> syntax to involve existing variables in the decision:</p>
<pre>let x = 5;<br/>let source7 = DemoStruct {id: 7, name: String::from("oops"), probability: 0.26};<br/>match source7 {<br/>    DemoStruct { id: y, name: _, probability: _ } if y == x =&gt; {<br/>        println!("The pattern with match guard matched, y is {}", y);<br/>    }<br/>    _ =&gt; {<br/>        println!("The pattern with match guard did not match")<br/>    }<br/>}</pre>
<p>What we're doing here is applying a <strong>match guard</strong> to the pattern. We do that by putting the <kbd>if</kbd> keyword after the pattern, but before the <kbd>=&gt;</kbd>, and following it up with a Boolean expression. This lets us add non-pattern matching criteria to a match branch. In this case, we're saying that if the pattern matches and the ID (stored in <kbd>y</kbd>) matches the value stored in <kbd>x</kbd>, we should run that block of code.</p>
<div class="packt_infobox">There has been talk of creating a similar feature for <kbd>if let</kbd>, but mostly people just use nested <kbd>if</kbd> expressions or <kbd>match</kbd>.</div>
<p class="mce-root">When we use a match guard, we need to be especially careful that our pattern doesn't shadow any variable names we want to use in the guard. That's why, in this example, we matched the <kbd>id</kbd><span> of </span><kbd>DemoStruct</kbd><span> </span><span>to a variable named</span> <kbd>y</kbd> <span>instead of</span> <kbd>x</kbd><span>. We needed to keep</span> <kbd>x</kbd> <span>around so our match guard could use it.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've seen how to use pattern patching to enhance our ability to make decisions and assign variables. In particular, we've learned the following:</p>
<ul>
<li>How to assign <em>part</em> of a data value to a variable by matching the whole value to a pattern that matches the part we're interested in to a variable name</li>
<li>How to use <kbd>if let</kbd> and <kbd>else if let</kbd> to decide whether a particular branch of an <kbd>if</kbd> chain should run</li>
<li>How to use <kbd>match</kbd> to check a single value against multiple patterns</li>
<li>How to use <kbd>_</kbd> as a <em>don't care</em> in patterns</li>
<li>The difference between a pattern that matches a borrowed value and a pattern that borrows a matched value</li>
<li>How to match patterns for complex, nested data structures</li>
<li>Surprises that can arise when we use pattern matching, and how to deal with them</li>
</ul>
<p>We'll be seeing more pattern matching in the next chapter, when we look at enumerations, traits, and trait objects.</p>


            </article>

            
        </section>
    </div>



  </body></html>