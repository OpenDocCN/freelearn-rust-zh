["```rs\n[package]\nname = \"elevator\"\nversion = \"1.0.0\"\n\n[dependencies]\n```", "```rs\nfn main()\n{\n   println!(\"main\")\n}\n```", "```rs\npub fn run_simulation()\n{\n\n   //1\\. Store location, velocity, and acceleration state\n   let mut location: f64 = 0.0; // meters\n   let mut velocity: f64 = 0.0; // meters per second\n   let mut acceleration: f64 = 0.0; // meters per second squared\n\n   //2\\. Store motor input voltage\n   let mut up_input_voltage: f64 = 0.0;\n   let mut down_input_voltage: f64 = 0.0;\n\n   //3\\. Store input building description and floor requests\n   let mut floor_count: u64 = 0;\n   let mut floor_height: f64 = 0.0; // meters\n   let mut floor_requests: Vec<u64> = Vec::new();\n\n   //4\\. Parse input and store as building description and floor requests\n\n   //5\\. Loop while there are remaining floor requests\n   while floor_requests.len() > 0\n   {\n      //5.1\\. Update location, velocity, and acceleration\n\n      //5.2\\. If next floor request in queue is satisfied, then remove from queue\n\n      //5.3\\. Adjust motor control to process next floor request\n\n      //5.4\\. Print realtime statistics\n   }\n\n   //6\\. Print summary\n   println!(\"summary\");\n}\n\nfn main()\n{\n   run_simulation()\n}\n```", "```rs\nfn process_floor_requests(...)\n{\n   if floor_requests.len() == 0 { return; }\n\n   //5.1 Update location, velocity, and acceleration\n\n   //5.2 If next floor request in queue is satisfied, then remove from queue\n\n   //5.3 Adjust motor control to process next floor request\n\n   //5.4 Print realtime statistics\n\n   //tail recursion\n   process_floor_requests(...)\n}\n```", "```rs\nlet buffer = match env::args().nth(1) {\n   Some(ref fp) if *fp == \"-\".to_string()  => {\n      let mut buffer = String::new();\n      io::stdin().read_to_string(&mut buffer)\n                 .expect(\"read_to_string failed\");\n      buffer\n   },\n   None => {\n      let fp = \"test1.txt\";\n      let mut buffer = String::new();\n      File::open(fp)\n         .expect(\"File::open failed\")\n         .read_to_string(&mut buffer)\n         .expect(\"read_to_string failed\");\n         buffer\n   },\n   Some(fp) => {\n      let mut buffer = String::new();\n      File::open(fp)\n         .expect(\"File::open failed\")\n         .read_to_string(&mut buffer)\n         .expect(\"read_to_string failed\");\n      buffer\n   }\n};\n\n```", "```rs\nfor (li,l) in buffer.lines().enumerate() {\n   if li==0 {\n      floor_count = l.parse::<u64>().unwrap();\n   } else if li==1 {\n      floor_height = l.parse::<f64>().unwrap();\n   } else {\n      floor_requests.push(l.parse::<u64>().unwrap());\n   }\n}\n```", "```rs\nlet mut prev_loop_time = Instant::now();\n```", "```rs\nlet now = Instant::now();\nlet dt = now.duration_since(prev_loop_time)\n            .as_fractional_secs();\nprev_loop_time = now;\n```", "```rs\nthread::sleep(time::Duration::from_millis(10));\n```", "```rs\nlocation = location + velocity * dt;\nvelocity = velocity + acceleration * dt;\nacceleration = {\n   let F = (up_input_voltage - down_input_voltage) * 8.0;\n   let m = 1200000.0;\n   //-9.8 is an approximation of acceleration due to gravity\n   -9.8 + F/m\n};\n```", "```rs\nlet next_floor = floor_requests[0];\nif (location - (next_floor as f64)*floor_height).abs() < 0.01\n   && velocity.abs() < 0.01\n{\n   velocity = 0.0;\n   floor_requests.remove(0);\n}\n```", "```rs\n//it will take t seconds to decelerate from velocity v at -1 m/s^2\nlet t = velocity.abs() / 1.0;\n\n//during which time, the carriage will travel d=t * v/2 meters\n//at an average velocity of v/2 before stopping\nlet d = t * (velocity/2.0);\n\n//l = distance to next floor\nlet l = (location - (next_floor as f64)*floor_height).abs();\n\n```", "```rs\nlet target_acceleration = {\n   //are we going up?\n   let going_up = location < (next_floor as f64)*floor_height;\n\n   //Do not exceed maximum velocity\n   if velocity.abs() >= 5.0 {\n      //if we are going up and actually going up\n      //or we are going down and actually going down\n      if (going_up && velocity>0.0)\n      || (!going_up && velocity<0.0) {\n         0.0\n      //decelerate if going in wrong direction\n      } else if going_up {\n         1.0\n      } else {\n         -1.0\n      }\n\n   //if within comfortable deceleration range and moving in right direction, decelerate\n   } else if l < d && going_up==(velocity>0.0) {\n      if going_up {\n         -1.0\n      } else {\n         1.0\n      }\n\n   //else if not at peak velocity, accelerate\n   } else {\n      if going_up {\n         1.0\n      } else {\n         -1.0\n      }\n   }\n};\n```", "```rs\nlet gravity_adjusted_acceleration = target_acceleration + 9.8;\nlet target_force = gravity_adjusted_acceleration * 1200000.0;\nlet target_voltage = target_force / 8.0;\nif target_voltage > 0.0 {\n   up_input_voltage = target_voltage;\n   down_input_voltage = 0.0;\n} else {\n   up_input_voltage = 0.0;\n   down_input_voltage = target_voltage.abs();\n};\n```", "```rs\nlet termsize = termion::terminal_size().ok();\nlet termwidth = termsize.map(|(w,_)| w-2).expect(\"termwidth\");\nlet termheight = termsize.map(|(_,h)| h-2).expect(\"termheight\");\nlet mut _stdout = io::stdout(); //lock once, instead of once per write\nlet mut stdout = _stdout.lock().into_raw_mode().unwrap();\n```", "```rs\nprint!(\"{}{}\", clear::All, cursor::Goto(1, 1));\nfor tx in 0..(termwidth-1)\n{\n   for ty in 0..(termheight-1)\n   {\n      write!(stdout, \"{}\", cursor::Goto(tx+1, ty+1));\n      write!(stdout, \"{}\", \" \");\n   }\n}\n```", "```rs\nprint!(\"{}{}{}\", clear::All, cursor::Goto(1, 1), cursor::Hide);\nlet carriage_floor = (location / floor_height).floor() as u64;\nlet carriage_floor = cmp::max(carriage_floor, 0);\nlet carriage_floor = cmp::min(carriage_floor, floor_count-1);\nfor tx in 0..(termwidth-1)\n{\n   for ty in 0..(termheight-1)\n   {\n      write!(stdout, \"{}\", cursor::Goto(tx+1, ty+1));\n      if tx==0 && (ty as u64)<floor_count {\n         write!(stdout, \"{}\", \"[\");\n      } else if tx==1 && (ty as u64)==((floor_count-1)-carriage_floor) {\n         write!(stdout, \"{}\", \"X\");\n      } else if tx==2 && (ty as u64)<floor_count {\n         write!(stdout, \"{}\", \"]\");\n      } else {\n         write!(stdout, \"{}\", \" \");\n      }\n   }\n}\nstdout.flush().unwrap();\n```", "```rs\nwrite!(stdout, \"{}\", cursor::Goto(6, 1));\nwrite!(stdout, \"Carriage at floor {}\", carriage_floor+1);\nwrite!(stdout, \"{}\", cursor::Goto(6, 2));\nwrite!(stdout, \"Location          {}\", location);\nwrite!(stdout, \"{}\", cursor::Goto(6, 3));\nwrite!(stdout, \"Velocity          {}\", velocity);\nwrite!(stdout, \"{}\", cursor::Goto(6, 4));\nwrite!(stdout, \"Acceleration      {}\", acceleration);\nwrite!(stdout, \"{}\", cursor::Goto(6, 5));\nwrite!(stdout, \"Voltage [up-down] {}\", up_input_voltage-down_input_voltage);\n```", "```rs\nlet mut terminal_buffer = vec![' ' as u8; (termwidth*termheight) as usize];\nfor ty in 0..floor_count\n{\n   terminal_buffer[ (ty*termwidth + 0) as usize ] = '[' as u8;\n   terminal_buffer[ (ty*termwidth + 1) as usize ] =\n      if   (ty as u64)==((floor_count-1)-carriage_floor) { 'X' as u8 }\n      else { ' ' as u8 };\n   terminal_buffer[ (ty*termwidth + 2) as usize ] = ']' as u8;\n   terminal_buffer[ (ty*termwidth + termwidth-2) as usize ] = '\\r' as u8;\n   terminal_buffer[ (ty*termwidth + termwidth-1) as usize ] = '\\n' as u8;\n}\nlet stats = vec![\n   format!(\"Carriage at floor {}\", carriage_floor+1),\n   format!(\"Location          {}\", location),\n   format!(\"Velocity          {}\", velocity),\n   format!(\"Acceleration      {}\", acceleration),\n   format!(\"Voltage [up-down] {}\", up_input_voltage-down_input_voltage)\n];\nfor sy in 0..stats.len()\n{\n   for (sx,sc) in stats[sy].chars().enumerate()\n   {\n      terminal_buffer[ sy*(termwidth as usize) + 6 + sx ] = sc as u8;\n   }\n}\nwrite!(stdout, \"{}\", String::from_utf8(terminal_buffer).unwrap()); \n```", "```rs\nlet mut record_location = Vec::new();\nlet mut record_velocity = Vec::new();\nlet mut record_acceleration = Vec::new();\nlet mut record_voltage = Vec::new();\n```", "```rs\nrecord_location.push(location);\nrecord_velocity.push(velocity);\nrecord_acceleration.push(acceleration);\nrecord_voltage.push(up_input_voltage-down_input_voltage);\n```", "```rs\nlet record_location_N = record_location.len();\nlet record_location_sum: f64 = record_location.iter().sum();\nlet record_location_avg = record_location_sum / (record_location_N as f64);\nlet record_location_dev = (\n   record_location.clone().into_iter()\n   .map(|v| (v - record_location_avg).powi(2))\n   .fold(0.0, |a, b| a+b)\n   / (record_location_N as f64)\n).sqrt();\n\nlet record_velocity_N = record_velocity.len();\nlet record_velocity_sum: f64 = record_velocity.iter().sum();\nlet record_velocity_avg = record_velocity_sum / (record_velocity_N as f64);\nlet record_velocity_dev = (\n   record_velocity.clone().into_iter()\n   .map(|v| (v - record_velocity_avg).powi(2))\n   .fold(0.0, |a, b| a+b)\n   / (record_velocity_N as f64)\n).sqrt();\n\nlet record_acceleration_N = record_acceleration.len();\nlet record_acceleration_sum: f64 = record_acceleration.iter().sum();\nlet record_acceleration_avg = record_acceleration_sum / (record_acceleration_N as f64);\nlet record_acceleration_dev = (\n   record_acceleration.clone().into_iter()\n   .map(|v| (v - record_acceleration_avg).powi(2))\n   .fold(0.0, |a, b| a+b)\n   / (record_acceleration_N as f64)\n).sqrt();\n\nlet record_voltage_N = record_voltage.len();\nlet record_voltage_sum = record_voltage.iter().sum();\nlet record_voltage_avg = record_voltage_sum / (record_voltage_N as f64);\nlet record_voltage_dev = (\n   record_voltage.clone().into_iter()\n   .map(|v| (v - record_voltage_avg).powi(2))\n   .fold(0.0, |a, b| a+b)\n   / (record_voltage_N as f64)\n).sqrt();\n```", "```rs\nwrite!(stdout, \"{}{}{}\", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();\n\nwrite!(stdout, \"Average of location                 {:.6}\\r\\n\", record_location_avg);\nwrite!(stdout, \"Standard deviation of location      {:.6}\\r\\n\", record_location_dev);\nwrite!(stdout, \"\\r\\n\");\n\nwrite!(stdout, \"Average of velocity                 {:.6}\\r\\n\", record_velocity_avg);\nwrite!(stdout, \"Standard deviation of velocity      {:.6}\\r\\n\", record_velocity_dev);\nwrite!(stdout, \"\\r\\n\");\n\nwrite!(stdout, \"Average of acceleration             {:.6}\\r\\n\", record_acceleration_avg);\nwrite!(stdout, \"Standard deviation of acceleration  {:.6}\\r\\n\", record_acceleration_dev);\nwrite!(stdout, \"\\r\\n\");\n\nwrite!(stdout, \"Average of voltage                  {:.6}\\r\\n\", record_voltage_avg);\nwrite!(stdout, \"Standard deviation of voltage       {:.6}\\r\\n\", record_voltage_dev);\nwrite!(stdout, \"\\r\\n\");\n\nstdout.flush().unwrap();\n```", "```rs\nfn variable_summary<W: Write>(stdout: &mut raw::RawTerminal<W>, vname: &str, data: Vec<f64>)\n{\n   //calculate statistics\n   let N = data.len();\n   let sum: f64 = data.iter().sum();\n   let avg = sum / (N as f64);\n   let dev = (\n      data.clone().into_iter()\n      .map(|v| (v - avg).powi(2))\n      .fold(0.0, |a, b| a+b)\n      / (N as f64)\n   ).sqrt();\n\n   //print formatted output\n   write!(stdout, \"Average of {:25}{:.6}\\r\\n\", vname, avg);\n   write!(stdout, \"Standard deviation of {:14}{:.6}\\r\\n\", vname, dev);\n   write!(stdout, \"\\r\\n\");\n}\n```", "```rs\nwrite!(stdout, \"{}{}{}\", clear::All, cursor::Goto(1, 1), cursor::Show).unwrap();\nvariable_summary(&mut stdout, \"location\", record_location);\nvariable_summary(&mut stdout, \"velocity\", record_velocity);\nvariable_summary(&mut stdout, \"acceleration\", record_acceleration);\nvariable_summary(&mut stdout, \"voltage\", record_voltage);\nstdout.flush().unwrap();\n```", "```rs\nlet N = data.len();\nlet sum: f64 = data.iter().sum();\nlet avg = sum / (N as f64);\nlet dev = (\n   data.clone().into_iter()\n   .map(|v| (v - avg).powi(2))\n   .fold(0.0, |a, b| a+b)\n   / (N as f64)\n).sqrt();\n\n```", "```rs\nstruct Fibonacci\n{\n curr: u32,\n next: u32,\n}\n\nimpl Iterator for Fibonacci\n{\n   type Item = u32;\n   fn next(&mut self) -> Option<u32>\n   {\n      let new_next = self.curr + self.next;\n      self.curr = self.next;\n      self.next = new_next;\n      Some(self.curr) //infinite list, never None\n   }\n}\n\nfn fibonacci() -> Fibonacci\n{\n   Fibonacci { curr: 1, next: 1 }\n}\n```", "```rs\nlet N = data.len();\nlet mut sum = 0.0;\nfor di in 0..data.len()\n{\n   sum += data[di];\n}\nlet avg = sum / (N as f64);\nlet mut dev = 0.0;\nfor di in 0..data.len()\n{\n   dev += (data[di] - avg).powi(2);\n}\ndev = (dev / (N as f64)).sqrt();\n```", "```rs\nfn variable_summary<W: Write>(stdout: &mut raw::RawTerminal<W>, vname: &str, data: Vec<f64>)\n{\n   let (avg, dev) = variable_summary_stats(data);\n   variable_summary_print(stdout, vname, avg, dev);\n}\n\nfn variable_summary_stats(data: Vec<f64>) -> (f64, f64)\n{\n   //calculate statistics\n   let N = data.len();\n   let sum: f64 = data.iter().sum();\n   let avg = sum / (N as f64);\n   let dev = (\n      data.clone().into_iter()\n      .map(|v| (v - avg).powi(2))\n      .fold(0.0, |a, b| a+b)\n      / (N as f64)\n   ).sqrt();\n   (avg, dev)\n}\n\nfn variable_summary_print<W: Write>(stdout: &mut raw::RawTerminal<W>, vname: &str, avg: f64, dev: f64)\n{\n   //print formatted output\n   write!(stdout, \"Average of {:25}{:.6}\\r\\n\", vname, avg);\n   write!(stdout, \"Standard deviation of {:14}{:.6}\\r\\n\", vname, dev);\n   write!(stdout, \"\\r\\n\");\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n   use super::*;\n\n   #[test]\n   fn variable_stats() {\n      let test_data = vec![\n         (vec![1.0, 2.0, 3.0, 4.0, 5.0], 3.0, 1.41),\n         (vec![1.0, 3.0, 5.0, 7.0, 9.0], 5.0, 2.83),\n         (vec![1.0, 9.0, 1.0, 9.0, 1.0], 4.2, 3.92),\n         (vec![1.0, 0.5, 0.7, 0.9, 0.6], 0.74, 0.19),\n         (vec![200.0, 3.0, 24.0, 92.0, 111.0], 86.0, 69.84),\n      ];\n      for (data, avg, dev) in test_data\n      {\n         let (ravg, rdev) = variable_summary_stats(data);\n         //it is not safe to use direct == operator on floats\n         //floats can be *very* close and not equal\n         //so instead we check that they are very close in value\n         assert!( (avg-ravg).abs() < 0.1 );\n         assert!( (dev-rdev).abs() < 0.1 );\n      }\n   }\n}\n```", "```rs\nextern crate elevator;\n\nfn main()\n{\n   elevator::run_simulation();\n}\n```", "```rs\nextern crate elevator;\nextern crate timebomb;\nuse timebomb::timeout_ms;\n\n#[test]\nfn test_main() {\n   timeout_ms(|| {\n      elevator::run_simulation();\n   }, 300000);\n}\n```", "```rs\n5\n5.67\n2\n1\n4\n0\n3\n1\n0\n```", "```rs\n[ ]   Carriage at floor 1\n[ ]   Location          2.203829\n[ ]   Velocity          -2.157214\n[ ]   Acceleration      1.000000\n[X]   Voltage [up-down] 1620000.000000\n\n[ ]   Carriage at floor 3\n[ ]   Location          11.344785\n[X]   Velocity          0.173572\n[ ]   Acceleration      -1.000000\n[ ]   Voltage [up-down] 1320000.000000\n\n[ ]   Carriage at floor 4\n[X]   Location          19.235710\n[ ]   Velocity          2.669347\n[ ]   Acceleration      -1.000000\n[ ]   Voltage [up-down] 1320000.000000\n\n[ ]   Carriage at floor 1\n[ ]   Location          0.133051\n[ ]   Velocity          0.160799\n[ ]   Acceleration      -1.000000\n[X]   Voltage [up-down] 1320000.000000\n```", "```rs\nAverage of location                 5.017036\nStandard deviation of location      8.813507\n\nAverage of velocity                 -0.007597\nStandard deviation of velocity      2.107692\n\nAverage of acceleration             0.000850\nStandard deviation of acceleration  0.995623\n\nAverage of voltage                  1470109.838195\nStandard deviation of voltage       149352.287579\n\ntest test_main ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\nrunning 1 test\ntest tests::variable_stats ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```"]