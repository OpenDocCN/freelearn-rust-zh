- en: Code Organization and Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we outlined some basic concepts of project planning and code architecture.
    The strategy we recommended specifically called for gathering and listing requirements
    before adapting them into pseudocode, stub code, and eventually a completed project.
    This process is still very applicable to larger projects, but we have not covered
    the aspect of file and module organization. How should code be grouped into files
    and modules?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we recommend something called **the workshop model**.
    Imagine a physical workshop with pegboards, shelves, jars, toolboxes, and larger
    equipment on the floor. When speaking about code architecture, experts often talk
    about different organizational strategies. It is possible to group code by type,
    by purpose, by project layer, or by convenience. There are infinite possible strategies,
    and these are just four common ones. None of these are wrong, though we recommend
    against choosing any one specifically. Our reason is simple—choose all of them.
    Nuts and bolts can be organized into jars (by type). Hand tools can be placed
    in a toolbox (by purpose). Large tools can be placed on the floor (by project
    layer). Common tools can be hung on a pegboard (by convenience). None of these
    strategies are invalid, and all of them can be used in the same workshop (project).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will reorganize the project as it grows. We will combine
    the principles of planning and architecture that we previously introduced with
    new concepts of code organization to develop a large software project that is
    navigable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The learning outcomes of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing and applying by type organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing and applying by purpose organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing and applying by layer organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing and applying by convenience organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing code waste during project reorganization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Shipping a product without sacrificing quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client has finished negotiating with your sales team—you won the contract.
    Now that the contract is signed, your team is on task to bring the simulation
    up to specification to run all of the elevator systems. The client has provided
    specifications for each of the three buildings, elevators, motor control, and
    braking systems. You also learn that the elevator motors have intelligent motor
    control software that regulates internal voltage and current dynamically. To control
    the motor, you will only be expected to supply the desired force output. The full
    specifications are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For building 1, there are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floor heights**: 8m, 4m, 4m, 4m, 4m'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator weight**: 1,200 kg'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator motor**: Maximum 50,000 N'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator driver**: Software interface supplied'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For building 2, there are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floor heights**: 5m, 5m, 5m, 5m, 5m, 5m, 5m, 5m'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator weight**: 1,350 kg'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator motor**: maximum 1,00,000 N'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator driver**: Software interface supplied'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For building 3, there are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floor heights**: 6m, 4m, 4m, 4m'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator weight**: 1,400 kg'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator motor**: Maximum 90,000 N'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevator driver**: Software interface supplied'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The program now needs to work in operational mode, where new floor requests
    are accepted and added to the queue. The simulation should also continue to work,
    now with all three building specifications. The simulation should verify that
    promised performance and quality metrics are all satisfied. Other than that, your
    team is free to develop the project as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: You decide that now is a good time to rethink the organization of the project,
    with significant new changes required. Using good architecture and project organization
    practices, you will move code around accordingly to group components orderly and
    conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: Reorganizing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have some ideas of good project architecture, let''s plan the project''s
    reorganization. Let''s list the possible workshop organization methods:'
  prefs: []
  type: TYPE_NORMAL
- en: By type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By convenience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The by type organization should be used for workshop nuts and bolts type components.
    Nuts and bolts are highly uniform components that have a different diameter, length,
    grade, and so on. We have a few good matches here, so let''s list objects and
    interfaces that could be grouped this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator controllers/drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The by purpose organization should be used for miscellaneous tools that have
    a common purpose. We have some good candidates for this style of organization,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: Transport planning (static/dynamic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physical interface to an elevator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The by layer organization should be used for distinct architectural components
    that fit well within normal program logic. An example of this would be our physics
    layer, which is logically independent of other modules. The physics layer exists
    solely to store constants, formulas, and modeling procedures. Here, we group this
    by layer:'
  prefs: []
  type: TYPE_NORMAL
- en: Physics modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The by convenience organization should be used for common or difficult components.
    Executables are a good fit for this type of organization because they are always
    an endpoint, not a library, and don''t typically fit into any other organization
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulation executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical elevator driver executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning content of files by type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by type method.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the motor_controllers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All motors will be grouped by type in the `motor_controller.rs` module. There
    will be three motors with varying properties. This module should provide a trait
    interface to all motors as well as each implementation. The trait should define
    a method to generate a motor input from the desired force output and also a method
    to accept a motor input to generate a force. The module must also link in the
    binary drivers for each motor controller. The old motor controller logic to dynamically
    control the elevator motor will be moved into a new file called `motion_controllers.rs`.
    The following should be defined in this module:'
  prefs: []
  type: TYPE_NORMAL
- en: Motor input trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor controller trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor input 1 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor controller 1 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor input 2 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor controller 2 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor input 3 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor controller 3 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the buildings.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All building specifications will be grouped by type in the `building.rs` module.
    There will be three building specifications. The building should encapsulate all
    aspects of elevator behavior and control, as well as a specification for the building
    itself. The module should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Building trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building 1 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building 2 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building 3 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning content of files by purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by purpose method.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the motion_controllers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Motion controllers will be organized by purpose. The motion controllers will
    be responsible for tracking elevator state to control the motor''s dynamics. The
    motion controllers module should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Motion Controller trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smooth Motion Controller implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the trip_planning.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trip planning will be organized by purpose. The planner should work in two
    modes: static and dynamic. For static mode, the planner should accept a list of
    floor requests to process. For dynamic mode, the planner should accept floor requests
    as they come dynamically and add them to the queue. The planner module should
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Planner trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static planner implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic planner implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the elevator_drivers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All elevator drivers will be organized by purpose in the `elevator_driver.rs`
    module. There are three elevator drivers that provide binary interfaces to be
    linked. The `elevator driver` module should contain a trait to define an interface
    to elevator drivers as well as the three implementations. The `planner` module
    should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Elevator driver trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator driver 1 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator driver 2 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator driver 3 implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning content of files by layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by layer method.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the physics.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `physics` module will group all physics-related code by layer. There will
    be miscellaneous code here, though it should all fit in the form of some sort
    of simulation or prediction. The module should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formula implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other logic required for the simulation or operation of elevators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics simulation loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the data_recorder.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data recorder module will move the `DataRecorder` trait and implementation
    into its own module. It should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `DataRecorder` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple data recorder implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the content of files by convenience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by convenience method.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the simulate_trip.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `simulate_trip.rs` executable will be organized by convenience. The scope
    of the trip simulation executable has not changed significantly. This file should
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument and input parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data logger definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulation setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the analyze_trip.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `analyze_trip.rs` executable will be organized by convenience. The scope
    of the analyze trip executable has not changed significantly. This file should
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument and input parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check specifications for acceptance or rejection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the operate_elevator.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `operate_elevator.rs` executable will be organized by convenience. The
    operate elevator executable should closely resemble the simulate elevator executable
    logic. This file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument and input parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup elevator drivers to match specified building code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the elevator with dynamic planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping code changes and additions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have organized our concepts, data structures, and logic into files,
    we can now proceed with the normal process to transform requirements into code.
    For each module, we will look at the required elements and produce code to satisfy
    those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we break down all code development steps by module. Different modules
    have different organizations, so pay attention for patterns regarding organization
    and code development.
  prefs: []
  type: TYPE_NORMAL
- en: Developing code by type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by type method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the motor_controllers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new `motor_controller` module serves as an adapter to all of the linked
    motor drivers and their interfaces, and provides a single uniform interface. Let''s
    see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s link all the drivers from the software provided into our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This section tells our program to link to statically compiled libraries named
    something like `libmotor1.a`, `libmotor2.a`, and `libmotor3.a`. Our example chapter
    also contains the source and build script for these libraries, so you can inspect
    each one. In a full project, there are many ways to link to an external binary
    library, this being only one of many options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should make a trait for `MotorInput` and a generic `MotorDriver` interface,
    including implementations for each motor. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should implement the motor controller trait and implementations. The
    motor controller should wrap motor information and drivers into a uniform interface.
    The `MotorDriver` and `MotorController` trait here are coerced into a simple upward/downward
    force model. Therefore, the relation between driver and controller is one-to-one
    and cannot be completely abstracted into a common trait. The code for it is as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The entire code for these is present in the GitHub repository at: [https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST).
  prefs: []
  type: TYPE_NORMAL
- en: Writing the buildings.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The building module is again grouped by type. There should be a common trait
    interface that is implemented by the three buildings. The building traits and
    structures should additionally wrap and expose interfaces to appropriate elevator
    drivers and motor controllers. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `Building` trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a `deserialize` helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define some miscellaneous helper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the buildings and their trait implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Developing code by purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by purpose method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the motion_controllers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The old logic from `motor_controllers.rs` for dynamically adjusting motor force
    will be moved to this module. The `SmoothMotionController` does not change much
    and the code becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Writing the trip_planning.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trip planner should work in static and dynamic modes. The basic structure
    is a FIFO queue, pushing requests into the queue, and popping the oldest element.
    We may be able to unify both static and dynamic modes into a single implementation,
    which would look like the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trip planning will be organized by purpose. The planner should work in two
    modes—static and dynamic. For static mode, the planner should accept a list of
    floor requests to process. For dynamic mode, the planner should accept floor requests
    as they come dynamically and add them to the queue. The planner module should
    contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing the elevator_drivers.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elevator drivers module should interface with the static libraries provided
    and additionally provide a common interface to all elevator drivers. The code
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Developing code by layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by layer method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the physics.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The physics module has become much smaller. It now contains a few struct definitions
    and constants and the central `simulate_elevator` method. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writing the data_recorders.rs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To separate responsibilities and not let individual modules get too big, we
    should move the data recorder implementation out of the simulation and into its
    own module. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `DataRecorder` trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `SimpleDataRecorder` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `SimpleDataRecorder` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `SimpleDataRecorder` implementation of the `DataRecorder` trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the miscellaneous helper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Developing code by convenience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These files will be organized using the by convenience method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the simulate_trip.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simulate trip changes quite a bit because the `DataRecorder` logic has
    been removed. The initialization of the simulation is also very different from
    before. The end result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize `ElevatorState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the building description and floor requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the input and store it as building description and floor requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the data recorder and motion controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the elevator simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the simulation summary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Writing the analyze_trip.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The analyze trip executable will only change a little bit, but only to accommodate
    symbols that have been moved and types that are now serializable with SerDe. The
    result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Trip` data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over log lines and initialize the elevator specification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the elevator state records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the elevator does not backup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the trips finish within 20% of their theoretical limit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Writing the operate_elevator.rs executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operate elevator is very similar to the `simulate_trip.rs` and physics
    `run_simulation` code. The most significant difference is the ability to continue
    running while dynamically accepting new requests and adjusting motor control using
    the linked libraries. In the main executable, we follow the same logical process
    as before, adjusted for new names and type signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize `ElevatorState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `MotionController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the operating loop to process incoming floor requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the processing loop, update the physics approximations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current floor request is satisfied, remove it from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the motor control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Reflecting on the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have developed code to organize and connect different elevator functions,
    as well as three executables to simulate, analyze, and operate the elevators,
    let's ask ourselves this—how does it all fit together, and have we done a good
    job architecting this project thus far?
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing this chapter, we can quickly see that we have made use of four different
    code organization techniques. At a more casual level, the code seems to fall into
    categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Luggage**: Like drivers that need to be connected, but may be difficult to
    work with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nuts**, **bolts**, and **gears**: Like structs and traits, we have a lot
    of control of how to design'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deliverables**: Like executables, these must fulfill a specific requirement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have organized all deliverables by convenience; all luggage by type or by
    purpose; and nuts, bolts, and gears have been organized by type, by purpose, or
    by layer. The result could be worse, and organizing by a different standard does
    not imply that the code will change significantly. Overall, the deliverables are
    supported by fairly maintainable code and the project is going in a good direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined four code organization principles that can be used
    alone or in combination to develop well-structured projects. The four principles
    of organization by type, by purpose, by layer, and by convenience are helpful
    perspectives for inspiring good architecture choices when structuring larger projects.
    The larger and more complex a project becomes, the more important these decisions
    become, though simultaneously more difficult to change.
  prefs: []
  type: TYPE_NORMAL
- en: Applying these concepts, we restructured the entire project using each principle
    to a varying degree. We also incorporated significant changes to allow interfacing
    with external libraries and applied operations of the elevator, as opposed to
    a closed simulation. Now, the elevators of three buildings should be capable of
    running entirely on the software developed here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about mutability and ownership. We have covered
    these concepts to a certain degree already, but the next chapter will demand a
    much more in-depth understanding of specific details and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are four ways of grouping code into modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does FFI stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are unsafe blocks necessary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it ever safe to use unsafe blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `libc::c_int` and an `int32`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can linked libraries define functions with the same name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of files can be linked into a Rust project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
