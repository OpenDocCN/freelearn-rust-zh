["```rs\nfn add_one(input: u32) -> u32 {\n    input + 1\n}\n```", "```rs\nmacro_rules! add_one {\n    ($input:expr) => {\n        $input + 1\n    }\n}\n```", "```rs\nmacro_rules! add {\n    {one to $input:expr} => ($input + 1);\n    {two to $input:expr} => ($input + 2);\n}\n\nfn main() {\n    println!(\"Add one: {}\", add!(one to 25/5));\n    println!(\"Add two: {}\", add!(two to 25/5));\n}\n```", "```rs\nmacro_rules! my_vec {\n    ($($x: expr),*) => {{\n        let mut vector = Vec::new();\n        $(vector.push($x);)*\n        vector\n    }}\n}\n```", "```rs\nfn main() {\n    let my_vector = my_vec![4, 8, 15, 16, 23, 42];\n    println!(\"Vector test: {:?}\", my_vector);\n}\n```", "```rs\nfn main() {\n    let my_vector = {\n        let mut vector = Vec::new();\n        vector.push(4);\n        vector.push(8);\n        vector.push(15);\n        vector.push(16);\n        vector.push(23);\n        vector.push(42);\n        vector\n    };\n    println!(\"Vector test: {:?}\", my_vector);\n}\n```", "```rs\nmacro_rules! add_to_vec {\n    ($( $x:expr; [ $( $y:expr ),* ]);* ) => {\n        &[ $($( $x + $y ),*),* ]\n    }\n}\n```", "```rs\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\npub struct Amount {\n    value: u64,\n}\n```", "```rs\nuse std::ops::Mul;\n\nimpl Mul<u8> for Amount {\n    type Output = Self;\n\n    fn mul(self, rhs: u8) -> Self::Output {\n        Self { value: self.value * rhs as u64 }\n    }\n}\n\nimpl Mul<Amount> for u8 {\n    type Output = Amount;\n\n    fn mul(self, rhs: Amount) -> Self::Output {\n        Self::Output { value: self as u64 * rhs.value }\n    }\n}\n```", "```rs\nmacro_rules! impl_mul_int {\n    ($($t:ty)*) => ($(\n        impl Mul<$t> for Amount {\n            type Output = Self;\n\n            fn mul(self, rhs: $t) -> Self::Output {\n                Self { value: self.value * rhs as u64 }\n            }\n        }\n\n        impl Mul<Amount> for $t {\n            type Output = Amount;\n\n            fn mul(self, rhs: Amount) -> Self::Output {\n                Self::Output { value: self as u64 * rhs.value }\n            }\n        }\n    )*)\n}\n\nimpl_mul_int! { u8 u16 u32 u64 usize }\n```", "```rs\ntrait TypeName {\n    fn type_name() -> &'static str;\n}\n```", "```rs\ncargo new type-name-derive\n```", "```rs\n[dependencies]\ntype-name-derive = { path = \"./type-name-derive\" }\n```", "```rs\n#[macro_use]\nextern crate type_name_derive;\n\ntrait TypeName {\n    fn type_name() -> &'static str;\n}\n```", "```rs\n[dependencies]\nsyn = \"0.12.10\"\nquote = \"0.4.2\"\n```", "```rs\n[lib]\nproc-macro = true\n```", "```rs\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(TypeName)]\npub fn type_name(input: TokenStream) -> TokenStream {\n    // some code\n}\n```", "```rs\n    // Parse the input tokens into a syntax tree\n    let input = syn::parse(input).unwrap();\n\n    // Build the output\n    let expanded = impl_type_name(&input);\n\n    // Hand the output tokens back to the compiler\n    expanded.into()\n```", "```rs\nfn impl_type_name(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    quote! {\n        impl TypeName for #name {\n            fn type_name() -> &'static str {\n                stringify!(#name)\n            }\n        }\n    }\n}\n```", "```rs\n#[derive(TypeName)]\nstruct Alice;\n\n#[derive(TypeName)]\nenum Bob {}\n\nfn main() {\n    println!(\"Alice's name is {}\", Alice::type_name());\n    println!(\"Bob's name is {}\", Bob::type_name());\n}\n```", "```rs\nAlice's name is Alice\nBob's name is Bob\n```", "```rs\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(Getters)]\npub fn derive_getters(input: TokenStream) -> TokenStream {\n    // Parse the input tokens into a syntax tree\n    let input = syn::parse(input).unwrap();\n\n    // Build the output\n    let expanded = impl_getters(&input);\n\n    // Hand the output tokens back to the compiler\n    expanded.into()\n}\n\nfn impl_getters(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    unimplemented!()\n}\n```", "```rs\nfn impl_getters(ast: &syn::DeriveInput) -> quote::Tokens {\n    use syn::{Data, Fields};\n\n    let name = &ast.ident;\n    let (impl_generics, ty_generics, where_clause) =\n                            ast.generics.split_for_impl();\n\n    match ast.data {\n        Data::Struct(ref structure) => {\n            if let Fields::Named(ref fields) = structure.fields {\n                let getters: Vec<_> =\n                                fields.named.iter()\n                                            .map(generate_getter)\n                                            .collect();\n\n                quote! {\n                    impl #impl_generics #name #ty_generics\n                        #where_clause {\n                        #(#getters)*\n                    }\n                }\n            } else {\n                panic!(\"you cannot implement getters for unit \\\n                        or tuple structs\");\n            }\n        },\n        Data::Union(ref _union) => {\n            unimplemented!(\"sorry, getters are not implemented \\\n                            for unions yet\");\n        }\n        Data::Enum(ref _enum) => {\n            panic!(\"you cannot derive getters for enumerations\");\n        }\n    }\n}\n\nfn generate_getter(field: &syn::Field) -> quote::Tokens {\n    unimplemented!(\"getters not yet implemented\")\n}\n```", "```rs\nfn generate_getter(field: &syn::Field) -> quote::Tokens {\n    let name = field.ident\n                .expect(\"named fields must have a name\");\n    let ty = &field.ty;\n\n    quote! {\n        fn #name(&self) -> &#ty {\n            &self.#name\n        }\n    }\n}\n```", "```rs\nuse syn::{DeriveInput, Fields, Field, Data};\nuse syn::punctuated::Punctuated;\nuse syn::token::Comma;\n\nfn get_fields(ast: &DeriveInput) -> &Punctuated<Field, Comma> {\n    match ast.data {\n        Data::Struct(ref structure) => {\n            if let Fields::Named(ref fields) = structure.fields {\n                &fields.named\n            } else {\n                panic!(\"you cannot implement setters or getters \\\n                        for unit or tuple structs\");\n            }\n        },\n        Data::Union(ref _union) => {\n            unimplemented!(\"sorry, setters and getters are not \\\n                            implemented for unions yet\");\n        }\n        Data::Enum(ref _enum) => {\n            panic!(\"you cannot derive setters or getters for \\\n                    enumerations\");\n        }\n    }\n}\n```", "```rs\nfn impl_methods<F>(ast: &DeriveInput, strategy: F) -> Tokens\nwhere F: FnMut(&Field) -> Tokens {\n    let methods: Vec<_> = get_fields(ast).iter()\n                                         .map(strategy)\n                                         .collect();\n    let name = &ast.ident;\n    let (impl_generics, ty_generics, where_clause) =\n                            ast.generics.split_for_impl();\n\n    quote! {\n        impl #impl_generics #name #ty_generics #where_clause {\n            #(#methods)*\n        }\n    }\n}\n```", "```rs\n#[proc_macro_derive(Getters)]\npub fn derive_getters(input: TokenStream) -> TokenStream {\n    // Parse the input tokens into a syntax tree\n    let input = syn::parse(input).unwrap();\n\n    // Build the output\n    let expanded = impl_methods(&input, generate_getter);\n\n    // Hand the output tokens back to the compiler\n    expanded.into()\n}\n\n#[proc_macro_derive(Setters)]\npub fn derive_setters(input: TokenStream) -> TokenStream {\n    // Parse the input tokens into a syntax tree\n    let input = syn::parse(input).unwrap();\n\n    // Build the output\n    let expanded = impl_methods(&input, generate_setter);\n\n    // Hand the output tokens back to the compiler\n    expanded.into()\n}\n```", "```rs\nuse syn::Ident;\n\nfn generate_setter(field: &Field) -> Tokens {\n    let name = field.ident\n                .expect(\"named fields must have a name\");\n    let fn_name = Ident::from(format!(\"set_{}\", name));\n    let ty = &field.ty;\n\n    quote! {\n        fn #fn_name<T>(&mut self, value: T) where T: Into<#ty> {\n            self.#name = value.into();\n        }\n    }\n}\n```", "```rs\n#[macro_use]\nextern crate getset_derive;\n\n#[derive(Debug, Getters, Setters)]\nstruct Alice {\n    x: String,\n    y: u32,\n}\n```", "```rs\nfn main() {\n    let mut alice = Alice {\n        x: \"this is a name\".to_owned(),\n        y: 34\n    };\n    println!(\"Alice: {{ x: {}, y: {} }}\",\n             alice.x(),\n             alice.y());\n\n    alice.set_x(\"testing str\");\n    alice.set_y(15u8);\n    println!(\"{:?}\", alice);\n}\n```", "```rs\nAlice: { x: this is a name, y: 34 }\nAlice { x: \"testing str\", y: 15 }\n```", "```rs\n#[proc_macro_derive(Setters, attributes(generic))]\n```", "```rs\n[lib]\nplugin = true\n```", "```rs\n#![crate_type=\"dylib\"]\n#![feature(plugin_registrar, rustc_private)]\n\nextern crate syntax;\nextern crate syntax_pos;\nextern crate rustc;\nextern crate rustc_plugin;\n\nuse rustc_plugin::Registry;\n\n#[plugin_registrar]\npub fn plugin_registrar(reg: &mut Registry) {\n    unimplemented!()\n}\n```"]