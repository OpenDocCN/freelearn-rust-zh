["```rs\nimport sys\n```", "```rs\nsys.stdout.write(\"5\\n\")\n```", "```rs\nsys.stdout.write(\"6\\n\")\n```", "```rs\nsys.stdout.write(\"7\\n\")\n```", "```rs\nsys.stdout.write(\"8\\n\")\n```", "```rs\nsys.stdout.write(\"9\\n\")\n```", "```rs\nsys.stdout.write(\"10\\n\")\n```", "```rs\n$ python input.py\n```", "```rs\n5\n```", "```rs\n6\n```", "```rs\n7\n```", "```rs\n8\n```", "```rs\n9\n```", "```rs\n10\n```", "```rs\nuse std::io;\n```", "```rs\nuse std::io::prelude::*;\n```", "```rs\npub fn fibonacci_reccursive(n: i32) -> u64 {\n```", "```rs\n    match n {\n```", "```rs\n         1 | 2 => 1,\n```", "```rs\n         _     => fibonacci_reccursive(n - 1) + \n```", "```rs\n                  fibonacci_reccursive(n - 2)\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n    let stdin = io::stdin();\n```", "```rs\n    let stdout = std::io::stdout();\n```", "```rs\n    let mut writer = stdout.lock();\n```", "```rs\n    for line in stdin.lock().lines() {\n```", "```rs\n        let input_int: i32 = line.unwrap().parse::<i32>() \\\n```", "```rs\n          .unwrap();\n```", "```rs\n        let fib_number = fibonacci_reccursive(input_int);\n```", "```rs\n        writeln!(writer, \"{}\", fib_number);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nrustc fib.rs\n```", "```rs\n$ python input.py | ./fib \n```", "```rs\n5\n```", "```rs\n8\n```", "```rs\n13\n```", "```rs\n21\n```", "```rs\n34\n```", "```rs\n55\n```", "```rs\nimport sys\n```", "```rs\nfor i in sys.stdin.readlines():\n```", "```rs\n    try:\n```", "```rs\n        processed_number = int(i)\n```", "```rs\n        print(f\"receiving: {processed_number}\")\n```", "```rs\n    except ValueError:\n```", "```rs\n        pass\n```", "```rs\n$ python input.py | ./fib | python output.py\n```", "```rs\nreceiving: 5\n```", "```rs\nreceiving: 8\n```", "```rs\nreceiving: 13\n```", "```rs\nreceiving: 21\n```", "```rs\nreceiving: 34\n```", "```rs\nreceiving: 55\n```", "```rs\ndef recur_fib(n: int) -> int:\n```", "```rs\n    if n <= 2:\n```", "```rs\n        return 1\n```", "```rs\n    else:\n```", "```rs\n        return (recur_fib(n - 1) +\n```", "```rs\n                recur_fib(n - 2))\n```", "```rs\nfor i in [5, 6, 7, 8, 9, 10, 15, 20, 25, 30]:\n```", "```rs\n    print(recur_fib(i))\n```", "```rs\n$ time python pure_python.py \n```", "```rs\n5\n```", "```rs\n8\n```", "```rs\n13\n```", "```rs\n21\n```", "```rs\n34\n```", "```rs\n55\n```", "```rs\n610\n```", "```rs\n6765\n```", "```rs\n75025\n```", "```rs\n832040\n```", "```rs\nreal  0m0.315s\n```", "```rs\nuser  0m0.240s\n```", "```rs\nsys  0m0.027s\n```", "```rs\n$ time python input.py | ./fib | python output.py\n```", "```rs\nreceiving: 5\n```", "```rs\nreceiving: 8\n```", "```rs\nreceiving: 13\n```", "```rs\nreceiving: 21\n```", "```rs\nreceiving: 34\n```", "```rs\nreceiving: 55\n```", "```rs\nreceiving: 610\n```", "```rs\nreceiving: 6765\n```", "```rs\nreceiving: 75025\n```", "```rs\nreceiving: 832040\n```", "```rs\nreal  0m0.054s\n```", "```rs\nuser  0m0.050s\n```", "```rs\nsys  0m0.025s\n```", "```rs\nfrom rust_package import calculate_coordinates\n```", "```rs\nclass Particle:\n```", "```rs\n    def __init__(self, v_x, v_y):\n```", "```rs\n        self.co_dict = calculate_coordinates(v_x, v_y)\n```", "```rs\n    def get_position(self, time) -> tuple:\n```", "```rs\n        return self.co_dict[time]\n```", "```rs\n    @property\n```", "```rs\n    def times(self):\n```", "```rs\n        return list(self.co_dict.keys())\n```", "```rs\nfrom . . . import Particle\n```", "```rs\nparticle = Particle(20, 30)\n```", "```rs\nx_positions = []\n```", "```rs\ny_positions = []\n```", "```rs\nfor t in particle.times:\n```", "```rs\n    x, y = particle.get_position(t)\n```", "```rs\n    x_positions.append(x)\n```", "```rs\n    y_positions.append(y)\n```", "```rs\nclass FlyWeight(type):\n```", "```rs\n    _instances = {}\n```", "```rs\n    def __call__(cls, *args, **kwargs):\n```", "```rs\n        key = str(args[0]) + str(args[1])\n```", "```rs\n        if key not in cls._instances:\n```", "```rs\n            cls._instances[key] = super( \\\n```", "```rs\n                FlyWeight, cls).__call__(*args, **kwargs)\n```", "```rs\n        return cls._instances[key]\n```", "```rs\nclass Particle(metaclass=FlyWeight):\n```", "```rs\n    def __init__(self, v_x, v_y):\n```", "```rs\n        self.co_dict = calculate_coordinates(v_x, v_y)\n```", "```rs\n    def get_position(self, time) -> tuple:\n```", "```rs\n        return self.co_dict[time]\n```", "```rs\n    @property\n```", "```rs\n    def times(self):\n```", "```rs\n        return list(self.co_dict.keys())\n```", "```rs\ntest = Particle(4, 6)\n```", "```rs\ntest_two = Particle(3, 8)\n```", "```rs\ntest_three = Particle(4, 6)\n```", "```rs\nprint(id(test))\n```", "```rs\nprint(id(test_three))\n```", "```rs\nprint(id(test_two))\n```", "```rs\n140579826787152\n```", "```rs\n140579826787152\n```", "```rs\n140579826787280\n```", "```rs\n├── Cargo.toml\n```", "```rs\n├── src\n```", "```rs\n│   ├── actions.rs\n```", "```rs\n│   ├── main.rs\n```", "```rs\n│   ├── objects.rs\n```", "```rs\n│   ├── people.rs\n```", "```rs\n│   └── traits.rs\n```", "```rs\npub trait Speak {\n```", "```rs\n    fn introduce(&self) -> ();\n```", "```rs\n}\n```", "```rs\npub trait ClinicalSkills {\n```", "```rs\n    fn can_prescribe(&self) -> bool {        \n```", "```rs\n        return false\n```", "```rs\n    }\n```", "```rs\n    fn can_diagnose(&self) -> bool {\n```", "```rs\n        return false\n```", "```rs\n    }\n```", "```rs\n    fn can_administer_medication(&self) -> bool {\n```", "```rs\n        return true\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\npub trait AdvancedMedical {}\n```", "```rs\npub trait PatientRole {\n```", "```rs\n    fn get_name(&self) -> String;\n```", "```rs\n}\n```", "```rs\nuse super::traits;\n```", "```rs\nuse traits::{Speak, ClinicalSkills, AdvancedMedical, \\\n```", "```rs\n  PatientRole};\n```", "```rs\npub struct Patient {\n```", "```rs\n    pub name: String\n```", "```rs\n}\n```", "```rs\npub struct Nurse {\n```", "```rs\n    pub name: String\n```", "```rs\n}\n```", "```rs\npub struct NursePractitioner {\n```", "```rs\n    pub name: String\n```", "```rs\n}\n```", "```rs\npub struct AdvancedNursePractitioner {\n```", "```rs\n    pub name: String\n```", "```rs\n}\n```", "```rs\npub struct Doctor {\n```", "```rs\n    pub name: String\n```", "```rs\n}\n```", "```rs\nimpl Speak for Patient {\n```", "```rs\n    fn introduce(&self) {\n```", "```rs\n        println!(\"hello I'm a Patient and my name is {}\", \\\n```", "```rs\n            self.name);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nimpl Speak for Nurse {\n```", "```rs\n    fn introduce(&self) {\n```", "```rs\n        println!(\"hello I'm a Nurse and my name is {}\", \\\n```", "```rs\n            self.name);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nimpl Speak for NursePractitioner {\n```", "```rs\n    fn introduce(&self) {\n```", "```rs\n        println!(\"hello I'm a Practitioner and my name is \\\n```", "```rs\n            {}\", self.name);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\n. . .\n```", "```rs\nimpl PatientRole for Patient {\n```", "```rs\n    fn get_name(&self) -> String {\n```", "```rs\n        return self.name.clone()\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nimpl ClinicalSkills for Nurse {}\n```", "```rs\nimpl ClinicalSkills for NursePractitioner {\n```", "```rs\n    fn can_prescribe(&self) -> bool {\n```", "```rs\n        return true\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nimpl AdvancedMedical for AdvancedNursePractitioner {}\n```", "```rs\nimpl AdvancedMedical for Doctor {}\n```", "```rs\nimpl<T> ClinicalSkills for T where T: AdvancedMedical {\n```", "```rs\n    fn can_prescribe(&self) -> bool {\n```", "```rs\n        return true\n```", "```rs\n    }\n```", "```rs\n    fn can_diagnose(&self) -> bool {\n```", "```rs\n        return true\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\nuse super::traits;\n```", "```rs\nuse traits::{ClinicalSkills, AdvancedMedical, PatientRole};\n```", "```rs\npub fn admit_patient<Y: ClinicalSkills>(\n```", "```rs\n    patient: &Box<dyn PatientRole>, _clinician: &Y) {\n```", "```rs\n    println!(\"{} is being admitted\", patient.get_name());\n```", "```rs\n}\n```", "```rs\npub fn diagnose_patient<Y: AdvancedMedical>(\n```", "```rs\n    patient: &Box<dyn PatientRole>, _clinician: &Y) {\n```", "```rs\n    println!(\"{} is being diagnosed\", patient.get_name());\n```", "```rs\n}\n```", "```rs\npub fn prescribe_meds<Y: ClinicalSkills>(\n```", "```rs\n    patient: &Box<dyn PatientRole>, clinician: &Y) {\n```", "```rs\n    if clinician.can_prescribe() {\n```", "```rs\n        println!(\"{} is being prescribed medication\", \\\n```", "```rs\n          patient.get_name());\n```", "```rs\n    } else {\n```", "```rs\n        panic!(\"clinician cannot prescribe medication\");\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\npub fn administer_meds<Y: ClinicalSkills>(\n```", "```rs\n    patient: &Box<dyn PatientRole>, _clinician: &Y) {\n```", "```rs\n    println!(\"{} is having meds administered\", \\\n```", "```rs\n      patient.get_name());\n```", "```rs\n}\n```", "```rs\npub fn discharge_patient<Y: ClinicalSkills>(\n```", "```rs\n    patient: &Box<dyn PatientRole>, _clinician: &Y) {\n```", "```rs\n    println!(\"{} is being discharged\", patient.get_name());\n```", "```rs\n}\n```", "```rs\nuse super::traits;\n```", "```rs\nuse traits::PatientRole;\n```", "```rs\npub struct PatientList {\n```", "```rs\n    pub patients: Vec<Box<dyn PatientRole>>\n```", "```rs\n}\n```", "```rs\n    mod traits;\n    mod objects;\n    mod people;\n    mod actions;\n    use people::{Patient, Nurse, Doctor};\n    use objects::PatientList;\n    use actions::{admit_patient, diagnose_patient, \\\n      prescribe_meds, administer_meds, discharge_patient};\n    ```", "```rs\n    fn main() {\n        let doctor = Doctor{name: String::from(\"Torath\")};\n        let doctor_two = Doctor{name: \\\n          String::from(\"Sergio\")};\n        let nurse = Nurse{name: String::from(\"Maxwell\")};\n        let nurse_two = Nurse{name: \\\n          String::from(\"Nathan\")};\n    }\n    ```", "```rs\n        let patient_list = PatientList {\n            patients: vec![\n                Box::new(Patient{name: \\\n                  String::from(\"pestilence\")}),\n                Box::new(Patient{name: \\\n                  String::from(\"war\")}),\n                Box::new(Patient{name: \\\n                  String::from(\"famine\")}),\n                Box::new(Patient{name: \\\n                  String::from(\"death\")})\n            ]\n        };\n    ```", "```rs\n        for i in patient_list.patients {\n            admit_patient(&i, &nurse);\n            diagnose_patient(&i, &doctor);\n            prescribe_meds(&i, &doctor_two);\n            administer_meds(&i, &nurse_two);\n            discharge_patient(&i, &nurse);\n        }\n    ```", "```rs\nconquest is being admitted\n```", "```rs\nconquest is being diagnosed\n```", "```rs\nconquest is being prescribed medication\n```", "```rs\nconquest is having meds administered\n```", "```rs\nconquest is being discharged\n```", "```rs\nwar is being admitted\n```", "```rs\n. . .\n```", "```rs\nfamine is being admitted\n```", "```rs\n. . .\n```", "```rs\ndeath is being admitted\n```", "```rs\n. . .\n```", "```rs\n#[pyclass]\n```", "```rs\npub struct NurseClass {\n```", "```rs\n    #[pyo3(get, set)]\n```", "```rs\n    pub name: String,\n```", "```rs\n    #[pyo3(get, set)]\n```", "```rs\n    pub admin: bool,\n```", "```rs\n    #[pyo3(get, set)]\n```", "```rs\n    pub prescribe: bool,\n```", "```rs\n    #[pyo3(get, set)]\n```", "```rs\n    pub diagnose: bool,\n```", "```rs\n}\n```", "```rs\n#[pymethods]\n```", "```rs\nimpl NurseClass {\n```", "```rs\n    #[new]\n```", "```rs\n    fn new(name: String, admin: bool, prescribe: bool,\n```", "```rs\n           diagnose: bool)      Self {\n```", "```rs\n        return Nurse{name, admin, prescribe}\n```", "```rs\n    }\n```", "```rs\n    fn introduce(&self)      Vec<Vec<u64>> {\n```", "```rs\n        println!(\"hello I'm a Nurse and my name is {}\", \n```", "```rs\n                 self.name);\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\n[dependencies]\n```", "```rs\nrayon = \"1.5.1\"\n```", "```rs\nWith this, we import this crate in our main.rs file with the \n```", "```rs\nfollowing code:\n```", "```rs\nextern crate rayon;\n```", "```rs\nuse rayon::prelude::*;\n```", "```rs\npub fn fibonacci_reccursive(n: i32) -> u64 {\n```", "```rs\n      match n {\n```", "```rs\n            1 | 2 => 1,\n```", "```rs\n      _     => fibonacci_reccursive(n - 1) +\n```", "```rs\n                   fibonacci_reccursive(n - 2)\n```", "```rs\n      }\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n    let numbers: Vec<u64> = vec![6, 7, 8, 9, 10].into_par_iter(\n```", "```rs\n    ).map(\n```", "```rs\n        |x| fibonacci_reccursive(x)\n```", "```rs\n    ).collect();\n```", "```rs\n    println!(\"{:?}\", numbers);\n```", "```rs\n}\n```"]