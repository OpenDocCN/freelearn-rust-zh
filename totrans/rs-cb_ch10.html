<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Advanced Web Development in Rust</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Web Development in Rust</h1>
                </header>
            
            <article>
                
<p>We will be covering the following recipes in this chapter:</p>
<ul>
<li>Setting up the API</li>
<li>Saving user data in MongoDB</li>
<li>Fetching user data</li>
<li>Deleting user data</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will create a RESTful API web service using open source crates in the Rust language. The simple RESTful API in Rust will connect to a MongoDB service, which provides an end-to-end API solution.</p>
<p>We will look at how to perform <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> requests on user data from an endpoint. The crates, <kbd>nickel.rs</kbd> and the MongoDB Rust driver, make it possible to create these actions in the Rust language.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up the API</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps through which we can install all the dependencies, such as nickel crate, to set up, and create the API, in our Rust project. You will also learn the commands required to set up the basic REST API service.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel and MongoDB crates before we can go ahead and create the REST API. Follow the steps given to download and set up nickel and the other crate for your project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the <kbd>cargo</kbd> command-line tool, and enter the newly created project:</li>
</ol>
<pre><strong>    cargo new --bin sample_rest_api &amp;&amp; cd sample_rest_api<br/></strong>
</pre>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="37" width="465" class="image-border" src="images/512cf565-9e68-4877-aa0a-64698c75276e.png"/></div>
<ol start="3">
<li>Open <span>the</span> <kbd>Cargo.toml</kbd> <span>file in your favorite text editor and make the modifications shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="132" width="304" class="image-border" src="images/07c90ba1-3f49-47fe-a0df-be9e652b8cad.png"/></div>
<ol start="4">
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<p style="padding-left: 60px">You will get the following screenshot as output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="358" width="425" class="image-border" src="images/0215c6f6-5481-463f-8310-889598705abf.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Perform the following steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Creating a simple REST API<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 28 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import the installed nickel crate by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use]<br/>        extern crate nickel;<br/><br/>        use nickel::{Nickel, JsonBody, HttpRouter, Request,<br/>        Response, MiddlewareResult, MediaType};
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/><br/>         let mut server = Nickel::new();<br/>         let mut router = Nickel::router();
</pre>
<ol start="5">
<li>Define the <kbd>GET</kbd> endpoint:</li>
</ol>
<pre>        router.get("/users", middleware! { |request, response|<br/><br/>        format!("Hello from GET /users")<br/><br/>        });
</pre>
<ol start="6">
<li>Defin<span>e the <kbd>POST</kbd> endpoint:</span></li>
</ol>
<pre>        router.post("/users/new", middleware! { |request,<br/>        response|<br/><br/>        format!("Hello from POST /users/new")<br/><br/>        });
</pre>
<ol start="7">
<li>Defi<span>ne the <kbd>DELETE</kbd> endpoint:</span></li>
</ol>
<pre>        router.delete("/users/:id", middleware! { |request,<br/>        response|<br/><br/>        format!("Hello from DELETE /users/:id")<br/><br/>        });
</pre>
<ol start="8">
<li>Declare the port at which the services will be started:</li>
</ol>
<pre>        server.utilize(router);<br/><br/>        server.listen("127.0.0.1:9000");<br/>        }
</pre>
<ol start="9">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>    cargo run</strong>
</pre>
<ol start="10">
<li>We will get the following output on the successful execution of our code in the terminal:</li>
</ol>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img height="65" width="427" class="image-border" src="images/7ea86c97-3340-497f-b701-95a8a6726b5a.png"/></div>
<p>We make a <kbd>GET</kbd> request to <kbd>http://127.0.0.1:9000/users</kbd>, which returns <kbd>Hello from GET /users</kbd> from the web service created using the nickel web application framework, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="267" width="798" class="image-border" src="images/35e4d971-4dd5-42a5-a1d9-f78b8d5135f2.png"/></div>
<p>&#160;</p>
<p>We make a <kbd><span><span>POST</span></span></kbd> request to <kbd>http://127.0.0.1:9000/users/new</kbd>, which returns <kbd>Hello from POST /users/new</kbd> from the web service created using the nickel web application framework:</p>
<div class="CDPAlignCenter CDPAlign"><img height="261" width="756" class="image-border" src="images/c7fdfd28-1166-41c7-938b-4656f766c718.png"/></div>
<p><span>We make a</span> <kbd><span><span>DELETE</span></span></kbd> <span>request to</span> <kbd>http://127.0.0.1:9000/users/:id</kbd>, <span>which returns</span> <kbd>Hello from DELETE /users/:id</kbd> <span>from the web service created using the nickel web application framework:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="253" width="756" class="image-border" src="images/69efb63b-b7dd-4289-9065-1bf0008e2397.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created the basic skeleton of our REST API service, where we have all our endpoints set.</p>
<p>Our API will have three endpoints, which are as follows:</p>
<ul>
<li><kbd>/users</kbd>: Here, we will hit out the <kbd>GET</kbd> request, which retrieves the <kbd>firstname</kbd> field of all the users</li>
<li><kbd>/users/new</kbd>: The <kbd>POST</kbd> request to this endpoint creates and saves a new user</li>
<li><kbd>/users/:id</kbd>: The <kbd>DELETE</kbd> method will delete a user based on the record's <kbd>ObjectId</kbd>, which is the unique ID obtained from the MongoDB database</li>
</ul>
<p>We will activate all these endpoints in the following recipes with their exact behavior, but currently, these will only display a sample message when the user hits the endpoint with the corresponding requests.</p>
<p><span>Starting at the top, we're referencing the external</span> nickel <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loading all of its macros with</span> <kbd>#[macro_use]</kbd><span>. The n</span>ickel <span>is the application object and the surface that holds all the public APIs; it's a struct, which implements all the fundamental methods for performing all the web application tasks. The other crates, such as bson, rustc-serialize, and MongoDB, which we downloaded initially using the <kbd>cargo</kbd> tool, will be used in the following recipes to activate the functionalities in the endpoints.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign the</span> <kbd>server</kbd> <span>instances to a mutable variable and create a new</span> nickel <span>application object using</span> <kbd>Nickel::new()</kbd><span>, which creates an instance of the nickel with default error handling. Similarly, we create a mutable router instance and assign it to</span> <kbd>Nickel::router()</kbd><span>, which will take care of handling the different endpoints.</span></p>
<p>We set up our endpoint routing using different methods, such as <kbd>get()</kbd>, <kbd>post()</kbd>, and <kbd>delete()</kbd>, of the <kbd>router</kbd> instance and provide a simple message in the <kbd>format!</kbd> macro to be displayed when these endpoints are accessed. The messages are as follows:</p>
<ul>
<li><kbd>/users</kbd>: The <kbd>GET</kbd> request will get <kbd>Hello from GET /users</kbd></li>
<li><kbd>/users/new</kbd>: The <kbd>POST</kbd> request will get <kbd>Hello from POST /users/new</kbd></li>
<li><kbd>/users/:id</kbd>: The <kbd>DELETE</kbd> request will get <kbd>Hello from DELETE /users/:id</kbd></li>
</ul>
<p>The <kbd>middleware!</kbd> macro is provided by <kbd>nickel.rs</kbd> and reduces the amount of boilerplate code needed for each route. Double-pipe characters represent the closure in Rust, and this is where our <kbd>request</kbd> and <kbd>response</kbd> parameters are placed.</p>
<p><span>Using the</span> <kbd>server.utilize</kbd> <span>method, we add the endpoints to the <kbd>server</kbd> instance and register the handler that will be invoked among other handlers before each request, by passing the <kbd>router</kbd> instance. The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:9000</kbd><span>, where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Saving user data in MongoDB</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will go a step ahead and rewrite the logic for the <kbd>POST</kbd> request, which will take the user data and save it in the MongoDB database, for which we will use the MongoDB Rust driver for interacting with the DB.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel and MongoDB crates before we can go ahead and create the REST API. Follow these steps to download and set up nickel and the MongoDB service in the project:</p>
<ol start="1">
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
</ol>
<p>&#160;</p>
<ol start="2">
<li>Create a Rust project using the <kbd>cargo</kbd> command-line tool and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new --bin sample_post &amp;&amp; cd sample_post</strong>
</pre>
<p style="padding-left: 90px">Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="91" width="480" class="image-border" src="images/01b6b8eb-786b-48dc-9e44-7a905ee6bdbe.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification as shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:<br/>
<div class="CDPAlignCenter CDPAlign"><img height="154" width="331" class="image-border" src="images/06847d30-c762-41a9-bc0a-5e07beda174c.png"/></div>
</li>
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>    cargo build</strong>
</pre>
<ol start="5">
<li>Set up the MongoDB service in your Linux system by following these steps:</li>
</ol>
<pre><strong>      sudo apt-key adv --keyserver<br/>      hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10</strong><br/><br/><strong>      echo "deb http://repo.mongodb.org/apt/ubuntu<br/>      "$(lsb_release -sc)"/mongodb-org/3.0 multiverse" | sudo<br/>      tee /etc/apt/sources.list.d/mongodb-org-3.0.list</strong><br/><br/><strong>      sudo apt-get update</strong><br/><br/><strong>      sudo apt-get install -y mongodb-org</strong><br/><br/><strong>      service mongod status</strong>
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the mentioned steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Perform POST action<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 28 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import all the required installed nickel and other supporting crates by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use]<br/>        extern crate nickel;<br/>        extern crate rustc_serialize;<br/><br/>        #[macro_use(bson, doc)]<br/>        extern crate bson;<br/>        extern crate mongodb;<br/><br/>        // Nickel<br/>        use nickel::{Nickel, JsonBody, HttpRouter, MediaType};<br/>        use nickel::status::StatusCode::{self};<br/><br/>        // MongoDB<br/>        use mongodb::{Client, ThreadedClient};<br/>        use mongodb::db::ThreadedDatabase;<br/>        use mongodb::error::Result as MongoResult;<br/><br/>        // bson<br/>        use bson::{Bson, Document};<br/>        use bson::oid::ObjectId;<br/><br/>        // rustc_serialize<br/>        use rustc_serialize::json::{Json, ToJson};
</pre>
<ol start="4">
<li>We create a <kbd>struct</kbd> named <kbd>User</kbd>, which is encodable and decodable and which models our user data:</li>
</ol>
<pre>        #[derive(RustcDecodable, RustcEncodable)]<br/>        struct User {<br/>         firstname: String,<br/>         lastname: String,<br/>         email: String<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function, where we'll declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/><br/>         let mut server = Nickel::new();<br/>         let mut router = Nickel::router();
</pre>
<ol start="6">
<li>Define the <kbd>GET</kbd> endpoint:</li>
</ol>
<pre>         router.get("/users", middleware! { |request, response|<br/><br/>         format!("Hello from GET /users")<br/><br/>         });
</pre>
<ol start="7">
<li>Define <span>the <kbd>POST</kbd> endpoint:</span></li>
</ol>
<pre>        router.post("/users/new", middleware! { |request,<br/>        response|<br/><br/>        // Accept a JSON string that corresponds to the User<br/>        struct<br/>        let user = request.json_as::&lt;User&gt;().unwrap();<br/><br/>        let firstname = user.firstname.to_string();<br/>        let lastname = user.lastname.to_string();<br/>        let email = user.email.to_string();<br/><br/>        // Connect to the database<br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Error establishing connection.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust-<br/>        cookbook").collection("users");<br/> <br/>        // Insert one user<br/>        match coll.insert_one(doc! {<br/>        "firstname" =&gt; firstname,<br/>        "lastname" =&gt; lastname,<br/>        "email" =&gt; email<br/>        }, None) {<br/>        Ok(_) =&gt; (StatusCode::Ok, "Item saved!"),<br/>        Err(e) =&gt; return response.send(format!("{}", e))<br/>        }<br/><br/>        });
</pre>
<ol start="8">
<li>Define <span>the <kbd>DELETE</kbd> endpoint:</span></li>
</ol>
<pre>        router.delete("/users/:id", middleware! { |request,<br/>        response|<br/><br/>        format!("Hello from DELETE /users/:id")<br/><br/>        });
</pre>
<ol start="9">
<li>Declare the port at which the services will be started:</li>
</ol>
<pre>        server.utilize(router);<br/><br/>        server.listen("127.0.0.1:9000");<br/>        }
</pre>
<ol start="10">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>      cargo run</strong>
</pre>
<p>We will get the following screenshot as output on the successful execution of our code in the terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img height="72" width="451" class="image-border" src="images/cf635a8e-3e72-44a2-9218-d2626d197c96.png"/></div>
<p class="mce-root">We submit a <kbd>POST</kbd> request to <kbd>http://127.0.0.1:9000/users/new</kbd> with a body, as shown in the following screenshot containing the user data:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><br/>
<img class="image-border" src="images/4cf43a29-ef65-46e0-aeeb-81425af34c00.png"/></div>
<p>On a successful API call, the web service built using the nickel web application framework returns a message <kbd>Item saved!</kbd>, which is an indication of the data being saved in the MongoDB configuration mentioned in the code. Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="219" width="742" class="image-border" src="images/ca61d191-4f47-4164-a379-4da0c297ce8f.png"/></div>
<p>In order to validate whether the <kbd>POST</kbd> request was successful, we can verify the record from the MongoDB database, where we can select the <kbd>rust-cookbook</kbd> database and the <kbd>users</kbd> collection:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/e5bbc9da-a7e7-463c-bef6-2a88eb31573c.png"/></div>
<p>In this recipe, we focused on getting the user data and saving it to the database. We activated <kbd>POST</kbd> requests to the <kbd>/users/new</kbd> endpoint for creating and saving a new user.</p>
<p><span>Starting at the top, we referenced the external</span> nickel <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>.</span> The nickel <span>is the application object and surface that holds all the public APIs; it's a struct, which implements all the fundamental methods for performing all the web application tasks.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>mutable instances to a mutable variable and create a new</span> nickel <span>application object with</span> <kbd>Nickel::new()</kbd><span>, which creates an instance of nickel with default error handling. Similarly, we create a mutable router instance and assign it to <kbd>Nickel::router()</kbd>, which will take care of handling the different endpoints.</span></p>
<div class="packt_infobox">The MongoDB Rust driver provides a nice interface for interacting with databases, collections, and cursors, with which we can establish a database connection for creating, reading, updating, and deleting user data in our application.</div>
<p><span>We will be getting the <kbd>POST /users/new</kbd> route working, for which we will be using the different crates that we downloaded initially, which are the units of <kbd>rustc_serialize</kbd>, <kbd>bson</kbd>, and <kbd>MongoDB</kbd>.</span></p>
<p>Next up, we create a complex data structure, which is a <kbd>User</kbd> struct that is encodable and decodable and that represents our user data fields.</p>
<p>We will need to send a JSON string input from the user end and convert the input data to the <kbd>User</kbd> struct by creating some variables that can hold the data. The <kbd>unwrap</kbd> method is one of the several ways that Rust provides for assigning a value. The unwrapped data from the user input is saved to variables <kbd>firstname</kbd>, <kbd>lastname</kbd>, and <kbd>email</kbd>. The next step is to establish a connection with the MongoDB service so that we can store the data that we just parsed from the input string. We achieve this with <kbd>Client::connect("localhost", 27017)</kbd>, where <kbd>27017</kbd> is the port in which the MongoDB service is running. The <kbd>coll</kbd> variable connected the particular collection in the database with <kbd>client.db("rust-cookbook").collection("users")</kbd>, where <kbd>rust-cookbook</kbd> is the database and <kbd>users</kbd> is the collection.</p>
<p>We can see the <kbd>match</kbd> statement at work when we use <kbd>coll.insert_doc</kbd> to insert the user data. In the <kbd>Ok</kbd> condition, we respond with a success message, which is <kbd>Item saved</kbd>, and in the <kbd>Err</kbd> condition, we respond with an error.</p>
<p><span>Using the</span> <kbd>server.utilize</kbd> <span>method, we add the endpoints to the server instance and register the handler, which will be invoked among other handlers before each request by passing the <kbd>router</kbd> instance. The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:9000</kbd><span>, where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fetching user data</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps with which we can install all the dependencies, such as the nickel crate, to set up and create the API, and the MongoDB Rust driver to interact with the database in our Rust project. You will also learn the commands with which you can get all the specific data required from the database. The <kbd>GET</kbd> request will fetch the <kbd>firstname</kbd> field's data, which was previously saved in the database, using the <kbd>POST</kbd> method.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel and MongoDB crates before we can go ahead and create the REST API. Follow these steps to download and set up nickel and the MongoDB service in the project:</p>
<ol start="1">
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the <kbd>cargo</kbd> command-line tool and enter the newly created project:</li>
</ol>
<pre><strong>    cargo new --bin sample_get &amp;&amp; cd sample_get</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="653" class="image-border" src="images/d1503520-ddaa-491c-a637-27e8aaeb213e.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification as shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:<br/>
<div class="CDPAlignCenter CDPAlign"><img height="147" width="338" class="image-border" src="images/99e1c63b-fde4-4890-a2ef-09d179b9b594.png"/></div>
</li>
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>      cargo build</strong>
</pre>
<ol start="5">
<li>Set up the MongoDB service in your system by following these steps:</li>
</ol>
<pre>        sudo apt-key adv --keyserver<br/>        hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10<br/><br/>        echo "deb http://repo.mongodb.org/apt/ubuntu<br/>        "$(lsb_release -sc)"/mongodb-org/3.0 multiverse" | sudo<br/>        tee /etc/apt/sources.list.d/mongodb-org-3.0.list<br/><br/>        sudo apt-get update<br/><br/>        sudo apt-get install -y mongodb-org<br/><br/>        service mongod status
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the mentioned steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Perform GET action<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 28 April 17<br/>        //-- ######################### 
</pre>
<ol start="3">
<li>Import all the required installed nickel and other supporting crates by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use]<br/>        extern crate nickel;<br/>        extern crate rustc_serialize;<br/><br/>        #[macro_use(bson, doc)]<br/>        extern crate bson;<br/>        extern crate mongodb;<br/><br/>        // Nickel<br/>        use nickel::{Nickel, JsonBody, HttpRouter, MediaType};<br/>        use nickel::status::StatusCode::{self};<br/><br/>        // MongoDB<br/>        use mongodb::{Client, ThreadedClient};<br/>        use mongodb::db::ThreadedDatabase;<br/>        use mongodb::error::Result as MongoResult;<br/><br/>        // bson<br/>        use bson::{Bson, Document};<br/>        use bson::oid::ObjectId;<br/><br/>        // rustc_serialize<br/>        use rustc_serialize::json::{Json, ToJson};
</pre>
<ol start="4">
<li>We create a <kbd>struct</kbd> named <kbd>User</kbd>, which is encodable and decodable and which models our user data:</li>
</ol>
<pre>        #[derive(RustcDecodable, RustcEncodable)]<br/>        struct User {<br/>          firstname: String,<br/>          lastname: String,<br/>          email: String<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/><br/>          let mut server = Nickel::new();<br/>          let mut router = Nickel::router();
</pre>
<ol start="6">
<li>Define the <kbd>GET</kbd> endpoint:</li>
</ol>
<pre>        router.get("/users", middleware! { |request, response|<br/><br/>        // Connect to the database<br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Error establishing connection.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust-<br/>        cookbook").collection("users");<br/><br/>        // Create cursor that finds all documents<br/>        let mut cursor = coll.find(None, None).unwrap();<br/><br/>        // Opening for the JSON string to be returned<br/>        let mut data_result = "{\"data\":[".to_owned();<br/><br/>        for (i, result) in cursor.enumerate() {<br/> <br/>        if let Ok(item) = result {<br/>          if let Some(&amp;Bson::String(ref firstname)) =<br/>          item.get("firstname") {<br/> <br/>            let string_data = if i == 0 {<br/>            format!("{},", firstname)<br/>            } else {<br/>              format!("{},", firstname)<br/>            };<br/>          data_result.push_str(&amp;string_data);<br/>        }<br/><br/> <br/>        }<br/>        }<br/><br/>        // Close the JSON string<br/>        data_result.push_str("]}");<br/>       <br/>        // Send back the result<br/>        format!("{}", data_result)<br/>        <br/>        });
</pre>
<ol start="7">
<li>Define t<span>he <kbd>POST</kbd> endpoint:</span></li>
</ol>
<pre>        router.post("/users/new", middleware! { |request,<br/>        response|<br/><br/>        // Accept a JSON string that corresponds to the User<br/>        struct<br/>        let user = request.json_as::&lt;User&gt;().unwrap();<br/><br/>        let firstname = user.firstname.to_string();<br/>        let lastname = user.lastname.to_string();<br/>        let email = user.email.to_string();<br/><br/>        // Connect to the database<br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Error establishing connection.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust<br/>        -cookbook").collection("users");<br/><br/>        // Insert one user<br/>        match coll.insert_one(doc! {<br/>        "firstname" =&gt; firstname,<br/>        "lastname" =&gt; lastname,<br/>        "email" =&gt; email<br/>        }, None) {<br/>        Ok(_) =&gt; (StatusCode::Ok, "Item saved!"),<br/>        Err(e) =&gt; return response.send(format!("{}", e))<br/>        }<br/><br/>        });
</pre>
<ol start="8">
<li>Define <span>the <kbd>DELETE</kbd> endpoint:</span></li>
</ol>
<pre>        router.delete("/users/:id", middleware! { |request,<br/>        response|<br/><br/>        format!("Hello from DELETE /users/:id")<br/><br/>        });
</pre>
<ol start="9">
<li>Declare the port at which the services will be started:</li>
</ol>
<pre>        server.utilize(router);<br/><br/>        server.listen("127.0.0.1:9000");<br/>        }
</pre>
<ol start="10">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>    cargo run</strong>
</pre>
<ol start="11">
<li>We will get the following output on the successful execution of our code in the terminal:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="74" width="487" class="image-border" src="images/435cb018-6bac-4547-816d-7c604fcd9ee5.png"/></div>
<p><span>We submit a</span> <kbd><span>GET</span></kbd> <span>request to</span> <kbd>http://127.0.0.1:9000/users</kbd><span>, as shown in the following screenshot, which fetches the user data on a successful API call, which returns</span> <kbd>{"data":[VIKI,]}</kbd> <span>from the web service created using the nickel web application framework. The data is fetched from the MongoDB records from the previous recipe where we store this data in the <kbd>rust-cookbook</kbd> database, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="262" width="795" class="image-border" src="images/93f02bc5-2d39-489f-b11e-f67253cc5b83.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we focused on getting previously-saved user data from the database. We activated <kbd>GET</kbd> requests to the <kbd>/users</kbd> endpoint for getting the data.</p>
<p><span>Starting at the top, we referenced the external</span> nickel <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>.</span> The nickel <span>is the application object and surface that holds all the public APIs. It's a struct that implements all the fundamental methods for performing all the web application tasks.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>mutable instances to a mutable variable and create a new</span> nickel <span>application object with</span> <kbd>Nickel::new()</kbd><span>, which creates an instance of nickel with default error handling. Similarly, we create a mutable router instance and assign it to</span> <kbd>Nickel::router()</kbd><span>, which will take care of handling the different endpoints.</span></p>
<p>We will be getting the <kbd>GET/users</kbd> route working, for which we will be using the different crates that we downloaded initially, which are the units of <kbd>rustc_serialize</kbd>, <kbd>bson</kbd>, and <kbd>MongoDB</kbd>.</p>
<p>Next up, we create a complex data structure, which is a <kbd>User</kbd> struct that is encodable and decodable and that represents our user data fields.</p>
<p>We first <span>establish a connection with the MongoDB service so that we can store our data, which we just parsed from the input string. We achieve this with</span> <kbd>Client::connect("localhost", 27017)</kbd>, <span>where</span> <kbd>27017</kbd> <span>is the port in which the MongoDB service is running, and the <kbd>coll</kbd> variable connected the particular collection in the database with</span> <kbd>client.db("rust-cookbook").collection("users")</kbd><span>, where</span> <kbd>rust-cookbook</kbd> <span>is the database and</span> <kbd>users</kbd> <span>is the collection. Then, we have to read through all the values in the collection, for which we create <kbd>cursor</kbd>, a mutable instance that</span> uses the <kbd>find</kbd> method to get all the documents in the <kbd>users</kbd> collection. We create a <kbd>data_result</kbd> instance, which is a JSON string that will be returned to the user after getting all the data from the collections. We then iterate over <kbd>result</kbd> with a <kbd>for</kbd> loop, where we collect the <kbd>i</kbd> index and the <kbd>Bson</kbd> form document with the cursor's <kbd>enumerate</kbd> method. We convert the value returned, which is of the <kbd>Option&lt;Result&lt;Document&gt;</kbd> type. We stringify the <kbd>firstname</kbd> field of the <kbd>item</kbd> instance using <kbd>Bson</kbd>, and push the results to the <kbd>data_result</kbd> string. In the end, we close it off the post, which we send back to the user in the <kbd>format!</kbd> macro.</p>
<p><span>Using the</span> <kbd>server.utilize</kbd> <span>method, we add the endpoints to the server instance and register the handler that will be invoked among other handlers before each request by passing the <kbd>router</kbd> instance. The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:9000</kbd><span>, where it binds and listens for connections on the given host and port.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deleting user data</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn the steps with which you can install all the dependencies, such as nickel crate, to set up and create the API, and the MongoDB Rust driver to interact with the database in our Rust project. You will also learn the commands with which you can get all the specific data required from the database. The <kbd>GET</kbd> request will fetch the <kbd>firstname</kbd> field's data, which was previously saved in the database by the <kbd>POST</kbd> method, and then, we will delete the fetched object, which makes this process an end-to-end REST API service.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will have to install the following nickel and MongoDB crates before we can go ahead and create the REST API. Follow these steps to download and set up nickel and the MongoDB service in the project:</p>
<ol>
<li>We will require the Rust compiler and any text editor to develop the Rust code snippet.</li>
<li>Create a Rust project using the <kbd>cargo</kbd> command-line tool, and enter the newly created project:</li>
</ol>
<pre><strong>      cargo new --bin sample_app &amp;&amp; cd sample_app</strong>
</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/723686d2-1ecf-45c9-978f-0409eda3e6bd.png"/></div>
<ol start="3">
<li>Open the <kbd>Cargo.toml</kbd> file in your favorite text editor and make the modification as shown in the following screenshot. Here, we are using the nickel crate, which is entered in the dependencies field:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;font-size: 1em" height="141" width="337" class="image-border" src="images/31b734ce-ea56-4c61-878e-4425763a5893.png"/></div>
<ol start="4">
<li>Install the crate in your project with the following command:</li>
</ol>
<pre><strong>    cargo build</strong>
</pre>
<ol start="5">
<li>Set up the MongoDB service in your system by following these steps:</li>
</ol>
<pre>        sudo apt-key adv --keyserver<br/>        hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10<br/><br/>        echo "deb http://repo.mongodb.org/apt/ubuntu<br/>        "$(lsb_release -sc)"/mongodb-org/3.0 multiverse" | sudo<br/>        tee /etc/apt/sources.list.d/mongodb-org-3.0.list<br/><br/>        sudo apt-get update<br/><br/>        sudo apt-get install -y mongodb-org<br/><br/>        service mongod status
</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Perform the following steps to implement this recipe:</p>
<ol>
<li>Open the <kbd>main.rs</kbd> file in the <kbd>src</kbd> directory in your preferred text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>    //-- #########################<br/>    //-- Task: Perform DELETE action<br/>    //-- Author: Vigneshwer.D<br/>    //-- Version: 1.0.0<br/>    //-- Date: 28 April 17<br/>    //-- ######################### 
</pre>
<ol start="3">
<li>Import all the required installed nickel and other supporting crates by using the <kbd>extern</kbd> keyword:</li>
</ol>
<pre>        #[macro_use]<br/>        extern crate nickel;<br/>        extern crate rustc_serialize;<br/><br/>        #[macro_use(bson, doc)]<br/>        extern crate bson;<br/>        extern crate mongodb;<br/><br/>        // Nickel<br/>        use nickel::{Nickel, JsonBody, HttpRouter, MediaType};<br/>        use nickel::status::StatusCode::{self};<br/><br/>        // MongoDB<br/>        use mongodb::{Client, ThreadedClient};<br/>        use mongodb::db::ThreadedDatabase;<br/>        use mongodb::error::Result as MongoResult;<br/><br/>        // bson<br/>        use bson::{Bson, Document};<br/>        use bson::oid::ObjectId;<br/><br/>        // rustc_serialize<br/>        use rustc_serialize::json::{Json, ToJson};
</pre>
<ol start="4">
<li>We create a <kbd>struct</kbd> named <kbd>User</kbd>, which is encodable and decodable and which models our user data:</li>
</ol>
<pre>        #[derive(RustcDecodable, RustcEncodable)]<br/>        struct User {<br/>         firstname: String,<br/>         lastname: String,<br/>         email: String<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function in which we declare the <kbd>server</kbd> instance:</li>
</ol>
<pre>        fn main() {<br/><br/>          let mut server = Nickel::new();<br/>          let mut router = Nickel::router();
</pre>
<ol start="6">
<li>Define the <kbd>GET</kbd> endpoint:</li>
</ol>
<pre>        router.get("/users", middleware! { |request, response|<br/><br/>        // Connect to the database<br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Error establishing connection.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust-<br/>        cookbook").collection("users");<br/><br/>        // Create cursor that finds all documents<br/>        let mut cursor = coll.find(None, None).unwrap();<br/><br/>        // Opening for the JSON string to be returned<br/>        let mut data_result = "{\"data\":[".to_owned();<br/><br/>        for (i, result) in cursor.enumerate() {<br/> <br/>        if let Ok(item) = result {<br/>        if let Some(&amp;Bson::String(ref firstname)) =<br/>        item.get("firstname") {<br/> <br/>        let string_data = if i == 0 {<br/>        format!("{},", firstname)<br/>        } else {<br/>        format!("{},", firstname)<br/>        };<br/>        data_result.push_str(&amp;string_data);<br/>        }<br/><br/> <br/>        }<br/>        }<br/><br/>        // Close the JSON string<br/>        data_result.push_str("]}");<br/><br/>        // Send back the result<br/>        format!("{}", data_result)<br/><br/>        });
</pre>
<ol start="7">
<li>Defin<span>e the <kbd>POST</kbd> endpoint:</span></li>
</ol>
<pre>        router.post("/users/new", middleware! { |request,<br/>        response|<br/><br/>        // Accept a JSON string that corresponds to the User<br/>        struct<br/>        let user = request.json_as::&lt;User&gt;().unwrap();<br/><br/>        let firstname = user.firstname.to_string();<br/>        let lastname = user.lastname.to_string();<br/>        let email = user.email.to_string();<br/><br/>        // Connect to the database<br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Error establishing connection.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust<br/>        -cookbook").collection("users");<br/><br/>        // Insert one user<br/>        match coll.insert_one(doc! {<br/>        "firstname" =&gt; firstname,<br/>        "lastname" =&gt; lastname,<br/>        "email" =&gt; email<br/>        }, None) {<br/>        Ok(_) =&gt; (StatusCode::Ok, "Item saved!"),<br/>        Err(e) =&gt; return response.send(format!("{}", e))<br/>        }<br/><br/>        });
</pre>
<ol start="8">
<li>Defi<span>ne the <kbd>DELETE</kbd> endpoint:</span></li>
</ol>
<pre>        router.delete("/users/:id", middleware! { |request,<br/>        response|<br/><br/>        let client = Client::connect("localhost", 27017)<br/>        .ok().expect("Failed to initialize standalone<br/>        client.");<br/><br/>        // The users collection<br/>        let coll = client.db("rust<br/>        -cookbook").collection("users");<br/><br/>        // Get the objectId from the request params<br/>        let object_id = request.param("id").unwrap();<br/><br/>        // Match the user id to an bson ObjectId<br/>        let id = match ObjectId::with_string(object_id) {<br/>        Ok(oid) =&gt; oid,<br/>        Err(e) =&gt; return response.send(format!("{}", e))<br/>        };<br/><br/>        match coll.delete_one(doc! {"_id" =&gt; id}, None) {<br/>        Ok(_) =&gt; (StatusCode::Ok, "Item deleted!"),<br/>        Err(e) =&gt; return response.send(format!("{}", e))<br/>        }<br/><br/>        });
</pre>
<ol start="9">
<li>Declare the port at which the services will be started:</li>
</ol>
<pre>        server.utilize(router);<br/><br/>        server.listen("127.0.0.1:9000");<br/>        }
</pre>
<ol start="10">
<li>Save the file and start the server with the following command from the root directory of the project:</li>
</ol>
<pre><strong>    cargo run</strong>
</pre>
<ol start="11">
<li>We will get the following screenshot as output on the successful execution of our code in the terminal:<br/>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/c5e52e3c-98e7-45c8-9297-f02833c4b741.png"/></div>
</li>
</ol>
<p>We find the <kbd>ObjectID</kbd> of the user data saved, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="images/eb54cf04-3237-4e29-a361-7f265f221be6.png"/></div>
<p>We submit a <kbd><span><span>DELETE</span></span></kbd> request to <kbd>http://127.0.0.1:9000/objectID</kbd>, as shown in the following screenshot, which deletes the user data on successful API calls, which returns <kbd>Item deleted!</kbd> from the web service created using the nickel web application framework, which deleted the data in MongoDB:</p>
<div class="CDPAlignCenter CDPAlign"><img height="275" width="793" class="image-border" src="images/9e1511b0-0a04-4a3e-9b24-144983103d11.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we focused on deleting the user data that was saved in the database. We activated <kbd>DELETE</kbd> requests to the <kbd>/users/:id</kbd> endpoint for deleting the previous records by the object ID.</p>
<p><span>Starting at the top, we referenced the external</span> nickel <span>crate using the</span> <kbd>extern</kbd> <span>keyword and loaded all of its macros with</span> <kbd>#[macro_use]</kbd><span>.</span> The nickel <span>is the application object and surface that holds all public APIs. It's a struct, which implements all the fundamental methods for performing all the web application tasks.</span></p>
<p><span>In the</span> <kbd>main</kbd> <span>function, we first assign</span> <kbd>server</kbd> <span>mutable instances to a mutable variable and create a new</span> nickel <span>application object with</span> <kbd>Nickel::new()</kbd><span>, which creates an instance of nickel with default error handling. Similarly, we create a mutable router instance and assign it to <kbd>Nickel::router()</kbd>, which will take care of handling the different endpoints.</span></p>
<p>We will be getting the <kbd>DELETE /users/:id</kbd> route working, for which we will be using the different crates that we downloaded initially, which are the units of <kbd>rustc_serialize</kbd>, <kbd>bson</kbd>, and <kbd>MongoDB</kbd>.</p>
<p>Next up, we create a complex data structure, which is a <kbd>User</kbd> struct that is encodable and decodable and that represents our user data fields.</p>
<p><span>This is the final step for this end-to-end API, where we allow the <kbd>users</kbd> collection elements to be deleted by their <kbd>objectId</kbd>. We can do this with the MongoDB Rust driver's <kbd>delete_one</kbd> method.</span></p>
<p><span>We first</span> <span>establish a connection with the MongoDB service so that we can store our data, which we just parsed from the input string. We achieve this with</span> <kbd>Client::connect("localhost", 27017)</kbd>, <span>where</span> <kbd>27017</kbd> <span>is the port in which the MongoDB service is running, and the <kbd>coll</kbd> variable connected the particular collection in the database with</span> <kbd>client.db("rust-cookbook").collection("users")</kbd><span>, where</span> <kbd>rust-cookbook</kbd> <span>is the database and</span> <kbd>users</kbd> <span>is the collection.</span></p>
<p>We get the <kbd>objectId</kbd> from the request parameters and assign it to <kbd>object_id</kbd> with <kbd>request.param("id").unwrap()</kbd>. Then, we use the <kbd>ObjectId::with_string</kbd> helper to decode the string representation of the <kbd>objectId</kbd>, after which it can be used in the <kbd>delete_one</kbd> method to remove the document for that user. With the <kbd>DELETE /users/:id</kbd> route in place, we should be able to remove <kbd>users</kbd> from the database when we make a request to it and include <kbd>objectId</kbd> as a parameter.</p>
<p><span>Using the</span> <kbd>server.utilize</kbd> <span>method, we add the endpoints to the server instance and register the handler that will be invoked among other handlers before each request, by passing the <kbd>router</kbd> instance. The</span> <kbd>server.listen</kbd> <span>method listens to the API requests on</span> <kbd>127.0.0.1:9000</kbd><span>, where it binds and listens for connections on the given host and port.</span></p>
<div class="packt_tip">Consider posting multiple data entries using the <kbd>POST</kbd> web service to store data values in the MongoDB with different <kbd>ObjectID</kbd>, and delete them using the service developed in this recipe to better understand the delete web service working.</div>


            </article>

            
        </section>
    </div>
</body>
</html>