<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Starting with Rust" id="aid-DB7S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Starting with Rust</h1></div></div></div><p>Rust <a id="id0" class="indexterm"/>is a programming language that is developed by Mozilla Research and backed up by a big open source community. Its development started in 2006 by language designer Graydon Hoare. Mozilla began sponsoring it in 2009, and it was first presented officially in 2010. The work on it went through a lot of iterations, culminating on May 15 2015 with the first stable production version 1.0.0, which was made by the Rust Project Developers who consisted of the Rust team at Mozilla and an open source community of over 900 contributors. Rust is based on clear and solid principles. It is a systems programming language, equaling C and C++ in its capabilities. It rivals idiomatic C++ in speed, but it lets you work in a much safer way by forbidding the use of code that could cause program crashes due to memory problems. Moreover, Rust has the built-in functionality necessary for concurrent execution on multicore machines; it makes concurrent programming memory safe without garbage collection—it is the only language that does this. Rust also eliminates the corruption of shared data through concurrent access, also known as data races.</p><p>This chapter will present you with the main reasons why Rust's popularity and adoption are steadily increasing. Then, we'll set up a working Rust development environment.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The advantages of Rust</li><li class="listitem">The trifecta of Rust: safety, speed, and concurrency</li><li class="listitem">Using Rust</li><li class="listitem">Installing Rust</li><li class="listitem">The Rust compiler – <code class="literal">rustc</code></li><li class="listitem">Building our first program</li><li class="listitem">Working with Cargo</li><li class="listitem">Developer tools </li></ul></div><div class="section" title="The advantages of Rust"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The advantages of Rust</h1></div></div></div><p>Mozilla is the company that is known for its mission to develop tools for and drive the evolution of the Web based on open standards, most notably through its flagship browser Firefox. Every browser today, including Firefox, is written in C++ by using some 12,900,992 lines of code for Firefox and 4,490,488 lines of code for Chrome. This enables programs to be fast, but it is inherently <a id="id1" class="indexterm"/>unsafe because the memory manipulations allowed by C and C++ are not checked for validity. If the code is written without the utmost programming discipline on the part of the developers, then program crashes, memory leaks, segmentation faults, buffer overflows, and null pointers can occur at program execution. Some of these can result in serious security vulnerabilities, which are all too well-known in existing browsers. Rust is designed from the ground up to avoid these kinds of problems.</p><p>On the other side of the programming-language spectrum, we have Haskell, which is widely known to be a very safe and reliable language, but with very little or no control of the level of memory allocation and other hardware resources. We can plot different languages along this control—safety axis, and it seems that when a language is safer, it loses low-level control; the inverse is also true: a language that gives more control over resources provides much less safety, shown as follows:</p><div class="mediaobject"><img src="../Images/image00168.jpeg" alt="The advantages of Rust"/></div><p style="clear:both; height: 1em;"> </p><p>Rust (<a class="ulink" href="http://www.rust-lang.org/">http://www.rust-lang.org/</a>) is made <a id="id2" class="indexterm"/>to overcome this dilemma by providing the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">High safety through its strong type system</li><li class="listitem">Deep but safe control over low-level resources (as much as C/C++) so that it runs close to the hardware</li></ul></div><p>Rust lets you specify exactly how your values should be laid out in memory and how that memory should be managed; this is why it works well at both ends of the control and safety line. This is the unique selling point of Rust: it breaks the safety-control dichotomy that, before Rust, existed in programming languages. With Rust, control and safety can be achieved together without losing performance.</p><p>Rust can accomplish both these goals without a garbage collector, in contrast to most modern languages such as Java, C#, Python, Ruby, Go; in fact Rust doesn't even have a garbage collector yet (though one is planned). Rust is a compiled language: the strict safety rules are enforced by the compiler so that they do not cause runtime overhead. As a consequence, Rust can work with minimal runtime or even no runtime at all; so, it can be used for real time or embedded projects, and it can easily integrate with other languages or projects.</p><p>Rust is meant for <a id="id3" class="indexterm"/>developers and projects where not only performance and low-level optimizations are important, but where there is also a need for a safe and stable execution environment. Moreover, Rust adds a lot of high-level functional programming techniques within the language so that it feels like a low-level and a high-level language at the same time.</p></div></div>
<div class="section" title="The trifecta of Rust &#x2013; safety, speed, and concurrency" id="aid-E9OE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The trifecta of Rust – safety, speed, and concurrency</h1></div></div></div><p>Rust is not a revolutionary <a id="id4" class="indexterm"/>language with new cutting-edge features, but it incorporates a lot of proven techniques from older languages while massively improving upon the design of C++ in matters of safe programming.</p><p>The Rust developers designed Rust to be a general-purpose and multi-paradigm language. Like C++, it is an imperative, structured, and object-oriented language. Besides this, it inherits a lot from functional languages and also incorporates advanced techniques for concurrent programming.</p><p>In Rust, the typing of variables is static (because Rust is compiled) and strong. However, unlike Java or C++, the developer is not forced to indicate the types for everything as the Rust compiler is able to infer the types in many cases.</p><p>C and C++ are known to be haunted by a series of problems that often lead to program crashes or memory leaks which are notoriously difficult to debug and solve. Think about dangling pointers, buffer overflows, null pointers, segmentation faults, data races, and so on. The Rust compiler (called <code class="literal">rustc</code>) is very intelligent and can detect all these problems while compiling your code, thereby guaranteeing memory safety during execution. This is done by the compiler by retaining complete control over memory layout, without needing the runtime burden of garbage collection (see <a class="link" title="Chapter 6. Pointers and Memory Safety" href="part0056.xhtml#aid-1LCVG2">Chapter 6</a>, <span class="emphasis"><em>Pointers and Memory Safety</em></span>). In addition, its safety also implies much less possibilities for security breaches.</p><p>Rust compiles native code like Go and Julia. However, in contrast to these two, Rust doesn't need runtime with garbage collection. In this respect, it also differs from Java JVM and the languages that run on the JVM, such as Scala and Clojure. Most other popular modern languages such as .NET with C# and F#, JavaScript, Python, Ruby, Dart, and so on, all need a virtual machine and garbage collection.</p><p>As one of its mechanisms for concurrency, Rust adopts the well-known actor model from Erlang. Lightweight processes called threads perform work in parallel. They do not share heap memory but communicate data through channels, and data races are eliminated by the type system (see <a class="link" title="Chapter 8. Concurrency and Parallelism" href="part0065.xhtml#aid-1TVKI2">Chapter 8</a>, <span class="emphasis"><em>Concurrency and Parallelism</em></span>). These primitives make it easy for programmers to leverage the power of many CPU cores that are available on current and future computing platforms.</p><p>The <code class="literal">rustc</code> compiler is completely self hosted, which means that it is written in Rust and can compile itself by using a previous version. It uses the LLVM compiler framework as its backend (for more information on<a id="id5" class="indexterm"/> LLVM compiler framework, go to <a class="ulink" href="http://en.wikipedia.org/wiki/LLVM">http://en.wikipedia.org/wiki/LLVM</a>) and produces natively executable code that runs blazingly fast because it compiles to the same low-level code as C++ (To see an example of its speed, go to <a class="ulink" href="http://benchmarksgame.alioth.debian.org/u64q/rust.php">http://benchmarksgame.alioth.debian.org/u64q/rust.php</a>.).</p><p>Rust is designed to be <a id="id6" class="indexterm"/>as portable as C++ and run on widely used hardware and software platforms; at present, it runs on Linux, Mac OS X, Windows, FreeBSD, Android, and iOS. It can call C's code as simply and efficiently as C can call its own code, and conversely, C can also call Rust code (see <a class="link" title="Chapter 9. Programming at the Boundaries" href="part0069.xhtml#aid-21PMQ1">Chapter 9</a>, <span class="emphasis"><em>Programming at the Boundaries</em></span>). The following is the logo of Rust:</p><div class="mediaobject"><img src="../Images/image00169.jpeg" alt="The trifecta of Rust – safety, speed, and concurrency"/></div><p style="clear:both; height: 1em;"> </p><p>Other Rust characteristics that will be discussed in more detail in later chapters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Its variables are immutable by default (see <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <span class="emphasis"><em>Using Variables and Types</em></span>)</li><li class="listitem">Enums (see <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <span class="emphasis"><em>Structuring Data and Matching Patterns</em></span>)</li><li class="listitem">Pattern matching (see <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <span class="emphasis"><em>Structuring Data and Matching Patterns</em></span>)</li><li class="listitem">Generics (see <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <span class="emphasis"><em>Generalizing Code with Higher-order Functions and Parametrization</em></span>)</li><li class="listitem">Higher-order functions and closures (see <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <span class="emphasis"><em>Generalizing Code with Higher-order Functions and Parametrization</em></span>)</li><li class="listitem">The interface system called traits (see <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <span class="emphasis"><em>Generalizing Code with Higher-order Functions and Parametrization</em></span>)</li><li class="listitem">A hygienic macro system (see <a class="link" title="Chapter 7. Organizing Code and Macros" href="part0062.xhtml#aid-1R42S2">Chapter 7</a>, <span class="emphasis"><em>Organizing Code and Macros</em></span>)</li><li class="listitem">Zero-cost abstractions, which means that Rust has higher-language constructs, but these do not have an impact on performance</li></ul></div><p>In conclusion, Rust gives <a id="id7" class="indexterm"/>you ultimate power over memory allocation as well as removing many security and stability problems that are commonly associated with native languages.</p><div class="section" title="Comparison with other languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Comparison with other languages</h2></div></div></div><p>Dynamic languages <a id="id8" class="indexterm"/>such as Ruby or Python give you the initial coding speed, but you pay the price later when you have to write more tests, runtime crashes, or even production outages. The Rust compiler forces you to get a lot of things right at compile-time, which is the least expensive place to identify and fix bugs.</p><p>Rust's object orientation is not that explicit or evolved as common object-oriented languages such as Java, C#, and Python as it doesn't have classes. Compared with Go, Rust gives you more control over memory and resources, so lets you code on a lower level. Go also works with a garbage collector, and it has no generics or a mechanism to prevent data races between its goroutines that are used in concurrency. Julia is focused on numerical computing performance; it works with a JIT compiler and doesn't give you that low-level control that Rust gives.</p></div></div>
<div class="section" title="Using Rust" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using Rust</h1></div></div></div><p>It is clear from the <a id="id9" class="indexterm"/>previous sections that Rust can be used in projects that normally use C or C++. Indeed, many regard Rust as a successor or a replacement of C and C++. Although Rust is designed to be a systems language, it has a broad range of possible applications due to its richness of constructs, making it an ideal candidate for applications that fall into one or all of the following categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Client applications, such as browsers</li><li class="listitem">Low-latency, high-performance systems, such as device drivers, games, and signal processing</li><li class="listitem">Highly distributed and concurrent systems, such as server applications</li><li class="listitem">Real-time and critical systems, such as operating systems or kernels</li><li class="listitem">Embedded systems (that require a very minimal runtime footprint) or a resource-constrained environment, such as a Raspberry Pi, Arduino, or robotics</li><li class="listitem">Tools or services that can't support the long warm-up delays that are common in <span class="strong"><strong>Just In Time</strong></span> (<span class="strong"><strong>JIT</strong></span>)<a id="id10" class="indexterm"/> compiler systems and need instantaneous startup</li><li class="listitem">Web frameworks</li><li class="listitem">Large-scale, high-performance, resource intensive, and complex software systems</li></ul></div><p>Rust is especially<a id="id11" class="indexterm"/> suited when code quality is important, that is for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Modestly-sized or larger developer teams</li><li class="listitem">Code for long-running production use</li><li class="listitem">Code with a longer lifetime that requires regular maintenance and refactoring</li><li class="listitem">Code for which you would normally write a lot of unit tests to safeguard it</li></ul></div><p>Even before the appearance of Rust 1.0, two companies already use it in production:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">OpenDNS (<a class="ulink" href="http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/">http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/</a>) is a <a id="id12" class="indexterm"/>middleware tool for blocking malware and malicious domains</li><li class="listitem">Skylight (<a class="ulink" href="https://www.skylight.io/">https://www.skylight.io/</a>) from the<a id="id13" class="indexterm"/> company Tilde<a id="id14" class="indexterm"/> (<a class="ulink" href="http://www.tilde.io/">http://www.tilde.io/</a>) is a tool for monitoring the execution of Rails apps.</li></ul></div><div class="section" title="Servo"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Servo</h2></div></div></div><p>Mozilla uses Rust as the language for <a id="id15" class="indexterm"/>writing Servo, its new web browser engine that is designed for <a id="id16" class="indexterm"/>parallelism and safety (<a class="ulink" href="https://github.com/servo/servo">https://github.com/servo/servo</a>).</p><p>Due to the design of Rust's compiler, many kinds of browser security bugs are prevented automatically. In 2013, Samsung got involved, porting Servo to Android and ARM processors. Servo itself is an open source project with more than 200 contributors. It is under heavy development, and among other things, it has already implemented its own CSS3 and HTML5 parser in Rust. It passed the web compatibility browser test <a id="id17" class="indexterm"/>ACID2 in March 2014 (<a class="ulink" href="http://en.wikipedia.org/wiki/Acid2/">http://en.wikipedia.org/wiki/Acid2/</a>).</p></div></div>
<div class="section" title="Installing Rust" id="aid-G6PI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing Rust</h1></div></div></div><p>The Rust <a id="id18" class="indexterm"/>compiler and tools can be <a id="id19" class="indexterm"/>downloaded from <a class="ulink" href="http://www.rust-lang.org/install.html">http://www.rust-lang.org/install.html</a> in the binary (that is, executable) form. The platform comes for the three major operating systems (Linux 2.6.18 or a later version, OS X 10.7 or a later version, and Windows 7, Windows 8, and Windows Server 2008 R2) in both the 32- and 64-bit formats, and it is delivered as an installer or in an archive format. You should use the current official stable release 1.0 when you engage in professional work with Rust. If you would like to investigate or use the latest developments, install the nightly build version.</p><p>For Windows, double-click on the <code class="literal">.exe</code> installer to install the Rust binaries and dependencies. Adding Rust's directory to the search path for executables is an optional part of the installation, so make sure that this option is selected.</p><p>For Linux and <a id="id20" class="indexterm"/>Mac OS X, the simplest way is to run the following command in your shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -sSL https://static.rust-lang.org/rustup.sh | sh</strong></span>
</pre></div><p>Verify the correctness of the installation by showing Rust's version with <code class="literal">rustc –V</code> or <code class="literal">rustc - -version</code>, which produces an output like <code class="literal">rustc 1.0.0-beta (9854143cb 2015-04-02) (built 2015-04-02)</code>.</p><p>Rust can be uninstalled by running <code class="literal">C:\Rust\unins001.exe</code> on Windows or <code class="literal">/usr/local/lib/rustlib/uninstall.sh</code> on Linux.</p><p>Rust has also been ported to Android OS on ARM processors and iOS.</p><p>A bare metal stack called zinc<a id="id21" class="indexterm"/> for running Rust in embedded environments can be found at <a class="ulink" href="http://zinc.rs/">http://zinc.rs/</a>. However, at this moment, only the ARM architecture is supported by it.</p><p>The source code resides on GitHub<a id="id22" class="indexterm"/> (<a class="ulink" href="https://github.com/rust-lang/rust/">https://github.com/rust-lang/rust/</a>) and if you want to build Rust from source, we refer you to <a class="ulink" href="https://github.com/rust-lang/rust#building-from-source">https://github.com/rust-lang/rust#building-from-source</a>.</p></div>
<div class="section" title="The Rust compiler &#x2013; rustc" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The Rust compiler – rustc</h1></div></div></div><p>The Rust installation directory containing <code class="literal">rustc</code> can be found on your machine in the following folder:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In Windows, at <code class="literal">C:\Program Files\Rust 1.0\bin</code> or a folder of your choice</li><li class="listitem">On Linux or Mac OS X, it can be found by navigating to <code class="literal">/usr/local/bin</code></li></ul></div><p>If the Rust home folder was added to the search path for executables, <code class="literal">rustc</code> can be run from any command-line window. The Rust libraries can be found in the <code class="literal">rustlib</code> subfolder of the <code class="literal">bin</code> directory on Windows, or in <code class="literal">/usr/local/lib/rustlib</code> on Linux. Its HTML documentation can be found at <code class="literal">C:\Rust\share\doc\rust\html</code> on Windows or <code class="literal">/usr/local/share/doc/html</code> on Linux.</p><p>The <code class="literal">rustc</code> command<a id="id23" class="indexterm"/> has the following format: <code class="literal">rustc [options] input</code>.</p><p>The options are one letter directives for the compiler after a dash, such as <code class="literal">-g</code> or <code class="literal">-W</code>, or words prefixed by a double dash, such as <code class="literal">- -test</code> or <code class="literal">- -no-analysis</code>. All the options with some explanation are shown when invoking <code class="literal">rustc -h</code>. In the next section, we will verify our installation by compiling and running our first Rust program.</p></div>
<div class="section" title="Our first program" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Our first program</h1></div></div></div><p>Let's get started by showing a<a id="id24" class="indexterm"/> welcome message to the players of our game:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open your favorite text editor (such as notepad or gedit) for a new file and type in the following code:<div class="informalexample"><pre class="programlisting">// code in Chapter1\code\welcome.rs
<span class="strong"><strong>fn main() {</strong></span>
<span class="strong"><strong>    println!("Welcome to the Game!");</strong></span>
}</pre></div></li><li class="listitem">Save the file as <code class="literal">welcome.rs</code>.<p>
<code class="literal">rs</code> is the standard extension of Rust code files. Source file names may not contain spaces; if they contain more than one word, use an underscore <code class="literal">_</code> as a separator; for example, <code class="literal">start_game.rs</code>.</p></li><li class="listitem">Then, compile it to native code on the command line with the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>rustc welcome.rs</strong></span>
</pre></div><p>This produces an executable program <code class="literal">welcome.exe</code> on Windows or <code class="literal">welcome</code> on Linux.</p></li><li class="listitem">Run this program with <code class="literal">welcome</code> or <code class="literal">./welcome</code> to get the following output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Welcome to the Game!</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The output executable gets its name from the source file. If you want to give the executable another name, such as <code class="literal">start</code>, compile it with the <code class="literal">-o output_name</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>rustc welcome.rs -o start</strong></span>
</pre></div><p>The <code class="literal">rustc –O</code> command produces a native code that is optimized for execution speed (which is equivalent to <code class="literal">rustc -C opt-level=2</code>; the most optimized code is generated for <code class="literal">rustc –C opt-level = 3</code>).</p><p>Compiling and running are separate, consecutive steps, contrary to dynamic languages such as Ruby or Python where these are performed in one step.</p><p>Let's explain the code a bit to you. If you have already worked in a C/Java/C# like environment, this code will seem quite familiar. As in most languages, execution of the code starts in a <code class="literal">main()</code> function, which is mandatory in an executable program.</p><p>In a larger project with many source files, the file containing the <code class="literal">main()</code> function would be called <code class="literal">main.rs</code> by convention.</p><p>We can see that <code class="literal">main()</code> is a function declaration because it is preceded by the keyword <code class="literal">fn</code>, which is short and elegant like most Rust keywords. <code class="literal">()</code> after main denotes the parameter list, which is empty here. The function's code is placed in a code block, which is surrounded by curly braces (<code class="literal">{ }</code>) where the opening brace is put by convention on the same line as the function declaration, but it is separated by one space. The closing brace appears after the code here, right beneath <code class="literal">fn</code>.</p><p>Our program has only <a id="id25" class="indexterm"/>one line, which is indented by four spaces to improve readability (Rust is not whitespace sensitive). This line prints the string, "Welcome to the Game!". Rust recognizes this as a string because it is surrounded by double quotes (<code class="literal">" "</code>). This string was given as an argument to the <code class="literal">println!</code> macro (<code class="literal">!</code> indicates that it is a macro and not a function). The code line ends with a semicolon (<code class="literal">;</code>), as most, but not all, code lines in Rust do (see <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <span class="emphasis"><em>Using Variables and Types</em></span>).</p><p>Perform the following exercises:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Write, compile, and execute a Rust program <code class="literal">name.rs</code> that prints out your name.</li><li class="listitem">What is the smallest possible program in Rust in terms of code size?</li></ul></div><p>The <code class="literal">println!</code> macro has some nice formatting capabilities and at the same time checks when compiling whether the type of variables is correct for the applied formatting (see <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <span class="emphasis"><em>Using Variables and Types</em></span>).</p></div>
<div class="section" title="Working with Cargo"><div class="titlepage" id="aid-J2B82"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Working with Cargo</h1></div></div></div><p>Cargo is <a id="id26" class="indexterm"/>Rust's package and dependency manager, and it is similar to Bundler, npm, pub, or pip for other languages. Although you can write Rust programs without it, Cargo is nearly indispensable for any large project; it works the same whether you work on a Windows, Linux, or a Mac OS X system. The installation procedure from the previous section includes the Cargo tool, so Rust is shipped with tooling included.</p><p>Cargo does the following things for you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It makes a tidy folder structure and some templates for your project with the <code class="literal">cargo new</code> command</li><li class="listitem">It compiles (builds) your code by using the <code class="literal">cargo build</code> command</li><li class="listitem">It runs your project by using <code class="literal">cargo run</code></li><li class="listitem">If your project contains unit tests, it can execute them for you by using <code class="literal">cargo test</code></li><li class="listitem">If your project depends on packages, it will download them and build these packages according to the needs of your code by using <code class="literal">cargo update</code></li></ul></div><p>We'll introduce how to use Cargo<a id="id27" class="indexterm"/> now, and we'll come back to it later, but you can find more info here: <a class="ulink" href="http://doc.crates.io/guide.html">http://doc.crates.io/guide.html</a>.</p><p>Let's remake <a id="id28" class="indexterm"/>our first project <code class="literal">welcomec</code> using Cargo by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start a new project <code class="literal">welcomec</code> using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cargo new welcomec --bin</strong></span>
</pre></div><p>The <code class="literal">––bin</code> option tells Cargo that we want to make an executable program (a binary). This creates the following directory structure:</p><div class="mediaobject"><img src="../Images/image00170.jpeg" alt="Working with Cargo"/></div><p style="clear:both; height: 1em;"> </p><p>A folder with the same name as the project is created; in this folder, you can put all kinds of general information such as a <code class="literal">License</code> file, a <code class="literal">README</code> file, and so on. In addition, a <code class="literal">src</code> subfolder is created that contains a template source file named <code class="literal">main.rs</code>. (This contains the same code as our <code class="literal">welcome.rs</code> file, but it prints out the string "Hello world!".)</p><p>The file <code class="literal">Cargo.toml</code> (with capital C) is the configuration file or manifest of your project; it contains all the metadata that Cargo needs to compile your project. It follows the so-called TOML format<a id="id29" class="indexterm"/> (for more details about this format, go to <a class="ulink" href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>) and contains the following text with information about our project:</p><div class="informalexample"><pre class="programlisting">[package]
name = "welcomec"
version = "0.0.1"
authors = ["Your name &lt;you@example.com&gt;"]"</pre></div><p>This file is<a id="id30" class="indexterm"/> editable, so other sections can be added. For example, you can add a section to tell Cargo that we want a binary with the name welcome:</p><div class="informalexample"><pre class="programlisting">[[bin]]
name = "welcome"</pre></div></li><li class="listitem">We can build our project (no matter how many source files it contains) using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cargo build</strong></span>
</pre></div><p>This gives us the following output (on Linux):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Compiling welcomec v0.0.1 (file:///home/ivo/Rust_Book/welcomec)</strong></span>
</pre></div><p>Now, the following folder structure is produced:</p><div class="mediaobject"><img src="../Images/image00171.jpeg" alt="Working with Cargo"/></div><p style="clear:both; height: 1em;"> </p><p>The directory target contains the executable <code class="literal">welcome</code>.</p></li><li class="listitem">To execute this program, run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cargo run</strong></span>
</pre></div><p>This produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running `target/welcome`</strong></span>
<span class="strong"><strong>Hello, world!</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>Step 2 has also produced a file named <code class="literal">Cargo.lock</code>; this is used by Cargo to keep track of dependencies in your application. At the moment, the application only contains:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[root]</strong></span>
<span class="strong"><strong>name = "welcomec"</strong></span>
<span class="strong"><strong>version = "0.0.1"</strong></span>
</pre></div><p>The same file<a id="id31" class="indexterm"/> format is used to lock down the versions of libraries or packages that your project depends on. If your project is built in the future when updated versions of the libraries are available, Cargo will make sure that only the versions recorded in <code class="literal">Cargo.lock</code> are used so that your project is not built with an incompatible version of a library. This ensures a repeatable build process.</p><p>Perform the following exercise:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Make, build, and run a project <code class="literal">name</code> that prints out your name with Cargo.</li></ul></div><p>The website at <a class="ulink" href="https://crates.io/">https://crates.io/</a> is the central repository for Rust packages or crates (as they are called) and contained 1700 crates as of the end of March 2015. You can search for crates using specific terms or browse them alphabetically or according to the number of downloads:</p><div class="mediaobject"><img src="../Images/image00172.jpeg" alt="Working with Cargo"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="The developer tools" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>The developer tools</h1></div></div></div><p>Since Rust is a systems <a id="id32" class="indexterm"/>programming language, the only thing that you need is a good text editor (but not a word processor!) for writing the source code, and everything else can be done by commands in a terminal session. However, some developers appreciate the functionalities offered by more fully fledged text editors which are specifically for programming or IDE's (short for integrated development environments). Rust is still young but a lot of possibilities have already come up on this front although some of them need to be updated in the latest Rust version.</p><p>Rust plugins exist for a host of text editors, such as Atom, Brackets, BBEdit, Emacs, Geany, GEdit, Kate, TextMate, Textadept, Vim, NEdit, Notepad++, and SublimeText. Most Rust developers work with Vim or Emacs. These come with a syntax highlighting, and code completion tool called<a id="id33" class="indexterm"/> racer; go to <a class="ulink" href="https://github.com/phildawes/racer">https://github.com/phildawes/racer</a>.</p><div class="section" title="Using Sublime Text"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Using Sublime Text</h2></div></div></div><p>The plugins <a id="id34" class="indexterm"/>for the popular <a id="id35" class="indexterm"/>Sublime Text<a id="id36" class="indexterm"/> editor (<a class="ulink" href="http://www.sublimetext.com/3">http://www.sublimetext.com/3</a>) are particularly pleasant to work with, and they don't get in your way. After you have installed Sublime Text (you might want to get a registered version), you must also install the Package Control package<a id="id37" class="indexterm"/>. (For instructions on how to do this, go to <a class="ulink" href="https://packagecontrol.io/installation">https://packagecontrol.io/installation</a>).</p><p>Then, to install the Sublime Text Rust plugin, open the palette in Sublime Text (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> or <span class="emphasis"><em>cmd</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> on Mac OS X) and select <span class="strong"><strong>Package Control</strong></span> | <span class="strong"><strong>Install Package</strong></span>. Then, select <span class="strong"><strong>Rust</strong></span> from the list, you will see something like the following screenshot:</p><div class="mediaobject"><img src="../Images/image00173.jpeg" alt="Using Sublime Text"/></div><p style="clear:both; height: 1em;"> </p><p>Sublime Text <a id="id38" class="indexterm"/>is a very comprehensive text editor, which includes color schemes. The Rust plugin provides syntax highlighting and auto-completion. Type one or more letters, choose an option from the list that appears with an arrow key and press <span class="emphasis"><em>Tab</em></span> to insert the code snippet, or simply select a list-option through a mouse click. To compile and execute Rust code, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Mark <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Build System</strong></span> | <span class="strong"><strong>Rust</strong></span> in the menu.</li><li class="listitem">Then, you can compile a source file by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>B</em></span>. Warnings or errors will appear in the lower pane; if everything is okay, a message similar to <span class="strong"><strong>[Finished in 0.6s]</strong></span> will appear.</li><li class="listitem">Then, you can run the program by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span>; again the output will appear beneath the code. Alternatively, you can use the menu items: <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Build</strong></span> and <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Run</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>A SublimeLinter plugin exists that provides an interface to rustc, which is called <code class="literal">SublimeLinter-contrib-rustc</code>. It does additional checks on your code for stylistic or programming errors. You can install it, as explained earlier, through Package Control and then use it from the menu <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>SublimeLinter</strong></span>. (For more details, go to <a class="ulink" href="https://github.com/oschwald/SublimeLinter-contrib-rustc">https://github.com/oschwald/SublimeLinter-contrib-rustc</a>.) There is also a code completion tool called <span class="emphasis"><em>racer</em></span>; you can find<a id="id39" class="indexterm"/> the information on how to install it at <a class="ulink" href="https://packagecontrol.io/packages/RustAutoComplete">https://packagecontrol.io/packages/RustAutoComplete</a>.</p></div><div class="section" title="Other tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Other tools</h2></div></div></div><p>
<span class="emphasis"><em>RustDT</em></span> (<a class="ulink" href="http://rustdt.github.io/">http://rustdt.github.io/</a>) is a new and promising Rust IDE based on Eclipse. On top of all the editing functionality offered by Eclipse, it is project-based using Cargo. Moreover it has code completion and debugging functionality (using the GDB debugger).</p><p>There are also plugins such as the following ones for IDEs at different states of completion:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The<a id="id40" class="indexterm"/> <span class="emphasis"><em>RustyCage</em></span> plugin (<a class="ulink" href="https://github.com/reidarsollid/RustyCage">https://github.com/reidarsollid/RustyCage</a>) for Eclipse</li><li class="listitem">The <span class="emphasis"><em>idea-rust</em></span> plugin<a id="id41" class="indexterm"/> (<a class="ulink" href="http://plugins.jetbrains.com/plugin/7438">http://plugins.jetbrains.com/plugin/7438</a>) for IntelliJ</li><li class="listitem">The <span class="emphasis"><em>rust-netbeans</em></span> plugin<a id="id42" class="indexterm"/> (<a class="ulink" href="https://github.com/azazar/rust-netbeans">https://github.com/azazar/rust-netbeans</a>) for NetBeans</li><li class="listitem">The <span class="emphasis"><em>VisualRust</em></span> plugin<a id="id43" class="indexterm"/> (<span class="emphasis"><em>https://github.com/PistonDevelopers/VisualRust</em></span>) for Visual Studio</li></ul></div><p>You can test out the Rust<a id="id44" class="indexterm"/> code even without local installation with the Rust Play Pen: <a class="ulink" href="http://play.rust-lang.org/">http://play.rust-lang.org/</a>. Here you can edit or paste your code, and evaluate it.</p><p>The <span class="emphasis"><em>rusti</em></span><a id="id45" class="indexterm"/> is an interactive shell or <a id="id46" class="indexterm"/>
<span class="strong"><strong>Read-Evaluate-Print-Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) that is being developed for Rust; this is common for dynamic languages, but it is remarkable for a statically compiled language. You can <a id="id47" class="indexterm"/>find it at <a class="ulink" href="https://github.com/murarth/rusti">https://github.com/murarth/rusti</a>.</p></div></div>
<div class="section" title="Summary" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we gave you an overview of Rust's characteristics, where Rust can be applied, and compared it to other languages. We made our first program, demonstrated how to build a project with Cargo, and gave you choices to make a more complete development environment.</p><p>In the next chapter, we look at variables and types and explore the important concept of mutability.</p></div></body></html>