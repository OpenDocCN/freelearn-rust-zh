<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Concurrency in Rust</h1>
                
            
            <article>
                
<p class="calibre1">Computers have come a long way in the last 35 years or so. Originally, we had the likes of the 6502, 6809, and Z80 processors. These were known as <strong class="calibre8">single processing units</strong>; they could only run a single program at a time and software ran in a linear fashion (this meant that performing two tasks at once wasn't possible).</p>
<p class="calibre1">Processors moved on, and from the single processing units (single-core), we moved on to processors that contained multiple processing units (multi-core). Programming languages evolved to allow for this form of processor, and running multiple operations (threads) at the same time became a reality.</p>
<p class="calibre1">Rust, being a very modern language, also has this ability to multiprocess. All of the benefits are available that you would expect from Rust (such as memory safety and avoiding race conditions), but there are some other things that you need to be aware of.</p>
<p class="calibre1">In this chapter, we will:</p>
<ul class="calibre12">
<li class="calibre13">Understand the mechanisms by which Rust performs concurrent processes</li>
<li class="calibre13">Learn how to use threads</li>
<li class="calibre13">See the difference between different threading models</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A bit of a story</h1>
                
            
            <article>
                
<p class="calibre1">The Mystery Mobile was heading down a very dark road. There was no way of knowing what was ahead. At a certain point, they came to a point in the road with three roads coming off. Each road had a sign on them saying <em class="calibre9">Exit</em>. Being the intrepid type, Freddie sent Velma down one road, Shaggy and Scooby down the second and Daphne down the third. Being the brave sort, Freddie would drive down the road. They did know, though, that the roads would feed back into the main road at some point.</p>
<p class="calibre1">They agreed that whoever reached the exit first would send a message to the others. They synchronized their watches and moved off, not knowing who would reach the exit first or even if the exit could be reached at all.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What was that all about?</h1>
                
            
            <article>
                
<p class="calibre1">In roughly two paragraphs, I've illustrated three very important aspects of concurrency in Rust: <span>S</span><span>end</span> (shown in the message being sent to the others from the Mystery Mobile), <span>S</span><span>ync,</span> and T<span>hreads</span> (each road donates a thread, and really, there is no real way to know when a thread will rejoin the sender, which can cause no ends of problems!).</p>
<p class="calibre1">Let's deal with each aspect in turn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Send</h1>
                
            
            <article>
                
<p class="calibre1"><span>Send</span> transfers <span>the type </span>safely to another thread—in other words, if type <kbd class="calibre10">T</kbd> implements <span>Send</span>, then it means <kbd class="calibre10">T</kbd> has been passed safely to another thread.</p>
<p class="calibre1">There are a couple of caveats on using <span>Send</span>:</p>
<ul class="calibre12">
<li class="calibre13">You don't use it for a process that is not thread safe (such as FFI)</li>
<li class="calibre13">Send has to be implemented for the type</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sync</h1>
                
            
            <article>
                
<p class="calibre1"><span>Sync</span> is considered the uber-safe option. When <kbd class="calibre10">T</kbd> implements <span>Sync</span>, there is a guarantee of memory safety. However, before we go any further, we need to consider the following question.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">When is an immutable variable not an immutable variable?</h1>
                
            
            <article>
                
<p class="calibre1">Up to this point, we have considered variables to be either mutable or immutable, and that's it. However, this is not the case.</p>
<p class="calibre1">Consider the following:</p>
<pre class="calibre21">let mut a = 10; 
let b = &amp;mut a; </pre>
<p class="calibre1">What does this actually mean? First, we create a mutable binding to <kbd class="calibre10">a</kbd> that initially contains the value <kbd class="calibre10">10</kbd>.</p>
<p class="calibre1">Next, we create an immutable binding to <kbd class="calibre10">b</kbd> that contains a reference to the mutable value of <kbd class="calibre10">a</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">And it's obviously mutable, it has mut in the definition</h1>
                
            
            <article>
                
<p class="calibre1">Let's consider a different example:</p>
<pre class="calibre21">let vc: Vec&lt;i32&gt; = Vec::new(); 
let dup = vc.clone(); </pre>
<p class="calibre1">This example is not what it seems. When the clone trait is called, <kbd class="calibre10">vc</kbd> has to update its reference count. The problem is, <kbd class="calibre10">vc</kbd> is not mutable, yet this code compiles and runs.</p>
<p class="calibre1">To understand how, we have to know how the borrowing system works (for more information on borrowing, please refer to <span><a href="part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 8</a>, <em class="calibre9">The Rust Application Lifetime</em></span>) in this instance. Borrowing has two very clear modes of operation:</p>
<ul class="calibre12">
<li class="calibre13">One (or more) references to the resource</li>
<li class="calibre13">Exactly one mutable reference</li>
</ul>
<p class="calibre1">Really, then, when we talk about immutability, we're not really talking about whether a variable is fixed, but whether it is safe to have more than one reference to the variable. In the preceding case, the mutation occurs within the vector structure and we have the <kbd class="calibre10">&amp;T</kbd> from there.</p>
<p class="calibre1">As the vector structure is not user facing, it is called as <strong class="calibre8">exterior mutable</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interior mutability</h1>
                
            
            <article>
                
<p class="calibre1">The opposite (interior mutability) can be found in this example:</p>
<pre class="calibre21">use std::cell::RefCell; 
fn main() 
{ 
    let x = RefCell::new(42); 
    let y = x.borrow_mut(); 
} </pre>
<p class="calibre1">Here, <kbd class="calibre10">RefCell</kbd> gives the <kbd class="calibre10">&amp;mut</kbd> when <kbd class="calibre10">borrow_mut()</kbd> is called. It works well, but will cause a panic if a second <kbd class="calibre10">borrow_mut()</kbd> is called on <kbd class="calibre10">x</kbd>; you are only allowed a single reference to a mutable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to sync</h1>
                
            
            <article>
                
<p class="calibre1">For sync to occur, we cannot have any type that uses interior mutability (which also includes some of the primitive types).</p>
<p class="calibre1">When it comes to sharing across threads, Rust uses <kbd class="calibre10">Arc&lt;T&gt;</kbd>. This is a wrapper type that implements <kbd class="calibre10">send</kbd> and <kbd class="calibre10">sync</kbd> if the following condition is met: <kbd class="calibre10">T</kbd> must implement both <kbd class="calibre10">send</kbd> and <kbd class="calibre10">sync</kbd>. <kbd class="calibre10">RefCell</kbd> uses interior mutability, so <kbd class="calibre10">Arc&lt;RefCell&lt;T&gt;&gt;</kbd> won't implement <kbd class="calibre10">sync</kbd>, which also means <kbd class="calibre10">send</kbd> can't be used—therefore <kbd class="calibre10">RefCell</kbd> can't be passed around threads.</p>
<p class="calibre1">Using <kbd class="calibre10">send</kbd> and <kbd class="calibre10">sync</kbd> provides the strong guarantees of safety Rust relies upon to ensure the code is rock solid when using a threading system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A beginner's guide to threading in Rust</h1>
                
            
            <article>
                
<p class="calibre1">Threads allow multiple processes to execute at the same time. The following is a very simple example of a threaded program:</p>
<pre class="calibre21">use std::thread;  
fn main()  
{ 
    thread::spawn(||  
    { 
        println!("Hello from a thread in your Rust program"); 
    }); 
} </pre>
<div class="packt_infobox">Code files can be found in <kbd class="calibre22">Chapter11/SimpleThreadExample</kbd>.</div>
<p class="calibre1">When compiled, you may expect the <kbd class="calibre10">println!</kbd> to show. However, what you get is this:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00088.jpeg"/></div>
<div class="packt_figref">Figure 1</div>
<p class="calibre1">Why is the <kbd class="calibre10">println!</kbd> not showing?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">An easy approach to thinking about how threads work.</h1>
                
            
            <article>
                
<p class="calibre1">Threads are more easily thought of graphically (at least I think so). We start with our main thread:</p>
<div class="cdpaligncenter"><img class="image-border21" src="../images/00089.jpeg"/></div>
<div class="packt_figref">Figure 2</div>
<p class="calibre1">The main thread goes from the start of the application to the end of the application.</p>
<p class="calibre1">At any point on our main thread, we can create a new thread (or new threads, if required).</p>
<div class="cdpaligncenter"><img class="image-border22" src="../images/00090.jpeg"/></div>
<div class="packt_figref">Figure 3</div>
<p class="calibre1">These two new threads can do anything the application needs them to do. There is a simple rule though: The threads can only last as long the application does. As <em class="calibre9">Figure 3</em> shows, the threads start and carry on their merry way; there is nothing to say the thread has to rejoin the main thread, nor is there any rule to say at what point the thread returns (which can cause some very large thread safety issues, leading to panics).</p>
<p class="calibre1">It goes without saying that each thread can also spawn their own threads to perform sub-processes:</p>
<div class="cdpaligncenter"><img class="image-border23" src="../images/00091.jpeg"/></div>
<div class="packt_figref">Figure 4</div>
<p class="calibre1">If you're accustomed to threading in the likes of C, C++, and C#, you'll already know that a thread can return to the main thread at any time and that this <em class="calibre9">at any time</em> can be disastrous to the safe running of the application. It is different in Rust.</p>
<p class="calibre1">When a thread in Rust is spawned from either the main thread (or any subthread) a handle is created. Rust then uses this token to retrieve the thread at a given point; therefore, the issue of a race condition (where one thread returns before another, leading to crashes) is essentially removed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Joining threads</h1>
                
            
            <article>
                
<p class="calibre1">To retrieve the spawned thread, Rust uses the <kbd class="calibre10">join()</kbd> trait and then unwraps the result.</p>
<div class="cdpaligncenter"><img class="image-border24" src="../images/00092.jpeg"/></div>
<div class="packt_figref">Figure 5</div>
<p class="calibre1">To make our small example application output, we therefore need to join the spawned thread back to the main thread:</p>
<pre class="calibre21">use std::thread;  
fn main()  
{ 
    let threadhandle = thread::spawn(||  
    { 
        "Hello from a thread in your Rust program" 
    }); 
     
    println!("{}", threadhandle.join().unwrap()); 
} </pre>
<div class="packt_infobox">Code for the alterations can be found in <kbd class="calibre22">Chapter11/joined_thread</kbd>.</div>
<p class="calibre1">When we run the code, this time we see the following:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00093.jpeg"/></div>
<div class="packt_figref">Figure 6</div>
<p class="calibre1">Hold on. That code isn't the same! This is true, and it is due to the spawn accepting a closure (<kbd class="calibre10">||</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Closures</h1>
                
            
            <article>
                
<p class="calibre1">Closures are a powerful piece of code present in many languages. Essentially, a closure wraps code or variables used only within the scope of the current code in a neat little package.</p>
<p class="calibre1">In its simplest form, we can have something like this:</p>
<pre class="calibre21">let add = |x : i32 | x + t; </pre>
<p class="calibre1">The part within the <kbd class="calibre10">| |</kbd> defines a variable called <kbd class="calibre10">x</kbd> that is only used within the scope of the calculation, and it is of type <kbd class="calibre10">i32</kbd>.</p>
<p class="calibre1">Okay, that may not seem that useful—after all, what we're doing here is adding two numbers together. Hold on though—if <kbd class="calibre10">x</kbd> is only defined within the scope of the calculation, what does <kbd class="calibre10">x</kbd> actually equal?</p>
<p class="calibre1">This is where closures come into their own. Typically, when we create a binding, we create a binding to something definite. Here, we are creating a binding, but binding it to the content of the closure. Anything between the pipes (<kbd class="calibre10">| |</kbd>) is an argument, with the expression being whatever follows the end pipe.</p>
<p class="calibre1">If you think about it, you've actually created something closer to the following:</p>
<pre class="calibre21">fn add(x : i32) -&gt; i32 
{ 
     x + x 
} </pre>
<p class="calibre1">In answer to our question "what does <kbd class="calibre10">x</kbd> actually equal?", here it is equal to the only known parameter, <kbd class="calibre10">t</kbd>. Therefore, <kbd class="calibre10">x + t</kbd> is the same as saying <kbd class="calibre10">t + t</kbd>. The add variable isn't being bound directly (that is, in the same way that we bind under normal conditions), but is borrowing the binding. This means that we have to apply the same borrowing rules as before. Say that we have the following:</p>
<pre class="calibre21">let m = &amp;mut t; </pre>
<p class="calibre1">This will give the following error:</p>
<div class="cdpaligncenter"><img class="image-border25" src="../images/00094.jpeg"/></div>
<div class="packt_figref">Figure 7</div>
<div class="packt_infobox">You will find an example of this error in <kbd class="calibre22">Chapter 11/close_mut_error</kbd>.</div>
<p class="calibre1">The important part of the throwback is that we're trying to borrow something that is being borrowed in an immutable line. We can fix this by changing the scope of the closure, as shown here:</p>
<pre class="calibre21">let mut t = 10i32; 
{ 
    let add = |x : i32 | x + t; 
} 
let m = &amp;mut t; </pre>
<p class="calibre1">This will result in the error going.</p>
<p class="calibre1">With that in mind, we can start to expand on this. If the value between the pipes is the argument, then we can clearly do some interesting things with closures</p>
<div class="packt_infobox">The code for this part can be found in <kbd class="calibre22">Chapter11/closures</kbd>.</div>
<p class="calibre1">Take this code, for example:</p>
<pre class="calibre21">let calc = |x|  
{ 
    let mut result: i32 = x; 
    result *= 4; 
    result += 2; 
    result -= 1; 
    result 
}; </pre>
<p class="calibre1">Rather than create a whole new function, we use the closure and create the function inline with <kbd class="calibre10">result</kbd> and <kbd class="calibre10">x</kbd> only existing within the scope of the enclosure <kbd class="calibre10">{ }</kbd>.</p>
<p class="calibre1">A closure without any arguments is the inline equivalent of the following:</p>
<pre class="calibre21">fn do_something() -&gt; T { ... } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Closures aren't all they first appear to be</h1>
                
            
            <article>
                
<p class="calibre1">Closures are known as <strong class="calibre8">syntax sugar</strong> (they effectively sweeten the bitterness of whatever they coat) for the underpinning trait they cover. This makes closures in Rust different to closures in other languages.</p>
<p class="calibre1">Given this premise, we can also use closures as arguments, as well as returning them from a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Closures as function arguments</h1>
                
            
            <article>
                
<p class="calibre1">Consider the following code:</p>
<pre class="calibre21">fn call_with_three&lt;F&gt;(some_closure: F) -&gt; i32 where F : Fn(i32) -&gt; i32<br class="calibre2"/>{<br class="calibre2"/>some_closure(3)<br class="calibre2"/>}<br class="calibre2"/>fn main()<br class="calibre2"/>{<br class="calibre2"/>let answer = call_with_three(|x| x + 10 );<br class="calibre2"/>println!("{}", answer);<br class="calibre2"/>}</pre>
<div class="packt_infobox">The code for this section can be found in <kbd class="calibre22">Chapter 11/close_fn_args</kbd>.</div>
<p class="calibre1">We call <kbd class="calibre10">call_with_three</kbd> and pass in the closure as the parameter. The function <kbd class="calibre10">call_with_three</kbd> takes a parameter of type <kbd class="calibre10">F</kbd>. So far, it's no different from any other function taking a generic value as an argument. However, we're binding <kbd class="calibre10">F</kbd> to be a function of type <kbd class="calibre10">i32</kbd>, which returns a value of type <kbd class="calibre10">i32</kbd>. We have created an inline function to be a parameter for a called function! When the code is compiled, we get the expected value on screen—<span>13</span>:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00095.jpeg"/></div>
<div class="packt_figref">Figure 8</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Closures with explicit lifetimes – a special case</h1>
                
            
            <article>
                
<p class="calibre1">As we saw back in <span><a href="part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 8</a>, <em class="calibre9">The Rust Application Lifetime</em></span>, there are two main types of scope: global and local. A variable that has a local scope goes out of bounds as soon as it is finished with, whereas a global scope variable is cleaned up when the application terminates. A global scope variable is also given the lifetime marker, <kbd class="calibre10">'</kbd>.</p>
<p class="calibre1">Closures also have different scopes. Typically, they will only be for the lifetime if they are called in, but they can also be global.</p>
<p class="calibre1">A "normal" function (as shown previously) would be as follows:</p>
<pre class="calibre21">fn call_with_three&lt;F&gt;(some_closure: F) -&gt; i32 where F : Fn(i32) -&gt; i32<br class="calibre2"/>{<br class="calibre2"/>some_closure(3)<br class="calibre2"/>}</pre>
<p class="calibre1">Conversely, for a lifetime scope, we would have the following:</p>
<pre class="calibre21">fn call_with_three&lt;'a, F&gt;(some_closure: F) -&gt; i32 where F : Fn(&amp;'a 32) -&gt; i32</pre>
<p class="calibre1">However, this won't compile. The problem is with the scope.</p>
<p class="calibre1">In our first example, the scope is purely for the lifetime of the invocation. In the second, it's for the lifetime of the function (and that is for the entirety of the function), which means that the compiler will see a mutable reference at the same lifetime as the immutable reference.</p>
<p class="calibre1">Although Rust does still allow us to use this, we need to use something called a <strong class="calibre8">higher-ranked trait bounds</strong> (in simple terms, it means that, in order of importance, this trumps something below it). This works by telling the compiler to use the minimum lifetime for the closure to run, which in turn should satisfy the borrow-checker. In this case, we use <kbd class="calibre10">for&lt;...&gt;</kbd>:</p>
<pre class="calibre21">fn call_with_three&lt;'a, F&gt;(some_closure: F) -&gt; i32 where F :&lt;for 'a&gt; Fn(&amp;'a 32) -&gt; i32</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Returning a closure</h1>
                
            
            <article>
                
<p class="calibre1">As threads within Rust use a return from a closure, it makes sense for us to consider that it is entirely possible to return a closure. However, returning a closure is not as straightforward as you'd expect.</p>
<p class="calibre1">Let's consider a normal function first:</p>
<pre class="calibre21">fn add_five(x : i32) -&gt; i32  
{ 
    return x + 5; 
} 
fn main() 
{ 
    let test = add_five(5); 
    println!("{}", test); 
} </pre>
<p class="calibre1">This will output the value <kbd class="calibre10">10</kbd>. It's not rocket science. Let's change this to a closure:</p>
<pre class="calibre21">fn add_five_closure() -&gt;(Fn(i32)-&gt;i32) 
{ 
    let num = 5; 
    |x| x + num 
} 
fn main() 
{ 
    let test = add_five_closure(); 
    let f = test(5); 
    println!("{}", f); 
} </pre>
<div class="packt_infobox">The code for the example can be found in <kbd class="calibre22">Chapter 11/return_closure_one</kbd>.</div>
<p class="calibre1">When we run this, though, we don't get the expected answer of <kbd class="calibre10">10</kbd>—instead we get this:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00096.jpeg"/></div>
<div class="packt_figref">Figure 9</div>
<p class="calibre1">So what has gone wrong? When we return from a function, we have to tell the compiler the type we're returning. However, <kbd class="calibre10">Fn</kbd> is a trait, so we have to somehow satisfy this requirement. We could always have it return a reference:</p>
<pre class="calibre21">fn add_five_closure() -&gt; &amp;(Fn(i32)-&gt;i32) </pre>
<p class="calibre1">This will generate another compiler error as it needs a lifetime expectancy applied.</p>
<p class="calibre1">We could always make the function return a lifetime static reference:</p>
<pre class="calibre21">fn add_five_closure() -&gt; &amp;'static (Fn(i32) → i32) </pre>
<p class="calibre1">However, this will produce a different error, which may look somewhat confusing:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00097.jpeg"/></div>
<div class="packt_figref">Figure 10</div>
<p class="calibre1">Why are the types mismatched? It's expecting an <kbd class="calibre10">i32</kbd>, but has found a closure. Makes sense really, but why is this happening?</p>
<p class="calibre1">This is down to how Rust works. For a closure, it generates its own struct and implementation of <kbd class="calibre10">Fn</kbd> (and anything else required) therefore, we're dealing not with a literal, but something else.</p>
<p class="calibre1">Trying to return a trait object (such as <kbd class="calibre10">Box</kbd>) won't work either as the function relies on the <kbd class="calibre10">num</kbd> binding (which is stack allocated). However, if we move from the stack to the heap, we can now return the closure:</p>
<pre class="calibre21">fn add_five_closure() -&gt; Box&lt;(Fn(i32) -&gt;→ i32)&gt; 
{ 
    let num = 5; 
    Box::new(move |x| x + num) 
} 
fn main() 
{ 
    let test = add_five_closure(); 
    let f = test(5); 
    println!("{}", f); 
} </pre>
<div class="packt_infobox">The source for this can be found in <kbd class="calibre22">Chapter 11/return_closure_three</kbd>.</div>
<p class="calibre1">This will now compile and give the following:</p>
<div class="cdpaligncenter"><img class="alignnone" src="../images/00098.jpeg"/></div>
<div class="packt_figref">Figure 11</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is the move parameter?</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">move</kbd> parameter forces the closure to take ownership of whatever is contained within. Let's look at that a bit closer:</p>
<pre class="calibre21">let myNum = 10; 
let myMove = move |x: i32| x + myNum; </pre>
<p class="calibre1">Here, <kbd class="calibre10">myMove</kbd> takes ownership of <kbd class="calibre10">myNum</kbd>. The value of <kbd class="calibre10">myNum</kbd> implements <kbd class="calibre10">Copy</kbd>, which is assigned to the binding. This is the same as the operation of any variable, so there has to be something to differentiate <kbd class="calibre10">move</kbd> from anything else.</p>
<p class="calibre1">Let's look at a slightly different example and see if we can see what is actually going on:</p>
<pre class="calibre21">let mut myMutNum = 10; 
{ 
    let mut subNum = |x: i32| num -= x; 
    subNum(3);  
} </pre>
<p class="calibre1">We've seen this before, so it should not be too hard to understand. This would give the answer <kbd class="calibre10">7</kbd>. If we used <kbd class="calibre10">move</kbd>, however, the answer may not be as expected:</p>
<pre class="calibre21">fn main()  
{ 
    let mut my_mut_num = 10; 
    { 
        let mut sub_num = move |x: i32| my_mut_num -= x; 
        sub_num(3);  
    } 
    println!("{}", my_mut_num); 
} </pre>
<div class="packt_infobox">The code for this example is in <kbd class="calibre22">Chapter 11/move_closure_one</kbd>.</div>
<p class="calibre1">When compiled, you may expect the answer <kbd class="calibre10">7</kbd>, but instead you get:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00099.jpeg"/></div>
<div class="packt_figref">Figure 12</div>
<p class="calibre1">How can we have a value of <kbd class="calibre10">10</kbd>?</p>
<p class="calibre1">In the nonmove version, we borrow the value of the mutable. With <kbd class="calibre10">move</kbd>, we take ownership of a copy. In practical terms, we have created a completely new stack frame for the closure. The <kbd class="calibre10">sub_num()</kbd> call is still being executed, but when it is called, the value returned is not the expected one, but the ownership of the copy of the original value (<kbd class="calibre10">10</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to threading</h1>
                
            
            <article>
                
<p class="calibre1">Now we have seen how closures work and their importance, we can continue with threading.</p>
<p class="calibre1">If we consider <em class="calibre9"><span>Figure 5</span></em>, we can use a closure to return a value from one of the subthreads:</p>
<pre class="calibre21">use std::thread;  
fn main()  
{ 
    let x = 10; 
    thread::spawn(|| (println!("x is {}", x); )); 
} </pre>
<p class="calibre1">Will this work as is? Unfortunately not. We are borrowing <kbd class="calibre10">x</kbd>, which we can't do because of ownership problems. However, we could add <kbd class="calibre10">move</kbd> to the invocation:</p>
<pre class="calibre21">use std::thread;  
fn main()  
{ 
    let x = 10; 
    thread::spawn(move || (println!("x is {}", x); )); 
} </pre>
<p class="calibre1">The thread will take ownership of the copy of <kbd class="calibre10">x</kbd> rather than borrow the value. By taking ownership, Rust prevents a common issue with any form of threading: race conditions. If you recall, from the start of this chapter I said that conventional threading has no guarantees of when a thread will return, which can cause all sorts of issues. Typically, other languages use mutexes to try and prevent the race condition (<kbd class="calibre10">mutex</kbd> stands for mutual exclusion, which should give an idea as to how they work). By taking ownership, Rust does a lot to prevent racing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ownership has its advantages</h1>
                
            
            <article>
                
<p class="calibre1">With the Rust ownership system, we can largely negate what many other languages have issues with, that of shared mutable states. Developers in other languages would usually rather chew off their legs than have to deal with a shared mutable state; they're inherently problematic—how can you share a mutable and not have problems with the return of the thread?</p>
<p class="calibre1">Rust doesn't have this issue, as the shared part is sorted with the ownership system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The reference counter</h1>
                
            
            <article>
                
<p class="calibre1">Consider the following piece of code. It won't work because there are multiple owners of the <kbd class="calibre10">vec</kbd>:</p>
<pre class="calibre21">use std::thread; 
use std::time::Duration;  
fn main()  
{ 
    let mut my_data = vec![5, 8, 13];  
    for i in 0..10  
   { 
        thread::spawn(move || { my_data[0] += i; }); // fails here 
   } 
 
    thread::sleep(Duration::from_millis(50)); 
} </pre>
<p class="calibre1">There has to be a way to get this compile, and there is. Rust provides us with a reference counter called <kbd class="calibre10">Rc</kbd>. The reference count has to have a type associated with it, and so it is commonly quoted as <kbd class="calibre10">Rc&lt;T&gt;</kbd>. This can be used to keep track of each reference. Every time we execute a clone on the execution, the reference count is incremented (and a new owned reference created), so the compiler always knows when something is returned.</p>
<p class="calibre1">The only problem with using <kbd class="calibre10">Rc&lt;T&gt;</kbd> is that it doesn't implement send. Therefore, we use <kbd class="calibre10">Arc&lt;T&gt;</kbd> (the <kbd class="calibre10">A</kbd> stands for atomic—it is Rust's own reference count and can be accessed across threads).</p>
<p class="calibre1"><kbd class="calibre10">Arc&lt;T&gt;</kbd>, though, has its own problem: by default, the contents are immutable. You can share data with <kbd class="calibre10">Arc&lt;T&gt;</kbd>, but <em class="calibre9">shared</em> mutable values—that's a different matter. Mutable shared values give rise to race conditions and that is what we are most certainly not after.</p>
<p class="calibre1">There are alternatives to <kbd class="calibre10">Arc&lt;T&gt;</kbd> (namely <kbd class="calibre10">RefCell&lt;T&gt;</kbd> and <kbd class="calibre10">Cell&lt;T&gt;</kbd>, but neither of these implement sync, and so they can't be used with threading).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Problem solved – use Mutex</h1>
                
            
            <article>
                
<p class="calibre1">Rust provides us with <kbd class="calibre10">Mutex&lt;T&gt;</kbd>. This works in much the same way as other languages by locking the thread. We implement <kbd class="calibre10">mutex</kbd> in our code like this:</p>
<pre class="calibre21">use std::sync::{Arc, Mutex}; 
use std::thread; 
use std::time::Duration; 
fn main()  
{ 
    let primes = Arc::new(Mutex::new(vec![1,2,3,5,7,9,13,17,19,23])); 
 
    for i in 0..10  
    { 
        let primes = primes.clone(); 
        thread::spawn(move ||  
        {  
            let mut data = primes.lock().unwrap(); 
            data[0] += i;  
        }); 
    } 
    thread::sleep(Duration::from_millis(50)); 
} </pre>
<div class="packt_infobox">The code for this example is in <kbd class="calibre22">Chapter 11/mutex</kbd>.</div>
<p class="calibre1">By using <kbd class="calibre10">lock</kbd>, we only allow a single thread to have access to that data at any one time (it has mutual exclusion). No other thread has access to that value, and if any other thread tries to access the value, it has to wait until the lock is released. When data goes out of scope (when <kbd class="calibre10">i</kbd> is incremented), the lock is released.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why do we put the thread to sleep?</h1>
                
            
            <article>
                
<p class="calibre1">Usually, the use of <kbd class="calibre10">thread::sleep</kbd> allows the execution to pause for a finite amount of time as an extra protection against racing. This is not always a good plan as there isn't any real way to tell how long a thread is going to take, so it's at best a guess. As with all guesses, they can be wildly inaccurate (it is used here as we're not doing anything with the data value).</p>
<p class="calibre1">In real systems, the preferred method, to ensure that the correct amount of time is given to ensure that everything has worked is to synchronize the threads using channels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Thread synchronization</h1>
                
            
            <article>
                
<p class="calibre1">The best way to think of a channel is to see it as a walkie-talkie. At one end you have the transmitter (send) and at the other end, the receiver:</p>
<pre class="calibre21">use std::thread; 
use std::sync::mpsc; 
 
fn main() { 
    // tx = transmission = sender 
    // rx = receiver 
    let (tx, rx) = mpsc::channel(); 
 
    for i in 0..10  
    { 
        let tx = tx.clone(); 
 
        thread::spawn(move ||  
        { 
            let answer = (i * 2) * i; 
 
            tx.send(answer).unwrap(); 
        }); 
    } 
 
    for _ in 0..10  
    { 
        println!("{}", rx.recv().unwrap()); 
    } 
} </pre>
<div class="packt_infobox">The code for this example is in <kbd class="calibre22">Chapter 11/channels</kbd>.</div>
<p class="calibre1">When we run this, we get the following:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00100.jpeg"/></div>
<div class="packt_figref">Figure 13</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Thread panics</h1>
                
            
            <article>
                
<p class="calibre1">As with anything in Rust (and pretty much any language), things can go wrong and the application will throw a panic. As with any other time a panic occurs, we can use panic! to catch the panic and then test the result to see if the thread did indeed panic. We do this using a construct such as:</p>
<pre class="calibre21">let handle = thread::spawn(move || { panic! ("panic occurred"); }); 
let res = handle.join(); </pre>
<p class="calibre1">The <kbd class="calibre10">join()</kbd> will return <kbd class="calibre10">Result&lt;T,E&gt;</kbd>, which can then be checked to see if there is an exception.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">We have seen in this chapter how Rust deals with threading within an application. Be under no illusion of the power threading has and the inherent issues it gives rise to. However, when used correctly, threading can greatly improve the performance of your application. Think of a web browser if you need further proof; imagine the speed of one if everything was performed on a single thread—a simple page could take over a minute to render!</p>
<p class="calibre1">We have also looked at closures and the power behind them. Put the two together and you can appreciate how powerful threading and inline functions can be.</p>
<p class="calibre1">We're taking a break in the next chapter to access how your Rust skills are progressing with another project task that will build upon the ones performed in <span><a href="part0121.html#3JCK20-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 6</a>, <em class="calibre9">Creating Your Own Rust Applications</em></span>. After that, we'll be concluding the book with a look at the standard libraries and using external libraries to further improve your Rust applications by interfacing with them.</p>


            </article>

            
        </section>
    </body></html>