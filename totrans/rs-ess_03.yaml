- en: Chapter 3. Using Functions and Control Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrates on how we can control the execution flow of our code
    and modularize our code through functions. We will also learn how to get input
    from the console, and how to document and test our code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Branching on a condition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching on a condition
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Branching on a condition is done with a common `if`, `if-else`, or `if-else
    if-else` construct, as shown in this example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives the following output:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The condition after `if` has to be a Boolean. However, unlike in C, the condition
    must not be enclosed within parentheses. Code blocks surrounded by `{ }` (curly
    braces) are needed after `if`, `else if`, or `else`. The first example shows that
    we can get out of a function with return.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of `if-else`, as it is an expression, is that it returns a
    value. This value can be used as a function call parameter in a `print!` statement,
    or it can be assigned to a `let` binding like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code blocks can contain many lines. However, you need to be careful when
    you return a value to ensure that you omit `;` (the semicolon) after the last
    expression in the `if` or `else` block. (For more information on this, see the
    *Expressions* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*). Moreover, all branches must
    always return a value of the same type. This alleviates the need for a ternary
    operator (? :) that is needed in C++; you can simply use `if` as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As an exercise, try the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Try adding a `;` (semi-colon) after `+18` and `-18`, like this `{"+18";}` and
    find out what value will be printed for `age`. What happens if you type annotate
    `age` as `&str`?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See whether you can omit `{ }` (the curly braces) if there is only one statement
    in the block.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, verify whether this code is okay:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How would you correct this statement, if necessary? (Refer to code in `Chapter
    3/exercises/iftest.rs`.)
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Simplify the following function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (See the code in `Chapter 3\exercises\ifreturn.rs`.)
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern matching, which we will examine in the next chapter, also branches code,
    but it does this based on the value of a variable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For repeating pieces of code, Rust has the common `while` loop, again without
    parentheses around the condition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This prints the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To start an infinite loop, use `loop`, which is syntactic sugar for while true:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, all power values including `50` are printed; then the loop stops with
    `break`. However, the power value `42` is not printed because of the `continue`
    statement. So, loop is equivalent to a while true, and a loop with a conditioned
    break simulates a do while in other languages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'When loops are nested inside each other, break and continue apply to the immediate
    enclosing loop. Any `loop` statement (also `while` and `for` that we''ll see next)
    can be preceded by a label (which is denoted as `''label:`) to allow us to jump
    to the next or outer enclosing loop, as shown in this code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code prints the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The infamous `goto` from C does not exist in Rust!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Looping where a `var` variable begins from a start value `a` to an end value
    `b` (exclusive) is done with `for` over a range expression `for var in a..b` statement.
    Here is an example that prints the squares of the numbers from 1 to 10:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In general, `for in` loops over an iterator, which is an object that gives
    back a series of values one by one. The range `a..b` is the simplest form of iterator.
    Each subsequent value is bound to `n` and used in the next loop iteration. The
    `for` loop ends when there are no more values, and `n` then goes out of scope.
    If we don''t need the value of `n` in the loop, we can replace it with `_` (an
    underscore) like this: `for _ in 1..11 { }`.The many bugs in the C-style `for`
    loops, like the off-by-one error with the counter, cannot occur here because we
    loop over an iterator.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can also be used in a range, like in the following snippet that prints
    nine dots:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll examine iterators in more detail in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point of every Rust program is a `fn` function called `main()`,
    which can be further subdivided into separate functions to reuse code or for better
    code organization. Rust doesn't care about the order in which these functions
    are defined, but it is nice to put `main()` at the start of the code to get a
    better overview. Rust has incorporated many features of traditional functional
    languages; we will see examples of this in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example of a basic function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like variables, functions also have `snake_case` names that must be unique,
    and their parameters (which have to be typed) are separated by commas. In this
    code snippet, the examples are `name1: &str` and `name2: &str` (it looks like
    a binding, but without `let`).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Mandating a type to the parameters was an excellent design decision: this documents
    the function for use by its caller code and allows type inference inside the function.
    The type here is `&str` because strings are stored on the heap (see the *The stack
    and the heap* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions in the preceding code don''t return anything useful (in fact,
    they return the unit `v`alue `()`), but if we want a function to actually return
    a value, its type must be specified after an arrow(`->`), as shown in this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When executed this prints the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The return value of a function is the value of its last expression. Note that
    in order to return a value, the final expression must not end with a semicolon.
    What happens when you do end it with a semicolon? Try this out. In this case,
    the unit value `()` will be returned, and the compiler will give you the error,
    **not all control paths return a value error**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have written return power + 1; as the last line, but this is not idiomatic
    code. If we wanted to return a value from the function before the last code line,
    we have to write a return value; as shown in here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If this was the last line in the function, you would write it like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A function can return only one value, but this isn't a limitation. If we have,
    for example, three values `a`, `b`, and `c` to return, make one tuple `(a, b,
    c)` with them and return this. We will examine tuples in more detail in the next
    chapter. In Rust, you can also write a function inside another function (a so-called
    nested function), contrary to C or Java. However, this should only be used for
    small helper functions that are needed locally.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an exercise for you:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: What is wrong with the following function that returns the absolute value of
    a given number x?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You need to correct and test it. (See the code in `Chapter 3/exercises/absolute.rs`.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a function
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s show you an example of documentation. In `exdoc.rs`, we have documented
    a `cube` function as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: /// let cube = cube(val);
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE22]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now invoke `rustdoc exdoc.rs` on the command line, a `doc` folder will
    be created. This contains an `exdoc` subfolder with `index.html` that is the starting
    point of a website that provides a documentation page for each function. For example,
    `fn.cube.html` shows the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting a function](img/image00177.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: By clicking on the **exdoc** link, you can return to the index page. For a project
    that is made with the cargo package manager, issue the `cargo doc` command to
    obtain its documentation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation comments are written in markdown. They can contain the following
    special sections preceded by `#`: Examples, Panics, Failures, and Safety. A code
    appears between [PRE23] [PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: // from Chapter 3/code/attributes_cfg.rs
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: on_windows();
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '#[cfg(target_os = "windows")]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: fn on_windows() {
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: println!("This machine has Windows as its OS.")
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: // from Chapter 3/code/attributes_testing.rs
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: println!("No tests are compiled,compile with rustc --test! ");
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '#[test]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: fn arithmetic() {
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: if 2 + 3 == 5 {
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: println!("You can calculate!");
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: assert_eq!(2, power);
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#[test]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: fn badtest() {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: assert_eq!(6, 2 + 3);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#[test]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: fn it_works() {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: So a library crate is created with no code of its own, but it does contain a
    test template to augment with the unit tests that you write on the functions of
    your library. You can then run these tests with `cargo test`, which will produce
    an output similar to that produced in the previous section. The `cargo test` command
    runs tests in parallel whenever it is possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个库crate被创建出来，它本身没有自己的代码，但它包含一个测试模板，可以用来增强你为库中的函数编写的单元测试。然后你可以使用`cargo test`来运行这些测试，它将产生类似于上一节中产生的输出。`cargo
    test`命令在可能的情况下会并行运行测试。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to make basic programs by using the `if` conditions,
    `while` and `for` loops, and functions to structure our code. We were also able
    to accept input to a program. Lastly, we saw the immense power that attributes
    give to widen Rust's possibilities, and we applied this in conditional compilation
    and testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用`if`条件语句、`while`和`for`循环以及函数来结构化我们的代码，从而制作基本的程序。我们还能够接受程序输入。最后，我们看到了属性赋予Rust扩展其可能性的巨大力量，并在条件编译和测试中应用了这一点。
- en: In the next chapter, we will start using composite values and explore the powers
    of pattern matching.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用复合值并探索模式匹配的力量。
