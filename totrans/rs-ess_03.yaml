- en: Chapter 3. Using Functions and Control Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrates on how we can control the execution flow of our code
    and modularize our code through functions. We will also learn how to get input
    from the console, and how to document and test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Branching on a condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching on a condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Branching on a condition is done with a common `if`, `if-else`, or `if-else
    if-else` construct, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The condition after `if` has to be a Boolean. However, unlike in C, the condition
    must not be enclosed within parentheses. Code blocks surrounded by `{ }` (curly
    braces) are needed after `if`, `else if`, or `else`. The first example shows that
    we can get out of a function with return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of `if-else`, as it is an expression, is that it returns a
    value. This value can be used as a function call parameter in a `print!` statement,
    or it can be assigned to a `let` binding like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code blocks can contain many lines. However, you need to be careful when
    you return a value to ensure that you omit `;` (the semicolon) after the last
    expression in the `if` or `else` block. (For more information on this, see the
    *Expressions* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*). Moreover, all branches must
    always return a value of the same type. This alleviates the need for a ternary
    operator (? :) that is needed in C++; you can simply use `if` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Try adding a `;` (semi-colon) after `+18` and `-18`, like this `{"+18";}` and
    find out what value will be printed for `age`. What happens if you type annotate
    `age` as `&str`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See whether you can omit `{ }` (the curly braces) if there is only one statement
    in the block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, verify whether this code is okay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How would you correct this statement, if necessary? (Refer to code in `Chapter
    3/exercises/iftest.rs`.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Simplify the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (See the code in `Chapter 3\exercises\ifreturn.rs`.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern matching, which we will examine in the next chapter, also branches code,
    but it does this based on the value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For repeating pieces of code, Rust has the common `while` loop, again without
    parentheses around the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To start an infinite loop, use `loop`, which is syntactic sugar for while true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, all power values including `50` are printed; then the loop stops with
    `break`. However, the power value `42` is not printed because of the `continue`
    statement. So, loop is equivalent to a while true, and a loop with a conditioned
    break simulates a do while in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'When loops are nested inside each other, break and continue apply to the immediate
    enclosing loop. Any `loop` statement (also `while` and `for` that we''ll see next)
    can be preceded by a label (which is denoted as `''label:`) to allow us to jump
    to the next or outer enclosing loop, as shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The infamous `goto` from C does not exist in Rust!
  prefs: []
  type: TYPE_NORMAL
- en: 'Looping where a `var` variable begins from a start value `a` to an end value
    `b` (exclusive) is done with `for` over a range expression `for var in a..b` statement.
    Here is an example that prints the squares of the numbers from 1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, `for in` loops over an iterator, which is an object that gives
    back a series of values one by one. The range `a..b` is the simplest form of iterator.
    Each subsequent value is bound to `n` and used in the next loop iteration. The
    `for` loop ends when there are no more values, and `n` then goes out of scope.
    If we don''t need the value of `n` in the loop, we can replace it with `_` (an
    underscore) like this: `for _ in 1..11 { }`.The many bugs in the C-style `for`
    loops, like the off-by-one error with the counter, cannot occur here because we
    loop over an iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can also be used in a range, like in the following snippet that prints
    nine dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll examine iterators in more detail in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point of every Rust program is a `fn` function called `main()`,
    which can be further subdivided into separate functions to reuse code or for better
    code organization. Rust doesn't care about the order in which these functions
    are defined, but it is nice to put `main()` at the start of the code to get a
    better overview. Rust has incorporated many features of traditional functional
    languages; we will see examples of this in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example of a basic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Like variables, functions also have `snake_case` names that must be unique,
    and their parameters (which have to be typed) are separated by commas. In this
    code snippet, the examples are `name1: &str` and `name2: &str` (it looks like
    a binding, but without `let`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mandating a type to the parameters was an excellent design decision: this documents
    the function for use by its caller code and allows type inference inside the function.
    The type here is `&str` because strings are stored on the heap (see the *The stack
    and the heap* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions in the preceding code don''t return anything useful (in fact,
    they return the unit `v`alue `()`), but if we want a function to actually return
    a value, its type must be specified after an arrow(`->`), as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed this prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The return value of a function is the value of its last expression. Note that
    in order to return a value, the final expression must not end with a semicolon.
    What happens when you do end it with a semicolon? Try this out. In this case,
    the unit value `()` will be returned, and the compiler will give you the error,
    **not all control paths return a value error**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have written return power + 1; as the last line, but this is not idiomatic
    code. If we wanted to return a value from the function before the last code line,
    we have to write a return value; as shown in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If this was the last line in the function, you would write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A function can return only one value, but this isn't a limitation. If we have,
    for example, three values `a`, `b`, and `c` to return, make one tuple `(a, b,
    c)` with them and return this. We will examine tuples in more detail in the next
    chapter. In Rust, you can also write a function inside another function (a so-called
    nested function), contrary to C or Java. However, this should only be used for
    small helper functions that are needed locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an exercise for you:'
  prefs: []
  type: TYPE_NORMAL
- en: What is wrong with the following function that returns the absolute value of
    a given number x?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You need to correct and test it. (See the code in `Chapter 3/exercises/absolute.rs`.)
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s show you an example of documentation. In `exdoc.rs`, we have documented
    a `cube` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: /// let cube = cube(val);
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE22]
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now invoke `rustdoc exdoc.rs` on the command line, a `doc` folder will
    be created. This contains an `exdoc` subfolder with `index.html` that is the starting
    point of a website that provides a documentation page for each function. For example,
    `fn.cube.html` shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting a function](img/image00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the **exdoc** link, you can return to the index page. For a project
    that is made with the cargo package manager, issue the `cargo doc` command to
    obtain its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation comments are written in markdown. They can contain the following
    special sections preceded by `#`: Examples, Panics, Failures, and Safety. A code
    appears between [PRE23] [PRE24]'
  prefs: []
  type: TYPE_NORMAL
- en: // from Chapter 3/code/attributes_cfg.rs
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: on_windows();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '#[cfg(target_os = "windows")]'
  prefs: []
  type: TYPE_NORMAL
- en: fn on_windows() {
  prefs: []
  type: TYPE_NORMAL
- en: println!("This machine has Windows as its OS.")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: // from Chapter 3/code/attributes_testing.rs
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: println!("No tests are compiled,compile with rustc --test! ");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '#[test]'
  prefs: []
  type: TYPE_NORMAL
- en: fn arithmetic() {
  prefs: []
  type: TYPE_NORMAL
- en: if 2 + 3 == 5 {
  prefs: []
  type: TYPE_NORMAL
- en: println!("You can calculate!");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: assert_eq!(2, power);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#[test]'
  prefs: []
  type: TYPE_NORMAL
- en: fn badtest() {
  prefs: []
  type: TYPE_NORMAL
- en: assert_eq!(6, 2 + 3);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#[test]'
  prefs: []
  type: TYPE_NORMAL
- en: fn it_works() {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: So a library crate is created with no code of its own, but it does contain a
    test template to augment with the unit tests that you write on the functions of
    your library. You can then run these tests with `cargo test`, which will produce
    an output similar to that produced in the previous section. The `cargo test` command
    runs tests in parallel whenever it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make basic programs by using the `if` conditions,
    `while` and `for` loops, and functions to structure our code. We were also able
    to accept input to a program. Lastly, we saw the immense power that attributes
    give to widen Rust's possibilities, and we applied this in conditional compilation
    and testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start using composite values and explore the powers
    of pattern matching.
  prefs: []
  type: TYPE_NORMAL
