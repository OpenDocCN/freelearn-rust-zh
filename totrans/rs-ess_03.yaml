- en: Chapter 3. Using Functions and Control Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用函数和控制结构
- en: This chapter concentrates on how we can control the execution flow of our code
    and modularize our code through functions. We will also learn how to get input
    from the console, and how to document and test our code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍我们如何通过函数控制代码的执行流程并模块化我们的代码。我们还将学习如何从控制台获取输入，以及如何记录和测试我们的代码。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Branching on a condition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据条件分支
- en: Looping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Branching on a condition
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据条件分支
- en: 'Branching on a condition is done with a common `if`, `if-else`, or `if-else
    if-else` construct, as shown in this example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据条件分支使用常见的`if`、`if-else`或`if-else if-else`结构，如本例所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives the following output:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The condition after `if` has to be a Boolean. However, unlike in C, the condition
    must not be enclosed within parentheses. Code blocks surrounded by `{ }` (curly
    braces) are needed after `if`, `else if`, or `else`. The first example shows that
    we can get out of a function with return.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`后面的条件必须是布尔值。然而，与C不同，条件不能被括号包围。在`if`、`else if`或`else`之后需要用`{ }`（大括号）包围的代码块。第一个例子显示我们可以通过`return`从函数中退出。'
- en: 'Another feature of `if-else`, as it is an expression, is that it returns a
    value. This value can be used as a function call parameter in a `print!` statement,
    or it can be assigned to a `let` binding like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`的另一个特性，作为表达式，是它返回一个值。这个值可以用作`print!`语句中的函数调用参数，或者可以像这样分配给`let`绑定：'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code blocks can contain many lines. However, you need to be careful when
    you return a value to ensure that you omit `;` (the semicolon) after the last
    expression in the `if` or `else` block. (For more information on this, see the
    *Expressions* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*). Moreover, all branches must
    always return a value of the same type. This alleviates the need for a ternary
    operator (? :) that is needed in C++; you can simply use `if` as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块可以包含多行。然而，当你返回一个值时，你需要小心，确保在`if`或`else`块中的最后一个表达式之后省略`;`（分号）。（有关更多信息，请参阅[第2章](part0023.xhtml#aid-LTSU1
    "第2章。使用变量和类型")的*表达式*部分，*使用变量和类型*）。此外，所有分支必须始终返回相同类型的值。这减少了在C++中需要的三元运算符（? :)的需求；你可以简单地像这样使用`if`：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As an exercise, try the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试以下操作：
- en: Try adding a `;` (semi-colon) after `+18` and `-18`, like this `{"+18";}` and
    find out what value will be printed for `age`. What happens if you type annotate
    `age` as `&str`?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在`+18`和`-18`之后添加一个`;`（分号），如下所示`{"+18";}`，并找出`age`将打印的值。如果你将`age`的类型注释为`&str`会发生什么？
- en: See whether you can omit `{ }` (the curly braces) if there is only one statement
    in the block.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看你是否可以省略块中的`{ }`（大括号），如果块中只有一个语句的话。
- en: 'Also, verify whether this code is okay:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，验证以下代码是否正确：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How would you correct this statement, if necessary? (Refer to code in `Chapter
    3/exercises/iftest.rs`.)
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，你将如何纠正这个语句？（参考`第3章/练习/iftest.rs`中的代码。）
- en: 'Simplify the following function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化以下函数：
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (See the code in `Chapter 3\exercises\ifreturn.rs`.)
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （参见`第3章\练习\ifreturn.rs`中的代码。）
- en: Pattern matching, which we will examine in the next chapter, also branches code,
    but it does this based on the value of a variable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配，我们将在下一章中探讨，它也会分支代码，但它基于变量的值来这样做。
- en: Looping
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'For repeating pieces of code, Rust has the common `while` loop, again without
    parentheses around the condition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重复的代码片段，Rust有常见的`while`循环，条件周围没有括号：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This prints the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To start an infinite loop, use `loop`, which is syntactic sugar for while true:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动无限循环，使用`loop`，它是`while true`的语法糖：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, all power values including `50` are printed; then the loop stops with
    `break`. However, the power value `42` is not printed because of the `continue`
    statement. So, loop is equivalent to a while true, and a loop with a conditioned
    break simulates a do while in other languages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，打印了包括`50`在内的所有功率值；然后循环通过`break`语句停止。然而，由于`continue`语句，功率值`42`没有被打印。因此，循环相当于一个无限循环，并且带有条件`break`的循环在其他语言中模拟了`do
    while`。
- en: 'When loops are nested inside each other, break and continue apply to the immediate
    enclosing loop. Any `loop` statement (also `while` and `for` that we''ll see next)
    can be preceded by a label (which is denoted as `''label:`) to allow us to jump
    to the next or outer enclosing loop, as shown in this code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环嵌套在彼此内部时，break和continue只应用于最近的包围循环。任何`loop`语句（也包括我们接下来将要看到的`while`和`for`）都可以有一个标签（表示为`'label:'`）作为前缀，这样我们就可以跳转到下一个或外部的包围循环，如这个代码片段所示：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code prints the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印以下输出：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The infamous `goto` from C does not exist in Rust!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中臭名昭著的`goto`在Rust中不存在！
- en: 'Looping where a `var` variable begins from a start value `a` to an end value
    `b` (exclusive) is done with `for` over a range expression `for var in a..b` statement.
    Here is an example that prints the squares of the numbers from 1 to 10:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`for`语句在范围表达式`for var in a..b`中对一个变量从起始值`a`到结束值`b`（不包括`b`）进行循环，可以完成从起始值`a`到结束值`b`的循环。以下是一个打印从1到10的数字平方的例子：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In general, `for in` loops over an iterator, which is an object that gives
    back a series of values one by one. The range `a..b` is the simplest form of iterator.
    Each subsequent value is bound to `n` and used in the next loop iteration. The
    `for` loop ends when there are no more values, and `n` then goes out of scope.
    If we don''t need the value of `n` in the loop, we can replace it with `_` (an
    underscore) like this: `for _ in 1..11 { }`.The many bugs in the C-style `for`
    loops, like the off-by-one error with the counter, cannot occur here because we
    loop over an iterator.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`for in`循环遍历一个迭代器，迭代器是一个返回一系列值的对象。范围`a..b`是迭代器的最简单形式。每个后续值都绑定到`n`并在下一个循环迭代中使用。当没有更多值时，`for`循环结束，`n`然后超出作用域。如果我们不需要在循环中使用`n`的值，我们可以用下划线`_`（一个下划线）来替换它：`for
    _ in 1..11 { }`。C风格`for`循环中的许多错误，如计数器的偏移量错误，在这里不会发生，因为我们是在迭代器上循环。
- en: 'Variables can also be used in a range, like in the following snippet that prints
    nine dots:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以用在范围中，如下面的代码片段所示，它打印出九个点：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll examine iterators in more detail in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](part0046.xhtml#aid-1BRPS1 "第5章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*中更详细地研究迭代器。
- en: Functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: The starting point of every Rust program is a `fn` function called `main()`,
    which can be further subdivided into separate functions to reuse code or for better
    code organization. Rust doesn't care about the order in which these functions
    are defined, but it is nice to put `main()` at the start of the code to get a
    better overview. Rust has incorporated many features of traditional functional
    languages; we will see examples of this in [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Rust程序的起点是一个名为`main()`的`fn`函数，这个函数可以进一步细分为单独的函数以重用代码或更好地组织代码。Rust不关心这些函数定义的顺序，但将`main()`放在代码的开头以获得更好的概览是个不错的选择。Rust已经融合了许多传统函数式语言的特征；我们将在[第5章](part0046.xhtml#aid-1BRPS1
    "第5章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*中看到这方面的例子。
- en: 'Let''s start with an example of a basic function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本函数的一个例子开始：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like variables, functions also have `snake_case` names that must be unique,
    and their parameters (which have to be typed) are separated by commas. In this
    code snippet, the examples are `name1: &str` and `name2: &str` (it looks like
    a binding, but without `let`).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '与变量一样，函数也有`snake_case`命名规则，这些名称必须是唯一的，它们的参数（必须指定类型）由逗号分隔。在这个代码片段中，示例是`name1:
    &str`和`name2: &str`（看起来像是一个绑定，但没有`let`）。'
- en: 'Mandating a type to the parameters was an excellent design decision: this documents
    the function for use by its caller code and allows type inference inside the function.
    The type here is `&str` because strings are stored on the heap (see the *The stack
    and the heap* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对参数强制类型是一个优秀的设计决策：这为调用者代码记录了函数的使用，并允许在函数内部进行类型推断。这里的类型是`&str`，因为字符串存储在堆上（参见[第2章](part0023.xhtml#aid-LTSU1
    "第2章。使用变量和类型")，*使用变量和类型*中的*栈和堆*部分）。
- en: 'The functions in the preceding code don''t return anything useful (in fact,
    they return the unit `v`alue `()`), but if we want a function to actually return
    a value, its type must be specified after an arrow(`->`), as shown in this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的函数没有返回任何有用的东西（实际上，它们返回了单元值 `()`），但如果我们想让函数真正返回一个值，其类型必须在箭头 `->` 后指定，就像这个例子所示：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When executed this prints the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，会打印以下内容：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The return value of a function is the value of its last expression. Note that
    in order to return a value, the final expression must not end with a semicolon.
    What happens when you do end it with a semicolon? Try this out. In this case,
    the unit value `()` will be returned, and the compiler will give you the error,
    **not all control paths return a value error**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是它的最后一个表达式的值。请注意，为了返回一个值，最后的表达式不能以分号结束。当你以分号结束时会发生什么？试一试。在这种情况下，将返回单元值
    `()`，编译器会给出错误，**not all control paths return a value error**。
- en: 'We could have written return power + 1; as the last line, but this is not idiomatic
    code. If we wanted to return a value from the function before the last code line,
    we have to write a return value; as shown in here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以写成 return power + 1; 作为最后一行，但这不是惯用的代码。如果我们想在最后一行代码之前从函数返回一个值，我们必须写 return
    value;，就像这里所示：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If this was the last line in the function, you would write it like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是函数中的最后一行，你会这样写：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A function can return only one value, but this isn't a limitation. If we have,
    for example, three values `a`, `b`, and `c` to return, make one tuple `(a, b,
    c)` with them and return this. We will examine tuples in more detail in the next
    chapter. In Rust, you can also write a function inside another function (a so-called
    nested function), contrary to C or Java. However, this should only be used for
    small helper functions that are needed locally.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数只能返回一个值，但这并不是一个限制。如果我们有，例如，三个值 `a`、`b` 和 `c` 要返回，可以用它们创建一个元组 `(a, b, c)`
    并返回这个元组。我们将在下一章更详细地研究元组。在 Rust 中，你还可以在另一个函数内部编写函数（称为嵌套函数），这与 C 或 Java 不同。然而，这应该只用于需要局部使用的辅助函数。
- en: 'The following is an exercise for you:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个练习题：
- en: What is wrong with the following function that returns the absolute value of
    a given number x?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下返回给定数字 x 的绝对值的函数有什么问题？
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You need to correct and test it. (See the code in `Chapter 3/exercises/absolute.rs`.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要纠正并测试它。（参见 `Chapter 3/exercises/absolute.rs` 中的代码。）
- en: Documenting a function
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Documenting a function
- en: 'Let''s show you an example of documentation. In `exdoc.rs`, we have documented
    a `cube` function as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给你展示一个文档的例子。在 `exdoc.rs` 中，我们这样注释了一个 `cube` 函数：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: /// let cube = cube(val);
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: /// let cube = cube(val);
- en: /// [PRE22]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE22]
- en: 'If we now invoke `rustdoc exdoc.rs` on the command line, a `doc` folder will
    be created. This contains an `exdoc` subfolder with `index.html` that is the starting
    point of a website that provides a documentation page for each function. For example,
    `fn.cube.html` shows the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在我们在命令行上调用 `rustdoc exdoc.rs`，将会创建一个 `doc` 文件夹。这个文件夹包含一个 `exdoc` 子文件夹，其中包含
    `index.html` 文件，它是提供每个函数文档页面的网站的起点。例如，`fn.cube.html` 显示以下内容：
- en: '![Documenting a function](img/image00177.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Documenting a function](img/image00177.jpeg)'
- en: By clicking on the **exdoc** link, you can return to the index page. For a project
    that is made with the cargo package manager, issue the `cargo doc` command to
    obtain its documentation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 **exdoc** 链接，你可以返回到索引页。对于一个使用 cargo 包管理器创建的项目，运行 `cargo doc` 命令以获取其文档。
- en: 'Documentation comments are written in markdown. They can contain the following
    special sections preceded by `#`: Examples, Panics, Failures, and Safety. A code
    appears between [PRE23] [PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释是用 Markdown 编写的。它们可以包含以下特殊部分，前面带有 `#`：示例、恐慌、失败和安全。代码位于 [PRE23] [PRE24] 之间
- en: // from Chapter 3/code/attributes_cfg.rs
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: // from Chapter 3/code/attributes_cfg.rs
- en: fn main() {
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: on_windows();
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: on_windows();
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '#[cfg(target_os = "windows")]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#[cfg(target_os = "windows")]'
- en: fn on_windows() {
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: fn on_windows() {
- en: println!("This machine has Windows as its OS.")
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: println!("This machine has Windows as its OS.")
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: // from Chapter 3/code/attributes_testing.rs
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: // from Chapter 3/code/attributes_testing.rs
- en: fn main() {
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: println!("No tests are compiled,compile with rustc --test! ");
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: println!("No tests are compiled,compile with rustc --test! ");
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '#[test]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '#[test]'
- en: fn arithmetic() {
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: fn arithmetic() {
- en: if 2 + 3 == 5 {
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: if 2 + 3 == 5 {
- en: println!("You can calculate!");
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: println!("You can calculate!");
- en: '}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: assert_eq!(2, power);
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: assert_eq!(2, power);
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#[test]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#[test]'
- en: fn badtest() {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: fn badtest() {
- en: assert_eq!(6, 2 + 3);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: assert_eq!(6, 2 + 3);
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#[test]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#[test]'
- en: fn it_works() {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: fn it_works() {
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: So a library crate is created with no code of its own, but it does contain a
    test template to augment with the unit tests that you write on the functions of
    your library. You can then run these tests with `cargo test`, which will produce
    an output similar to that produced in the previous section. The `cargo test` command
    runs tests in parallel whenever it is possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个库crate被创建出来，它本身没有自己的代码，但它包含一个测试模板，可以用来增强你为库中的函数编写的单元测试。然后你可以使用`cargo test`来运行这些测试，它将产生类似于上一节中产生的输出。`cargo
    test`命令在可能的情况下会并行运行测试。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to make basic programs by using the `if` conditions,
    `while` and `for` loops, and functions to structure our code. We were also able
    to accept input to a program. Lastly, we saw the immense power that attributes
    give to widen Rust's possibilities, and we applied this in conditional compilation
    and testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用`if`条件语句、`while`和`for`循环以及函数来结构化我们的代码，从而制作基本的程序。我们还能够接受程序输入。最后，我们看到了属性赋予Rust扩展其可能性的巨大力量，并在条件编译和测试中应用了这一点。
- en: In the next chapter, we will start using composite values and explore the powers
    of pattern matching.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用复合值并探索模式匹配的力量。
