<html><head></head><body>
		<div id="_idContainer034">
			<h1 id="_idParaDest-109"><em class="italic"><a id="_idTextAnchor109"/>Chapter 9</em>: Displaying Users' Post</h1>
			<p>In this chapter, we are going to implement displaying user posts. Along with displaying user posts, we are going to learn about <strong class="bold">generic data types</strong> and <strong class="bold">trait bounds</strong> to group types that behave similarly and so reduce the creation of similar code. We are also going to learn about the most important part of the Rust programming language: the memory model and its terminologies. We are going to learn more about <strong class="bold">ownership</strong>, <strong class="bold">moving</strong>, <strong class="bold">copying</strong>, <strong class="bold">cloning</strong>, <strong class="bold">borrowing</strong>, and <strong class="bold">lifetime</strong>, and how we can implement those in our code.</p>
			<p>After completing this chapter, you will understand and implement those concepts in Rust programming. Generic data types and trait bounds are useful to reduce repetitions, while the Rust memory model and concepts are arguably the most distinctive features of the Rust language and make it not only fast but one of the safest programming languages. Those concepts also make people say that Rust has a steep learning curve.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Displaying posts – text, photo, and video</li>
				<li>Using generic data types and trait bounds</li>
				<li>Learning about ownership and moving</li>
				<li>Borrowing and lifetime</li>
			</ul>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Displaying posts – text, photo, and video</h1>
			<p>In the previous chapters, we implemented user management, including listing, showing, creating, updating, and deleting user entities. Now, we want to do the same with posts. To refresh your <a id="_idIndexMarker480"/>memory, we are planning to have <strong class="source-inline">User</strong> posts. The posts can be either text, photos, or videos.</p>
			<p>When we implemented the application skeleton, we created a <strong class="source-inline">Post</strong> struct in <strong class="source-inline">src/models/post.rs</strong> with the following content:</p>
			<pre class="source-code">pub struct Post {</pre>
			<pre class="source-code">    pub uuid: Uuid,</pre>
			<pre class="source-code">    pub user_uuid: Uuid,</pre>
			<pre class="source-code">    pub post_type: PostType,</pre>
			<pre class="source-code">    pub content: String,</pre>
			<pre class="source-code">    pub created_at: OurDateTime,</pre>
			<pre class="source-code">}</pre>
			<p>The plan is to use <strong class="source-inline">post_type</strong> to differentiate a post based on its type and use the <strong class="source-inline">content</strong> field to store the content of the post.</p>
			<p>Now that we have rehashed what we wanted to do, let's implement showing the posts:</p>
			<ol>
				<li>The first thing we want to do is to create a migration file to change the database schema. We want to create a table to store the posts. In the application root folder, run this command:<p class="source-code"><strong class="bold">sqlx migrate add create_posts</strong></p></li>
				<li>We should then see a new file in the <strong class="source-inline">migrations</strong> folder named <strong class="source-inline">YYYYMMDDHHMMSS_create_posts.sql</strong> (depending on the current date-time). Edit the file with the following lines:<p class="source-code">CREATE TABLE IF NOT EXISTS posts</p><p class="source-code">(</p><p class="source-code">    uuid       UUID PRIMARY KEY,</p><p class="source-code">    user_uuid  UUID NOT NULL,</p><p class="source-code">    post_type  INTEGER NOT NULL DEFAULT 0,</p><p class="source-code">    content    VARCHAR NOT NULL UNIQUE,</p><p class="source-code">    created_at TIMESTAMPTZ NOT NULL DEFAULT CUR-</p><p class="source-code">    RENT_TIMESTAMP,</p><p class="source-code">    FOREIGN KEY (user_uuid) REFERENCES "users" (uuid)</p><p class="source-code">);</p></li>
				<li>After editing <a id="_idIndexMarker481"/>the file, run the migration in the command line to create the database table:<p class="source-code"><strong class="bold">sqlx migrate run</strong></p></li>
				<li>We have also created a <strong class="source-inline">DisplayPostContent</strong> trait in <strong class="source-inline">src/traits/mod.rs</strong>, which has the <strong class="source-inline">raw_html()</strong> method. We want to show content in <strong class="source-inline">Post</strong> by converting content to HTML snippets and rendering the snippets in the Tera template. Change the signature of <strong class="source-inline">raw_html()</strong> so we can use <strong class="source-inline">Post</strong> as the source of HTML snippets:<p class="source-code">fn raw_html(&amp;self) -&gt; String;</p></li>
				<li>Now, we can implement each of the types in <strong class="source-inline">src/models/text_post.rs</strong>, <strong class="source-inline">src/models/photo_post.rs</strong>, and <strong class="source-inline">src/models/video_post.rs</strong>. Start with changing <strong class="source-inline">src/models/text_post.rs</strong>:<p class="source-code">pub struct TextPost(<strong class="bold">pub</strong> Post);</p><p class="source-code">impl DisplayPostContent for TextPost {</p><p class="source-code">    fn raw_html<strong class="bold">(&amp;self</strong>) -&gt; String {</p><p class="source-code">        <strong class="bold">format!("&lt;p&gt;{}&lt;/p&gt;", self.0.content)</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The implementation <a id="_idIndexMarker482"/>is very simple, we are just wrapping the <strong class="source-inline">Post</strong> content inside a <strong class="source-inline">p</strong> HTML tag.</p>
			<ol>
				<li value="6">Next, modify <strong class="source-inline">src/models/photo_post.rs</strong>:<p class="source-code">pub struct PhotoPost(<strong class="bold">pub</strong> Post);</p><p class="source-code">impl DisplayPostContent for PhotoPost {</p><p class="source-code">    fn raw_html<strong class="bold">(&amp;self</strong>) -&gt; String {</p><p class="source-code">        <strong class="bold">format!(</strong></p><p class="source-code"><strong class="bold">            r#"&lt;figure&gt;&lt;img src="{}" class="section </strong></p><p class="source-code"><strong class="bold">            media"/&gt;&lt;/figure&gt;"#,</strong></p><p class="source-code"><strong class="bold">            self.0.content</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>For <strong class="source-inline">PhotoPost</strong>, we used the <strong class="source-inline">Post</strong> content as the source of the <strong class="source-inline">img</strong> HTML tag.</p>
			<ol>
				<li value="7">The last type we modify is <strong class="source-inline">src/models/video_post.rs</strong>:<p class="source-code">pub struct VideoPost(<strong class="bold">pub</strong> Post);</p><p class="source-code">impl DisplayPostContent for VideoPost {</p><p class="source-code">    fn raw_html(<strong class="bold">&amp;self</strong>) -&gt; String {</p><p class="source-code">        <strong class="bold">format!(</strong></p><p class="source-code"><strong class="bold">            r#"&lt;video width="320" height="240" con-</strong></p><p class="source-code"><strong class="bold">            trols&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;source src="{}" type="video/mp4"&gt;</strong></p><p class="source-code"><strong class="bold">    Your browser does not support the video tag.</strong></p><p class="source-code"><strong class="bold">    &lt;/video&gt;"#,</strong></p><p class="source-code"><strong class="bold">            self.0.content</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>For <strong class="source-inline">VideoPost</strong>, we are using the <strong class="source-inline">Post</strong> content as the source of the <strong class="source-inline">video</strong> HTML tag.</p>
			<p>We need to <a id="_idIndexMarker483"/>create templates for the posts. Let's start with a template that will be used in a single post or multiple posts. </p>
			<ol>
				<li value="8">Create a <strong class="source-inline">posts</strong> folder in the <strong class="source-inline">src/views</strong> folder. Then, create a <strong class="source-inline">_post.html.tera</strong> file inside the <strong class="source-inline">src/views/posts</strong> folder. Add the following lines to the file:<p class="source-code">&lt;div class="card fluid"&gt;</p><p class="source-code">  {{ post.post_html | safe }}</p><p class="source-code">&lt;/div&gt;</p></li>
			</ol>
			<p>We are wrapping some content inside a <strong class="source-inline">div</strong> and filtering the content as safe HTML.</p>
			<ol>
				<li value="9">In the <strong class="source-inline">src/views/posts</strong> folder, create a <strong class="source-inline">show.html.tera</strong> file as a template to show a single post. Add the following lines to the file:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block body %}</p><p class="source-code">  {% include "posts/_post" %}</p><p class="source-code">  &lt;button type="submit" value="Submit" form="delete-</p><p class="source-code">  Post"&gt;Delete&lt;/button&gt;</p><p class="source-code">  &lt;a href="/users/{{user.uuid}}/posts" class="but-</p><p class="source-code">  ton"&gt;Post List&lt;/a&gt;</p><p class="source-code">{% endblock %}</p></li>
				<li>Create an <strong class="source-inline">index.html.tera</strong> file inside the <strong class="source-inline">src/views/posts</strong> folder to show <a id="_idIndexMarker484"/>user posts. Add the following lines:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block body %}</p><p class="source-code">  {% for post in posts %}</p><p class="source-code">    &lt;div class="container"&gt;</p><p class="source-code">      &lt;div&gt;&lt;mark class="tag"&gt;{{ loop.index </p><p class="source-code">      }}&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">      {% include "posts/_post" %}</p><p class="source-code">      &lt;a href="/users/{{ user.uuid }}/posts/{{ </p><p class="source-code">      post.uuid }}" class="button"&gt;See Post&lt;/a&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  {% endfor %}</p><p class="source-code">  {% if pagination %}</p><p class="source-code">    &lt;a href="/users/{{ user.uuid }}/posts?pagina</p><p class="source-code">    tion.next={{ pagination.next }}&amp;paginat-</p><p class="source-code">    ion.limit={{ pagination.limit }}" class="button"&gt;</p><p class="source-code">      Next</p><p class="source-code">    &lt;/a&gt;</p><p class="source-code">  {% endif %}</p><p class="source-code">  &lt;a href="/users/{{ user.uuid }}/posts/new" </p><p class="source-code">  class="button"&gt;Upload Post&lt;/a&gt;</p><p class="source-code">{% endblock %}</p></li>
				<li>After creating the views, we can implement methods for the <strong class="source-inline">Post</strong> struct to get the data <a id="_idIndexMarker485"/>from the database. Modify the <strong class="source-inline">src/models/post.rs</strong> file to include <strong class="source-inline">use</strong> declarations:<p class="source-code">use super::bool_wrapper::BoolWrapper;</p><p class="source-code">use super::pagination::{Pagination, DEFAULT_LIMIT};</p><p class="source-code">use super::photo_post::PhotoPost;</p><p class="source-code">use super::post_type::PostType;</p><p class="source-code">use super::text_post::TextPost;</p><p class="source-code">use super::video_post::VideoPost;</p><p class="source-code">use crate::errors::our_error::OurError;</p><p class="source-code">use crate::fairings::db::DBConnection;</p><p class="source-code">use crate::traits::DisplayPostContent;</p><p class="source-code">use rocket::form::FromForm;</p><p class="source-code">use rocket_db_pools::sqlx::{FromRow, PgConnection};</p><p class="source-code">use rocket_db_pools::{sqlx::Acquire, Connection};</p></li>
				<li>We need to derive <strong class="source-inline">FromRow</strong> for the <strong class="source-inline">Post</strong> struct to convert database rows into <strong class="source-inline">Post</strong> instances:<p class="source-code">#[derive(<strong class="bold">FromRow</strong>, FromForm)]</p><p class="source-code">pub struct Post {</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Create an <strong class="source-inline">impl</strong> block for <strong class="source-inline">Post</strong>:<p class="source-code">impl Post {}</p></li>
				<li>Inside the <strong class="source-inline">impl Post</strong> block, we can add functions to query the database and return the <strong class="source-inline">Post</strong> data. As the functions are similar to the <strong class="source-inline">User</strong> functions, you can copy <a id="_idIndexMarker486"/>the code for <em class="italic">steps 14</em> to <em class="italic">17</em> in the <strong class="source-inline">Chapter09/01DisplayingPost</strong> source code folder. First, we add the <strong class="source-inline">find()</strong> method to get a single post:<p class="source-code">pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Post, OurError&gt; {</p><p class="source-code">    let parsed_uuid = </p><p class="source-code">    Uuid::parse_str(uuid).map_err(Our</p><p class="source-code">    Error::from_uuid_error)?;</p><p class="source-code">    let query_str = "SELECT * FROM posts WHERE uuid = </p><p class="source-code">    $1";</p><p class="source-code">    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .fetch_one(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(OurError::from_sqlx_error)?)</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">find_all()</strong> method:<p class="source-code">pub async fn find_all(</p><p class="source-code">    db: &amp;mut Connection&lt;DBConnection&gt;,</p><p class="source-code">    user_uuid: &amp;str,</p><p class="source-code">    pagination: Option&lt;Pagination&gt;,</p><p class="source-code">) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {</p><p class="source-code">    if pagination.is_some() {</p><p class="source-code">        return Self::find_all_with_pagination(db, </p><p class="source-code">        user_uuid, &amp;pagination.unwrap()).await;</p><p class="source-code">    } else {</p><p class="source-code">        return Self::find_all_without_pagination(db, user_uuid).await;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add <a id="_idIndexMarker487"/>the <strong class="source-inline">find_all_without_pagination()</strong> method:<p class="source-code">async fn find_all_without_pagination(</p><p class="source-code">    db: &amp;mut Connection&lt;DBConnection&gt;,</p><p class="source-code">    user_uuid: &amp;str,</p><p class="source-code">) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {</p><p class="source-code">    let parsed_uuid = </p><p class="source-code">    Uuid::parse_str(user_uuid).map_err(Our-</p><p class="source-code">    Error::from_uuid_error)?;</p><p class="source-code">    let query_str = r#"SELECT *</p><p class="source-code">FROM posts</p><p class="source-code">WHERE user_uuid = $1</p><p class="source-code">ORDER BY created_at DESC</p><p class="source-code">LIMIT $2"#;</p><p class="source-code">    let connection = db.acquire().await.map_err(Our-</p><p class="source-code">    Error::from_sqlx_error)?;</p><p class="source-code">    let posts = sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .bind(DEFAULT_LIMIT as i32)</p><p class="source-code">        .fetch_all(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(OurError::from_sqlx_error)?;</p><p class="source-code">    let mut new_pagination: Option&lt;Pagination&gt; = None;</p><p class="source-code">    if posts.len() == DEFAULT_LIMIT {</p><p class="source-code">        let query_str = "SELECT EXISTS(SELECT 1 FROM </p><p class="source-code">        posts WHERE created_at &lt; $1 ORDER BY </p><p class="source-code">        created_at DESC LIMIT 1)";</p><p class="source-code">        let connection = db.acquire().</p><p class="source-code">        await.map_err(OurError::from_sqlx_error)?;</p><p class="source-code">        let exists = sqlx::query_as::&lt;_,</p><p class="source-code">        BoolWrapper&gt;(query_str)</p><p class="source-code">            .bind(&amp;posts.last().unwrap().created_at)</p><p class="source-code">            .fetch_one(connection)</p><p class="source-code">            .await</p><p class="source-code">            .map_err(OurError::from_sqlx_error)?;</p><p class="source-code">        if exists.0 {</p><p class="source-code">            new_pagination = Some(Pagination {</p><p class="source-code">                next: posts.last().unwrap()</p><p class="source-code">                .created_at.to_owned(),</p><p class="source-code">                limit: DEFAULT_LIMIT,</p><p class="source-code">            });</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Ok((posts, new_pagination))</p><p class="source-code">}</p></li>
				<li>Add <a id="_idIndexMarker488"/>the <strong class="source-inline">find_all_with_pagination()</strong> method:<p class="source-code">async fn find_all_with_pagination(</p><p class="source-code">    db: &amp;mut Connection&lt;DBConnection&gt;,</p><p class="source-code">    user_uuid: &amp;str,</p><p class="source-code">    pagination: &amp;Pagination,</p><p class="source-code">) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {</p><p class="source-code">    let parsed_uuid = </p><p class="source-code">    Uuid::parse_str(user_uuid).map_err(</p><p class="source-code">    OurError::from_uuid_error)?;</p><p class="source-code">    let query_str = r#"SELECT *</p><p class="source-code">FROM posts</p><p class="source-code">WHERE user_uuid = $1 AND☐created_at &lt; $2</p><p class="source-code">ORDER BY created_at☐DESC</p><p class="source-code">LIMIT $3"#;</p><p class="source-code">    let connection = db.acquire().await.map_err(</p><p class="source-code">    OurError::from_sqlx_error)?;</p><p class="source-code">    let posts = sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(&amp;parsed_uuid)</p><p class="source-code">        .bind(&amp;pagination.next)</p><p class="source-code">        .bind(DEFAULT_LIMIT as i32)</p><p class="source-code">        .fetch_all(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(OurError::from_sqlx_error)?;</p><p class="source-code">    let mut new_pagination: Option&lt;Pagination&gt; = None;</p><p class="source-code">    if posts.len() == DEFAULT_LIMIT {</p><p class="source-code">        let query_str = "SELECT EXISTS(SELECT 1 FROM </p><p class="source-code">        posts WHERE created_at &lt; $1 ORDER BY </p><p class="source-code">        created_at DESC LIMIT 1)";</p><p class="source-code">        let connection = db.</p><p class="source-code">        acquire().await.map_err(</p><p class="source-code">        OurError::from_sqlx_error)?;</p><p class="source-code">        let exists = sqlx::query_as::&lt;_,</p><p class="source-code">        BoolWrapper&gt;(query_str)</p><p class="source-code">            .bind(&amp;posts.last().unwrap().created_at)</p><p class="source-code">            .fetch_one(connection)</p><p class="source-code">            .await</p><p class="source-code">            .map_err(OurError::from_sqlx_error)?;</p><p class="source-code">        if exists.0 {</p><p class="source-code">            new_pagination = Some(Pagination {</p><p class="source-code">                next: posts.last().unwrap().</p><p class="source-code">                created_at.to_owned(),</p><p class="source-code">                limit: DEFAULT_LIMIT,</p><p class="source-code">            });</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Ok((posts, new_pagination))</p><p class="source-code">}</p></li>
				<li>We need to add methods to convert a <strong class="source-inline">Post</strong> instance into <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, or <strong class="source-inline">VideoPost</strong>. Add the following lines inside the <strong class="source-inline">impl Post</strong> block:<p class="source-code">pub fn to_text(self) -&gt; TextPost {</p><p class="source-code">    TextPost(self)</p><p class="source-code">}</p><p class="source-code">pub fn to_photo(self) -&gt; PhotoPost {</p><p class="source-code">    PhotoPost(self)</p><p class="source-code">}</p><p class="source-code">pub fn to_video(self) -&gt; VideoPost {</p><p class="source-code">    VideoPost(self)</p><p class="source-code">}</p></li>
				<li>When the <a id="_idIndexMarker489"/>view and model implementations are ready, we can implement the function for showing user posts. In <strong class="source-inline">src/routes/post.rs</strong>, add the required <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::models::{pagination::Pagination, post::Post, post_type::PostType, user::User};</p><p class="source-code">use crate::traits::DisplayPostContent;</p><p class="source-code">use rocket::http::Status;</p><p class="source-code">use rocket::serde::Serialize;</p><p class="source-code">use rocket_db_pools::{sqlx::Acquire, Connection};</p><p class="source-code">use rocket_dyn_templates::{context, Template};</p></li>
				<li>Modify the <strong class="source-inline">get_post()</strong> function inside <strong class="source-inline">src/routes/post.rs</strong>:<p class="source-code">#[get("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]</p><p class="source-code">pub async fn get_post(</p><p class="source-code">    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,</p><p class="source-code">    <strong class="bold">user_uuid</strong>: &amp;str,</p><p class="source-code">    <strong class="bold">uuid</strong>: &amp;str,</p><p class="source-code">) -&gt; HtmlResponse {}</p></li>
				<li>Inside the <strong class="source-inline">get_post()</strong> function, query the <strong class="source-inline">user</strong> information and the <strong class="source-inline">post</strong> information <a id="_idIndexMarker490"/>from the database. Write the following lines:<p class="source-code">let connection = db</p><p class="source-code">    .acquire()</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| Status::InternalServerError)?;</p><p class="source-code">let user = User::find(connection, user_uuid)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|e| e.status)?;</p><p class="source-code">let connection = db</p><p class="source-code">    .acquire()</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| Status::InternalServerError)?;</p><p class="source-code">let post = Post::find(connection, uuid).await.map_err(|e| e.status)?;</p><p class="source-code">if post.user_uuid != user.uuid {</p><p class="source-code">    return Err(Status::InternalServerError);</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">src/views/posts/show.html.tera</strong> and <strong class="source-inline">src/views/posts/_post.html.tera</strong>, we have set two variables: <strong class="source-inline">user</strong> and <strong class="source-inline">post</strong>. We have to add those two variables into the context passed to the template. Append two structs that will be passed to templates:<p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct ShowPost {</p><p class="source-code">    post_html: String,</p><p class="source-code">}</p><p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct Context {</p><p class="source-code">    user: User,</p><p class="source-code">    post: ShowPost,</p><p class="source-code">}</p></li>
				<li>And finally, we can pass the <strong class="source-inline">user</strong> and <strong class="source-inline">post</strong> variables into <strong class="source-inline">context</strong>, render the template <a id="_idIndexMarker491"/>along with <strong class="source-inline">context</strong>, and return from the function. Append the following lines:<p class="source-code">let mut post_html = String::new();</p><p class="source-code">    match post.post_type {</p><p class="source-code">        PostType::Text =&gt; post_html = </p><p class="source-code">        post.to_text().raw_html(),</p><p class="source-code">        PostType::Photo =&gt; post_html = </p><p class="source-code">        post.to_photo().raw_html(),</p><p class="source-code">        PostType::Video =&gt; post_html = </p><p class="source-code">        post.to_video().raw_html(),</p><p class="source-code">    }</p><p class="source-code">    let context = Context {</p><p class="source-code">        user,</p><p class="source-code">        post: ShowPost { post_html },</p><p class="source-code">    };</p><p class="source-code">    Ok(Template::render("posts/show", context))</p></li>
				<li>For the <strong class="source-inline">get_posts()</strong> function in <strong class="source-inline">src/routes/post.rs</strong>, we want to get the <strong class="source-inline">posts</strong> data from <a id="_idIndexMarker492"/>the database. Modify the function into the following lines:<p class="source-code">#[get("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts?&lt;<strong class="bold">pagination</strong>&gt;", format = "text/html")]</p><p class="source-code">pub async fn get_posts(</p><p class="source-code">    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,</p><p class="source-code">    <strong class="bold">user_uuid</strong>: &amp;str,</p><p class="source-code">    <strong class="bold">pagination</strong>: Option&lt;Pagination&gt;,</p><p class="source-code">) -&gt; HtmlResponse {</p><p class="source-code">    <strong class="bold">let user = User::find(&amp;mut db, </strong></p><p class="source-code"><strong class="bold">    user_uuid).await.map_err(|e| e.status)?;</strong></p><p class="source-code"><strong class="bold">    let (posts, new_pagination) = Post::find_all(&amp;mut </strong></p><p class="source-code"><strong class="bold">    db, user_uuid, pagination)</strong></p><p class="source-code"><strong class="bold">        .await</strong></p><p class="source-code"><strong class="bold">        .map_err(|e| e.status)?;</strong></p><p class="source-code">}</p></li>
				<li>Now that we have implemented getting the <strong class="source-inline">posts</strong> data, it's time to render those posts as well. Inside the <strong class="source-inline">get_posts()</strong> function, append the following lines:<p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct ShowPost {</p><p class="source-code"> uuid: String,</p><p class="source-code"> post_html: String,</p><p class="source-code">}</p><p class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</p><p class="source-code">    .into_iter()</p><p class="source-code">    .map(|post| {</p><p class="source-code">        let uuid = post.uuid.to_string();</p><p class="source-code">        let mut post_html = String::new();</p><p class="source-code">        match post.post_type {</p><p class="source-code">            PostType::Text =&gt; post_html = </p><p class="source-code">            post.to_text().raw_html(),</p><p class="source-code">            PostType::Photo =&gt; post_html = </p><p class="source-code">            post.to_photo().raw_html(),</p><p class="source-code">            PostType::Video =&gt; post_html = </p><p class="source-code">            post.to_video().raw_html(),</p><p class="source-code">        };</p><p class="source-code">        ShowPost { uuid, post_html }</p><p class="source-code">    })</p><p class="source-code">    .collect();</p><p class="source-code">let context =</p><p class="source-code">    context! {user, posts: show_posts, pagination: </p><p class="source-code">    new_pagination.map(|pg|pg.to_context())};</p><p class="source-code">Ok(Template::render("posts/index", context))</p></li>
			</ol>
			<p>Now we have <a id="_idIndexMarker493"/>finished the code for <strong class="source-inline">get_post()</strong> and <strong class="source-inline">get_posts()</strong>, it's time to test those two endpoints. Try adding images and videos to a static folder and add an entry in the database. You can find a sample image and video in the static folder in the source code in the GitHub repository for this chapter. Here is an example:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_9.1_B16825.jpg" alt="Figure 9.1 – Testing the endpoints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Testing the endpoints</p>
			<p>When we <a id="_idIndexMarker494"/>open a web browser and navigate to the user posts page, we should be able to see something similar to this screenshot:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_9.2_B16825.jpg" alt="Figure 9.2 – Example user posts page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Example user posts page</p>
			<p>We have implemented the functions to show posts, but if we look back at the code, we can see that all three types (Text, Photo, and Video) have the same method because they are all implementing the same interface. </p>
			<p>Let's convert those into generic data types and trait bounds in the next section.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Using generic data types and trait bounds</h1>
			<p>A <strong class="bold">generic data type</strong>, <strong class="bold">generic type</strong>, or simply, <strong class="bold">generic</strong>, is a <a id="_idIndexMarker495"/>way for programming languages <a id="_idIndexMarker496"/>to be able to apply the same routine to different data types.</p>
			<p>For example, we want to create a <strong class="source-inline">multiplication(a, b) -&gt; c {}</strong> function for different <a id="_idIndexMarker497"/>data types, <strong class="source-inline">u8</strong> or <strong class="source-inline">f64</strong>. If a language does not have a generic, a programmer might have to implement two different functions, for example, <strong class="source-inline">multiplication_u8(a: u8, b: u8) -&gt; u8</strong> and <strong class="source-inline">multiplication_f64(a: f64, b: f64) -&gt; f64</strong>. Creating two different functions might look simple, but as the application grows in complexity, the branching and figuring out which function to use will be more complex. If a language has a generic, then the problem of multiple functions can be solved by using a single function that can accept <strong class="source-inline">u8</strong> and <strong class="source-inline">f64</strong>.</p>
			<p>In the Rust language, we can make a function to use generics by declaring the generics inside angle brackets after the function name as follows:</p>
			<pre class="source-code">fn multiplication<strong class="bold">&lt;T&gt;</strong>(a: <strong class="bold">T</strong>, b: <strong class="bold">T</strong>) -&gt; <strong class="bold">T</strong> {}</pre>
			<p>We can also use generics in a <strong class="source-inline">struct</strong> or <strong class="source-inline">enum</strong> definition. Here is an example:</p>
			<pre class="source-code">struct Something<strong class="bold">&lt;T&gt;</strong>{</pre>
			<pre class="source-code">    a: <strong class="bold">T</strong>,</pre>
			<pre class="source-code">    b: <strong class="bold">T</strong>,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">enum Shapes<strong class="bold">&lt;T, U&gt;</strong> {</pre>
			<pre class="source-code">    Rectangle(<strong class="bold">T</strong>, <strong class="bold">U</strong>),</pre>
			<pre class="source-code">    Circle(<strong class="bold">T</strong>),</pre>
			<pre class="source-code">}</pre>
			<p>We can also use generics inside method definitions. Following <strong class="source-inline">Something&lt;T&gt;</strong>, we can implement the method as follows:</p>
			<pre class="source-code">impl&lt;T, U&gt; Something&lt;T, U&gt; {</pre>
			<pre class="source-code">    fn add(&amp;self, T, U) -&gt; T {}</pre>
			<pre class="source-code">}</pre>
			<p>At compile time, the compiler identifies and changes the generic code into specific code by using the concrete type (<strong class="source-inline">u8</strong> or <strong class="source-inline">f64</strong> in our multiplication example), depending on which type is used. This <a id="_idIndexMarker498"/>process is called <strong class="bold">monomorphization</strong>. Because of monomorphization, code written using a generic will produce a binary that has the same execution speed as binary generated using specific code.</p>
			<p>Now that we <a id="_idIndexMarker499"/>have looked at an introduction to generics, let's use generics in our existing application:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">src/models/post.rs</strong> file, add another method to convert <strong class="source-inline">Post</strong> instances into <strong class="source-inline">media</strong>:<p class="source-code">pub fn to_media(self) -&gt; Box&lt;dyn DisplayPostContent&gt; {</p><p class="source-code">    match self.post_type {</p><p class="source-code">        PostType::Text =&gt; Box::new(self.to_text()),</p><p class="source-code">        PostType::Photo =&gt; Box::new(self.to_photo()),</p><p class="source-code">        PostType::Video =&gt; Box::new(self.to_video()),</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>We are telling the <strong class="source-inline">to_media()</strong> method to return the type that implemented <strong class="source-inline">DisplayPostContent</strong> and put <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, or <strong class="source-inline">VideoPost</strong> into the heap.</p>
			<ol>
				<li value="2">In the <strong class="source-inline">src/routes/post.rs</strong> file, inside the <strong class="source-inline">get_post()</strong> function, and after the <strong class="source-inline">Context</strong> struct declaration, add the following lines:<p class="source-code">struct Context {</p><p class="source-code">    …</p><p class="source-code">}</p><p class="source-code"><strong class="bold">fn create_context&lt;T&gt;(user: User, media: T) -&gt; Context {</strong></p><p class="source-code"><strong class="bold">    Context {</strong></p><p class="source-code"><strong class="bold">        user,</strong></p><p class="source-code"><strong class="bold">        post: ShowPost {</strong></p><p class="source-code"><strong class="bold">            post_html: media.raw_html(),</strong></p><p class="source-code"><strong class="bold">        },</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ol>
			<p>Yes, we can <a id="_idIndexMarker500"/>create a function inside another function. The inner function will have local scope and cannot be used outside the <strong class="source-inline">get_post()</strong> function.</p>
			<ol>
				<li value="3">We need to change the <strong class="source-inline">context</strong> variable from initiating the struct directly, as follows:<p class="source-code">let context = Context {...};</p></li>
			</ol>
			<p>We need to change it into using the <strong class="source-inline">create_context()</strong> function:</p>
			<p class="source-code"><strong class="bold">let media = post.to_media();</strong></p>
			<p class="source-code">let context = <strong class="bold">create_context(user, media);</strong></p>
			<p>At this point, we can see that <strong class="source-inline">create_context()</strong> can use any type, such as <strong class="source-inline">String</strong> or <strong class="source-inline">u8</strong>, but <strong class="source-inline">String</strong> and <strong class="source-inline">u8</strong> types don't have the <strong class="source-inline">raw_html()</strong> function. The Rust compiler will show an error <a id="_idIndexMarker501"/>when compiling the code. Let's fix this problem <a id="_idIndexMarker502"/>by using <strong class="bold">trait bounds</strong>.</p>
			<p>We have defined and implemented traits several times, and we already know that a trait provides consistent behavior for different data types. We defined the <strong class="source-inline">DisplayPostContent</strong> trait in <strong class="source-inline">src/traits/mod.rs</strong>, and every type that implements <strong class="source-inline">DisplayPostContent</strong> has the same method, <strong class="source-inline">raw_html(&amp;self) -&gt; String</strong>.</p>
			<p>We can limit the generic type by adding a trait after the generic declaration. Change the <strong class="source-inline">create_context()</strong> function to use trait bounds:</p>
			<pre class="source-code">fn create_context&lt;T<strong class="bold">: DisplayPostContent</strong>&gt;(user: User, media: T) -&gt; Context {...}</pre>
			<p>Unfortunately, using <strong class="source-inline">DisplayPostContent</strong> alone is not enough, because the <strong class="source-inline">T</strong> size is not fixed. We can change the function parameters from <strong class="source-inline">media: T</strong> into a <strong class="source-inline">media: &amp;T</strong> reference, as a reference has a fixed size. We also have another problem, as the <strong class="source-inline">DisplayPostContent</strong> size is not known at compile time, so we need to add another bound. Every <strong class="source-inline">T</strong> type is implicitly expected to have a constant size at compile time, implicitly trait bound to <strong class="source-inline">std::marker::Sized</strong>. We can remove the implicit bound by using a special <strong class="source-inline">?Size</strong> syntax.</p>
			<p>We can have <a id="_idIndexMarker503"/>more than one trait bound and combine them using the <strong class="source-inline">+</strong> sign. The resulting signature for the <strong class="source-inline">create_context()</strong> function will be as follows:</p>
			<pre class="source-code">fn create_context&lt;T<strong class="bold">: DisplayPostContent + ?Sized</strong>&gt;(user: User, media: &amp;T) -&gt; Context {...}</pre>
			<p>Writing multiple trait bounds inside angle brackets (<strong class="source-inline">&lt;&gt;</strong>) can make the function signature hard to read, so there's an alternative syntax for defining trait bounds:</p>
			<pre class="source-code">fn create_context<strong class="bold">&lt;T&gt;(</strong>user: User, media: &amp;T) -&gt; Context</pre>
			<pre class="source-code"><strong class="bold">where T: DisplayPostContent + ?Sized</strong> {...}</pre>
			<p>Because we changed the function signature to use a reference, we have to change the function usage as well:</p>
			<pre class="source-code">let context = create_context(user, <strong class="bold">&amp;*</strong>media);</pre>
			<p>We get <strong class="source-inline">media</strong> object by dereferencing using the <strong class="source-inline">*</strong> sign and referencing <strong class="source-inline">media</strong> again using the <strong class="source-inline">&amp;</strong> sign.</p>
			<p>Now, the Rust compiler should be able to compile the code again. We will learn more about reference in the next two sections, but before that, we have to learn about Rust's memory model called ownership and moving.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Learning about ownership and moving</h1>
			<p>When we <a id="_idIndexMarker504"/>instantiate a struct, we create an <strong class="bold">instance</strong>. Imagine a struct as being like a template; an instance is created in the memory based on the template and filled with appropriate data.</p>
			<p>An instance in Rust has a <strong class="bold">scope</strong>; it is created in a function and gets returned. Here is an example:</p>
			<pre class="source-code">fn something() -&gt; User {</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">    <strong class="bold">user</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">let user = something()</pre>
			<p>If an instance <a id="_idIndexMarker505"/>is not returned, then it's removed from memory because it's not used anymore. In this example, the <strong class="source-inline">user</strong> instance will be removed by the end of the function:</p>
			<pre class="source-code">fn something() {</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>We can say that an instance has a scope, as mentioned previously. Any resources created inside a scope will be destroyed by the end of the scope in the <em class="italic">reverse order</em> of their creation.</p>
			<p>We can also create a local scope in a routine by using curly brackets, <strong class="source-inline">{}</strong>. Any instance created inside the scope will be destroyed by the end of the scope. For example, the <strong class="source-inline">user</strong> scope is within the curly brackets:</p>
			<pre class="source-code">...</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<p>An instance <strong class="bold">owns</strong> resources, not only in <strong class="bold">stack memory</strong> but also in <strong class="bold">heap memory</strong>. When an instance goes out of scope, either because of function exits or curly brackets scope exits, the resource attached to the instance is automatically cleaned <em class="italic">in reverse order of the creation</em>. This <a id="_idIndexMarker506"/>process is called <strong class="bold">resource acquisition is initialization</strong> (<strong class="bold">RAII</strong>). </p>
			<p>Imagine that computer memory consists of a stack and a heap:</p>
			<pre class="source-code">Stack: ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>An instance owns memory from stack memory:</p>
			<pre class="source-code">Stack: ☐☒☒☒☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>Another instance may own memory from the stack and the heap. For example, a string can be a single <a id="_idIndexMarker507"/>word or a couple of paragraphs. We cannot say how large a <strong class="source-inline">String</strong> instance is going to be, so we cannot store all of the information in stack memory; instead, we can store some in stack memory and some in heap memory. This is a simplification of what it looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>In other programming <a id="_idIndexMarker508"/>languages, there's a function called a <strong class="bold">destructor</strong>, which is a routine executed when an object is removed from the memory. In Rust, there's a similar <a id="_idIndexMarker509"/>trait called <strong class="bold">Drop</strong>. In order to execute a function when an object destroyed, a type can implement the <strong class="source-inline">std::ops::Drop</strong> trait. But, most types don't need to implement the <strong class="source-inline">Drop</strong> trait and are automatically removed from memory when they're out of scope.</p>
			<p>In Rust, if we create an instance and set the instance to another instance, it is called <strong class="bold">move</strong>. To see why it's called <em class="italic">move</em>, let's modify our application code. In the <strong class="source-inline">src/routes/post.rs</strong> file, inside the <strong class="source-inline">get_posts()</strong> function, modify it into the following:</p>
			<pre class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</pre>
			<pre class="source-code">    .into_iter()</pre>
			<pre class="source-code"><strong class="bold">    .map(|post| ShowPost {</strong></pre>
			<pre class="source-code"><strong class="bold">        post_html: post.to_media().raw_html(),</strong></pre>
			<pre class="source-code"><strong class="bold">        uuid: post.uuid.to_string(),</strong></pre>
			<pre class="source-code"><strong class="bold">    })</strong></pre>
			<pre class="source-code">    .collect();</pre>
			<pre class="source-code">let context = ...</pre>
			<p>If we compile <a id="_idIndexMarker510"/>the program, we should see an error similar to the following:</p>
			<p class="source-code">error[E0382]: borrow of moved value: `post`</p>
			<p class="source-code">  --&gt; src/routes/post.rs:78:19</p>
			<p class="source-code">   |</p>
			<p class="source-code">76 |         .map(|post| ShowPost {</p>
			<p class="source-code">   |               ---- move occurs because `post` has type `models::post::Post`, which does not implement the `Copy` trait</p>
			<p class="source-code">77 |             post_html: post.to_media().raw_html(),</p>
			<p class="source-code">   |                             ---------- `post` moved due to this method call</p>
			<p class="source-code">78 |             uuid: post.uuid.to_string(),</p>
			<p class="source-code">   |                   ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move</p>
			<p>What is moving? Let's go back to the simplification of memory. When an instance is assigned to another instance, some of the second instance is allocated in stack memory: </p>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Then, some of the new instance points to old data in the heap:</p>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">              ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>If both instances point to the same heap memory, what happens if the first instance gets dropped? Because of the possibility of invalid data, in Rust, only one instance may have its own resources. The Rust compiler will refuse to compile code that uses an instance that has been moved.</p>
			<p>If we look <a id="_idIndexMarker511"/>at our code, the <strong class="source-inline">to_media()</strong> method in <strong class="source-inline">Post</strong> moved the <strong class="source-inline">post</strong> instance and put it inside either <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, or <strong class="source-inline">VideoPost</strong>. As a result, we cannot use the <strong class="source-inline">post</strong> instance again in <strong class="source-inline">post.uuid.to_string()</strong> because it has been moved. Right now, we can fix the code by changing the order of the lines:</p>
			<pre class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</pre>
			<pre class="source-code">    .into_iter()</pre>
			<pre class="source-code"><strong class="bold">    .map(|post| ShowPost {</strong></pre>
			<pre class="source-code"><strong class="bold">        uuid: post.uuid.to_string(),</strong></pre>
			<pre class="source-code"><strong class="bold">        post_html: post.to_media().raw_html(),</strong></pre>
			<pre class="source-code"><strong class="bold">    })</strong></pre>
			<pre class="source-code">    .collect();</pre>
			<p>There's no moving when we use <strong class="source-inline">post.uuid.to_string()</strong>, so the code should compile.</p>
			<p>But, how we can create a <strong class="bold">copy</strong> of an instance instead of moving it? If a type implements the <strong class="source-inline">std::marker::Copy</strong> trait, then when we assign an instance from another instance, it will create a duplicate in the stack. This is the reason why simple types such as <strong class="source-inline">u8</strong>, which don't require a lot of memory or have a known size, implement the <strong class="source-inline">Copy</strong> trait. Let's see the illustration of how this code works:</p>
			<pre class="source-code">let x: u8 = 8;</pre>
			<pre class="source-code">let y = x;</pre>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>A type may automatically derive the <strong class="source-inline">Copy</strong> trait if all members of that type implement the <strong class="source-inline">Copy</strong> trait. We also have to derive <strong class="source-inline">Clone</strong>, because the <strong class="source-inline">Copy</strong> trait is trait bound by the <strong class="source-inline">Clone</strong> trait in its definition: <strong class="source-inline">pub trait Copy: Clone { })</strong>. Here is an example of deriving the <strong class="source-inline">Copy</strong> trait:</p>
			<pre class="source-code">#[derive(<strong class="bold">Copy, Clone</strong>)]</pre>
			<pre class="source-code">struct Circle {</pre>
			<pre class="source-code">    r: u8,</pre>
			<pre class="source-code">}</pre>
			<p>However, this example <a id="_idIndexMarker512"/>will not work because <strong class="source-inline">String</strong> does not implement <strong class="source-inline">Copy</strong>:</p>
			<pre class="source-code">#[derive(<strong class="bold">Copy, Clone</strong>)]</pre>
			<pre class="source-code">pub struct Sheep {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    pub name: <strong class="bold">String</strong>,</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This example will work:</p>
			<pre class="source-code">#[derive(<strong class="bold">Clone</strong>)]</pre>
			<pre class="source-code">pub struct Sheep {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    pub name: <strong class="bold">String</strong>,</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>Cloning works by copying the content of the heap memory. For example, let's say we have the preceding code and the following code:</p>
			<pre class="source-code">let dolly = Sheep::new(...);</pre>
			<p>We c<a id="_idTextAnchor114"/>an visualize <strong class="source-inline">dolly</strong> as follows:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Let's say we <a id="_idIndexMarker513"/>assign another instance from <strong class="source-inline">dolly</strong>, as follows:</p>
			<pre class="source-code">let debbie = dolly;</pre>
			<p>This is what the memory usage looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☒☐☐☐☐☐</pre>
			<pre class="source-code">         ↓                ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☒☒☒☒☐☐</pre>
			<p>As allocating heap memory is expensive, we can use another way to see the value of an instance: <strong class="bold">borrowing</strong>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Borrowing and lifetime</h1>
			<p>We have used <strong class="bold">references</strong> in our code. A reference is <a id="_idIndexMarker514"/>an instance in the stack <a id="_idIndexMarker515"/>that points to another instance. Let's recall what an instance memory usage looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>A reference is allocated in stack memory, pointing to another instance:</p>
			<pre class="source-code">Stack: ☐☒←☒☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Allocating in the stack is cheaper than allocating in the heap. Because of this, using references most of the time is more efficient than cloning. The process of creating a reference is called <strong class="bold">borrowing</strong>, as the reference borrows the content of another instance.</p>
			<p>Suppose <a id="_idIndexMarker516"/>we have an instance named <strong class="source-inline">airwolf</strong>:</p>
			<pre class="source-code">#[derive(Debug)]</pre>
			<pre class="source-code">struct Helicopter {</pre>
			<pre class="source-code">    height: u8,</pre>
			<pre class="source-code">    cargo: Vec&lt;u8&gt;,    </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">let mut <strong class="bold">airwolf</strong> = Helicopter {</pre>
			<pre class="source-code">    height: 0,</pre>
			<pre class="source-code">    cargo: Vec::new(),</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">airwolf.height = 10;</pre>
			<p>We can create a reference to <strong class="source-inline">airwolf</strong> by using an ampersand (<strong class="source-inline">&amp;</strong>) operator:</p>
			<pre class="source-code">let camera_monitor_a = <strong class="bold">&amp;</strong>airwolf;</pre>
			<p>Borrowing an instance is like a camera monitor; a reference can see the value of the referenced instance, but the reference cannot modify the value. We can have more than one reference, as seen in this example:</p>
			<pre class="source-code">let camera_monitor_a = &amp;airwolf;</pre>
			<pre class="source-code">let camera_monitor_b = &amp;airwolf;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">let camera_monitor_z = &amp;airwolf;</pre>
			<p>What if we want a reference that can modify the value of the instance it referenced? We can create a <strong class="bold">mutable reference</strong> by using the <strong class="source-inline">&amp;mut</strong> operator:</p>
			<pre class="source-code">let remote_control = <strong class="bold">&amp;mut</strong> airwolf;</pre>
			<pre class="source-code"><strong class="bold">remote_control.height = 15;</strong></pre>
			<p>Now, what will happen if we have two remote controls? Well, the helicopter cannot ascend and <a id="_idIndexMarker517"/>descend at the same time. In the same way, Rust restricts mutable references and only allows one mutable reference at a time.</p>
			<p>Rust also disallows using mutable references along with immutable references because data inconsistency may occur. For example, adding the following lines will not work: </p>
			<pre class="source-code">let last_load = <strong class="bold">camera_monitor_a</strong>.cargo.last(); // None</pre>
			<pre class="source-code"><strong class="bold">remote_control</strong>.cargo.push(100);</pre>
			<p>What is the value of <strong class="source-inline">last_load</strong>? We expected <strong class="source-inline">last_load</strong> to be <strong class="source-inline">None</strong>, but the remote control already pushed something to cargo. Because of the data inconsistency problem, the Rust compiler will emit an error if we try to compile the code.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/>Implementing borrowing and lifetime</h2>
			<p>Now that we have learned about ownership, moving, and borrowing, let's modify our code to use references.</p>
			<ol>
				<li value="1">If we look at the current definition for <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, and <strong class="source-inline">VideoPost</strong>, we can see we are taking ownership of <strong class="source-inline">post</strong> and moving the <strong class="source-inline">post</strong> instance into a new instance of <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, or <strong class="source-inline">VideoPost</strong>. In <strong class="source-inline">src/models/text_post.rs</strong> add the following struct:<p class="source-code">pub struct TextPost(pub Post);</p></li>
				<li>And in <strong class="source-inline">src/models/post.rs</strong> , add the following function:<p class="source-code">pub fn to_text(self) -&gt; TextPost { // self is post instance</p><p class="source-code">    TextPost(self) // post is moved into TextPost instance </p><p class="source-code">}</p></li>
				<li>We can convert the <strong class="source-inline">TextPost</strong> field to be a reference to a <strong class="source-inline">Post</strong> instance. Modify <strong class="source-inline">src/models/text_post.rs</strong> into the following:<p class="source-code">pub struct TextPost(<strong class="bold">&amp;</strong>Post);</p></li>
				<li>Since we are converting the unnamed field into a private unnamed field, we also need an initializer. Append the following lines:<p class="source-code">impl TextPost {</p><p class="source-code">    pub fn new(post: &amp;Post) -&gt; Self {</p><p class="source-code">        TextPost(post)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Since we <a id="_idIndexMarker518"/>changed the initialization of <strong class="source-inline">TextPost</strong>, we also need to change the implementation of <strong class="source-inline">to_text()</strong> and <strong class="source-inline">to_media()</strong>. In <strong class="source-inline">src/models/post.rs</strong>, change the <strong class="source-inline">to_text()</strong> method to the following:</p>
			<p class="source-code">pub fn to_text(&amp;self) -&gt; TextPost {</p>
			<p class="source-code">    TextPost::new(self)</p>
			<p class="source-code">}</p>
			<p>Change the <strong class="source-inline">to_media()</strong> method to the following:</p>
			<p class="source-code">pub fn to_media(self) -&gt; Box&lt;dyn DisplayPostContent&gt; {</p>
			<p class="source-code">    match self.post_type {</p>
			<p class="source-code">        PostType::Text =&gt; Box::new(<strong class="bold">(&amp;self)</strong>.to_text()),</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="5">Let's try compiling the code. We should see an error as follows:<p class="source-code"><strong class="bold">error[E0106]: missing lifetime specifier</strong></p><p class="source-code"><strong class="bold"> --&gt; src/models/text_post.rs:4:21</strong></p><p class="source-code"><strong class="bold">  |</strong></p><p class="source-code"><strong class="bold">4 | pub struct TextPost(&amp;Post);</strong></p><p class="source-code"><strong class="bold">  |                     ^ expected named lifetime parameter</strong></p></li>
			</ol>
			<p>The reason for this error is that the code needs a <strong class="bold">lifetime specifier</strong>. What is a lifetime specifier? Let's see an example of a very simple program:</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let x;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        let y = 5;</p>
			<p class="source-code">        x = &amp;y;</p>
			<p class="source-code">    } // y is out of scope</p>
			<p class="source-code">    println!("{}", *x);</p>
			<p class="source-code">}</p>
			<ol>
				<li value="6">Remember, in Rust, any instance is removed automatically after we reach the end of the scope. In the <a id="_idIndexMarker519"/>preceding code, <strong class="source-inline">y</strong> is created inside a scope denoted by curly brackets, <strong class="source-inline">{}</strong>. When the code reaches the end of the scope, <strong class="source-inline">}</strong>, the <strong class="source-inline">y</strong> instance is cleared from the memory. So, what will happen with <strong class="source-inline">x</strong>? The preceding code will fail to compile because <strong class="source-inline">x</strong> is not valid anymore. We can fix the code as follows:<p class="source-code">fn main() {</p><p class="source-code">    let x;</p><p class="source-code">    {</p><p class="source-code">        let y = 5;</p><p class="source-code">        x = &amp;y;</p><p class="source-code">        println!("{}", *x);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, let's take a look at our code in <strong class="source-inline">src/models/text_post.rs</strong>:<p class="source-code">pub struct TextPost(&amp;Post);</p></li>
			</ol>
			<p>Because Rust is multithreaded and has a lot of branching, we cannot guarantee that the reference to the <strong class="source-inline">Post</strong> instance, <strong class="source-inline">&amp;Post</strong>, can exist for as long as the <strong class="source-inline">TextPost</strong> instance. What will happen if <strong class="source-inline">&amp;Post</strong> is already destroyed while the <strong class="source-inline">TextPost</strong> instance is not destroyed? The <a id="_idIndexMarker520"/>solution is that we place a marker called a <strong class="bold">lifetime specifier</strong> or <strong class="bold">lifetime annotation</strong>. Let's <a id="_idIndexMarker521"/>modify the code definition for <strong class="source-inline">TextPost</strong> as follows:</p>
			<p class="source-code">pub struct TextPost<strong class="bold">&lt;'a&gt;</strong>(&amp;<strong class="bold">'a</strong> Post);</p>
			<p>We are telling the compiler that any instance of <strong class="source-inline">TextPost</strong> should live as long as the referenced <strong class="source-inline">&amp;Post</strong>, which indicated by lifetime indicator, <strong class="source-inline">'a</strong>. If the compiler finds out that <strong class="source-inline">&amp;Post</strong> is not living as long as the <strong class="source-inline">TextPost</strong> instance, it does not compile the program.</p>
			<p>The convention for a lifetime specifier is using a small, single letter such as <strong class="source-inline">'a</strong>, but there's also <a id="_idIndexMarker522"/>a special lifetime specifier, <strong class="source-inline">'static</strong>. A <strong class="source-inline">'static</strong> lifetime specifier means the data referenced is living as long as the application. For example, we are saying the data referenced by <strong class="source-inline">pi</strong> will live as long as the application:</p>
			<p class="source-code">let pi: &amp;<strong class="bold">'static</strong> f64 = &amp;3.14;</p>
			<ol>
				<li value="8">Let's modify the rest of the application. We have seen how we use a lifetime specifier in the type definition; let's use it in an <strong class="source-inline">impl</strong> block and method as well. Modify the rest of <strong class="source-inline">src/models/text_post.rs</strong> into the following:<p class="source-code">impl<strong class="bold">&lt;'a&gt;</strong> TextPost<strong class="bold">&lt;'a&gt;</strong> {</p><p class="source-code">    pub fn new(post: &amp;<strong class="bold">'a</strong> Post) -&gt; Self {...}</p><p class="source-code">}</p><p class="source-code">impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for TextPost<strong class="bold">&lt;'a&gt;</strong> {...}</p></li>
				<li>Let's change <strong class="source-inline">PhotoPost</strong> in <strong class="source-inline">src/models/photo_post.rs</strong> to use lifetime as well:<p class="source-code">pub struct PhotoPost<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a </strong>Post);</p><p class="source-code"><strong class="bold">impl&lt;'a&gt; PhotoPost&lt;'a&gt; {</strong></p><p class="source-code"><strong class="bold">    pub fn new(post: &amp;'a Post) -&gt; Self {</strong></p><p class="source-code"><strong class="bold">        PhotoPost(post)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code">impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for PhotoPost<strong class="bold">&lt;'a&gt;</strong> {...}</p></li>
				<li>Let's also change <strong class="source-inline">VideoPost</strong> in <strong class="source-inline">src/models/video_post.rs</strong>:<p class="source-code">pub struct VideoPost<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a</strong> Post);</p><p class="source-code"><strong class="bold">impl&lt;'a&gt; VideoPost&lt;'a&gt; {</strong></p><p class="source-code"><strong class="bold">    pub fn new(post: &amp;'a Post) -&gt; Self {</strong></p><p class="source-code"><strong class="bold">        VideoPost(post)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code">impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for VideoPost<strong class="bold">&lt;'a&gt;</strong> {...}</p></li>
				<li>And in <strong class="source-inline">src/models/post.rs</strong>, modify <a id="_idIndexMarker523"/>the code as follows:<p class="source-code">impl Post {</p><p class="source-code">    pub fn to_text(<strong class="bold">&amp;</strong>self) -&gt; TextPost {</p><p class="source-code">        TextPost::new(self)</p><p class="source-code">    }</p><p class="source-code">    pub fn to_photo(<strong class="bold">&amp;</strong>self) -&gt; PhotoPost {</p><p class="source-code">        PhotoPost::new(self)</p><p class="source-code">    }</p><p class="source-code">    pub fn to_video(<strong class="bold">&amp;</strong>self) -&gt; VideoPost {</p><p class="source-code">        VideoPost::new(self)</p><p class="source-code">    }</p><p class="source-code">    pub fn to_media<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a</strong> self) -&gt; Box&lt;dyn </p><p class="source-code">    DisplayPostContent <strong class="bold">+ 'a</strong>&gt; {</p><p class="source-code">        match self.post_type {</p><p class="source-code">            PostType::Photo =&gt; Box::new(self.to_photo()),</p><p class="source-code">            PostType::Text =&gt; Box::new(self.to_text()),</p><p class="source-code">            PostType::Video =&gt; Box::new(self.to_video()),</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, we are <a id="_idIndexMarker524"/>using a borrowed <strong class="source-inline">Post</strong> instance for <strong class="source-inline">TextPost</strong>, <strong class="source-inline">PhotoPost</strong>, or <strong class="source-inline">VideoPost</strong> instances. But, before we end this chapter, let's refactor the code a little bit by following these instructions:</p>
			<ol>
				<li value="1">We can see the <strong class="source-inline">ShowPost</strong> struct is duplicated inside <strong class="source-inline">get_post()</strong> and <strong class="source-inline">get_posts()</strong>. Add a new struct into <strong class="source-inline">src/models/post.rs</strong>:<p class="source-code">use rocket::serde::Serialize;</p><p class="source-code">...</p><p class="source-code">#[derive(Serialize)]</p><p class="source-code">pub struct ShowPost {</p><p class="source-code">    pub uuid: String,</p><p class="source-code">    pub post_html: String,</p><p class="source-code">}</p></li>
				<li>Add a method to convert <strong class="source-inline">Post</strong> into <strong class="source-inline">ShowPost</strong>:<p class="source-code">impl Post {</p><p class="source-code">    ...</p><p class="source-code"><strong class="bold">    pub fn to_show_post&lt;'a&gt;(&amp;'a self) -&gt; ShowPost {</strong></p><p class="source-code"><strong class="bold">        ShowPost {</strong></p><p class="source-code"><strong class="bold">            uuid: self.uuid.to_string(),</strong></p><p class="source-code"><strong class="bold">            post_html: self.to_media().raw_html(),</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">src/routes/post.rs</strong>, add <strong class="source-inline">ShowPost</strong> to a <strong class="source-inline">use</strong> declaration:<p class="source-code">use crate::models::{</p><p class="source-code">    pagination::Pagination,</p><p class="source-code">    post::{Post<strong class="bold">, ShowPost</strong>},</p><p class="source-code">    user::User,</p><p class="source-code">};</p></li>
				<li>Modify <a id="_idIndexMarker525"/>the <strong class="source-inline">get_post()</strong> function by removing these lines to remove unnecessary struct declarations and functions:<p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct ShowPost {</p><p class="source-code">    post_html: String,</p><p class="source-code">}</p><p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct Context {</p><p class="source-code">    user: User,</p><p class="source-code">    post: ShowPost,</p><p class="source-code">}</p><p class="source-code">fn create_context&lt;T: DisplayPostContent + ?Sized&gt;(user: User, media: &amp;T) -&gt; Context {</p><p class="source-code">    Context {</p><p class="source-code">        user,</p><p class="source-code">        post: ShowPost {</p><p class="source-code">            post_html: media.raw_html(),</p><p class="source-code">        },</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">let media = post.to_media();</p><p class="source-code">let context = create_context(user, &amp;*media);</p></li>
				<li>Replace <a id="_idIndexMarker526"/>those lines with the <strong class="source-inline">context!</strong> macro:<p class="source-code">let context = <strong class="bold">context! { user, post: &amp;(post.to_show_post())};</strong></p></li>
				<li>In the <strong class="source-inline">get_posts()</strong> function, remove these lines:<p class="source-code">#[derive(Serialize)]</p><p class="source-code">struct ShowPost {</p><p class="source-code">    uuid: String,</p><p class="source-code">    post_html: String,</p><p class="source-code">}</p><p class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</p><p class="source-code">    .into_iter()</p><p class="source-code">    .map(|post| ShowPost {</p><p class="source-code">        uuid: post.uuid.to_string(),</p><p class="source-code">        post_html: post.to_media().raw_html(),</p><p class="source-code">    })</p><p class="source-code">    .collect();</p></li>
			</ol>
			<p>Replace those lines with this line:</p>
			<p class="source-code">let show_posts: Vec&lt;ShowPost&gt; = <strong class="bold">posts.into_iter().map(|post| post.to_show_post()).collect();</strong></p>
			<ol>
				<li value="7">Also, change the <strong class="source-inline">context</strong> instantiation:<p class="source-code">let context = <strong class="bold">context! {user, posts: &amp;show_posts, pagination: new_pagination.map(|pg|pg.to_context())};</strong></p></li>
				<li>And finally, remove the unnecessary <strong class="source-inline">use</strong> declaration. Remove these lines:<p class="source-code">use crate::traits::DisplayPostContent;</p><p class="source-code">use rocket::serde::Serialize;</p></li>
			</ol>
			<p>The implementation <a id="_idIndexMarker527"/>of showing posts should be cleaner now we are using the borrowed <strong class="source-inline">Post</strong> instance. There should be no difference in the speed of the application because we are just using the reference of a single instance.</p>
			<p>In fact, sometimes it's better to use an owned attribute instead of a reference because there's no significant performance improvement. Using references can be useful in complex applications, high-memory usage applications, or high-performance applications such as gaming or high-speed trading with a lot of data, at the cost of development time.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Summary</h1>
			<p>In this chapter, we have implemented <strong class="source-inline">get_post()</strong> and <strong class="source-inline">get_posts()</strong> to show <strong class="source-inline">Post</strong> information in a web browser. Along with those implementations, we have learned about reducing code duplication through generics and trait bounds. </p>
			<p>We have also learned about the most distinct and important feature of Rust: its memory model. We now know an instance owns a memory block, either in the stack or in both the stack and heap. We have also learned that assigning another instance to an instance means moving ownership unless it's a simple type that implements the <strong class="source-inline">Copy</strong> and/or <strong class="source-inline">Clone</strong> trait. We have also learned about borrowing, the rules of borrowing, and the use of the lifetime specifier to complement moving, copying, and borrowing.</p>
			<p>Those rules are some of the most confusing parts of Rust, but those rules are also what make Rust a very safe language while still having the same performance as other system languages such as C or C++. Now that we have implemented showing posts, let's learn how to upload data in the next chapter.</p>
		</div>
	</body></html>