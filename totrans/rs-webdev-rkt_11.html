<html><head></head><body>
		<div><h1 id="_idParaDest-109"><em class="italic"><a id="_idTextAnchor109"/>Chapter 9</em>: Displaying Users' Post</h1>
			<p>In this chapter, we are going to implement displaying user posts. Along with displaying user posts, we are going to learn about <strong class="bold">generic data types</strong> and <strong class="bold">trait bounds</strong> to group types that behave similarly and so reduce the creation of similar code. We are also going to learn about the most important part of the Rust programming language: the memory model and its terminologies. We are going to learn more about <strong class="bold">ownership</strong>, <strong class="bold">moving</strong>, <strong class="bold">copying</strong>, <strong class="bold">cloning</strong>, <strong class="bold">borrowing</strong>, and <strong class="bold">lifetime</strong>, and how we can implement those in our code.</p>
			<p>After completing this chapter, you will understand and implement those concepts in Rust programming. Generic data types and trait bounds are useful to reduce repetitions, while the Rust memory model and concepts are arguably the most distinctive features of the Rust language and make it not only fast but one of the safest programming languages. Those concepts also make people say that Rust has a steep learning curve.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Displaying posts – text, photo, and video</li>
				<li>Using generic data types and trait bounds</li>
				<li>Learning about ownership and moving</li>
				<li>Borrowing and lifetime</li>
			</ul>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Displaying posts – text, photo, and video</h1>
			<p>In the previous chapters, we implemented user management, including listing, showing, creating, updating, and deleting user entities. Now, we want to do the same with posts. To refresh your <a id="_idIndexMarker480"/>memory, we are planning to have <code>User</code> posts. The posts can be either text, photos, or videos.</p>
			<p>When we implemented the application skeleton, we created a <code>Post</code> struct in <code>src/models/post.rs</code> with the following content:</p>
			<pre class="source-code">pub struct Post {</pre>
			<pre class="source-code">    pub uuid: Uuid,</pre>
			<pre class="source-code">    pub user_uuid: Uuid,</pre>
			<pre class="source-code">    pub post_type: PostType,</pre>
			<pre class="source-code">    pub content: String,</pre>
			<pre class="source-code">    pub created_at: OurDateTime,</pre>
			<pre class="source-code">}</pre>
			<p>The plan is to use <code>post_type</code> to differentiate a post based on its type and use the <code>content</code> field to store the content of the post.</p>
			<p>Now that we have rehashed what we wanted to do, let's implement showing the posts:</p>
			<ol>
				<li>The first thing we want to do is to create a migration file to change the database schema. We want to create a table to store the posts. In the application root folder, run this command:<pre><strong class="bold">sqlx migrate add create_posts</strong></pre></li>
				<li>We should then see a new file in the <code>migrations</code> folder named <code>YYYYMMDDHHMMSS_create_posts.sql</code> (depending on the current date-time). Edit the file with the following lines:<pre>CREATE TABLE IF NOT EXISTS posts
(
    uuid       UUID PRIMARY KEY,
    user_uuid  UUID NOT NULL,
    post_type  INTEGER NOT NULL DEFAULT 0,
    content    VARCHAR NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CUR-
    RENT_TIMESTAMP,
    FOREIGN KEY (user_uuid) REFERENCES "users" (uuid)
);</pre></li>
				<li>After editing <a id="_idIndexMarker481"/>the file, run the migration in the command line to create the database table:<pre><strong class="bold">sqlx migrate run</strong></pre></li>
				<li>We have also created a <code>DisplayPostContent</code> trait in <code>src/traits/mod.rs</code>, which has the <code>raw_html()</code> method. We want to show content in <code>Post</code> by converting content to HTML snippets and rendering the snippets in the Tera template. Change the signature of <code>raw_html()</code> so we can use <code>Post</code> as the source of HTML snippets:<pre>fn raw_html(&amp;self) -&gt; String;</pre></li>
				<li>Now, we can implement each of the types in <code>src/models/text_post.rs</code>, <code>src/models/photo_post.rs</code>, and <code>src/models/video_post.rs</code>. Start with changing <code>src/models/text_post.rs</code>:<pre>pub struct TextPost(<strong class="bold">pub</strong> Post);
impl DisplayPostContent for TextPost {
    fn raw_html<strong class="bold">(&amp;self</strong>) -&gt; String {
        <strong class="bold">format!("&lt;p&gt;{}&lt;/p&gt;", self.0.content)</strong>
    }
}</pre></li>
			</ol>
			<p>The implementation <a id="_idIndexMarker482"/>is very simple, we are just wrapping the <code>Post</code> content inside a <code>p</code> HTML tag.</p>
			<ol>
				<li value="6">Next, modify <code>src/models/photo_post.rs</code>:<pre>pub struct PhotoPost(<strong class="bold">pub</strong> Post);
impl DisplayPostContent for PhotoPost {
    fn raw_html<strong class="bold">(&amp;self</strong>) -&gt; String {
        <strong class="bold">format!(</strong>
<strong class="bold">            r#"&lt;figure&gt;&lt;img src="img/{}" class="section </strong>
<strong class="bold">            media"/&gt;&lt;/figure&gt;"#,</strong>
<strong class="bold">            self.0.content</strong>
<strong class="bold">        )</strong>
    }
}</pre></li>
			</ol>
			<p>For <code>PhotoPost</code>, we used the <code>Post</code> content as the source of the <code>img</code> HTML tag.</p>
			<ol>
				<li value="7">The last type we modify is <code>src/models/video_post.rs</code>:<pre>pub struct VideoPost(<strong class="bold">pub</strong> Post);
impl DisplayPostContent for VideoPost {
    fn raw_html(<strong class="bold">&amp;self</strong>) -&gt; String {
        <strong class="bold">format!(</strong>
<strong class="bold">            r#"&lt;video width="320" height="240" con-</strong>
<strong class="bold">            trols&gt;</strong>
<strong class="bold">    &lt;source src="img/{}" type="video/mp4"&gt;</strong>
<strong class="bold">    Your browser does not support the video tag.</strong>
<strong class="bold">    &lt;/video&gt;"#,</strong>
<strong class="bold">            self.0.content</strong>
<strong class="bold">        )</strong>
    }
}</pre></li>
			</ol>
			<p>For <code>VideoPost</code>, we are using the <code>Post</code> content as the source of the <code>video</code> HTML tag.</p>
			<p>We need to <a id="_idIndexMarker483"/>create templates for the posts. Let's start with a template that will be used in a single post or multiple posts. </p>
			<ol>
				<li value="8">Create a <code>posts</code> folder in the <code>src/views</code> folder. Then, create a <code>_post.html.tera</code> file inside the <code>src/views/posts</code> folder. Add the following lines to the file:<pre>&lt;div class="card fluid"&gt;
  {{ post.post_html | safe }}
&lt;/div&gt;</pre></li>
			</ol>
			<p>We are wrapping some content inside a <code>div</code> and filtering the content as safe HTML.</p>
			<ol>
				<li value="9">In the <code>src/views/posts</code> folder, create a <code>show.html.tera</code> file as a template to show a single post. Add the following lines to the file:<pre>{% extends "template" %}
{% block body %}
  {% include "posts/_post" %}
  &lt;button type="submit" value="Submit" form="delete-
  Post"&gt;Delete&lt;/button&gt;
  &lt;a href="/users/{{user.uuid}}/posts" class="but-
  ton"&gt;Post List&lt;/a&gt;
{% endblock %}</pre></li>
				<li>Create an <code>index.html.tera</code> file inside the <code>src/views/posts</code> folder to show <a id="_idIndexMarker484"/>user posts. Add the following lines:<pre>{% extends "template" %}
{% block body %}
  {% for post in posts %}
    &lt;div class="container"&gt;
      &lt;div&gt;&lt;mark class="tag"&gt;{{ loop.index 
      }}&lt;/mark&gt;&lt;/div&gt;
      {% include "posts/_post" %}
      &lt;a href="/users/{{ user.uuid }}/posts/{{ 
      post.uuid }}" class="button"&gt;See Post&lt;/a&gt;
    &lt;/div&gt;
  {% endfor %}
  {% if pagination %}
    &lt;a href="/users/{{ user.uuid }}/posts?pagina
    tion.next={{ pagination.next }}&amp;paginat-
    ion.limit={{ pagination.limit }}" class="button"&gt;
      Next
    &lt;/a&gt;
  {% endif %}
  &lt;a href="/users/{{ user.uuid }}/posts/new" 
  class="button"&gt;Upload Post&lt;/a&gt;
{% endblock %}</pre></li>
				<li>After creating the views, we can implement methods for the <code>Post</code> struct to get the data <a id="_idIndexMarker485"/>from the database. Modify the <code>src/models/post.rs</code> file to include <code>use</code> declarations:<pre>use super::bool_wrapper::BoolWrapper;
use super::pagination::{Pagination, DEFAULT_LIMIT};
use super::photo_post::PhotoPost;
use super::post_type::PostType;
use super::text_post::TextPost;
use super::video_post::VideoPost;
use crate::errors::our_error::OurError;
use crate::fairings::db::DBConnection;
use crate::traits::DisplayPostContent;
use rocket::form::FromForm;
use rocket_db_pools::sqlx::{FromRow, PgConnection};
use rocket_db_pools::{sqlx::Acquire, Connection};</pre></li>
				<li>We need to derive <code>FromRow</code> for the <code>Post</code> struct to convert database rows into <code>Post</code> instances:<pre>#[derive(<strong class="bold">FromRow</strong>, FromForm)]
pub struct Post {
    ...
}</pre></li>
				<li>Create an <code>impl</code> block for <code>Post</code>:<pre>impl Post {}</pre></li>
				<li>Inside the <code>impl Post</code> block, we can add functions to query the database and return the <code>Post</code> data. As the functions are similar to the <code>User</code> functions, you can copy <a id="_idIndexMarker486"/>the code for <em class="italic">steps 14</em> to <em class="italic">17</em> in the <code>Chapter09/01DisplayingPost</code> source code folder. First, we add the <code>find()</code> method to get a single post:<pre>pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Post, OurError&gt; {
    let parsed_uuid = 
    Uuid::parse_str(uuid).map_err(Our
    Error::from_uuid_error)?;
    let query_str = "SELECT * FROM posts WHERE uuid = 
    $1";
    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(parsed_uuid)
        .fetch_one(connection)
        .await
        .map_err(OurError::from_sqlx_error)?)
}</pre></li>
				<li>Add the <code>find_all()</code> method:<pre>pub async fn find_all(
    db: &amp;mut Connection&lt;DBConnection&gt;,
    user_uuid: &amp;str,
    pagination: Option&lt;Pagination&gt;,
) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {
    if pagination.is_some() {
        return Self::find_all_with_pagination(db, 
        user_uuid, &amp;pagination.unwrap()).await;
    } else {
        return Self::find_all_without_pagination(db, user_uuid).await;
    }
}</pre></li>
				<li>Add <a id="_idIndexMarker487"/>the <code>find_all_without_pagination()</code> method:<pre>async fn find_all_without_pagination(
    db: &amp;mut Connection&lt;DBConnection&gt;,
    user_uuid: &amp;str,
) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {
    let parsed_uuid = 
    Uuid::parse_str(user_uuid).map_err(Our-
    Error::from_uuid_error)?;
    let query_str = r#"SELECT *
FROM posts
WHERE user_uuid = $1
ORDER BY created_at DESC
LIMIT $2"#;
    let connection = db.acquire().await.map_err(Our-
    Error::from_sqlx_error)?;
    let posts = sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(parsed_uuid)
        .bind(DEFAULT_LIMIT as i32)
        .fetch_all(connection)
        .await
        .map_err(OurError::from_sqlx_error)?;
    let mut new_pagination: Option&lt;Pagination&gt; = None;
    if posts.len() == DEFAULT_LIMIT {
        let query_str = "SELECT EXISTS(SELECT 1 FROM 
        posts WHERE created_at &lt; $1 ORDER BY 
        created_at DESC LIMIT 1)";
        let connection = db.acquire().
        await.map_err(OurError::from_sqlx_error)?;
        let exists = sqlx::query_as::&lt;_,
        BoolWrapper&gt;(query_str)
            .bind(&amp;posts.last().unwrap().created_at)
            .fetch_one(connection)
            .await
            .map_err(OurError::from_sqlx_error)?;
        if exists.0 {
            new_pagination = Some(Pagination {
                next: posts.last().unwrap()
                .created_at.to_owned(),
                limit: DEFAULT_LIMIT,
            });
        }
    }
    Ok((posts, new_pagination))
}</pre></li>
				<li>Add <a id="_idIndexMarker488"/>the <code>find_all_with_pagination()</code> method:<pre>async fn find_all_with_pagination(
    db: &amp;mut Connection&lt;DBConnection&gt;,
    user_uuid: &amp;str,
    pagination: &amp;Pagination,
) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), OurError&gt; {
    let parsed_uuid = 
    Uuid::parse_str(user_uuid).map_err(
    OurError::from_uuid_error)?;
    let query_str = r#"SELECT *
FROM posts
WHERE user_uuid = $1 AND☐created_at &lt; $2
ORDER BY created_at☐DESC
LIMIT $3"#;
    let connection = db.acquire().await.map_err(
    OurError::from_sqlx_error)?;
    let posts = sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(&amp;parsed_uuid)
        .bind(&amp;pagination.next)
        .bind(DEFAULT_LIMIT as i32)
        .fetch_all(connection)
        .await
        .map_err(OurError::from_sqlx_error)?;
    let mut new_pagination: Option&lt;Pagination&gt; = None;
    if posts.len() == DEFAULT_LIMIT {
        let query_str = "SELECT EXISTS(SELECT 1 FROM 
        posts WHERE created_at &lt; $1 ORDER BY 
        created_at DESC LIMIT 1)";
        let connection = db.
        acquire().await.map_err(
        OurError::from_sqlx_error)?;
        let exists = sqlx::query_as::&lt;_,
        BoolWrapper&gt;(query_str)
            .bind(&amp;posts.last().unwrap().created_at)
            .fetch_one(connection)
            .await
            .map_err(OurError::from_sqlx_error)?;
        if exists.0 {
            new_pagination = Some(Pagination {
                next: posts.last().unwrap().
                created_at.to_owned(),
                limit: DEFAULT_LIMIT,
            });
        }
    }
    Ok((posts, new_pagination))
}</pre></li>
				<li>We need to add methods to convert a <code>Post</code> instance into <code>TextPost</code>, <code>PhotoPost</code>, or <code>VideoPost</code>. Add the following lines inside the <code>impl Post</code> block:<pre>pub fn to_text(self) -&gt; TextPost {
    TextPost(self)
}
pub fn to_photo(self) -&gt; PhotoPost {
    PhotoPost(self)
}
pub fn to_video(self) -&gt; VideoPost {
    VideoPost(self)
}</pre></li>
				<li>When the <a id="_idIndexMarker489"/>view and model implementations are ready, we can implement the function for showing user posts. In <code>src/routes/post.rs</code>, add the required <code>use</code> declarations:<pre>use crate::models::{pagination::Pagination, post::Post, post_type::PostType, user::User};
use crate::traits::DisplayPostContent;
use rocket::http::Status;
use rocket::serde::Serialize;
use rocket_db_pools::{sqlx::Acquire, Connection};
use rocket_dyn_templates::{context, Template};</pre></li>
				<li>Modify the <code>get_post()</code> function inside <code>src/routes/post.rs</code>:<pre>#[get("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]
pub async fn get_post(
    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,
    <strong class="bold">user_uuid</strong>: &amp;str,
    <strong class="bold">uuid</strong>: &amp;str,
) -&gt; HtmlResponse {}</pre></li>
				<li>Inside the <code>get_post()</code> function, query the <code>user</code> information and the <code>post</code> information <a id="_idIndexMarker490"/>from the database. Write the following lines:<pre>let connection = db
    .acquire()
    .await
    .map_err(|_| Status::InternalServerError)?;
let user = User::find(connection, user_uuid)
    .await
    .map_err(|e| e.status)?;
let connection = db
    .acquire()
    .await
    .map_err(|_| Status::InternalServerError)?;
let post = Post::find(connection, uuid).await.map_err(|e| e.status)?;
if post.user_uuid != user.uuid {
    return Err(Status::InternalServerError);
}</pre></li>
				<li>In <code>src/views/posts/show.html.tera</code> and <code>src/views/posts/_post.html.tera</code>, we have set two variables: <code>user</code> and <code>post</code>. We have to add those two variables into the context passed to the template. Append two structs that will be passed to templates:<pre>#[derive(Serialize)]
struct ShowPost {
    post_html: String,
}
#[derive(Serialize)]
struct Context {
    user: User,
    post: ShowPost,
}</pre></li>
				<li>And finally, we can pass the <code>user</code> and <code>post</code> variables into <code>context</code>, render the template <a id="_idIndexMarker491"/>along with <code>context</code>, and return from the function. Append the following lines:<pre>let mut post_html = String::new();
    match post.post_type {
        PostType::Text =&gt; post_html = 
        post.to_text().raw_html(),
        PostType::Photo =&gt; post_html = 
        post.to_photo().raw_html(),
        PostType::Video =&gt; post_html = 
        post.to_video().raw_html(),
    }
    let context = Context {
        user,
        post: ShowPost { post_html },
    };
    Ok(Template::render("posts/show", context))</pre></li>
				<li>For the <code>get_posts()</code> function in <code>src/routes/post.rs</code>, we want to get the <code>posts</code> data from <a id="_idIndexMarker492"/>the database. Modify the function into the following lines:<pre>#[get("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts?&lt;<strong class="bold">pagination</strong>&gt;", format = "text/html")]
pub async fn get_posts(
    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,
    <strong class="bold">user_uuid</strong>: &amp;str,
    <strong class="bold">pagination</strong>: Option&lt;Pagination&gt;,
) -&gt; HtmlResponse {
    <strong class="bold">let user = User::find(&amp;mut db, </strong>
<strong class="bold">    user_uuid).await.map_err(|e| e.status)?;</strong>
<strong class="bold">    let (posts, new_pagination) = Post::find_all(&amp;mut </strong>
<strong class="bold">    db, user_uuid, pagination)</strong>
<strong class="bold">        .await</strong>
<strong class="bold">        .map_err(|e| e.status)?;</strong>
}</pre></li>
				<li>Now that we have implemented getting the <code>posts</code> data, it's time to render those posts as well. Inside the <code>get_posts()</code> function, append the following lines:<pre>#[derive(Serialize)]
struct ShowPost {
 uuid: String,
 post_html: String,
}
let show_posts: Vec&lt;ShowPost&gt; = posts
    .into_iter()
    .map(|post| {
        let uuid = post.uuid.to_string();
        let mut post_html = String::new();
        match post.post_type {
            PostType::Text =&gt; post_html = 
            post.to_text().raw_html(),
            PostType::Photo =&gt; post_html = 
            post.to_photo().raw_html(),
            PostType::Video =&gt; post_html = 
            post.to_video().raw_html(),
        };
        ShowPost { uuid, post_html }
    })
    .collect();
let context =
    context! {user, posts: show_posts, pagination: 
    new_pagination.map(|pg|pg.to_context())};
Ok(Template::render("posts/index", context))</pre></li>
			</ol>
			<p>Now we have <a id="_idIndexMarker493"/>finished the code for <code>get_post()</code> and <code>get_posts()</code>, it's time to test those two endpoints. Try adding images and videos to a static folder and add an entry in the database. You can find a sample image and video in the static folder in the source code in the GitHub repository for this chapter. Here is an example:</p>
			<div><div><img src="img/Figure_9.1_B16825.jpg" alt="Figure 9.1 – Testing the endpoints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Testing the endpoints</p>
			<p>When we <a id="_idIndexMarker494"/>open a web browser and navigate to the user posts page, we should be able to see something similar to this screenshot:</p>
			<div><div><img src="img/Figure_9.2_B16825.jpg" alt="Figure 9.2 – Example user posts page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Example user posts page</p>
			<p>We have implemented the functions to show posts, but if we look back at the code, we can see that all three types (Text, Photo, and Video) have the same method because they are all implementing the same interface. </p>
			<p>Let's convert those into generic data types and trait bounds in the next section.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Using generic data types and trait bounds</h1>
			<p>A <strong class="bold">generic data type</strong>, <strong class="bold">generic type</strong>, or simply, <strong class="bold">generic</strong>, is a <a id="_idIndexMarker495"/>way for programming languages <a id="_idIndexMarker496"/>to be able to apply the same routine to different data types.</p>
			<p>For example, we want to create a <code>multiplication(a, b) -&gt; c {}</code> function for different <a id="_idIndexMarker497"/>data types, <code>u8</code> or <code>f64</code>. If a language does not have a generic, a programmer might have to implement two different functions, for example, <code>multiplication_u8(a: u8, b: u8) -&gt; u8</code> and <code>multiplication_f64(a: f64, b: f64) -&gt; f64</code>. Creating two different functions might look simple, but as the application grows in complexity, the branching and figuring out which function to use will be more complex. If a language has a generic, then the problem of multiple functions can be solved by using a single function that can accept <code>u8</code> and <code>f64</code>.</p>
			<p>In the Rust language, we can make a function to use generics by declaring the generics inside angle brackets after the function name as follows:</p>
			<pre class="source-code">fn multiplication<strong class="bold">&lt;T&gt;</strong>(a: <strong class="bold">T</strong>, b: <strong class="bold">T</strong>) -&gt; <strong class="bold">T</strong> {}</pre>
			<p>We can also use generics in a <code>struct</code> or <code>enum</code> definition. Here is an example:</p>
			<pre class="source-code">struct Something<strong class="bold">&lt;T&gt;</strong>{</pre>
			<pre class="source-code">    a: <strong class="bold">T</strong>,</pre>
			<pre class="source-code">    b: <strong class="bold">T</strong>,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">enum Shapes<strong class="bold">&lt;T, U&gt;</strong> {</pre>
			<pre class="source-code">    Rectangle(<strong class="bold">T</strong>, <strong class="bold">U</strong>),</pre>
			<pre class="source-code">    Circle(<strong class="bold">T</strong>),</pre>
			<pre class="source-code">}</pre>
			<p>We can also use generics inside method definitions. Following <code>Something&lt;T&gt;</code>, we can implement the method as follows:</p>
			<pre class="source-code">impl&lt;T, U&gt; Something&lt;T, U&gt; {</pre>
			<pre class="source-code">    fn add(&amp;self, T, U) -&gt; T {}</pre>
			<pre class="source-code">}</pre>
			<p>At compile time, the compiler identifies and changes the generic code into specific code by using the concrete type (<code>u8</code> or <code>f64</code> in our multiplication example), depending on which type is used. This <a id="_idIndexMarker498"/>process is called <strong class="bold">monomorphization</strong>. Because of monomorphization, code written using a generic will produce a binary that has the same execution speed as binary generated using specific code.</p>
			<p>Now that we <a id="_idIndexMarker499"/>have looked at an introduction to generics, let's use generics in our existing application:</p>
			<ol>
				<li value="1">In the <code>src/models/post.rs</code> file, add another method to convert <code>Post</code> instances into <code>media</code>:<pre>pub fn to_media(self) -&gt; Box&lt;dyn DisplayPostContent&gt; {
    match self.post_type {
        PostType::Text =&gt; Box::new(self.to_text()),
        PostType::Photo =&gt; Box::new(self.to_photo()),
        PostType::Video =&gt; Box::new(self.to_video()),
    }
}</pre></li>
			</ol>
			<p>We are telling the <code>to_media()</code> method to return the type that implemented <code>DisplayPostContent</code> and put <code>TextPost</code>, <code>PhotoPost</code>, or <code>VideoPost</code> into the heap.</p>
			<ol>
				<li value="2">In the <code>src/routes/post.rs</code> file, inside the <code>get_post()</code> function, and after the <code>Context</code> struct declaration, add the following lines:<pre>struct Context {
    …
}
<strong class="bold">fn create_context&lt;T&gt;(user: User, media: T) -&gt; Context {</strong>
<strong class="bold">    Context {</strong>
<strong class="bold">        user,</strong>
<strong class="bold">        post: ShowPost {</strong>
<strong class="bold">            post_html: media.raw_html(),</strong>
<strong class="bold">        },</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>Yes, we can <a id="_idIndexMarker500"/>create a function inside another function. The inner function will have local scope and cannot be used outside the <code>get_post()</code> function.</p>
			<ol>
				<li value="3">We need to change the <code>context</code> variable from initiating the struct directly, as follows:<pre>let context = Context {...};</pre></li>
			</ol>
			<p>We need to change it into using the <code>create_context()</code> function:</p>
			<pre><strong class="bold">let media = post.to_media();</strong>
let context = <strong class="bold">create_context(user, media);</strong></pre>
			<p>At this point, we can see that <code>create_context()</code> can use any type, such as <code>String</code> or <code>u8</code>, but <code>String</code> and <code>u8</code> types don't have the <code>raw_html()</code> function. The Rust compiler will show an error <a id="_idIndexMarker501"/>when compiling the code. Let's fix this problem <a id="_idIndexMarker502"/>by using <strong class="bold">trait bounds</strong>.</p>
			<p>We have defined and implemented traits several times, and we already know that a trait provides consistent behavior for different data types. We defined the <code>DisplayPostContent</code> trait in <code>src/traits/mod.rs</code>, and every type that implements <code>DisplayPostContent</code> has the same method, <code>raw_html(&amp;self) -&gt; String</code>.</p>
			<p>We can limit the generic type by adding a trait after the generic declaration. Change the <code>create_context()</code> function to use trait bounds:</p>
			<pre class="source-code">fn create_context&lt;T<strong class="bold">: DisplayPostContent</strong>&gt;(user: User, media: T) -&gt; Context {...}</pre>
			<p>Unfortunately, using <code>DisplayPostContent</code> alone is not enough, because the <code>T</code> size is not fixed. We can change the function parameters from <code>media: T</code> into a <code>media: &amp;T</code> reference, as a reference has a fixed size. We also have another problem, as the <code>DisplayPostContent</code> size is not known at compile time, so we need to add another bound. Every <code>T</code> type is implicitly expected to have a constant size at compile time, implicitly trait bound to <code>std::marker::Sized</code>. We can remove the implicit bound by using a special <code>?Size</code> syntax.</p>
			<p>We can have <a id="_idIndexMarker503"/>more than one trait bound and combine them using the <code>+</code> sign. The resulting signature for the <code>create_context()</code> function will be as follows:</p>
			<pre class="source-code">fn create_context&lt;T<strong class="bold">: DisplayPostContent + ?Sized</strong>&gt;(user: User, media: &amp;T) -&gt; Context {...}</pre>
			<p>Writing multiple trait bounds inside angle brackets (<code>&lt;&gt;</code>) can make the function signature hard to read, so there's an alternative syntax for defining trait bounds:</p>
			<pre class="source-code">fn create_context<strong class="bold">&lt;T&gt;(</strong>user: User, media: &amp;T) -&gt; Context</pre>
			<pre class="source-code"><strong class="bold">where T: DisplayPostContent + ?Sized</strong> {...}</pre>
			<p>Because we changed the function signature to use a reference, we have to change the function usage as well:</p>
			<pre class="source-code">let context = create_context(user, <strong class="bold">&amp;*</strong>media);</pre>
			<p>We get <code>media</code> object by dereferencing using the <code>*</code> sign and referencing <code>media</code> again using the <code>&amp;</code> sign.</p>
			<p>Now, the Rust compiler should be able to compile the code again. We will learn more about reference in the next two sections, but before that, we have to learn about Rust's memory model called ownership and moving.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Learning about ownership and moving</h1>
			<p>When we <a id="_idIndexMarker504"/>instantiate a struct, we create an <strong class="bold">instance</strong>. Imagine a struct as being like a template; an instance is created in the memory based on the template and filled with appropriate data.</p>
			<p>An instance in Rust has a <strong class="bold">scope</strong>; it is created in a function and gets returned. Here is an example:</p>
			<pre class="source-code">fn something() -&gt; User {</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">    <strong class="bold">user</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">let user = something()</pre>
			<p>If an instance <a id="_idIndexMarker505"/>is not returned, then it's removed from memory because it's not used anymore. In this example, the <code>user</code> instance will be removed by the end of the function:</p>
			<pre class="source-code">fn something() {</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>We can say that an instance has a scope, as mentioned previously. Any resources created inside a scope will be destroyed by the end of the scope in the <em class="italic">reverse order</em> of their creation.</p>
			<p>We can also create a local scope in a routine by using curly brackets, <code>{}</code>. Any instance created inside the scope will be destroyed by the end of the scope. For example, the <code>user</code> scope is within the curly brackets:</p>
			<pre class="source-code">...</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    let <strong class="bold">user</strong> = User::find(...).unwrap();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">...</pre>
			<p>An instance <strong class="bold">owns</strong> resources, not only in <strong class="bold">stack memory</strong> but also in <strong class="bold">heap memory</strong>. When an instance goes out of scope, either because of function exits or curly brackets scope exits, the resource attached to the instance is automatically cleaned <em class="italic">in reverse order of the creation</em>. This <a id="_idIndexMarker506"/>process is called <strong class="bold">resource acquisition is initialization</strong> (<strong class="bold">RAII</strong>). </p>
			<p>Imagine that computer memory consists of a stack and a heap:</p>
			<pre class="source-code">Stack: ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>An instance owns memory from stack memory:</p>
			<pre class="source-code">Stack: ☐☒☒☒☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>Another instance may own memory from the stack and the heap. For example, a string can be a single <a id="_idIndexMarker507"/>word or a couple of paragraphs. We cannot say how large a <code>String</code> instance is going to be, so we cannot store all of the information in stack memory; instead, we can store some in stack memory and some in heap memory. This is a simplification of what it looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>In other programming <a id="_idIndexMarker508"/>languages, there's a function called a <code>std::ops::Drop</code> trait. But, most types don't need to implement the <code>Drop</code> trait and are automatically removed from memory when they're out of scope.</p>
			<p>In Rust, if we create an instance and set the instance to another instance, it is called <code>src/routes/post.rs</code> file, inside the <code>get_posts()</code> function, modify it into the following:</p>
			<pre class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</pre>
			<pre class="source-code">    .into_iter()</pre>
			<pre class="source-code"><strong class="bold">    .map(|post| ShowPost {</strong></pre>
			<pre class="source-code"><strong class="bold">        post_html: post.to_media().raw_html(),</strong></pre>
			<pre class="source-code"><strong class="bold">        uuid: post.uuid.to_string(),</strong></pre>
			<pre class="source-code"><strong class="bold">    })</strong></pre>
			<pre class="source-code">    .collect();</pre>
			<pre class="source-code">let context = ...</pre>
			<p>If we compile <a id="_idIndexMarker510"/>the program, we should see an error similar to the following:</p>
			<pre>error[E0382]: borrow of moved value: `post`
  --&gt; src/routes/post.rs:78:19
   |
76 |         .map(|post| ShowPost {
   |               ---- move occurs because `post` has type `models::post::Post`, which does not implement the `Copy` trait
77 |             post_html: post.to_media().raw_html(),
   |                             ---------- `post` moved due to this method call
78 |             uuid: post.uuid.to_string(),
   |                   ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move</pre>
			<p>What is moving? Let's go back to the simplification of memory. When an instance is assigned to another instance, some of the second instance is allocated in stack memory: </p>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Then, some of the new instance points to old data in the heap:</p>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">              ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>If both instances point to the same heap memory, what happens if the first instance gets dropped? Because of the possibility of invalid data, in Rust, only one instance may have its own resources. The Rust compiler will refuse to compile code that uses an instance that has been moved.</p>
			<p>If we look <a id="_idIndexMarker511"/>at our code, the <code>to_media()</code> method in <code>Post</code> moved the <code>post</code> instance and put it inside either <code>TextPost</code>, <code>PhotoPost</code>, or <code>VideoPost</code>. As a result, we cannot use the <code>post</code> instance again in <code>post.uuid.to_string()</code> because it has been moved. Right now, we can fix the code by changing the order of the lines:</p>
			<pre class="source-code">let show_posts: Vec&lt;ShowPost&gt; = posts</pre>
			<pre class="source-code">    .into_iter()</pre>
			<pre class="source-code"><strong class="bold">    .map(|post| ShowPost {</strong></pre>
			<pre class="source-code"><strong class="bold">        uuid: post.uuid.to_string(),</strong></pre>
			<pre class="source-code"><strong class="bold">        post_html: post.to_media().raw_html(),</strong></pre>
			<pre class="source-code"><strong class="bold">    })</strong></pre>
			<pre class="source-code">    .collect();</pre>
			<p>There's no moving when we use <code>post.uuid.to_string()</code>, so the code should compile.</p>
			<p>But, how we can create a <code>std::marker::Copy</code> trait, then when we assign an instance from another instance, it will create a duplicate in the stack. This is the reason why simple types such as <code>u8</code>, which don't require a lot of memory or have a known size, implement the <code>Copy</code> trait. Let's see the illustration of how this code works:</p>
			<pre class="source-code">let x: u8 = 8;</pre>
			<pre class="source-code">let y = x;</pre>
			<pre class="source-code">Stack: ☐☒☐☐☒☐☐☐☐☐☐☐</pre>
			<pre class="source-code">Heap:  ☐☐☐☐☐☐☐☐☐☐☐☐</pre>
			<p>A type may automatically derive the <code>Copy</code> trait if all members of that type implement the <code>Copy</code> trait. We also have to derive <code>Clone</code>, because the <code>Copy</code> trait is trait bound by the <code>Clone</code> trait in its definition: <code>pub trait Copy: Clone { })</code>. Here is an example of deriving the <code>Copy</code> trait:</p>
			<pre class="source-code">#[derive(<strong class="bold">Copy, Clone</strong>)]</pre>
			<pre class="source-code">struct Circle {</pre>
			<pre class="source-code">    r: u8,</pre>
			<pre class="source-code">}</pre>
			<p>However, this example <a id="_idIndexMarker512"/>will not work because <code>String</code> does not implement <code>Copy</code>:</p>
			<pre class="source-code">#[derive(<strong class="bold">Copy, Clone</strong>)]</pre>
			<pre class="source-code">pub struct Sheep {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    pub name: <strong class="bold">String</strong>,</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>This example will work:</p>
			<pre class="source-code">#[derive(<strong class="bold">Clone</strong>)]</pre>
			<pre class="source-code">pub struct Sheep {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    pub name: <strong class="bold">String</strong>,</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>Cloning works by copying the content of the heap memory. For example, let's say we have the preceding code and the following code:</p>
			<pre class="source-code">let dolly = Sheep::new(...);</pre>
			<p>We c<a id="_idTextAnchor114"/>an visualize <code>dolly</code> as follows:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Let's say we <a id="_idIndexMarker513"/>assign another instance from <code>dolly</code>, as follows:</p>
			<pre class="source-code">let debbie = dolly;</pre>
			<p>This is what the memory usage looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☒☐☐☐☐☐</pre>
			<pre class="source-code">         ↓                ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☒☒☒☒☐☐</pre>
			<p>As allocating heap memory is expensive, we can use another way to see the value of an instance: <strong class="bold">borrowing</strong>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Borrowing and lifetime</h1>
			<p>We have used <strong class="bold">references</strong> in our code. A reference is <a id="_idIndexMarker514"/>an instance in the stack <a id="_idIndexMarker515"/>that points to another instance. Let's recall what an instance memory usage looks like:</p>
			<pre class="source-code">Stack: ☐☒☐☐☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>A reference is allocated in stack memory, pointing to another instance:</p>
			<pre class="source-code">Stack: ☐☒←☒☐☐☐☐☐☐☐☐</pre>
			<pre class="source-code">         ↓</pre>
			<pre class="source-code">Heap:  ☐☒☒☒☒☐☐☐☐☐☐☐</pre>
			<p>Allocating in the stack is cheaper than allocating in the heap. Because of this, using references most of the time is more efficient than cloning. The process of creating a reference is called <strong class="bold">borrowing</strong>, as the reference borrows the content of another instance.</p>
			<p>Suppose <a id="_idIndexMarker516"/>we have an instance named <code>airwolf</code>:</p>
			<pre class="source-code">#[derive(Debug)]</pre>
			<pre class="source-code">struct Helicopter {</pre>
			<pre class="source-code">    height: u8,</pre>
			<pre class="source-code">    cargo: Vec&lt;u8&gt;,    </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">let mut <strong class="bold">airwolf</strong> = Helicopter {</pre>
			<pre class="source-code">    height: 0,</pre>
			<pre class="source-code">    cargo: Vec::new(),</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">airwolf.height = 10;</pre>
			<p>We can create a reference to <code>airwolf</code> by using an ampersand (<code>&amp;</code>) operator:</p>
			<pre class="source-code">let camera_monitor_a = <strong class="bold">&amp;</strong>airwolf;</pre>
			<p>Borrowing an instance is like a camera monitor; a reference can see the value of the referenced instance, but the reference cannot modify the value. We can have more than one reference, as seen in this example:</p>
			<pre class="source-code">let camera_monitor_a = &amp;airwolf;</pre>
			<pre class="source-code">let camera_monitor_b = &amp;airwolf;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">let camera_monitor_z = &amp;airwolf;</pre>
			<p>What if we want a reference that can modify the value of the instance it referenced? We can create a <code>&amp;mut</code> operator:</p>
			<pre class="source-code">let remote_control = <strong class="bold">&amp;mut</strong> airwolf;</pre>
			<pre class="source-code"><strong class="bold">remote_control.height = 15;</strong></pre>
			<p>Now, what will happen if we have two remote controls? Well, the helicopter cannot ascend and <a id="_idIndexMarker517"/>descend at the same time. In the same way, Rust restricts mutable references and only allows one mutable reference at a time.</p>
			<p>Rust also disallows using mutable references along with immutable references because data inconsistency may occur. For example, adding the following lines will not work: </p>
			<pre class="source-code">let last_load = <strong class="bold">camera_monitor_a</strong>.cargo.last(); // None</pre>
			<pre class="source-code"><strong class="bold">remote_control</strong>.cargo.push(100);</pre>
			<p>What is the value of <code>last_load</code>? We expected <code>last_load</code> to be <code>None</code>, but the remote control already pushed something to cargo. Because of the data inconsistency problem, the Rust compiler will emit an error if we try to compile the code.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/>Implementing borrowing and lifetime</h2>
			<p>Now that we have learned about ownership, moving, and borrowing, let's modify our code to use references.</p>
			<ol>
				<li value="1">If we look at the current definition for <code>TextPost</code>, <code>PhotoPost</code>, and <code>VideoPost</code>, we can see we are taking ownership of <code>post</code> and moving the <code>post</code> instance into a new instance of <code>TextPost</code>, <code>PhotoPost</code>, or <code>VideoPost</code>. In <code>src/models/text_post.rs</code> add the following struct:<pre>pub struct TextPost(pub Post);</pre></li>
				<li>And in <code>src/models/post.rs</code> , add the following function:<pre>pub fn to_text(self) -&gt; TextPost { // self is post instance
    TextPost(self) // post is moved into TextPost instance 
}</pre></li>
				<li>We can convert the <code>TextPost</code> field to be a reference to a <code>Post</code> instance. Modify <code>src/models/text_post.rs</code> into the following:<pre>pub struct TextPost(<strong class="bold">&amp;</strong>Post);</pre></li>
				<li>Since we are converting the unnamed field into a private unnamed field, we also need an initializer. Append the following lines:<pre>impl TextPost {
    pub fn new(post: &amp;Post) -&gt; Self {
        TextPost(post)
    }
}</pre></li>
			</ol>
			<p>Since we <a id="_idIndexMarker518"/>changed the initialization of <code>TextPost</code>, we also need to change the implementation of <code>to_text()</code> and <code>to_media()</code>. In <code>src/models/post.rs</code>, change the <code>to_text()</code> method to the following:</p>
			<pre>pub fn to_text(&amp;self) -&gt; TextPost {
    TextPost::new(self)
}</pre>
			<p>Change the <code>to_media()</code> method to the following:</p>
			<pre>pub fn to_media(self) -&gt; Box&lt;dyn DisplayPostContent&gt; {
    match self.post_type {
        PostType::Text =&gt; Box::new(<strong class="bold">(&amp;self)</strong>.to_text()),
        ...
    }
}</pre>
			<ol>
				<li value="5">Let's try compiling the code. We should see an error as follows:<pre><strong class="bold">error[E0106]: missing lifetime specifier</strong>
<strong class="bold"> --&gt; src/models/text_post.rs:4:21</strong>
<strong class="bold">  |</strong>
<strong class="bold">4 | pub struct TextPost(&amp;Post);</strong>
<strong class="bold">  |                     ^ expected named lifetime parameter</strong></pre></li>
			</ol>
			<p>The reason for this error is that the code needs a <strong class="bold">lifetime specifier</strong>. What is a lifetime specifier? Let's see an example of a very simple program:</p>
			<pre>fn main() {
    let x;
    {
        let y = 5;
        x = &amp;y;
    } // y is out of scope
    println!("{}", *x);
}</pre>
			<ol>
				<li value="6">Remember, in Rust, any instance is removed automatically after we reach the end of the scope. In the <a id="_idIndexMarker519"/>preceding code, <code>y</code> is created inside a scope denoted by curly brackets, <code>{}</code>. When the code reaches the end of the scope, <code>}</code>, the <code>y</code> instance is cleared from the memory. So, what will happen with <code>x</code>? The preceding code will fail to compile because <code>x</code> is not valid anymore. We can fix the code as follows:<pre>fn main() {
    let x;
    {
        let y = 5;
        x = &amp;y;
        println!("{}", *x);
    }
}</pre></li>
				<li>Now, let's take a look at our code in <code>src/models/text_post.rs</code>:<pre>pub struct TextPost(&amp;Post);</pre></li>
			</ol>
			<p>Because Rust is multithreaded and has a lot of branching, we cannot guarantee that the reference to the <code>Post</code> instance, <code>&amp;Post</code>, can exist for as long as the <code>TextPost</code> instance. What will happen if <code>&amp;Post</code> is already destroyed while the <code>TextPost</code> instance is not destroyed? The <a id="_idIndexMarker520"/>solution is that we place a marker called a <code>TextPost</code> as follows:</p>
			<pre>pub struct TextPost<strong class="bold">&lt;'a&gt;</strong>(&amp;<strong class="bold">'a</strong> Post);</pre>
			<p>We are telling the compiler that any instance of <code>TextPost</code> should live as long as the referenced <code>&amp;Post</code>, which indicated by lifetime indicator, <code>'a</code>. If the compiler finds out that <code>&amp;Post</code> is not living as long as the <code>TextPost</code> instance, it does not compile the program.</p>
			<p>The convention for a lifetime specifier is using a small, single letter such as <code>'a</code>, but there's also <a id="_idIndexMarker522"/>a special lifetime specifier, <code>'static</code>. A <code>'static</code> lifetime specifier means the data referenced is living as long as the application. For example, we are saying the data referenced by <code>pi</code> will live as long as the application:</p>
			<pre>let pi: &amp;<strong class="bold">'static</strong> f64 = &amp;3.14;</pre>
			<ol>
				<li value="8">Let's modify the rest of the application. We have seen how we use a lifetime specifier in the type definition; let's use it in an <code>impl</code> block and method as well. Modify the rest of <code>src/models/text_post.rs</code> into the following:<pre>impl<strong class="bold">&lt;'a&gt;</strong> TextPost<strong class="bold">&lt;'a&gt;</strong> {
    pub fn new(post: &amp;<strong class="bold">'a</strong> Post) -&gt; Self {...}
}
impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for TextPost<strong class="bold">&lt;'a&gt;</strong> {...}</pre></li>
				<li>Let's change <code>PhotoPost</code> in <code>src/models/photo_post.rs</code> to use lifetime as well:<pre>pub struct PhotoPost<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a </strong>Post);
<strong class="bold">impl&lt;'a&gt; PhotoPost&lt;'a&gt; {</strong>
<strong class="bold">    pub fn new(post: &amp;'a Post) -&gt; Self {</strong>
<strong class="bold">        PhotoPost(post)</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for PhotoPost<strong class="bold">&lt;'a&gt;</strong> {...}</pre></li>
				<li>Let's also change <code>VideoPost</code> in <code>src/models/video_post.rs</code>:<pre>pub struct VideoPost<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a</strong> Post);
<strong class="bold">impl&lt;'a&gt; VideoPost&lt;'a&gt; {</strong>
<strong class="bold">    pub fn new(post: &amp;'a Post) -&gt; Self {</strong>
<strong class="bold">        VideoPost(post)</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
impl<strong class="bold">&lt;'a&gt;</strong> DisplayPostContent for VideoPost<strong class="bold">&lt;'a&gt;</strong> {...}</pre></li>
				<li>And in <code>src/models/post.rs</code>, modify <a id="_idIndexMarker523"/>the code as follows:<pre>impl Post {
    pub fn to_text(<strong class="bold">&amp;</strong>self) -&gt; TextPost {
        TextPost::new(self)
    }
    pub fn to_photo(<strong class="bold">&amp;</strong>self) -&gt; PhotoPost {
        PhotoPost::new(self)
    }
    pub fn to_video(<strong class="bold">&amp;</strong>self) -&gt; VideoPost {
        VideoPost::new(self)
    }
    pub fn to_media<strong class="bold">&lt;'a&gt;</strong>(<strong class="bold">&amp;'a</strong> self) -&gt; Box&lt;dyn 
    DisplayPostContent <strong class="bold">+ 'a</strong>&gt; {
        match self.post_type {
            PostType::Photo =&gt; Box::new(self.to_photo()),
            PostType::Text =&gt; Box::new(self.to_text()),
            PostType::Video =&gt; Box::new(self.to_video()),
        }
    }
    ...
}</pre></li>
			</ol>
			<p>Now, we are <a id="_idIndexMarker524"/>using a borrowed <code>Post</code> instance for <code>TextPost</code>, <code>PhotoPost</code>, or <code>VideoPost</code> instances. But, before we end this chapter, let's refactor the code a little bit by following these instructions:</p>
			<ol>
				<li value="1">We can see the <code>ShowPost</code> struct is duplicated inside <code>get_post()</code> and <code>get_posts()</code>. Add a new struct into <code>src/models/post.rs</code>:<pre>use rocket::serde::Serialize;
...
#[derive(Serialize)]
pub struct ShowPost {
    pub uuid: String,
    pub post_html: String,
}</pre></li>
				<li>Add a method to convert <code>Post</code> into <code>ShowPost</code>:<pre>impl Post {
    ...
<strong class="bold">    pub fn to_show_post&lt;'a&gt;(&amp;'a self) -&gt; ShowPost {</strong>
<strong class="bold">        ShowPost {</strong>
<strong class="bold">            uuid: self.uuid.to_string(),</strong>
<strong class="bold">            post_html: self.to_media().raw_html(),</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    ...
}</pre></li>
				<li>In <code>src/routes/post.rs</code>, add <code>ShowPost</code> to a <code>use</code> declaration:<pre>use crate::models::{
    pagination::Pagination,
    post::{Post<strong class="bold">, ShowPost</strong>},
    user::User,
};</pre></li>
				<li>Modify <a id="_idIndexMarker525"/>the <code>get_post()</code> function by removing these lines to remove unnecessary struct declarations and functions:<pre>#[derive(Serialize)]
struct ShowPost {
    post_html: String,
}
#[derive(Serialize)]
struct Context {
    user: User,
    post: ShowPost,
}
fn create_context&lt;T: DisplayPostContent + ?Sized&gt;(user: User, media: &amp;T) -&gt; Context {
    Context {
        user,
        post: ShowPost {
            post_html: media.raw_html(),
        },
    }
}
let media = post.to_media();
let context = create_context(user, &amp;*media);</pre></li>
				<li>Replace <a id="_idIndexMarker526"/>those lines with the <code>context!</code> macro:<pre>let context = <strong class="bold">context! { user, post: &amp;(post.to_show_post())};</strong></pre></li>
				<li>In the <code>get_posts()</code> function, remove these lines:<pre>#[derive(Serialize)]
struct ShowPost {
    uuid: String,
    post_html: String,
}
let show_posts: Vec&lt;ShowPost&gt; = posts
    .into_iter()
    .map(|post| ShowPost {
        uuid: post.uuid.to_string(),
        post_html: post.to_media().raw_html(),
    })
    .collect();</pre></li>
			</ol>
			<p>Replace those lines with this line:</p>
			<pre>let show_posts: Vec&lt;ShowPost&gt; = <strong class="bold">posts.into_iter().map(|post| post.to_show_post()).collect();</strong></pre>
			<ol>
				<li value="7">Also, change the <code>context</code> instantiation:<pre>let context = <strong class="bold">context! {user, posts: &amp;show_posts, pagination: new_pagination.map(|pg|pg.to_context())};</strong></pre></li>
				<li>And finally, remove the unnecessary <code>use</code> declaration. Remove these lines:<pre>use crate::traits::DisplayPostContent;
use rocket::serde::Serialize;</pre></li>
			</ol>
			<p>The implementation <a id="_idIndexMarker527"/>of showing posts should be cleaner now we are using the borrowed <code>Post</code> instance. There should be no difference in the speed of the application because we are just using the reference of a single instance.</p>
			<p>In fact, sometimes it's better to use an owned attribute instead of a reference because there's no significant performance improvement. Using references can be useful in complex applications, high-memory usage applications, or high-performance applications such as gaming or high-speed trading with a lot of data, at the cost of development time.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Summary</h1>
			<p>In this chapter, we have implemented <code>get_post()</code> and <code>get_posts()</code> to show <code>Post</code> information in a web browser. Along with those implementations, we have learned about reducing code duplication through generics and trait bounds. </p>
			<p>We have also learned about the most distinct and important feature of Rust: its memory model. We now know an instance owns a memory block, either in the stack or in both the stack and heap. We have also learned that assigning another instance to an instance means moving ownership unless it's a simple type that implements the <code>Copy</code> and/or <code>Clone</code> trait. We have also learned about borrowing, the rules of borrowing, and the use of the lifetime specifier to complement moving, copying, and borrowing.</p>
			<p>Those rules are some of the most confusing parts of Rust, but those rules are also what make Rust a very safe language while still having the same performance as other system languages such as C or C++. Now that we have implemented showing posts, let's learn how to upload data in the next chapter.</p>
		</div>
	</body></html>