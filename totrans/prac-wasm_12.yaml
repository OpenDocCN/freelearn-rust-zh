- en: '*Chapter 9*: Crossing the Boundary between Rust and WebAssembly'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only seen examples of sharing simple numbers between JavaScript
    and WebAssembly. In the last section, we saw how `wasm-bindgen` helps to pass
    a string from Rust to JavaScript with ease. In this chapter, we will explore how
    `wasm-bindgen` makes it easier to convert more complex data types between JavaScript
    and WebAssembly via Rust. We will cover the following sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing classes from Rust with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing classes from JavaScript with Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the JavaScript API via WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling closures via WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the JavaScript function into Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a web API via WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary](https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary).
  prefs: []
  type: TYPE_NORMAL
- en: Sharing classes from Rust with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wasm-bindgen` enables sharing classes from JavaScript with Rust and vice versa
    using simple annotations. It handles all the boilerplate stuff, such as translating
    a value from JavaScript to WebAssembly or WebAssembly to JavaScript, complex memory
    manipulations, and error-prone pointer arithmetic. Thus, `wasm-bindgen` makes
    everything easier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how easy it is to share classes between JavaScript and WebAssembly
    (from Rust):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `wasm-bindgen` dependency for the project. Open the `cargo.toml`
    file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `src/lib.rs` file and replace the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `&mut` before the argument specifies that the argument (in this case, `self`)
    is a mutable reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rust does not have classes but we can define a class via a struct. The `Point`
    struct contains getters, setters, and an `add` function. This is normal Rust code
    with only the `#[wasm_bindgen]` annotation added.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The functions and struct were explicitly marked `pub`. The `pub` modifier means
    the function is public and will be exported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the WebAssembly module using Cargo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `wasm-bindgen` CLI to generate the binding file for the WebAssembly
    module generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate the binding files and type definition files as we have seen
    in the previous chapter. Let's look at the `class_world.js` file first. This file
    will be similar to the file generated in previous chapters except for the `Point`
    class. The `Point` class has all the getters, the setters, and the `add` function
    in it. The functions use the pointer to their references.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `wasm-bindgen` produces a static method called `__wrap` that creates
    the `Point` class object and attaches a pointer to it. It adds a free method that
    in turn calls the `__wbg_point_free` method inside the WebAssembly module. This
    method is responsible for freeing up the memory taken by the `Point` object or
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following files. We will use them in the other sections too:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `webpack.config.js`. This holds the webpack configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `package.json` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run `npm install`. Modify `index.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the new method in the `Point` class and pass it `x` and `y`. We print
    the `x` and `y` coordinates. This will print `10, 10`. Then, we will create another
    point (`p2`). Finally, we call the `add` function and pass it point `p2`. This
    will print `13, 13`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The getter method uses the pointer and fetches the value from the shared array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the setter method, we pass in the pointer and the value. Since we are just
    passing in a number here, there is no extra conversion needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of `add`, we take the argument, get the pointer to the `Point`
    object, and pass it to the WebAssembly module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`wasm-bindgen` makes it simple to convert a class into a WebAssembly module.
    We have seen how to share a class in Rust with JavaScript. Now, we will see how
    to share a class from JavaScript with Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing classes from JavaScript with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing JavaScript classes with Rust is also made easy with `#[wasm_bindgen]`.
    Let's look at how to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript classes are objects with some methods. Rust is a strictly typed language.
    This means the Rust compiler needs to have concrete bindings. Without them, the
    compiler complains, because it needs to know about the lifetime of an object.
    We need a way to ensure the compiler has this API available at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The extern C function block helps out here. The extern C makes a function name
    available in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s see how to share a class from JavaScript with Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `wasm-bindgen` dependency for the project. Open the `cargo.toml`
    file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please copy over `package.json`, `index.js`, and `webpack-config.js` from the
    previous section. Then, run `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `src/lib.rs` file and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At `//1`, we are importing the JavaScript module. This will import a JavaScript
    file, `point.js`. Note that this file should be present in the same directory
    as `Cargo.toml`. Then, we create an extern C block to define the methods that
    we need to use.
  prefs: []
  type: TYPE_NORMAL
- en: We first declare a type in the block (`pub type Point;`). Now, we can use this
    as any other type in the Rust code. After that, we define a list of functions.
    We first define the constructor. We pass in the constructor as an argument to
    the `#[wasm_bindgen]` annotation. Define a function that takes in arguments and
    returns the type declared previously. This will bind to the namespace of the Point
    type, and we can call `Point::new(x, y);` inside the Rust function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define getters and setters (`//4` and `//5`, respectively). We can
    even define a method; these are analogous to the function on the JavaScript side.
    Then, we have the `add` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the functions inside the extern C block are completely typed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are exporting the `get_precious_point()` function using the `#[wasm_bindgen]`
    annotation. In the `get_precious_point` function, we create two `Point` with `Point::new(x,
    y)`, then add two points using `p1.add(p2)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can call this from JavaScript just like we did before. We also have to define
    a `Point` class on the JavaScript side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Point.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, replace `index.js` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the following command to start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the browser and run `http://localhost:8000`. Open the developer console
    to see the printed object class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how the `#[wasm_bindgen]` macro is expanding the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a few interesting things happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `type` point is converted into a struct. This is similar to what
    we did in the previous example. But the struct''s members are JsValue instead
    of `x` and `y`. This is because `wasm_bindgen` will not know what this Point class
    is instantiating. So, it creates a JavaScript object and makes that its member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It also defines how to construct the Point object and how to dereference it.
    This is useful for the WebAssembly runtime to know when to allocate and when to
    dereference it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the methods that are defined are converted into the implementation of the
    Point struct. As you can see, there is a lot of unsafe code in the method declaration.
    This is because the Rust code interacts directly with the raw pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Shown in the previous code is the code generated by the `#[wasm_bindgen(constructor)]`
    macro. It first links the code with the extern C block. The arguments are then
    cast such that they are inferred in WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the unsafe block. First, space is reserved in the global stack.
    Then, both `x` and `y` are converted into the `IntoWasmAbi` type.
  prefs: []
  type: TYPE_NORMAL
- en: '`IntoWasmAbi` is a trait for anything that can be converted into a type that
    can cross the WebAssembly ABI directly, for example, u32 or f64\. Then, the function
    in JavaScript is called. The returned value is then cast into a `Point` type using
    `FromWasmAbi`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FromWasmAbi` is a trait for anything that can be recovered by value from the
    WebAssembly ABI boundary; for example, a Rust u8 can be recovered from the WebAssembly
    ABI u32 type.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to share a class in JavaScript with Rust. Now, we will see
    how we can call a JavaScript API in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the JavaScript API via WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript provides a rich API to work with objects, arrays, maps, sets, and
    so on. If we want to use or define them in Rust, then we need to provide the necessary
    bindings. Handcrafting those bindings will be a huge process. But what if we have
    bindings to those APIs? That is a common API for both Node.js and a browser environment
    that will create a platform where we can write the code completely in Rust and
    use `wasm_bindgen` to create necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: The rustwasm team's answer to that is the js-sys crate.
  prefs: []
  type: TYPE_NORMAL
- en: The js-sys crate contains raw `#[wasm_bindgen]` bindings to all the global APIs
    guaranteed to exist in every JavaScript environment by the ECMAScript standard.
    – RustWASM
  prefs: []
  type: TYPE_NORMAL
- en: They provide bindings to JavaScript's standard built-in objects, including their
    methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s see how to call a JavaScript API via WebAssembly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a default project with the `cargo new` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy over `webpack.config.js`, `index.js`, and `package.json` similarly to the
    previous example. Then, open the generated project in your favorite editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the contents of `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `src/lib.rs` and replace the file with the following content. We
    can create a JavaScript map inside Rust using the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Added to the `wasm_bindgen` import, we imported the map from the `js_sys` crate
    using `use js_sys::Map;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define the `new_js_map` function, which will return a new map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `set_get_js_map` function creates a new map, sets a value in the map, and
    then returns the value set.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the return type here is `JsValue`. This is a wrapper in Rust for specifying
    the JavaScript values. Also, note that we are passing the string into the trait
    functions get and set. This will return `bar` as the output when called in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now also run through the map using `for_each` inside the Rust code like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a map and then loads the map with the values `1`, `2`, `3`, `4`,
    and `5`. Then, it runs over the created map and adds the value together. This
    will produce an output of `15` (that is, 1 + 2 + 3 + 4 + 5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we replace `index.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this on the browser will print the result. Refer to the comments near
    the console log statements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the generated JavaScript binding file. The generated binding
    JavaScript file has almost the same structure as in the previous section, but
    with a few more functions exported.
  prefs: []
  type: TYPE_NORMAL
- en: The heap object is used as a stack here. All the JavaScript objects that are
    shared or referenced with the WebAssembly modules are stored in this heap. It
    is also important to note that once a value is accessed, it is popped out from
    the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `takeObject` function is used to fetch the object from the heap. It first
    gets the object at the given index. Then, it removes the object from that heap
    index (that is, it pops it out). Finally, it returns the value `ret`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can use JavaScript APIs inside Rust. The bindings are only generated
    for the common JavaScript API (including Node.js and the browser).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to call the JavaScript API in Rust. Now, we will see how we
    can call a Rust closure via WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Calling closures via WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Rust book defines closures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Closures are anonymous functions which you can save in a variable or can be
    passed as arguments to other functions. - The Rust Programming Language (Covers
    Rust 2018) by Steve Klabnik and Carol Nichols ([https://doc.rust-lang.org/book/ch13-00-functional-features.html](https://doc.rust-lang.org/book/ch13-00-functional-features.html))
  prefs: []
  type: TYPE_NORMAL
- en: 'MDN defines a closure for JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A closure is the combination of a function and lexical environment within which
    that function was declared.- MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure))
  prefs: []
  type: TYPE_NORMAL
- en: In general, closures are self-contained blocks of functionality that are tossed
    around and used in the code. They can capture and store references to the variables
    from the context in which they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Closures and functions are similar except for a subtle difference. Closures
    will capture the state when it is first created. Then, whenever a closure is called,
    it closes over that captured state.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are functions with a state. When you create a closure, it captures
    the state. Then, we can pass around closures just like any other function. When
    a closure is then invoked, it closes over this captured state and executes (even
    when the closure is invoked outside of their captured state). That is one of the
    important reasons why the use of closures is increasing on the functional side
    of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Closures make it easy to do data encapsulation, higher-order functions, and
    memoization. (Sounds functional, right? ;))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to share closures from JavaScript to Rust and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `wasm-bindgen` dependency for the project. Let''s open the `cargo.toml`
    file and add the content highlighted in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need the js-sys crate to copy over the closures from JavaScript into
    Rust. Please copy over `package.json`, `index.js`, and `webpack-config.js` from
    the previous section. Then, run `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then open the `src/lib.rs` file and add the content from our `Point` class
    example with an additional method that takes in JavaScript''s closure function
    as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will change `index.js` to call the `distance` function with a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's spin the webpack server with `npm run serve`. This will print out `3`.
  prefs: []
  type: TYPE_NORMAL
- en: The js-sys crate offers an option to invoke the JavaScript function using the
    apply and call method. That is what we have done by calling `js_func.call2(&this,
    &x, &y)`.
  prefs: []
  type: TYPE_NORMAL
- en: Rust does not have function overloading. This means that we have to use different
    method names based on the number of arguments that we pass. So, `js-sys` offers
    us `call1`, `call2`, `call3`, and so on, each taking `1`, `2`, `3`, and so on
    arguments, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a JavaScript function in Rust will return `Result<JsValue, Error>`.
    We will unwrap the result to get the JsValue and return it. `wasm-bindgen` will
    create the necessary binding to return the value as a number in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, passing a closure from Rust to JavaScript will need some
    extra information and options.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-bindgen` supports two variants here:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack lifetime closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap-allocated closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see what they actually mean:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack lifetime closures should not be invoked by JavaScript again once the imported
    JavaScript function that the closure was passed to returns. This is because once
    the function (closure) returns, the closure will be invalidated by Rust. Any future
    invocations will lead to an exception. In other words, stack lifetime closures
    are short-lived and they go out of context once they are accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, heap-allocated closures are useful for invoking the memory
    multiple times. Here, the validity is tied to the lifetime of the closure in Rust.
    Once the closure in Rust is dropped, the closure will deallocate and garbage will
    be collected. This will in turn invalidate the closure (function) in JavaScript.
    Once invalidated, any further attempts to access the closure or memory will raise
    an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the stack lifetime and heap-allocated closures support both `Fn` and `FnMut`
    closures, arguments, and return values.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to call a closure function. Now, we will see how to import
    a function from JavaScript into Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the JavaScript function into Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain places, JavaScript is faster than WebAssembly because there is no
    overhead of boundary crossing and instantiating a separate runtime environment.
    JavaScript runs more naturally in its own environment.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript ecosystem is huge. There are millions of libraries created and
    battle tested (not all of them, of course) with JavaScript. This makes JavaScript
    easy (easy here is subjective).
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly addresses the most important problem that we have in the frontend
    world, that of "consistent" performance. But it is not a complete replacement
    for JavaScript. WebAssembly helps JavaScript to deliver better and more consistent
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript will be a default choice in most places. It is important to provide
    an ecosystem that allows seamless integration between the two. We have already
    seen how to import a class from JavaScript into Rust. Similarly, we can import
    anything from JavaScript into Rust using `wasm-bindgen`. The most important part
    is that we can more naturally use these imported JavaScript functions inside Rust
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s see how to import a JavaScript function into Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `wasm-bindgen` dependency for the project. Let''s open the `cargo.toml`
    file and add the content highlighted in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please copy over `package.json`, `index.js`, and `webpack-config.js` from the
    previous section. Then, run `npm install`. Then, open the `src/lib.rs` file and
    replace its content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start by importing the `wasm_bindgen` library. Then, we define the extern
    C block to define the FFI functions (that is, the functions that we import from
    JavaScript). Inside the extern C block, we define the function signature similar
    to what the Rust compiler understands. We also annotate the extern C block with
    `#[wasm_bindgen(module ="./array")]`. This helps the `wasm-bindgen` CLI to understand
    where the functions are defined and exported. It will use this information and
    create the necessary link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `array.js` file is in the same directory as the `cargo.toml` file. We will
    define `array.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The functions mentioned previously should be exported in the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare a function (`sum_of_square_root`) in Rust and export it as a
    function in the WebAssembly module that is generated. We first call the `getNumber()`
    method from JavaScript. We use the return value and then run the `for` loop for
    the length of the array. For each loop, we call `topArray` to get the lowest element
    from the array. Then, we take the square root of the number (this happens in Rust
    code). Sum them up and return the sum (`15` for the example that we saw previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will replace `index.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's run the previous code with `npm run serve`. Go to the URL and open the
    developer console. `15` and `HEYA! I AM ALL CAPS` will be printed in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the generated binding JavaScript file. It will be interesting to see that
    both the `getNumber` and `topArray` functions are not available in the generated
    binding JavaScript file. The main reason for this is we are just sharing numbers
    between the JavaScript and the WebAssembly module. Hence, the boundary crossing
    happens more naturally in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But there will be a function exported for the `some_string_to_share` function.
    This is because we are sharing a string, which needs conversion. So, the binding
    file will make the necessary conversion to work with the string. It is also important
    to note that there is a `getInt64Memory` function. This is because we are returning
    `f64` as output. `wasm-bindgen` converts the number into `bigInt` and returns
    it to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-bindgen` also does the necessary shifting and parsing of the byte buffer
    based on the byte size of the memory object. For `Uint32Array`, the pointer and
    memory are calculated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `BigInt64Array`, the pointer and memory are calculated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have seen how to import a JavaScript function into Rust. Now, we will see
    how we can call a web API in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a web API via WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The evolution of the web has been phenomenal, with its growth being attributed
    to its open standards. Today, the web provides hundreds of APIs, which makes it
    easy for web developers to develop for audio, video, canvases, SVGs, USBs, batteries,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The web is universal and omnipresent. It is continuously experimented with and
    changed to make it desirable and easy for developers and companies to use, respectively.
    The web-sys crate provides access to almost all the APIs that are available on
    the web at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `web-sys` crate provides raw bindings to all the Web''s APIs: everything
    from DOM manipulation to WebGL to Web Audio to timers to fetch and more! – web-sys
    crates.io ([https://crates.io/crates/web-sys](https://crates.io/crates/web-sys))'
  prefs: []
  type: TYPE_NORMAL
- en: The WebIDL interface definitions are converted into `wasm-bindgen`'s internal
    **abstract syntax trees** (**ASTs**). Then, these ASTs are used to create zero-overhead
    Rust and JavaScript glue code.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of this binding code, we can call and manipulate the web APIs.
    Converting the web APIs into Rust ensures the type information of parameters and
    return values is handled correctly and safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s call a web API via WebAssembly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a default project with the `cargo new` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy over `webpack.config.js`, `index.js`, and `package.json` similarly to
    the `jsapi` section (in the above section). We''ll now open the generated project
    in our favorite editor. Let''s change the contents of `cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The major difference here is that instead of just defining the dependency and
    its version, we also defined the features that we will be using in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need it? Since there is a huge number of APIs in the web ecosystem,
    we do not want to carry bindings for all of them. The binding files are created
    and used only for the listed features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `src/lib.rs` and replace the file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first fetch the window using `web_sys::window()`. The unwrap at the end makes
    sure the window is available. If it is not, it will throw an error. After that,
    we get the document from the window object. We then create a `div` element with
    `document.createElement`. Then, we create an SVG and circle document element and
    append the circle to the SVG element. Finally, we append the SVG as a child to
    the `div` element and return the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: The API is quite similar to the web API except for the fact that the method
    names are using snake case instead of camel case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change `index.js` to use this element as a web component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, what have we done here? We first imported the binding file, which will,
    in turn, initialize the WebAssembly module. Once the WebAssembly module is initialized,
    we create a `Pie` class that extends the HTML element. Inside the class' constructor,
    we call the `super` method. Then, we create a shadow DOM. We add a style element
    to the shadow DOM, and then define the style for the element.
  prefs: []
  type: TYPE_NORMAL
- en: We go on to append the style element to the shadow element, and then add the
    element that is exported from the Rust code. We then register it as a custom element
    named `pie-chart`. Finally, we append the custom element to our document's body
    to see the pie chart getting displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the browser to see the pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how `wasm-bindgen` makes it easy to share complex objects
    between JavaScript and Rust. The annotations make it easy to mark a function to
    export/import between JavaScript and WebAssembly. We also saw how js-sys and web-sys
    Cargo make it easier to call JavaScript and web APIs inside Rust code easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to optimize the generated WebAssembly module
    in Rust.
  prefs: []
  type: TYPE_NORMAL
