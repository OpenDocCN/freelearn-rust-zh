- en: '*Chapter 9*: Crossing the Boundary between Rust and WebAssembly'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only seen examples of sharing simple numbers between JavaScript
    and WebAssembly. In the last section, we saw how `wasm-bindgen` helps to pass
    a string from Rust to JavaScript with ease. In this chapter, we will explore how
    `wasm-bindgen` makes it easier to convert more complex data types between JavaScript
    and WebAssembly via Rust. We will cover the following sections in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Sharing classes from Rust with JavaScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing classes from JavaScript with Rust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the JavaScript API via WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling closures via WebAssembly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the JavaScript function into Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a web API via WebAssembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary](https://github.com/PacktPublishing/Practical-WebAssembly/tree/main/09-rust-wasm-boundary).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Sharing classes from Rust with JavaScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wasm-bindgen` enables sharing classes from JavaScript with Rust and vice versa
    using simple annotations. It handles all the boilerplate stuff, such as translating
    a value from JavaScript to WebAssembly or WebAssembly to JavaScript, complex memory
    manipulations, and error-prone pointer arithmetic. Thus, `wasm-bindgen` makes
    everything easier.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how easy it is to share classes between JavaScript and WebAssembly
    (from Rust):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the `wasm-bindgen` dependency for the project. Open the `cargo.toml`
    file and add the following content:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `src/lib.rs` file and replace the content with the following:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `&mut` before the argument specifies that the argument (in this case, `self`)
    is a mutable reference.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rust does not have classes but we can define a class via a struct. The `Point`
    struct contains getters, setters, and an `add` function. This is normal Rust code
    with only the `#[wasm_bindgen]` annotation added.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The functions and struct were explicitly marked `pub`. The `pub` modifier means
    the function is public and will be exported.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the WebAssembly module using Cargo:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `wasm-bindgen` CLI to generate the binding file for the WebAssembly
    module generated:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will generate the binding files and type definition files as we have seen
    in the previous chapter. Let's look at the `class_world.js` file first. This file
    will be similar to the file generated in previous chapters except for the `Point`
    class. The `Point` class has all the getters, the setters, and the `add` function
    in it. The functions use the pointer to their references.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `wasm-bindgen` produces a static method called `__wrap` that creates
    the `Point` class object and attaches a pointer to it. It adds a free method that
    in turn calls the `__wbg_point_free` method inside the WebAssembly module. This
    method is responsible for freeing up the memory taken by the `Point` object or
    class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following files. We will use them in the other sections too:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下文件。我们将在其他部分也使用它们：
- en: 'Create `webpack.config.js`. This holds the webpack configuration:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`webpack.config.js`。它包含webpack配置：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create `package.json` and add the following content:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`package.json`并添加以下内容：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create an `index.js` file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.js`文件：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run `npm install`. Modify `index.js` with the following content:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次运行`npm install`。用以下内容修改`index.js`：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We call the new method in the `Point` class and pass it `x` and `y`. We print
    the `x` and `y` coordinates. This will print `10, 10`. Then, we will create another
    point (`p2`). Finally, we call the `add` function and pass it point `p2`. This
    will print `13, 13`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Point`类中调用新方法，并传递`x`和`y`参数。我们打印`x`和`y`坐标。这将打印`10, 10`。然后，我们将创建另一个点（`p2`）。最后，我们调用`add`函数，并传递点`p2`。这将打印`13,
    13`。
- en: 'The getter method uses the pointer and fetches the value from the shared array:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取器方法使用指针从共享数组中获取值：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the setter method, we pass in the pointer and the value. Since we are just
    passing in a number here, there is no extra conversion needed:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置器方法中，我们传递指针和值。由于我们在这里只是传递一个数字，所以不需要额外的转换：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the case of `add`, we take the argument, get the pointer to the `Point`
    object, and pass it to the WebAssembly module:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`add`函数的情况下，我们获取参数，获取`Point`对象的指针，并将其传递给WebAssembly模块：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`wasm-bindgen` makes it simple to convert a class into a WebAssembly module.
    We have seen how to share a class in Rust with JavaScript. Now, we will see how
    to share a class from JavaScript with Rust.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen`使将类转换为WebAssembly模块变得简单。我们已经看到了如何在Rust中与JavaScript共享一个类。现在，我们将看到如何从JavaScript与Rust共享一个类。'
- en: Sharing classes from JavaScript with Rust
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript与Rust共享类
- en: Sharing JavaScript classes with Rust is also made easy with `#[wasm_bindgen]`.
    Let's look at how to achieve it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#[wasm_bindgen]`，JavaScript类与Rust的共享也变得简单。让我们看看如何实现它。
- en: JavaScript classes are objects with some methods. Rust is a strictly typed language.
    This means the Rust compiler needs to have concrete bindings. Without them, the
    compiler complains, because it needs to know about the lifetime of an object.
    We need a way to ensure the compiler has this API available at runtime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript类是具有一些方法的对象。Rust是一种强类型语言。这意味着Rust编译器需要具体的绑定。如果没有它们，编译器会报错，因为它需要了解对象的生命周期。我们需要一种方法来确保编译器在运行时可以访问这个API。
- en: The extern C function block helps out here. The extern C makes a function name
    available in Rust.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 外部C函数块在这里很有帮助。extern C使得函数名在Rust中可用。
- en: 'In this example, let''s see how to share a class from JavaScript with Rust:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看如何将JavaScript中的类与Rust共享：
- en: 'Let''s create a new project:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the `wasm-bindgen` dependency for the project. Open the `cargo.toml`
    file and add the following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目定义`wasm-bindgen`依赖项。打开`cargo.toml`文件，并添加以下内容：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please copy over `package.json`, `index.js`, and `webpack-config.js` from the
    previous section. Then, run `npm install`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请将上一节中的`package.json`、`index.js`和`webpack-config.js`复制过来。然后，运行`npm install`。
- en: 'Open the `src/lib.rs` file and replace the contents with the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/lib.rs`文件，并用以下内容替换其内容：
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At `//1`, we are importing the JavaScript module. This will import a JavaScript
    file, `point.js`. Note that this file should be present in the same directory
    as `Cargo.toml`. Then, we create an extern C block to define the methods that
    we need to use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`//1`处，我们正在导入JavaScript模块。这将导入一个JavaScript文件，`point.js`。注意，这个文件应该位于与`Cargo.toml`相同的目录中。然后，我们创建一个extern
    C块来定义我们需要使用的方法。
- en: We first declare a type in the block (`pub type Point;`). Now, we can use this
    as any other type in the Rust code. After that, we define a list of functions.
    We first define the constructor. We pass in the constructor as an argument to
    the `#[wasm_bindgen]` annotation. Define a function that takes in arguments and
    returns the type declared previously. This will bind to the namespace of the Point
    type, and we can call `Point::new(x, y);` inside the Rust function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在块中声明一个类型（`pub type Point;`）。现在，我们可以在Rust代码中像使用任何其他类型一样使用它。之后，我们定义一系列函数。我们首先定义构造函数。我们将构造函数作为参数传递给`#[wasm_bindgen]`注解。定义一个接受参数并返回之前声明的类型的函数。这将绑定到Point类型的命名空间，我们可以在Rust函数内部调用`Point::new(x,
    y);`。
- en: Then, we define getters and setters (`//4` and `//5`, respectively). We can
    even define a method; these are analogous to the function on the JavaScript side.
    Then, we have the `add` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义获取器和设置器（分别对应`//4`和`//5`）。我们甚至可以定义一个方法；这些与JavaScript侧上的函数类似。然后，我们有`add`函数。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the functions inside the extern C block are completely typed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 C 块内的所有函数都是完全类型化的。
- en: Finally, we are exporting the `get_precious_point()` function using the `#[wasm_bindgen]`
    annotation. In the `get_precious_point` function, we create two `Point` with `Point::new(x,
    y)`, then add two points using `p1.add(p2)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `#[wasm_bindgen]` 注解导出 `get_precious_point()` 函数。在 `get_precious_point`
    函数中，我们使用 `Point::new(x, y)` 创建两个 `Point`，然后使用 `p1.add(p2)` 添加两个点。
- en: We can call this from JavaScript just like we did before. We also have to define
    a `Point` class on the JavaScript side.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样从 JavaScript 中调用它。我们还需要在 JavaScript 端定义一个 `Point` 类。
- en: 'Create `Point.js` with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建 `Point.js`：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, replace `index.js` with the following:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下内容替换 `index.js`：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, run the following command to start the server:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以启动服务器：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the browser and run `http://localhost:8000`. Open the developer console
    to see the printed object class.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并运行 `http://localhost:8000`。打开开发者控制台以查看打印的对象类。
- en: 'Let''s see how the `#[wasm_bindgen]` macro is expanding the code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看 `#[wasm_bindgen]` 宏是如何扩展代码的：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a few interesting things happening here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些有趣的事情。
- en: 'First, the `type` point is converted into a struct. This is similar to what
    we did in the previous example. But the struct''s members are JsValue instead
    of `x` and `y`. This is because `wasm_bindgen` will not know what this Point class
    is instantiating. So, it creates a JavaScript object and makes that its member:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`type` 点被转换成一个结构体。这与我们在上一个示例中所做的是类似的。但是，结构体的成员是 `JsValue` 而不是 `x` 和 `y`。这是因为
    `wasm_bindgen` 不会知道这个 `Point` 类正在实例化什么。因此，它创建一个 JavaScript 对象并将其作为成员：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It also defines how to construct the Point object and how to dereference it.
    This is useful for the WebAssembly runtime to know when to allocate and when to
    dereference it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它还定义了如何构造 `Point` 对象以及如何解引用它。这对于 WebAssembly 运行时知道何时分配和何时解引用它是有用的。
- en: 'All the methods that are defined are converted into the implementation of the
    Point struct. As you can see, there is a lot of unsafe code in the method declaration.
    This is because the Rust code interacts directly with the raw pointers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所定义的所有方法都被转换成 `Point` 结构体的实现。正如你所看到的，方法声明中有大量的 unsafe 代码。这是因为 Rust 代码直接与原始指针交互：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Shown in the previous code is the code generated by the `#[wasm_bindgen(constructor)]`
    macro. It first links the code with the extern C block. The arguments are then
    cast such that they are inferred in WebAssembly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中展示了由 `#[wasm_bindgen(constructor)]` 宏生成的代码。它首先将代码与 extern C 块链接起来。然后，参数被转换，以便在
    WebAssembly 中推断。
- en: Then, we have the unsafe block. First, space is reserved in the global stack.
    Then, both `x` and `y` are converted into the `IntoWasmAbi` type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有 unsafe 块。首先，在全局栈中预留空间。然后，`x` 和 `y` 都被转换成 `IntoWasmAbi` 类型。
- en: '`IntoWasmAbi` is a trait for anything that can be converted into a type that
    can cross the WebAssembly ABI directly, for example, u32 or f64\. Then, the function
    in JavaScript is called. The returned value is then cast into a `Point` type using
    `FromWasmAbi`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntoWasmAbi` 是一个 trait，用于任何可以转换为可以直接跨越 WebAssembly ABI 的类型的任何东西，例如 u32 或 f64。然后，调用
    JavaScript 中的函数。然后，使用 `FromWasmAbi` 将返回值转换成 `Point` 类型。'
- en: '`FromWasmAbi` is a trait for anything that can be recovered by value from the
    WebAssembly ABI boundary; for example, a Rust u8 can be recovered from the WebAssembly
    ABI u32 type.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromWasmAbi` 是一个 trait，用于任何可以从 WebAssembly ABI 边界恢复值的任何东西；例如，Rust u8 可以从 WebAssembly
    ABI u32 类型中恢复。'
- en: We have seen how to share a class in JavaScript with Rust. Now, we will see
    how we can call a JavaScript API in Rust.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Rust 与 JavaScript 共享一个类。现在，我们将看到我们如何在 Rust 中调用 JavaScript API。
- en: Calling the JavaScript API via WebAssembly
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 WebAssembly 调用 JavaScript API
- en: JavaScript provides a rich API to work with objects, arrays, maps, sets, and
    so on. If we want to use or define them in Rust, then we need to provide the necessary
    bindings. Handcrafting those bindings will be a huge process. But what if we have
    bindings to those APIs? That is a common API for both Node.js and a browser environment
    that will create a platform where we can write the code completely in Rust and
    use `wasm_bindgen` to create necessary code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了丰富的 API 来处理对象、数组、映射、集合等。如果我们想在 Rust 中使用或定义它们，那么我们需要提供必要的绑定。手工制作这些绑定将是一个巨大的过程。但是，如果我们已经有了这些
    API 的绑定呢？这是一个既适用于 Node.js 也适用于浏览器环境的通用 API，它将创建一个平台，我们可以在这个平台上完全用 Rust 编写代码，并使用
    `wasm_bindgen` 来创建必要的代码。
- en: The rustwasm team's answer to that is the js-sys crate.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: rustwasm 团队对此的答案是 js-sys crate。
- en: The js-sys crate contains raw `#[wasm_bindgen]` bindings to all the global APIs
    guaranteed to exist in every JavaScript environment by the ECMAScript standard.
    – RustWASM
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: They provide bindings to JavaScript's standard built-in objects, including their
    methods and properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s see how to call a JavaScript API via WebAssembly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a default project with the `cargo new` command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copy over `webpack.config.js`, `index.js`, and `package.json` similarly to the
    previous example. Then, open the generated project in your favorite editor.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the contents of `Cargo.toml`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, open `src/lib.rs` and replace the file with the following content. We
    can create a JavaScript map inside Rust using the following snippet:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Added to the `wasm_bindgen` import, we imported the map from the `js_sys` crate
    using `use js_sys::Map;`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define the `new_js_map` function, which will return a new map:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `set_get_js_map` function creates a new map, sets a value in the map, and
    then returns the value set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Note that the return type here is `JsValue`. This is a wrapper in Rust for specifying
    the JavaScript values. Also, note that we are passing the string into the trait
    functions get and set. This will return `bar` as the output when called in JavaScript.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'We now also run through the map using `for_each` inside the Rust code like
    this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This creates a map and then loads the map with the values `1`, `2`, `3`, `4`,
    and `5`. Then, it runs over the created map and adds the value together. This
    will produce an output of `15` (that is, 1 + 2 + 3 + 4 + 5).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we replace `index.js` with the following content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running this on the browser will print the result. Refer to the comments near
    the console log statements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the generated JavaScript binding file. The generated binding
    JavaScript file has almost the same structure as in the previous section, but
    with a few more functions exported.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The heap object is used as a stack here. All the JavaScript objects that are
    shared or referenced with the WebAssembly modules are stored in this heap. It
    is also important to note that once a value is accessed, it is popped out from
    the heap.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `takeObject` function is used to fetch the object from the heap. It first
    gets the object at the given index. Then, it removes the object from that heap
    index (that is, it pops it out). Finally, it returns the value `ret`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can use JavaScript APIs inside Rust. The bindings are only generated
    for the common JavaScript API (including Node.js and the browser).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to call the JavaScript API in Rust. Now, we will see how we
    can call a Rust closure via WebAssembly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Calling closures via WebAssembly
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Rust book defines closures as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Closures are anonymous functions which you can save in a variable or can be
    passed as arguments to other functions. - The Rust Programming Language (Covers
    Rust 2018) by Steve Klabnik and Carol Nichols ([https://doc.rust-lang.org/book/ch13-00-functional-features.html](https://doc.rust-lang.org/book/ch13-00-functional-features.html))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是无名函数，你可以将其保存到变量中，或者将其作为参数传递给其他函数。- 《Rust 编程语言》（涵盖 Rust 2018）由 Steve Klabnik
    和 Carol Nichols 编著 ([https://doc.rust-lang.org/book/ch13-00-functional-features.html](https://doc.rust-lang.org/book/ch13-00-functional-features.html))
- en: 'MDN defines a closure for JavaScript as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MDN 将 JavaScript 中的闭包定义为如下：
- en: A closure is the combination of a function and lexical environment within which
    that function was declared.- MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是函数和其声明时所处词法环境的组合。- MDN Web 文档 ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#closure))
- en: In general, closures are self-contained blocks of functionality that are tossed
    around and used in the code. They can capture and store references to the variables
    from the context in which they are defined.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，闭包是自包含的功能块，可以在代码中传递和使用。它们可以捕获并存储定义它们上下文中的变量引用。
- en: Closures and functions are similar except for a subtle difference. Closures
    will capture the state when it is first created. Then, whenever a closure is called,
    it closes over that captured state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包和函数相似，除了一个细微的区别。闭包会在第一次创建时捕获状态。然后，每次调用闭包时，它都会覆盖这个捕获的状态。
- en: Closures are functions with a state. When you create a closure, it captures
    the state. Then, we can pass around closures just like any other function. When
    a closure is then invoked, it closes over this captured state and executes (even
    when the closure is invoked outside of their captured state). That is one of the
    important reasons why the use of closures is increasing on the functional side
    of JavaScript.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是有状态的函数。当你创建闭包时，它会捕获状态。然后，我们可以像传递任何其他函数一样传递闭包。当闭包被调用时，它会覆盖这个捕获的状态并执行（即使闭包在捕获状态之外被调用）。这是闭包在
    JavaScript 函数式编程方面使用越来越多的一个重要原因。
- en: Closures make it easy to do data encapsulation, higher-order functions, and
    memoization. (Sounds functional, right? ;))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包使得数据封装、高阶函数和记忆化变得容易。（听起来像是函数式编程，对吧？ ;))
- en: 'Let''s see how to share closures from JavaScript to Rust and vice versa:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从 JavaScript 到 Rust 以及从 Rust 到 JavaScript 共享闭包：
- en: 'Create a new project:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `wasm-bindgen` dependency for the project. Let''s open the `cargo.toml`
    file and add the content highlighted in bold:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目定义 `wasm-bindgen` 依赖项。让我们打开 `cargo.toml` 文件，并添加加粗的内容：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will need the js-sys crate to copy over the closures from JavaScript into
    Rust. Please copy over `package.json`, `index.js`, and `webpack-config.js` from
    the previous section. Then, run `npm install`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 js-sys 包来将闭包从 JavaScript 复制到 Rust。请从上一节复制 `package.json`、`index.js` 和 `webpack-config.js`。然后，运行
    `npm install`。
- en: 'We then open the `src/lib.rs` file and add the content from our `Point` class
    example with an additional method that takes in JavaScript''s closure function
    as its argument:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开 `src/lib.rs` 文件，并添加来自我们的 `Point` 类示例的内容，以及一个接受 JavaScript 闭包函数作为参数的额外方法：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will change `index.js` to call the `distance` function with a closure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更改 `index.js` 以使用闭包调用 `distance` 函数：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's spin the webpack server with `npm run serve`. This will print out `3`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `npm run serve` 启动 webpack 服务器。这将打印出 `3`。
- en: The js-sys crate offers an option to invoke the JavaScript function using the
    apply and call method. That is what we have done by calling `js_func.call2(&this,
    &x, &y)`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: js-sys 包提供了一种使用 apply 和 call 方法调用 JavaScript 函数的选项。这正是我们通过调用 `js_func.call2(&this,
    &x, &y)` 来实现的。
- en: Rust does not have function overloading. This means that we have to use different
    method names based on the number of arguments that we pass. So, `js-sys` offers
    us `call1`, `call2`, `call3`, and so on, each taking `1`, `2`, `3`, and so on
    arguments, respectively.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有函数重载。这意味着我们必须根据传递的参数数量使用不同的方法名。因此，`js-sys` 为我们提供了 `call1`、`call2`、`call3`
    等等，分别接受 `1`、`2`、`3` 等等个参数。
- en: Invoking a JavaScript function in Rust will return `Result<JsValue, Error>`.
    We will unwrap the result to get the JsValue and return it. `wasm-bindgen` will
    create the necessary binding to return the value as a number in JavaScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中调用 JavaScript 函数将返回 `Result<JsValue, Error>`。我们将展开结果以获取 JsValue 并返回它。`wasm-bindgen`
    将创建必要的绑定，以便将值作为数字在 JavaScript 中返回。
- en: On the other hand, passing a closure from Rust to JavaScript will need some
    extra information and options.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将闭包从 Rust 传递到 JavaScript 需要一些额外的信息和选项。
- en: '`wasm-bindgen` supports two variants here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 在这里支持两种变体：'
- en: Stack lifetime closures
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈生命周期闭包
- en: Heap-allocated closures
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆分配的闭包
- en: 'Let''s see what they actually mean:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们实际上意味着什么：
- en: Stack lifetime closures should not be invoked by JavaScript again once the imported
    JavaScript function that the closure was passed to returns. This is because once
    the function (closure) returns, the closure will be invalidated by Rust. Any future
    invocations will lead to an exception. In other words, stack lifetime closures
    are short-lived and they go out of context once they are accessed.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦将闭包传递给导入的 JavaScript 函数后，堆栈生命周期闭包不应再次被 JavaScript 调用。这是因为一旦函数（闭包）返回，Rust 将使闭包失效。任何未来的调用都将导致异常。换句话说，堆栈生命周期闭包是短暂的，一旦被访问，它们就会超出上下文。
- en: On the other hand, heap-allocated closures are useful for invoking the memory
    multiple times. Here, the validity is tied to the lifetime of the closure in Rust.
    Once the closure in Rust is dropped, the closure will deallocate and garbage will
    be collected. This will in turn invalidate the closure (function) in JavaScript.
    Once invalidated, any further attempts to access the closure or memory will raise
    an exception.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，堆分配的闭包对于多次调用内存非常有用。在这里，其有效性与 Rust 中闭包的生命周期相关联。一旦 Rust 中的闭包被丢弃，闭包将进行解分配，垃圾回收器将进行垃圾回收。这将反过来使
    JavaScript 中的闭包（函数）失效。一旦失效，任何进一步尝试访问闭包或内存的操作都将引发异常。
- en: Both the stack lifetime and heap-allocated closures support both `Fn` and `FnMut`
    closures, arguments, and return values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈生命周期和堆分配的闭包都支持 `Fn` 和 `FnMut` 闭包、参数和返回值。
- en: We have seen how to call a closure function. Now, we will see how to import
    a function from JavaScript into Rust.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何调用闭包函数。现在，我们将了解如何将 JavaScript 中的函数导入 Rust。
- en: Importing the JavaScript function into Rust
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JavaScript 函数导入 Rust
- en: In certain places, JavaScript is faster than WebAssembly because there is no
    overhead of boundary crossing and instantiating a separate runtime environment.
    JavaScript runs more naturally in its own environment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些地方，JavaScript 比 WebAssembly 快，因为没有边界跨越和实例化单独运行时环境的开销。JavaScript 在其自身环境中运行得更自然。
- en: The JavaScript ecosystem is huge. There are millions of libraries created and
    battle tested (not all of them, of course) with JavaScript. This makes JavaScript
    easy (easy here is subjective).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 生态系统非常庞大。有成千上万的库是用 JavaScript 创建并经过实战检验的（当然，并非全部），这使得 JavaScript
    变得容易（这里的“容易”是主观的）。
- en: WebAssembly addresses the most important problem that we have in the frontend
    world, that of "consistent" performance. But it is not a complete replacement
    for JavaScript. WebAssembly helps JavaScript to deliver better and more consistent
    performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 解决了前端世界最重要的一个问题，即“一致”的性能问题。但它并不是 JavaScript 的完全替代品。WebAssembly 帮助
    JavaScript 提供更好和更一致的性能。
- en: JavaScript will be a default choice in most places. It is important to provide
    an ecosystem that allows seamless integration between the two. We have already
    seen how to import a class from JavaScript into Rust. Similarly, we can import
    anything from JavaScript into Rust using `wasm-bindgen`. The most important part
    is that we can more naturally use these imported JavaScript functions inside Rust
    code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将在大多数地方成为默认选择。提供允许两个系统无缝集成的生态系统很重要。我们已经看到了如何将 JavaScript 中的类导入 Rust。同样，我们可以使用
    `wasm-bindgen` 将任何内容从 JavaScript 导入 Rust。最重要的是，我们可以在 Rust 代码中更自然地使用这些导入的 JavaScript
    函数。
- en: 'In this example, let''s see how to import a JavaScript function into Rust:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看如何将 JavaScript 函数导入 Rust：
- en: 'Create a new project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `wasm-bindgen` dependency for the project. Let''s open the `cargo.toml`
    file and add the content highlighted in bold:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目定义 `wasm-bindgen` 依赖项。让我们打开 `cargo.toml` 文件，并添加以下加粗内容：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Please copy over `package.json`, `index.js`, and `webpack-config.js` from the
    previous section. Then, run `npm install`. Then, open the `src/lib.rs` file and
    replace its content with the following:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We start by importing the `wasm_bindgen` library. Then, we define the extern
    C block to define the FFI functions (that is, the functions that we import from
    JavaScript). Inside the extern C block, we define the function signature similar
    to what the Rust compiler understands. We also annotate the extern C block with
    `#[wasm_bindgen(module ="./array")]`. This helps the `wasm-bindgen` CLI to understand
    where the functions are defined and exported. It will use this information and
    create the necessary link.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `array.js` file is in the same directory as the `cargo.toml` file. We will
    define `array.js` as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The functions mentioned previously should be exported in the JavaScript file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We then declare a function (`sum_of_square_root`) in Rust and export it as a
    function in the WebAssembly module that is generated. We first call the `getNumber()`
    method from JavaScript. We use the return value and then run the `for` loop for
    the length of the array. For each loop, we call `topArray` to get the lowest element
    from the array. Then, we take the square root of the number (this happens in Rust
    code). Sum them up and return the sum (`15` for the example that we saw previously).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'We will replace `index.js` with the following content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's run the previous code with `npm run serve`. Go to the URL and open the
    developer console. `15` and `HEYA! I AM ALL CAPS` will be printed in the console.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the generated binding JavaScript file. It will be interesting to see that
    both the `getNumber` and `topArray` functions are not available in the generated
    binding JavaScript file. The main reason for this is we are just sharing numbers
    between the JavaScript and the WebAssembly module. Hence, the boundary crossing
    happens more naturally in this case.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But there will be a function exported for the `some_string_to_share` function.
    This is because we are sharing a string, which needs conversion. So, the binding
    file will make the necessary conversion to work with the string. It is also important
    to note that there is a `getInt64Memory` function. This is because we are returning
    `f64` as output. `wasm-bindgen` converts the number into `bigInt` and returns
    it to JavaScript.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-bindgen` also does the necessary shifting and parsing of the byte buffer
    based on the byte size of the memory object. For `Uint32Array`, the pointer and
    memory are calculated as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For `BigInt64Array`, the pointer and memory are calculated as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have seen how to import a JavaScript function into Rust. Now, we will see
    how we can call a web API in Rust.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Calling a web API via WebAssembly
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The evolution of the web has been phenomenal, with its growth being attributed
    to its open standards. Today, the web provides hundreds of APIs, which makes it
    easy for web developers to develop for audio, video, canvases, SVGs, USBs, batteries,
    and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的发展是惊人的，其增长归功于其开放标准。今天，网络提供了数百个API，这使得网络开发者能够轻松地为音频、视频、画布、SVG、USB、电池等开发。
- en: The web is universal and omnipresent. It is continuously experimented with and
    changed to make it desirable and easy for developers and companies to use, respectively.
    The web-sys crate provides access to almost all the APIs that are available on
    the web at the moment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是普遍存在的。它不断地被实验和改变，以使其对开发者和公司来说既吸引人又易于使用。`web-sys`包提供了对目前网络上几乎所有API的访问。
- en: 'The `web-sys` crate provides raw bindings to all the Web''s APIs: everything
    from DOM manipulation to WebGL to Web Audio to timers to fetch and more! – web-sys
    crates.io ([https://crates.io/crates/web-sys](https://crates.io/crates/web-sys))'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-sys`包提供了对Web所有API的原始绑定：从DOM操作到WebGL、Web Audio、计时器、fetch等！ – web-sys crates.io
    ([https://crates.io/crates/web-sys](https://crates.io/crates/web-sys))'
- en: The WebIDL interface definitions are converted into `wasm-bindgen`'s internal
    **abstract syntax trees** (**ASTs**). Then, these ASTs are used to create zero-overhead
    Rust and JavaScript glue code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WebIDL接口定义被转换为`wasm-bindgen`的内部**抽象语法树**（**ASTs**）。然后，这些ASTs被用来创建零开销的Rust和JavaScript粘合代码。
- en: With the help of this binding code, we can call and manipulate the web APIs.
    Converting the web APIs into Rust ensures the type information of parameters and
    return values is handled correctly and safely.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个绑定代码的帮助下，我们可以调用和操作网络API。将网络API转换为Rust确保了参数和返回值的类型信息被正确且安全地处理。
- en: 'In this example, let''s call a web API via WebAssembly:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们通过WebAssembly调用一个网络API：
- en: 'Create a default project with the `cargo new` command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new`命令创建一个默认项目：
- en: '[PRE39]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Copy over `webpack.config.js`, `index.js`, and `package.json` similarly to
    the `jsapi` section (in the above section). We''ll now open the generated project
    in our favorite editor. Let''s change the contents of `cargo.toml`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`webpack.config.js`、`index.js`和`package.json`的内容与`jsapi`部分（在上面的部分）类似地复制过来。现在，我们将打开生成的项目到我们最喜欢的编辑器中。让我们更改`cargo.toml`的内容：
- en: '[PRE40]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The major difference here is that instead of just defining the dependency and
    its version, we also defined the features that we will be using in this example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于，我们不仅定义了依赖及其版本，还定义了我们将在此示例中使用的功能。
- en: Why do we need it? Since there is a huge number of APIs in the web ecosystem,
    we do not want to carry bindings for all of them. The binding files are created
    and used only for the listed features.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要它？由于网络生态系统中存在大量的API，我们不希望携带所有这些API的绑定。绑定文件仅用于列出的功能。
- en: 'Let''s open `src/lib.rs` and replace the file with the following content:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`src/lib.rs`并将文件替换为以下内容：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We first fetch the window using `web_sys::window()`. The unwrap at the end makes
    sure the window is available. If it is not, it will throw an error. After that,
    we get the document from the window object. We then create a `div` element with
    `document.createElement`. Then, we create an SVG and circle document element and
    append the circle to the SVG element. Finally, we append the SVG as a child to
    the `div` element and return the `div` element.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`web_sys::window()`获取窗口。最后的unwrap确保窗口可用。如果不可用，它将抛出一个错误。之后，我们从窗口对象中获取文档。然后，我们使用`document.createElement`创建一个`div`元素。然后，我们创建一个SVG和圆形文档元素，并将圆形添加到SVG元素中。最后，我们将SVG作为子元素添加到`div`元素中，并返回`div`元素。
- en: The API is quite similar to the web API except for the fact that the method
    names are using snake case instead of camel case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: API与Web API非常相似，只是方法名使用的是蛇形命名法而不是驼峰命名法。
- en: 'We will change `index.js` to use this element as a web component:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更改`index.js`以使用此元素作为Web组件：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, what have we done here? We first imported the binding file, which will,
    in turn, initialize the WebAssembly module. Once the WebAssembly module is initialized,
    we create a `Pie` class that extends the HTML element. Inside the class' constructor,
    we call the `super` method. Then, we create a shadow DOM. We add a style element
    to the shadow DOM, and then define the style for the element.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里做了什么？我们首先导入绑定文件，这将反过来初始化WebAssembly模块。一旦WebAssembly模块初始化完成，我们创建一个扩展HTML元素的`Pie`类。在类的构造函数中，我们调用`super`方法。然后，我们创建一个阴影DOM。我们在阴影DOM中添加一个样式元素，然后定义元素的样式。
- en: We go on to append the style element to the shadow element, and then add the
    element that is exported from the Rust code. We then register it as a custom element
    named `pie-chart`. Finally, we append the custom element to our document's body
    to see the pie chart getting displayed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续将样式元素附加到阴影元素上，然后添加从Rust代码导出的元素。然后我们将其注册为名为`pie-chart`的自定义元素。最后，我们将自定义元素附加到文档的主体中，以查看饼图被显示出来。
- en: 'Now, run the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Open the browser to see the pie chart.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器查看饼图。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how `wasm-bindgen` makes it easy to share complex objects
    between JavaScript and Rust. The annotations make it easy to mark a function to
    export/import between JavaScript and WebAssembly. We also saw how js-sys and web-sys
    Cargo make it easier to call JavaScript and web APIs inside Rust code easily.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了`wasm-bindgen`如何使JavaScript和Rust之间共享复杂对象变得容易。注释使得标记一个函数以导出/导入JavaScript和WebAssembly变得简单。我们还看到了如何使用js-sys和web-sys
    Cargo在Rust代码中轻松调用JavaScript和Web API。
- en: In the next chapter, we will see how to optimize the generated WebAssembly module
    in Rust.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在Rust中优化生成的WebAssembly模块。
