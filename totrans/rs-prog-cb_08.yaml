- en: Safe Programming for the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since the popular Rails framework for the Ruby programming language, creating
    backend web services seemed like a domain for dynamically typed languages. This
    trend was only reinforced by the rise of Python and JavaScript as primary languages
    for these tasks. After all, the nature of these technologies made creating these
    services especially fast and changes to services (for example, a new field in
    the JSON response) are simple to do. Returning to static types for web services
    feels strange for many of us; after all, it takes a lot longer to get *something* going.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a cost to these: many services are deployed in the cloud
    nowadays, which means that a pay-as-you-go model is employed together with (practically)
    infinite scalability. Since—most notably—Python is not known for its execution
    speed, we can now see the cost of this overhead on the bill from the cloud provider.
    A 10% faster execution time can mean serving 10% more customers on the same hardware
    at the same level of quality (for example, response time). Similarly, smaller
    devices benefit from lower resource usage, which translates into faster software
    and therefore less energy consumed. Rust, as a systems programming language, was
    built with zero overhead in mind and is a close rival to C in many aspects such
    as speed or efficiency. It is therefore not unreasonable for heavily used web
    services to write critical parts in Rust, a move that has famously been made by
    Dropbox to improve its service quality and save costs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust is a great language for the web and, in this chapter, we are looking at
    creating a regular RESTful API using a framework that is in use at many different
    applications and developed at Microsoft. You can look forward to learning about
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling JSON payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering HTML templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an ORM to save data to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running advanced queries using an ORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication on the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last few years, web servers have changed. Where early web applications
    have been deployed behind some sort of web server application such as Apache Tomcat
    ([http://tomcat.apache.org/](http://tomcat.apache.org/)), IIS ([https://www.iis.net/](https://www.iis.net/)),
    and nginx ([https://www.nginx.com/](https://www.nginx.com/)), it is now more common
    to embed the serving part into the application as well. Not only is this easier
    on the Ops people, it also allows developers to have tight control over the entire
    application. Let's see how we can get started and set up a basic static web server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up a Rust binary project using `cargo new static-web`. Since we are
    going to serve stuff on local port `8081`, make sure that the port is accessible
    as well. Inside the newly created project folder, we need an additional folder, `static/`,
    where you can put an interesting `.jpg` image and serve it. We are going to assume
    that this image is called `foxes.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to set up and run our own web server in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` first, and let''s add some code. We will work our way down
    to the `main` function, starting with imports and a simple index handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not going to be the only request handler, however, so let''s add a
    few more to see how request-handling works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s missing is the `main` function. This `main` function starts the server
    and attaches the services we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first handler, we mention a static `index.html` handle, which we haven''t
    yet created. Add a simple `marquee` output to a new file and save it as `static/index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing that we are still need to do is adjust `Cargo.toml`. Declare
    the dependencies in `Cargo.toml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a Terminal to execute `cargo run` and run the code, then open a browser
    window at `http://localhost:8081/`, `http://localhost:8081/welcome`, `http://localhost:8081/foxes`,
    and `http://localhost:8081/somethingarbitrary/10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for `http://localhost:8081`, handled by the `index` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7d7d636-1c6d-4374-9972-f8b2bcb88743.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also call the welcome handler at `http://localhost:8081/welcome`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd5b036f-2750-4554-a671-803761ba3eb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our static handler returns a photo of the Mozilla office in Berlin at `http://localhost:8081/foxes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a78dedb7-20a5-4320-ba71-134a7ac1947c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we added a path handler that parses a string and an integer from the
    path, only to return the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd845229-2c6e-468d-a19a-3ec92867e03d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To verify the requests were actually handled by our web server, you should
    view the individual requests in the log output of the Terminal running `cargo
    run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`actix-web` ([https://actix.rs](https://actix.rs)) is a versatile web framework
    and it—among other things—efficiently serves static files as well. In this recipe,
    we covered how to declare and register request handlers, as well as some ways
    to provide responses. In a typical web framework, there are several ways to achieve
    these tasks (declaring handlers, creating responses) and *steps 1 *to *3* show
    two ways to do this with `actix-web`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using an attribute (`#[get("/foxes")]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the service registration call (`.service(web::resource("/welcome").to(rust_cookbook)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the way we associate a handler with a route, each of them is wrapped
    into a factory that creates new handler instances on demand, which is very visible
    when a compiler error points to the `#[get(...)]` attribute instead of the actual
    function. The paths include typed placeholders for passing data from the path
    into the handler function—but more on that in the next recipe (*Designing a RESTful
    API*).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we also add logging middleware that logs the user agent, time,
    and IP address so we can see requests also on the server side. All of this is
    done using `actix-web` method chaining, which structures the calls nicely. The
    call to `run()` blocks the application and starts the actix main loop.
  prefs: []
  type: TYPE_NORMAL
- en: The photo in *step 6* was taken in Mozilla's Berlin office during Rust All Hands
    2019\. Yes, those are Firefox pillows.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* adds a very basic `index.html` file to be served, while *step 5* declares
    the dependencies in `Cargo.toml` as we have done before.'
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we are running the code and showing the output—both in the
    browser and the logging.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned the basics of setting up a web server. Equipped with
    this knowledge of serving static files and images, as well as parsed path parameters,
    we can move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost everything relies on web resources—from a single page application that
    dynamically fetches data via JavaScript and displays it in HTML to the app integration
    for a particular service. A resource on a web service can be anything but it's
    typically expressed using readable URIs so information is already transferred
    by using a specific path, which then only accepts the required information it
    needs to process. This allows structuring code internally and globally utilizes
    all `HTTP` methods to create an expressive interface that developers can use.
    RESTful APIs ([https://www.codecademy.com/articles/what-is-rest](https://www.codecademy.com/articles/what-is-rest))
    ideally capture all of these benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up a Rust binary project using `cargo new api`. Since we are going
    to serve stuff on local port `8081`, make sure that the port is accessible as
    well. Inside the newly created project folder, we need an additional `static/` folder, where
    you can put an interesting `.jpg` image to serve. Additionally, make sure that
    there is a program such as `curl` ([https://curl.haxx.se/](https://curl.haxx.se/)) available
    on your command line. Alternatively, Postman ([https://www.getpostman.com/](https://www.getpostman.com/))
    is a tool that does the same thing with a graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build an API with a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` to add the primary code for the server and handling requests.
    Let''s go step by step and start with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are defining a few handlers that take requests and use that data somehow.
    Add these lines to `main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should also register the handlers with the web server. The following
    is the `main` function for `main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we should adapt `Cargo.toml` to include these new dependencies as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build and run the app using `cargo run`. Then, let''s see whether
    we can reach the APIs using `curl` or Postman, which should result in a similar
    logging output to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the `curl` requests—they should be easy to replicate with
    Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That's it, but there is a lot to unpack so let's see why this works the way
    it does.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing *good* APIs is hard and requires a good grasp of what's possible—especially
    with new frameworks and languages. `actix-web` has proven itself to be a versatile
    tool that proficiently uses types to achieve great results. *Step 1* sets this
    up by importing a few types and traits.
  prefs: []
  type: TYPE_NORMAL
- en: Only in *step 2* and *step 3* does it get more interesting. Here, we define
    the various handlers in almost all of the ways `actix-web` allows us to, by either
    using the attribute that wraps a function into a factory (underneath it's all
    asynchronous actors; check out *Handle asynchronous messages with actors* in [Chapter
    4](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml), *Fearless Concurrency* ) or letting
    the `web::resource()` type do that. Either way, every handler function has a route
    associated with it and will be called in parallel. The routes also contain parameters
    that can be specified using a `{}` syntax that also allows regular expression
    (see the route containing `"{tail:.*}" - a` shorthand that receives the path's
    remainder under the `tail` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t let users directly access files on your filesystem as we did here. This
    is a bad idea in many ways, but most importantly offers a way to execute potentially
    any file in the filesystem. A better way is to provide a white list of abstracted
    files—for example, Base64 ([https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding))-encoded—using
    an independent key: for example, a UUID ([https://tools.ietf.org/html/rfc4122](https://tools.ietf.org/html/rfc4122)).'
  prefs: []
  type: TYPE_NORMAL
- en: If a function provides an input parameter of the `Path<T>` type, then `T` is
    what's checked for in the corresponding path variable. Therefore, if a function
    header expects `i32`, the request will fail for anyone trying to pass a string.
    You can verify that yourself with the `bookmarks/by-id/{id}` path. As an alternative
    to `Path<T>`, you can also receive the entire `HttpRequest` ([https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html](https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html))
    as a parameter and extract the required information with the `.query()` function.
    Both the `echo_bookmark` and `bit_ly` functions demonstrate how to use these.
  prefs: []
  type: TYPE_NORMAL
- en: The responses behave similarly. `actix-web` provides a `Responder` trait that
    is implemented for standard types such as `String` (along with the correct response
    content type as far as we saw), which makes the handler more readable. Again,
    returning an `HttpResponse` type provides more finely controllable returns. Additionally,
    there are results and similar types that are automatically converted into appropriate
    responses, but showing all of these would go beyond the scope of this book. Check
    out the `actix-web` documentation to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: One downside to the attributes is the fact that only one of them can go on top
    of a function—so how can we reuse a function for two different `HTTP` methods?
    `echo_bookmark` is registered to respond to the input ID only on `PUT` and `POST`,
    not on `DELETE`, `HEAD`, `GET`, and more. This is done by guards that forward
    a request only if a condition is met. Check out the docs ([https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html](https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html))
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* shows adaptations to `Cargo.toml` to make it all work and, in *step
    5**,* we get to try out the web service. If you take some time to observe the
    `curl` responses, we receive the expected results. `curl` also does not follow
    redirects by default, hence the `HTTP` response code, `302`, with the location
    header set pointing to where I would go. This redirect is provided by an external
    resource that `actix-web` provides, which is useful for these situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned more about designing APIs in `actix-web`, let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Handling JSON payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning how to create APIs, we need to pass data back and forth. While
    the path provides one method to do that, anything a little more sophisticated
    (for example, a long list of things) will quickly show the limitations of these
    methods. This is why other formats are typically used to structure the data—JSON
    ([http://json.org/](http://json.org/)) is the most popular for web services. In
    this chapter, we are going to use the previous API and enhance it by handling
    and returning JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up a Rust binary project using `cargo new json-handling`. Since we
    are going to serve stuff on the local port `8081`, make sure that the port is
    accessible as well. Additionally, a program such as `curl` or Postman is required
    to test the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, we are going to add the imports first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create some handler functions along with a serializable JSON type.
    Add the following code to `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we are registering the handlers with the web server in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to specify the dependencies in `Cargo.toml`. Replace the existing
    dependencies with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see whether it works by running `cargo run` and issuing requests
    with `curl` from a different Terminal. The commands and their responses should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, the logging output of `cargo run` shows the requests from the server
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This was quick and easy, right? Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding JSON handling to an `actix-web` web service is easy—thanks to the deep
    integration of the popular `serde` crate ([https://crates.io/crates/serde](https://crates.io/crates/serde)).
    After some imports in *step 1*, we declare a `Bookmark` struct as `Serialize`
    and `Deserialize` in *step 2*, which enables `serde` to generate and parse JSON
    for this data type.
  prefs: []
  type: TYPE_NORMAL
- en: The change in the handler functions is also minimal since returning and ingesting
    JSON is a very common task. The required function to return a JSON payload with
    the response is attached to the `HttpResponse` factory method that does everything,
    including setting the appropriate content type. On the ingest part, there is a
    `web::Json<T>` type to take care of deserializing and checking whatever is forwarded
    into the request handler. We can rely on the framework to do most of the heavy
    lifting here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The registering of the handlers in *step 3* is no different from previous recipes;
    the JSON input is only declared in the handler function. There are more variations
    in the `actix-web` docs ([https://actix.rs/docs/request/#json-request](https://actix.rs/docs/request/#json-request))
    and their examples ([https://github.com/actix/examples/tree/master/json](https://github.com/actix/examples/tree/master/json)).
    Similarly, *step 4* contains the required dependencies we have also used in other
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we run the whole project and see how it works: if we pass JSON,
    the input `content-type` header has to be set to the appropriate mime type (`application/json`);
    the return values have this header set as well (and the `content-length` header)
    so browsers or other programs can easily work with the results.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and look at another recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Web error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The various layers of web services make error handling tricky, even without
    security requirements: what to communicate and when? Should an error bubble up
    only to be handled at the last minute or earlier? What about cascades? In this
    recipe, we will uncover some options to do that elegantly in `actix-web`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up a Rust binary project using `cargo new web-errors`. Since we are
    going to serve stuff on the local port `8081`, make sure that the port is accessible
    as well. Additionally, a program such as `curl` or Postman is required to test
    the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are just a few steps away from understanding error handling with `actix-web`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, we are going to add the basic imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As a next step, we are going to define our error types and augment them with
    attributes to make the types known to the framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the handler function to `src/main.rs` and register it in `main()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To import the dependencies, we also have to adapt `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish this recipe, let''s see how everything works together with `cargo
    run` and `curl`. Here is the server output after the requests have been handled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what the requests look like with `curl`''s verbose mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Requesting the wrong ID returns an appropriate HTTP status code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as expected, a request to `/underconstruction` yields an HTTP 500 error
    (internal server error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since that worked well, let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`actix-web` uses an error trait to convert Rust errors into `HttpResponses`.
    This trait is automatically implemented for a range of default errors but only
    by responding with the default *Internal Server Error* message.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1* and *step 2*, we are setting up custom errors so that we can return
    messages that are relevant to what the user is currently doing (or trying to do).
    As with other errors (see [Chapter 5](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml),
    *Handling Errors and Other Results*), we are using enums to provide an umbrella
    to match error variations to. Each of the variants is augmented with an attribute
    that provides a corresponding error message with a format string—an ability provided
    by the `failure` crate ([https://crates.io/crates/failure](https://crates.io/crates/failure)).
    The message here is a last-resort type message for a response code 500 (the default).
    This HTTP response code, along with the body of the error—such as an HTML page—can
    be customized by implementing the `actix_web::error::ResponseError` trait. Whichever
    `HttpResponse` is supplied using the `error_response()` function will be returned
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you call the function yourself, then the `#[fail(display="...")]` message
    won't be attached. Always use Rust's `Result` enum to communicate errors to `actix_web`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* defines the handler functions of the web service and, since it uses
    a JSON response, a struct for serializing the information. In this example, we
    are also using the arbitrary number 10 as a cutoff point for returning an error—using
    a Rust `Result` enum. This provides a framework-agnostic way to handle bad outcomes
    just as if we were working with plain Rust. The second route, `/underconstruction`,
    provides an insight into how `actix-web` routes can be implemented: as a closure.
    Since this immediately returns an error, we have to explicitly tell the compiler
    about the return types and that it''s a `Result` enum that could either be `HttpResponse`
    or `WebError`. We then directly return the latter. *Step 4* shows the required
    dependencies and tells us we have to include the failure crate. In the last step,
    we are running the code and testing it by issuing `curl` requests and checking
    the logs on the server side. That''s nothing too complex, right? If you want to
    go deeper, also check out the `actix-web` docs ([https://actix.rs/docs/errors/](https://actix.rs/docs/errors/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While JSON is a very human-readable format and easy to work with, many people
    still prefer a more interactive experience—such as websites. While this is not
    native to `actix-web`, some template engines provide seamless integration to minimize
    the calls required to assemble and output HTML. The major difference compared
    to simply delivering a static site is that template engines render variable output
    and Rust code into an augmented HTML page to produce content adapted to whatever
    the application's state is. In this recipe, we are taking a look at **Yet Another
    Rust Template Engine** (**Yarte**) ([https://crates.io/crates/yarte](https://crates.io/crates/yarte)) and
    its integration with `actix-web`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a Rust binary project using `cargo new html-templates` and make sure
    that port `8081` is accessible from the localhost. After creating the project
    directory, you''ll have to create some additional folders and files. The image
    files inside the static directory can be any image, as long as there is a Base64-encoded
    version of it available as a text file. Use an online service or the Base64 binary
    ([https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64) on Linux)
    to create your own (you''ll have to change the names in the code accordingly)
    or use ours from the repository. The `.hbs` files will be filled (created) in
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create templated web pages in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add some code to `src/main.rs`. Replace the default snippet with
    the following (note: the Base64-encoded string in `PLACEHOLDER_IMG` is abbreviated
    here. Get the full Base64-encoded image at [https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After adjusting `src/main.rs`, add the required dependencies to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the templates, we need to register a handler to serve them
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s add the bookmark data for the recognized user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For everyone else (unrecognized users), we can simply return an empty vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s start the server in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is ready, but we still lack templates. This is where we add some content
    to the `.hbs` files. First, let''s add code to `templates/index.hbs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After the head, we need an HTML body that marks up the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling a partial inside this last template, so let''s add some code
    to it as well. Open `templates/partials/bookmark.hbs` and insert the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to try this out! Use `cargo run` to start the server logging output
    and open a browser window at `localhost:8081/bookmarks/Hans` as well as `localhost:8081/bookmarks/Claus` to
    see whether it works. Here is what `cargo run` shows after the browser window
    has been opened at the URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the results for an unrecognized user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b92368b6-0067-49e0-863f-17be693eb176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a recognized user, the system returns the appropriate content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce12f078-f0c7-4980-ae72-957f06fd6698.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's find out why this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many languages, creating a template engine is somewhat like an introduction
    tutorial—which is probably where the name Yarte comes from. While the choices
    are many, `actix-web` provides examples with three other engines as well; we recommend
    checking them out in their GitHub repository ([https://github.com/actix/examples](https://github.com/actix/examples)).
    *Step 1* of this recipe already covers some of the important work: importing stuff
    and declaring the view models (as in the MVVM pattern: [https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/](https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/)).
    Yarte provides macro attributes that associate a particular model with a template
    file—and it automatically finds the `templates` folder. If that does not suit
    your project, they allow you to configure the framework accordingly. Find out
    more on their website ([https://yarte.netlify.com/](https://yarte.netlify.com/)).
    We are using a nested model, where the inner struct does not need its own associated
    template.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we are registering the handler function under the `/bookmarks`
    scope and the `/{name}` path, which leads to the URL: `/bookmarks/{name}`. `actix-web`
    is strict in checking the routes, so `/bookmarks/{name}**/**` is going to return
    an error (404). The handler function returns a small list of bookmarks for the
    name Claus but not for anyone else, which—in a more realistic scenario—would come
    out of a database. Regardless, we are using this hardcoded version, and we added
    the logger middleware so we can see what's going on. We are also using a constant
    for the placeholder image, which you can download at [https://blog.x5ff.xyz/other/placeholder.b64](https://blog.x5ff.xyz/other/placeholder.b64).
  prefs: []
  type: TYPE_NORMAL
- en: The templates we are defining in *step 3* are the main difference between engines.
    Using the well-known `{{ rust-code }}` notation, we can augment regular HTML to
    generate more sophisticated output. There are loops of all kinds, conditionals,
    variables, and partials. Partials are important because they let you split the
    view parts into reusable components, which don't even have to be HTML/Yarte templates
    but can be any text.
  prefs: []
  type: TYPE_NORMAL
- en: The compilation process pulls in these templates, combining them with the types
    we declared earlier—with an important consequence. Currently, changing the template
    requires the `main.rs` file to be recompiled, reflect the changes, so using touch
    or similar to set the modified date of `src/main.rs` is recommended. After that,
    `cargo` behaves as if there was a change to `src/main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* implements the partial that shows each bookmark, similarly to the
    index template in *step 3*. Only in *step 5* do we run and look at the results:
    a simple website showing the list of associated bookmarks for when a user is recognized
    (read: has data associated with the name) and when a user is not recognized. The
    minimal design is achieved by using the popular Bootstrap CSS framework ([https://getbootstrap.com](https://getbootstrap.com)).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM to save data to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opinions about object-relational mappers vary considerably: their use was strongly
    encouraged when SQL databases stored all of the World''s data but they quickly
    fell out of favor when it was actually the whole World''s data. Typically these
    frameworks provide a trade-off between ease of use, language integration, and
    scalability. While it''s true that querying terabytes of data requires a fundamentally
    different approach, simple CRUD-type business applications work well with frameworks
    that do the heavy lifting for you and—most importantly—are somewhat independent
    of the actual database they connect to. Rust''s macros come in very handy here—they
    allow the ORM framework to do these things largely at compile time, so it''s memory-safe,
    type-safe, and fast. Let''s see how it''s done.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a Rust binary project using `cargo new orm` and make sure that port
    `8081` is accessible from the localhost. To access the services, get a program
    such as `curl` or Postman to execute `POST`, `GET`, and more type web requests,
    as well as a program to create and manage SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html))
    databases (for example, sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a SQLite database manager, create a new database, `bookmarks.sqlite`, in
    a folder, `db`. Then, add a table that follows this schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to use the `libsqlite3` library and headers in the project.
    On Linux, WSL, and macOS, install the appropriate packages from the package repository.
    On Ubuntu and the WSL, you can use something such as `apt-get install libsqlite3-dev`.
    For other distributions and macOS, please use your preferred package manager to
    install `libsqlite3` and its headers.
  prefs: []
  type: TYPE_NORMAL
- en: Native Windows 10 users may have to download the `dll` binaries from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    and place them into the project directory. However, using Linux/macOS is highly
    recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Get your database queries running in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, we are going to add the basic imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set up some more helper types and a constant for the connection string
    in `main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to need some handlers as well, so let''s add them to the file,
    starting with retrieving bookmarks by their IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out all IDs, we also want to have a handler that returns all bookmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s see whether we can add some bookmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s missing for almost full CRUD is the `delete` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we tie them all together in the `main` function that starts the server
    and attaches these handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, where are the models? They are in their own file, `src/models.rs`. Create
    it and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still another import that we have not yet created: `src/schema.rs`.
    Create that file as well with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we need to adapt `Cargo.toml` to download the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This should set everything up to run the web service with `cargo run` and observe
    the logging output (after the requests):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can interact with the web service with `curl`, and here are the expected
    calls and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`diesel-rs` is Rust''s most well-known database connection framework and provides
    a fast, type-safe, and easy-to-use experience with mapping database tables. This
    is, again, possible thanks to the power of macros, which enable the creation of
    zero-cost abstractions at compile time. However, there is a trade-off for a few
    things and it''s important to learn how to use the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite does not have a very rigid type system. This is why we get away with
    using a generic type for strings called text. Other databases may have more nuanced
    types. Check out SQLite3 types ([https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1*, we are preparing the imports—nothing too interesting but you'll
    notice the declaration of `models.rs` and `schema.rs`. One step further, in *step
    2* we see a connection string (actually just a file path) constant that we'll
    use to connect to the database in the connect function. Additionally, we are making
    a JSON web service so we create the transfer object type, `WebBookmark`. We are
    creating these handlers in *step 3*, one for adding, retrieving (all and by ID),
    and deleting a bookmark entity.
  prefs: []
  type: TYPE_NORMAL
- en: All of these handlers return a `Future` object and run asynchronously. While
    handlers always run asynchronously (they are actors), these return the type explicitly
    since they use a synchronous section to connect to the database—`diesel-rs` is
    not thread-safe right now. This synchronous section is implemented using a `web::block`
    statement that returns a result that is mapped onto `Future` and an appropriate
    `HttpResponse` type. In the case of the `bookmarks_add` handler, it returns the
    newly created ID as a JSON string, while `bookmarks_delete` returns the number
    of rows affected by the delete. All of the handlers return a 500 in the case of
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know how to use connection pooling and properly manage those,
    check out the `actix-web` example for diesel ([https://github.com/actix/examples/tree/master/diesel](https://github.com/actix/examples/tree/master/diesel)).
    It uses Rust's `r2d2` crate ([https://github.com/sfackler/r2d2](https://github.com/sfackler/r2d2)).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* also registers these functions with their respective routes. The `by-id`
    route accepts two different methods (`GET` and `DELETE`) and, thanks to the asynchronous
    nature of the `bookmarks_add` function, the data has to be declared to explicitly
    declare `JsonConfig` to automatically parse JSON input. All of the registrations
    are done using the `to_async` method as well, which makes the attribute method
    impossible to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Only in *step 4* and *step 5* are we creating `diesel-rs`-specific code. `models.rs`
    is a file that contains all of our models, and both of them are abstractions for
    a row in the table, but the `NewBookmark` type takes care of inserting new objects
    (the `table_name` and `Insertable` attributes attach it to the DSL),  while `Bookmark`
    is returned to the user (diesel's `Queryable` and Serde's `Serialize` enable that).
    `schema.rs` contains a macro call declaring the table name (`bookmarks`), its
    primary key (`id`), and its columns (`id` and `url`) along with their datatypes
    as understood by diesel. There are many more types; check out diesel's in-depth
    explanation of `table!` ([https://diesel.rs/guides/schema-in-depth/](https://diesel.rs/guides/schema-in-depth/)).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* shows how `diesel-rs` works with different databases; all of them
    are features that have to be declared. Additionally, diesel has a CLI for database
    migrations and other fun stuff, so check out its getting started guide ([https://diesel.rs/guides/getting-started/](https://diesel.rs/guides/getting-started/))
    for more information. In *step 7*, we finally get to run the web service and insert/query
    some of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: However, let's move on to do more advanced stuff with the ORM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Running advanced queries using an ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major downside of ORMs is typically the complexity of doing things that
    are outside the happy path. SQL—the language relational databases use—is standardized
    but its types are not always compatible with what the application is doing. In
    this recipe, we'll explore a few ways to run more advanced queries in Rust's `diesel-rs.`
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust binary project using `cargo new advanced-orm` and make sure that
    port `8081` is accessible from the localhost. To access the services, get a program
    such as `curl` or Postman to execute `POST`, `GET`, and more type web requests,
    as well as a program to create and manage SQLite ([https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)) databases
    (for example, sqlitebrowser: [https://github.com/sqlitebrowser/sqlitebrowser](https://github.com/sqlitebrowser/sqlitebrowser)).
  prefs: []
  type: TYPE_NORMAL
- en: You can reuse and expand the code from the previous recipe (*Using an ORM to
    save data to a database*) if you ensure you update the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a SQLite database manager, create a new database, `bookmarks.sqlite`, in
    a folder, `db`. Then, add tables that follow these schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to use the `libsqlite3` library and headers in the project.
    On Linux, WSL, and macOS, install the appropriate packages from the package repository.
    On Ubuntu and the WSL, you can use something like `apt-get install libsqlite3-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: Native Windows 10 users may have to download the `dll` binaries from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html) and
    place them into the project directory. However, using Linux/macOS is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use templates in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main.rs` is going to contain the handlers and main function. Let''s start
    by adding some helper types and functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After some imports, let''s set up the helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A new handler will fetch bookmarks with a Julian date. Let''s add it along
    with some other, well-known handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding bookmarks is one of these well-known handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, deleting bookmarks is an important handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can add and delete comments and bookmarks, all we have to do is
    fetch them all at once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we wire everything up in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To save comments alongside bookmarks, we had to expand the schema and models
    as well. Create (or edit) `src/schema.rs` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create or update `src/models.rs` to create the Rust representation of
    these types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To import the dependencies, we also have to adapt `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish this recipe, let''s see how everything works together with `cargo
    run` and `curl`. The requests should respond in line with the following logging
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the server logs generated by the requests, printed to the Terminal
    that `cargo run` runs in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, a lot is going on. Let's find out what.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with `diesel-rs` requires a good understanding of how it works internally
    to achieve the desired results. Check out the previous recipe (*Using an ORM to
    save data to a database*) for some details on the basics. In this recipe, we are
    diving straight into the more advanced stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some basic setup in *step 1*, *step 2* creates a new handler that fetches
    all bookmarks added on a particular day and returns the date as a Julian date
    ([https://en.wikipedia.org/wiki/Julian_day](https://en.wikipedia.org/wiki/Julian_day)).
    The calculation is done using one of SQLite''s few scalar functions: `juliandate()` ([https://www.sqlite.org/lang_datefunc.html](https://www.sqlite.org/lang_datefunc.html)).
    So, how did we get the function into Rust? *Step 4* shows the `diesel-rs` way:
    by using a `sql_function!` macro ([https://docs.diesel.rs/diesel/macro.sql_function.html](https://docs.diesel.rs/diesel/macro.sql_function.html))
    that maps the data types and output appropriately. Since we are mapping a pre-existing
    function here, there are no further steps required (this should work the same
    for stored procedures).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect that *step 2* covers is inserting into and deleting from multiple
    tables, which is easy thanks to SQLite''s disabled referential integrity constraint
    ([https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php](https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php)).
    If this constraint is enforced, take a look at the `diesel-rs` transactions ([https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction](https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction)).
    *Step 3* goes on to show how to retrieve this data—using a left outer join. Left
    joins take every row from the left side (`bookmarks` if the join looks as follows: `bookmarks
    LEFT JOIN comments`) and try to match it to rows in the table on the right, which
    means we get every bookmark regardless of whether they have comments or not. To
    map this result set, we have to provide a corresponding data type to parse to,
    which `diesel-rs` expects to be `(Bookmark, Option<Comment>)`. Since the `left_join()`
    call does not mention which columns to join on, how does the framework know? Again,
    in *step 4*, we declare the two tables as `joinable` via two macros: `joinable`
    ([https://docs.diesel.rs/diesel/macro.joinable.html](https://docs.diesel.rs/diesel/macro.joinable.html))
    and `allow_tables_to_appear_in_same_query` ([https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html](https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html)). After
    the results are fetched, we map them to a `Serializable` combined type to hide
    this implementation detail from the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Only in *step 4* and *step 5* do we take care of mapping out the database tables
    and rows for diesel—nothing too surprising here. The `Queryable` attribute is
    important for `diesel-rs` to map tuples to types—regardless of the actual table.
    For more ad hoc queries, we could work with tuples directly as well. *Step 6*
    takes care of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 7* runs the server and avid readers will have noticed one thing: compilation
    takes longer than usual. We suspect that `diesel-rs` is doing a lot of work behind
    the scenes, creating type-safe code to keep the dynamic runtime overhead low.
    However, this may significantly factor into bigger projects, but once compiled,
    the types help to avoid errors and make the service work smoothly.'
  prefs: []
  type: TYPE_NORMAL
- en: We formatted the `curl` output to make it more readable and the output works
    just as expected. `serde` provides consistent serialization and deserialization
    of JSON objects; thus, the `comment` field is optional on input but is rendered
    as `null` on output.
  prefs: []
  type: TYPE_NORMAL
- en: While `diesel-rs` tries to abstract many database operations, it uses a `sql_query`
    interface ([https://docs.diesel.rs/diesel/fn.sql_query.html](https://docs.diesel.rs/diesel/fn.sql_query.html))
    to work with other SQL statements as well. However, more complex group by aggregations
    are not yet supported—even in the raw SQL interface—which is unfortunate. You
    can follow the progress on GitHub ([https://github.com/diesel-rs/diesel/issues/210](https://github.com/diesel-rs/diesel/issues/210)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about running queries with `diesel-rs`, let's move on
    to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication on the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running web services safely on public interfaces is itself challenge and a lot
    of things need to be taken care of. While many details fall within the job description
    of a security engineer, developers should adhere to at least a minimum set of
    best practices so they rightfully earn the trust of their users. At the start,
    there is transport encryption (TLS), which is something we did not include in
    any recipes in this chapter since reverse proxies and load balancers provide amazing
    and simple integration for this (and let's encrypt: [https://letsencrypt.org/](https://letsencrypt.org/) provides
    free certificates). This chapter focuses on using the `actix-web` middleware infrastructure
    to authenticate requests via JWT ([https://jwt.io/](https://jwt.io/)) at the application
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust binary project using `cargo new authentication` and make sure
    that port `8081` is accessible from the localhost. To access the services, get
    a program such as `curl` or Postman to execute `POST`, `GET`, and more type web
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the entire directory with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authenticate your users in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, we start by declaring the required imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, we can take care of the more relevant bits. Let''s
    declare a few basics for authentication and a handler that we want to access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a handler to log users in and create the token if they provide
    the expected password, as well as the `main()` function to set everything up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wrap()` call in the `main()` function already gives away some details—we
    are going to need middleware to take care of authentication. Let''s create a new
    file, `src/middlewares.rs`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code in *step 4*, we see another struct that needs implementation: `JwtLoginMiddleware`.
    Let''s add it to `src/middlewares.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important code can be found in the call function implementation where
    the request is passed through to apply the middleware (and authenticate the token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can run the server, we also have to update `Cargo.toml` with the
    current dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Exciting—let''s try it out! Start the server with `cargo run` and issue some
    `curl` requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `curl` output for each request. First, the unauthorized
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we try to log in using an invalid password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the real password and receive a token back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With this token in the `authorization` header ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)),
    we can then access the secret resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Let's pull back the curtain and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JWTs are a great way to provide authentication combined with authorization
    in a web application. As demonstrated on the official website, a JWT consists
    of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The header, providing meta-information about the token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its payload, which is where the information is sent (JSON-serialized)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signature to guarantee that the token wasn't changed in transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parts are Base64-encoded and joined with `.` to form a single string.
    This string is put into the `authorization` header of an HTTP request ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)).
    One important remark is that TLS is mandatory for this kind of authentication
    since the headers as well as everything else are sent in plaintext—everyone would
    be able to see the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload can contain anything you wish to carry back and forth as user information.
    However, there are special fields as well: `iss`, `sub`, and `exp`. `iss` provides
    the issuer''s credentials (in whichever way), `sub` is the subject, and `exp`
    is the expiration timestamp. This is because JWTs can be used to authenticate
    via federation, that is, third-party services, as well. For this implementation,
    we are using a crate called `jsonwebtoken` ([https://github.com/Keats/jsonwebtoken](https://github.com/Keats/jsonwebtoken)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 1*, we are simply setting up the imports—nothing special here. Only
    *step 2* provides something interesting: a hardcoded password (**BAD** security
    practice, but good enough for demonstration) as well as a hardcoded secret (also
    **BAD**). Real applications can use a secret store for the secret (for example,
    Azure Key Vault: [https://azure.microsoft.com/en-in/services/key-vault/](https://azure.microsoft.com/en-in/services/key-vault/))
    and a hash stored in a database for the password. In the same step, we are also
    declaring the input data structure for logging in—we care only about the password—as
    well as the handler for the path/secret, which should only work once we are logged
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following step creates the handler for logging in: if the password matches,
    the handler creates a new token containing the payload data (a struct called `Claims`)
    and the HMAC ([https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC](https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC)) algorithm
    (HS256 by default) used to sign the token, and returns it. The handlers are then
    registered with the `App` instance, together with the new JWT authentication middleware
    implemented in the following steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* and *step 5* take care of creating the middleware for validating JWT
    tokens. *Step 4* contains the `Claims` type mentioned previously; however, the
    rest of the code is a largely required boilerplate if the request and response
    types remains default. If we wanted to retrieve user information to pass to the
    handlers, we would look into defining custom requests. Only in *step 5* are we
    implementing the important part: the `call()` function. This function is called
    before every request is processed and decides whether to continue or stop propagating
    it. Obviously, the `/login` route is the exception and will always be passed on
    the handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every other route has to contain a header field called `authorization` and
    a type called `Bearer`, along with the token, for example, (truncated) `authorization:
    Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJ[...]8wcyELavx-c`. The `call()` function extracts
    the token and tries to decode it with its secret. If that works, the call is forwarded
    to the handler; if not, the user is clearly not authorized to access the resource—the
    same happens if there is no authorization header at all. `jsonwebtoken` validates
    the `exp` field by default as well (our `Claims` type does not have this), which
    is what we are turning off for this example. For brevity, we used `unwrap()` when
    parsing the header''s bytes into a string. However, this can crash the thread
    if unknown bytes are encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: The return types here are imported from the `futures` library ([https://docs.rs/futures/](https://docs.rs/futures/)) and
    provide the `Either` type ([https://docs.rs/futures/0.1.28/futures/future/enum.Either.html](https://docs.rs/futures/0.1.28/futures/future/enum.Either.html))
    as well as the `ok()` function ([https://docs.rs/futures/0.1.28/futures/future/fn.ok.html](https://docs.rs/futures/0.1.28/futures/future/fn.ok.html)).
    Check their documentation to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* simply declares the additional dependencies, and in *step 7*, we get
    to run the server! Check the `curl` requests first—can you see what''s off? Requests
    without authorization are blocked *before* logging happens. Additionally, we have
    marked the important bits in bold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes this chapter. We hope you enjoyed the web programming recipes.
    The next chapter covers something a lot closer to the metal: systems programming.'
  prefs: []
  type: TYPE_NORMAL
