<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-123"><em class="italic"><a id="_idTextAnchor122"/>Chapter 7</em>: Using Python Modules with Rust</h1>&#13;
			<p>We have now become comfortable with writing Python packages in Rust that can be installed using <code>pip</code>. However, a large advantage of Python is that it has a lot of mature Python libraries that help us write productive code with minimal errors. This seems a legitimate observation that could halt us from adopting Rust in our Python system. However, in this chapter, we counter this observation by importing Python modules into our Rust code and running Python code in our Rust code. To achieve an understanding of this, we are going to use the <strong class="bold">NumPy</strong> Python package to implement a basic mathematical model. Once this is done, we are going to use the NumPy package in our Rust code to simplify the implementation of our mathematical model. Finally, we will evaluate the speed of both implementations. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Exploring NumPy </li>&#13;
				<li>Building a model in NumPy</li>&#13;
				<li>Using NumPy and other Python modules in Rust</li>&#13;
				<li>Recreating our NumPy model in Rust </li>&#13;
			</ul>&#13;
			<p>After completing this chapter, we will be able to import Python packages into our Rust code and use it. This is powerful, as relying on a certain Python package would not hold us back from implementing Rust in our Python systems for a certain task. The solutions that we implement in this chapter using pure Python, Rust, and NumPy will also give us an understanding of the trade-offs of each implementation when it comes to code complexity and speed so that we do not try to implement a <em class="italic">one-size-fits-all</em> solution for every problem, avoiding sub-optimal solutions. </p>&#13;
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Technical requirements</h1>&#13;
			<p>The code for this chapter can be found via the following GitHub link:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven</a></p>&#13;
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Exploring NumPy </h1>&#13;
			<p>Before we<a id="_idIndexMarker449"/> start using NumPy in our own modules, we must explore what NumPy is and how to use it. NumPy is a third-party computational Python package that enables us to perform calculations on lists. NumPy is mainly written in the C language, meaning that it will be faster than pure Python. In this section, we will have to assess whether our NumPy implementation beats a Rust implementation that is imported into Python.  </p>&#13;
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Adding vectors in NumPy </h2>&#13;
			<p>NumPy enables <a id="_idIndexMarker450"/>us to <a id="_idIndexMarker451"/>build vectors that we can loop through and apply functions to. We can also perform operations between vectors. We can demonstrate the power of NumPy by adding items of each vector together, as seen here:</p>&#13;
			<pre>[0, 1, 2, 3, 4]</pre>&#13;
			<pre>[0, 1, 2, 3, 4]</pre>&#13;
			<pre>---------------</pre>&#13;
			<pre>[0, 2, 4, 6, 8]</pre>&#13;
			<p>To achieve this, we initially need to import modules by running the following code:</p>&#13;
			<pre>import time</pre>&#13;
			<pre>import numpy as np</pre>&#13;
			<pre>import matplotlib.pyplot as plt</pre>&#13;
			<p>With this, we can build a <code>numpy_function</code> NumPy function that creates two NumPy vectors of a certain size and adds them together by running the code presented here:</p>&#13;
			<pre>def numpy_function(total_vector_size: int) -&gt; float:</pre>&#13;
			<pre>    t1 = time.time()</pre>&#13;
			<pre>    first_vector = np.arange(total_vector_size)</pre>&#13;
			<pre>    second_vector = np.arange(total_vector_size)</pre>&#13;
			<pre>    sum_vector = first_vector + second_vector</pre>&#13;
			<pre>    return time.time() - t1</pre>&#13;
			<p>Here, we can see that we can add the vectors by merely using the addition operator. Now that <a id="_idIndexMarker452"/>we<a id="_idIndexMarker453"/> have our function defined, we can plot how this scales by looping through a list of integers and applying <code>numpy_function</code> to the items, collecting the results in a list, by running the code shown here:</p>&#13;
			<pre>numpy_results = [numpy_function(i) for i in range(0 \ </pre>&#13;
			<pre>  10000)]</pre>&#13;
			<pre>plt.plot(numpy_results, linestyle='dashdot')</pre>&#13;
			<pre>plt.show()</pre>&#13;
			<p>This gives us a line plot, as shown here:</p>&#13;
			<p class="figure-caption"> </p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_7.01_B17720.jpg" alt="Figure 7.1 – Time taken to add two NumPy vectors based on size&#13;&#10;" width="1080" height="833"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 7.1 – Time taken to add two NumPy vectors based on size</p>&#13;
			<p>We can see in the preceding screenshot that the increase is linear. This is expected because there is only one loop when adding each integer in the vector to the other vector. We<a id="_idIndexMarker454"/> can <a id="_idIndexMarker455"/>also see that there are points where the time taken shoots up—this is the garbage collection kicking in. To appreciate the effect NumPy has, we can redefineour example by adding both vectors with a list in pure Python in the next subsection.</p>&#13;
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Adding vectors in pure Python </h2>&#13;
			<p>We <a id="_idIndexMarker456"/>can <a id="_idIndexMarker457"/>add two<a id="_idIndexMarker458"/> vectors in pure Python and time this by running the following code: </p>&#13;
			<pre>def python_function(total_vector_size: int) -&gt; float:</pre>&#13;
			<pre>    t1 = time.time()</pre>&#13;
			<pre>    first_vector = range(total_vector_size)</pre>&#13;
			<pre>    second_vector = range(total_vector_size)</pre>&#13;
			<pre>    sum_vector = [first_vector[i] + second_vector[i] for \</pre>&#13;
			<pre>      i in range(len(second_vector))]</pre>&#13;
			<pre>    return time.time() - t1</pre>&#13;
			<p>With our new Python function, we can run both NumPy and Python functions and chart them by<a id="_idIndexMarker459"/> running<a id="_idIndexMarker460"/> the<a id="_idIndexMarker461"/> following code:</p>&#13;
			<pre>print(python_function(1000))</pre>&#13;
			<pre>print(numpy_function(1000))</pre>&#13;
			<pre>python_results = [python_function(i) for i in range(0, \</pre>&#13;
			<pre>  10000)]</pre>&#13;
			<pre>numpy_results = [numpy_function(i) for i in range(0, \</pre>&#13;
			<pre>  10000)]</pre>&#13;
			<pre>plt.plot(python_results, linestyle='solid')</pre>&#13;
			<pre>plt.plot(numpy_results, linestyle='dashdot')</pre>&#13;
			<pre>plt.show()</pre>&#13;
			<p>This gives us the following results:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_7.02_B17720.jpg" alt="Figure 7.2 – Time taken to add two vectors based on size &#13;&#10;" width="1129" height="807"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 7.2 – Time taken to add two vectors based on size </p>&#13;
			<p>As we can see in <em class="italic">Figure 7.2</em>, the NumPy vectors are represented in the bottom line and pure Python is represented in the increasing line, so we can conclude that Python does not<a id="_idIndexMarker462"/> scale that well when compared to our NumPy<a id="_idIndexMarker463"/> implementation. The output makes it clear that NumPy<a id="_idIndexMarker464"/> is a good choice when performing calculations on big vectors. However, how does this compare to our Rust implementation? We explore this in the next subsection.</p>&#13;
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Adding vectors using NumPy in Rust </h2>&#13;
			<p>To<a id="_idIndexMarker465"/> compare<a id="_idIndexMarker466"/> how NumPy compares to our Rust implementation, we must incorporate an adding vector function to our Rust package that we have been building throughout this book so far. Here are the steps we need to take:</p>&#13;
			<ol>&#13;
				<li>Considering that this is a test function that we are using for demonstrative purposes, we can merely insert it into our <code>lib.rs</code> file. All we do is build a <code>time_add_vectors</code> function that accepts a number, create two vectors of a size equal to the number passed as input, loop through them at the same time, and add the items together, as shown here:<pre>#[pyfunction]
fn time_add_vectors(total_vector_size: i32)
    -&gt; Vec&lt;i32&gt; {    
    let mut buffer: Vec&lt;i32&gt; = Vec::new();
    let first_vector: Vec&lt;i32&gt; = 
      (0..total_vector_size.clone()
         ).map(|x| x).collect();
    let second_vector: Vec&lt;i32&gt; = \
      (0..total_vector_size
         ).map(|x| x).collect();
    
    for i in &amp;first_vector {
        buffer.push(first_vector[**&amp;i as usize] + 
                     second_vector[*i as usize]);
    }
   return buffer
}</pre></li>&#13;
				<li>Once <a id="_idIndexMarker467"/>we <a id="_idIndexMarker468"/>have done this, we must remember to add this function to our module, as follows:<pre>#[pymodule]
fn flitton_fib_rs(_py: Python, m: &amp;PyModule) -&gt; \
  PyResult&lt;()&gt; {
    . . .
    m.add_wrapped(wrap_pyfunction!(time_add_vectors));
    . . .
    Ok(())
}</pre><p>We must remember to update our GitHub repository and reinstall our Rust package in our Python environment. </p></li>&#13;
				<li>Once this is done, we must implement the function in our Python testing script and<a id="_idIndexMarker469"/> time it. First, we must import it with <a id="_idIndexMarker470"/>the code shown here:<pre>import time
import matplotlib.pyplot as plt
import numpy as np
from flitton_fib_rs import time_add_vectors</pre></li>&#13;
				<li>Once this is done, we can define our <code>rust_function</code> Python function that calls the <code>time_add_vectors</code> function and times how long it takes to complete the addition by running the following code:<pre>def rust_function(total_vector_size: int) -&gt; float:
    t1 = time.time()
    sum_vector = time_add_vectors(total_vector_size)
    result = time.time() - t1
    if result &gt; 0.00001:
        result = 0.00001
    return result</pre><p>You may have noticed that we trim <code>result</code> returned by <code>rust_function</code>. This is not cheating—we do this because when the garbage collector kicks in, it can cause spikes and ruin the scaling of the graph. We will also do this with our NumPy function by running the following code:</p><pre>def numpy_function(total_vector_size: int) -&gt; float:
    t1 = time.time()
    first_vector = np.arange(total_vector_size)
    second_vector = np.arange(total_vector_size)
    sum_vector = first_vector + second_vector
    result = time.time() - t1
    if result &gt; 0.00001:
        result = 0.00001
    return result</pre><p>We can<a id="_idIndexMarker471"/> see <a id="_idIndexMarker472"/>that we are applying the same metrics to both the functions so that one will not be artificially lowered compared to the other.</p></li>&#13;
				<li>Now that we have done this, we need to define the pure function by running the following code:<pre>def python_function(total_vector_size: int) -&gt; float:
    t1 = time.time()
    first_vector = range(total_vector_size)
    second_vector = range(total_vector_size)
    sum_vector = [first_vector[i] + second_vector[i] for
      i in range(len(second_vector))]
    result = time.time() - t1
    if result &gt; 0.0001:
        result = 0.0001
    return result</pre><p>It must be noted that we have a higher cut-off for the pure Python because we expect the base reading to be much higher. </p></li>&#13;
				<li>Now that we have all of our metric functions for Rust, NumPy, and pure Python, we can create<a id="_idIndexMarker473"/> Python lists with the results of both functions and plot them by running<a id="_idIndexMarker474"/> the following code:<pre>numpy_results = [numpy_function(i) for i in range(0, \ 
  300)]
rust_results = [rust_function(i) for i in range(0, \
  300)]
python_results = [python_function(i) for i in range \
  (0,300)]
plt.plot(rust_results, linestyle='solid', \
  color="green")
plt.plot(python_results, linestyle='solid', \
 color="red")
plt.plot(numpy_results, linestyle='solid', \
color="blue")
plt.show()</pre><p>Running our code will give us the result shown here:</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_7.03_B17720.jpg" alt="Figure 7.3 – Time taken to add two vectors based on the size of the vectors; &#13;&#10;left: NumPy; middle: Rust; right: pure Python&#13;&#10;" width="1568" height="399"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 7.3 – Time taken to add two vectors based on the size of the vectors; left: NumPy; middle: Rust; right: pure Python</p>&#13;
			<p>In the preceding screenshot, we can see that NumPy is the fastest and is not scaling aggressively as the size of the vector increases. Our Rust implementation is a lot faster than our pure Python implementation by an order of magnitude, but it is not as efficient as NumPy. </p>&#13;
			<p>We can see that Python optimizations such as NumPy do increase the speed compared to pure Python and Rust. However, NumPy's clean syntax of simply adding vectors is not the only functional advantage of this module. In the next section, we will explore another<a id="_idIndexMarker475"/> functionality that NumPy has that would require a <a id="_idIndexMarker476"/>lot of extra code if we were going to try to code it from scratch in Python or Rust.</p>&#13;
			<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Building a model in NumPy </h1>&#13;
			<p>In this<a id="_idIndexMarker477"/> section, we are going to build a basic mathematical model to demonstrate the power that NumPy has apart from speed. We are going to use matrices to make a simple model. To achieve this, we will have to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Define our model. </li>&#13;
				<li>Build a Python object that executes our model.</li>&#13;
			</ol>&#13;
			<p>Let's look at these steps in detail in the following subsections.</p>&#13;
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Defining our model</h2>&#13;
			<p>A mathematical <a id="_idIndexMarker478"/>model is essentially a set of weights that calculate an outcome based on inputs. Before we go any further, we must remember the scope of this book. We are building a model to demonstrate how to utilize NumPy. If we covered the nuances of mathematical modeling, that would take up the whole book. We will be building a model based on the example discussed in the previous section, but this does not mean that the model defined is an accurate description of the complexity of mathematical modeling. Here are the steps we need to take:</p>&#13;
			<ol>&#13;
				<li value="1">We start by looking at a very simple mathematical model that would be a simple speed equation, as shown here:<p><img src="img/B17720_07_001.png" alt="" width="403" height="109"/></p></li>&#13;
				<li>With our model, we can calculate the time taken to complete a journey with the rearrangement shown here:<p><img src="img/B17720_07_002.png" alt="" width="1100" height="118"/></p><p>The final equation on the right is merely substituting the values for letters so that they can be plugged into a bigger model without it taking up an entire page.</p></li>&#13;
				<li>Now, let's take our model a little further. We collect some data from a trucking company, and we manage to quantify different grades of traffic into numbers and fit our data so that we can produce a weight to describe the effect traffic has on time. With this, our model has evolved to the one defined here:<p><img src="img/B17720_07_003.png" alt="" width="302" height="61"/></p><p>Here, <img src="img/B17720_07_004.png" alt="" width="26" height="41"/> is the weight of traffic, and <em class="italic">y</em> is the grade of traffic. As we can see, if the grade of traffic increases, so does the time. Now, let's say that the model is different for cars and trucks. This gives us the following set of equations:</p><p><img src="img/B17720_07_005.png" alt="" width="302" height="44"/></p><p><img src="img/B17720_07_006.png" alt="" width="291" height="42"/></p><p>We can deduce from the equations that the distance (<em class="italic">x</em>) and traffic grade (<em class="italic">y</em>) are the same for both cars and trucks. This makes sense. While the weights could be different as cars could be affected by distance and traffic differently, as denoted in their weights, the input parameters are the same.</p></li>&#13;
				<li>Considering this, the equation could be defined as the following matrix equation:<p><img src="img/B17720_07_007.png" alt="" width="347" height="96"/></p><p>This might <a id="_idIndexMarker479"/>seem excessive right now, but there are advantages to this. Matrices have a range of functions that enable us to perform algebra on them. We will cover a few here so that we can understand how NumPy becomes invaluable to us when calculating this model. </p></li>&#13;
				<li>To do this, we must acknowledge that matrix multiplication must occur in a certain order for it to work. Our model is essentially calculated by the notation shown here:<p><img src="img/B17720_07_008.png" alt="" width="790" height="101"/></p></li>&#13;
				<li>Our <em class="italic">x</em> <em class="italic">y</em> matrix must be on the right of our weights matrix. We can add more inputs to our <em class="italic">x</em> <em class="italic">y</em> matrix with the following notation:<p><img src="img/B17720_07_009.png" alt="" width="753" height="98"/></p></li>&#13;
				<li>We can, in fact, keep stacking our inputs, and we will get proportional outputs. This is powerful; we can put in an input matrix of any size if we keep the dimensions of the matrix consistent. We can also invert our matrix. If we invert our matrix, we can then input times to work out the distance and grade of the traffic. Inverting a matrix takes the following form:<p><img src="img/B17720_07_010.png" alt="" width="1030" height="200"/></p></li>&#13;
				<li>Here, we can see that if we multiply a scalar by the matrix, it just gets applied to all elements of the matrix. Considering this, our model can calculate the traffic grade and distance using the inverse matrix with the following notation:</li>&#13;
			</ol>&#13;
			<p><img src="img/B17720_07_011.png" alt="" width="392" height="108"/></p>&#13;
			<p>We have<a id="_idIndexMarker480"/> only covered enough matrix mathematics to code our model, but even with just this, we can see that matrices enable us to manipulate multiple equations and shuffle them around to calculate different things quickly. However, if we were to code the matrix multiplications from scratch, it would take a lot of time and we would run the risk of performing errors. To have fast, safe development of our model, we will need to use NumPy module functions, which is what we will do in the next subsection.</p>&#13;
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Building a Python object that executes our model</h2>&#13;
			<p>We saw in the<a id="_idIndexMarker481"/> previous section that there are two different paths that we can take. When we build our model, we are going to have two branches—one for calculating the time taken, and the other for calculating the traffic and distance from time. To build our model class, we must map out our dependencies, as shown here:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_7.04_B17720.jpg" alt="Figure 7.4 – Dependencies of a Python matrix model  &#13;&#10;" width="995" height="550"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 7.4 – Dependencies of a Python matrix model  </p>&#13;
			<p>The preceding diagram shows us that we must define the weight matrix property before anything else<a id="_idIndexMarker482"/> as this property is the main mechanism on which everything else is calculated. This was also evident in the matrix equation. We can build our class with the weight matrix property, as follows:</p>&#13;
			<pre>import numpy as np</pre>&#13;
			<pre>class MatrixModel:</pre>&#13;
			<pre>    @property</pre>&#13;
			<pre>    def weights_matrix(self) -&gt; np.array:</pre>&#13;
			<pre>        return np.array([</pre>&#13;
			<pre>            [3, 2],</pre>&#13;
			<pre>            [1, 4]</pre>&#13;
			<pre>        ])</pre>&#13;
			<p>Here, we can see that we use NumPy for our matrix and that our matrix is a list of lists. We use NumPy arrays over normal arrays because NumPy arrays have matrix operations such as <code>transpose</code>. Remember that the positions of the matrices matter when they are being multiplied. For instance, we have a simple matrix equation as follows:</p>&#13;
			<p><img src="img/B17720_07_012.png" alt="" width="694" height="77"/></p>&#13;
			<p>If we were to swap the matrix order, the matrices would not be able to multiply due to their shapes not being compatible; this is where the <code>transpose</code> operation comes in. A <code>transpose</code> function flips the matrix, enabling us to switch the order of the multiplication. We will not be using <code>transpose</code> in our model, but the Python commands in <a id="_idIndexMarker483"/>the terminal here show us how NumPy gives us this function out of the box:</p>&#13;
			<pre>&gt;&gt;&gt; import numpy as np</pre>&#13;
			<pre>&gt;&gt;&gt; t = np.array([</pre>&#13;
			<pre>                [3, 2],</pre>&#13;
			<pre>                [1, 4]</pre>&#13;
			<pre>            ])</pre>&#13;
			<pre>&gt;&gt;&gt; t.transpose()</pre>&#13;
			<pre>array([[3, 1],</pre>&#13;
			<pre>       [2, 4]])</pre>&#13;
			<pre>&gt;&gt;&gt; x = np.array([</pre>&#13;
			<pre>                    [3],</pre>&#13;
			<pre>                    [1]</pre>&#13;
			<pre>                ])</pre>&#13;
			<pre>&gt;&gt;&gt; x.transpose()</pre>&#13;
			<pre>array([[3, 1]])</pre>&#13;
			<p>Here, we can see that the matrices that we have built with NumPy arrays can change shape with ease. Now that we have established that we are building our matrices with NumPy arrays, we can build a function that will call the function that accepts the distance of the journey and the traffic grade for our <code>MatrixModel</code> class, as follows: </p>&#13;
			<pre>    def calculate_times(self, distance: int, \</pre>&#13;
			<pre>      traffic_grade: int) -&gt; dict:</pre>&#13;
			<pre>        inputs = np.array([</pre>&#13;
			<pre>            [distance],</pre>&#13;
			<pre>            [traffic_grade]</pre>&#13;
			<pre>        ])</pre>&#13;
			<pre>        result = np.dot(self.weights_matrix, inputs)</pre>&#13;
			<pre>        return {</pre>&#13;
			<pre>            "car time": result[0][0],</pre>&#13;
			<pre>            "truck time": result[1][0]</pre>&#13;
			<pre>        }</pre>&#13;
			<p>Here, we can<a id="_idIndexMarker484"/> see that once we have constructed our input matrix, we multiply this by our weights matrix with the <code>np.dot</code> function. <code>result</code> is a matrix, which—as we know—is a list of lists. We unpack this and then return it in the form of a dictionary. </p>&#13;
			<p>We have nearly finished our model; all we must do now is now build our inverse model. This is where we pass in the times taken for the journey to calculate the distance and traffic grade for our <code>MatrixModel</code> class. This is done with the following code:</p>&#13;
			<pre>    def calculate_parameters(self, car_time: int, </pre>&#13;
			<pre>                             truck_time: int) -&gt; dict:</pre>&#13;
			<pre>        inputs = np.array([</pre>&#13;
			<pre>            [car_time],</pre>&#13;
			<pre>            [truck_time]</pre>&#13;
			<pre>        ])</pre>&#13;
			<pre>        result = np.dot(np.linalg.inv(self. \</pre>&#13;
			<pre>          weights_matrix), inputs)</pre>&#13;
			<pre>        return {</pre>&#13;
			<pre>            "distance": result[0][0],</pre>&#13;
			<pre>            "traffic grade": result[1][0]</pre>&#13;
			<pre>        }</pre>&#13;
			<p>Here, we can see that we take the same approach; however, we use the <code>np.linalg.inv</code> function to get the inverse of the <code>self.weights_matrix</code> matrix. Now <a id="_idIndexMarker485"/>that this is done, we have a fully functioning model and we can test it, as follows: </p>&#13;
			<pre>test = MatrixModel()</pre>&#13;
			<pre>times = test.calculate_times(distance=10, traffic_grade=3)</pre>&#13;
			<pre>print(f"here are the times: {times}")</pre>&#13;
			<pre>parameters = test.calculate_parameters(</pre>&#13;
			<pre>    car_time=times["car time"], truck_time=times["truck \</pre>&#13;
			<pre>      time"]</pre>&#13;
			<pre>)</pre>&#13;
			<pre>print(f"here are the parameters: {parameters}")</pre>&#13;
			<p>Running the preceding code will give us the following printout in the terminal:</p>&#13;
			<pre>{'car time': 36, 'truck time': 22}</pre>&#13;
			<pre>{'distance': 10.0, 'traffic grade': 3.0}</pre>&#13;
			<p>With this terminal printout, we can see that our model works and that our inverse model returns the original inputs. With this, we can also conclude that NumPy is more than just speeding up our code; it gives us extra tools to solve problems such as modeling with matrices. This is the last hurdle that could stop us from reaching for Rust. In the next section, we will use the NumPy Python module in Rust by recreating our model <a id="_idIndexMarker486"/>in Rust.</p>&#13;
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Using NumPy and other Python modules in Rust</h1>&#13;
			<p>In this <a id="_idIndexMarker487"/>section, we <a id="_idIndexMarker488"/>are going<a id="_idIndexMarker489"/> to <a id="_idIndexMarker490"/>understand the basics of importing a Python module such as NumPy in our Rust program and return the result to our Python function. We will build our functionality in our Fibonacci number package that we have been coding so far in this book. We will also briefly explore importing a Python module in a generic sense so that you experience how to use a Python module that has the functionality you are relying on. We will build a more comprehensive approach to using Python modules in our Rust code in the next section. For this section, we will write all our code in the <code>src/lib.rs</code> file. Here are the steps we need to take:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to acknowledge that we pass in a dictionary and return the results in it. Because of this, we must import the <code>PyDict</code> struct by running the following code:<pre>use pyo3::types::PyDict;</pre></li>&#13;
				<li>Now that this is imported, we can define our function by running the following code:<pre>#[pyfunction]
fn test_numpy&lt;'a&gt;(result_dict: &amp;'a PyDict) 
            -&gt; PyResult&lt;&amp;'a PyDict&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let locals = PyDict::new(py);
    locals.set_item("np", 
      py.import("numpy").unwrap());
}</pre><p>Because we are using a Python module, there is no surprise that we acquire the <code>PyDict</code> struct called <code>locals</code>. </p><p>We then import the NumPy module using the <code>py.import</code> function, inserting it into our <code>localsstruct</code>.</p><p>As <a id="_idIndexMarker491"/>demonstrated <a id="_idIndexMarker492"/>here, we<a id="_idIndexMarker493"/> will be <a id="_idIndexMarker494"/>using our <code>locals</code> struct as Python storage:</p><div><img src="img/Figure_7.05_B17720.jpg" alt="Figure 7.5 – Rust flow for computing Python processes within Rust  &#13;&#10;" width="716" height="606"/></div><p class="figure-caption">Figure 7.5 – Rust flow for computing Python processes within Rust  </p><p>Here, every time we run a Python operation in our Rust code, we will pass Python objects from the <code>locals</code> into the Python computation. We then pass any new Python variables we need to add to our <code>PyDict</code> <code>locals</code> struct.</p></li>&#13;
				<li>Now that we understand the flow, we can compute our first Python computation inside our <code>test_numpy</code> function by running the following code:<pre>    let code = "np.array([[3, 2], [1, 4]])";
    let weights_matrix = py.eval(code, 
                           None, 
                           Some(&amp;locals)).unwrap();
    locals.set_item("weights_matrix", weights_matrix);</pre><p>Here, we <a id="_idIndexMarker495"/>can<a id="_idIndexMarker496"/> see that <a id="_idIndexMarker497"/>we <a id="_idIndexMarker498"/>define the Python command as a string literal. We then pass this into our <code>py.eval</code> function. Our <code>None</code> parameter is for global variables. We are going to refrain from passing in global variables to keep this simple. We also pass in our <code>PyDict</code> <code>locals</code> struct to get the NumPy module we imported under the <code>np</code> namespace. We then unwrap the result and add this to our <code>localsstruct</code>.</p></li>&#13;
				<li>We can now create an input NumPy vector and insert the outcome into our <code>localsstruct</code> by running the following code:<pre>    let new_code = "np.array([[10], [20]])";
    let input_matrix = py.eval(new_code, None, 
                              Some(&amp;locals)).unwrap();
    locals.set_item("input_matrix", input_matrix);</pre></li>&#13;
				<li>Now that we have both of our matricies in our <code>locals</code> storage, we can multiply them together, add them to our input dictionary, and return the result by running the following code:<pre>    let calc_code = "np.dot(weights_matrix, \
       input_matrix)";
    let result_end = py.eval(calc_code, None, 
                             Some(&amp;locals)).unwrap();
    result_dict.set_item("numpy result", result_end);
    return Ok(result_dict)</pre></li>&#13;
			</ol>&#13;
			<p>With this, we can now use NumPy in our Rust code and get the results to pass them back into the Python system. We must remember to update our GitHub repository and reinstall our Rust package in our Python system. To test this, we can carry out the following console commands:</p>&#13;
			<pre>&gt;&gt;&gt; from flitton_fib_rs import test_numpy</pre>&#13;
			<pre>&gt;&gt;&gt; outcome = test_numpy({})</pre>&#13;
			<pre>&gt;&gt;&gt; outcome["numpy result"].transpose()</pre>&#13;
			<pre>array([[70, 90]])</pre>&#13;
			<p>Here, we can see that our NumPy process works inside Rust and returns Python objects that we can use just like all other Python objects. We could have done this using the Rust NumPy module, which gives us NumPy Rust structs. However, with the approach that we have covered, nothing is stopping us from using any Python module that we wish. We <a id="_idIndexMarker499"/>now have <a id="_idIndexMarker500"/>a <a id="_idIndexMarker501"/>full tool belt for fusing Python with Rust. In the <a id="_idIndexMarker502"/>next section, we will structure our NumPy model in Rust over a range of functions so that we can put in times for the inverse calculation and grade traffic with distance to calculate the times. </p>&#13;
			<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Recreating our NumPy model in Rust </h1>&#13;
			<p>Now that <a id="_idIndexMarker503"/>we can <a id="_idIndexMarker504"/>use our NumPy module in Rust, we need to explore how to structure it so that we can use Python modules to solve bigger problems. We will do this by building a NumPy model with a Python interface. To achieve this, we can break down the processes into functions that can be used as and when we need them. The structure of our NumPy model can be seen here:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_7.06_B17720.jpg" alt="Figure 7.6 – Rust NumPy model structure  &#13;&#10;" width="1302" height="1182"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 7.6 – Rust NumPy model structure  </p>&#13;
			<p>Considering<a id="_idIndexMarker505"/> the<a id="_idIndexMarker506"/> flow of our model structure in the preceding diagram, we can build our NumPy model in Rust with the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Build <code>get_weight_matrix</code> and <code>inverse_weight_matrix</code> functions.</li>&#13;
				<li>Build <code>get_parameters</code>, <code>get_times</code>, and <code>get_input_vector</code> functions. </li>&#13;
				<li>Build <code>calculate_parameters</code> and <code>calculate_times</code> functions. </li>&#13;
				<li>Add calculate functions to the Python bindings and add a NumPy dependency to our <code>setup.py</code> file.</li>&#13;
				<li>Build our Python interface. </li>&#13;
			</ol>&#13;
			<p>We can see that each step has dependencies from the previous step. Let's have a detailed<a id="_idIndexMarker507"/> look<a id="_idIndexMarker508"/> at each of these steps in the following subsections. </p>&#13;
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Building get_weight_matrix and inverse_weight_matrix functions </h2>&#13;
			<p>Our <a id="_idIndexMarker509"/>weight<a id="_idIndexMarker510"/> and inverse weight matrices enable us to calculate the times and then recalculate the parameters inputted based on those times. We can start building our weight matrix function in the <code>src/numpy_model.rs</code> file with the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Before we write any code, we can import what we need by running the following code:<pre>use pyo3::prelude::*;
use pyo3::types::PyDict;</pre><p>We will be using the <code>PyDict</code> struct to pass data between our functions and <code>pyo3</code> macros to wrap the functions and get the Python GIL. </p></li>&#13;
				<li>Now that we have all of our imports, we can build our weight matrix function by running the following code:<pre>fn get_weight_matrix(py: &amp;Python, locals: &amp;PyDict) \
  -&gt; () {
    let code: &amp;str = "np.array([[3, 2], [1, 4]])";
    let weights_matrix = py.eval(code, None, 
                         Some(&amp;locals)).unwrap();
    locals.set_item("weights_matrix", weights_matrix);
}</pre><p>Here, we can see that we accept a reference to Python and <code>locals</code> storage. With this, we run our code and add it to our <code>locals</code> storage. We do not have to return anything because these are just referencing via borrowing. This means that the <code>py</code> and <code>locals</code> variables are not deleted when the scope of the variable has run its course. It also means that the <code>locals</code> storage will be updated with our <code>weights_matrix</code> function even though nothing is returned. We will be using this approach in most of our functions shown in <em class="italic">Figure 7.6</em>.</p></li>&#13;
				<li>Now<a id="_idIndexMarker511"/> that <a id="_idIndexMarker512"/>we have our approach defined, we can create our inverse matrix function by running the following code:<pre>fn invert_get_weight_matrix(py: &amp;Python, 
                            locals: &amp;PyDict) -&gt; () {
    let code: &amp;str = "np.linalg.inv(weights_matrix)";
    let inverted_weights_matrix = py.eval(code, None, 
                              Some(&amp;locals)).unwrap();
    locals.set_item("inverted_weights_matrix", 
                    inverted_weights_matrix);
}</pre></li>&#13;
			</ol>&#13;
			<p>Clearly, the <code>invert_get_weight_matrix</code> function cannot be run unless we run our <code>get_weight_matrix</code> function beforehand. We could make this more robust with a <code>get_item</code> check for <code>weights_matrix</code> in our <code>locals</code> storage and run the <code>get_weight_matrix</code> function if the weights matrix is not there, but this is not essential. We now have our weights functions defined, so we can move on to our next step of building our input vectors and calculation functions. </p>&#13;
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Building get_parameters, get_times, and get_input_vector functions</h2>&#13;
			<p>Just as <a id="_idIndexMarker513"/>with <a id="_idIndexMarker514"/>the previous <a id="_idIndexMarker515"/>steps. we are going to get our parameters, times, and inputs by using three functions. We will also have to pass the Python struct and <code>locals</code> storage into these functions as they are also going to be using NumPy via Python. We define these three functions in the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Referring to <em class="italic">Figure 7.6</em>, we can see that our input vector function does not have any dependencies and the other two depend on the input vector. Considering this, we build our input vector function by running the following code:<pre>fn get_input_vector(py: &amp;Python, locals: &amp;PyDict, 
                    first: i32, second: i32) -&gt; () {
    let code: String = format!("np.array([[{}], \
      [{}]])", first, second);
    let input_vector = py.eval(&amp;code.as_str(), None, 
                       Some(&amp;locals)).unwrap();
    locals.set_item("input_vector", input_vector);
}</pre><p>Here, we can see that this vector is generic, so we can pass in the parameters or the times depending on the calculation that we need. We can see that we use the <code>format!</code> macro to pass our parameters into our Python code. </p></li>&#13;
				<li>Now that our input vector function is defined, we can build our calculations by running the following code:<pre>fn get_times&lt;'a&gt;(py: &amp;'a Python, 
                 locals: &amp;PyDict) -&gt; &amp;'a PyAny {
    let code: &amp;str = "np.dot(weights_matrix, \
      input_vector)";
    let times = py.eval(code, None, 
      Some(&amp;locals)).unwrap();
    return times
}
fn get_parameters&lt;'a&gt;(py: &amp;'a Python, 
                     locals: &amp;PyDict) -&gt; &amp;'a PyAny {
    let code: &amp;str = "
    np.dot(inverted_weights_matrix, input_vector)";
    let parameters = py.eval(code, None, 
                     Some(&amp;locals)).unwrap();
    return parameters
}</pre></li>&#13;
			</ol>&#13;
			<p>With the aforementioned functions, we can get the variables that we need and put them into our Python code that uses the NumPy <code>np.dot</code> function. We then return the result <a id="_idIndexMarker516"/>as <a id="_idIndexMarker517"/>opposed <a id="_idIndexMarker518"/>to adding it to <code>locals</code>. We do not need to add it to <code>locals</code> because we are not going to use the results in any other computations in Rust. Now that all the computation steps have been done, we can move on to our next step—building the calculation functions that run and organize the whole process.</p>&#13;
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Building calculate_parameters and calculate_times functions </h2>&#13;
			<p>With these<a id="_idIndexMarker519"/> calculation<a id="_idIndexMarker520"/> functions, we need to take in some parameters, get the Python GIL, define our <code>locals</code> storage, and then run a series of computation processes to get what we need. We can define a <code>calculate_times</code> function by running the following code:</p>&#13;
			<pre>#[pyfunction]</pre>&#13;
			<pre>pub fn calculate_times&lt;'a&gt;(result_dict: &amp;'a PyDict, </pre>&#13;
			<pre>    distance: i32, traffic_grade: i32) -&gt; PyResult&lt;&amp;'a \</pre>&#13;
			<pre>      PyDict&gt; {</pre>&#13;
			<pre>    let gil = Python::acquire_gil();</pre>&#13;
			<pre>    let py = gil.python();</pre>&#13;
			<pre>    let locals = PyDict::new(py);</pre>&#13;
			<pre>    locals.set_item("np", py.import("numpy").unwrap());</pre>&#13;
			<pre>    get_weight_matrix(&amp;py, locals);</pre>&#13;
			<pre>    get_input_vector(&amp;py, locals, distance, traffic_grade);</pre>&#13;
			<pre>    result_dict.set_item("times", get_times(&amp;py, locals));</pre>&#13;
			<pre>    return Ok(result_dict)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we <a id="_idIndexMarker521"/>can <a id="_idIndexMarker522"/>see that we get the weight matrix, then the input vector, and then insert the results into a blank <code>PyDict</code> struct and return it. We can see the flexibility in this approach. We can slot functions in and out whenever we want, and rearranging the order is not a struggle. Now that we have built our <code>calculate_times</code> function, we can build our <code>calculate_parameters</code> function by running the following code:</p>&#13;
			<pre>#[pyfunction]</pre>&#13;
			<pre>pub fn calculate_parameters&lt;'a&gt;(result_dict: &amp;'a PyDict, </pre>&#13;
			<pre>    car_time: i32, truck_time: i32) -&gt; PyResult&lt;&amp;'a PyDict&gt; {</pre>&#13;
			<pre>    let gil = Python::acquire_gil();</pre>&#13;
			<pre>    let py = gil.python();</pre>&#13;
			<pre>    let locals = PyDict::new(py);</pre>&#13;
			<pre>    locals.set_item("np", py.import("numpy").unwrap());</pre>&#13;
			<pre>    get_weight_matrix(&amp;py, locals);</pre>&#13;
			<pre>    invert_get_weight_matrix(&amp;py, locals);</pre>&#13;
			<pre>    get_input_vector(&amp;py, locals, car_time, truck_time);</pre>&#13;
			<pre>    result_dict.set_item("parameters", </pre>&#13;
			<pre>        get_parameters(&amp;py, locals));</pre>&#13;
			<pre>    return Ok(result_dict)</pre>&#13;
			<pre>}</pre>&#13;
			<p>We can see that we use the same approach as our <code>calculate_times</code> function, using the invert weights instead. We could refactor this to reduce the repeated code, or we could enjoy <a id="_idIndexMarker523"/>the maximum flexibility of having the two <a id="_idIndexMarker524"/>functions isolated against each other. Our model is built now, so we can move to our next step where we add our calculation functions to our Python bindings.</p>&#13;
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Adding calculate functions to the Python bindings and adding a NumPy dependency to our setup.py file</h2>&#13;
			<p>Now <a id="_idIndexMarker525"/>that<a id="_idIndexMarker526"/> we have <a id="_idIndexMarker527"/>all the<a id="_idIndexMarker528"/> model code needed to calculate parameters through two functions, we are going to have to enable our outside user to utilize these functions with the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">In our <code>src/lib.rs</code> file, we must define our module by running the following code:<pre>mod numpy_model;</pre></li>&#13;
				<li>Now that this module has been declared, we can import the functions by running the following code:<pre>use numpy_model::__pyo3_get_function_calculate_times;
use numpy_model::__pyo3_get_function_calculate_ \
  parameters;</pre></li>&#13;
				<li>We<a id="_idIndexMarker529"/> then<a id="_idIndexMarker530"/> wrap<a id="_idIndexMarker531"/> our<a id="_idIndexMarker532"/> functions in our module by running the following code:<pre>#[pymodule]
fn flitton_fib_rs(_py: Python, m: &amp;PyModule) -&gt; \
  PyResult&lt;()&gt; {
    . . . 
    m.add_wrapped(wrap_pyfunction!(calculate_times));
    m.add_wrapped(wrap_pyfunction!(calculate_parameters));
    . . . 
}</pre><p>Remember—<code>. . .</code> denotes existing code. We now must accept that our Rust code has a dependency on NumPy, so in our <code>setup.py</code> file, our dependencies will look like this:</p><pre>    requirements=[
        "pyyaml&gt;=3.13",
        "numpy"
    ]</pre></li>&#13;
			</ol>&#13;
			<p>At this point, there is nothing stopping us from using our NumPy model; however, it will be better with a simple Python interface, which we will define in the next step.</p>&#13;
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Building our Python interface </h2>&#13;
			<p>In the <code>src/numpy_model.rs</code> file, we <a id="_idIndexMarker533"/>import what we need and define a basic class by running the following code:</p>&#13;
			<pre>from .flitton_fib_rs import calculate_times, \</pre>&#13;
			<pre>calculate_parameters</pre>&#13;
			<pre>class NumpyInterface:</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    def __init__(self):</pre>&#13;
			<pre>        self.inventory = {}</pre>&#13;
			<p>The <code>self.inventory</code> variable will be where we store the results. Our functions for our class should calculate the times and parameters by calling our Rust functions, as follows: </p>&#13;
			<pre>    def calc_times(self, distance, traffic_grade):</pre>&#13;
			<pre>        result = calculate_times({}, distance, </pre>&#13;
			<pre>                                 traffic_grade)</pre>&#13;
			<pre>        self.inventory["car time"] = result["times"][0][0]</pre>&#13;
			<pre>        self.inventory["truck time"] = \</pre>&#13;
			<pre>          result["times"][1][0]</pre>&#13;
			<pre>        </pre>&#13;
			<pre>    def calc_parameters(self, car_time, truck_time):</pre>&#13;
			<pre>        result = calculate_parameters({}, car_time, </pre>&#13;
			<pre>            truck_time)</pre>&#13;
			<pre>        self.inventory["distance"] = </pre>&#13;
			<pre>                          result["parameters"][0][0]</pre>&#13;
			<pre>        self.inventory["traffic grade"] = </pre>&#13;
			<pre>                          result["parameters"][1][0]</pre>&#13;
			<p>Now that our Python interface is built, we have finished our NumPy model.</p>&#13;
			<p>We must remember to update our GitHub repository and reinstall our module. Once this is done, we can run the following Python console commands:</p>&#13;
			<pre>&gt;&gt;&gt; from flitton_fib_rs.numpy_interface import </pre>&#13;
			<pre>NumpyInterface</pre>&#13;
			<pre>&gt;&gt;&gt; test = NumpyInterface()</pre>&#13;
			<pre>&gt;&gt;&gt; test.calc_times(10, 20)</pre>&#13;
			<pre>&gt;&gt;&gt; test.calc_parameters(70, 90)</pre>&#13;
			<pre>&gt;&gt;&gt; test.inventory</pre>&#13;
			<pre>{'car time': 70, 'truck time': 90, </pre>&#13;
			<pre> 'distance': 9.999999999999998, </pre>&#13;
			<pre> 'traffic grade': 20.0}</pre>&#13;
			<p>While this demonstrates how we can use Python modules within Rust, we have to be careful when to use them. For our NumPy model example, it would have just been better to use NumPy within our Python code. To be honest, there is not that much that you can do with Python modules that you cannot do in Rust. Rust already has a NumPy crate that we <a id="_idIndexMarker534"/>can use. We should be using the Python modules in the initial stage if we cannot find—or do not have time to find and learn—a Rust alternative module; however, over time, these should be phased out of your Rust code.  </p>&#13;
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Summary</h1>&#13;
			<p>In this chapter, we completed our tool belt when it comes to building Python extensions in Rust by using Python modules in our Rust code. We got a deeper appreciation for modules such as NumPy by exploring matrix mathematics to create a simple mathematical model. This showed us that we use modules such as NumPy for other functionality such as matrix multiplication, as opposed to just using NumPy for speed. This was demonstrated when we manipulated multiple mathematical equations with a few lines of NumPy code and matrix logic.</p>&#13;
			<p>We then used matrix NumPy multiplication functions in our Rust code to recreate our mathematical model using a flexible functional programming approach. We finished this off by making our interface in a Python class. We also must remember that the NumPy implementation was faster than our Rust code. This is partly down to poor implementation on our part and the C optimization in NumPy. This has shown us that while Rust is a lot faster than Python, solving problems with Python packages such as NumPy might still be faster until equivalent crates are coded in Rust.</p>&#13;
			<p>We used a generic approach to using Python modules in Rust. Because of this, we can theoretically use any Python module that we want. This means that if the Python module that you are rewriting relies on the functionality of third-party Python modules such as NumPy, we are now able to create Rust functions that use them. Considering this, there is no generic technical hurdle stopping you from rewriting Python code in Rust and slotting it into your Python system. </p>&#13;
			<p>In the next chapter, we will put everything that we have learned so far together to build a new Python package written in Rust from start to end. </p>&#13;
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What are the steps we must follow to run a Python module in Rust?</li>&#13;
				<li>How do you import a Python module into your Rust code?</li>&#13;
				<li>If we wanted to use our Python code result inside Rust, how would we do this? </li>&#13;
				<li>When you compare speed graphs of Python/NumPy with Rust, the Python/NumPy code has a lot of spikes. What could be causing this?</li>&#13;
				<li>Do you think our NumPy implementation in Rust will be slower or faster than calling NumPy from Python, and why?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">We initially must get Python from the GIL. We then must build a <code>PyDict</code> struct in order to store and pass Python variables between Python executions. We then define the Python code as a string literal and pass this into our <code>py.eval</code> function with our <code>PyDict</code> storage.</li>&#13;
				<li>We must make sure that we get Python from the GIL. We then use this to run the <code>py.eval</code> function with the import line of code passed in as a string literal. We must remember to pass in our <code>PyDict</code> storage to ensure that we can reference the module in the future.</li>&#13;
				<li>We must remember that Python code returns a <code>PyAny</code> struct, which we can extract using the following code:<pre>let code = "5 + 6";
<code>number</code> should be <code>11</code>. </p></li>&#13;
				<li>This is because the Python versions must keep stopping to clean up variables with the garbage collection mechanism.</li>&#13;
				<li>It would be slightly slower. This is because we are essentially still running Python code but through an extra layer which is Rust.Considering this, we should be using Python code out of convenience as opposed to optimization. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Further reading</h1>&#13;
			<ul>&#13;
				<li>NumPy documentation for Rust (2021): <em class="italic">Crate numpy:</em> <a href="https://docs.rs/numpy/0.14.1/numpy/">https://docs.rs/numpy/0.14.1/numpy/</a></li>&#13;
				<li>Giuseppe Ciaburro (2020): <em class="italic">Hands-on Simulation Modeling with Python: Develop simulation models to get accurate results and enhance decision-making processes</em>. Packt Publishing.</li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>