["```rs\nlet playlist = self.playlist.clone();\nlet play_image = self.toolbar.play_image.clone();\nlet cover = self.cover.clone();\nlet state = self.state.clone();\nself.toolbar.play_button.connect_clicked(move |_| {\n    if state.lock().unwrap().stopped {\n        if playlist.play() {\n            set_image_icon(&play_image, PAUSE_ICON);\n            set_cover(&cover, &playlist);\n        }\n    } else {\n        playlist.pause();\n        set_image_icon(&play_image, PLAY_ICON);\n    }\n});\n```", "```rs\nuse std::cell::RefCell;\nuse std::collections::HashMap;\n\nfn main() {\n    let cell = RefCell::new(HashMap::new());\n    cell.borrow_mut().insert(\"one\", 1);\n    let borrowed_cell = cell.borrow();\n    if let Some(key) = borrowed_cell.get(\"one\") {\n        cell.borrow_mut().insert(\"two\", 2);\n    }\n}\n```", "```rs\nthread 'main' panicked at 'already borrowed: BorrowMutError', /checkout/src/libcore/result.rs:906:4\n```", "```rs\npub fn view(&self) -> &TreeView {\n    &self.treeview\n}\n```", "```rs\nuse std::ops::Deref;\n\nimpl Deref for Playlist {\n    type Target = TreeView;\n\n    fn deref(&self) -> &TreeView {\n        &self.treeview\n    }\n}\n```", "```rs\nparent.add(&*playlist);\n```", "```rs\nparent.add(playlist.view());\n```", "```rs\nrustup default nightly\n```", "```rs\nrustup default stable\n```", "```rs\nrustup update\n```", "```rs\ncargo new rusic-relm --bin\n```", "```rs\n[dependencies]\ngtk = \"^0.3.0\"\ngtk-sys = \"^0.5.0\"\nrelm = \"^0.11.0\"\nrelm-attributes = \"^0.11.0\"\nrelm-derive = \"^0.11.0\"\n```", "```rs\n#![feature(proc_macro)]\n\nextern crate gtk;\nextern crate gtk_sys;\n#[macro_use]\nextern crate relm;\nextern crate relm_attributes;\n#[macro_use]\nextern crate relm_derive;\n```", "```rs\npub struct Model {\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    fn model() -> Model {\n        Model {\n        }\n    }\n\n    // …\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    Quit,\n}\n```", "```rs\nuse gtk::{\n    GtkWindowExt,\n    Inhibit,\n    WidgetExt,\n};\nuse relm::Widget;\nuse relm_attributes::widget;\n\nuse self::Msg::*;\n\n#[widget]\nimpl Widget for App {\n    // …\n\n    view! {\n        gtk::Window {\n            title: \"Rusic\",\n            delete_event(_, _) => (Quit, Inhibit(false)),\n        }\n    }\n}\n```", "```rs\ndelete_event(_, _) => (Quit, Inhibit(false)),\n```", "```rs\nfn view(relm: &Relm<Self>, model: Self::Model) -> Self {\n   // This method does not actually exist, but relm directly create a window using the functions from the sys crates.\n    let window = gtk::Window::new();\n    window.set_title(\"Rusic\");\n\n    window.show();\n\n    connect!(relm, window, connect_delete_event(_, _), return \n     (Some(Quit), Inhibit(false)));\n\n    Win {\n        model,\n        window: window,\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    fn update(&mut self, event: Msg) {\n        match event {\n            Quit => gtk::main_quit(),\n        }\n    }\n\n    // …\n}\n```", "```rs\nfn main() {\n    App::run(()).unwrap();\n}\n```", "```rs\nview! {\n    gtk::Window {\n        title: \"Rusic\",\n        delete_event(_, _) => (Quit, Inhibit(false)),\n        gtk::Box {\n        },\n    }\n}\n```", "```rs\nview! {\n    gtk::Window {\n        title: \"Rusic\",\n        delete_event(_, _) => (Quit, Inhibit(false)),\n        gtk::Box {\n            orientation: Vertical,\n            #[name=\"toolbar\"]\n            gtk::Toolbar {\n            },\n        },\n    }\n}\n```", "```rs\nuse gtk::Image;\n\npub const PAUSE_ICON: &str = \"gtk-media-pause\";\npub const PLAY_ICON: &str = \"gtk-media-play\";\n\npub struct Model {\n    play_image: Image,\n}\n```", "```rs\nfn model() -> Model {\n    Model {\n        play_image: new_icon(PLAY_ICON),\n    }\n}\n```", "```rs\nfn new_icon(icon: &str) -> Image {\n    Image::new_from_file(format!(\"assets/{}.png\", icon))\n}\n```", "```rs\nuse gtk::{\n    OrientableExt,\n    ToolButtonExt,\n};\nuse gtk::Orientation::Vertical;\n\nview! {\n    gtk::Window {\n        title: \"Rusic\",\n        delete_event(_, _) => (Quit, Inhibit(false)),\n        gtk::Box {\n            orientation: Vertical,\n            #[name=\"toolbar\"]\n            gtk::Toolbar {\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"document-open\"),\n                    clicked => Open,\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"document-save\"),\n                    clicked => Save,\n                },\n                gtk::SeparatorToolItem {\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-media-previous\"),\n                },\n                gtk::ToolButton {\n                    icon_widget: &self.model.play_image,\n                    clicked => PlayPause,\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-media-stop\"),\n                    clicked => Stop,\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-media-next\"),\n                },\n                gtk::SeparatorToolItem {\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"remove\"),\n                },\n                gtk::SeparatorToolItem {\n                },\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-quit\"),\n                    clicked => Quit,\n                },\n            },\n        },\n    }\n}\n```", "```rs\ntool_button.set_icon_widget(&new_icon(\"gtk-quit\"));\n```", "```rs\nself.model.string.push_str(\"string\");\n```", "```rs\nself.model.string += \"string\";\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    Open,\n    PlayPause,\n    Quit,\n    Save,\n    Stop,\n}\n```", "```rs\n    fn update(&mut self, event: Msg) {\n        match event {\n            Open => (),\n            PlayPause => (),\n            Quit => gtk::main_quit(),\n            Save => (),\n            Stop => (),\n        }\n    }\n```", "```rs\n#[widget]\nimpl Widget for App {\n    fn init_view(&mut self) {\n        self.toolbar.show_all();\n    }\n\n    // …\n}\n```", "```rs\n[dependencies]\ngdk-pixbuf = \"^0.3.0\"\n```", "```rs\nextern crate gdk_pixbuf;\n```", "```rs\nuse gdk_pixbuf::Pixbuf;\nuse gtk::{\n    Adjustment,\n    BoxExt,\n    ImageExt,\n    LabelExt,\n    ScaleExt,\n};\nuse gtk::Orientation::Horizontal;\n```", "```rs\npub struct Model {\n    adjustment: Adjustment,\n    cover_pixbuf: Option<Pixbuf>,\n    cover_visible: bool,\n    current_duration: u64,\n    current_time: u64,\n    play_image: Image,\n}\n```", "```rs\nfn model() -> Model {\n    Model {\n        adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        cover_pixbuf: None,\n        cover_visible: false,\n        current_duration: 0,\n        current_time: 0,\n        play_image: new_icon(PLAY_ICON),\n    }\n}\n```", "```rs\ngtk::Image {\n    from_pixbuf: self.model.cover_pixbuf.as_ref(),\n    visible: self.model.cover_visible,\n},\n```", "```rs\nview! {\n    gtk::Window {\n        title: \"Rusic\",\n        delete_event(_, _) => (Quit, Inhibit(false)),\n        gtk::Box {\n            orientation: Vertical,\n            #[name=\"toolbar\"]\n            gtk::Toolbar {\n                // …\n            },\n            gtk::Image {\n                from_pixbuf: self.model.cover_pixbuf.as_ref(),\n                visible: self.model.cover_visible,\n            },\n            gtk::Box {\n                orientation: Horizontal,\n                spacing: 10,\n                gtk::Scale(Horizontal, &self.model.adjustment) {\n                    draw_value: false,\n                    hexpand: true,\n                },\n                gtk::Label {\n                    text: &millis_to_minutes(self.model.current_time),\n                },\n                gtk::Label {\n                    text: \"/\",\n                },\n                gtk::Label {\n                    margin_right: 10,\n                    text: &millis_to_minutes(self.model.current_duration),\n                },\n            },\n        },\n    }\n}\n```", "```rs\nfn millis_to_minutes(millis: u64) -> String {\n    let mut seconds = millis / 1_000;\n    let minutes = seconds / 60;\n    seconds %= 60;\n    format!(\"{}:{:02}\", minutes, seconds)\n}\n```", "```rs\ngtk::Scale(Horizontal, &self.model.adjustment) {\n    draw_value: false,\n    hexpand: true,\n}\n```", "```rs\ngtk::Scale::new(Horizontal, &self.model.adjustment);\n```", "```rs\nuse gtk::RangeExt;\n\ngtk::Scale {\n    adjustment: &self.model.adjustment,\n    orientation: Horizontal,\n    draw_value: false,\n    hexpand: true,\n}\n```", "```rs\nuse std::path::PathBuf;\n\nuse gtk::{FileChooserAction, FileChooserDialog, FileFilter};\nuse gtk_sys::{GTK_RESPONSE_ACCEPT, GTK_RESPONSE_CANCEL};\n\nconst RESPONSE_ACCEPT: i32 = GTK_RESPONSE_ACCEPT as i32;\nconst RESPONSE_CANCEL: i32 = GTK_RESPONSE_CANCEL as i32;\n\nfn show_open_dialog(parent: &Window) -> Option<PathBuf> {\n    let mut file = None;\n    let dialog = FileChooserDialog::new(Some(\"Select an MP3 audio file\"), \n    Some(parent), FileChooserAction::Open);\n\n    let mp3_filter = FileFilter::new();\n    mp3_filter.add_mime_type(\"audio/mp3\");\n    mp3_filter.set_name(\"MP3 audio file\");\n    dialog.add_filter(&mp3_filter);\n\n    let m3u_filter = FileFilter::new();\n    m3u_filter.add_mime_type(\"audio/x-mpegurl\");\n    m3u_filter.set_name(\"M3U playlist file\");\n    dialog.add_filter(&m3u_filter);\n\n    dialog.add_button(\"Cancel\", RESPONSE_CANCEL);\n    dialog.add_button(\"Accept\", RESPONSE_ACCEPT);\n    let result = dialog.run();\n    if result == RESPONSE_ACCEPT {\n        file = dialog.get_filename();\n    }\n    dialog.destroy();\n    file\n}\n\nfn show_save_dialog(parent: &Window) -> Option<PathBuf> {\n    let mut file = None;\n    let dialog = FileChooserDialog::new(Some(\"Choose a destination M3U playlist \n    file\"), Some(parent), FileChooserAction::Save);\n    let filter = FileFilter::new();\n    filter.add_mime_type(\"audio/x-mpegurl\");\n    filter.set_name(\"M3U playlist file\");\n    dialog.set_do_overwrite_confirmation(true);\n    dialog.add_filter(&filter);\n    dialog.add_button(\"Cancel\", RESPONSE_CANCEL);\n    dialog.add_button(\"Save\", RESPONSE_ACCEPT);\n    let result = dialog.run();\n    if result == RESPONSE_ACCEPT {\n        file = dialog.get_filename();\n    }\n    dialog.destroy();\n    file\n}\n```", "```rs\nuse gtk::{ButtonsType, DialogFlags, MessageDialog, MessageType};\n\nimpl App {\n    fn open(&self) {\n        let file = show_open_dialog(&self.window);\n        if let Some(file) = file {\n            let ext = file.extension().map(|ext| \n             ext.to_str().unwrap().to_string());\n            if let Some(ext) = ext {\n                match ext.as_str() {\n                    \"mp3\" => (),\n                    \"m3u\" => (),\n                    extension => {\n                        let dialog = \n                        MessageDialog::new(Some(&self.window),  \n                        DialogFlags::empty(), MessageType::Error,\n                        ButtonsType::Ok, &format!(\"Cannot open file \n                         with extension . {}\", extension));\n                        dialog.run();\n                        dialog.destroy();\n                    },\n                }\n            }\n        }\n    }\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        Open => self.open(),\n        PlayPause =>  (),\n        Quit => gtk::main_quit(),\n        Save => show_save_dialog(&self.window),\n        Stop => (),\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    // …\n\n    fn set_current_time(&mut self, time: u64) {\n        self.model.current_time = time;\n        self.model.adjustment.set_value(time as f64);\n    }\n\n    fn set_play_icon(&self, icon: &str) {\n        self.model.play_image.set_from_file(format!(\"assets/{}.png\", icon));\n    }\n}\n```", "```rs\npub struct Model {\n    adjustment: Adjustment,\n    cover_pixbuf: Option<Pixbuf>,\n    cover_visible: bool,\n    current_duration: u64,\n    current_time: u64,\n    play_image: Image,\n    stopped: bool,\n}\n```", "```rs\nfn model() -> Model {\n    Model {\n        adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        cover_pixbuf: None,\n        cover_visible: false,\n        current_duration: 0,\n        current_time: 0,\n        play_image: new_icon(PLAY_ICON),\n        stopped: true,\n    }\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        Open => self.open(),\n        PlayPause =>  {\n            if !self.model.stopped {\n                self.set_play_icon(PLAY_ICON);\n            }\n        },\n        Quit => gtk::main_quit(),\n        Save => show_save_dialog(&self.window),\n        Stop => {\n            self.set_current_time(0);\n            self.model.current_duration = 0;\n            self.model.cover_visible = false;\n            self.set_play_icon(PLAY_ICON);\n        },\n    }\n}\n```", "```rs\n[dependencies]\nid3 = \"^0.2.0\"\nm3u = \"^1.0.0\"\n```", "```rs\nextern crate id3;\nextern crate m3u;\n```", "```rs\nmod playlist;\n```", "```rs\nuse gtk::ListStore;\n\npub struct Model {\n    current_song: Option<String>,\n    model: ListStore,\n    relm: Relm<Playlist>,\n}\n```", "```rs\nuse relm::Relm;\n```", "```rs\nuse gdk_pixbuf::Pixbuf;\nuse gtk::{StaticType, Type};\n\n#[widget]\nimpl Widget for Playlist {\n    fn model(relm: &Relm<Self>, _: ()) -> Model {\n        Model {\n            current_song: None,\n            model: ListStore::new(&[\n                Pixbuf::static_type(),\n                Type::String,\n                Type::String,\n                Type::String,\n                Type::String,\n                Type::String,\n                Type::String,\n                Type::String,\n                Pixbuf::static_type(),\n            ]),\n            relm: relm.clone(),\n        }\n    }\n}\n```", "```rs\nApp::run(()).unwrap();\n```", "```rs\nuse gtk;\nuse gtk::{TreeViewExt, WidgetExt};\nuse relm::Widget;\nuse relm_attributes::widget;\n\n#[widget]\nimpl Widget for Playlist {\n    // …\n\n    view! {\n        #[name=\"treeview\"]\n        gtk::TreeView {\n            hexpand: true,\n            model: &self.model.model,\n            vexpand: true,\n        }\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for Playlist {\n    // …\n\n    fn update(&mut self, event: Msg) {\n    }\n}\n```", "```rs\nuse self::Visibility::*;\n\n#[derive(PartialEq)]\nenum Visibility {\n    Invisible,\n    Visible,\n}\n\nconst THUMBNAIL_COLUMN: u32 = 0;\nconst TITLE_COLUMN: u32 = 1;\nconst ARTIST_COLUMN: u32 = 2;\nconst ALBUM_COLUMN: u32 = 3;\nconst GENRE_COLUMN: u32 = 4;\nconst YEAR_COLUMN: u32 = 5;\nconst TRACK_COLUMN: u32 = 6;\nconst PATH_COLUMN: u32 = 7;\nconst PIXBUF_COLUMN: u32 = 8;\n```", "```rs\nimpl Playlist {\n    fn add_pixbuf_column(&self, column: i32, visibility: Visibility) {\n        let view_column = TreeViewColumn::new();\n        if visibility == Visible {\n            let cell = CellRendererPixbuf::new();\n            view_column.pack_start(&cell, true);\n            view_column.add_attribute(&cell, \"pixbuf\", column);\n        }\n        self.treeview.append_column(&view_column);\n\n    }\n\n    fn add_text_column(&self, title: &str, column: i32) {\n        let view_column = TreeViewColumn::new();\n        view_column.set_title(title);\n        let cell = CellRendererText::new();\n        view_column.set_expand(true);\n        view_column.pack_start(&cell, true);\n        view_column.add_attribute(&cell, \"text\", column);\n        self.treeview.append_column(&view_column);\n    }\n\n    fn create_columns(&self) {\n        self.add_pixbuf_column(THUMBNAIL_COLUMN as i32, Visible);\n        self.add_text_column(\"Title\", TITLE_COLUMN as i32);\n        self.add_text_column(\"Artist\", ARTIST_COLUMN as i32);\n        self.add_text_column(\"Album\", ALBUM_COLUMN as i32);\n        self.add_text_column(\"Genre\", GENRE_COLUMN as i32);\n        self.add_text_column(\"Year\", YEAR_COLUMN as i32);\n        self.add_text_column(\"Track\", TRACK_COLUMN as i32);\n        self.add_pixbuf_column(PIXBUF_COLUMN as i32, Invisible);\n    }\n}\n```", "```rs\nuse gtk::{\n    CellLayoutExt,\n    CellRendererPixbuf,\n    CellRendererText,\n    TreeViewColumn,\n    TreeViewColumnExt,\n    TreeViewExt,\n};\n```", "```rs\n#[widget]\nimpl Widget for Playlist {\n    fn init_view(&mut self) {\n        self.create_columns();\n    }\n\n    // …\n}\n```", "```rs\nuse std::path::Path;\n\nuse gtk::{ListStoreExt, ListStoreExtManual, ToValue};\nuse id3::Tag;\n\nimpl Playlist {\n    fn add(&self, path: &Path) {\n        let filename =  \n         path.file_stem().unwrap_or_default().to_str().unwrap_or_default();\n\n        let row = self.model.model.append();\n\n        if let Ok(tag) = Tag::read_from_path(path) {\n            let title = tag.title().unwrap_or(filename);\n            let artist = tag.artist().unwrap_or(\"(no artist)\");\n            let album = tag.album().unwrap_or(\"(no album)\");\n            let genre = tag.genre().unwrap_or(\"(no genre)\");\n            let year = tag.year().map(|year|\n            year.to_string()).unwrap_or(\"(no year)\".to_string());\n            let track = tag.track().map(|track|  \n             track.to_string()).unwrap_or(\"??\".to_string());\n            let total_tracks = \n             tag.total_tracks().map(|total_tracks|  \n             total_tracks.to_string()).unwrap_or(\"??\".to_string());\n            let track_value = format!(\"{} / {}\", track, \n             total_tracks);\n\n            self.set_pixbuf(&row, &tag);\n\n            self.model.model.set_value(&row, TITLE_COLUMN, \n            &title.to_value());\n            self.model.model.set_value(&row, ARTIST_COLUMN,\n            &artist.to_value());\n            self.model.model.set_value(&row, ALBUM_COLUMN, \n            &album.to_value());\n            self.model.model.set_value(&row, GENRE_COLUMN, \n            &genre.to_value());\n            self.model.model.set_value(&row, YEAR_COLUMN,\n            &year.to_value());\n            self.model.model.set_value(&row, TRACK_COLUMN,\n            &track_value.to_value());\n        }\n        else {\n            self.model.model.set_value(&row, TITLE_COLUMN, \n             &filename.to_value());\n        }\n\n        let path = path.to_str().unwrap_or_default();\n        self.model.model.set_value(&row, PATH_COLUMN,\n         &path.to_value());\n    }\n}\n```", "```rs\nuse gdk_pixbuf::{InterpType, PixbufLoader};\nuse gtk::TreeIter;\n\nconst INTERP_HYPER: InterpType = 3;\n\nconst IMAGE_SIZE: i32 = 256;\nconst THUMBNAIL_SIZE: i32 = 64;\n\nfn set_pixbuf(&self, row: &TreeIter, tag: &Tag) {\n    if let Some(picture) = tag.pictures().next() {\n        let pixbuf_loader = PixbufLoader::new();\n        pixbuf_loader.set_size(IMAGE_SIZE, IMAGE_SIZE);\n        pixbuf_loader.loader_write(&picture.data).unwrap();\n        if let Some(pixbuf) = pixbuf_loader.get_pixbuf() {\n            let thumbnail = pixbuf.scale_simple(THUMBNAIL_SIZE, \n             THUMBNAIL_SIZE, INTERP_HYPER).unwrap();\n            self.model.model.set_value(row, THUMBNAIL_COLUMN, \n             &thumbnail.to_value());\n            self.model.model.set_value(row, PIXBUF_COLUMN, \n             &pixbuf.to_value());\n        }\n        pixbuf_loader.close().unwrap();\n    }\n}\n```", "```rs\nuse std::path::PathBuf;\n\nuse self::Msg::*;\n\n#[derive(Msg)]\npub enum Msg {\n    AddSong(PathBuf),\n    LoadSong(PathBuf),\n    NextSong,\n    PauseSong,\n    PlaySong,\n    PreviousSong,\n    RemoveSong,\n    SaveSong(PathBuf),\n    SongStarted(Option<Pixbuf>),\n    StopSong,\n}\n```", "```rs\n   fn update(&mut self, event: Msg) {\n      match event {\n          AddSong(path) => self.add(&path),\n          LoadSong(path) => (),\n          NextSong => (),\n          PauseSong => (),\n          PlaySong => (),\n          PreviousSong => (),\n          RemoveSong => (),\n          SaveSong(path) => (),\n          SongStarted(_) => (),\n          StopSong => (),\n        }\n    }\n```", "```rs\nuse playlist::Playlist;\nuse playlist::Msg::{\n    AddSong,\n    LoadSong,\n    NextSong,\n    PlaySong,\n    PauseSong,\n    PreviousSong,\n    RemoveSong,\n    SaveSong,\n    SongStarted,\n    StopSong,\n};\n```", "```rs\nview! {\n    #[name=\"window\"]\n    gtk::Window {\n        title: \"Rusic\",\n        gtk::Box {\n            orientation: Vertical,\n            #[name=\"toolbar\"]\n            gtk::Toolbar {\n                // …\n            },\n            #[name=\"playlist\"]\n            Playlist {\n            },\n            gtk::Image {\n                from_pixbuf: self.model.cover_pixbuf.as_ref(),\n                visible: self.model.cover_visible,\n            },\n            gtk::Box {\n                // …\n            },\n        },\n        delete_event(_, _) => (Quit, Inhibit(false)),\n    }\n}\n```", "```rs\ngtk::ToolButton {\n    icon_widget: &new_icon(\"gtk-quit\"),\n    clicked => Quit,\n}\n```", "```rs\nimpl Playlist {\n    fn play(&mut self) {\n        if let Some(path) = self.selected_path() {\n            self.model.current_song = Some(path.into());\n            self.model.relm.stream().emit(SongStarted(self.pixbuf()));\n        }\n    }\n}\n```", "```rs\nself.model.relm.stream().emit(SongStarted(self.pixbuf()));\n```", "```rs\nuse gtk::{\n    TreeModelExt,\n    TreeSelectionExt,\n};\n\nimpl Playlist {\n    fn pixbuf(&self) -> Option<Pixbuf> {\n        let selection = self.treeview.get_selection();\n        if let Some((_, iter)) = selection.get_selected() {\n            let value = self.model.model.get_value(&iter, \n             PIXBUF_COLUMN as i32);\n            return value.get::<Pixbuf>();\n        }\n        None\n    }\n\n    fn selected_path(&self) -> Option<String> {\n        let selection = self.treeview.get_selection();\n        if let Some((_, iter)) = selection.get_selected() {\n            let value = self.model.model.get_value(&iter, PATH_COLUMN as i32);\n            return value.get::<String>();\n        }\n        None\n    }\n}\n```", "```rs\n    fn update(&mut self, event: Msg) {\n        match event {\n            AddSong(path) => self.add(&path),\n            LoadSong(path) => (),\n            NextSong => (),\n            PauseSong => (),\n            PlaySong => self.play(),\n            PreviousSong => (),\n            RemoveSong => (),\n            SaveSong(path) => (),\n            // To be listened by App.\n            SongStarted(_) => (),\n            StopSong => (),\n        }\n    }\n```", "```rs\nimpl App {\n    fn open(&self) {\n        let file = show_open_dialog(&self.window);\n        if let Some(file) = file {\n            let ext = file.extension().map(|ext| ext.to_str().unwrap().to_string());\n            if let Some(ext) = ext {\n                match ext.as_str() {\n                    \"mp3\" => self.playlist.emit(AddSong(file)),\n                    \"m3u\" => self.playlist.emit(LoadSong(file)),\n                    extension => {\n                        let dialog = MessageDialog::new(Some(&self.window),  \n                        DialogFlags::empty(), MessageType::Error,\n                        ButtonsType::Ok, &format!(\"Cannot open file with \n                         extension . {}\", extension));\n                        dialog.run();\n                        dialog.destroy();\n                    },\n                }\n            }\n        }\n    }\n}\n```", "```rs\nself.playlist.emit(AddSong(file))\n```", "```rs\nuse m3u;\n\nimpl Playlist {\n    fn load(&self, path: &Path) {\n        let mut reader = m3u::Reader::open(path).unwrap();\n        for entry in reader.entries() {\n            if let Ok(m3u::Entry::Path(path)) = entry {\n                self.add(&path);\n            }\n        }\n    }\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        AddSong(path) => self.add(&path),\n        LoadSong(path) => self.load(&path),\n        NextSong => (),\n        PauseSong => (),\n        PlaySong => self.play(),\n        PreviousSong => (),\n        RemoveSong => (),\n        SaveSong(path) => (),\n        // To be listened by App.\n        SongStarted(_) => (),\n        StopSong => (),\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    // …\n\n    view! {\n        // …\n        #[name=\"playlist\"]\n        Playlist {\n            SongStarted(ref pixbuf) => Started(pixbuf.clone()),\n        }\n    }\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    Open,\n    PlayPause,\n    Quit,\n    Save,\n    Started(Option<Pixbuf>),\n    Stop,\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        // …\n        Started(pixbuf) => {\n            self.set_play_icon(PAUSE_ICON);\n            self.model.cover_visible = true;\n            self.model.cover_pixbuf = pixbuf;\n        },\n    }\n}\n```", "```rs\ngtk::ToolButton {\n    icon_widget: &new_icon(\"remove\"),\n    clicked => playlist@RemoveSong,\n}\n```", "```rs\n#[widget]\nimpl Widget for Playlist {\n    fn update(&mut self, event: Msg) {\n        match event {\n            AddSong(path) => self.add(&path),\n            LoadSong(path) => self.load(&path),\n            NextSong => (),\n            PauseSong => (),\n            PlaySong => self.play(),\n            PreviousSong => (),\n            RemoveSong => self.remove_selection(),\n            SaveSong(path) => (),\n            // To be listened by App.\n            SongStarted(_) => (),\n            StopSong => (),\n        }\n    }\n\n    // …\n}\n```", "```rs\nfn remove_selection(&self) {\n    let selection = self.treeview.get_selection();\n    if let Some((_, iter)) = selection.get_selected() {\n        self.model.model.remove(&iter);\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    fn update(&mut self, event: Msg) {\n        match event {\n            PlayPause =>  {\n                if self.model.stopped {\n                    self.playlist.emit(PlaySong);\n                } else {\n                    self.playlist.emit(PauseSong);\n                    self.set_play_icon(PLAY_ICON);\n                }\n            },\n            Save => {\n                let file = show_save_dialog(&self.window);\n                if let Some(file) = file {\n                    self.playlist.emit(SaveSong(file));\n                }\n            },\n            Stop => {\n                self.set_current_time(0);\n                self.model.current_duration = 0;\n                self.playlist.emit(StopSong);\n                self.model.cover_visible = false;\n                self.set_play_icon(PLAY_ICON);\n            },\n            // …\n        }\n    }\n}\n```", "```rs\nview! {\n    #[name=\"window\"]\n    gtk::Window {\n        title: \"Rusic\",\n        gtk::Box {\n            orientation: Vertical,\n            #[name=\"toolbar\"]\n            gtk::Toolbar {\n                // …\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-media-previous\"),\n                    clicked => playlist@PreviousSong,\n                },\n                // …\n                gtk::ToolButton {\n                    icon_widget: &new_icon(\"gtk-media-next\"),\n                    clicked => playlist@NextSong,\n                },\n            },\n            // …\n        },\n        delete_event(_, _) => (Quit, Inhibit(false)),\n    }\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        AddSong(path) => self.add(&path),\n        LoadSong(path) => self.load(&path),\n        NextSong => self.next(),\n        PauseSong => (),\n        PlaySong => self.play(),\n        PreviousSong => self.previous(),\n        RemoveSong => self.remove_selection(),\n        SaveSong(path) => self.save(&path),\n        // To be listened by App.\n        SongStarted(_) => (),\n        StopSong => self.stop(),\n    }\n}\n```", "```rs\nfn next(&mut self) {\n    let selection = self.treeview.get_selection();\n    let next_iter =\n        if let Some((_, iter)) = selection.get_selected() {\n            if !self.model.model.iter_next(&iter) {\n                return;\n            }\n            Some(iter)\n        }\n        else {\n            self.model.model.get_iter_first()\n        };\n    if let Some(ref iter) = next_iter {\n        selection.select_iter(iter);\n        self.play();\n    }\n}\n```", "```rs\nfn previous(&mut self) {\n    let selection = self.treeview.get_selection();\n    let previous_iter =\n        if let Some((_, iter)) = selection.get_selected() {\n            if !self.model.model.iter_previous(&iter) {\n                return;\n            }\n            Some(iter)\n        }\n        else {\n            self.model.model.iter_nth_child(None, max(0,  \n            self.model.model.iter_n_children(None) - 1))\n        };\n    if let Some(ref iter) = previous_iter {\n        selection.select_iter(iter);\n        self.play();\n    }\n}\n```", "```rs\nuse std::fs::File;\n\nfn save(&self, path: &Path) {\n    let mut file = File::create(path).unwrap();\n    let mut writer = m3u::Writer::new(&mut file);\n\n    let mut write_iter = |iter: &TreeIter| {\n        let value = self.model.model.get_value(&iter, PATH_COLUMN as i32);\n        let path = value.get::<String>().unwrap();\n        writer.write_entry(&m3u::path_entry(path)).unwrap();\n    };\n\n    if let Some(iter) = self.model.model.get_iter_first() {\n        write_iter(&iter);\n        while self.model.model.iter_next(&iter) {\n            write_iter(&iter);\n        }\n    }\n}\n```", "```rs\nfn stop(&mut self) {\n    self.model.current_song = None;\n}\n```", "```rs\nmod mp3;\n```", "```rs\n[dependencies]\ncrossbeam = \"^0.3.0\"\nfutures = \"^0.1.16\"\npulse-simple = \"^1.0.0\"\nsimplemad = \"^0.8.1\"\n```", "```rs\nextern crate crossbeam;\nextern crate futures;\nextern crate pulse_simple;\nextern crate simplemad;\n```", "```rs\nmod player;\n```", "```rs\nuse std::cell::Cell;\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Condvar, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nuse crossbeam::sync::SegQueue;\nuse futures::{AsyncSink, Sink};\nuse futures::sync::mpsc::UnboundedSender;\nuse pulse_simple::Playback;\n\nuse mp3::Mp3Decoder;\nuse playlist::PlayerMsg::{\n    self,\n    PlayerPlay,\n    PlayerStop,\n    PlayerTime,\n};\nuse self::Action::*;\n```", "```rs\n#[derive(Clone)]\npub enum PlayerMsg {\n    PlayerPlay,\n    PlayerStop,\n    PlayerTime(u64),\n}\n```", "```rs\nconst BUFFER_SIZE: usize = 1000;\nconst DEFAULT_RATE: u32 = 44100;\n```", "```rs\nenum Action {\n    Load(PathBuf),\n    Stop,\n}\n\n#[derive(Clone)]\nstruct EventLoop {\n    condition_variable: Arc<(Mutex<bool>, Condvar)>,\n    queue: Arc<SegQueue<Action>>,\n    playing: Arc<Mutex<bool>>,\n}\n\npub struct Player {\n    event_loop: EventLoop,\n    paused: Cell<bool>,\n    tx: UnboundedSender<PlayerMsg>,\n}\n```", "```rs\nimpl EventLoop {\n    fn new() -> Self {\n        EventLoop {\n            condition_variable: Arc::new((Mutex::new(false), Condvar::new())),\n            queue: Arc::new(SegQueue::new()),\n            playing: Arc::new(Mutex::new(false)),\n        }\n    }\n}\n```", "```rs\nimpl Player {\n    pub(crate) fn new(tx: UnboundedSender<PlayerMsg>) -> Self {\n        let event_loop = EventLoop::new();\n\n        {\n            let mut tx = tx.clone();\n            let event_loop = event_loop.clone();\n            let condition_variable = event_loop.condition_variable.clone();\n            thread::spawn(move || {\n                let block = || {\n                    let (ref lock, ref condition_variable) = *condition_variable;\n                    let mut started = lock.lock().unwrap();\n                    *started = false;\n                    while !*started {\n                        started = condition_variable.wait(started).unwrap();\n                    }\n                };\n\n                let mut buffer = [[0; 2]; BUFFER_SIZE];\n                let mut playback = Playback::new(\"MP3\", \"MP3 Playback\", None,  \n                DEFAULT_RATE);\n                let mut source = None;\n                loop {\n                    if let Some(action) = event_loop.queue.try_pop() {\n                        match action {\n                            Load(path) => {\n                                let file = File::open(path).unwrap();\n                                source = \n                Some(Mp3Decoder::new(BufReader::new(file)).unwrap());\n                                let rate = source.as_ref().map(|source|  \n                                source.samples_rate()).unwrap_or(DEFAULT_RATE);\n                                playback = Playback::new(\"MP3\", \"MP3 Playback\",  \n                                 None, rate);\n                                send(&mut tx, PlayerPlay);\n                            },\n                            Stop => {\n                                source = None;\n                            },\n                        }\n                    } else if *event_loop.playing.lock().unwrap() {\n                        let mut written = false;\n                        if let Some(ref mut source) = source {\n                            let size = iter_to_buffer(source, &mut buffer);\n                            if size > 0 {\n                                send(&mut tx, PlayerTime(source.current_time()));\n                                playback.write(&buffer[..size]);\n                                written = true;\n                            }\n                        }\n\n                        if !written {\n                            send(&mut tx, PlayerStop);\n                            *event_loop.playing.lock().unwrap() = false;\n                            source = None;\n                            block();\n                        }\n                    } else {\n                        block();\n                    }\n                }\n            });\n        }\n\n        Player {\n            event_loop,\n            paused: Cell::new(false),\n            tx,\n        }\n    }\n}\n```", "```rs\nsend(&mut tx, PlayerTime(source.current_time()));\n```", "```rs\nfn send(tx: &mut UnboundedSender<PlayerMsg>, msg: PlayerMsg) {\n    if let Ok(AsyncSink::Ready) = tx.start_send(msg) {\n        tx.poll_complete().unwrap();\n    } else {\n        eprintln!(\"Unable to send message to sender\");\n    }\n}\n```", "```rs\nfn iter_to_buffer<I: Iterator<Item=i16>>(iter: &mut I, buffer: &mut [[i16; 2]; BUFFER_SIZE]) -> usize {\n    let mut iter = iter.take(BUFFER_SIZE);\n    let mut index = 0;\n    while let Some(sample1) = iter.next() {\n        if let Some(sample2) = iter.next() {\n            buffer[index][0] = sample1;\n            buffer[index][1] = sample2;\n        }\n        index += 1;\n    }\n    index\n}\n```", "```rs\npub fn load<P: AsRef<Path>>(&self, path: P) {\n    let pathbuf = path.as_ref().to_path_buf();\n    self.emit(Load(pathbuf));\n    self.set_playing(true);\n}\n\npub fn pause(&mut self) {\n    self.paused.set(true);\n    self.send(PlayerStop);\n    self.set_playing(false);\n}\n\npub fn resume(&mut self) {\n    self.paused.set(false);\n    self.send(PlayerPlay);\n    self.set_playing(true);\n}\n```", "```rs\nfn emit(&self, action: Action) {\n    self.event_loop.queue.push(action);\n}\n\nfn send(&mut self, msg: PlayerMsg) {\n    send(&mut self.tx, msg);\n}\n\nfn set_playing(&self, playing: bool) {\n    *self.event_loop.playing.lock().unwrap() = playing;\n    let (ref lock, ref condition_variable) = *self.event_loop.condition_variable;\n    let mut started = lock.lock().unwrap();\n    *started = playing;\n    if playing {\n        condition_variable.notify_one();\n    }\n}\n```", "```rs\npub fn is_paused(&self) -> bool {\n    self.paused.get()\n}\n\npub fn stop(&mut self) {\n    self.paused.set(false);\n    self.send(PlayerTime(0));\n    self.send(PlayerStop);\n    self.emit(Stop);\n    self.set_playing(false);\n}\n```", "```rs\nuse player::Player;\n\npub struct Model {\n    current_song: Option<String>,\n    player: Player,\n    model: ListStore,\n    relm: Relm<Playlist>,\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    AddSong(PathBuf),\n    LoadSong(PathBuf),\n    NextSong,\n    PauseSong,\n    PlayerMsgRecv(PlayerMsg),\n    PlaySong,\n    PreviousSong,\n    RemoveSong,\n    SaveSong(PathBuf),\n    SongStarted(Option<Pixbuf>),\n    StopSong,\n}\n```", "```rs\nuse futures::sync::mpsc;\n\nfn model(relm: &Relm<Self>, _: ()) -> Model {\n    let (tx, rx) = mpsc::unbounded();\n    relm.connect_exec_ignore_err(rx, PlayerMsgRecv);\n    Model {\n        current_song: None,\n        player: Player::new(tx),\n        model: ListStore::new(&[\n            Pixbuf::static_type(),\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Type::String,\n            Pixbuf::static_type(),\n        ]),\n        relm: relm.clone(),\n    }\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        // To be listened by App.\n        PlayerMsgRecv(_) => (),\n        // …\n    }\n}\n```", "```rs\nfn pause(&mut self) {\n    self.model.player.pause();\n}\n```", "```rs\nfn play(&mut self) {\n    if let Some(path) = self.selected_path() {\n        if self.model.player.is_paused() && Some(&path) == self.path().as_ref() {\n            self.model.player.resume();\n        } else {\n            self.model.player.load(&path);\n            self.model.current_song = Some(path.into());\n            self.model.relm.stream().emit(SongStarted(self.pixbuf()));\n        }\n    }\n}\n\nfn stop(&mut self) {\n    self.model.current_song = None;\n    self.model.player.stop();\n}\n```", "```rs\nfn path(&self) -> Option<String> {\n    self.model.current_song.clone()\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    MsgRecv(PlayerMsg),\n    // …\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        MsgRecv(player_msg) => self.player_message(player_msg),\n        // …\n    }\n}\n```", "```rs\n#[widget]\nimpl Widget for App {\n    fn player_message(&mut self, player_msg: PlayerMsg) {\n        match player_msg {\n            PlayerPlay => {\n                self.model.stopped = false;\n                self.set_play_icon(PAUSE_ICON);\n            },\n            PlayerStop => {\n                self.set_play_icon(PLAY_ICON);\n                self.model.stopped = true;\n            },\n            PlayerTime(time) => self.set_current_time(time),\n        }\n    }\n}\n```", "```rs\npub fn compute_duration<P: AsRef<Path>>(path: P) -> Option<Duration> {\n    let file = File::open(path).unwrap();\n    Mp3Decoder::compute_duration(BufReader::new(file))\n}\n```", "```rs\nuse std::thread;\nuse futures::sync::oneshot;\n\nfn compute_duration(&self, path: &Path) {\n    let path = path.to_path_buf();\n    let (tx, rx) = oneshot::channel();\n    thread::spawn(move || {\n        if let Some(duration) = Player::compute_duration(&path) {\n            tx.send((path, duration))\n                .expect(\"Cannot send computed duration\");\n        }\n    });\n    self.model.relm.connect_exec_ignore_err(rx, |(path, duration)| DurationComputed(path, duration));\n}\n```", "```rs\nuse std::time::Duration;\n\n#[derive(Msg)]\npub enum Msg {\n    AddSong(PathBuf),\n    DurationComputed(PathBuf, Duration),\n    SongDuration(u64),\n    // …\n}\n```", "```rs\nimpl Playlist {\n    fn add(&self, path: &Path) {\n        self.compute_duration(path);\n        // …\n    }\n}\n```", "```rs\nuse to_millis;\n\nfn update(&mut self, event: Msg) {\n    match event {\n        DurationComputed(path, duration) => {\n            let path = path.to_string_lossy().to_string();\n            if self.model.current_song.as_ref() == Some(&path) {\n                self.model.relm.stream().emit(SongDuration(to_millis(duration)));\n            }\n            self.model.durations.insert(path, to_millis(duration));\n        },\n        // To be listened by App.\n        SongDuration(_) => (),\n        // …\n    }\n}\n```", "```rs\nuse std::collections::HashMap;\n\npub struct Model {\n    current_song: Option<String>,\n    durations: HashMap<String, u64>,\n    player: Player,\n    model: ListStore,\n    relm: Relm<Playlist>,\n}\n```", "```rs\nfn model(relm: &Relm<Self>, _: ()) -> Model {\n    // …\n    Model {\n        durations: HashMap::new(),\n        // …\n    }\n}\n```", "```rs\nuse std::time::Duration;\n\nfn to_millis(duration: Duration) -> u64 {\n    duration.as_secs() * 1000 + duration.subsec_nanos() as u64 / 1_000_000\n}\n```", "```rs\nfn play(&mut self) {\n    if let Some(path) = self.selected_path() {\n        if self.model.player.is_paused() && Some(&path) == self.path().as_ref() {\n            self.model.player.resume();\n        } else {\n            self.model.player.load(&path);\n            if let Some(&duration) = self.model.durations.get(&path) {\n                self.model.relm.stream().emit(SongDuration(duration));\n            }\n            self.model.current_song = Some(path.into());\n            self.model.relm.stream().emit(SongStarted(self.pixbuf()));\n        }\n    }\n}\n```", "```rs\nview! {\n    Playlist {\n        PlayerMsgRecv(ref player_msg) => MsgRecv(player_msg.clone()),\n        SongDuration(duration) => Duration(duration),\n        SongStarted(ref pixbuf) => Started(pixbuf.clone()),\n    }\n    // …\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    Duration(u64),\n    // …\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        Duration(duration) => {\n            self.model.current_duration = duration;\n            self.model.adjustment.set_upper(duration as f64);\n        },\n        // …\n    }\n}\n```", "```rs\nrelm_widget! {\n    impl Widget for App {\n        fn init_view(&mut self) {\n            self.toolbar.show_all();\n        }\n\n        fn model() -> Model {\n            Model {\n                adjustment: Adjustment::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n                cover_pixbuf: None,\n                cover_visible: false,\n                current_duration: 0,\n                current_time: 0,\n                play_image: new_icon(PLAY_ICON),\n                stopped: true,\n            }\n        }\n\n        fn open(&self) {\n            // …\n        }\n\n        // …\n\n        fn update(&mut self, event: Msg) {\n            // …\n        }\n\n        view! {\n            #[name=\"window\"]\n            gtk::Window {\n                title: \"Rusic\",\n                // …\n            }\n        }\n    }\n}\n```", "```rs\npub struct Model {\n    detailed_view: bool,\n    // …\n}\n\n    fn model() -> Model {\n        Model {\n            detailed_view: false,\n            // …\n        }\n    }\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    ViewToggle,\n    // …\n}\n```", "```rs\n#[name=\"toggle_button\"]\ngtk::ToggleToolButton {\n    label: \"Detailed view\",\n    toggled => ViewToggle,\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        ViewToggle => self.model.detailed_view = self.toggle_button.get_active(),\n        // …\n    }\n}\n```", "```rs\n#[derive(Msg)]\npub enum Msg {\n    DetailedView(bool),\n    // …\n}\n```", "```rs\nfn update(&mut self, event: Msg) {\n    match event {\n        DetailedView(detailed) => self.set_detailed_view(detailed),\n        // …\n    }\n}\n\nfn set_detailed_view(&self, detailed: bool) {\n    for column in self.treeview.get_columns().iter().skip(2) {\n        column.set_visible(detailed);\n    }\n}\n```", "```rs\nuse playlist::Msg::DetailedView;\n\nview! {\n    // …\n    #[name=\"playlist\"]\n    Playlist {\n        // …\n        DetailedView: self.model.detailed_view,\n    }\n}\n```"]