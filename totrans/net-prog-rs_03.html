<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TCP and UDP Using Rust</h1>
                
            
            <article>
                
<p class="calibre2">Being a system programming language, the Rust Standard Library has support for interacting with the network stack. All the networking-related functionality is located in the <kbd class="calibre11">std::net</kbd> namespace; reading and writing to sockets also uses <kbd class="calibre11">Read</kbd> and <kbd class="calibre11">Write</kbd> traits from <kbd class="calibre11">std::io</kbd>. Some of the most important structures here are <kbd class="calibre11">IpAddr</kbd>, which represents a generic IP address that can either be v4 or v6, <kbd class="calibre11">SocketAddr</kbd>, which represents a generic socket address (a combination of an IP and a port on a host), <kbd class="calibre11">TcpListener</kbd> and <kbd class="calibre11">TcpStream</kbd> for communicating over TCP, <kbd class="calibre11">UdpSocket</kbd> for UDP, and more. Currently, the standard library does not provide any APIs to deal with the network stack at a lower level. While this might change in the future, a number of crates fill that gap. The most important of these is <kbd class="calibre11">libpnet</kbd>, which provides a set of APIs for lower-level networking.</p>
<p class="calibre2">Some other important crates for networking are <kbd class="calibre11">net2</kbd> and <kbd class="calibre11">socket2</kbd>. These were meant to be incubators for APIs that might be moved to the standard library. Some of the functionality here is ported to Rust core repo when it is deemed to be useful and stable enough. Unfortunately, this doesn't work out as planned in all cases. On the whole, the community now suggests using the tokio ecosystem of crates for writing high-performance networking applications that do not require fine-grained control of socket semantics. Note that tokio is not in the scope of this chapter, and that we will cover it in a following chapter.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre7">
<li class="calibre8">What a simple multithreaded TCP client and server looks like in Rust</li>
<li class="calibre8">Writing a simple multithreaded UDP client and server</li>
<li class="calibre8">A number of functionalities in <kbd class="calibre11">std::net</kbd></li>
<li class="calibre8">Learning how to use <kbd class="calibre11">net2</kbd>, <kbd class="calibre11">ipnetwork</kbd>, and <kbd class="calibre11">libpnet</kbd></li>
</ul>
<p class="calibre2">For the sake of simplicity, all code in this chapter will deal with IPv4 only. Extending the given examples to IPv6 should be trivial.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A Simple TCP server and client</h1>
                
            
            <article>
                
<p class="calibre2">Most networking examples start with an echo server. So, let's go ahead and write a basic echo server in Rust to see how all the pieces fit together. We will use the threading model from the standard library for handling multiple clients in parallel. The code is as follows:</p>
<pre class="calibre17">// chapter3/tcp-echo-server.rs<br class="title-page-name"/><br class="title-page-name"/>use std::net::{TcpListener, TcpStream};<br class="title-page-name"/>use std::thread;<br class="title-page-name"/><br class="title-page-name"/>use std::io::{Read, Write, Error};<br class="title-page-name"/><br class="title-page-name"/>// Handles a single client<br class="title-page-name"/>fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Error&gt; {<br class="title-page-name"/>    println!("Incoming connection from: {}", stream.peer_addr()?);<br class="title-page-name"/>    let mut buf = [0; 512];<br class="title-page-name"/>    loop {<br class="title-page-name"/>        let bytes_read = stream.read(&amp;mut buf)?;<br class="title-page-name"/>        if bytes_read == 0 { return Ok(()); }<br class="title-page-name"/>        stream.write(&amp;buf[..bytes_read])?;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let listener = TcpListener::bind("0.0.0.0:8888")<br class="title-page-name"/>                               .expect("Could not bind");<br class="title-page-name"/>    for stream in listener.incoming() {<br class="title-page-name"/>        match stream {<br class="title-page-name"/>            Err(e) =&gt; { eprintln!("failed: {}", e) }<br class="title-page-name"/>            Ok(stream) =&gt; {<br class="title-page-name"/>                thread::spawn(move || {<br class="title-page-name"/>                    handle_client(stream)<br class="title-page-name"/>                    .unwrap_or_else(|error| eprintln!("{:?}", error));<br class="title-page-name"/>                });<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In our <kbd class="calibre11">main</kbd> function, we create a new <kbd class="calibre11">TcpListener</kbd>, which in Rust, represents a TCP socket that is listening for incoming connections from clients. For our example, we have hardcoded the local address and the port; the local address being set to <kbd class="calibre11">0.0.0.0</kbd> tells the kernel to bind this socket to all available interfaces on this host. Setting a well-known port here is important since we will need to know that to connect from the client. In a real application, this should be a configurable parameter taken from the CLI or a configuration file. We call <kbd class="calibre11">bind</kbd> on the local IP and port pair to create a local listening socket. As discussed earlier, our given choice of IP will bind this socket to all interfaces available on the host, on port 8888. As a result, any client that can reach a network connected to this host will be able to talk to this host. As we have seen in the last chapter, the <kbd class="calibre11">expect</kbd> function returns the listener if there were no errors. If that is not the case, it panics with the given message. Panicking on failing to bind to the port is actually okay here, since if that fails, there is no way the server will continue working. The <kbd class="calibre11">incoming</kbd> method on <kbd class="calibre11">listener</kbd> returns an iterator over streams that have connected to the server. We loop over them and check if any of those have encountered an error. In that case, we can print the error and move on to the next connected client. Note that panicking in this case is not appropriate since the server can function fine if some of the clients run into errors for some reason.</p>
<p class="calibre2">Now, we must read data from each of the clients in an infinite loop. But running an infinite loop in the main thread will block it and no other clients will be able to connect. That behavior is definitely not desirable. Thus, we must spawn a worker thread to handle each client connection. The logic of reading from each stream and writing it back is encapsulated in the function called <kbd class="calibre11">handle_client</kbd>. Each thread receives a closure that calls this function. This closure must be a <kbd class="calibre11">move</kbd> closure, since this must read a variable (<kbd class="calibre11">stream</kbd>) from the enclosing scope. In the function, we print the remote endpoint address and port, and then define a buffer to hold data temporarily. We also make sure that the buffer is zeroed out. We then run an infinite loop in which we read all data in the stream. The read method in the stream returns the length of the data it has read. It can return zero in two cases, if it has reached the end of the stream or if the given buffer was zero in length. We know for sure that the second case is not true. Thus, we break out of the loop (and the function) when the read method returns a zero. In that case, we return a <kbd class="calibre11">Ok()</kbd>. We then write the same data back to the stream using the slice syntax. Note that we have used <kbd class="calibre11">eprintln!</kbd> to output errors. This macro writes the given string to a standard error, and has been stabilized recently.</p>
<p class="calibre2">One might notice the apparent lack of error handling in reading from and writing to the stream. But that is not actually the case. We have used the <kbd class="calibre11">?</kbd> operator to handle errors in these invocations. This operator unwraps the result to an <kbd class="calibre11">Ok</kbd> if everything was fine; otherwise, it does an early return of the error to the calling function. Given this setup, the return type of the function must be either the empty type, to handle success cases, or the <kbd class="calibre11">io::Error</kbd> type, to handle error cases. Note that it might be a good idea to implement custom errors in such cases and return those instead of built-in errors. Also note that the <kbd class="calibre11">?</kbd> operator cannot be used in the <kbd class="calibre11">main</kbd> function currently since the <kbd class="calibre11">main</kbd> function does not return a <kbd class="calibre11">Result</kbd>.</p>
<div class="packt_infobox">Rust recently accepted an RFC which proposes the ability to use the <kbd class="calibre31">?</kbd> operator in the <kbd class="calibre31">main</kbd> function.</div>
<p class="calibre2">Interacting with the server from the terminal is easy. When we run the server on a Linux machine and <kbd class="calibre11">nc</kbd> on another terminal, any text entered to <kbd class="calibre11">nc</kbd> should be echoed back. Note that if the client and the server are running on the same node, we can use 127.0.0.1 as the server address:</p>
<pre class="calibre17"><strong class="calibre1">$ nc &lt;server ip&gt; 8888</strong><br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>foobar<br class="title-page-name"/>foobar<br class="title-page-name"/>foobarbaz<br class="title-page-name"/>foobarbaz<br class="title-page-name"/>^C</pre>
<p class="calibre2">While using <kbd class="calibre11">nc</kbd> to interact with the server is fine, it is much more fun to write a client from scratch. In this section, we will see what a simple TCP client might look like. This client will read input from <kbd class="calibre11">stdin</kbd> as a string and send it over to the server. When it gets back a reply, it will print that in <kbd class="calibre11">stdout</kbd>. In our example here, the client and the server are running on the same physical host, so we can use 127.0.0.1 as the server address:</p>
<pre class="calibre17">// chapter3/tcp-client.rs<br class="title-page-name"/><br class="title-page-name"/>use std::net::TcpStream;<br class="title-page-name"/>use std::str;<br class="title-page-name"/>use std::io::{self, BufRead, BufReader, Write};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut stream = TcpStream::connect("127.0.0.1:8888")<br class="title-page-name"/>                               .expect("Could not connect to server");<br class="title-page-name"/>    loop {<br class="title-page-name"/>        let mut input = String::new();<br class="title-page-name"/>        let mut buffer: Vec&lt;u8&gt; = Vec::new();<br class="title-page-name"/>        io::stdin().read_line(&amp;mut input)<br class="title-page-name"/>                   .expect("Failed to read from stdin");<br class="title-page-name"/>        stream.write(input.as_bytes())<br class="title-page-name"/>              .expect("Failed to write to server");<br class="title-page-name"/><br class="title-page-name"/>        let mut reader = BufReader::new(&amp;stream);<br class="title-page-name"/><br class="title-page-name"/>        reader.read_until(b'\n', &amp;mut buffer)<br class="title-page-name"/>              .expect("Could not read into buffer");<br class="title-page-name"/>        print!("{}", str::from_utf8(&amp;buffer)<br class="title-page-name"/>               .expect("Could not write buffer as string"));<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this case, we start with importing all required libraries. We then set up a connection to the server using <kbd class="calibre11">TcpStrem::connect</kbd>, which takes in the remote endpoint address as a string. Like all TCP connections, the client needs to know the remote IP and port to connect. In case setting up the connection fails, we will abort our program with an error message. We then start an infinite loop, in which we will initialize an empty string to read user input locally and a vector of <kbd class="calibre11">u8</kbd> to read responses from the server. Since a vector in Rust grows as necessary, we will not need to manually chunk the data at each iteration. The <kbd class="calibre11">read_line</kbd> function reads a line from standard input and stores it in the variable called <kbd class="calibre11">input</kbd>. Then, it is written to the connection as a stream of bytes. At this point, if everything worked as expected, the server should have sent back a response. We will read that using a <kbd class="calibre11">BufReader</kbd> that takes care of chunking the data internally. This also makes reading more efficient since there will not be more system calls than necessary. The <kbd class="calibre11">read_until</kbd> method reads the data in our buffer, which grows as needed. Finally, we can print out the buffer as a string, which has been converted using the <kbd class="calibre11">from_utf8</kbd> method.</p>
<p class="calibre2">Running the client is easy, and as expected, behaves exactly like <kbd class="calibre11">nc</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc tcp-client.rs &amp;&amp; ./tcp-client</strong><br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>foobar<br class="title-page-name"/>foobar<br class="title-page-name"/>foobarbaz<br class="title-page-name"/>foobarbaz<br class="title-page-name"/>^C</pre>
<p class="calibre2">Real-world applications are often more complex than this. A server might need some time to process the input before serving back the response. Let's simulate that by sleeping for a random amount of time in the <kbd class="calibre11">handle_client</kbd> function; the <kbd class="calibre11">main</kbd> function will remain exactly the same as the previous example. The first step is to create our project using <kbd class="calibre11">cargo</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin tcp-echo-random</strong></pre>
<p class="calibre2">Note that we will need to add the <kbd class="calibre11">rand</kbd> crate in our <kbd class="calibre11">Cargo.toml</kbd>, as shown in the following code snippet:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "tcp-echo-random"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>rand = "0.3.17"</pre>
<p class="calibre2">Having set up our dependencies, let's modify the <kbd class="calibre11">handle_client</kbd> function to sleep for a random delay before sending the response back:</p>
<pre class="calibre17">// chapter3/tcp-echo-random/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate rand;<br class="title-page-name"/><br class="title-page-name"/>use std::net::{TcpListener, TcpStream};<br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use rand::{thread_rng, Rng};<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/>use std::io::{Read, Write, Error};<br class="title-page-name"/><br class="title-page-name"/>fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Error&gt; {<br class="title-page-name"/>    let mut buf = [0; 512];<br class="title-page-name"/>    loop {<br class="title-page-name"/>        let bytes_read = stream.read(&amp;mut buf)?;<br class="title-page-name"/>        if bytes_read == 0 { return Ok(()) }<br class="title-page-name"/>        let sleep = Duration::from_secs(*thread_rng()<br class="title-page-name"/>                             .choose(&amp;[0, 1, 2, 3, 4, 5])<br class="title-page-name"/>                             .unwrap());<br class="title-page-name"/>        println!("Sleeping for {:?} before replying", sleep);<br class="title-page-name"/>        std::thread::sleep(sleep);<br class="title-page-name"/>        stream.write(&amp;buf[..bytes_read])?;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let listener = TcpListener::bind("127.0.0.1:8888").expect("Could<br class="title-page-name"/>    not bind");<br class="title-page-name"/>    for stream in listener.incoming() {<br class="title-page-name"/>        match stream {<br class="title-page-name"/>            Err(e) =&gt; eprintln!("failed: {}", e),<br class="title-page-name"/>            Ok(stream) =&gt; {<br class="title-page-name"/>                thread::spawn(move || {<br class="title-page-name"/>                    handle_client(stream).unwrap_or_else(|error|<br class="title-page-name"/>                    eprintln!("{:?}", error));<br class="title-page-name"/>                });<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In our main file, we must declare a dependency on the <kbd class="calibre11">rand</kbd> crate and declare it as an <kbd class="calibre11">extern crate</kbd>. We use the <kbd class="calibre11">thread_rng</kbd> function to select an integer between zero and five randomly and then sleep for that time duration using <kbd class="calibre11">std::thread::sleep</kbd>. On the client side, we will set read and connect timeouts, since replies won't be instantaneous from the server:</p>
<pre class="calibre17">// chapter3/tcp-client-timeout.rs<br class="title-page-name"/><br class="title-page-name"/>use std::net::TcpStream;<br class="title-page-name"/>use std::str;<br class="title-page-name"/>use std::io::{self, BufRead, BufReader, Write};<br class="title-page-name"/>use std::time::Duration;<br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let remote: SocketAddr = "127.0.0.1:8888".parse().unwrap();<br class="title-page-name"/>    let mut stream = TcpStream::connect_timeout(&amp;remote,<br class="title-page-name"/>    Duration::from_secs(1))<br class="title-page-name"/>                               .expect("Could not connect to server");<br class="title-page-name"/>    stream.set_read_timeout(Some(Duration::from_secs(3)))<br class="title-page-name"/>          .expect("Could not set a read timeout");<br class="title-page-name"/>    loop {<br class="title-page-name"/>        let mut input = String::new();<br class="title-page-name"/>        let mut buffer: Vec&lt;u8&gt; = Vec::new();<br class="title-page-name"/>        io::stdin().read_line(&amp;mut input).expect("Failed to read from<br class="title-page-name"/>        stdin");<br class="title-page-name"/>        stream.write(input.as_bytes()).expect("Failed to write to<br class="title-page-name"/>        server");<br class="title-page-name"/><br class="title-page-name"/>        let mut reader = BufReader::new(&amp;stream);<br class="title-page-name"/><br class="title-page-name"/>        reader.read_until(b'\n', &amp;mut buffer)<br class="title-page-name"/>              .expect("Could not read into buffer");<br class="title-page-name"/>        print!("{}", str::from_utf8(&amp;buffer)<br class="title-page-name"/>                    .expect("Could not write buffer as string"));<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we use <kbd class="calibre11">set_read_timeout</kbd> to set the timeout to three seconds. Thus, if the server sleeps for more than three seconds, the client will abort the connection. This function is curious since it takes in <kbd class="calibre11">Option&lt;Duration&gt;</kbd> to be able to specify a <kbd class="calibre11">Duration</kbd> that is <kbd class="calibre11">None</kbd>. Hence, we will need to wrap our <kbd class="calibre11">Duration</kbd> in a <kbd class="calibre11">Some</kbd> before passing to this function. Now, if we open two sessions, running the server using cargo in one and the client in another, here is what we'll see; the server prints how long it slept, for each client it accepts:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/tcp-echo-random`<br class="title-page-name"/>Sleeping for Duration { secs: 2, nanos: 0 } before replying<br class="title-page-name"/>Sleeping for Duration { secs: 1, nanos: 0 } before replying<br class="title-page-name"/>Sleeping for Duration { secs: 1, nanos: 0 } before replying<br class="title-page-name"/>Sleeping for Duration { secs: 5, nanos: 0 } before replying</pre>
<p class="calibre2">On the client side, we have a single file (not a cargo project) that we will build using <kbd class="calibre11">rustc</kbd> and run the executable directly after compiling:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc tcp-client-timeout.rs &amp;&amp; ./tcp-client-timeout</strong><br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>foo<br class="title-page-name"/>foo<br class="title-page-name"/>bar<br class="title-page-name"/>bar<br class="title-page-name"/>baz<br class="title-page-name"/>thread 'main' panicked at 'Could not read into buffer: Error { repr: Os { code: 35, message: "Resource temporarily unavailable" } }', src/libcore/result.rs:906:4<br class="title-page-name"/>note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<p class="calibre2">For the first three inputs, the server chose delays which were less than three seconds. The client got a response back within three seconds and did not abort the connection. For the last message, the delay was five seconds, which caused the client to abort reading.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A Simple UDP server and client</h1>
                
            
            <article>
                
<p class="calibre2">There are a few semantic differences between the UDP server and the TCP server we wrote earlier. Unlike TCP, UDP does not have a stream structure. This derives from the semantic differences between the two protocols. Let's take a look at what a UDP server might look like:</p>
<pre class="calibre17">// chapter3/udp-echo-server.rs<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use std::net::UdpSocket;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let socket = UdpSocket::bind("0.0.0.0:8888")<br class="title-page-name"/>                           .expect("Could not bind socket");<br class="title-page-name"/><br class="title-page-name"/>    loop {<br class="title-page-name"/>        let mut buf = [0u8; 1500];<br class="title-page-name"/>        let sock = socket.try_clone().expect("Failed to clone socket");<br class="title-page-name"/>        match socket.recv_from(&amp;mut buf) {<br class="title-page-name"/>            Ok((_, src)) =&gt; {<br class="title-page-name"/>                thread::spawn(move || {<br class="title-page-name"/>                    println!("Handling connection from {}", src);<br class="title-page-name"/>                    sock.send_to(&amp;buf, &amp;src)<br class="title-page-name"/>                        .expect("Failed to send a response");<br class="title-page-name"/>                });<br class="title-page-name"/>            },<br class="title-page-name"/>            Err(e) =&gt; {<br class="title-page-name"/>                eprintln!("couldn't recieve a datagram: {}", e);<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As with TCP, we start with binding to the local address on a given port and we handle the possibility that binding can fail. Since UDP is a connectionless protocol, we will not need to do a sliding window to read all the data. Thus, we can just allocate a static buffer of a given size. It will be a better idea to dynamically detect the MTU of the underlying network card and set the buffer size to be that, since that is the maximum size each UDP packet can have. However, since MTU for a common LAN is around 1,500, we can get away with allocating a buffer of that size here. The <kbd class="calibre11">try_clone</kbd> method clones the given socket and returns a new one, which is moved into the closure.</p>
<p class="calibre2">We then read from the socket, which returns the length of the data read and the source in the <kbd class="calibre11">Ok()</kbd> case. We then spawn a new thread, in which we write back the same buffer to the given socket. For anything that can fail, we will need to handle the error like we did for the TCP server.</p>
<p class="calibre2">Interacting with this server is exactly the same as last time—using <kbd class="calibre11">nc</kbd>. The only difference is that in this case, we will need to pass the <kbd class="calibre11">-u</kbd> flag to force <kbd class="calibre11">nc</kbd> to make it use only UDP. Take a look at the following example:</p>
<pre class="calibre17"><strong class="calibre1">$ nc -u 127.0.0.1 8888</strong><br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>^C</pre>
<p class="calibre2">Now, let's write a simple UDP client to achieve the same results. As we will see, there are some subtle differences between the TCP server and this:</p>
<pre class="calibre17">// chapter3/udp-client.rs<br class="title-page-name"/><br class="title-page-name"/>use std::net::UdpSocket;<br class="title-page-name"/>use std::{str,io};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let socket = UdpSocket::bind("127.0.0.1:8000")<br class="title-page-name"/>                           .expect("Could not bind client socket");<br class="title-page-name"/>    socket.connect("127.0.0.1:8888")<br class="title-page-name"/>          .expect("Could not connect to server");<br class="title-page-name"/>    loop {<br class="title-page-name"/>        let mut input = String::new();<br class="title-page-name"/>        let mut buffer = [0u8; 1500];<br class="title-page-name"/>        io::stdin().read_line(&amp;mut input)<br class="title-page-name"/>                   .expect("Failed to read from stdin");<br class="title-page-name"/>        socket.send(input.as_bytes())<br class="title-page-name"/>              .expect("Failed to write to server");<br class="title-page-name"/><br class="title-page-name"/>        socket.recv_from(&amp;mut buffer)<br class="title-page-name"/>              .expect("Could not read into buffer");<br class="title-page-name"/>        print!("{}", str::from_utf8(&amp;buffer)<br class="title-page-name"/>                         .expect("Could not write buffer as string"));<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">There is a major difference between this basic client and the TCP client we saw in the last section. In this case, it is absolutely essential to <kbd class="calibre11">bind</kbd> to a client-side socket first before connecting to the server. Once that is done, the rest of the example is essentially the same. Running it on the client side and the server side produces similar results like the TCP case. Here is a session on the server side:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc udp-echo-server.rs &amp;&amp; ./udp-echo-server</strong><br class="title-page-name"/>Handling connection from 127.0.0.1:8000<br class="title-page-name"/>Handling connection from 127.0.0.1:8000<br class="title-page-name"/>Handling connection from 127.0.0.1:8000<br class="title-page-name"/>^C</pre>
<p class="calibre2">Here is what we see on the client side:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc udp-client.rs &amp;&amp; ./udp-client</strong><br class="title-page-name"/>test<br class="title-page-name"/>test<br class="title-page-name"/>foo<br class="title-page-name"/>foo<br class="title-page-name"/>bar<br class="title-page-name"/>bar<br class="title-page-name"/>^C</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UDP multicasting</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">UdpSocket</kbd> type has a number of methods that the corresponding TCP types do not. Of these, the most interesting ones are for multicasting and broadcasting. Let's look at how multicasting works with an example server and client. For this example, we will combine the client and the server in one file. In the <kbd class="calibre11">main</kbd> function, we will check whether a CLI argument has been passed. If there has, we will run the client; otherwise, we will run the server. Note that the value of the argument will not be used; it will be treated as a Boolean:</p>
<pre class="calibre17">// chapter3/udp-multicast.rs<br class="title-page-name"/><br class="title-page-name"/>use std::{env, str};<br class="title-page-name"/>use std::net::{UdpSocket, Ipv4Addr};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mcast_group: Ipv4Addr = "239.0.0.1".parse().unwrap();<br class="title-page-name"/>    let port: u16 = 6000;<br class="title-page-name"/>    let any = "0.0.0.0".parse().unwrap();<br class="title-page-name"/>    let mut buffer = [0u8; 1600];<br class="title-page-name"/>    if env::args().count() &gt; 1 {<br class="title-page-name"/>        // client case<br class="title-page-name"/>        let socket = UdpSocket::bind((any, port))<br class="title-page-name"/>                               .expect("Could not bind client socket");<br class="title-page-name"/>        socket.join_multicast_v4(&amp;mcast_group, &amp;any)<br class="title-page-name"/>              .expect("Could not join multicast group");<br class="title-page-name"/>        socket.recv_from(&amp;mut buffer)<br class="title-page-name"/>              .expect("Failed to write to server");<br class="title-page-name"/>        print!("{}", str::from_utf8(&amp;buffer)<br class="title-page-name"/>                         .expect("Could not write buffer as string"));<br class="title-page-name"/>    } else {<br class="title-page-name"/>        // server case<br class="title-page-name"/>        let socket = UdpSocket::bind((any, 0))<br class="title-page-name"/>                               .expect("Could not bind socket");<br class="title-page-name"/>        socket.send_to("Hello world!".as_bytes(), &amp;(mcast_group, port))<br class="title-page-name"/>              .expect("Failed to write data");<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Both the client and the server parts here are mostly similar to what we discussed before. One difference is that the <kbd class="calibre11">join_multicast_v4</kbd> call makes the current socket join a multicast group with the address passed. For both the server and the client, we do not specify a single address while binding. Instead, we use the special address <kbd class="calibre11">0.0.0.0</kbd> that denotes any available address. This is equivalent to passing <kbd class="calibre11">INADDR_ANY</kbd> to the underlying <kbd class="calibre11">setsockopt</kbd> call. In the server case, we send it to the multicast group instead. Running this is a bit more tricky. Since there is no way to set <kbd class="calibre11">SO_REUSEADDR</kbd> and <kbd class="calibre11">SO_REUSEPORT</kbd> in the standard library, we will need to run the client on multiple different machines and the server on another. For this to work, all of those need to be in the same network and the address of the multicast group needs to be a valid multicast address (the first four bits should be 1110). The <kbd class="calibre11">UdpSocket</kbd> type also supports leaving multicast groups, broadcasting, and so on. Note that broadcasting does not make sense for TCP since it is a connection between two hosts by definition.</p>
<p class="calibre2">Running the previous example is simple; on one host, we will run the server, and on the other, the client. Given this setup, the output should look like this on the server side:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc udp-multicast.rs &amp;&amp; ./udp-multicast server</strong><br class="title-page-name"/>Hello world!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Miscellaneous utilities in std::net</h1>
                
            
            <article>
                
<p class="calibre2">Another important type in the standard library is <kbd class="calibre11">IpAddr</kbd>, which represents an IP address. Not surprisingly, it is an enum with two variants, one for v4 addresses and the other for v6 addresses. All of these types have methods to classify addresses according to their types (global, loopback, multicast, and so on). Note that a number of these methods are not stabilized yet and hence are only available in the nightly compiler. They are behind a feature flag named <kbd class="calibre11">ip</kbd> which must be included in the crate root so that you can use those methods. A closely related type is <kbd class="calibre11">SocketAddr</kbd>, which is a combination of an IP address and a port number. Thus, this also has two variants, one for v4 and one for v6. Let's look at some examples:</p>
<pre class="calibre17">// chapter3/ip-socket-addr.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(ip)]<br class="title-page-name"/><br class="title-page-name"/>use std::net::{IpAddr, SocketAddr};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // construct an IpAddr from a string and check it<br class="title-page-name"/>    // represents the loopback address<br class="title-page-name"/>    let local: IpAddr = "127.0.0.1".parse().unwrap();<br class="title-page-name"/>    assert!(local.is_loopback());<br class="title-page-name"/><br class="title-page-name"/>    // construct a globally routable IPv6 address from individual<br class="title-page-name"/>    octets<br class="title-page-name"/>    // and assert it is classified correctly<br class="title-page-name"/>    let global: IpAddr = IpAddr::from([0, 0, 0x1c9, 0, 0, 0xafc8, 0,<br class="title-page-name"/>    0x1]);<br class="title-page-name"/>    assert!(global.is_global());<br class="title-page-name"/><br class="title-page-name"/>    // construct a SocketAddr from a string an assert that the<br class="title-page-name"/>    underlying<br class="title-page-name"/>    // IP is a IPv4 address<br class="title-page-name"/>    let local_sa: SocketAddr = "127.0.0.1:80".parse().unwrap();<br class="title-page-name"/>    assert!(local_sa.is_ipv4());<br class="title-page-name"/><br class="title-page-name"/>    // construct a SocketAddr from a IPv6 address and a port, assert<br class="title-page-name"/>    that<br class="title-page-name"/>    // the underlying address is indeed IPv6<br class="title-page-name"/>    let global_sa = SocketAddr::new(global, 80u16);<br class="title-page-name"/>    assert!(global_sa.is_ipv6());<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre11">feature(ip)</kbd> declaration is necessary since the <kbd class="calibre11">is_global</kbd> function is not stabilized yet. This example does not produce any output since all asserts should evaluate to true.</p>
<p class="calibre2">A common functionality is that of a DNS lookup, given a hostname. Rust does this using the <kbd class="calibre11">lookup_host</kbd> function that returns the <kbd class="calibre11">LookupHost</kbd> type, which is actually an iterator over DNS responses. Let's look at how this can be used. This function is gated by the <kbd class="calibre11">looup_host</kbd> flag and must be included to use this function with the nightly compiler:</p>
<pre class="calibre17">// chapter3/lookup-host.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(lookup_host)]<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/>use std::net::lookup_host;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let args: Vec&lt;_&gt; = env::args().collect();<br class="title-page-name"/>    if args.len() != 2 {<br class="title-page-name"/>        eprintln!("Please provide only one host name");<br class="title-page-name"/>        std::process::exit(1);<br class="title-page-name"/>    } else {<br class="title-page-name"/>        let addresses = lookup_host(&amp;args[1]).unwrap();<br class="title-page-name"/>        for address in addresses {<br class="title-page-name"/>            println!("{}", address.ip());<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we read a CLI argument and exit if we were not given exactly one name to resolve. Otherwise, we call <kbd class="calibre11">lookup_host</kbd> with the given hostname. We iterate over the returned results and print the IP of each. Note that each of the returned results is of type <kbd class="calibre11">SocketAddr</kbd>; since we are only interested in the IP, we extract that using the <kbd class="calibre11">ip()</kbd> method. This function corresponds to the <kbd class="calibre11">getaddrinfo</kbd> call in libc, and thus it returns only <kbd class="calibre11">A</kbd> and <kbd class="calibre11">AAAA</kbd> record types. Running this is as expected:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc lookup-host.rs &amp;&amp; ./lookup-host google.com</strong><br class="title-page-name"/>2a00:1450:4009:810::200e<br class="title-page-name"/>216.58.206.110</pre>
<p class="calibre2">Currently, reverse DNS lookup is not possible in the standard library. In the next section, we will discuss some crates in the ecosystem that can be used for the advanced networking functionality. For instance, the <kbd class="calibre11">trust-dns</kbd> crate supports interacting with DNS servers in more detail, and it also supports querying all record types and also reverse DNS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Some related crates</h1>
                
            
            <article>
                
<p class="calibre2">A careful reader might have noticed that a lot of common networking-related functionalities are missing from the standard library. For instance, there is no way to deal with IP networks (CIDRs). Let's look at how the <kbd class="calibre11">ipnetwork</kbd> crate helps with that. Since we are going to use an external crate, the example has to be in a cargo project. We will need to add it as a dependency to <kbd class="calibre11">Cargo.toml</kbd>. Let's start by setting up a project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin ipnetwork-example</strong></pre>
<p class="calibre2">This generates a <kbd class="calibre11">Cargo.toml</kbd> file that we need to modify to declare our dependency. Once we do that, it should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "ipnetwork-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>ipnetwork = "0.12.7"</pre>
<p class="calibre2">Having set up the project, let's look at our <kbd class="calibre11">main</kbd> function:</p>
<pre class="calibre17">// chapter3/ipnetwork-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate ipnetwork;<br class="title-page-name"/><br class="title-page-name"/>use std::net::Ipv4Addr;<br class="title-page-name"/>use ipnetwork::{IpNetwork, Ipv4Network, Ipv6Network};<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let net = IpNetwork::new("192.168.122.0".parse().unwrap(), 22)<br class="title-page-name"/>                        .expect("Could not construct a network");<br class="title-page-name"/>    let str_net: IpNetwork = "192.168.122.0/22".parse().unwrap();<br class="title-page-name"/><br class="title-page-name"/>    assert!(net == str_net);<br class="title-page-name"/>    assert!(net.is_ipv4());<br class="title-page-name"/><br class="title-page-name"/>    let net4: Ipv4Network = "192.168.121.0/22".parse().unwrap();<br class="title-page-name"/>    assert!(net4.size() == 2u64.pow(32 - 22));<br class="title-page-name"/>    assert!(net4.contains(Ipv4Addr::new(192, 168, 121, 3)));<br class="title-page-name"/><br class="title-page-name"/>    let _net6: Ipv6Network = "2001:db8::0/96".parse().unwrap();<br class="title-page-name"/>    for addr in net4.iter().take(10) {<br class="title-page-name"/>        println!("{}", addr);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The first two lines show two different ways of constructing <kbd class="calibre11">IpNetwork</kbd> instances, either using the constructor or by parsing a string. The next <kbd class="calibre11">assert</kbd> makes sure they are indeed identical. The <kbd class="calibre11">assert</kbd> after that ensures that the network we created is a v4 network. Next, we specifically create <kbd class="calibre11">Ipv4Network</kbd> objects and as expected, the size of the network matches <em class="calibre16">2^(32 - prefix)</em>. The next <kbd class="calibre11">assert</kbd> makes sure the <kbd class="calibre11">contains</kbd> method works correctly for an IP in that network. We then create a <kbd class="calibre11">Ipv6Network</kbd>, and since all of these types implement the iterator protocol, we can iterate over the network and print individual addresses in a <kbd class="calibre11">for</kbd> loop. Here is the output that we should see by running the last example:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling ipnetwork v0.12.7<br class="title-page-name"/>   Compiling ipnetwork-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter3/ipnetwork-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.18 secs<br class="title-page-name"/>     Running `target/debug/ipnetwork-example`<br class="title-page-name"/>192.168.120.0<br class="title-page-name"/>192.168.120.1<br class="title-page-name"/>192.168.120.2<br class="title-page-name"/>192.168.120.3<br class="title-page-name"/>192.168.120.4<br class="title-page-name"/>192.168.120.5<br class="title-page-name"/>192.168.120.6<br class="title-page-name"/>192.168.120.7<br class="title-page-name"/>192.168.120.8<br class="title-page-name"/>192.168.120.9</pre>
<p class="calibre2">The standard library also lacks fine-grained control over sockets and connections, one example being the ability to set <kbd class="calibre11">SO_REUSEADDR</kbd>, as we described before. The primary reason for this is that the community has not been able to reach a strong consensus on how to best expose these features while maintaining a clean API. A useful library in this context is <kbd class="calibre11">mio</kbd>, which provides an alternative to thread-based concurrency. <kbd class="calibre11">mio</kbd> essentially runs an event loop where all parties register. When there is an event, every listener is alerted and they have the option to handle that event. Let's look at the following example. Like last time, we will need to set up the project using cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin mio-example</strong></pre>
<p class="calibre2">The next step is to add <kbd class="calibre11">mio</kbd> as a dependency; the <kbd class="calibre11">Cargo.toml</kbd> file should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "mio-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>mio = "0.6.11"</pre>
<p class="calibre2">Like all other cargo projects, we will need to declare <kbd class="calibre11">mio</kbd> as a dependency in <kbd class="calibre11">Cargo.toml</kbd> and pin it to a specific version so that cargo can download it and link it against our app:</p>
<pre class="calibre17">// chapter3/mio-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate mio;<br class="title-page-name"/><br class="title-page-name"/>use mio::*;<br class="title-page-name"/>use mio::tcp::TcpListener;<br class="title-page-name"/><br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/>use std::env;<br class="title-page-name"/><br class="title-page-name"/>// This will be later used to identify the server on the event loop<br class="title-page-name"/>const SERVER: Token = Token(0);<br class="title-page-name"/><br class="title-page-name"/>// Represents a simple TCP server using mio<br class="title-page-name"/>struct TCPServer {<br class="title-page-name"/>    address: SocketAddr,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Implementation for the TCP server<br class="title-page-name"/>impl TCPServer {<br class="title-page-name"/>    fn new(port: u32) -&gt; Self {<br class="title-page-name"/>        let address = format!("0.0.0.0:{}", port)<br class="title-page-name"/>            .parse::&lt;SocketAddr&gt;().unwrap();<br class="title-page-name"/><br class="title-page-name"/>        TCPServer {<br class="title-page-name"/>            address,<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // Actually binds the server to a given address and runs it<br class="title-page-name"/>    // This function also sets up the event loop that dispatches<br class="title-page-name"/>    // events. Later, we use a match on the token on the event<br class="title-page-name"/>    // to determine if the event is for the server.<br class="title-page-name"/>    fn run(&amp;mut self) {<br class="title-page-name"/>        let server = TcpListener::bind(&amp;self.address)<br class="title-page-name"/>            .expect("Could not bind to port");<br class="title-page-name"/>        let poll = Poll::new().unwrap();<br class="title-page-name"/>        poll.register(&amp;server, <br class="title-page-name"/>                       SERVER,<br class="title-page-name"/>                       Ready::readable(),<br class="title-page-name"/>                       PollOpt::edge()).unwrap();<br class="title-page-name"/><br class="title-page-name"/>        let mut events = Events::with_capacity(1024);<br class="title-page-name"/>        loop {<br class="title-page-name"/>            poll.poll(&amp;mut events, None).unwrap();<br class="title-page-name"/><br class="title-page-name"/>            for event in events.iter() {<br class="title-page-name"/>                match event.token() {<br class="title-page-name"/>                    SERVER =&gt; {<br class="title-page-name"/>                        let (_stream, remote) =<br class="title-page-name"/>                        server.accept().unwrap();<br class="title-page-name"/>                        println!("Connection from {}", remote);<br class="title-page-name"/>                    }<br class="title-page-name"/>                    _ =&gt; {<br class="title-page-name"/>                        unreachable!();<br class="title-page-name"/>                    }<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let args: Vec&lt;String&gt; = env::args().collect();<br class="title-page-name"/>    if args.len() != 2 {<br class="title-page-name"/>        eprintln!("Please provide only one port number as argument");<br class="title-page-name"/>        std::process::exit(1);<br class="title-page-name"/>    }<br class="title-page-name"/>    let mut server = TCPServer::new(args[1].parse::&lt;u32&gt;()<br class="title-page-name"/>                               .expect("Could not parse as u32"));<br class="title-page-name"/>    server.run();<br class="title-page-name"/>}</pre>
<p class="calibre2">Unlike our previous examples, this is a TCP server that just prints the client's source IP and port. In <kbd class="calibre11">mio</kbd>, every listener on the event loop is assigned a token, which can then be used to differentiate between the listeners when an event is delivered. We define a struct for our server (<kbd class="calibre11">TCPServer</kbd>) in its constructor, and we <kbd class="calibre11">bind</kbd> to all local addresses and return an instance of the struct. The <kbd class="calibre11">run</kbd> method of that struct binds the socket to the given socket address; it then uses the <kbd class="calibre11">Poll</kbd> struct to instantiate the event loop.</p>
<p class="calibre2">It then registers the server socket, with a token on the instance. We also indicate that we should be alerted when the event is ready for reading or writing. Lastly, we indicate that we want edge-triggered events only, which means that the event should be wholly consumed when it is received, otherwise subsequent calls on the same token might block it. We then set up an empty container for our events. Having done all the boilerplate, we enter an infinite loop and start polling with the events container we just created. We loop over the list of events, and if any of the event's tokens match the server's token, we know it is meant for the server. We can then accept the connection and print the remote end's information. We then go back to the next event, and so on. In our <kbd class="calibre11">main</kbd> function, we first deal with CLI arguments, making sure that we passed a port number as an integer. Then, we instantiate the server and call the run method on it.</p>
<p class="calibre2">Here is a sample session on running the server when two clients are connected to it. Note that either <kbd class="calibre11">nc</kbd> or the TCP clients from earlier can be used to connect to this server:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run 4321</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/mio-example 4321`<br class="title-page-name"/>Connection from 127.0.0.1:60955<br class="title-page-name"/>Connection from 127.0.0.1:60956<br class="title-page-name"/>^C</pre>
<p class="calibre2">Some other major things that are missing from the standard library and the crates discussed here is the ability to work with the physical network device, a nicer API to craft and parse packets, and so on. One crate that helps in dealing with lower level network-related things in <kbd class="calibre11">libpnet</kbd>. Let's write a small packet dumper using it:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "pnet-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo Bar &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>pnet = "0.20.0"</pre>
<p class="calibre2">We initialize our Cargo project like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin pnet-example</strong></pre>
<p class="calibre2">We then add <kbd class="calibre11">pnet</kbd> as a dependency, pinning it to a specific version (the latest one currently available). We can then move on to our source, which should look like this:</p>
<pre class="calibre17">// chapter3/pnet-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate pnet;<br class="title-page-name"/><br class="title-page-name"/>use pnet::datalink::{self, NetworkInterface};<br class="title-page-name"/>use pnet::datalink::Channel::Ethernet;<br class="title-page-name"/>use pnet::packet::ethernet::{EtherTypes, EthernetPacket};<br class="title-page-name"/>use pnet::packet::ipv4::Ipv4Packet;<br class="title-page-name"/>use pnet::packet::tcp::TcpPacket;<br class="title-page-name"/>use pnet::packet::ip::IpNextHeaderProtocols;<br class="title-page-name"/>use pnet::packet::Packet;<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/><br class="title-page-name"/>// Handles a single ethernet packet<br class="title-page-name"/>fn handle_packet(ethernet: &amp;EthernetPacket) {<br class="title-page-name"/>    match ethernet.get_ethertype() {<br class="title-page-name"/>        EtherTypes::Ipv4 =&gt; {<br class="title-page-name"/>            let header = Ipv4Packet::new(ethernet.payload());<br class="title-page-name"/>            if let Some(header) = header {<br class="title-page-name"/>                match header.get_next_level_protocol() {<br class="title-page-name"/>                    IpNextHeaderProtocols::Tcp =&gt; {<br class="title-page-name"/>                        let tcp = TcpPacket::new(header.payload());<br class="title-page-name"/>                        if let Some(tcp) = tcp {<br class="title-page-name"/>                            println!(<br class="title-page-name"/>                                "Got a TCP packet {}:{} to {}:{}",<br class="title-page-name"/>                                header.get_source(),<br class="title-page-name"/>                                tcp.get_source(),<br class="title-page-name"/>                                header.get_destination(),<br class="title-page-name"/>                                tcp.get_destination()<br class="title-page-name"/>                            );<br class="title-page-name"/>                        }<br class="title-page-name"/>                    }<br class="title-page-name"/>                    _ =&gt; println!("Ignoring non TCP packet"),<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        _ =&gt; println!("Ignoring non IPv4 packet"),<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let interface_name = env::args().nth(1).unwrap();<br class="title-page-name"/><br class="title-page-name"/>    // Get all interfaces<br class="title-page-name"/>    let interfaces = datalink::interfaces();<br class="title-page-name"/>    // Filter the list to find the given interface name<br class="title-page-name"/>    let interface = interfaces<br class="title-page-name"/>        .into_iter()<br class="title-page-name"/>        .filter(|iface: &amp;NetworkInterface| iface.name == interface_name)<br class="title-page-name"/>        .next()<br class="title-page-name"/>        .expect("Error getting interface");<br class="title-page-name"/><br class="title-page-name"/>    let (_tx, mut rx) = match datalink::channel(&amp;interface, Default::default()) {<br class="title-page-name"/>        Ok(Ethernet(tx, rx)) =&gt; (tx, rx),<br class="title-page-name"/>        Ok(_) =&gt; panic!("Unhandled channel type"),<br class="title-page-name"/>        Err(e) =&gt; {<br class="title-page-name"/>            panic!(<br class="title-page-name"/>                "An error occurred when creating the datalink channel:<br class="title-page-name"/>                {}",e<br class="title-page-name"/>            )<br class="title-page-name"/>        }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    // Loop over packets arriving on the given interface<br class="title-page-name"/>    loop {<br class="title-page-name"/>        match rx.next() {<br class="title-page-name"/>            Ok(packet) =&gt; {<br class="title-page-name"/>                let packet = EthernetPacket::new(packet).unwrap();<br class="title-page-name"/>                handle_packet(&amp;packet);<br class="title-page-name"/>            }<br class="title-page-name"/>            Err(e) =&gt; {<br class="title-page-name"/>            panic!("An error occurred while reading: {}", e);<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Like always, we start with declaring <kbd class="calibre11">pnet</kbd> as an external crate. We then import a bunch of things that we will use later. We take in the name of the interface we should sniff as a CLI argument. The <kbd class="calibre11">datalink::interfaces()</kbd> gets us a list of all available interfaces in the current host, and we filter that list by the name of the interface we were given. In case we do not find a match, we throw an error and exit. The <kbd class="calibre11">datalink::channel()</kbd> call gives us a channel to send and receive packets. In this case, we do not care about the sending end since we are just interested in sniffing packets. We match on the returned channel type to make sure we work with Ethernet only. The receiving end of the channel, <kbd class="calibre11">rx</kbd>, gives us an iterator that yields packets on each <kbd class="calibre11">next()</kbd> call.</p>
<p class="calibre2">The packets are then passed to the <kbd class="calibre11">handle_packet</kbd> function, which extracts relevant information and prints those. For this toy example, we will only deal with IPv4-based TCP packets. A real network will obviously get IPv6 and ICMP packets with UDP and TCP. All those combinations will be ignored here.</p>
<p class="calibre2">In the <kbd class="calibre11">handle_packet</kbd> function, we match on the ethertype of the packet to make sure we only process IPv4 packets. Since the whole payload of the Ethernet packet is the IP packet (refer to <a href="part0020.html#J2B80-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 1</a>, <em class="calibre16">Introduction to Client/Server Networking</em>), we construct an IP packet from the payload. The <kbd class="calibre11">get_next_level_protocol()</kbd> call returns the transport protocol, and if that matches TCP, we construct a TCP packet from the payload of the preceding layer. At this point, we can print the source and destination port from the TCP packet. The source and destination IP will be in the enclosing IP packet. An example run is shown in the following code block. We need to pass the name of the interface to listen on to our program as command line arguments. Here is how we can get the interface name in Linux:</p>
<pre class="calibre17"><strong class="calibre1">$ ip a</strong><br class="title-page-name"/>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br class="title-page-name"/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br class="title-page-name"/>    inet 127.0.0.1/8 scope host lo<br class="title-page-name"/>       valid_lft forever preferred_lft forever<br class="title-page-name"/>    inet6 ::1/128 scope host <br class="title-page-name"/>       valid_lft forever preferred_lft forever<br class="title-page-name"/>2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br class="title-page-name"/>    link/ether f4:4d:30:ac:88:ee brd ff:ff:ff:ff:ff:ff<br class="title-page-name"/>    inet 192.168.5.15/22 brd 192.168.7.255 scope global enp1s0<br class="title-page-name"/>       valid_lft forever preferred_lft forever<br class="title-page-name"/>    inet6 fe80::58c6:9ccc:e78c:caa6/64 scope link <br class="title-page-name"/>       valid_lft forever preferred_lft forever</pre>
<p class="calibre2">For this example, we will ignore the loopback interface <kbd class="calibre11">l0</kbd> since it does not receive a lot of traffic, and use the other interface <kbd class="calibre11">enp1s0</kbd>. We will also run this example with root privileges (using sudo) since it need to access the network device directly. </p>
<p class="calibre2">The first step is to build the project using cargo and the run the executable. Note that the exact output of this example might be a bit different, depending on what packets arrive:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo build</strong><br class="title-page-name"/><strong class="calibre1">$ sudo ./target/debug/pnet-example enp1s0</strong><br class="title-page-name"/>Got a TCP packet 192.168.0.2:53041 to 104.82.249.116:443<br class="title-page-name"/>Got a TCP packet 104.82.249.116:443 to 192.168.0.2:53041<br class="title-page-name"/>Got a TCP packet 192.168.0.2:53064 to 17.142.169.200:443<br class="title-page-name"/>Got a TCP packet 192.168.0.2:53064 to 17.142.169.200:443<br class="title-page-name"/>Got a TCP packet 17.142.169.200:443 to 192.168.0.2:53064<br class="title-page-name"/>Got a TCP packet 17.142.169.200:443 to 192.168.0.2:53064<br class="title-page-name"/>Got a TCP packet 192.168.0.2:53064 to 17.142.169.200:443<br class="title-page-name"/>Got a TCP packet 192.168.0.2:52086 to 52.174.153.60:443<br class="title-page-name"/>Ignoring non IPv4 packet<br class="title-page-name"/>Got a TCP packet 52.174.153.60:443 to 192.168.0.2:52086<br class="title-page-name"/>Got a TCP packet 192.168.0.2:52086 to 52.174.153.60:443<br class="title-page-name"/>Ignoring non IPv4 packet<br class="title-page-name"/>Ignoring non IPv4 packet<br class="title-page-name"/>Ignoring non IPv4 packet<br class="title-page-name"/>Ignoring non IPv4 packet</pre>
<p class="calibre2">In the previous section, we saw how the DNS-related functionality in the standard library is rather limited. One crate that is widely popular for DNS-related things in <kbd class="calibre11">trust-dns</kbd>. Let's look at an example of using this for querying a given name. Let's start with the empty project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin trust-dns-example</strong></pre>
<p class="calibre2">We will then add the versions of required crates in <kbd class="calibre11">Cargo.toml</kbd> first:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "trust-dns-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>trust-dns-resolver = "0.6.0"<br class="title-page-name"/>trust-dns = "0.12.0"</pre>
<p class="calibre2">Our app depends on <kbd class="calibre11">trust-dns</kbd> for DNS-related things. As usual, we will add it to our <kbd class="calibre11">Cargo.toml</kbd> before using it in our app:</p>
<pre class="calibre17">// chapter3/trust-dns-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate trust_dns_resolver;<br class="title-page-name"/>extern crate trust_dns;<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/><br class="title-page-name"/>use trust_dns_resolver::Resolver;<br class="title-page-name"/>use trust_dns_resolver::config::*;<br class="title-page-name"/><br class="title-page-name"/>use trust_dns::rr::record_type::RecordType;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let args: Vec&lt;String&gt; = env::args().collect();<br class="title-page-name"/>    if args.len() != 2 {<br class="title-page-name"/>        eprintln!("Please provide a name to query");<br class="title-page-name"/>        std::process::exit(1);<br class="title-page-name"/>    }<br class="title-page-name"/>    let resolver = Resolver::new(ResolverConfig::default(),<br class="title-page-name"/>                                 ResolverOpts::default()).unwrap();<br class="title-page-name"/><br class="title-page-name"/>    // Add a dot to the given name<br class="title-page-name"/>    let query = format!("{}.", args[1]);<br class="title-page-name"/><br class="title-page-name"/>    // Run the DNS query<br class="title-page-name"/>    let response = resolver.lookup_ip(query.as_str());<br class="title-page-name"/>    println!("Using the synchronous resolver");<br class="title-page-name"/>    for ans in response.iter() {<br class="title-page-name"/>        println!("{:?}", ans);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println!("Using the system resolver");<br class="title-page-name"/>    let system_resolver = Resolver::from_system_conf().unwrap();<br class="title-page-name"/>    let system_response = system_resolver.lookup_ip(query.as_str());<br class="title-page-name"/>    for ans in system_response.iter() {<br class="title-page-name"/>        println!("{:?}", ans);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    let ns = resolver.lookup(query.as_str(), RecordType::NS);<br class="title-page-name"/>    println!("NS records using the synchronous resolver");<br class="title-page-name"/>    for ans in ns.iter() {<br class="title-page-name"/>        println!("{:?}", ans);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We set up all required imports and <kbd class="calibre11">extern</kbd> crate declarations. Here, we expect to get the name to resolve as a CLI argument, and if everything goes well, it should be in <kbd class="calibre11">args[1]</kbd>. This crate supports two types of synchronous DNS resolver. <kbd class="calibre11">Resolver::new</kbd> creates a synchronous resolver, and with default options, it will use Google's public DNS as upstream servers. The <kbd class="calibre11">Resolver::from_system_conf</kbd> creates a synchronous resolver with configurations from the system's <kbd class="calibre11">resolv.conf</kbd>. Thus, this second option is only available on Unix systems. Before we pass the query to the <kbd class="calibre11">resolver</kbd>, we format it to FQDN by appending a <kbd class="calibre11">.</kbd> to the name, using the <kbd class="calibre11">format!</kbd> macro. We pass the query using the <kbd class="calibre11">lookup_ip</kbd> function, which then returns an iterator over the answers of the DNS question. Once we get that, we can iterate over it and print out each answer. As the name suggests, the <kbd class="calibre11">lookup_ip</kbd> function only looks up <kbd class="calibre11">A</kbd> and <kbd class="calibre11">AAAA</kbd> records. There is a more general <kbd class="calibre11">lookup</kbd> function that can take in a record type to query. In the last step, we want to get all <kbd class="calibre11">NS</kbd> records for the given name. Once we get back an answer, we loop over it and print the results.</p>
<div class="packt_tip"><kbd class="calibre31">trust-dns</kbd> also supports a tokio-based asynchronous DNS resolver.</div>
<p class="calibre2">An example session will look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run google.com</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/trust-dns-example google.com`<br class="title-page-name"/>Using the synchronous resolver<br class="title-page-name"/>LookupIp(Lookup { rdatas: [AAAA(2a00:1450:4009:811::200e), A(216.58.206.142)] })<br class="title-page-name"/>Using the system resolver<br class="title-page-name"/>LookupIp(Lookup { rdatas: [A(216.58.206.110), AAAA(2a00:1450:4009:810::200e)] })<br class="title-page-name"/>NS records using the synchronous resolver<br class="title-page-name"/>Lookup { rdatas: [NS(Name { is_fqdn: true, labels: ["ns3", "google", "com"] }), NS(Name { is_fqdn: true, labels: ["ns1", "google", "com"] }), NS(Name { is_fqdn: true, labels: ["ns4", "google", "com"] }), NS(Name { is_fqdn: true, labels: ["ns2", "google", "com"] })] }</pre>
<p class="calibre2">In this example, all prints are using the debug representation of the structures. A real application will want to format these as required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was a short introduction to the basic networking functionality in Rust. We started with given functionality in <kbd class="calibre11">std::net</kbd>, and we wrote a few TCP and UDP servers using those. We then looked at some other utilities in the same namespace. At the end, we went over examples of a number of crates which are aimed at extending the standard library's functionality around networking. Bear in mind that it is always possible to just use the libc crate to write networking code, which is based on POSIX-compatible networking code with access to fine-grained control over sockets and network devices. The problem with this approach is that the code might be unsafe, breaking Rust's guarantee of safety. Another crate called nix aims to provide libc's functionality <span>native Rust so that it preserves all the memory and type safety guarantees that the compiler provides: </span>this might be a useful alternative for someone who needs very fine control over networking.</p>
<p class="calibre2">In the next chapter, we will look at how to handle data once we receive it in a server or a client using a number of serialization/de-serialization methods in the Rust ecosystem.</p>


            </article>

            
        </section>
    </body></html>