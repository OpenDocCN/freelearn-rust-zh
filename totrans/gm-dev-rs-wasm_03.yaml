- en: '*Chapter 2*: Drawing Sprites'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got a working app and we're drawing to the screen, we can start
    making something that actually looks like a game. That means **rendering sprites**,
    which is just a fancy way of saying drawing pictures. So, in this chapter, we'll
    start by defining what those pictures are by doing a little bit of game design,
    and then we'll render a static sprite to the screen. Since a static picture is
    a pretty boring game, we'll even get the sprite animating too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design our game, Walk the Dog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render a sprite to the Canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a sprite sheet to load many sprites at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate a character via the sprite sheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be drawing characters instead of static triangles,
    and you'll even have them running on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the technical requirements of [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*, you'll need to download the assets found at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    We'll build on top of the results of that chapter as well, so don't throw away
    the code. If you're reading this book out of order because you can't be tamed
    by society's rules, then you can get the previous chapter's source code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_1)
    and start there. If you get stumped, you can find the complete source code for
    this chapter at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3wOpCqy](https://bit.ly/3wOpCqy)'
  prefs: []
  type: TYPE_NORMAL
- en: A quick game design session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, I had you create a project called "Walk the Dog", and
    you were so engrossed by the process of creating a Rust project and my thrilling
    prose that you didn't even ask why that was the name of the project. Now we'll
    dig into the game we're making for this book – **Walk the Dog**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Walk the Dog* is an endless runner with a simple concept. You play as a boy
    walking his dog through the forest when your dog is surprised by a cat that runs
    by and starts chasing it. You, in turn, begin chasing your dog through the forest,
    dodging obstacles along the way, until you crash into one and fall down. At which
    point, of course, the dog turns around and checks on you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you hadn''t guessed, the idea for this game came to me while walking
    the dog on ice. I''ve used *Miro* ([https://miro.com](https://miro.com)) to make
    a prototype, just to get a feel for what the game will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A Walk the Dog screen, hypothetically](img/Figure_2.01_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A Walk the Dog screen, hypothetically
  prefs: []
  type: TYPE_NORMAL
- en: Before you get the idea that I'm a great artist, all of the assets I'm using
    are freely available online via creative commons licenses. You might notice that
    the background is a little fuzzy relative to the characters, and that's because
    I made almost no effort to scale the characters to fit beyond copying and pasting
    them into Miro and dragging the corners around. When we place the actual objects
    in our game, we'll need to make a better effort than that.
  prefs: []
  type: TYPE_NORMAL
- en: The temptation at this point is to say, "we're done" and start coding. Given
    the small size of our game, I don't think we need a full treatment to start coding,
    but I do want to make sure that we clarify a few things about the game.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring is done by measuring how far our little **Red Hat Boy** (**RHB** for
    short) runs – the same as most endless runners such as *Canabalt* ([http://canabalt.com/](http://canabalt.com/))
    or the *Dinosaur T-Rex* game that shows up when you start Google Chrome without
    an internet connection. The dog and cat navigate all obstacles effortlessly and
    are just there to give the player ideas on how to catch the dog, and perhaps mislead
    the player by taking a path they cannot follow. Obstacles will include rocks and
    boxes that you can crash into and water that you can fall into. RHB has a slide
    animation, so sometimes he'll need to slide under little cliffs too, which the
    dog runs under effortlessly. It's not enough for a fully fledged game, but it's
    enough to give us a checklist of features for future chapters. Let's say goodbye
    to our lovely triangles and begin rendering our adorable Red Hat Boy.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite is a term so commonplace that it's possible to use it in conversation
    without actually knowing its meaning, yet properly defining it means properly
    defining bitmap, which in turn means properly defining pixmap. Did you know the
    term sprite was coined in the 1970s by Danny Hillis ([http://bit.ly/3aZlJ72](http://bit.ly/3aZlJ72))?
    It's exhausting.
  prefs: []
  type: TYPE_NORMAL
- en: While I find all of this fascinating, you didn't get this book for that, so
    for our purposes, a sprite is a 2D image loaded from a file. Red Hat Boy, his
    dog and cat, and the background will all be sprites. Let's not waste any more
    time on definitions and start drawing one.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by unzipping the assets and copying the `Idle (1).png` file from
    `resized/rhb` into the `static` directory in your project. This will make it reachable
    from your program. As we build the program out, we''ll need further organization,
    but for one file, this is fine. Next, we''ll need to modify our code. You can
    leave the Sierpiński triangle in there for now as it looks cute next to the sprite,
    but the first thing to do is use the `HTMLImage` element to load an image. For
    now, it''s important that you load and draw the image **before** calling into
    the Sierpiński triangle. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will once again get the `` ^^^^^^^^^^^^^^^^ could not find `HtmlImageElement`
    in `web_sys` `` error. Remember that the `web-sys` crate makes heavy use of feature
    flags, so you'll need to add `HtmlImageElement` to the feature flag list in `Cargo.toml`.
    After you add that, rebuilding will take a little longer, but the application
    will build again. Now you have loaded the image, and we can draw it.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we draw it, we need to cover one thing about the `line_to` and `move_to`
    commands that may not have made sense at the time, which is why we need to discuss
    the coordinate system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)](img/Figure_2.02_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2 – Source: Mozilla (http://mzl.la/30NLhxX)'
  prefs: []
  type: TYPE_NORMAL
- en: Our canvas is divided into a 2D grid with dimensions of 600 by 600\. Why 600
    x 600? Because that's the height and width of our canvas element on the HTML page
    that we created in [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015),
    *Hello WebAssembly*. The size itself was completely arbitrary, and we'll probably
    change it as our game grows. The units of the grid are pixels, so when we moved
    the top of our original triangle to `(300.0, 0.0)`, we moved it 300 pixels to
    the right (because `(0.0, 0.0)` is in the top-left corner of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing one image at this point seems uncomplicated – we'll use the `drawImage`
    command from JavaScript; only we'll use the `web-sys` version for `HtmlElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that JavaScript functions frequently use function overloading, which
    Rust doesn't support, so one JavaScript function may have many corresponding variations
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the draw command right after the code to load the image, and
    we''ll be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've ignored `Result` from the `draw_image_with_html_image_element` command,
    but that should draw the image, except, it…doesn't. It turns out you can't draw
    the image immediately after setting the source of an image element because the
    image hasn't been loaded yet. In order to wait for the image to be loaded, we'll
    use the `onload` callback of `HtmlImageElement`, which you can set up using `set_onload`
    in Rust. To do that, you'll need to learn a little about using JavaScript callbacks
    from Rust in the WebAssembly environment.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you set the `onload` callback via the `set_onload` function in Rust, you''re
    calling into JavaScript from WebAssembly, via a function that `web-sys` has generated
    for you. Unfortunately, translating the following JavaScript to Rust is complicated
    by the fact that JavaScript is garbage collected whereas Rust uses manual memory
    management, with its famous borrow checker. Take this code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What this means is to actually pass a function to JavaScript, as we want to
    do here, you have to use a complicated signature as well as think carefully about
    the borrowing rules of Rust. It's the kind of code that finally makes sense after
    you get it right but can be hard to write. Let's work through what we need to
    do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our source code, right after creating `HtmlImageElement`, we can try
    to add an `onload` callback in a way that seems intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitive might be an exaggeration, but that fits with the code we know how
    to write so far. Unfortunately, that doesn''t work, as you''ll get compiler errors
    about mismatched types, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the error says, `set_onload` doesn''t take a Rust closure but instead takes
    `Option<&js_sys::Function>`. Unfortunately, the error doesn''t tell you how to
    fix it, and it''s not clear how to create the `js_sys::Function` object. What
    you can do is start by creating a `Closure` object, with a capital "C," and try
    passing that into `set_onload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Closure` is a `wasm-bindgen` struct that is used to transfer a Rust closure
    to JavaScript. Here, we are using the `once` function on `Closure` because we
    know the `onload` handler is only called once. However, we still can''t just send
    that to JavaScript as is; trying to via `image.set_onload(callback)` results in
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `set_onload` wants `Option<&js_sys::Function>`, and so far, we''ve
    only created `Closure`. Fortunately, the `Closure` struct provides a way to make
    that conversion, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we call `as_ref` on the callback, which returns a raw `JsValue`, and
    then we call `unchecked_ref`, which converts it to a `&Function` object. We pass
    that into `Some` because `onload` can be `null` in JavaScript. Hooray! It compiles!
    The draw code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you run the app, it **still** doesn''t show our image, but it does log
    an error in the browser''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When was the closure destroyed? This is all in the `main` function, and so
    the closure is destroyed a couple of lines later when the function completes and
    the `callback` variable is no longer in scope. In order to see our log message,
    we can add one more call to the code after setting the `on_load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Calling `forget()` on the callback hands over memory management from Rust to
    JavaScript, effectively creating a deliberate memory leak. This is not something
    we want to do often, and it's here strictly to get us past our latest error, by
    preventing the closure from being destroyed. If you compile that and check your
    browser console, you'll see the message "loaded" now. This is great and all, but
    it still doesn't draw our picture because we're not actually waiting for the image
    to be loaded yet. For that, we'll need an asynchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Translating Rust closures to JavaScript closures is one of those cases where
    the abstractions between JavaScript and Rust are leaking all over the place, and
    it can be "accidentally-swear-in-front-of-your-kids" frustrating. So, don't feel
    bad when you get this wrong or get confused; it just means you're human.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We'll have more examples of sending closures to JavaScript throughout this book,
    but you may find yourself wanting to cross-reference the official documents at
    [http://bit.ly/3kSyOSI](http://bit.ly/3kSyOSI) and [http://bit.ly/3sXt1OW](http://bit.ly/3sXt1OW).
  prefs: []
  type: TYPE_NORMAL
- en: Async Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust added `async`, letting the runtime know that a function can be made to
    run asynchronously. Inside that function, you can then use an `await` call to
    pause execution of the current thread/process and allow the rest of the application
    to continue until the function that's being waited for can resume. The key thing
    is that while `await` pauses execution of the current execution context, it allows
    the rest of the code to continue. This makes it ideal for a game that cannot ever
    stop executing its game loop. It's also significantly cleaner to work with than
    callback-based code, so we'll be using it here (in combination with channels)
    to make sure that we don't try to draw our image before it's loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re familiar with using `async`/`.await` in traditional Rust, then you
    know these functions need to execute in a runtime, usually using crates such as
    `tokio` or `async-std`. That runtime is responsible for handing off control and
    restoring it. Take this simple example from the `async-std` library''s repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `async` block is wrapped in a function called `task::block_on`, which
    handles stopping the execution of this block on each `await` call and then resuming
    execution when the `await` "wakes up" for future processing. All of this requires
    spawning threads or checking event loops, code that you don't have to write because
    you're getting it from `async-std`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with other languages that natively support async/.await syntax,
    such as JavaScript, you might wonder why this additional step is necessary. The
    answer is that, unlike JavaScript, Rust doesn't `async` and `await` keywords exist
    in the language but don't work without additional crates, but that's a price we
    pay for additional power.
  prefs: []
  type: TYPE_NORMAL
- en: That's the bad news, but now for the good news – in WebAssembly, we don't need
    any additional runtime! Our code runs in the browser and can, therefore, use the
    browser's runtime; we just need to use a crate to spawn futures on the local event
    loop, and that crate is already present – `wasm_bindgen_futures`.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a future
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Future`, naturally, but as a user of futures, you don't generally create
    the `Future` type directly. You declare a function or closure as `async`, and
    when an `async` function is called, its return value will be wrapped in `Future`.
    Then, the caller can wait for that `Future` instance to finish by calling `await`.
    The benefit of this approach is that while the program doesn't actually stop when
    you call `await`, it looks like it does from the perspective of the code author.
    This makes the code look a lot more linear. In reality, execution of your program
    continues; otherwise, it would become unresponsive, but the runtime handles picking
    up the program where it left off when `Future` completes.
  prefs: []
  type: TYPE_NORMAL
- en: In case you forgot, we're trying to draw a sprite to the canvas, and to do so,
    we have to wait for the image to be loaded first. For that, we'll eventually use
    futures, but there's some infrastructure we need to build first. We'll start by
    adding an `onload` callback to `HtmlImageElement`, which will call a `oneshot`
    channel when the image is loaded. A `oneshot` channel is a channel where the receiver
    implements the `Future` trait, so we can call `await` on it to wait for it to
    receive a message. If we set up the `onload` callback to send a message to that
    channel, we can then call `await` on the receiver so execution will block until
    that image is loaded. Then, we can actually draw the image, knowing it's loaded.
    For all that to work, we need to wrap everything in an `async` block and spawn
    the returned future. That's a limitation of the `await` syntax; it can only work
    inside an `async` function of a block. Naturally, we'll start the implementation
    in the…`Cargo.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'I guess it''s not natural to start with the .`TOML` file, but we need to pull
    the future dependencies into our WebAssembly project. They''re already present
    in testing, so we''ll move `futures` and `wasm-bindgen-futures` out of `dev-dependencies`
    and into the standard `dependencies` block. You can put them right under `getrandom`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have access to Rust futures, we can use `wasm_bindgen_futures::spawn_local`
    to spawn a local future and put all our code for drawing the image into it. Returning
    to the code we wrote earlier to load `HtmlImageElement`, we will want to wrap
    all of it in a call to `spawn_local`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you call `spawn_local`, you need to pass it as a block marked with `async,`
    because `spawn_local` requires `Future`. We've marked this block as `move` to
    give the block ownership of any bindings we reference in it. Later, we'll also
    need to make sure we deal properly with the lifetime of this closure, which must
    be `'static`, but right now, we don't have to worry about that because everything
    is in the closure. This image is still not going to draw because while `Future`
    gets spawned when it runs to completion, our program exits. We need to wait for
    the image to be loaded, and for that, we'll use the `oneshot` channel.
  prefs: []
  type: TYPE_NORMAL
- en: A `oneshot` channel works like its name; you can call once, at which point it
    is consumed and cannot be called again. This means that when you move a `oneshot`
    channel into a Rust closure, the closure immediately becomes `FnOnce`. In fact,
    if you try to move `oneshot` into `FnMut` or `Fn`, you'll get compiler errors,
    with a side effect of your hair falling out as you try to figure out what's wrong.
    So, don't do that – it hurts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s create the channel inside the `spawn_local` block, and then
    replace the `web_sys::console::log_1` call in the callback by sending a message
    to the channel. The changes are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first line, we created the `oneshot` channel of `unit` type and then
    moved its transmitter into the callback. We got rid of the log message and replaced
    it with a call to `send` on the transmitter. Now, we need to wait for that message
    to be sent before we try to draw the image. Let''s modify the code underneath
    the closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we remove the `forget` call, as it's no longer necessary since we'll
    wait for the `onload` function to be called before we try to draw the image. That
    makes it okay for the closure to be deleted when the scope completes. Then, we
    call `success_rx.await` to block while the load completes. Finally, we'll draw
    the image as we were doing before, and it shows up!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – It is I, Red Hat Boy, king of the triangle](img/Figure_2.03_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – It is I, Red Hat Boy, king of the triangle
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We're ignoring a lot of results here, which is a bad practice. In the next chapter,
    we'll start structuring our game to better separate concerns, and when doing so,
    we'll remove that in favor of explicit error handling or calls to `expect` if
    we truly want to halt execution.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we're using `spawn_local` at all here, instead of just
    using a standard Rust channel and calling `recv` on it, and the reason is that
    a `recv` call blocks the main thread's execution, which is a big no-no in the
    browser. Browser-based code must allow the web browser to continue its event loop,
    and pausing it will cause the browser itself to become unresponsive. You could
    use a `try_rcv` call because that doesn't block, but you'd have to check it in
    a loop to make sure to wait until the image loads. That would also pause the browser
    and would probably cause one of those irritating `The browser is not responding`
    errors. Since both the browser and video games coincidentally can't cause the
    app to become unresponsive, we will use a `spawn_local` block and the `async`/`await`
    syntax. Remember that while the `await` context pauses local execution, the program
    itself actually keeps running, if only to constantly poll and see whether `Future`
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You''ve drawn an image on the screen a mere thousand words
    after I promised you would, but there''s one more thing we have to concern ourselves
    with. Let''s make a small change to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the app, the screen doesn't draw anything, including the triangle!
    This is because we await a successful load, which will never come. We need to
    handle the error case as well so that we can continue in the event of a failed
    load rather than hanging, even if we just want to halt the error. What we want
    to do is send one message (a unit) on success and another message (the error)
    to the receiver when the image is finished loading, either one way or the other.
  prefs: []
  type: TYPE_NORMAL
- en: You might think you can change `success_tx` to take either `unit` or an error
    code when the load fails. We can use `JsValue` for the error since that's the
    type any error code from the browser will be.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`JsValue` is a type that represents any value that comes directly from JavaScript.
    In Rust code, we''ll frequently convert these types into more specific Rust types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is immediately going to be a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`success_tx` cannot be moved into both closures at the same time. We''re going
    to need to use one of the Rust constructs to share the channel across threads
    so that we can use it in both callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We could use two `oneshot` channels and a `select` statement here as well, but
    at the time of writing, that did not work well in WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do is create the channel and then set up a reference counted version
    of the success and error transmitters. This means that both transmitters will
    send to the same receiver. Both of these will need to wrapped inside `Mutex`,
    as shown here, replacing the original creation of the `oneshot` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we will start sending the channel the `Result`, so we can differentiate
    between success and failure later. You''ll need to make sure that you import `std::rc::Rc`
    and `std::sync::Mutex`. Now that `success_tx` has been changed into `Rc<Mutex<Sender>`,
    you''ll need to update the `success` callback to reflect it. You''ll want to lock
    access to `Mutex` and then send the `success` message. Your first try is likely
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This locks `Mutex` and then sends its `oneshot` an `Ok(())`. This is *almost*
    right, but there''s a problem leading to a compiler error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler error is a mouthful, so it''s worth breaking it down. As the error
    says, the`.and_then(|oneshot| Ok(oneshot.send(Ok(()))));` line requires the `oneshot`
    value to be moved into the closure. This is because `oneshot` doesn''t implement
    copy. This makes sense; if you could copy `oneshot`, then you could use it more
    than once. Okay, so `oneshot` has to be moved into the closure – so what? Moves
    aren''t bad, but the error says, ``error[E0507]: cannot move out of dereference
    of `std::sync::MutexGuard``. `Mutex` takes ownership of the value you move into
    it, and you can''t just move out its value leaving it with "nothing." So, the
    compiler prevents this action.'
  prefs: []
  type: TYPE_NORMAL
- en: These are the kinds of errors that are both a great feature of Rust and the
    bane of a Rustacean's existence. Here, the compiler is preventing us from making
    a threading mistake, the kind that would be easy to do in almost any other language,
    but the side effect is an error that's hard to read. The Rust team continues to
    work hard on clearer compiler messages, but some things are just hard. When the
    compiler has you confused, read the errors slowly and carefully, and you'll usually
    figure out what it's trying to tell you.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you get around this problem? What you need to do is make sure to
    never move out of the `Mutex` reference while still getting access to the underlying
    `Sender`. The way we can do that is to use the `Option<T>` type, which implements
    a copy and the `take` function. That will allow us to replace, inside the locked
    `Mutex`, `Sender` with `None`. Then, any other user of that `Mutex` reference
    will have `None` and be able to use it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by modifying the creation of `success_tx` to take `Option`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `success` callback, we need to modify the code to account for the
    transmitter being optional. We''ll use `take` here to immediately replace `Some(transmitter)`
    with `None` when its used. This is the `success` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `if let` construct to get the transmitter out of `Mutex`
    and `Option`. If you follow the code from `success_tx.lock()`, you'll see we call
    `ok` to convert the `lock()` result to an `Option`, use the `and_then` function
    to operate on the `Some` version of `Option`, and then finally use `take` to get
    the value of `Option`. In the `if` condition, we call the transmitter's `send`
    function with an `Ok` result, and we no longer need the strange `Ok` wrapper around
    the `send` call. The key is that `Option` never moves out of `Mutex`; it's replaced
    by `None`. Since nobody else can access the `oneshot` struct while in the lock,
    the code is thread-safe, and because we use `Option`, the `Mutex` always contains
    something – even if it's `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can finally write the `error` callback that started all this, and it''s
    very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That `error` callback needs to be set using the `set_onerror` call. We had
    that previously, but just in case you didn''t add that earlier, it looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I placed the `set_onerror` call right under the existing `set_onload` call for
    symmetry. We do not need to add a second `await` call for the errors. Both `oneshot`
    transmitters send to the same receiver, because `error_tx` is a clone of `success_tx`,
    and we are protected from receiving an error and success because `oneshot` can
    only fire one time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're handling the error and success cases correctly, and we aren't getting
    compiler errors. If you look at your browser right now, you should see just the
    triangle, as we aren't stuck at the `await` call anymore. Go ahead and restore
    the call to `image.set_src("Idle (1).png")` so that it uses the right file again
    and the RHB shows back up.
  prefs: []
  type: TYPE_NORMAL
- en: So, there it is – our game now displays an image again *and* handles errors.
    But what if your game displays...more than one image?
  prefs: []
  type: TYPE_NORMAL
- en: Sprite sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a game where every sprite is its own individual file is certainly
    possible, but it would mean making the player wait for every file to load individually
    when the game started. One common way to organize sprites for a game is a **sprite
    sheet**, which is made up of two parts. The first is an image file with many sprites
    in it, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The top of the sprite sheet](img/Figure_2.04_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The top of the sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is a map of coordinates and metadata that lets us "cut out"
    each image we need, like a cookie cutter. For instance, if we want to show the
    first sprite in the preceding figure (which happens to be named `Dead (7).png`),
    we''ll need to know its location and dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – One sprite in the sheet](img/Figure_2.05_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – One sprite in the sheet
  prefs: []
  type: TYPE_NORMAL
- en: I've drawn a box marking the frame you'd want to "cut out" of the image when
    you want to draw `Dead (7).png`. When you want to draw a different file, say `Slide
    (1).png`, you can use the same image but a different frame when drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to know the frame and names of every sprite sheet, we need to load
    a separate file that stores all that information alongside the image itself. In
    our case, we will use files I''ve already generated for you with a tool called
    *TexturePacker* ([https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker)),
    which lets you export a JSON file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*TexturePacker* generated a JSON file with a lookup table by sprite name. In
    this case, the "`Dead` `(7).png`" sprite is found at (`0,0`) with a width of 109
    pixels and a height of 67 pixels, so in the upper left-hand corner of the larger
    image. To draw the image, you''ll eventually use a version of the `drawImage`
    function that takes source coordinates, which are the dimensions you saw in the
    preceding code, and destination coordinates where you want to position the drawing
    on the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to render the same `Idle` `(1).png` that we rendered earlier from the sprite
    sheet, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the JSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the JSON file into a Rust structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the image into `HtmlImageElement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the version of `drawImage` that lets us draw only a part of an image element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There isn't anything else to do, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Loading JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the assets that you downloaded earlier, there's a directory called `sprite_sheets`
    that has two files, `rhb.json` and `rhb.png`. Go ahead and copy both of those
    to the `static` directory so that they can be loaded by our project. Now, let's
    go back and start editing `lib.rs` to load our sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll start by writing an entirely new function to call `fetch_json`.
    It will use the `window.fetch` call to retrieve the JSON file and then pull the
    JSON off of the response body. This requires two asynchronous calls, so we''re
    going to write the entire thing as an `async` function. Go ahead and put all of
    this after `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things that won't even compile yet, and we'll fix them as I
    walk through this line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we retrieve `window`. Once again, we''re using `unwrap` because `window()`
    is an `Option`; in the next chapter, we''ll do a better job of dealing with our
    errors. That second line is a doozy; we''ll go through it in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part is the call to `wasm_bindgen_futures::JsFuture::from`, which
    is a little misleading. `JsFuture` is not a JavaScript future but a Rust future
    backed by a JavaScript promise. We want a Rust future so that we can eventually
    call `await` on it. We call `from` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to the `window.fetch` function in JavaScript, but as with many
    other JavaScript functions, `fetch` is overloaded, so we need to explicitly call
    it `with_str`. That function returns `Promise`, which we immediately convert to
    a future via the `from` call we discussed earlier. Finally, we call `await?` ,
    which will block until `fetch` returns. This is allowed because the `fetch_json`
    function is `async`.
  prefs: []
  type: TYPE_NORMAL
- en: Still with me? If you understood that, you've figured out the hardest part.
    Next, we cast the returned `resp_value` into `Response` because the `fetch` call
    resolves to `JsValue`. Once again, we must convert from the dynamic typing of
    JavaScript to the static typing of Rust, and the `dyn_into()` function does that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a response (corresponding to the `Response` object in the
    browser), we can call its `json()` function, corresponding to the `json()` function
    on the web's `Response` object. That function also returns a promise, so we wrap
    it in `JsFuture` as well and block on it with an `await` call.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this function returns `Result<JsValue, JsValue>`, which means it's
    `Result` with a dynamic JavaScript object as both its `Ok` or `Err` cases. That's
    why we can use `?` everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, this still doesn't compile because, once again, we're missing
    a feature flag. Make sure you add `Response` to the list of `web-sys` dependencies,
    and you should be green again. Well, except for the warning that says `fetch_json`
    isn't called.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in `main`, we''ll make the draw order as Red Hat Boy, the Sierpiński triangle,
    and then another Red Hat Boy. So, after the call to `sierpinski`, let''s fetch
    the "`rhb.json`" file corresponding to the Red Hat Boy''s data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This fetches the JSON but doesn't parse it into a structure we can use. We have
    a few options for JSON parsing, including using the browser's built-in facilities,
    but this is a Rust book, so let's use a Rust library, **Serde**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serde is one of the more popular serialization libraries for Rust and is excellent
    at taking JSON (as well as many other formats) and converting it to Rust structures.
    Add the necessary dependency to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The crate we need is `serde`, which generically handles serialization and deserialization
    (`rhb.json` file that you copied to the `static` directory earlier in your editor.
    At the top, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This JSON document describes a hash of frames, where the key to each frame is
    the name of the image `("Dead (1).png`") and the structure below it is the properties
    of that image. The property we care about is `frame`. The image for "`Dead (1).png`"
    is located at (`210, 493`) with a width of 71 pixels and a height of 115 pixels.
    Go back to the code, and we can parse that JSON that we fetched earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up data structures that `serde` can use. At the top of
    `lib.rs`, we can add the `Deserialize` procedural macro to the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also want to add `HashMap` from `std::collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll work backward. You''ll have a `Sheet` class that contains the lookup
    table from the preceding JSON. You can put this struct anywhere in the `lib.rs`
    file, just not inside a function. I put it at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[derive(Deserialize)]` macro means we can use `Sheet` as a target for
    deserializing the JSON, and `HashMap` and `String` work automatically, but we
    haven''t defined `Cell`. This will represent the portion of the JSON containing
    `frame`, which is what we care about because it''s where the target sprite is
    located. We''ll add all the structs we need above `Sheet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Great – we have a bunch of structures that can hold the map of data we need
    to draw our images, but we haven''t filled them, but fortunately, `wasm-bindgen`
    makes this very easy with the `serde-serialize` feature. To enable that feature,
    you''ll need to once again update `Cargo.toml`, replacing the basic `wasm-bindgen`
    dependency with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Where before you only had `wasm-bindgen = "0.2.78"`, now you''ll need to add
    the `serde-serialize` feature flag, so you have to use the slightly more complex
    syntax. After that builds, you can import the JSON data with only one line of
    code, `into_serde`, after you fetch the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: I removed the `unwrap` calls and replaced them with `expect` because I wanted
    a specific message in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Almost all of the dependencies that we are using are very young, and it's unlikely
    that this book will be able to keep up with every quirk. To follow along, stick
    to versions the book is using, but for your own future projects, remember to check
    documents for feature flags, version numbers, or both whenever a dependency seemingly
    doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the sheet, we are ready to load the image and draw a sprite
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with our "cookie cutter"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that we had four steps to draw from a sprite sheet. We''ve completed
    the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the JSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the JSON file into a Rust structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the image into `HtmlImageElement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the version of `drawImage` that lets us draw only a part of an image element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 3 is something you've already done before, and like all good programmers,
    we go immediately to one tool when we need to write the same code twice…
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste, of course! What, you thought that I was gonna say a function?
    We'll save that for later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: More seriously, copying and pasting to get something working a second time is
    perfectly acceptable; just avoid checking that in as the final version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy everything from `let (success_tx, success_rx)` to `success_rx.await` and
    paste it right below, where we converted `rhb.json` into `Sheet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the way Rust works, you won''t need to rename any variables, as every
    time you use `let`, you shadow the previous version of that variable and create
    a new binding. In the pasted code, we only need to make one change – to load the
    image sheet instead of "`Idle (1().png`":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3 is now complete; we''ve loaded the large image with many sprites in
    it. Finally, we''ll draw the sprite that we want. Let''s go ahead and draw the
    "`Run (1).png`" sprite, which will admittedly look similar but will allow us to
    add some animation to go along with it. We''ll use the version of the `drawImage`
    call that takes a source location, which is the frame we discussed earlier, and
    a destination location where we will put the image on the canvas. To make sure
    that we see the new image, let''s stick this image somewhere near the middle.
    Add this right after the last `await` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line, `sheet.frames.get`, retrieves the sprite by name, with an `expect`
    thrown in for when we get the name wrong. The next line is a monster because `drawImage`
    has nine argument versions in JavaScript, and it''s represented in Rust by the
    call to `draw_image_with_html_image_element_and_sw_and_sh_and_dx_and_dy_and_dw_and_dh`.
    That''s a mouthful, but what it means is drawing the image using the source rectangle
    (our frame) to a destination rectangle, where the source rectangle is represented
    by four position and size coordinates, and the destination rectangle is also represented
    by four coordinates. The source rectangle is our frame, drawn from the JSON file
    we loaded earlier. The destination rectangle starts at (`300,300`) to put RHB
    in about the center of the canvas and uses the same width and height because we
    don''t want to change the size of the image. The end result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Multiple Red Hat Boys](img/Figure_2.06_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Multiple Red Hat Boys
  prefs: []
  type: TYPE_NORMAL
- en: The original RHB is up in the left, using its own image file, and the second
    RHB from the sprite sheet is approximately in the center of the triangle. You'll
    notice his right hand is slightly tucked in because it's at the start of his run
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the run animation, how about we see it in action?
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Loading the sprite sheet and images the way we did here is just one of many
    ways to implement this technique. For example, another option would have been
    to embed the JSON and the images in the Rust executable, perhaps by Base64-encoding
    them, thereby doing all data loading at once. They could also have been bundled
    into destination applications via webpack and exposed to our Rust app. All these
    different ways come with their own trade-offs, and in our case, we have traded
    some complexity and upfront load times for the requirement to make calls to a
    server. Find the solution that works best for your game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sprite animation works just like a flip-book or a movie. Show a sequence of
    images fast enough, where each image is drawn to be only slightly different than
    the previous one, and it causes the illusion of motion. Animation on the canvas
    works in much the same way, where each frame in the sprite sheet has the same
    effect as a drawing in a flip-book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The run animation for Red Hat Boy](img/Figure_2.07_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The run animation for Red Hat Boy
  prefs: []
  type: TYPE_NORMAL
- en: To draw Red Hat Boy running, we have to simply draw the images in order, one
    at a time, and loop after drawing the last one. Simple for a loop, right?
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's not quite that simple. First, we can't just use an infinite
    loop, as that would block the browser from any processing, resulting in a frozen
    browser tab. Second, we have to make sure to clear the canvas between each frame.
    Otherwise, we'll see all the images merged together as one draws on top of the
    other. So, each time we draw the canvas, we'll need to clear it first, and then
    draw the desired frame.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with double buffering in traditional game development and
    are worried about seeing flicker when we clear the canvas and then redraw, don't.
    The canvas element already handles this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you already know almost all you need to in order to draw the animated
    RHB. You''ll need to pass a Rust closure to a function and draw a sprite from
    a sprite sheet. The only thing you don''t know is how to clear the canvas, and
    we''ll cover that in a moment, but we must start by saying goodbye:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sierpinski` and all the code it uses, including the `midpoint` and `draw_triangle`
    functions. They served us well and will be missed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Delete the idle RHB**: We could probably go to the effort of keeping the
    idle RHB sprite around, but it would require dealing with the duplicated code
    we wrote to create the sprite sheet. It''s best to delete all that copy and paste
    code before the boss finds out.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No, go ahead and delete everything inside the `spawn_local` closure up until
    we loaded the `rhb.json` file. After those deletions, your code should look like
    this around `spawn_local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, before spawning the local future, the last thing you do is get the `2d`
    context, and the first thing you do after spawning the future is load the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to change the draw into a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: '`setInterval` function, which is called `set_interval_with_callback`. First,
    we need to set up the callback itself, using the `Closure` `struct` that we used
    earlier. Right after the `success_rx.await` call, add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets up an empty `Closure`, but unlike the previous time we created `Closure`,
    we're using `Closure::wrap` instead of `Closure::once`. Why? Well, because this
    closure will be called multiple times. This also means we need to use `Box` with
    an explicit cast, `as Box<dyn FnMut()>`, because the `wrap` function requires
    `Box`, and there isn't enough information for the compiler to infer the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an empty interval callback, we can schedule it to be called.
    On the next line, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding that will start the process of calling our `interval_callback` every
    50 milliseconds; however, doing so will cause an error. If you look into the browser''s
    error log via the console, you''ll see this repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That should sound familiar, as we''ve already fixed it once this chapter. The
    fix will be to once again forget the closure that we passed into `setInterval`
    so that Rust doesn''t destroy it when we leave the scope of this future. Add this
    right *after* the `set_interval` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then, go back and check the console to verify that the error has gone away.
    You may need to refresh the browser to ensure that you don't get stale error messages
    showing up to confuse you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve scheduled a regular callback, let''s add one line to that
    callback to clear the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not compile because outside of this callback, we''re still calling
    `draw_image`. Since we''ve moved the `context` into this `Closure`, we''ve run
    afoul of the borrow checker. To address this, we''re going to need to move the
    drawing code into the closure, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You are now clearing the screen and redrawing it every 50 milliseconds.
    Unfortunately, it doesn't look like anything because you're always drawing the
    same image. Let's change the code to loop from "`Run (1).png`" to "`Run (8).png`"
    over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize a frame counter outside of the closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the inside of the closure, we''ll cycle the frame count between 0 and
    7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Why 0 to 7 when it goes to frame 8? Because we''ll adjust it on the next line
    when we construct `framename`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, instead of getting "`Run (1).png`" every time, we''ll get the constructed
    sprite name from the sprite sheet. Just change the `sheet.get` call to use `&frame_name`,
    and we''ll move the call to `get` above the `clear_rect` call as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Take a look now and, sure enough, Red Hat Boy is running!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – You can''t see running in a book, trust me](img/Figure_2.08_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – You can't see running in a book, trust me
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered rendering sprites to the screen, including
    sprite sheets, but we actually covered so much more than that. We covered how
    to use futures and `async` code in a WebAssembly app, how to parse JSON, and perhaps
    most confusingly how to send Rust closures to JavaScript via the `Closure` struct.
    We also reviewed some of the quirks of using Rust in the WebAssembly environment
    from [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*.
    This chapter was fun, but we made some messy code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll deal with that by setting up a simple architecture
    for our game and writing a proper game loop. Lest you think [*Chapter 3*](B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063)*,
    Creating a Game Loop*, is all refactoring, we'll also move our friend Red Hat
    Boy around the screen. It'll start to look like a real game!
  prefs: []
  type: TYPE_NORMAL
