- en: '*Chapter 7*: Handling Errors in Rust and Rocket'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about creating endpoints and SQL queries
    to handle the management of the `User` entity. In this chapter, we are going to
    learn more about error handling in Rust and Rocket. After learning the concepts
    in this chapter, you will be able to implement error handling in a Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to discuss more common ways to handle errors in Rust and Rocket,
    including signaling unrecoverable errors using the `panic!` macro and catching
    the `panic!` macro, using `Option`, using `Result`, creating a custom `Error`
    type, and logging the generated error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using panic!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning Result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom error type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Using panic!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand error handling in Rust, we need to begin with the `panic!` macro.
    We can use the `panic!` macro when the application encounters an unrecoverable
    error and there's no purpose in continuing the application. If the application
    encounters `panic!`, the application will emit the backtrace and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try using `panic!` on the program that we created in the previous chapter.
    Suppose we want the application to read a secret file before we initialize Rocket.
    If the application cannot find this secret file, it will not continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file in the `rocket()` function, prepend the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterward, try executing `cargo run` without creating an empty file named `secret_file`
    inside the working directory. You should see the output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try running the application again with `RUST_BACKTRACE=1 cargo run`. You
    should see the backtrace output in the terminal similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes, we don''t want to deallocate after panicking using the `panic!`
    macro because we want the application to exit as soon as possible. We can skip
    deallocating by setting `panic = "abort"` in `Cargo.toml` under the profile we
    are using. Setting that configuration will make our binary smaller and exit faster,
    and the operating system will need to clean it later. Let''s try doing that. Set
    the following lines in `Cargo.toml` and run the application again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know how to use `panic!`, let's see how we can catch it in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Catching panic!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as using `panic!`, we can also use the `todo!` and `unimplemented!`
    macros in Rust code. Those macros are very useful for prototyping because they
    will call `panic!` while also allowing the code to type-check at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, why does Rocket not shut down when we are calling a route with `todo!`?
    If we check the Rocket source code, there''s a `catch_unwind` function in `src::panic`
    that can be used to capture a panicking function. Let''s see that code in the
    Rocket source code, `core/lib/src/server.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `run()` is a route handling function. Each time we call a route that is
    panicking, the preceding routine will convert the panic into the result's `Err`
    variant. Try removing the `secret_file_path` routine we added before and running
    the application. Now, create a user and try going into user posts. For example,
    create a user with the `95a54c16-e830-45c9-ba1d-5242c0e4c18f` UUID. Try opening
    `http://127.0.0.1/users/95a54c16-e830-45c9-ba1d-5242c0e4c18f/posts`. Since we
    only put `todo!("will implement later")` in the function body, the application
    will panic, but the preceding `catch_unwind` function will catch the panic and
    convert it into an error. Please note that `catch_unwind` will not work if we
    set `panic = "abort"` in `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: In a regular workflow, we don't usually want to use `panic!`, because panicking
    interrupts everything, and the program will not be able to continue. If the Rocket
    framework does not catch `panic!` and one of the route handling functions is panicking,
    then that single error will close the application and there will be nothing to
    handle the other requests. But, what if we want to terminate the Rocket application
    when we encounter an unrecoverable error? Let's see how we can do it in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using shutdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To shut down smoothly if the application encounters an unrecoverable error in
    the route handling function, we can use the `rocket::Shutdown` request guard.
    Remember, the request guard is a parameter we are supplying to the route handling
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the `Shutdown` request guard in action, let''s try implementing it in
    our application. Using the previous application, add a new route in `src/routes/mod.rs`
    called `/shutdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Try adding the `shutdown()` function in `src/main.rs`. After that, rerun the
    application and send an HTTP request to `/shutdown` while monitoring the output
    of the application on the terminal. The application should shut down smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, let's see how we can use `Option` and `Result` as
    an alternative way to handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, a routine might produce a correct result or encounter a problem.
    One classical example is division by zero. Dividing something by zero is mathematically
    undefined. If the application has a routine to divide something, and the routine
    encounters zero as input, the application cannot return any number. We want the
    application to return another type instead of a number. We need a type that can
    hold multiple variants of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, we can define an `enum` type, a type that can be different variants
    of data. An `enum` type might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Point` and `Line` are said to have `Rectangle` is said to have `Rectangle`
    can also be called a **struct-like enum** variant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If all members of `enum` have no data, we can add a discriminant on the member.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign `enum` to a variable, and use the variable in a function as in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to error handling, we can use `enum` to communicate that there''s
    something wrong in our code. Going back to division by zero, here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding pattern returning something or not returning something is very
    common, so Rust has its own enum to show whether we have something or not in the
    standard library, called `std::option::Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`Some(T)` is used to communicate that we have `T`, and `None` is obviously
    used to communicate that we don''t have `T`. We used `Option` in some of the previous
    code. For example, we used it in the `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used `Option` as a function parameter or return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many useful things we can use with `Option`. Suppose we have two
    variables, `we_have_it` and `we_do_not_have_it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing we can do is pattern matching and use the content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can process it in a more convenient way if we care about the content of
    `we_have_it`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Option` can be compared if the inner type implements `std::cmp::Eq` and `std::cmp::Ord`,
    that is, the inner type can be compared using `==`, `!=`, `>`, and other comparison
    operators. Notice that we use `assert!`, a macro used for testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check whether a variable is `Some` or `None`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also get the content by unwrapping `Option`. But, there''s a caveat;
    unwrapping `None` will cause panic, so be careful when unwrapping `Option`. Notice
    we use `assert_eq!`, which is a macro used for testing to ensure equality:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `expect()` method. This method will work the same with
    `unwrap()` but we can use a custom message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can unwrap and set the default value so it will not panic if we unwrap `None`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can unwrap and set the default value with a closure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can convert the value contained to something else using `map()`, `map_or()`,
    or `map_or_else()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are other important methods, which you can check in the documentation
    for `std::option::Option`. Even though we can use `Option` to handle a situation
    where there's something or nothing, it does not convey a message of *something
    went wrong*. We can use another type similar to `Option` in the next part to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Rust, we have the `std::result::Result` enum that works like `Option`, but
    instead of saying *we have it* or *we don''t have it*, the `Result` type is more
    about saying *we have it* or *we have this error*. Just like `Option`, `Result`
    is an `enum` type of the possible `T` type or possible `E` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the division by zero problem, take a look at the following simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We don't want division by `0`, so we return an error for the preceding function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `Option`, `Result` has many convenient features we can use. Suppose
    we have the `we_have_it` and `we_have_error` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the value or the error using pattern matching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, we can use `if let` to destructure and get the value or the error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compare the `Ok` variant and the `Err` variant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check whether a variable is an `Ok` variant or an `Err` variant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can convert `Result` to `Option`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like `Option`, we can use `unwrap()`, `unwrap_or()`, or `unwrap_or_else()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, we can use `map()`, `map_err()`, `map_or()`, or `map_or_else()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are other important methods besides those methods in the `std::result::Result`
    documentation. Do check them because `Option` and `Result` are very important
    in Rust and Rocket.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a string or numbers as an error might be acceptable in some cases,
    but most likely, we want a real error type with a message and possible backtrace
    that we can process further. In the next section, we are going to learn about
    (and use) the `Error` trait and return the dynamic error type in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom error type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust has a trait to unify propagating errors by providing the `std::error::Error`
    trait. Since the `Error` trait is defined as `pub trait Error: Debug + Display`,
    any type that implements `Error` should also implement the `Debug` and `Display`
    traits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create a custom error type by creating a new module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/lib.rs`, add the new `errors` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, create a new folder, `src/errors`, and add the `src/errors/mod.rs`
    and `src/errors/our_error.rs` files. In `src/errors/mod.rs`, add this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/errors/our_error.rs`, add the custom type for `error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can implement the `Error` trait for `OurError`. In `src/errors/our_error.rs`,
    add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Currently, for the `User` module, we return a `Result<..., Box<dyn Error>>`
    dynamic error for each method. This is a common pattern of returning an error
    by using any type that implements `Error` and then putting the instance in the
    heap using `Box`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is we can only use methods provided by the `Error`
    trait, that is, `source()`. We want to be able to use the `OurError` status, message,
    and debug information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add a couple of builder methods to `OurError`. In `src/errors/our_error.rs`,
    add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we take a look at `src/models/user.rs`, there are three sources of errors:
    `sqlx::Error`, `uuid::Error`, and `argon2`. Let''s create a conversion for `sqlx::Error`
    and `uuid::Error` to `OurError`. Add the following `use` directive in `src/errors/our_error.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the same file, `src/errors/our_error.rs`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `sqlx::Error`, we want to convert `not_found` error to HTTP status `404`
    and duplicate index error to an HTTP status 400bad request. Add the following
    lines to `src/errors/our_error.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to do one more thing before we modify our `User` entity. Some crates
    in Rust do not compile the `std` library by default to make the resulting binary
    smaller and embeddable in IoT (Internet of Things) devices or WebAssembly. For
    example, the `argon2` crate does not include the `Error` trait implementation
    by default, so we need to enable the `std` feature. In `Cargo.toml`, modify the
    `argon2` dependencies to enable the `std` library features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/models/user.rs`, delete `use std::error::Error;` and replace it with
    `use crate::errors::our_error::OurError;`. Then, we can replace the methods for
    `User` to use `OurError` instead. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `argon2` error, we can create a function or method, or convert it manually.
    For example, in `src/models/user.rs`, we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change all the methods to use `OurError`. Just a reminder: you can find the
    complete source code for `src/models/user.rs` in the GitHub repository at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then use the `OurError` status and message in `src/routes/user.rs`.
    Because the `Error` type already implements the `Display` trait, we can use `e`
    directly inside `format!()`. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find the complete source code for `src/routes/user.rs` in the GitHub
    repository. Now that we have implemented errors, it might be a good time to try
    to implement the catchers that we defined before in `src/catchers/mod.rs` to show
    default errors for the user. You can also see the example of the default catchers
    in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, tracking and logging errors are an important part of maintaining
    the application. Since we implemented the `Error` trait, we can log the `source()`
    of an error in our application. Let's take a look at how to do that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Logging errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Rust, there''s a log crate that provides a facade for application logging.
    The log provides five macros: `error!`, `warn!,` `info!`, `debug!`, and `trace!`.
    An application can then create a log based on the severity and filter what needs
    to be logged, also based on the severity. For example, if we filter based on `warn`,
    then we only log `error!` and `warn!` and ignore the rest. Since the log crate
    does not implement the logging itself, people often use another crate to do the
    actual implementation. In the documentation for the log crate, we can find examples
    of other logging crates that can be used: `env_logger`, `simple_logger,` `simplelog`,
    `pretty_env_logger`, `stderrlog`, `flexi_logger`, `log4rs`, `fern`, `syslog`,
    and `slog-stdlog`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement custom logging in our application. We will use the `fern`
    crate for logging and wrap that in `async_log` to make logging asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add these crates in `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Rocket.toml`, add the config for `log_level`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then create the function to initialize a global logger in our application.
    In `src/main.rs`, create a new function called `setup_logger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the function, let''s initialize the logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we create a new instance of `fern::Dispatch`. After that, we configure
    the output format using the `format()` method. After setting the output format,
    we set the log level using the `level()` method.
  prefs: []
  type: TYPE_NORMAL
- en: For the logger, we want to not only output the log to the operating system `stdout`,
    but we also want to write to a log file. We can do it using the `chain()` method.
    To avoid panicking, don't forget to create a `logs` folder in the application
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we set up the level and logger, we wrap it inside `async_log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will log `OurError` when it''s created. Inside `src/errors/our_error.rs`,
    add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `setup_logger()` function to `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s try to see `OurError` inside the application log. Try creating
    users with the same username; the application should emit a duplicate username
    error in the terminal and `logs/application.log` similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have learned how to log errors, we can implement logging functionalities
    to improve the application. For example, we might want to create server-side analytics,
    or we can combine the logs with third-party monitoring as a service to improve
    the operations and create business intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned some ways to handle errors in Rust and Rocket
    applications. We can use `panic!`, `Option`, and `Result` as a way to propagate
    errors and create handling for the errors.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned about creating a custom type that implements the `Error`
    trait. The type can store another error, creating an error chain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned ways to log errors in our application. We can also use log
    capability to improve the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Our user pages are looking good, but using `String` all over the place is cumbersome,
    so in the next chapter, we are going to learn more about templating using CSS,
    JavaScript, and other assets in our application.
  prefs: []
  type: TYPE_NORMAL
