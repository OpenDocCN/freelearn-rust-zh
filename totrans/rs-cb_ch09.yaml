- en: Web Development with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rust进行Web开发
- en: 'We will be covering the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Setting up a web server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Web服务器
- en: Creating endpoints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建端点
- en: Handling JSONRequests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JSON请求
- en: Building a custom error handler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义错误处理器
- en: Hosting templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管模板
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Rust has many packages available that allow the developer to spin up a web server
    with it, and Rust is an ideal choice for a web project where memory, safety, and
    speed are of a great significance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有许多可用的包，允许开发者使用它启动一个Web服务器，并且Rust是内存、安全和速度至关重要的Web项目的理想选择。
- en: In this chapter, we will be playing with the nickel crate in Rust, which is
    a web application framework in Rust and provides all the fundamental units required
    for building a web application in Rust. The fundamental units include setting
    up a web server, handling web requests, and more. We will focus on the different
    macros and types that the nickel crate provides us for creating a web application
    in Rust.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Rust中的nickel crate进行实验，nickel是一个Rust的Web应用框架，它提供了构建Rust Web应用所需的所有基本单元。这些基本单元包括设置Web服务器、处理Web请求等。我们将关注nickel
    crate为我们提供的不同宏和类型，以在Rust中创建Web应用。
- en: Setting up a web server
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Web服务器
- en: In this recipe, you will learn the steps through which you can install the nickel
    crate into your Rust project and learn the commands with which you can start a
    web server where you can host your web application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何将nickel crate安装到你的Rust项目中，并学习使用哪些命令可以启动一个可以托管你的Web应用的Web服务器。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following nickel crate before we can go ahead and
    spawn a web server. Follow the given steps to download and set up the `nickel`
    crate for your project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续启动Web服务器之前，必须安装以下nickel crate。按照以下步骤下载和设置项目中的`nickel` crate：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the Cargo tool and enter the newly created project:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建Rust项目，并进入新创建的项目：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/ab489f1f-34ef-4269-9c2a-d0e6c3d4657f.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab489f1f-34ef-4269-9c2a-d0e6c3d4657f.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改。在这里，我们使用nickel crate，它在依赖项字段中输入：
- en: '![](img/a8a98c8a-d53f-41b9-b313-f0be3b1d330c.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8a98c8a-d53f-41b9-b313-f0be3b1d330c.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在你的项目中安装crate：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/80c06119-f80b-43bb-af96-84cdde0a6187.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80c06119-f80b-43bb-af96-84cdde0a6187.png)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个菜谱：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码头，包含相关信息：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import the installed `nickel` crate by using the `extern` keyword:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extern`关键字导入已安装的`nickel` crate：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中定义，其中我们声明`server`实例：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/22e108f7-f971-4c33-9ac1-1b809a67e391.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22e108f7-f971-4c33-9ac1-1b809a67e391.png)'
- en: 'Open your favorite browser and redirect to `http://127.0.0.1:6767/` to get
    the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的浏览器，并重定向到`http://127.0.0.1:6767/`以获取以下输出：
- en: '![](img/ec0e4839-7bc6-473e-9182-8b10ccbde998.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec0e4839-7bc6-473e-9182-8b10ccbde998.png)'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project named `nickel-demo`, which helps us
    spawn a web server using the `nickel` web application crate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个名为`nickel-demo`的Rust项目，它帮助我们使用`nickel` Web应用crate启动Web服务器。
- en: Starting at the top, we referenced the external `nickel` crate using the `extern`
    keyword and loaded all its macros with `#[macro_use]`. The `nickel` crate is the
    application object and surface that holds all public APIs; it's a struct, which
    implements all the fundamental methods for performing all the web application
    tasks. In the `main` function, we first assign `server` instances to a mutable
    variable and create a new `nickel` application object with `Nickel::new()`, which
    creates an instance of nickel with default error handling.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用了外部`nickel` crate，并使用`#[macro_use]`加载了所有宏。`nickel` crate是应用程序对象和表面，它包含所有公共API；它是一个结构体，实现了执行所有web应用程序任务的所有基本方法。在`main`函数中，我们首先将`server`实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的`nickel`应用程序对象，它创建了一个具有默认错误处理的nickel实例。
- en: Next, we set up our endpoint routing for which we use the `router!` macro, which
    listens at `"**"` and provides a simple message `"Hello world!"`, when a `get`
    request is demanded by the end user. The `get` method of the nickel crate or the
    server instance registers a handler to be used for a specific `get` request. Handlers
    are assigned to paths and paths are allowed to contain variables and wildcards;
    we have `"**"` in our case for handlers, which is a wild card entry and basically
    returns the same response for the get request of any endpoint. A handler added
    through this API will be attached to the default router. Double pipe characters
    represent a closure in Rust; this is the place where our `request` and `response`
    parameters go, which are `_req` and `_res` in our application. Fundamentally,
    there are structs that contain the request and response data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置端点路由，我们使用`router!`宏，它监听在`"**"`，当最终用户请求`get`请求时，提供一个简单的消息`"Hello world!"`。`nickel`
    crate的`get`方法或服务器实例注册一个用于特定`get`请求的处理程序。处理程序被分配到路径上，路径允许包含变量和通配符；在我们的情况下，处理程序是`"**"`，这是一个通配符条目，基本上为任何端点的`get`请求返回相同的响应。通过此API添加的处理程序将被附加到默认路由器。双竖线字符在Rust中表示闭包；这是我们的`request`和`response`参数放置的地方，在我们的应用程序中分别是`_req`和`_res`。基本上，有一些结构体包含请求和响应数据。
- en: Using the `server.utilize` method, we add the endpoint to the server instance
    and register the handler, which will be invoked among other handlers before each
    request. The `server.listen` method listens to the API requests on `127.0.0.1:6767`,
    where it binds and listens for connections on the given host and port.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`server.utilize`方法，我们将端点添加到服务器实例中，并注册处理程序，该处理程序将在其他处理程序之前被调用。`server.listen`方法监听在`127.0.0.1:6767`上的API请求，它绑定并监听给定主机和端口上的连接。
- en: Creating endpoints
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建端点
- en: In this recipe, you will learn the steps through which you can install the nickel
    crate into your Rust project. You will also learn the commands with which we can
    create custom endpoints in our web application, which would display different
    messages on being accessed by an end user of the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何将`nickel` crate安装到你的Rust项目中。你还将学习使用哪些命令可以在我们的web应用程序中创建自定义端点，当应用程序的最终用户访问时，会显示不同的消息。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following nickel crate before we can go ahead and
    spawn a web server. Follow the given steps to download and set up the `nickel`
    crate for your project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续并启动web服务器之前，我们必须安装以下`nickel` crate。按照以下步骤下载和设置你的项目中的`nickel` crate：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the Cargo tool and enter the newly created project:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建Rust项目并进入新创建的项目：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/5520e964-1bc2-49b0-bf98-a1d9801a8b53.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5520e964-1bc2-49b0-bf98-a1d9801a8b53.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we are using the nickel crate, which
    is entered in the dependencies field:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你最喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改。在这里，我们在依赖项字段中使用了`nickel` crate：
- en: '![](img/bcaf2dd9-4f06-4b90-bbea-1ac1f3535f04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcaf2dd9-4f06-4b90-bbea-1ac1f3535f04.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在你的项目中安装crate：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command will install all the dependencies of the `nickel` crate in your
    Rust project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在你的Rust项目中安装`nickel` crate的所有依赖。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement this recipe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你偏好的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息编写代码头：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Import the installed `nickel` crate by using the `extern` keyword:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `extern` 关键字导入已安装的 `nickel` crate：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中定义 `main` 函数，其中我们声明 `server` 实例：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/b85dfb27-66b6-46a9-af96-89e658562809.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b85dfb27-66b6-46a9-af96-89e658562809.png)'
- en: 'Open your favorite browser and redirect to the following endpoints:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器并重定向到以下端点：
- en: 'Enter the URL, `http://127.0.0.1:6767/bar`:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 URL，`http://127.0.0.1:6767/bar`：
- en: '![](img/b0ae273b-4816-4265-80a7-64bfc59bb08b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0ae273b-4816-4265-80a7-64bfc59bb08b.png)'
- en: 'Enter the URL, `http://127.0.0.1:6767/user/viki`:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 URL，`http://127.0.0.1:6767/user/viki`：
- en: '![](img/a5bdc4bd-33ee-4f01-bfac-9814db93b7c3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5bdc4bd-33ee-4f01-bfac-9814db93b7c3.png)'
- en: 'Enter the URL, `http://127.0.0.1:6767/a/b/d/d`:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 URL，`http://127.0.0.1:6767/a/b/d/d`：
- en: '![](img/c8c4e97f-acaa-4b6d-830c-d621829585e0.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8c4e97f-acaa-4b6d-830c-d621829585e0.png)'
- en: 'Enter the URL, `http://127.0.0.1:6767/a/b/c/d`:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 URL，`http://127.0.0.1:6767/a/b/c/d`：
- en: '![](img/fde183f3-5d96-4d54-aff9-b862a8cab52e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fde183f3-5d96-4d54-aff9-b862a8cab52e.png)'
- en: 'Enter the URL, `http://127.0.0.1:6767/a/b/d`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 URL，`http://127.0.0.1:6767/a/b/d`：
- en: '![](img/3be22968-c278-4e56-8dae-2b3e112ef5c8.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3be22968-c278-4e56-8dae-2b3e112ef5c8.png)'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project named `nickel-routing`, which helps
    us to create multiple endpoints in our web application, and each endpoint displays
    different custom messages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个名为 `nickel-routing` 的 Rust 项目，它帮助我们创建网络应用程序中的多个端点，并且每个端点显示不同的自定义消息。
- en: Starting at the top, we referenced the external `nickel` crate using the `extern`
    keyword and loading all of its macros with `#[macro_use]`. We use `nickel` as
    the application object and surface, which holds all the public APIs. It's a struct
    that implements all the fundamental methods for performing all the web application
    tasks, and `HttpRouter` is a public trait provided by the `nickle` crate, which
    has the signature of various REST API calls.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用 `extern` 关键字引用了外部 `nickel` crate，并使用 `#[macro_use]` 加载了其所有宏。我们使用
    `nickel` 作为应用程序对象和表面，它持有所有公共 API。它是一个实现了执行所有网络应用程序任务的基本方法的结构体，`HttpRouter` 是 `nickle`
    crate 提供的公共 trait，它具有各种 REST API 调用的签名。
- en: In the `main` function, we first assign `server` instances to a mutable variable
    and create a new `nickel` application object with `Nickel::new()`, which creates
    an instance of nickel with default error handling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先将 `server` 实例分配给一个可变变量，并使用 `Nickel::new()` 创建一个新的 `nickel`
    应用程序对象，这会创建一个具有默认错误处理的 `nickel` 实例。
- en: The `server.get` method registers a handler to be used for a specific `get`
    request. Handlers are assigned to paths and paths are allowed to contain variables
    and wildcards. A handler added through this API will be attached to the default
    router. The `middleware!` macro reduces the amount of boilerplate code needed
    for each route.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.get` 方法注册一个用于特定 `get` 请求的处理程序。处理程序被分配到路径上，并且路径可以包含变量和通配符。通过此 API 添加的处理程序将被附加到默认路由器。`middleware!`
    宏减少了每个路由所需的样板代码量。'
- en: 'We create the following routes in this recipe:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了以下路由：
- en: '`/bar`: On hitting this endpoint, we get the message, This is the /bar handler.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bar`：点击此端点，我们得到消息，这是 /bar 处理程序。'
- en: '`/user/:userid`: On hitting this endpoint, we get the message, This is user:
    {:?}. Here, the argument is replaced with the data (`:userid`) passed in the `get`
    request with the `request.param("userid")` command, where `param` is a method
    of the `request` struct.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/:userid`：点击此端点，我们得到消息，这是用户：{:?}。在这里，参数被替换为通过 `request.param("userid")`
    命令在 `get` 请求中传递的数据（`:userid`），其中 `param` 是 `request` 结构体的一个方法。'
- en: '`/a/*/d`: On hitting this endpoint, we get the message, matches /a/b/d but
    not /a/b/c/d. The asterisk here allows only one intermediate path.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/a/*/d`：点击此端点，我们得到消息，匹配 /a/b/d 但不匹配 /a/b/c/d。这里的星号允许只有一个中间路径。'
- en: '`/a/**/d`: On hitting this endpoint, we get a message: This matches /a/b/d
    and also /a/b/c/d. The asterisk here allows only two intermediate paths.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/a/**/d`：点击此端点，我们得到消息：这匹配 /a/b/d 和 /a/b/c/d。这里的星号允许有两个中间路径。'
- en: Routes can be as simple as `/foo`, use parameters, wildcards, and even double
    wildcards.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以像 `/foo` 那样简单，可以使用参数、通配符，甚至双通配符。
- en: The `server.listen` method listens to the API requests on `127.0.0.1:6767` where
    it binds and listens for connections on the given host and port.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen` 方法监听在 `127.0.0.1:6767` 上的 API 请求，它在该主机和端口上绑定并监听连接。'
- en: Handling JSONRequests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON 请求
- en: In this recipe, we will learn the steps through which we can install the `nickel`
    crate into your Rust project and learn the commands with which we can accept a
    `POST` request to an endpoint from the end user.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何将 `nickel` 包安装到您的 Rust 项目中，以及如何使用命令接受来自终端用户的端点 `POST` 请求。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following `nickel` crate before we can go ahead
    and spawn a web server. Follow the given steps to download and set up the `nickel`
    and `rustc_serialize` crates for your project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续并启动一个 web 服务器之前，我们必须安装以下 `nickel` 包。按照以下步骤下载并设置 `nickel` 和 `rustc_serialize`
    包以供项目使用：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 Rust 编译器和任何文本编辑器来开发 Rust 代码片段。
- en: 'Create a Rust project using the Cargo tool and enter the newly created project:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 工具创建一个 Rust 项目并进入新创建的项目：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Take a look at the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图：
- en: '![](img/35670fb1-ccec-4082-9a84-d6e8e6a57428.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35670fb1-ccec-4082-9a84-d6e8e6a57428.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we are using the nickel and `rustc-serialize`
    crates, which are entered in the dependencies field:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的文本编辑器中打开 `Cargo.toml` 文件并按照以下截图进行修改。在这里，我们使用 `nickel` 和 `rustc-serialize`
    包，它们被输入到依赖项字段中：
- en: '![](img/be5f1bf6-479e-4c00-8ddf-5fcb4484224b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be5f1bf6-479e-4c00-8ddf-5fcb4484224b.png)'
- en: 'Install the crate in your project using the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的项目中安装该包：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command will install all the dependencies of the `nickel` and `rustc-serialize`
    crate in your Rust project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的 Rust 项目中安装 `nickel` 和 `rustc-serialize` 包的所有依赖项。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现本教程：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开 `src` 目录下的 `main.rs` 文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Import the installed `nickel` and `rustc_serialize` crates by using the `extern`
    keyword:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `extern` 关键字导入已安装的 `nickel` 和 `rustc-serialize` 包：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a custom `Struct` type named `Person`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Person` 的自定义 `Struct` 类型：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the `main` function, where we declare the `server` instance:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 函数，其中我们声明 `server` 实例：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并从项目的根目录使用以下命令启动服务器：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/8ba3af65-6ef8-4c96-a2eb-81c1be6103f1.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ba3af65-6ef8-4c96-a2eb-81c1be6103f1.png)'
- en: 'Open your terminal and enter the following command to hit the endpoint with
    `curl`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的终端并输入以下命令以使用 `curl` 击中端点：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On successfully hitting the endpoint with the `curl` command, we will get the
    following response (highlighted) in the output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `curl` 命令成功击中端点后，我们将在输出中看到以下（突出显示）的响应：
- en: '![](img/87d48b7e-0306-4b81-9d9e-afaa360f7b18.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87d48b7e-0306-4b81-9d9e-afaa360f7b18.png)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project named `nickel-jsonhandling`, which
    helps us get data from the end user and perform a certain set of actions based
    on the input. The `nickel` crate makes it easy to map JSON data right onto your
    struct. We use the `rustc-serialize` dependency for this project in order to handle
    JSON encoding and decoding.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们创建了一个名为 `nickel-jsonhandling` 的 Rust 项目，它帮助我们从终端用户获取数据并根据输入执行一系列操作。`nickel`
    包使得将 JSON 数据直接映射到您的结构体变得容易。我们在这个项目中使用 `rustc-serialize` 依赖项来处理 JSON 编码和解码。
- en: 'Starting at the top, we referenced the external `nickel` crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`. We use `nickel` as the
    application object and surface, which holds all the public APIs; it''s basically
    a struct that implements all the fundamental methods for performing the web application
    tasks. The `HttpRouter` is a public trait provided by the `nickle` crate, which
    has the signature of various REST API calls. `JsonBody` is a public trait provided
    by the `nickle` crate, which has the signature of the `json_as` method, which
    takes a decodable type provided by the `rustc-serialize` crate. We create a custom
    struct type named `Person`, which has two string fields: `firstname` and `lastname`.
    The JSON body that is posted from the end user is converted to the `Person` type
    so that we can use it our application. To be able to encode a piece of data, it
    must implement the `rustc_serialize::Encodable` trait. To be able to decode a
    piece of data, it must implement the `rustc_serialize::Decodable` trait. The Rust
    compiler provides an annotation to automatically generate the code for these traits:
    `#[derive(RustcDecodable, RustcEncodable)]`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用了外部的`nickel`crate，并使用`#[macro_use]`加载了其所有宏。我们将`nickel`用作应用程序对象和表面，它包含所有公共API；它基本上是一个实现了执行Web应用程序任务的所有基本方法的struct。`HttpRouter`是`nickle`crate提供的公共trait，它具有各种REST
    API调用的签名。`JsonBody`是`nickle`crate提供的公共trait，它具有`json_as`方法的签名，该方法接受由`rustc-serialize`crate提供的可解码类型。我们创建了一个名为`Person`的自定义struct类型，它有两个字符串字段：`firstname`和`lastname`。从终端用户发布的JSON体被转换为`Person`类型，这样我们就可以在我们的应用程序中使用它。为了能够编码数据，它必须实现`rustc_serialize::Encodable`trait。为了能够解码数据，它必须实现`rustc_serialize::Decodable`trait。Rust编译器提供了一个注解，可以自动生成这些trait的代码：`#[derive(RustcDecodable,
    RustcEncodable)]`。
- en: In the `main` function, we first assign `server` instances to a mutable variable
    and create a new `nickel` application object with `Nickel::new()`, which creates
    an instance of `nickel` with default error handling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将`server`实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的`nickel`应用程序对象，这会创建一个具有默认错误处理的`nickel`实例。
- en: The `server.post` method registers a handler to be used for a specific `POST`
    request. Handlers are assigned to paths and paths are allowed to contain variables
    and wildcards. A handler added through this API will be attached to the default
    router. The `middleware!` macro reduces the amount of boilerplate code needed
    for each route. We create a variable, `person`, which is assigned to `request.json_as::<Person>().unwrap()`,
    where `request` is a parameter containing the information from the end user and
    the `unwrap` method is one of the several ways that Rust provides for assigning
    a value. We provide a simple message, `"Hello {} {}", person.firstname, person.lastname"`,
    in the `format!` macro to be displayed when the `/a/post/request` endpoint is
    accessed, where `person` is a variable of the `Person` type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.post`方法注册一个用于特定`POST`请求的处理程序。处理程序被分配到路径上，路径允许包含变量和通配符。通过此API添加的处理程序将被附加到默认路由器。`middleware!`宏减少了每个路由所需的样板代码量。我们创建了一个变量`person`，它被分配给`request.json_as::<Person>().unwrap()`，其中`request`是一个包含终端用户信息的参数，`unwrap`方法是Rust提供的几种分配值的方法之一。我们在`format!`宏中提供了一个简单的消息`"Hello
    {} {}", person.firstname, person.lastname"`，当访问`/a/post/request`端点时将显示，其中`person`是`Person`类型的变量。'
- en: 'To hit the endpoint, we use the `curl` command, where `-H` stands for the header
    type, which is`"Content-Type: application/json"`, and we give a `POST` request
    (`-X`) at `http://127.0.0.1:6767/a/post/request` with the following data (`-d`):
    `''{"firstname":"Vigneshwer","lastname":"Dhinakaran"}''`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '要访问端点，我们使用`curl`命令，其中`-H`代表头类型，是`"Content-Type: application/json"`，我们在`http://127.0.0.1:6767/a/post/request`上发送一个`POST`请求（`-X`），并附带以下数据（`-d`）:`''{"firstname":"Vigneshwer","lastname":"Dhinakaran"}''`。'
- en: The `server.listen` method listens to the API requests on `127.0.0.1:6767` where
    it binds and listens for connections on the given host and port.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen`方法监听在`127.0.0.1:6767`上的API请求，在那里它绑定并监听给定主机和端口上的连接。'
- en: Building custom error handlers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义错误处理程序
- en: In this recipe, you will learn the steps through which you can install the nickel
    crate into your Rust project. You will also learn the commands to create your
    custom error handler, which, for example, can help you create a custom `404` page.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何将`nickel`crate安装到你的Rust项目中。你还将学习创建自定义错误处理程序的命令，例如，可以帮你创建自定义的`404`页面。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following `nickel` crate before we can go ahead
    and spawn a web server. Follow the given steps to download and setup a `nickel`
    crate for your project:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够继续并启动Web服务器之前，我们必须安装以下`nickel`包。按照以下步骤下载和设置项目中的`nickel`包：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the Cargo tool and enter the newly created project:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建一个Rust项目，并进入新创建的项目：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/d34b64b0-f53d-4d1d-9782-96bc5146b361.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d34b64b0-f53d-4d1d-9782-96bc5146b361.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we are using the `nickel` crate, which
    is entered in the dependencies field:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你偏好的文本编辑器中打开`Cargo.toml`文件，并按照以下截图进行修改。在这里，我们使用`nickel`包，它在依赖项字段中输入：
- en: '![](img/46940cf2-7b45-436b-8b61-92bb888644c4.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46940cf2-7b45-436b-8b61-92bb888644c4.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在你的项目中安装该包：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will install all the dependencies of the `nickle` crate in your
    Rust project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在你的Rust项目中安装`nickle`包的所有依赖项。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你偏好的文本编辑器中打开`src`目录下的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头进行编写：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Import the installed `nickel` crate by using the `extern` keyword:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extern`关键字导入已安装的`nickel`包：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the `main` function in which we declare the `server` instance:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中定义，其中我们声明`server`实例：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/7347614f-956d-48ce-bda1-5ac413ddaa86.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7347614f-956d-48ce-bda1-5ac413ddaa86.png)'
- en: 'Open your favorite browser and redirect to `127.0.0.1:6767/viki` to get the
    following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的浏览器，并重定向到`127.0.0.1:6767/viki`以获取以下输出：
- en: '![](img/03544319-dcb3-4337-ba2f-96d5c11bcdc1.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03544319-dcb3-4337-ba2f-96d5c11bcdc1.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project named `nickel-errorhandling`, which
    helps us spawn the web server using the `nickel` web application crate. By default,
    `nickel` catches all the errors with its default ErrorHandler and tries to take
    reasonable actions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们创建了一个名为`nickel-errorhandling`的Rust项目，它帮助我们使用`nickel` Web应用程序包启动Web服务器。默认情况下，`nickel`使用其默认的ErrorHandler捕获所有错误，并尝试采取合理的行动。
- en: Starting at the top, we referenced the external `nickel` crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用`extern`关键字引用了外部的`nickel`包，并使用`#[macro_use]`加载了其所有宏。
- en: 'We used the following units from the `nickel` crate:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`nickel`包中的以下单元：
- en: The `nickel` crate is the application object and surface, which holds all the
    public APIs. It's a struct that implements all the fundamental methods for performing
    all the web application tasks.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nickel`包是应用程序对象和界面，它包含所有公共API。它是一个实现了执行所有Web应用程序任务的基本方法的`struct`。'
- en: '`NickelError` is a basic error type for `HTTP` errors as well as user-defined
    errors.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NickelError`是`HTTP`错误以及用户定义错误的基类错误类型。'
- en: '`Action` is an `enum` data type provided by the `nickel` crate, where `Continue`
    and `Halt` are variants of the `Action` type.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action`是`nickel`包提供的`enum`数据类型，其中`Continue`和`Halt`是`Action`类型的变体。'
- en: '`Request` is a container for all the request data.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Request`是一个用于存储所有请求数据的容器。'
- en: We used `nickel::status::StatusCode::NotFound`; here, the status is a public
    module of the `nickel` crate, which defines the `StatusCode` `enum` type containing
    the different HTTP status codes. `NotFound` is one of them and `std::io::Write`,
    which is a trait that defines the `write_all` method, writes all the data in the
    entire buffer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`nickel::status::StatusCode::NotFound`；在这里，状态是`nickel`包的公共模块，它定义了一个包含不同HTTP状态码的`StatusCode`
    `enum`类型。`NotFound`是其中之一，`std::io::Write`是一个定义了`write_all`方法的`trait`，它将整个缓冲区中的所有数据写入。
- en: In the `main` function, we first assign `server` instances to a mutable variable
    and create a new `nickel` application object with `Nickel::new()`, which creates
    an instance of `nickel` with default error handling.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将`server`实例分配给一个可变变量，并使用`Nickel::new()`创建一个新的`nickle`应用程序对象，它创建了一个具有默认错误处理的`nickle`实例。
- en: We create a custom error handler named `custom_handler`, which is invoked in
    the case of `NotFound` or `404` status code. We call the function, `custom_404`,
    which takes in two parameters, `NickelError` and `Request`, and returns an `Action`
    type. The `custom_404` is a way to overwrite the default error handler to handle
    `404` cases with a custom view.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`custom_handler`的自定义错误处理器，在`NotFound`或`404`状态码的情况下被调用。我们调用函数`custom_404`，它接受两个参数，`NickelError`和`Request`，并返回一个`Action`类型。`custom_404`是一种覆盖默认错误处理器以使用自定义视图处理`404`情况的方法。
- en: The `custom_404` assigns the arguments `&mut NickelError` and `&mut Request`
    to `err` and `_req`, respectively. In the function, we assign `err.stream`, where
    `stream` is a field of the `NickelError` type to `Some(ref mut res)`, and check
    whether it is true; else we return `Continue(())`. If true, we know that there
    has been an error when the end user tried to access the endpoint, and the next
    step is to check whether the status code `res.status()` is `NotFound`. In such
    a case, we write the custom `404` page with the `res.write_all` method and return
    `Halt(())`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom_404`将`&mut NickelError`和`&mut Request`的参数分别赋值给`err`和`_req`。在函数中，我们将`err.stream`（`stream`是`NickelError`类型的一个字段）赋值给`Some(ref
    mut res)`，并检查它是否为真；否则返回`Continue(())`。如果为真，我们知道当最终用户尝试访问端点时发生了错误，下一步是检查状态码`res.status()`是否为`NotFound`。在这种情况下，我们使用`res.write_all`方法编写自定义的`404`页面，并返回`Halt(())`。'
- en: The `server.handle_error` registers an error handler, which will be invoked
    among other error handlers as soon as any regular handler returns an error; the
    other error handler in our case is `custom_handler`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.handle_error`注册了一个错误处理器，当任何常规处理器返回错误时，它将在其他错误处理器中调用；在我们的情况下，其他错误处理器是`custom_handler`。'
- en: The `server.listen` method listens to the API requests on `127.0.0.1:6767` where
    it binds and listens for connections on the given host and port.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen`方法监听在`127.0.0.1:6767`上的API请求，它在该主机和端口上绑定并监听连接。'
- en: Hosting templates
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管模板
- en: In this recipe, you will learn the steps through which you can install the `nickel`
    crate into your Rust project and learn the commands with which we can host a custom
    template when the end user hits an endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何将`nickle`crate安装到您的Rust项目中，并学习当最终用户点击端点时我们可以使用哪些命令来托管自定义模板。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will have to install the following `nickel` crate before we can go ahead
    and spawn a web server. Follow the given steps to download and set up the `nickel`
    crate for your project:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续并启动web服务器之前，我们必须安装以下`nickle`crate。按照以下步骤下载并设置项目中的`nickle`crate：
- en: We will require the Rust compiler and any text editor to develop the Rust code
    snippet.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要Rust编译器和任何文本编辑器来开发Rust代码片段。
- en: 'Create a Rust project using the Cargo tool and enter the newly created project:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cargo工具创建Rust项目并进入新创建的项目：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Take a look at the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/4578440a-4d03-44b0-89b3-188e1a70342a.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4578440a-4d03-44b0-89b3-188e1a70342a.png)'
- en: 'Open the `Cargo.toml` file in your favorite text editor and make the modification
    shown in the following screenshot. Here, we are using the `nickel` crate, which
    is entered in the dependencies field:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的文本编辑器中打开`Cargo.toml`文件，并按照以下截图所示进行修改。在这里，我们使用`nickle`crate，它在依赖项字段中输入：
- en: '![](img/a75776da-da81-4853-bedc-20f3c389c696.png)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/a75776da-da81-4853-bedc-20f3c389c696.png)'
- en: 'Install the crate in your project with the following command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的项目中安装crate：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command will install all the dependencies of the `nickle` crate in your
    Rust project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的Rust项目中安装`nickle`crate的所有依赖项。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the given steps to implement this recipe:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现此配方：
- en: Open the `main.rs` file in the `src` directory in your preferred text editor.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您首选的文本编辑器中打开`src`目录中的`main.rs`文件。
- en: 'Write the code header with the relevant information:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关信息的代码头进行编写：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Import the installed `nickel` crate by using the `extern` keyword:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extern`关键字导入已安装的`nickle`crate：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `main` function where we declare the `server` instance:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中定义我们声明的`server`实例：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the `examples/assets` directory and the `template.tpl` file using the
    the following commands:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建 `examples/assets` 目录和 `template.tpl` 文件：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](img/7a98653a-d3e4-47dc-aaa9-8d776ea694ff.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a98653a-d3e4-47dc-aaa9-8d776ea694ff.png)'
- en: 'Open the file `template.tpl` in a text editor and enter the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开文件 `template.tpl` 并输入以下代码：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save the file and start the server with the following command from the root
    directory of the project:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并从项目的根目录使用以下命令启动服务器：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will get the following output on the successful execution of our code in
    the terminal:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端成功执行我们的代码后，我们将得到以下输出：
- en: '![](img/90d49d32-0574-413a-a8c1-9efe852ab4d9.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90d49d32-0574-413a-a8c1-9efe852ab4d9.png)'
- en: 'Open your favorite browser and redirect to `127.0.0.1:6767` to get the following
    output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器并重定向到 `127.0.0.1:6767` 以获取以下输出：
- en: '![](img/32968ef2-1fc5-48d4-a75b-0870f9f40f93.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32968ef2-1fc5-48d4-a75b-0870f9f40f93.png)'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Rust project named `nickel-template`, which loads
    a custom HTML template with dynamic data fields when the end user tries to access
    a particular endpoint.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个名为 `nickel-template` 的 Rust 项目，当最终用户尝试访问特定端点时，它会加载一个自定义的 HTML
    模板，其中包含动态数据字段。
- en: Starting at the top, we referenced the external `nickel` crate using the `extern`
    keyword and loaded all of its macros with `#[macro_use]`. We used `nickel` as
    the application object and surface, which holds all the public APIs; it's a struct
    that implements all the fundamental methods for performing all the web application
    tasks. We also used `HttpRouter`, which is a public trait provided by the `nickle`
    crate and has the signature of various REST API calls, and the `Hashmap` type
    from `std::collections`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们使用 `extern` 关键字引用了外部的 `nickel` crate，并使用 `#[macro_use]` 加载了其所有宏。我们将
    `nickel` 作为应用程序对象和表面使用，它包含所有公共 API；它是一个实现了执行所有网络应用程序任务的基本方法的 struct；我们还使用了 `HttpRouter`，这是
    `nickle` crate 提供的公共 trait，具有各种 REST API 调用的签名，以及来自 `std::collections` 的 `Hashmap`
    类型。
- en: HashMaps store values by key. `HashMap` keys can be Booleans, integers, Strings,
    and vectors. HashMaps are growable but HashMaps can also shrink themselves when
    they have excess space.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: HashMaps 通过键存储值。`HashMap` 的键可以是布尔值、整数、字符串和向量。HashMap 是可增长的，但当它们有额外空间时，HashMap
    也可以缩小自己。
- en: In the `main` function, we first assign `server` instances to a mutable variable
    and create a new `nickel` application object with `Nickel::new()`, which creates
    an instance of `nickel` with default error handling.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先将 `server` 实例分配给一个可变变量，并使用 `Nickel::new()` 创建一个新的 `nickel`
    应用程序对象，它创建了一个具有默认错误处理的 `nickel` 实例。
- en: The `server.get` method registers a handler to be used for a specific `get`
    request. Handlers are assigned to paths and paths are allowed to contain variables
    and wildcards. A handler added through this API will be attached to the default
    router. The `middleware!` macro reduces the amount of boilerplate code needed
    for each route. The path here is `"/"`, where the response contains the data that
    needs to be returned to the end user. We host the template created in `examples/asset
    s/template.tpl` and provide the input for the `name` field in the arguments for
    `response.render`, which is returned as output to the end user. We create a mutable
    variable named `data`, which is of the `HashMap` type. We also insert a key named
    `name` and assign it a value, `"viki"` using `data.insert`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.get` 方法注册了一个用于特定 `get` 请求的处理程序。处理程序被分配到路径上，路径允许包含变量和通配符。通过此 API 添加的处理程序将被附加到默认路由器。`middleware!`
    宏减少了每个路由所需的样板代码量。这里的路径是 `"/"`，其中响应包含需要返回给最终用户的数据。我们托管在 `examples/asset s/template.tpl`
    中创建的模板，并为 `response.render` 的参数提供 `name` 字段的输入，它作为输出返回给最终用户。我们创建了一个名为 `data` 的可变变量，其类型为
    `HashMap`。我们还插入了一个名为 `name` 的键，并使用 `data.insert` 分配了值 `"viki"`。'
- en: The `server.listen` method listens to the API requests on `127.0.0.1:6767` where
    it binds and listens for connections on the given host and port.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen` 方法监听 `127.0.0.1:6767` 上的 API 请求，其中它绑定并监听给定主机和端口上的连接。'
