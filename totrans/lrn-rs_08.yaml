- en: The Rust Application Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust, as we have seen, is a very stable language. It is also what can be described
    as a memory-safe language in that, when the code is compiling, the compiler tests
    the code to ensure that things don't go wrong, such as accessing outside of an
    array or freeing memory twice.
  prefs: []
  type: TYPE_NORMAL
- en: This is purely down to Rust obeying three key rules—ownership, references (or
    borrowing, as it's more commonly known), and the application lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss and see how the three key facets work to ensure
    that your Rust application always behaves itself. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borrowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are they?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell, we can think of the three facets in these terms.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think of ownership, we inevitably think of possession. I have a MacBook
    Pro, which I'm writing this text on currently. It is not part of any finance agreement,
    stolen, borrowed, or on a lease, therefore the ownership of it is mine.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Should I sell or dispose of my computer, I will release the ownership to the
    next party, or to the recycling facilities. If my son has a DVD that I want to
    use, I will borrow it from him—he has not released ownership to me, just given
    it to me for a finite period. He will keep a record, or a reference, that I have
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is how long something lasts and, unfortunately, virtually nothing lasts
    forever. Once the application or ownership ends, the time from taking ownership
    to removing ownership, which includes the borrowing of something, is considered
    the lifetime of that object or process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider each of these facets in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to appreciate ownership, we will need to take a small detour into compilation
    abstractions and a very common pitfall.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect of any Rust application that holds it above other applications from
    other languages is that they are really fast and memory-safe. This is down to
    an ideal called a **zero-cost abstraction**. An abstraction is a way of hoisting
    a low-level construct higher, making it easier, safer, and more reliable. These
    are commonly seen in cross-platform libraries where a user interface has a common
    abstraction layer, so developers only need to say `var n = new Label {Text = "Hello"};`
    to create a label for the UI without needing to know what is going on under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: It is usual that abstractions cause some sort of penalties, meaning that code
    that uses abstractions would run slower or use more memory than corresponding
    lower-level code. In terms of Rust, these zero-cost abstractions mean that, in
    terms of computer resources, they cause no penalties. This is normally performed
    during compilation; the compiler generates the abstractions and executes them.
    Once done, the compiler will generate the best possible code.
  prefs: []
  type: TYPE_NORMAL
- en: This does have a problem—the compiler will object to code that the developer
    considers completely fine. This is because, as people, we don't think the same
    way as a language does, so what we consider as correct ownership is not how Rust
    considers it. Thankfully, as time goes on, and you use Rust more, this problem
    becomes far less of one.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership – from the beginning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by considering a very simple piece of code to help you understand
    how this works. We have seen the likes of the following plenty of times up to
    this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When `my_function` is called (it comes into scope), Rust will allocate memory
    on the stack to store this value. When the function ends (it goes out of scope),
    Rust will do an automatic cleanup to deallocate any memory used by `mypi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector, or anything else that uses the heap, works in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recall from [Chapter 5](part0106.html#352RK0-a5175cb437d742a9aed0ea574000ee2d),
    *Remember, Remember*, the vector requires memory both on the heap and on the stack
    and can be thought of like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Address | Variable name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| `heap` | `heap_posn - 1` |  | `base_of_vecs` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `heap_posn - 2` |  | `Vec[1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `my_second_function` | `0` | `myvec` | `heap_posn - 1` |'
  prefs: []
  type: TYPE_TB
- en: This time, when `my_second_function` goes out of scope, not only is the position
    on the stack cleared, but also the contiguous locations pointed to by `myvec`
    on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: I've given two examples of variables here for a good reason—the handling is
    different; a vector takes a generic parameter and these are handled differently
    to a standard variable type.
  prefs: []
  type: TYPE_NORMAL
- en: It's not quite as simple as this though, and to really understand how things
    work with ownership, we will really need to consider things on a basic level.
  prefs: []
  type: TYPE_NORMAL
- en: Variable binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the creation of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a non-mutable variable with the name `myvar`. We will then
    say that this variable has the value `10` as a 32-bit integer. In other words,
    if this was in C, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What we have actually done here is create a binding between the variable name
    and the value. We say that `10i32` is bound to `myvar`. Bindings are very important
    when it comes to ownership. Rust has a rule that you can only have something bound
    to something else once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following snippet as it demonstrates why things go wrong
    when at the zero-cost abstraction level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Normally, as a developer, you'd look at this and say that `myvec` is bound to
    a vector of type `i32`, which contains three elements. You'd then assume that
    `myothervec` is just a copy of the first vector as in the likes of C, C++, and
    C#; that is what it means. The implementation will vary, but the meaning is the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that, in Rust, what it means is that I have first created `myvec`.
    When I then say that `myothervec = myvec`, I am actually telling the compiler
    that the ownership of what `myvec` was bound to has now been given to `myothervec`
    and therefore `myvec` is out of scope and if (as a developer) I try to do anything
    with `myvec`, then the compiler is to fail the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates this (it can be found in `Chapter 8/outofscope`).
    When you attempt to build it, you will get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will get a similar sort of issue when a function takes ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following can be found in `08/function_outofscope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first look through, we don''t see the obvious transfer of ownership
    and, usually, when you pass a variable to a function, you don''t really consider
    that as a transfer. In Rust, passing a variable directly to another function is
    the same as in our first example: the ownership is released from `myvec` and passed
    to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this, try to compile the code and you will end up with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In other words, it's the same error as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and heap variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why we get this problem, we will need to understand in depth how
    Rust works, and by this I mean at memory level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As I've said, in our minds, we will create a `myvar` variable of type `i32`
    and bind it to the value `32`. Rust, on the other hand, does it differently.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it identifies that we will need space on the stack for a value that
    is the size of `i32`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it copies the value for `32` into that space allocated on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it binds the binding to the position of the stack allocated block to
    the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the complete opposite to how we do it in our minds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we create another binding, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler moves the binding to where the data sits on the stack for `myvar`
    and then says that that position (and data) belongs to `myvartwo`. The binding
    will be transferred. What happens to `myvar` though? Rust won't allow things to
    *dangle* or allow information to be bound to two different objects. Once the binding
    is transferred, `myvar` is removed.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happens if the binding points to something in the heap. Therefore,
    when we consider `let myvec = vec![1i32, 2i32, 3i32];`, `let myvec = vec![1i32,
    2i32, 3i32];` we know how this will work. The compiler knows that it requires
    space on the heap, enough to hold three elements of type `i32`. These values are
    copied into the locations and the base address of the contiguous chunk of memory
    is bound to `myvec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s transfer ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, `vectwo` is the only usable binding to the vector on the heap, and `myvec`
    gets invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common error in the likes of C# is when you have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we will get from this may not be as you would expect, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It may be expected that, as we have removed the duplicate from `dupVar`, the
    `myList` variable should still have all of the numbers it was set to originally.
    In this code, what is happening is that `dupVar` is known as a copy pointer—we
    have two variables bound to the same pointer on the stack. While it may not seem
    that big a deal, we have two variable names that are able to change data. This
    catches a lot of people out and leads to more memory and content bugs than it
    is worth.
  prefs: []
  type: TYPE_NORMAL
- en: As Rust only allows one pointer per block, we cannot have the likes of this.
    Once ownership is transferred, the original bound name can no longer be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The Copy trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this section can be found in `08/copyint` and `08/copyf32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust does have a way to create a copy of the original: the `Copy` trait (traits
    are covered in [Chapter 10](part0238.html#72V5S0-a5175cb437d742a9aed0ea574000ee2d),
    *Creating your own Crate*) and all primitives implement `Copy`. If we have something
    along the lines of `let varone = 1i32;` or `let vartwo = varone;`, then `i32`
    is a primitive type and the `vartwo` variable will contain a copy of `varone`.
    Both will have their own allocations on the stack, rather than `vartwo` pointing
    to `varone`. Ownership will not be changed; the value is duplicated and bound
    to the new variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section can be found in the `08/copyint` and `08/copyf32` folders
    in the supporting code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output when compiled (`numone` is
    an `i32` value, which is a primitive, so it makes a copy of itself when passed
    to `do_something` with an `i32` being returned into `numtwo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `copyf32` example shows the same `Copy` trait in action but for an `f32`
    primitive.
  prefs: []
  type: TYPE_NORMAL
- en: There must be a way around this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, we''ve seen an answer already in many examples used throughout this
    book—we hand the ownership back; however, as the following code block shows, it
    can get a bit messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code for this section can be found in the `Chapter8/handback` folder in
    the supporting code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Rust does provide a neater way to pass ownership around. Instead
    of giving ownership, we can borrow ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Way back in Chapter 2, *Variables*, we referred to something known as a reference
    and it was said to be a copy of the pointer to some memory location. This is a
    big part of what is meant by borrowing in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding example, we can make use of borrowing. Our code for it is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code for this section can be found in the `08/handback` folder which can
    be found in the supporting code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will no longer pass ownership, but rather we will pass the reference to
    the vector. When compiled, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Borrow immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look back to the start of this chapter, I described borrowing as borrowing
    a DVD from my son. When I take possession of the DVD, I cannot change it, as my
    son would expect the same DVD back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies for Rust: the references cannot be changed as they are immutable
    values. If you think about it, this makes sense. Let me explain.'
  prefs: []
  type: TYPE_NORMAL
- en: I have created a `Vec<T>` array type, which is, let's say, eight values long
    (it doesn't matter what the values are or the type they are). When the binding
    between the heap and stack is made, it will be of a particular type. If we allow
    the reference to alter the vector, we will have the same problem as the C# example
    and so the guarantees can't be assured and the Rust compiler will fail the build.
    To ensure that the guarantee is kept, Rust simply says that you are unable to
    change the values borrowed.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable borrows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is more a writable DVD than a prerecorded one if we use the analogy of
    borrowing a DVD.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using a mutable reference, and we have to be careful how we use
    these.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is in the `08/mutableref1` and `08/mutableref2` folders
    in the supporting code bundle provided for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first example `(mutableref1`), we will create a variable, the reference,
    do something, and get a new value out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The important line here is `*y += 1`; and, in particular, the `*`, as this means
    we're directly altering the value of the memory position that the reference points
    to. When dealing with anything to do with memory, absolute care has to be observed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second important point to observe is that we have a set of braces around
    the code used in the mutable reference. Remove them and everything fails (`mutableref2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The important line is the result of the error; it is saying that you cannot
    borrow the same item as both mutable and immutable at the same time. It's like
    saying you can borrow something that can and can't be changed at the same time!
    Utter nonsense. This is down to borrowing having rules.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust borrowing rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two rules that must be observed with borrowing, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What you borrow must not outlive the original
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can have one of the following types of borrow, but never at the same time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One (or more) references of type `&T` to a resource
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one mutable reference
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first rule makes sense: you can''t have the reference outlive where it
    came from as once where it comes from goes out of scope, it is destroyed and,
    once destroyed, what are you borrowing exactly?'
  prefs: []
  type: TYPE_NORMAL
- en: The second one requires a bit more thought about why it is as it should be and
    what it is that Rust is trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Rust is ensuring that something known as a **race condition**
    occurs (if you are used to writing multithreaded applications, you'll already
    understand these).
  prefs: []
  type: TYPE_NORMAL
- en: Here, Rust is trying to prevent two references trying to access the same point
    of memory at the same time. In other words, Rust is trying to prevent a synchronization
    error.
  prefs: []
  type: TYPE_NORMAL
- en: With non-mutable references, you can have as many as you'd like, as the references
    can never be written to. With a mutable reference, Rust prevents the problem by
    allowing just a single reference to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, can we use these rules to fix our code from `mutableref2`
    in order to do away with the `{}` braces around the mutable reference?
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the code again (I''ve removed anything from the original that
    is not required here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try and compile, we get the following output returned from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have broken the second rule—you can only have a single mutable or many immutables,
    never both.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we solve this? Let''s look back to the original `mutableref1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This works, but why?
  prefs: []
  type: TYPE_NORMAL
- en: Think about the scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is actually happening with this code is that we created a new scope for
    the borrowing section of the code, which passes back in to `mutvar` before the
    final `println!` is reached. In other words, the scope changes; therefore, when
    `mutvar` is hit on the `println!`, no borrowing is occurring and we're just displaying
    whatever is bound to the `mutvar` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to remove the braces, we will have to ensure that the borrowing has
    finished before we output through `println!`
  prefs: []
  type: TYPE_NORMAL
- en: It's all for your own good
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These compiler rules are there to help you as a developer. They prevent the
    sorts of issues commonly found in other languages, the biggest being writing to
    a variable after it is destroyed or doing something stupid, such as trying to
    mutate a vector inside of a loop iterating through that vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The source for this section is in the `08/invaliditerator` folder in the supporting
    code bundle for this book, with additional discussion in Chapter 5, *Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is obviously never going to work. If you think about it, we have a loop
    that takes `myvec` as the argument and then, within the loop, we will add to the
    vector, so the loop never knows about one of the guarantees, as that guarantee
    is not there: the iterator count. It won''t build as well because we are breaking
    the second borrowing rule.'
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider another piece of code which won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying to build this piece of code, the compiler will complain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may recall that we had something similar to the following piece of code
    back in Chapter 4, *Conditions, Recursion, and Loops*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In Chapter 5, *Memory Management*, we then explained why the preceding code
    would not work.
  prefs: []
  type: TYPE_NORMAL
- en: We are assigning `y` to the value of a variable that only exists in a small
    scope and then trying to access that value, which is giving rise to undefined
    behavior. As we've seen, the Rust compiler will do everything it can to prevent
    this sort of error. In this case, the compiler keeps track of each and every reference
    and fails to build if a reference lasts longer than the pointer in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the same happening here: `varname` is declared before `x`; therefore,
    it lives longer than `x`, which is what gives rise to the error.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is a simple demonstration of a lifetime, but it's not as
    simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: The mythical bank account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate a more complex problem with lifetimes, let''s consider a mythical
    bank account:'
  prefs: []
  type: TYPE_NORMAL
- en: I am given access to a bank account, legally, of course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I decide that I want my friend to have access to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a certain amount of time, I decide I no longer want access to the account
    and have my access removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My friend then tries to use the account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When my friend comes to use the account, he is unable to do so, as the reference
    I had, and which was passed to him, no longer exists. He is trying to *use after
    free* (in programming terms) and he is known here as a **dangling reference**.
  prefs: []
  type: TYPE_NORMAL
- en: It sounds far-fetched, but in development terms, it happens far more frequently
    than you would possibly give credit for.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime variable - '
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two types of lifetime within Rust—implicit and explicit. We have seen
    the implicit functions plenty of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The lifetime of the function is the length of time the code inside of the braces
    exists once it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have an explicit lifetime, denoted by `''` before the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, what exactly does the `'a` mean?
  prefs: []
  type: TYPE_NORMAL
- en: It means, for the lifetime of `a`. The `<>` after `expfunction` means that the
    function is taking a generic parameter (these will all become clear in Chapter
    9, *Generics and Traits*), but it means of a type. If you consider `Vec`, it is
    actually `Vec<T>`. When we create a vector of type `f32`, `T` becomes `f32`, so
    it's `Vec<f32>` when it comes to compile time. In the case of `expfunction`, `T`
    is `'a`, and therefore the type inside the `()` has to also be `'a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had another parameter within the `<>`, we would have `<''a, ''b>(f: &''a
    f32, g: &''b i32)`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime of other types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will commonly see lifetimes expressed with the likes of `struct` and `impl`
    (`impl` and the `impl` lifetime are dealt with in Chapter 10, *Matching and Structures*).
    You can have multiple lifetimes used as well.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime within an struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in Chapter 7, *Structs*, within Rust have a special purpose and they
    can also take multiple types within them and can be extended as much as required
    with as many parameters as required. Let''s consider the following piece of code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a `struct` called `MyStruct` with three properties
    called `a`, `b`, and `c`. When an instance of `mystruct` is called into scope,
    the elements within `struct` can be readily accessed. If we want `struct` to be
    able to take a lifetime variable, we will have to both explicitly ask `struct`
    to take that lifetime variable and then allocate it to an element, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the lifetime variable in there, we can be assured that the structure cannot
    outlive the `f32` reference it was passed to.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both of these are acceptable to define multiple lifetimes within a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have two parameters of the lifetime of `'a` cast as an `i32` value and return
    an `i32` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also have multiple lifetimes passed in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Always consider the scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with borrowing, we have to consider the scope to ensure that things work
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code, for example, won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code for this section is in the `08/lifetimescope` folder of the supporting
    code bundle provided along with this book.
  prefs: []
  type: TYPE_NORMAL
- en: It may not seem obvious at first why this should not work. In terms of scope,
    `f` is created after `y`, so is in the scope of `y` and `y` is created within
    the scope of `x`. Or is it?
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is built, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The error will be the `x = &f.lifea`, as we attempted to assign a value of something
    about to go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '''struct'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect of many languages that is useful is to have a variable that lives
    for the lifetime of the entire application. While some purists argue that having
    a variable that lasts for the life of an application is not good practice, they
    cannot argue that it has its uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Rust, we can also do this using a special `struct` type, a lifetime
    `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Local type inference allows us to omit the type when it is not global, so this
    is equivalent to the above when inside a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Input and output lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although not commonly considered, there are two types of lifetimes: input (going
    into the function) and output (coming out of the function).'
  prefs: []
  type: TYPE_NORMAL
- en: Input only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of a function with an input lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Output only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of a function with an output lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of a function with both input and
    output lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can conclude the following from the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Each lifetime in the function argument becomes a distinct lifetime parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is one input lifetime, the lifetime is assigned to all lifetimes in
    the return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another concept that we will need to include: if there are multiple
    input lifetimes and one of them points to `&self` (either mutable or immutable),
    the lifetime of self applies to all output lifetimes.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding how Rust deals with the lifetime of variables is of key importance
    in ensuring that as few mistakes as possible are made when creating your Rust
    applications. We have considered how information is moved around functions and
    seen how the Rust model ensures that we are never left with dangling references
    or code that is addressing a memory location that no longer belongs to the variable.
    We have also seen how Rust removes the ability to have data-race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will consider generic types, their importance to your
    Rust application, and how the compiler deals with them.
  prefs: []
  type: TYPE_NORMAL
