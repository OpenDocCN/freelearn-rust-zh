<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting Ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this guide, we're going to learn the basics of working with Rust, a systems-level programming language that has been making a name for itself over the last few years. Rust is a strict language, designed to make the most common errors impossible and less common errors obvious.</p>
<p class="mce-root">Being a systems-level language means that Rust is guided by the needs of low-level programs that don't have a safety net, because they <em>are </em>the safety net for higher-level programs. Operating system kernels, web browsers, and other critical pieces of infrastructure are systems-level applications.</p>
<p class="mce-root">This is not to say that Rust can only be used for writing critical infrastructure, of course. The efficiency and reliability of Rust code can benefit any program. It's just that the priorities for higher-level code can be different.</p>
<p>In this chapter, we're going to cover the following topics:</p>
<ul>
<li>The <kbd>rustup</kbd> tool</li>
<li>The <kbd>cargo</kbd> tool</li>
<li>How to start a new Rust project</li>
<li>How to compile a Rust project</li>
<li>How to locate third-party libraries</li>
<li>How to manage dependencies</li>
<li>How to keep a Rust installation up-to-date</li>
<li>How to switch between stable and beta Rust</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Rust</h1>
                </header>
            
            <article>
                
<p class="mce-root CDPAlignLeft CDPAlign">Installing Rust on any supported platform is simple. All we need to do is navigate to <a href="https://rustup.rs/">https://rustup.rs/</a>. That page will give us a single-step procedure to install the command-line Rust compiler. The procedure differs slightly depending on the platform, but it's never difficult. Here we see the <kbd>rustup.rs</kbd> page for Linux:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="Images/a5afd80a-e6dc-4335-ab7b-10aaad3b9236.png" style="width:35.50em;height:36.67em;" width="772" height="797"/></p>
<p class="mce-root">The installer doesn't just install the Rust compiler, it also installs a tool called <kbd>rustup</kbd> that can be used at any time to upgrade our compiler to the latest version. To do this, all we have to do is open up a command-line (or Terminal) window, and type: <kbd>rustup update</kbd>.</p>
<p class="mce-root">Upgrading the compiler needs to be simple because the Rust project uses a six-week rapid release schedule, meaning there's a new version of the compiler every six weeks, like clockwork. Each release contains whatever new features have been deemed to be stable in the six weeks since the previous release, in addition to the features of previous releases.</p>
<div class="mce-root packt_infobox">Don't worry, the rapid release of new features doesn't mean that those features were slapped together in the six weeks prior to the release. It's common for them to have spent years in development and testing prior to that. The release schedule just makes sure that, once a feature is deemed to be truly stable, it doesn't take long to get into our hands.</div>
<p class="mce-root">If we aren't willing to wait for a feature to be vetted and stabilized, for whatever reason, we can also use <kbd>rustup</kbd> to download, install, and update the <em>beta</em> or <em>nightly</em> releases of the compiler.</p>
<p class="mce-root">To download and install the beta compiler, we just need to type this: <kbd>rustup toolchain install beta</kbd>.</p>
<p class="mce-root">From that point on, when we use <kbd>rustup</kbd> to update our compiler, it will make sure that we have the newest versions of both the stable and beta compilers. We can then make the beta compiler active with <span class="packt_screen"><kbd>rustup default beta</kbd></span>.</p>
<p class="mce-root">Please note that the beta compiler is not the same thing as the next release of the stable compiler. The beta version is where features live before they graduate to stable, and features can and do remain in beta for years.</p>
<p class="mce-root">The nightly version is at most 24 hours behind the development code repository, which means that it might be broken in any number of ways. It's not particularly useful unless you're actually participating in the development of Rust itself. However, should you want to try it out, <kbd>rustup</kbd> can install and update it as well. You might also find yourself depending on a library that someone else has written that depends on features that only exist in the nightly build, in which case you'll need to tell <kbd>rustup</kbd> that you need the nightly build, too.</p>
<p>One of the things <kbd>rustup</kbd> will install is a tool called <kbd>cargo</kbd>, which we'll be seeing a lot of in this chapter, and using behind the scenes for the rest of this book. The <kbd>cargo</kbd> tool is the frontend to the whole Rust compiler system: it is used for creating new Rust project directories containing the initial boilerplate code for a program or library, for installing and managing dependencies, and for compiling Rust programs, among other things.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting a new project</h1>
                </header>
            
            <article>
                
<p class="mce-root">Okay, so we've installed the compiler. Yay! But how do we use it?</p>
<p class="mce-root">The first step is to open up a command-line window, and navigate to the directory where we want to store our new project. Then we can create the skeleton of a new program with <kbd>cargo new foo</kbd>.</p>
<p class="mce-root">When we do this, <kbd>cargo</kbd> will create a new directory named <kbd>foo</kbd> and set up the skeletal program inside it.</p>
<p class="mce-root">The default is for <kbd>cargo</kbd> to create the skeleton of an executable program, but we can also tell it to set up a new library for us. All that takes is an additional command-line argument (<kbd>bar</kbd> is the name of the new directory that will be created, like <kbd>foo</kbd>):<span class="packt_screen"> <kbd>cargo new --lib bar</kbd></span>.</p>
<p class="mce-root">When we look inside the newly created <kbd>foo</kbd> directory, we see a file called <kbd>Cargo.toml</kbd> and a sub-directory called <kbd>src</kbd>. There may also be a Git version control repository, which we will ignore for now.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project metadata</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Cargo.toml</kbd> file is where metadata about the program is stored. That includes the program's name, version number, and authors, but importantly it also has a section for dependencies. Editing the content of the <kbd>[dependencies]</kbd> section is how we tell Rust that our code should be linked to external libraries when it is compiled, which libraries and versions to use, and where to find them. External libraries are collections of source code that were packaged up in order to make them easy to use as components of other programs. By finding and linking good libraries, we can save the time and effort of writing our whole program ourselves. Instead, we can write only the part that nobody else has already done.</p>
<div class="mce-root packt_infobox">By the way, <kbd>.toml</kbd> files are written in <strong>Tom's Obvious, Minimal Language</strong> (<strong>TOML</strong>), a more well-defined and feature-complete version of the old <kbd>.ini</kbd> format that Microsoft popularized but never standardized. TOML is becoming quite popular, and is supported and used in a wide variety of languages and applications. You can find the language specification at <a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>.<a href="https://github.com/toml-lang/toml"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependencies on libraries from crates.io</h1>
                </header>
            
            <article>
                
<p class="mce-root">If a library that our program depends on is published on <a href="https://crates.io/">https://crates.io/</a>, all we have to do to link it is add its linking code to the dependencies section. Let's say we want to use <strong>serde </strong>(a tool for turning Rust data into formats such as JSON and back) in our program. First, we find its linking code with:<span class="packt_screen"> <kbd>cargo search serde</kbd></span>.</p>
<div class="packt_tip">I originally found out about <strong>serde</strong> by browsing through <kbd>crates.io</kbd>, an exploration that I would encourage you to try as well.</div>
<p class="mce-root">This will print out a list of matches that looks something like this:</p>
<pre class="mce-root"><br/>     serde = "1.0.70"                          # A generic serialization/deserialization framework<br/>     serde_json = "1.0.24"                 # A JSON serialization file format<br/>     serde_derive_internals = "0.23.1"     # AST representation used by Serde derive macros. Unstable.<br/>     serde_any = "0.5.0"                   # Dynamic serialization and deserialization with the format chosen at runtime<br/>     serde_yaml = "0.7.5"                 # YAML support for Serde<br/>     serde_bytes = "0.10.4"              # Optimized handling of `&amp;[u8]` and `Vec&lt;u8&gt;` for Serde<br/>     serde_traitobject = "0.1.0"       # Serializable trait objects.  This library enables the serialization of trait objects such…<br/>     cargo-ssearch = "0.1.2"             # cargo-ssearch: cargo search on steroids<br/>     serde_codegen_internals = "0.14.2"    # AST representation used by Serde codegen. Unstable.<br/>     serde_millis = "0.1.1"                #     A serde wrapper that stores integer millisecond value for timestamps     and duration…<br/>     ... and 458 crates more (use --limit N to see more)</pre>
<p class="mce-root">The first one is the core <kbd>serde</kbd> library, and the linking code is the part of the line before the <kbd>#</kbd> symbol. All we have to do is copy and paste that into the dependencies section of <kbd>Cargo.toml</kbd>, and Rust will know that it should compile and link <kbd>serde</kbd> when it compiles our <kbd>foo</kbd> program. So, the dependencies section of <kbd>Cargo.toml</kbd> would look like this:</p>
<pre class="mce-root"> [dependencies]<br/> serde = "1.0.70"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependencies on Git repositories</h1>
                </header>
            
            <article>
                
<p class="mce-root">Depending on a library stored in the Git version control system, either locally or remotely, is also easy. The linking code is slightly different, but it looks like this:</p>
<pre class="mce-root">    [dependencies]<br/>    thing = { git = "https://github.com/example/thing" }</pre>
<p class="mce-root">We tell Rust where to find the repository, and it knows how to check it out, compile it, and link it with our program. The repository location doesn't have to be a URL; it can be any repository location that the <kbd>git</kbd> command recognizes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependencies on local libraries</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can also link against other libraries stored on our own systems, of course. To do this, we just have to add an entry such as this to our <kbd>Cargo.toml</kbd> file:</p>
<pre class="mce-root"><br/>     [dependencies]<br/>     example = { path = "/path/to/example" }</pre>
<p class="mce-root">The path can be absolute or relative. If it's relative, it's interpreted as being relative to the directory containing our <kbd>Cargo.toml</kbd> file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Automatically generated source files</h1>
                </header>
            
            <article>
                
<p class="mce-root">When creating an executable program, <kbd>cargo</kbd> adds a file called <kbd>main.rs</kbd> to our project as it is created. For a newly created library, it instead adds <kbd>lib.rs</kbd>. In either case, that file is the entry point for the whole project.</p>
<p class="mce-root">Let's take a look at the boilerplate <kbd>main.rs</kbd> file:</p>
<pre class="mce-root">     fn main() {<br/>         println!("Hello, world!");<br/>     }</pre>
<p class="mce-root">Simple enough, right? Cargo's default program is a Rust version of the classic <kbd>hello world</kbd> program, which has been re-implemented countless times by new programmers in every conceivable programming language.</p>
<p class="mce-root">If we look at a new library's <kbd>lib.rs</kbd> file, things are a little more interesting:</p>
<pre class="mce-root">     #[cfg(test)]<br/>     mod tests {<br/>         #[test]<br/>         fn it_works() {<br/>             assert_eq!(2 + 2, 4);<br/>         }<br/>     }</pre>
<p class="mce-root">Instead of having a main function, which all executable programs need because they need a place to start, the library boilerplate includes a framework for automated tests and a single test that confirms that <kbd>2 + 2 = 4</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compiling our project</h1>
                </header>
            
            <article>
                
<p class="mce-root">The basic command to compile a Rust program is simple: <kbd>cargo build.</kbd></p>
<p class="mce-root CDPAlignLeft CDPAlign">We need to be in the directory containing <kbd>Cargo.toml</kbd> (or any subdirectory of that directory) in order to be able to do this, since that's how the <kbd>cargo</kbd> program knows which project to compile. However, we don't need to give it any other information, since everything it needs to know is in the metadata file. </p>
<p class="mce-root CDPAlignLeft CDPAlign">Here, we see the result of building the <kbd>chapter02</kbd> source code:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="Images/93e50d15-c345-4d6e-b2b1-319f3a6921f2.png" style="width:48.50em;height:34.33em;" width="1027" height="728"/></p>
<p><span>The warnings are expected and do not prevent the compile from succeeding. </span>If we look at those warnings carefully, we can see that Rust is a lot more helpful with its warnings than many programming languages, giving us hints for improving efficiency and such, rather than just talking about language syntax.</p>
<p class="mce-root">When we build the program, a <kbd>Cargo.lock</kbd> file and <kbd>target</kbd> directory are created.</p>
<p class="mce-root"><kbd>Cargo.lock</kbd> records the exact versions of dependencies that were used to build the project, which makes it much easier to produce repeatable results from different compilations of the same program. It's largely safe to ignore this file, as <kbd>cargo</kbd> will usually take care of anything that needs to be done with it.</p>
<p class="mce-root">The Rust community recommends that the <kbd>Cargo.lock</kbd> file should be added to your version control system (Git, for example) if your project is a program, but not if your project is a library. That's because a program's <kbd>Cargo.lock</kbd> file stores all of the versions that resulted in a successful compile of a complete program, where a library's only encompasses part of the picture, and so can lead to more confusion than help when distributed to others.</p>
<p class="mce-root">The <kbd>target</kbd> directory contains all of the build artifacts and intermediate files resulting from the compilation process, as well as the final program file. Storing the intermediate files allows future compiles to process only those files that need to be processed, and so speeds up the compilation process.</p>
<p class="mce-root">Our program itself is in the <kbd>target/debug/foo</kbd> file (or <kbd>target\debug\foo.exe</kbd> on Windows) and we can navigate to it and run it manually if we want to. However, <kbd>cargo</kbd> provides a shortcut:<span class="packt_screen"> <kbd>cargo run</kbd></span>.</p>
<p class="mce-root">We can use that command from any subdirectory of our project, and it will find and run our program for us.</p>
<p class="mce-root">Additionally, <kbd>cargo run</kbd> implies <kbd>cargo build</kbd>, meaning that if we've changed the source code since the last time we ran the program, <kbd>cargo run</kbd> will recompile the program before running it. That means we can just alternate between making changes to our code and executing it with <kbd>cargo run</kbd> to see it in action.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Debug and release builds</h1>
                </header>
            
            <article>
                
<p class="mce-root">You may have noticed that the program was in a directory called <kbd>target/debug</kbd>. What's that about? By default, <kbd>cargo</kbd> builds our program in debug mode, which is what a programmer normally wants.</p>
<p class="mce-root">That means that the resulting program is instrumented to work with the <kbd>rust-gdb</kbd> debugging program so we can examine what is happening in its internals, and to provide useful information in crash dumps and such, as well as skipping the compiler's optimization phase. The optimizations are skipped because they rearrange things in such a way that it makes debugging information almost incomprehensible.</p>
<p class="mce-root">However, sometimes a program doesn't have any more bugs (that we know about) and we're ready to ship it out to others. To construct our final, optimized version of the program, we use <kbd><span>cargo build --release</span></kbd>.</p>
<p class="mce-root">This will construct the release version of the program, and leave it in <kbd>target/release/foo</kbd>. We can copy it from there and package it up for distribution.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dynamic libraries, software distribution, and Rust</h1>
                </header>
            
            <article>
                
<p class="mce-root">For the most part, Rust avoids using dynamic libraries. Instead, all of the dependencies of a Rust program are linked directly into the executable, and only select operating system libraries are dynamically linked. This makes Rust programs a little larger than you might expect, but a few megabytes are of no concern in the era of gigabytes. In exchange, Rust programs are very portable and immune to dynamically linked library version issues.</p>
<p class="mce-root">That means that, if a Rust program works at all, it's going to work on pretty much any computer running roughly the same operating system and architecture it was compiled for, with no hassles. You can take your release version of a Rust program, zip it up, and email it to someone else with confidence that they will have no problem running it.</p>
<p class="mce-root">This doesn't entirely eliminate external dependencies. If your program is a client, the server it connects to needs to be available, for example. However, it does greatly simplify the whole packaging and distribution process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using crates.io</h1>
                </header>
            
            <article>
                
<p class="mce-root">We saw <kbd>cargo search</kbd> earlier, which allowed us a quick and easy way to find third-party libraries from the command line, so that we could link them with our own program. That's very useful, but sometimes we want a little more information than what that provides. It's really most useful when we know exactly which library we want and just need a quick reference to the linking code.</p>
<p class="mce-root">When we <em>don't</em> know exactly what we want, it's usually better to use a web browser to look around <a href="https://crates.io/">https://crates.io/</a> and find options.</p>
<p class="mce-root">When we find an interesting or useful library in the web browser, we get the following:</p>
<ul>
<li class="mce-root">The linking code</li>
<li class="mce-root">Introductory information</li>
<li class="mce-root">Documentation</li>
<li class="mce-root">Popularity statistics</li>
<li class="mce-root">Version history</li>
<li class="mce-root">License information</li>
<li class="mce-root">A link to the library's web site</li>
<li class="mce-root">A link to the source code</li>
</ul>
<p class="mce-root"/>
<p>This richer information is useful for figuring out which library or libraries are best suited to our projects. Picking the best libraries for the job saves a lot of time in the end, so the web interface to <kbd>crates.io</kbd> is great.</p>
<p class="mce-root">The front page of <kbd>crates.io</kbd> shows new and popular libraries, divided up in several ways, and these can be interesting and useful to explore. However, the main value is the search box. Using the search box, we can usually find several candidates for any library needs we may have.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">So, now we know how to install the Rust compiler, set up a Rust project, find and link useful third-party libraries, and compile source code into a usable program. We've also taken a basic look at the boilerplate code that <kbd>cargo</kbd> generates when we ask it to set up a new program or library project for us. We've learned about the difference between a debugging build and a release build and taken a quick look at what's involved in distributing a Rust program to users.</p>
<p class="mce-root">Coming up in <a href="ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml" target="_blank">Chapter 2</a>, <em>Basics of the Rust Language</em>, we're going to begin looking at the Rust programming language itself, rather than the support facilities that surround it. We're going to see how the language is structured and some of the most important commands.</p>


            </article>

            
        </section>
    </div>



  </body></html>