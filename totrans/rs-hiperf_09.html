<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Your Own Macros</h1>
                
            
            
                
<p class="mce-root">In previous chapters, we saw how macros and metaprogramming, in general, can make your life much easier. We saw both, macros that reduce the required boilerplate code and macros that will speed up your final code. It's time for you to learn how to create your own macros.</p>
<p>In this chapter, you will learn how to create your own standard macros, how to create your own procedural macros and custom derives, and finally, how to use nightly features to create your own plugins. You will also see how the new declarative macros work.</p>
<p>The chapter is divided into three sections:</p>
<ul>
<li><strong>Macrosystem</strong>: Understanding the <kbd>macro_rules!{}</kbd> macro</li>
<li><strong>Procedural macros</strong>: Learning how to create your own custom derives</li>
<li><strong>Nightly metaprogramming</strong>: Plugins and declarative macros</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating your own standard macros</h1>
                
            
            
                
<p>Since Rust 1.0, we have had a great macro system. Macros allow us to apply some code to multiple types or expressions, as they work by expanding themselves at compile time. This means that when you use a macro, you are effectively writing a lot of code before the actual compilation starts. This has two main benefits, first, the codebase can be easier to maintain by being smaller and reusing code, and second, since macros expand before starting the creation of object code, you can abstract at the syntactic level.</p>
<p>For example, you can have a function like this one:</p>
<pre style="padding-left: 60px">fn add_one(input: u32) -&gt; u32 {<br/>    input + 1<br/>}</pre>
<p>This function restricts the input to <kbd>u32</kbd> types and the return type to <kbd>u32</kbd>. We could add some more accepted types by using generics, which may accept <kbd>&amp;u32</kbd> if we use the <kbd>Add</kbd> trait. Macros allow us to create this kind of code for any element that can be written to the left of the <kbd>+</kbd> sign and it will be expanded differently for each type of element, creating different code for each case.</p>
<p>To create a macro, you will need to use a macro built in to the language, the <kbd>macro_rules!{}</kbd> macro. This macro receives the name of the new macro as a first parameter and a block with the macro code as a second element. The syntax can be a bit complex the first time you see it, but it can be learned quickly. Let's start with a macro that does just the same as the function we saw before:</p>
<pre style="padding-left: 60px">macro_rules! add_one {<br/>    ($input:expr) =&gt; {<br/>        $input + 1<br/>    }<br/>}</pre>
<p>You can now call that macro from your <kbd>main()</kbd> function by calling <kbd>add_one!(integer);</kbd>. Note that the macro needs to be defined before the first call, even if it's in the same file. It will work with any integer, which wasn't possible with functions.</p>
<p>Let's analyze how the syntax works. In the block after the name of the new macro (<kbd>add_one</kbd>), we can see two sections. In the first part, on the left of the <kbd>=&gt;</kbd>, we see <kbd>$input:expr</kbd> inside parentheses. Then, to the right, we see a Rust block where we do the actual addition.</p>
<p>The left part works similarly (in some ways) to a pattern match. You can add any combination of characters and then some variables, all of them starting with a dollar sign (<kbd>$</kbd>) and showing the type of variable after a colon. In this case, the only variable is the <kbd>$input</kbd> variable and it's an expression. This means that you can insert any kind of expression there and it will be written in the code to the right, substituting the variable with the expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Macro variants</h1>
                
            
            
                
<p>As you can see, it's not as complicated as you might think. As I wrote, you can have almost any pattern to the left of the <kbd>macro_rules!{}</kbd> side. Not only that, you can also have multiple patterns, as if it were a match statement, so that if one of them matches, it will be the one expanded. Let's see how this works by creating a macro which, depending on how we call it, will add one or two to the given integer:</p>
<pre style="padding-left: 60px">macro_rules! add {<br/>    {one to $input:expr} =&gt; ($input + 1);<br/>    {two to $input:expr} =&gt; ($input + 2);<br/>}<br/><br/>fn main() {<br/>    println!("Add one: {}", add!(one to 25/5));<br/>    println!("Add two: {}", add!(two to 25/5));<br/>}</pre>
<p>You can see a couple of clear changes to the macro. First, we swapped braces for parentheses and parentheses for braces in the macro. This is because in a macro, you can use interchangeable braces (<kbd>{</kbd> and <kbd>}</kbd>), square brackets (<kbd>[</kbd> and <kbd>]</kbd>), and parentheses (<kbd>(</kbd> and <kbd>)</kbd>). Not only that, you can use them when calling the macro. You have probably already used the <kbd>vec![]</kbd> macro and the <kbd>format!()</kbd> macro, and we saw the <kbd>lazy_static!{}</kbd> macro in the last chapter. We use brackets and parentheses here just for convention, but we could call the <kbd>vec!{}</kbd> or the <kbd>format![]</kbd> macros the same way, because we can use braces, brackets, and parentheses in any macro call.</p>
<p>The second change was to add some extra text to our left-hand side patterns. We now call our macro by writing the text <kbd>one to</kbd> or <kbd>two to</kbd>, so I also removed the <kbd>one</kbd> redundancy to the macro name and called it <kbd>add!()</kbd>. This means that we now call our macro with literal text. That is not valid Rust, but since we are using a macro, we modify the code we are writing before the compiler tries to understand actual Rust code and the generated code is valid. We could add any text that does not end the pattern (such as parentheses or braces) to the pattern.</p>
<p>The final change was to add a second possible pattern. We can now add one or two and the only difference will be that the right side of the macro definition must now end with a trailing semicolon for each pattern (the last one is optional) to separate each of the options.</p>
<p>A small detail that I also added in the example was when calling the macro in the <kbd>main()</kbd> function. As you can see, I could have added <kbd>one</kbd> or <kbd>two</kbd> to <kbd>5</kbd>, but I wrote <kbd>25/5</kbd> for a reason. When compiling this code, this will be expanded to <kbd>25/5 + 1</kbd> (or <kbd>2</kbd>, if you use the second variant). This will later be optimized at compile time, since it will know that <kbd>25/5 + 1</kbd> is <kbd>6</kbd>, but the compiler will receive that expression, not the final result. The macro system will not calculate the result of the expression; it will simply copy in the resulting code whatever you give to it and then pass it to the next compiler phase.</p>
<p>You should be especially careful with this when a macro you are creating calls another macro. They will get expanded recursively, one inside the other, so the compiler will receive a bunch of final Rust code that will need to be optimized. Issues related to this were found in the CLAP crate that we saw in the last chapter, since the exponential expansions were adding a lot of bloat code to their executables. Once they found out that there were too many macro expansions inside the other macros and fixed it, they reduced the size of their binary contributions by more than 50%.</p>
<p>Macros allow for an extra layer of customization. You can repeat arguments more than once. This is common, for example, in the <kbd>vec![]</kbd> macro, where you create a new vector with information at compile time. You can write something like <kbd>vec![3, 4, 76, 87];</kbd>. How does the <kbd>vec![]</kbd> macro handle an unspecified number of arguments?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Complex macros</h1>
                
            
            
                
<p>We can specify that we want multiple expressions in the left-hand side pattern of the macro definition by adding a <kbd>*</kbd> for <em>zero or more</em> matches or a <kbd>+</kbd> for <em>one or more</em> matches. Let's see how we can do that with a simplified <kbd>my_vec![]</kbd> macro:</p>
<pre style="padding-left: 60px">macro_rules! my_vec {<br/>    ($($x: expr),*) =&gt; {{<br/>        let mut vector = Vec::new();<br/>        $(vector.push($x);)*<br/>        vector<br/>    }}<br/>}</pre>
<p>Let's see what is happening here. First, we see that on the left side, we have two variables, denoted by the two <kbd>$</kbd> signs. The first makes reference to the actual repetition. Each comma-separated expression will generate a <kbd>$x</kbd> variable. Then, on the right side, we use the various repetitions to push <kbd>$x</kbd> to the vector once for every expression we receive.</p>
<p>There is another new thing on the right-hand side. As you can see, the macro expansion starts and ends with a double brace instead of using only one. This is because, once the macro gets expanded, it will substitute the given expression for a new expression: the one that gets generated. Since what we want is to return the vector we are creating, we need a new scope where the last sentence will be the value of the scope once it gets executed. You will be able to see it more clearly in the next code snippet.</p>
<p>We can call this code with the <kbd>main()</kbd> function:</p>
<pre style="padding-left: 60px">fn main() {<br/>    let my_vector = my_vec![4, 8, 15, 16, 23, 42];<br/>    println!("Vector test: {:?}", my_vector);<br/>}</pre>
<p>It will be expanded to this code:</p>
<pre style="padding-left: 60px">fn main() {<br/>    let my_vector = {<br/>        let mut vector = Vec::new();<br/>        vector.push(4);<br/>        vector.push(8);<br/>        vector.push(15);<br/>        vector.push(16);<br/>        vector.push(23);<br/>        vector.push(42);<br/>        vector<br/>    };<br/>    println!("Vector test: {:?}", my_vector);<br/>}</pre>
<p>As you can see, we need those extra braces to create the scope that will return the vector so that it gets assigned to the <kbd>my_vector</kbd> binding.</p>
<p>You can have multiple repetition patterns on the left expression and they will be repeated for every use, as needed on the right. There is a nice example illustrating this behavior in the first edition of the official Rust book, which I have adapted here:</p>
<pre style="padding-left: 60px">macro_rules! add_to_vec {<br/>    ($( $x:expr; [ $( $y:expr ),* ]);* ) =&gt; {<br/>        &amp;[ $($( $x + $y ),*),* ]<br/>    }<br/>}</pre>
<p>In this example, the macro can receive one or more <kbd>$x; [$y1, $y2,...]</kbd> input. So, for each input, it will have one expression, then a semicolon, then a bracket with multiple sub-expressions separated by a comma, and finally, another bracket and a semicolon. But what does the macro do with this input? Let's check to the right-hand side of it.</p>
<p>As you can see, this will create multiple repetitions. We can see that it creates a slice (<kbd>&amp;[T]</kbd>) of whatever we feed to it, so all the expressions we use must be of the same type. Then, it will start iterating over all <kbd>$x</kbd> variables, one per input group. So if we feed it only one input, it will iterate once for the expression to the left of the semicolon. Then, it will iterate once for every <kbd>$y</kbd> expression associated with the <kbd>$x</kbd> expression, add them to the <kbd>+</kbd> operator, and include the result in the slice.</p>
<p>If this was too complex to understand, let's look at an example. Let's suppose we call the macro with <kbd>65; [22, 34]</kbd> as input. In this case, <kbd>65</kbd> will be <kbd>$x</kbd>, and <kbd>22</kbd>, <kbd>24</kbd>, and so on will be <kbd>$y</kbd> variables associated with <kbd>65</kbd>. So, the result will be a slice like this: <kbd>&amp;[65+22, 65+34]</kbd>. Or, if we calculate the results: <kbd>&amp;[87, 99]</kbd>.</p>
<p>If, on the other hand, we give two groups of variables by using <kbd>65; [22, 34]; 23; [56, 35]</kbd> as input, in the first iteration, <kbd>$x</kbd> will be <kbd>65</kbd>, while in the second one, it will be <kbd>23</kbd>. The <kbd>$y</kbd> variables of <kbd>64</kbd> will be <kbd>22</kbd> and <kbd>34</kbd>, as before, and the ones associated with <kbd>23</kbd> will be <kbd>56</kbd> and <kbd>35</kbd>. This means that the final slice will be <kbd>&amp;[87, 99, 79, 58]</kbd>, where <kbd>87</kbd> and <kbd>99</kbd> work the same way as before and <kbd>79</kbd> and <kbd>58</kbd> are the extension of adding <kbd>23</kbd> to <kbd>56</kbd> and <kbd>23</kbd> to <kbd>35</kbd>.</p>
<p>This gives you much more flexibility than the functions, but remember, all this will be expanded during compile time, which can make your compilation time much slower and the final codebase larger and slower still if the macro used duplicates too much code. In any case, there is more flexibility to it yet.</p>
<p>So far, all variables have been of the <kbd>expr</kbd> kind. We have used this by declaring <kbd>$x:expr</kbd> and <kbd>$y:expr</kbd> but, as you can imagine, there are other kinds of macro variables. The list follows:</p>
<ul>
<li><kbd>expr</kbd>: Expressions that you can write after an <kbd>=</kbd> sign, such as <kbd>76+4</kbd> or <kbd>if a==1 {"something"} else {"other thing"}</kbd>.</li>
<li><kbd>ident</kbd>: An identifier or binding name, such as <kbd>foo</kbd> or <kbd>bar</kbd>.</li>
<li><kbd>path</kbd>: A qualified path. This will be a path that you could write in a use sentence, such as <kbd>foo::bar::MyStruct</kbd> or <kbd>foo::bar::my_func</kbd>.</li>
<li><kbd>ty</kbd>: A type, such as <kbd>u64</kbd> or <kbd>MyStruct</kbd>. It can also be a path to the type.</li>
<li><kbd>pat</kbd>: A pattern that you can write at the left side of an <kbd>=</kbd> sign or in a match expression, such as <kbd>Some(t)</kbd> or <kbd>(a, b, _)</kbd>.</li>
<li><kbd>stmt</kbd>: A full statement, such as a let binding like <kbd>let a = 43;</kbd>.</li>
<li><kbd>block</kbd>: A block element that can have multiple statements and a possible expression between braces, such as <kbd>{vec.push(33); vec.len()}</kbd>.</li>
<li><kbd>item</kbd>: What Rust calls <em>items</em>. For example, function or type declarations, complete modules, or trait definitions.</li>
<li><kbd>meta</kbd>: A meta element, which you can write inside of an attribute (<kbd>#[]</kbd>). For example, <kbd>cfg(feature = "foo")</kbd>.</li>
<li><kbd>tt</kbd>: Any token tree that will eventually get parsed by a macro pattern, which means almost anything. This is useful for creating recursive macros, for example.</li>
</ul>
<p>As you can imagine, some of these kinds of macro variables overlap and some of them are just more specific than the others. The use will be verified on the right-hand side of the macro, in the expansion, since you might try to use a statement where an expression must be used, even though you might use an identifier too, for example.</p>
<p>There are some extra rules, too, as we can see in the Rust documentation (<a href="https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements">https://doc.rust-lang.org/book/first-edition/macros.html#syntactic-requirements</a>). Statements and expressions can only be followed by <kbd>=&gt;</kbd>, a comma, or a semicolon. Types and paths can only be followed by <kbd>=&gt;</kbd>, the <kbd>as</kbd> or <kbd>where</kbd> keywords, or any commas, <kbd>=</kbd>, <kbd>|</kbd>, <kbd>;</kbd>, <kbd>:</kbd>, <kbd>&gt;</kbd>, <kbd>[</kbd>, or <kbd>{</kbd>. And finally, patterns can only be followed by <kbd>=&gt;</kbd>, the <kbd>if</kbd> or <kbd>in</kbd> keywords, or any commas, <kbd>=</kbd>, or <kbd>|</kbd>.</p>
<p>Let's put this in practice by implementing a small <kbd>Mul</kbd> trait for a currency type we can create. This is an adapted example of some work we did when creating the Fractal Credits digital currency. In this case, we will look to the implementation of the <kbd>Amount</kbd> type (<a href="https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102">https://github.com/FractalGlobal/utils-rs/blob/49955ead9eef2d9373cc9386b90ac02b4d5745b4/src/amount.rs#L99-L102</a>), which represents a currency amount. Let's start with the basic type definition:</p>
<pre style="padding-left: 60px">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]<br/>pub struct Amount {<br/>    value: u64,<br/>}</pre>
<p>This amount will be divisible by up to three decimals, but it will always be an exact value. We should be able to add an <kbd>Amount</kbd> to the current <kbd>Amount</kbd>, or to subtract it. I will not explain these trivial implementations, but there is one implementation where macros can be of great help. We should be able to multiply the amount by any positive integer, so we should implement the <kbd>Mul</kbd> trait for <kbd>u8</kbd>, <kbd>u16</kbd>, <kbd>u32</kbd>, and <kbd>u64</kbd> types. Not only that, we should be able to implement the <kbd>Div</kbd> and the <kbd>Rem</kbd> traits, but I will leave those out, since they are a little bit more complex. You can check them in the implementation linked earlier.</p>
<p>The only thing the multiplication of an <kbd>Amount</kbd> with an integer should do is to multiply the value by the integer given. Let's see a simple implementation for <kbd>u8</kbd>:</p>
<pre style="padding-left: 60px">use std::ops::Mul;<br/><br/>impl Mul&lt;u8&gt; for Amount {<br/>    type Output = Self;<br/><br/>    fn mul(self, rhs: u8) -&gt; Self::Output {<br/>        Self { value: self.value * rhs as u64 }<br/>    }<br/>}<br/><br/>impl Mul&lt;Amount&gt; for u8 {<br/>    type Output = Amount;<br/><br/>    fn mul(self, rhs: Amount) -&gt; Self::Output {<br/>        Self::Output { value: self as u64 * rhs.value }<br/>    }<br/>}</pre>
<p>As you can see, I implemented it both ways so that you can put the <kbd>Amount</kbd> to the left and to the right of the multiplication. If we had to do this for all integers, it would be a big waste of time and code. And if we had to modify one of the implementations (especially for <kbd>Rem</kbd> functions), it would be troublesome to do it in multiple code points. Let's use macros to help us.</p>
<p>We can define a macro, <kbd>impl_mul_int!{}</kbd>, which will receive a list of integer types and then implement the <kbd>Mul</kbd> trait back and forward between all of them and the <kbd>Amount</kbd> type. Let's see:</p>
<pre style="padding-left: 60px">macro_rules! impl_mul_int {<br/>    ($($t:ty)*) =&gt; ($(<br/>        impl Mul&lt;$t&gt; for Amount {<br/>            type Output = Self;<br/><br/>            fn mul(self, rhs: $t) -&gt; Self::Output {<br/>                Self { value: self.value * rhs as u64 }<br/>            }<br/>        }<br/><br/>        impl Mul&lt;Amount&gt; for $t {<br/>            type Output = Amount;<br/><br/>            fn mul(self, rhs: Amount) -&gt; Self::Output {<br/>                Self::Output { value: self as u64 * rhs.value }<br/>            }<br/>        }<br/>    )*)<br/>}<br/><br/>impl_mul_int! { u8 u16 u32 u64 usize }</pre>
<p>As you can see, we specifically ask for the given elements to be types and then we implement the trait for all of them. So, for any code that you want to implement for multiple types, you might as well try this approach, since it will save you from writing a lot of code and it will make it more maintainable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating procedural macros</h1>
                
            
            
                
<p>We have seen what standard macros can do for our crate. We can create complex compile-time code that can both reduce the verbosity of our code, making it more maintainable, and improve the performance of the final executable by performing operations at compile time instead of at runtime.</p>
<p>Nevertheless, standard macros can only do so much. With them, you can only modify some of the Rust grammar token processing, but you are still bound to what the <kbd>macro_rules!{}</kbd> macro can understand. This is where procedural macros, also known as macros 1.1 or custom derives, come into play.</p>
<p>With procedural macros, you can create libraries that will be called by the compiler when deriving their name in some structure or enumeration. You can effectively create a custom trait, <kbd>derive</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a simple trait</h1>
                
            
            
                
<p>Let's see how this can be done by implementing a simple trait for a structure or enumeration. The trait we will be implementing is the following:</p>
<pre style="padding-left: 60px">trait TypeName {<br/>    fn type_name() -&gt; &amp;'static str;<br/>}</pre>
<p>This <kbd>trait</kbd> should return the name of the current structure or enumeration as a string. Implementing that by hand is really easy, but it doesn't make sense to implement it manually, one by one, for our types. The best thing to do is to derive it with a procedural macro. Let's see how we can do that.</p>
<p>First, we will need to create a library crate. As per convention, it should have the parent crate's name and then the <kbd>-derive</kbd> suffix. In this case, we do not have a name for the crate, but let's call the library <kbd>type-name-derive</kbd>:</p>
<pre style="padding-left: 60px">cargo new type-name-derive</pre>
<p>This should create a new folder next to the <kbd>src/</kbd> folder, named <kbd>type-name-derive</kbd>. We can now add it to the <kbd>Cargo.toml</kbd> file:</p>
<pre style="padding-left: 60px">[dependencies]<br/>type-name-derive = { path = "./type-name-derive" }</pre>
<p>In the <kbd>main.rs</kbd> file of our crate, we will need to add the crate and use its macros:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate type_name_derive;<br/><br/>trait TypeName {<br/>    fn type_name() -&gt; &amp;'static str;<br/>}</pre>
<p>Let's now start with the actual derivation development. We will need to use two crates—<kbd>syn</kbd> and <kbd>quote</kbd>. We will add them to the <kbd>Cargo.toml</kbd> file inside the <kbd>type-name-derive</kbd> directory:</p>
<pre style="padding-left: 60px">[dependencies]<br/>syn = "0.12.10"<br/>quote = "0.4.2"</pre>
<p>The <kbd>syn</kbd> crate gives us some useful types and functions to work with the source tree and token streams of Rust. We need this because all our macro will see is a bunch of information about the source code of our structure or enumeration. We will need to parse it and get information from it. The <kbd>syn</kbd> crate is a <kbd>Nom</kbd> parser that will transform that Rust source code into something we can easily use.</p>
<p>The <kbd>quote</kbd> crate gives us the <kbd>quote!{}</kbd> macro, which we will use to implement the source code of our implementation directly. It basically allows us to write almost <em>normal</em> Rust code instead of compiler tokens to implement the trait.</p>
<p>There is other extra information we will need to include in the <kbd>Cargo.toml</kbd> file. We need to inform cargo and the Rust compiler that this crate is a procedural macro crate. For that, we will need to add this to the file:</p>
<pre style="padding-left: 60px">[lib]<br/>proc-macro = true</pre>
<p>Then, we need to start with the initial schema of the <kbd>./type-name-derive/src/lib.rs</kbd> file:</p>
<pre style="padding-left: 60px">extern crate proc_macro;<br/>extern crate syn;<br/>#[macro_use]<br/>extern crate quote;<br/><br/>use proc_macro::TokenStream;<br/><br/>#[proc_macro_derive(TypeName)]<br/>pub fn type_name(input: TokenStream) -&gt; TokenStream {<br/>    // some code<br/>}</pre>
<p>As you can see, we first imported the required definitions. The <kbd>proc_macro</kbd> crate is built in the compiler and gives us the <kbd>TokenStream</kbd> type. This type represents a stream of Rust tokens (characters in your source files). We then import the <kbd>syn</kbd> and <kbd>quote</kbd> crates. As we saw earlier, we will need to use the <kbd>quote!{}</kbd> macro from the quote crate, so we import the macros too.</p>
<p>The syntax for implementing a custom derive is really simple. We need to define a function with a <kbd>proc_macro_derive</kbd> attribute of the value of the trait we want to derive. The function will take ownership of a token stream and return another (or the same) token stream so that the compiler can later process the new generated Rust code.</p>
<p>To implement the trait, I prefer to divide the token parsing and the actual trait implementation into two functions. For that, let's first write the code inside our <kbd>type_name()</kbd> function:</p>
<pre>    // Parse the input tokens into a syntax tree<br/>    let input = syn::parse(input).unwrap();<br/><br/>    // Build the output<br/>    let expanded = impl_type_name(&amp;input);<br/><br/>    // Hand the output tokens back to the compiler<br/>    expanded.into()</pre>
<p>The token stream first gets converted into a <kbd>DeriveInput</kbd> structure. This structure contains the properly parsed data from the input token stream; deserialized into the information of the type here, we will add the <kbd>#[derive]</kbd> attribute. In a production environment, those <kbd>unwrap()</kbd> functions should probably be changed for <kbd>expect()</kbd>, so that we can add some text if things go wrong.</p>
<p>Later, we use that information to call the <kbd>impl_type_name()</kbd> function, which we haven't  yet defined. That function will take that information about the structure or enumeration and will return a series of tokens. Since we will use the quote crate to create those tokens, they will need to be converted into Rust compiler token streams later and returned to the compiler.</p>
<p>Let's now implement the <kbd>impl_type_name()</kbd> function:</p>
<pre style="padding-left: 60px">fn impl_type_name(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {<br/>    let name = &amp;ast.ident;<br/>    quote! {<br/>        impl TypeName for #name {<br/>            fn type_name() -&gt; &amp;'static str {<br/>                stringify!(#name)<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, this implementation is really simple. We get the name of the structure or enumeration from the <strong>advanced source tree</strong> (<strong>AST</strong>), and then use it inside the <kbd>quote!{}</kbd> macro, where we implement the <kbd>TypeName</kbd> macro for the structure or enumeration with that name. The <kbd>stringify!()</kbd> macro is a native Rust macro that gets a token and returns a compile time string representation of it. In this case, the <kbd>name</kbd>.</p>
<p>Let's see if this works by adding some code in the <kbd>main()</kbd> function of our parent crate and adding a couple of types that will derive our implementation:</p>
<pre style="padding-left: 60px">#[derive(TypeName)]<br/>struct Alice;<br/><br/>#[derive(TypeName)]<br/>enum Bob {}<br/><br/>fn main() {<br/>    println!("Alice's name is {}", Alice::type_name());<br/>    println!("Bob's name is {}", Bob::type_name());<br/>}</pre>
<p>If you execute <kbd>cargo run</kbd>, you will see that the output is the following, as one would expect:</p>
<pre style="padding-left: 60px"><strong>Alice's name is Alice</strong><br/><strong>Bob's name is Bob</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing complex derivations</h1>
                
            
            
                
<p>The <kbd>syn</kbd> and <kbd>quote</kbd> crates allow for really complex derivations. And, not only that, we do not necessarily need to derive a trait; we can implement any kind of code for the given structure or enumeration. This means that we can derive builder patterns, as we saw in the previous chapter, which will actually create a new structure or <kbd>Getters</kbd> and <kbd>Setters</kbd> for our structure.</p>
<p>That is what we are going to do for our next example. We will create structures and give them some methods to <kbd>get</kbd> and <kbd>set</kbd> the fields of the structure. In Rust, convention says that <kbd>Getters</kbd> should have the name of the field, without any prefix or a suffix such as <kbd>get</kbd>. So, for a field named <kbd>foo</kbd>, the <kbd>Getter</kbd> should be <kbd>foo()</kbd>. For mutable <kbd>Getters</kbd>, the function should have the <kbd>_mut</kbd> suffix, so in this case it would be <kbd>foo_mut()</kbd>. Setters should have the name of the field preceded by a <kbd>set_</kbd> prefix. So for a field named <kbd>bar</kbd>, it should be <kbd>set_bar()</kbd>.</p>
<p>Let's start with the creation of this new <kbd>getset-derive</kbd> procedural macro crate. As before, remember to set the <kbd>proc_macro</kbd> variable in the <kbd>[lib]</kbd> section of the <kbd>Cargo.toml</kbd> file to true and to add the <kbd>syn</kbd> and <kbd>quote</kbd> crates as dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing getters</h1>
                
            
            
                
<p>We will add two derives, <kbd>Getters</kbd> and <kbd>Setters</kbd>. We will start with the first one by creating the required boilerplate:</p>
<pre style="padding-left: 60px">extern crate proc_macro;<br/>extern crate syn;<br/>#[macro_use]<br/>extern crate quote;<br/><br/>use proc_macro::TokenStream;<br/><br/>#[proc_macro_derive(Getters)]<br/>pub fn derive_getters(input: TokenStream) -&gt; TokenStream {<br/>    // Parse the input tokens into a syntax tree<br/>    let input = syn::parse(input).unwrap();<br/><br/>    // Build the output<br/>    let expanded = impl_getters(&amp;input);<br/><br/>    // Hand the output tokens back to the compiler<br/>    expanded.into()<br/>}<br/><br/><br/>fn impl_getters(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {<br/>    let name = &amp;ast.ident;<br/>    unimplemented!()<br/>}</pre>
<p>We will not only need the name of the structure, we will also need any further generics added to the structure and <kbd>where</kbd> clauses. We didn't bother with these in our previous example, but we should add them in this more complex one. Gladly, the <kbd>syn</kbd> crate gives us all we need.</p>
<p>Let's write the next piece of code in the <kbd>impl_getters()</kbd> function:</p>
<pre style="padding-left: 60px">fn impl_getters(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {<br/>    use syn::{Data, Fields};<br/><br/>    let name = &amp;ast.ident;<br/>    let (impl_generics, ty_generics, where_clause) =<br/>                            ast.generics.split_for_impl();<br/><br/>    match ast.data {<br/>        Data::Struct(ref structure) =&gt; {<br/>            if let Fields::Named(ref fields) = structure.fields {<br/>                let getters: Vec&lt;_&gt; =<br/>                                fields.named.iter()<br/>                                            .map(generate_getter)<br/>                                            .collect();<br/><br/>                quote! {<br/>                    impl #impl_generics #name #ty_generics<br/>                        #where_clause {<br/>                        #(#getters)*<br/>                    }<br/>                }<br/>            } else {<br/>                panic!("you cannot implement getters for unit \<br/>                        or tuple structs");<br/>            }<br/>        },<br/>        Data::Union(ref _union) =&gt; {<br/>            unimplemented!("sorry, getters are not implemented \<br/>                            for unions yet");<br/>        }<br/>        Data::Enum(ref _enum) =&gt; {<br/>            panic!("you cannot derive getters for enumerations");<br/>        }<br/>    }<br/>}<br/><br/>fn generate_getter(field: &amp;syn::Field) -&gt; quote::Tokens {<br/>    unimplemented!("getters not yet implemented")<br/>}</pre>
<p>We have a lot going on here. First, as you can see, we get the generics from the <kbd>ast.generics</kbd> field and we use them later in the <kbd>quote!</kbd> macro. We then check which type of data we have. We cannot implement getters or setters for enumerations, unit structs, or structures with no named fields, such as <kbd>Foo(T)</kbd>, so we panic in those cases. Even though it's still not possible to derive anything for unions yet, we can specifically filter the options with the <kbd>syn</kbd> crate, so we just add that for potential future changes in the language.</p>
<p>In the case of a structure with named fields, we get a list of the fields and, for each of them, we implement the getter. For that, we map them to the <kbd>generate_getter()</kbd> function, defined at the bottom but still unimplemented.</p>
<p>Once we have the list of getters, we call the quote <kbd>!{}</kbd> macro to generate the tokens. As you can see, we add the generics for the <kbd>impl</kbd> block so that if we had any in the structure, such as <kbd>Bar&lt;T, F, G&gt;</kbd>, they would be added to the implementation.</p>
<p>To add all the getters from a vector, we use the <kbd>#(#var)*</kbd> syntax and the same as with the <kbd>macro_rules!{}</kbd> macro, it will add one after the other. We can use this syntax with any type implementing the <kbd>IntoIterator</kbd> trait, in this case, <kbd>Vec&lt;quote::Tokens&gt;</kbd>.</p>
<p>So, now we have to actually implement one getter. We have the <kbd>generate_getter()</kbd> function which receives a <kbd>syn::Field</kbd>, so we have all the information we need. The function will return <kbd>quote::Tokens</kbd>, so we will need to use the <kbd>quote!{}</kbd> macro inside. You can probably implement it yourself if you have been following, by checking the <kbd>syn</kbd> crate documentation at <kbd>docs.rs</kbd>. Let's see how it looks fully implemented:</p>
<pre style="padding-left: 60px">fn generate_getter(field: &amp;syn::Field) -&gt; quote::Tokens {<br/>    let name = field.ident<br/>                .expect("named fields must have a name");<br/>    let ty = &amp;field.ty;<br/><br/>    quote! {<br/>        fn #name(&amp;self) -&gt; &amp;#ty {<br/>            &amp;self.#name<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, this is really simple. We get the identifier or name of the attribute, which should exist given that we are only implementing it for structures for named fields, and then get the type of the field. We then create the getter and return a reference to the internal data.</p>
<p>We could improve this further by adding exceptions for types that have their borrowed counterparts, such as <kbd>String</kbd> or <kbd>PathBuf</kbd>, returning <kbd>&amp;str</kbd> and <kbd>Path</kbd> respectively, but I don't think it's worth it.</p>
<p>We could also add the documentation of the field to the generated getter. For that, we would use the <kbd>field.attrs</kbd> variable and get the contents of the attribute named <kbd>doc</kbd>, which is the one that includes the documentation text. Nevertheless, it's not so easy, because the name of the attribute is stored as a path and we would need to convert it to a string. But I invite you to try it with the <kbd>syn</kbd> crate documentation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing setters</h1>
                
            
            
                
<p>The second part of this exercise will be to implement setters for our structure. Usually this is done by creating a <kbd>set_{field}()</kbd> function for each field. Moreover, it's common practice to use generics for it so that they can be used with many different types. For example, for a <kbd>String</kbd> field, it would be great if we didn't need to always use an actual <kbd>String</kbd> type and we could use a <kbd>&amp;str</kbd>, a <kbd>Cow&lt;_, str&gt;</kbd>, or a <kbd>Box&lt;str&gt;</kbd>.</p>
<p>We only need to declare the input as <kbd>Into&lt;String&gt;</kbd>. This makes things a little bit more complex, but our API will look much better. To implement the new setters, it would only mean changing a little bit of what we saw earlier and most of the code would be duplicated.</p>
<p>To avoid that, we will use the strategy pattern so that we simply change the <kbd>generate_getter()</kbd> function to the <kbd>generate_setter()</kbd>, one for each field. I also moved the field retrieving a new function. Let's see how it looks:</p>
<pre style="padding-left: 60px">use syn::{DeriveInput, Fields, Field, Data};<br/>use syn::punctuated::Punctuated;<br/>use syn::token::Comma;<br/><br/>fn get_fields(ast: &amp;DeriveInput) -&gt; &amp;Punctuated&lt;Field, Comma&gt; {<br/>    match ast.data {<br/>        Data::Struct(ref structure) =&gt; {<br/>            if let Fields::Named(ref fields) = structure.fields {<br/>                &amp;fields.named<br/>            } else {<br/>                panic!("you cannot implement setters or getters \<br/>                        for unit or tuple structs");<br/>            }<br/>        },<br/>        Data::Union(ref _union) =&gt; {<br/>            unimplemented!("sorry, setters and getters are not \<br/>                            implemented for unions yet");<br/>        }<br/>        Data::Enum(ref _enum) =&gt; {<br/>            panic!("you cannot derive setters or getters for \<br/>                    enumerations");<br/>        }<br/>    }<br/>}</pre>
<p>Much better, right? It returns an iterator over the fields, which is what we need for our functions. We now create the method implementation function, which will receive a function as an argument, and will then be used for each field:</p>
<pre style="padding-left: 60px">fn impl_methods&lt;F&gt;(ast: &amp;DeriveInput, strategy: F) -&gt; Tokens<br/>where F: FnMut(&amp;Field) -&gt; Tokens {<br/>    let methods: Vec&lt;_&gt; = get_fields(ast).iter()<br/>                                         .map(strategy)<br/>                                         .collect();<br/>    let name = &amp;ast.ident;<br/>    let (impl_generics, ty_generics, where_clause) =<br/>                            ast.generics.split_for_impl();<br/><br/>    quote! {<br/>        impl #impl_generics #name #ty_generics #where_clause {<br/>            #(#methods)*<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, apart from small naming changes to make the meaning of bindings clearer, the only big change was to add a <kbd>FnMut</kbd> in the <kbd>where</kbd> signature of the function, which will be the <kbd>getter</kbd> or <kbd>setter</kbd> implementer. Therefore, to call this new function, we will need to change the <kbd>derive_getters()</kbd> method and add the new <kbd>derive_setters()</kbd> function:</p>
<pre style="padding-left: 60px">#[proc_macro_derive(Getters)]<br/>pub fn derive_getters(input: TokenStream) -&gt; TokenStream {<br/>    // Parse the input tokens into a syntax tree<br/>    let input = syn::parse(input).unwrap();<br/><br/>    // Build the output<br/>    let expanded = impl_methods(&amp;input, generate_getter);<br/><br/>    // Hand the output tokens back to the compiler<br/>    expanded.into()<br/>}<br/><br/>#[proc_macro_derive(Setters)]<br/>pub fn derive_setters(input: TokenStream) -&gt; TokenStream {<br/>    // Parse the input tokens into a syntax tree<br/>    let input = syn::parse(input).unwrap();<br/><br/>    // Build the output<br/>    let expanded = impl_methods(&amp;input, generate_setter);<br/><br/>    // Hand the output tokens back to the compiler<br/>    expanded.into()<br/>}</pre>
<p>As you can see, both methods are exactly the same, except that, when calling the <kbd>impl_methods()</kbd> function, they use a different strategy. The first one will generate getters and the second one setters. Finally, let's see what the <kbd>generate_setters()</kbd> function will look like:</p>
<pre style="padding-left: 60px">use syn::Ident;<br/><br/>fn generate_setter(field: &amp;Field) -&gt; Tokens {<br/>    let name = field.ident<br/>                .expect("named fields must have a name");<br/>    let fn_name = Ident::from(format!("set_{}", name));<br/>    let ty = &amp;field.ty;<br/><br/>    quote! {<br/>        fn #fn_name&lt;T&gt;(&amp;mut self, value: T) where T: Into&lt;#ty&gt; {<br/>            self.#name = value.into();<br/>        }<br/>    }<br/>}</pre>
<p>The code is similar in most aspects to the <kbd>generate_getter()</kbd> function, but it has some differences. First, the function name is not the same as the <kbd>name</kbd>, since it needs the <kbd>set_</kbd> prefix. For that, we create a string with the field name after it and we create an identifier with that name.</p>
<p>We then construct the setter by using the new function name, using a mutable <kbd>self</kbd> and adding a new input variable to the function, the value. Since we want this value to be generic, we use the <kbd>T</kbd> type that we define later in the where clause as being a type that can be transformed into our field type (<kbd>Into&lt;#ty&gt;</kbd>). We finally assign the converted value to our field.</p>
<p>Let's see how this getter and setter setup works by creating a short example in the <kbd>main.rs</kbd> file of our parent crate. We add the procedural macro dependency to the <kbd>Cargo.toml</kbd> file and we define a structure:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate getset_derive;<br/><br/>#[derive(Debug, Getters, Setters)]<br/>struct Alice {<br/>    x: String,<br/>    y: u32,<br/>}</pre>
<p>Nothing special about it; except the <kbd>Getters</kbd> and <kbd>Setters</kbd> derive. As you see, we don't need to derive an actual trait. Now, we add a simple <kbd>main()</kbd> function to test the code:</p>
<pre style="padding-left: 60px">fn main() {<br/>    let mut alice = Alice {<br/>        x: "this is a name".to_owned(),<br/>        y: 34<br/>    };<br/>    println!("Alice: {{ x: {}, y: {} }}",<br/>             alice.x(),<br/>             alice.y());<br/><br/>    alice.set_x("testing str");<br/>    alice.set_y(15u8);<br/>    println!("{:?}", alice);<br/>}</pre>
<p>We create a new <kbd>Alice</kbd> structure and set the two fields in it. When printing the structure, we can see that the <kbd>Alice::x()</kbd> and <kbd>Alice::y()</kbd> getters can be used directly. Note that the double braces are for escaping.</p>
<p>Then, since we have a mutable variable, we use the setters to change the values of the <kbd>x</kbd> and <kbd>y</kbd> fields. As you can see, we don't have to provide a <kbd>String</kbd> or a <kbd>u32</kbd>; we can provide any type that can be converted directly to those without failing. Finally, since we implemented the <kbd>Debug</kbd> trait for <kbd>Alice</kbd>, we can print its contents without using the getters. The result after executing <kbd>cargo run</kbd> should be the following:</p>
<pre style="padding-left: 60px"><strong>Alice: { x: this is a name, y: 34 }</strong><br/><strong>Alice { x: "testing str", y: 15 }</strong></pre>
<p>Procedural macros or custom derives allow for really complex code generation, and you can even further customize the user experience. As we saw in the previous chapter, with the <kbd>serde</kbd> crate we could use the <kbd>#[serde]</kbd> attribute. You can add custom attributes to your derive crate by defining them in the <kbd>#[proc_macro_derive]</kbd> attribute, like this:</p>
<pre style="padding-left: 60px">#[proc_macro_derive(Setters, attributes(generic))]</pre>
<p>You can then use them by checking the attributes of the structure/enumeration or its fields via the <kbd>attrs</kbd> fields in <kbd>Field</kbd>, <kbd>DeriveInput</kbd>, <kbd>Variant</kbd>, or <kbd>FieldValue</kbd> structures. You could, for example, let the developer decide whether they wanted generics in the setters or to fine-tune the attributes that should be generic.</p>
<p>Extra information can be found in the official documentation at <a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes">https://doc.rust-lang.org/book/first-edition/procedural-macros.html#custom-attributes</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Metaprogramming in nightly Rust</h1>
                
            
            
                
<p>Until now, we have stayed in stable Rust, since it allows forward compatibility. There are some nightly features, though, that can help us improve our control over the code we generate. Nevertheless, all of them are experimental and they might change or even get removed before being stabilized.</p>
<p>Therefore, you should take into account that using nightly features will probably break your code in the future and it will take more effort to maintain it to be compatible with new Rust versions. Nevertheless, we will have a quick look at two new features that are coming to Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding compiler plugins</h1>
                
            
            
                
<p>The Rust nightly compiler accepts loading extensions, called <strong>plugins</strong>. They effectively change the way the compiler behaves, so they can modify the language itself. A plugin is a crate, similar to the procedural macro crate we created previously.</p>
<p>The difference between a procedural or standard macro and a plugin is that, while the first two modify the Rust code they are given, a plugin is able to perform extra computations that can greatly improve the performance of your crate.</p>
<p>Since these plugins get loaded inside the compiler, they will have access to a lot of information that standard macros don't have. Moreover, this requires using the <kbd>rustc</kbd> compiler and the <kbd>libsyntax</kbd> library as external crates, which means that you will be loading a lot of the compiler code when compiling the plugin.</p>
<p>Therefore, do not add your plugin as an external crate to your binaries as it will create a huge executable with a lot of compiler code. To use a plugin without adding it as a library, you will need the nightly compiler and you will have to add <kbd>#![feature(plugin)]</kbd> and <kbd>#![plugin({plugin_name})]</kbd> attributes to your crate.</p>
<p>When developing a new plugin, you will need to create the crate with some extra information in the <kbd>Cargo.toml</kbd> file, as we did with the procedural macro:</p>
<pre style="padding-left: 60px">[lib]<br/>plugin = true</pre>
<p>Then, in the <kbd>lib.rs</kbd> file, you will need to import the required libraries and define the plugin registrar. The bare minimum for the plugin to work would be the following:</p>
<pre style="padding-left: 60px">#![crate_type="dylib"]<br/>#![feature(plugin_registrar, rustc_private)]<br/><br/>extern crate syntax;<br/>extern crate syntax_pos;<br/>extern crate rustc;<br/>extern crate rustc_plugin;<br/><br/>use rustc_plugin::Registry;<br/><br/>#[plugin_registrar]<br/>pub fn plugin_registrar(reg: &amp;mut Registry) {<br/>    unimplemented!()<br/>}</pre>
<p>Even though, in this example, the <kbd>rustc</kbd>, <kbd>syntax</kbd>, and <kbd>syntax_pos</kbd> crates are not being used, it's almost certain you will need them when developing the plugin, since they have the required types for you to change any behaviour. The <kbd>Registry</kbd> object lets you register multiple types of new language items, such as macros or syntax extensions. For each of them, you will need to define a function to receive the compiler tokens and modify them to produce the desired output.</p>
<p>The <kbd>#![crate_type = "dylib"]</kbd> attribute tells the compiler to create a dynamic library with the crate, instead of the normal static one. This enables the library to be loaded by the compiler. The <kbd>plugin_registrar</kbd> nightly feature lets us create the actual plugin registrar function and the <kbd>rustc_private</kbd> feature allows us to use the private Rust compiler types so that we can use the compiler internals.</p>
<p>At the time of writing, the only online documentation for these crates is the one hosted by Manish Goregaokar, but that should change soon. On his website, you can find the API documentation for <kbd>rustc_plugin</kbd> (<a href="https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html">https://manishearth.github.io/rust-internals-docs/rustc_plugin/index.html</a>), for <kbd>rustc</kbd> (<a href="https://manishearth.github.io/rust-internals-docs/rustc/index.html">https://manishearth.github.io/rust-internals-docs/rustc/index.html</a>), for <kbd>syntax</kbd> (<a href="https://manishearth.github.io/rust-internals-docs/syntax/index.html">https://manishearth.github.io/rust-internals-docs/syntax/index.html</a>), and for <kbd>syntax_pox</kbd> (<a href="https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html">https://manishearth.github.io/rust-internals-docs/syntax_pos/index.html</a>). I invite you to read the API of those crates and to create small plugins for the compiler. Nevertheless, remember that the syntax will probably change, which makes it more difficult to maintain.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declarative macros</h1>
                
            
            
                
<p>The next thing that is coming to Rust are declarative macros, macros 2.0, or macros by example. It's true that some call standard macros declarative macros too, since they are based on the same principle. But I wanted to make this difference known so that we learn about some improvements that these new macros will bring to the language.</p>
<p>These new macros introduce the <kbd>macro</kbd> keyword, which will work similarly to the <kbd>macro_rules!{}</kbd> macro, but using a syntax more close to the function syntax than to the current syntax. Not only that, it will also add modularization to macros so that you can have two macros with the same name in the same crate, as long as they are in different modules. This extra modularization will make integration between crates much easier.</p>
<p>Sadly, there is still no syntax proposition for these macros, and the current nightly implementation is not much more than a placeholder for what is yet to come. I invite you to keep yourself up to date on the standardization of these new macros and even to define a future syntax for them by contributing to the community.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you have learned how to create your own macros. First, we saw the standard macros and created some that could help you develop more quickly and create more efficient code. Then, you learned about procedural macros and how to derive your own code for your structures and enumeration. Finally, you found out about two features that might be coming to stable Rust in the future, which can currently be used in nightly Rust—plugins and declarative macros.</p>
<p>In the two remaining chapters, we will talk about concurrency in Rust. As you will see, once our single-threaded code is fast enough, the next step toward faster execution is to compute it in parallel.</p>


            

            
        
    </body></html>