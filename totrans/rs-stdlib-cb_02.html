<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Collections</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using a vector</li>
<li>Using a string</li>
<li>Accessing collections as iterators</li>
<li>Using a <kbd>VecDeque</kbd></li>
<li>Using a <kbd>HashMap</kbd></li>
<li>Using a <kbd>HashSet</kbd></li>
<li>Creating an own iterator</li>
<li>Using a slab</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><strong>Rust</strong> provides a very broad set of collections to use. We will look at most of them, see how they're used, discuss how they're implemented, and when to use and choose them. A big part of this chapter focuses on iterators. Much of Rust's flexibility comes from them, as all collections (and more!) can be used as iterators. Learning how to use them is crucial.</p>
<p>Throughout this chapter, we are going to use the <em>big O notation</em> to show how effective certain algorithms are. In case you don't know it yet, it is a way of telling how much longer an algorithm takes when working with more elements. Let's look at it briefly.</p>
<p><img class="fm-editor-equation" src="assets/2d8a2575-71ea-413d-b7dc-12001272e5c0.png" style="width:1.92em;height:1.08em;"/> means that an algorithm is going to take the same time, no matter how much data is stored in a collection. It doesn't tell us how fast exactly it is, just that it's not going to slow down with size. This is the realistic ideal for a function. A practical example for this is accessing the first number in an infinite list of numbers: no matter how many numbers there are, you're always going to be able to instantly pick out the first one.</p>
<p><img class="fm-editor-equation" src="assets/d6bf9ef3-9e89-4e76-aeb5-a125f45e6a12.png" style="width:2.50em;height:1.42em;"/> means that an algorithm is going to slow down by the same degree for every element. This is not good, but still okay. An example for this is printing all data in a <kbd>for</kbd> loop.</p>
<p><img class="fm-editor-equation" src="assets/6cf884d4-c07a-4ba2-8d1c-2eaf8363dfa5.png" style="width:2.50em;height:1.25em;"/>Â is really bad. It tells us that an algorithm is going to be slower and slower with every element. An example of it would be accessing data in a <kbd>for</kbd> loop nested in another <kbd>for</kbd> loop over the same data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a vector</h1>
                </header>
            
            <article>
                
<p>The most basic collection is the vector, or <kbd>Vec</kbd> for short. It is essentially a variable-length array with a very low overhead. As such, it is the collection that you will use most of the time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the command line, jump one folder up with <kbd>cd ..</kbd> so you're not in <kbd>chapter-one</kbd> anymore. In the next chapters, we are going to assume that you always started with this step.</li>
<li>
<p>Create a Rust project to work on during this chapter with <kbd>cargo new chapter-two</kbd>.</p>
</li>
<li>Navigate into the newly-created <kbd>chapter-two</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory.</li>
<li>Inside the folder <kbd>src</kbd>, create a new folder called <kbd>bin</kbd>.</li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library.</li>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>vector.rs</kbd>.</li>
<li>Add the following code blocks to the file and run them with <kbd>cargo run --bin vector</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2    // Create a vector with some elements<br/>3    let fruits = vec!["apple", "tomato", "pear"];<br/>4    // A vector cannot be directly printed<br/>5    // But we can debug-print it<br/>6    println!("fruits: {:?}", fruits);<br/>7<br/>8    // Create an empty vector and fill it<br/>9    let mut fruits = Vec::new();<br/>10    fruits.push("apple");<br/>11   fruits.push("tomato");<br/>12    fruits.push("pear");<br/>13    println!("fruits: {:?}", fruits);<br/>14<br/>15    // Remove the last element<br/>16    let last = fruits.pop();<br/>17    if let Some(last) = last {<br/>18        println!("Removed {} from {:?}", last, fruits);<br/>19    }<br/>20<br/>21    // Insert an element into the middle of the vector<br/>22    fruits.insert(1, "grape");<br/>23    println!("fruits after insertion: {:?}", fruits);<br/>24<br/>25    // Swap two elements<br/>26    fruits.swap(0, 1);<br/>27    println!("fruits after swap: {:?}", fruits);</pre>
<ol start="8">
<li>This is how you can access single elements in a vector:</li>
</ol>
<pre style="padding-left: 60px">29    // Access the first and last elements<br/>30    let first = fruits.first();<br/>31    if let Some(first) = first {<br/>32      println!("First fruit: {}", first);<br/>33    }<br/>34    let last = fruits.last();<br/>35    if let Some(last) = last {<br/>36      println!("Last fruit: {}", last);<br/>37    }<br/>38 <br/>39    // Access arbitrary elements<br/>40    let second = fruits.get(1);<br/>41    if let Some(second) = second {<br/>42      println!("Second fruit: {}", second);<br/>43    }<br/>44    // Access arbitrary elements without bonds checking<br/>45    let second = fruits[1];<br/>46    println!("Second fruit: {}", second);</pre>
<ol start="9">
<li>The next few methods apply to the whole vector:</li>
</ol>
<pre style="padding-left: 60px">50    // Initialize the vector with a value<br/>51    // Here, we fill our vector with five zeroes<br/>52    let bunch_of_zeroes = vec![0; 5];<br/>53    println!("bunch_of_zeroes: {:?}", bunch_of_zeroes);<br/>54 <br/>55    // Remove some item and shift all that come after<br/>56    // into place<br/>57    let mut nums = vec![1, 2, 3, 4];<br/>58    let second_num = nums.remove(1);<br/>59    println!("Removed {} from {:?}", second_num, nums); <br/>60 <br/>61    // Filter the vector in place<br/>62    let mut names = vec!["Aaron", "Felicia", "Alex", "Daniel"];<br/>63    // Only keep names starting with 'A'<br/>64    names.retain(|name| name.starts_with('A'));<br/>65    println!("Names starting with A: {:?}", names);<br/>66 <br/>67    // Check if the vector contains an element<br/>68    println!("Does 'names' contain \"Alex\"? {}", <br/>        names.contains(&amp;"Alex"));<br/>69 <br/>70 <br/>71 <br/>72    // Remove consecutive(!) duplicates<br/>73    let mut nums = vec![1, 2, 2, 3, 4, 4, 4, 5];<br/>74    nums.dedup();<br/>75    println!("Deduped, pre-sorted nums: {:?}", nums);<br/>76 <br/>77    // Be careful if your data is not sorted!<br/>78    let mut nums = vec![2, 1, 4, 2, 3, 5, 1, 2];<br/>79    nums.dedup();<br/>80    // Doens't print what you might expect<br/>81    println!("Deduped, unsorted nums: {:?}", nums);<br/>82 <br/>83    // Sort a vector<br/>84    nums.sort();<br/>85    println!("Manually sorted nums: {:?}", nums);<br/>86    nums.dedup();<br/>87    println!("Deduped, sorted nums: {:?}", nums);<br/>88 <br/>89    // Reverse a vector<br/>90    nums.reverse();<br/>91    println!("nums after being reversed: {:?}", nums);<br/>92 <br/>93    // Create a consuming iterator over a range<br/>94    let mut alphabet = vec!['a', 'b', 'c'];<br/>95    print!("The first two letters of the alphabet are: ");<br/>96    for letter in alphabet.drain(..2) {<br/>97      print!("{} ", letter);<br/>98    }<br/>99    println!();<br/>100   // The drained elements are no longer in the vector<br/>101   println!("alphabet after being drained: {:?}", alphabet);<br/>102 <br/>103 <br/>104   // Check if a vector is empty<br/>105   let mut fridge = vec!["Beer", "Leftovers", "Mayonaise"];<br/>106   println!("Is the fridge empty {}", fridge.is_empty());<br/>107   // Remove all elements<br/>108   fridge.clear();<br/>109   println!("Is the fridge now empty? {}", fridge.is_empty());</pre>
<ol start="10">
<li>We can split a vector into two and combine them again:</li>
</ol>
<pre style="padding-left: 60px">111   // Split a vector into two pieces<br/>112   let mut colors = vec!["red", "green", "blue", "yellow"];<br/>113   println!("colors before splitting: {:?}", colors);<br/>114   let half = colors.len() / 2;<br/>115   let mut second_half = colors.split_off(half);<br/>116   println!("colors after splitting: {:?}", colors);<br/>117   println!("second_half: {:?}", second_half);<br/>118 <br/>119   // Put two vectors together<br/>120   colors.append(&amp;mut second_half);<br/>121   println!("colors after appending: {:?}", colors);<br/>122   // This empties the second vector<br/>123   println!("second_half after appending: {:?}", second_half);</pre>
<ol start="11">
<li>You might remember the <kbd>splice</kbd> method from JavaScript:</li>
</ol>
<pre style="padding-left: 60px">127   let mut stuff = vec!["1", "2", "3", "4", "5", "6"];<br/>128   println!("Original stuff: {:?}", stuff);<br/>129   let stuff_to_insert = vec!["a", "b", "c"];<br/>130   let removed_stuff: Vec&lt;_&gt; = stuff.splice(1..4, <br/>        stuff_to_insert).collect();<br/>131   println!("Spliced stuff: {:?}", stuff);<br/>132   println!("Removed stuff: {:?}", removed_stuff);</pre>
<ol start="12">
<li>If you are working with very big datasets, you can optimize the performance of your vector:</li>
</ol>
<pre style="padding-left: 60px">136   // Initialize the vector with a certain capacity<br/>137   let mut large_vec: Vec&lt;i32&gt; = Vec::with_capacity(1_000_000);<br/>138   println!("large_vec after creation:");<br/>139   println!("len:\t\t{}", large_vec.len());<br/>140   println!("capacity:\t{}", large_vec.capacity());<br/>141 <br/>142   // Shrink the vector as close as possible to its length<br/>143   large_vec.shrink_to_fit();<br/>144   println!("large_vec after shrinking:");<br/>145   println!("len:\t\t{}", large_vec.len());<br/>146   println!("capacity:\t{}", large_vec.capacity());<br/>147 <br/>148   // Remove some item, replacing it with the last<br/>149   let mut nums = vec![1, 2, 3, 4];<br/>150   let second_num = nums.swap_remove(1);<br/>151   // This changes the order, but works in O(1)<br/>152   println!("Removed {} from {:?}", second_num, nums);<br/>153 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe is going to be a bit longer than the others, because:</p>
<ul>
<li>The vector is the most important collection</li>
<li>Many of its core principles, like preallocation, apply to other collections as well</li>
<li>It includes methods used on slices, which are also usable by many other collections</li>
</ul>
<p>Let's start at the beginning.</p>
<p>A vector can be created [9] by using the constructor pattern we mentioned earlier (<a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics, Using the Constructor Pattern</em>), and filled by calling <kbd>push</kbd> on it for every element we want to store [10]. Because this is such a common pattern, Rust provides you with a convenient macro called <kbd>vec!</kbd>[3]. While its end effect is the same, the macro is implemented with some nice performance optimizations.</p>
<div class="packt_tip">Because of the convenience <kbd>vec!</kbd> provides, other Rustacians have implemented similar macros for the other collections, which you can find here: <a href="https://crates.io/crates/maplit">https://crates.io/crates/maplit.</a></div>
<p>If you want to initialize a vector by repeating an element over and over, you can use the special calling syntax described in line [52] to do so.</p>
<p>The opposite of <kbd>push</kbd> is <kbd>pop</kbd>: it removes the last element of the vector, and returns it if the vector wasn't empty before. Because of the memory layout of <kbd>Vec</kbd>, which we are going to look at in the next section, this operation is done in <img class="fm-editor-equation" src="assets/0eab5654-6646-4a88-b72b-0e4e435476b8.png" style="width:1.58em;height:0.92em;"/> complexity. If you don't know what that means, let me rephrase that: it's pretty fast. This is why vectors can be nicely used as <strong>First In, Last Out (FILO)</strong> stacks.</p>
<p>If you need to modify the contents of a vector, <kbd>insert</kbd>[22],Â  <kbd>remove</kbd> [58], and <kbd>swap</kbd> [26] should be self-explanatory. Sometimes, though, you want to access a specific element in the vector. You can use <kbd>get</kbd> to borrow an element at an index [40], and <kbd>get_mut</kbd> to mutate it. Both return an <kbd>Option</kbd> that only contains <kbd>Some</kbd> element if the index was valid. Most times, though, this fine grade of error checking is unnecessary for vector access, as an out-of-bounds index is usually not recoverable, and will just be handled by unwrapping the <kbd>Option</kbd>. For this reason, Rust lets you call the <kbd>Index</kbd> operator, <kbd>[]</kbd>, on a <kbd>Vec</kbd> [45]. This will automatically deduce its mutability and perform an unwrap for you.</p>
<p>There are a bunch of methods that help us work with the entire vector at once. <kbd>retain</kbd> is a very useful one that is also implemented by most other collections [64]. It accepts a so-called <strong>predicate</strong>, which is a fancy word for a function that returns <kbd>true</kbd> or <kbd>false</kbd>. It applies that predicate to every element, and only keeps the ones where it returned <kbd>true</kbd>.</p>
<p><kbd>dedup</kbd> removes all <em>consecutive</em> duplicates [74]. This means that for the vector <kbd>[1, 2, 2, 3, 2, 3]</kbd>, <kbd>dedup</kbd> would result in <kbd>[1, 2, 3, 2, 3]</kbd>, as only the duplicate 2s were consecutive. Always remember this when using it, as it can cause bugs that are hard to find. If you want to remove <em>all</em> duplicates, you need to make them consecutive by sorting the vector first. If your elements are comparable, this is as simple as calling <kbd>.sort()</kbd> [84].</p>
<p>Using <kbd>drain</kbd> creates a consuming iterator over your vector, accessing all elements and removing them in the process, leaving your vector empty [96]. This is useful when you have to <em>work through</em>Â your data and reuse your empty vector again afterwards to collect more work.</p>
<p>If you've never seen <kbd>splice</kbd> in another language, you're probably going to feel a bit confused at first about what it does. Let's take a look at it, shall we?</p>
<p><kbd>splice</kbd> does three things:</p>
<ul>
<li>It takes a range. This range will be <em>removed</em> from the vector.</li>
<li>It takes an iterator. This iterator will be <em>inserted</em> into the space left open by the removal from the last step.</li>
<li>It <em>returns</em> the removed elements as an iterator.</li>
</ul>
<p>How to handle the returned iterator is going to be the topic of the recipe in theÂ <em>Access collections as iterators</em>Â section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The vector should always be your go-to collection. Internally, it is implemented as a continuous chunk of memory stored on the heap:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f6cc6a9c-c751-4371-8826-14b279ace5fd.jpg" style="width:32.17em;height:11.83em;"/></div>
<p>The important keyword here is <em>continuous</em>, which means that the memory is very cache-friendly. In other words, the vector is pretty fast! The vector even allocates a bit of extra memory in case you want to extend it. Be careful, though, when inserting a lot of data at the beginning of the vector: the entire stack will have to be moved.</p>
<p>At the end, you can see a bit of <em>extra capacity</em>. This is because <kbd>Vec</kbd> and many other collections preallocate a bit of extra memory each time you have to move the block, because it has grown too large. This is done in order to prevent as many reallocations as possible. You can check the exact amount of total space of a vector by calling <kbd>capacity</kbd>[140] on it. You can influence the preallocation by initializing your vector with <kbd>with_capacity</kbd>[137]. Use it when you have a rough idea about how many elements you plan on storing. This can be a big difference in capacity when working with big amounts of data.</p>
<p>The extra capacity doesn't go away when shortening the vector. If you had a vector with a length of 10,000 and a capacity of 100,000 and called <kbd>clear</kbd> on it, you would still have a capacity of 100,000 preallocated. When working on systems with memory limitations, like microcontrollers, this can become a problem. The solution is calling <kbd>shrink_to_fit</kbd> periodically on such vectors [143]. This will bring the capacity as close as possible to the length, but it is allowed to still leave a little bit of preallocated space ready.</p>
<p>Another way to optimize really big vectors is to call <kbd>swap_remove</kbd> [150]. Normally, when removing an element from a vector, all elements after it will be shifted to the left in order to preserve continuous memory. This is a lot of work when removing the first element in a big vector. If you don't care about the exact order of your vector, you can call <kbd>swap_remove</kbd> instead of <kbd>remove</kbd>. It works by swapping the element that is to be removed with the last element, and adjusting the length. This is great, because you don't create a <em>hole</em>Â that needs to be filled by shifting, and because swapping memory is a really fast operation in today's processors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a string</h1>
                </header>
            
            <article>
                
<p>Rust provides an unusually large functionality for its string. Knowing it can save you quite some headache when dealing with raw user input.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>string.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin string</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   fn main() {<br/>2     // As a String is a kind of vector,<br/>3     // you can construct them the same way<br/>4     let mut s = String::new();<br/>5     s.push('H');<br/>6     s.push('i');<br/>7     println!("s: {}", s);<br/>8<br/>9     // The String however can also be constructed<br/>10    // from a string slice (&amp;str)<br/>11    // The next two ways of doing to are equivalent<br/>12    let s = "Hello".to_string();<br/>13    println!("s: {}", s);<br/>14    let s = String::from("Hello");<br/>15    println!("s: {}", s);<br/>16<br/>17    // A String in Rust will always be valid UTF-8<br/>18    let s = "<img src="assets/9fafd50e-8e2b-4bd3-bfa6-36cdc9481b63.png" style="width:4.83em;height:1.25em;"/> ÃjÃ³Ã°hildur <img src="assets/ba11c801-302a-4585-a1d5-63bc836deee7.png" style="width:1.58em;height:1.58em;"/> <img src="assets/a9cb44f5-9c31-4b23-ba30-e7d684ca634b.png" style="width:1.58em;height:1.58em;"/>".to_string();<br/>19    println!("s: {}", s);<br/>20<br/>21    // Append strings to each other<br/>22    let mut s = "Hello ".to_string();<br/>23    s.push_str("World");<br/>24<br/>25    // Iterate over the character<br/>26    // A "character" is defined here as a<br/>27    // Unicode Scalar Value<br/>28    for ch in "Tubular".chars() {<br/>29        print!("{}.", ch);<br/>30    }<br/>31    println!();<br/>32    // Be careful though, a "character" might not<br/>33    // always be what you expect<br/>34    for ch in "yÌ".chars() {<br/>35        // This does NOT print yÌ<br/>36        print!("{} ", ch);<br/>37    }<br/>38    println!();</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">Use the following code to split a string in various ways:</p>
<pre style="padding-left: 60px">42    // Split a string slice into two halves<br/>43    let (first, second) = "HelloThere".split_at(5);<br/>44    println!("first: {}, second: {}", first, second);<br/>45<br/>46    // Split on individual lines<br/>47    let haiku = "\<br/>48                 she watches\n\<br/>49                 satisfied after love\n\<br/>50                 he lies\n\<br/>51                 looking up at nothing\n\<br/>52                 ";<br/>53    for line in haiku.lines() {<br/>54        println!("\t{}.", line);<br/>55    }<br/>56<br/>57    // Split on substrings<br/>58    for s in "Never;Give;Up".split(';') {<br/>59        println!("{}", s);<br/>60    }<br/>61    // When the splitted string is at the beginning or end,<br/>62    // it will result in the empty string<br/>63    let s: Vec&lt;_&gt; = "::Hi::There::".split("::").collect();<br/>64    println!("{:?}", s);<br/>65<br/>66    // If you can eliminate the empty strings at the end<br/>67    // by using split_termitor<br/>68    let s: Vec&lt;_&gt; = "Mr. T.".split_terminator('.').collect();<br/>69    println!("{:?}", s);<br/>70<br/>71    // char has a few method's that you can use to split on<br/>72    for s in "I'm2fast4you".split(char::is_numeric) {<br/>73        println!("{}", s);<br/>74    }<br/>75<br/>76    // Split only a certain amount of times<br/>77    for s in "It's not your fault, it's mine".splitn(3,<br/>        char::is_whitespace) {<br/>78        println!("{}", s);<br/>79    }<br/>80<br/>81    // Get only the substrings that match a pattern<br/>82    // This is the opposite of splitting<br/>83    for c in "The Dark Knight rises".matches(char::is_uppercase) {<br/>84        println!("{}", c);<br/>85    }<br/>86<br/>87    // Check if a string starts with something<br/>88    let saying = "The early bird gets the worm";<br/>89    let starts_with_the = saying.starts_with("The");<br/>90    println!(<br/>        "Does \"{}\" start with \"The\"?: {}",<br/>         saying,<br/>         starts_with_the<br/>      );<br/>91    let starts_with_bird = saying.starts_with("bird");<br/>92    println!(<br/>        "Does \"{}\" start with \"bird\"?: {}",<br/>         saying,<br/>         starts_with_bird<br/>      );<br/>93<br/>94    // Check if a string ends with something<br/>95    let ends_with_worm = saying.ends_with("worm");<br/>96    println!("Does \"{}\" end with \"worm\"?: {}", saying,<br/>        ends_with_worm);</pre>
<pre style="padding-left: 60px">97<br/>98    // Check if the string contains something somewhere<br/>99    let contains_bird = saying.contains("bird");<br/>100   println!("Does \"{}\" contain \"bird\"?: {}", saying,<br/>        contains_bird);</pre>
<p style="padding-left: 60px">Remove whitespace:</p>
<pre style="padding-left: 60px">105   // Splitting on whitespace might not result in what you expect<br/>106   let a_lot_of_whitespace = "    I   love spaaace     ";<br/>107   let s: Vec&lt;_&gt; = a_lot_of_whitespace.split(' ').collect();<br/>108   println!("{:?}", s);<br/>109   // Use split_whitespace instead<br/>110   let s: Vec&lt;_&gt; = <br/>        a_lot_of_whitespace.split_whitespace().collect();<br/>111   println!("{:?}", s);<br/>112<br/>113   // Remove leading and trailing whitespace<br/>114   let username = "   P3ngu1n\n".trim();<br/>115   println!("{}", username);<br/>116   // Remove only leading whitespace<br/>117   let username = "   P3ngu1n\n".trim_left();<br/>118   println!("{}", username);<br/>119   // Remove only trailing whitespace<br/>120   let username = "   P3ngu1n\n".trim_right();<br/>121   println!("{}", username);<br/>122<br/>123<br/>124   // Parse a string into another data type<br/>125   // This requires type annotation<br/>126   let num = "12".parse::&lt;i32&gt;();<br/>127   if let Ok(num) = num {<br/>128     println!("{} * {} = {}", num, num, num * num);<br/>129   }</pre>
<p style="padding-left: 60px">Modify the string:</p>
<pre style="padding-left: 60px">133   // Replace all occurences of a pattern<br/>134   let s = "My dad is the best dad";<br/>135   let new_s = s.replace("dad", "mom");<br/>136   println!("new_s: {}", new_s);<br/>137<br/>138   // Replace all characters with their lowercase<br/>139   let lowercase = s.to_lowercase();<br/>140   println!("lowercase: {}", lowercase);<br/>141<br/>142   // Replace all characters with their uppercase<br/>143   let uppercase = s.to_uppercase();<br/>144   println!("uppercase: {}", uppercase);<br/>145<br/>146   // These also work with other languages<br/>147   let greek = "á½ÎÎ¥Î£Î£ÎÎÎ£";<br/>148   println!("lowercase greek: {}", greek.to_lowercase());<br/>149<br/>150   // Repeat a string<br/>151   let hello = "Hello! ";<br/>152   println!("Three times hello: {}", hello.repeat(3));<br/>153 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Essentially, being a kind of vector, a string can be created the same way by combining <kbd>new</kbd> and <kbd>push</kbd>; however, because this is really inconvenient, a <kbd>string</kbd>, which is an owned chunk of memory, can be created from a string slice (<kbd>&amp;str</kbd>), which is either a borrowed string or a literal. Both of the ways to do it, that are shown in this recipe, are equivalent:</p>
<pre>    let s = "Hello".to_string();<br/>    println!("s: {}", s);<br/>    let s = String::from("Hello");<br/>    println!("s: {}", s);</pre>
<p>Out of pure personal preference, we will use the first variant.</p>
<div class="packt_infobox">Before Rust <kbd>1.9</kbd>, <kbd>to_owned()</kbd> was the fastest way to create a string. Now, <kbd>to_string()</kbd> is equally performant and should be preferred, because it offers more clarity over what is done. We mention this because many old tutorials and guides have not been updated since then, and still use <kbd>to_owned()</kbd>.</div>
<p>All strings in Rust are valid Unicode in UTF-8 encoding. This can lead to some surprises, as a <em>character</em>, as we know it, is an inherently Latin invention. For instance, look at languages that have a modifier for a letterâis <kbd>Ã¤</kbd>Â an own character, or is it merely a variation of <kbd>a</kbd>? What about languages that allow many combinations in extreme? What would that keyboard even look like? For this reason, Unicode lets you compose your <em>characters</em>Â from different <em>Unicode scalar values</em>. With <kbd>.chars()</kbd>, you can create an iterator that goes through these scalars [28]. If you work with non-Latin characters, you might get surprised by this when accessing composing characters â<kbd>yÌ</kbd> is not one, but two scalars,Â <kbd>y</kbd> andÂ  <kbd>Ì</kbd> [36]. You can get around this by using the <kbd>Unicode-segmentation</kbd> crate, which supports iteration over graphemes: <a href="https://crates.io/crates/unicode-segmentation">https://crates.io/crates/unicode-segmentation.</a></p>
<p><a href="https://crates.io/crates/unicode-segmentation"/></p>
<p>When splitting a string on a pattern that is at the beginning, is at the end, or occurs multiple times after each other, each instance gets split into an empty string <kbd>""</kbd>[107]. This is especially nasty when splitting on spaces (<kbd>' '</kbd>). In this case, you should use <kbd>split_whitespace</kbd> instead [110]. Otherwise, <kbd>split_terminator</kbd> will remove the empty strings from the end of the string [68].</p>
<div class="packt_infobox">By the way, when we talk about a <em>pattern</em> in this recipe, we mean one of three things:<br/>
- <span>A character<br/></span><span>- A string<br/></span><span>- A predicate that takes one <kbd>char</kbd><br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The implementation of <kbd>String</kbd> should not be much of a surprise<span>â</span>it's just a kind of vector:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f412c3fb-e496-4985-af5b-64a327a58aba.jpg" style="width:33.75em;height:12.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing collections as iterators</h1>
                </header>
            
            <article>
                
<p>Welcome to one of the most flexible parts of the Rust standard library. Iterators are, as the name suggests, a way of applying actions of items in a collection. If you come from C#, you will already be familiar with iterators because of Linq. Rust's iterators are kind of similar, but come with a more functional approach to things.</p>
<p>Because they are an extremely fundamental part of the standard library, we are going to dedicate this recipe entirely to a showcase of all the different things you can do with them in isolation. For real-world use cases, you can simply continue reading the book, as a big portion of the other recipes features iterators in some way or another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>iterator.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin iterator</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   fn main() {<br/>2     let names = vec!["Joe", "Miranda", "Alice"];<br/>3     // Iterators can be accessed in many ways.<br/>4     // Nearly all collections implement .iter() for this purpose<br/>5     let mut iter = names.iter();<br/>6     // A string itself is not iterable, but its characters are<br/>7     let mut alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".chars();<br/>8     // Ranges are also (limited) iterators<br/>9     let nums = 0..10;<br/>10    // You can even create infinite iterators!<br/>11    let all_nums = 0..;<br/>12<br/>13    // As the name says, you can iterate over iterators<br/>14    // This will consume the iterator<br/>15    for num in nums {<br/>16        print!("{} ", num);<br/>17    }<br/>18    // nums is no longer usable<br/>19    println!();<br/>20<br/>21    // Get the index of the current item<br/>22    for (index, letter) in "abc".chars().enumerate() {<br/>23      println!("#{}. letter in the alphabet: {}", index + 1,<br/>          letter);<br/>24    }</pre>
<ol start="3">
<li>Access individual items:</li>
</ol>
<pre style="padding-left: 60px">26    // going through an iterator, step by step<br/>27    if let Some(name) = iter.next() {<br/>28        println!("First name: {}", name);<br/>29    }<br/>30    if let Some(name) = iter.next() {<br/>31        println!("Second name: {}", name);<br/>32    }<br/>33    if let Some(name) = iter.next() {<br/>34        println!("Third name: {}", name);<br/>35    }<br/>36    if iter.next().is_none() {<br/>37        println!("No names left");<br/>38    }<br/>39<br/>40    // Arbitrary access to an item in the iterator<br/>41    let letter = alphabet.nth(3);<br/>42    if let Some(letter) = letter {<br/>43      println!("the fourth letter in the alphabet is: {}",<br/>          letter);<br/>44    }<br/>45    // This works by consuming all items up to a point<br/>46    let current_first = alphabet.nth(0);<br/>47    if let Some(current_first) = current_first {<br/>48      // This will NOT print 'A'<br/>49      println!(<br/>50        "The first item in the iterator is currently: {}",<br/>51           current_first<br/>52      );<br/>53    }<br/>54    let current_first = alphabet.nth(0);<br/>55    if let Some(current_first) = current_first {<br/>56      println!(<br/>57        "The first item in the iterator is currently: {}",<br/>58           current_first<br/>59      );<br/>60    }<br/>61<br/>62    // Accessing the last item; This will<br/>63    // consume the entire iterator<br/>64    let last_letter = alphabet.last();<br/>65    if let Some(last_letter) = last_letter {<br/>66      println!("The last letter of the alphabet is: {}",<br/>          last_letter);<br/>67    }</pre>
<ol start="4">
<li>Collect the iterator into a collection:</li>
</ol>
<pre style="padding-left: 60px">69    // Collect iterators into collections<br/>70    // This requires an anotation of which collection we want<br/>71    // The following two are equivalent:<br/>72    let nums: Vec&lt;_&gt; = (1..10).collect();<br/>73    println!("nums: {:?}", nums);<br/>74    let nums = (1..10).collect::&lt;Vec&lt;_&gt;&gt;();<br/>75    println!("nums: {:?}", nums)</pre>
<ol start="5">
<li>Change which items are being iterated over:</li>
</ol>
<pre style="padding-left: 60px">79    // Taking only the first n items<br/>80    // This is often used to make an infinite iterator finite<br/>81    let nums: Vec&lt;_&gt; = all_nums.take(5).collect();<br/>82    println!("The first five numbers are: {:?}", nums);<br/>83<br/>84    // Skip the first few items<br/>85    let nums: Vec&lt;_&gt; = (0..11).skip(2).collect();<br/>86    println!("The last 8 letters in a range from zero to 10:<br/>        {:?}", nums);<br/>87<br/>88    // take and skip accept predicates in the form of<br/>89    // take_while and skip_while<br/>90    let nums: Vec&lt;_&gt; = (0..).take_while(|x| x * x &lt;<br/>      50).collect();<br/>91    println!(<br/>92      "All positive numbers that are less than 50 when squared: <br/>93        {:?}", nums<br/>94    );<br/>95<br/>96    // This is useful to filter an already sorted vector<br/>97    let names = ["Alfred", "Andy", "Jose", "Luke"];<br/>98    let names: Vec&lt;_&gt; = names.iter().skip_while(|x|<br/>        x.starts_with('A')).collect();<br/>99    println!("Names that don't start with 'A': {:?}", names);<br/>100<br/>101   // Filtering iterators<br/>102   let countries = [<br/>103     "U.S.A.",<br/>        "Germany",<br/>        "France",<br/>        "Italy",<br/>        "India",<br/>        "Pakistan",<br/>        "Burma",<br/>104   ];<br/>105   let countries_with_i: Vec&lt;_&gt; = countries<br/>106     .iter()<br/>107     .filter(|country| country.contains('i'))<br/>108     .collect();<br/>109   println!(<br/>110     "Countries containing the letter 'i': {:?}",<br/>111     countries_with_i<br/>112   );</pre>
<ol start="6">
<li>Check if an iterator contains an element:</li>
</ol>
<pre style="padding-left: 60px">116   // Find the first element that satisfies a condition<br/>117   if let Some(country) = countries.iter().find(|country| <br/>118     country.starts_with('I')) {<br/>119       println!("First country starting with the letter 'I':<br/>            {}", country);<br/>        }<br/>120<br/>121   // Don't get the searched item but rather its index<br/>122   if let Some(pos) = countries<br/>123     .iter()<br/>124     .position(|country| country.starts_with('I'))<br/>125     {<br/>126       println!("It's index is: {}", pos);<br/>127     }<br/>128<br/>129   // Check if at least one item satisfies a condition<br/>130   let are_any = countries.iter().any(|country| country.len() ==<br/>        5);<br/>131   println!(<br/>132     "Is there at least one country that has exactly five <br/>         letters? {}",<br/>133      are_any<br/>134   );<br/>135<br/>136   // Check if ALL items satisfy a condition<br/>137   let are_all = countries.iter().all(|country| country.len() ==<br/>        5);<br/>138   println!("Do all countries have exactly five letters? {}",<br/>        are_all);</pre>
<ol start="7">
<li>Useful operations for numeric items:</li>
</ol>
<pre style="padding-left: 60px">141   let sum: i32 = (1..11).sum();<br/>142   let product: i32 = (1..11).product();<br/>143   println!(<br/>144     "When operating on the first ten positive numbers\n\<br/>145      their sum is {} and\n\<br/>146      their product is {}.",<br/>147      sum, product<br/>148   );<br/>149 <br/>150   let max = (1..11).max();<br/>151   let min = (1..11).min();<br/>152   if let Some(max) = max {<br/>153     println!("They have a highest number, and it is {}", max);<br/>154   }<br/>155   if let Some(min) = min {<br/>156     println!("They have a smallest number, and it is {}", min);<br/>157   }</pre>
<ol start="8">
<li>Combine iterators:</li>
</ol>
<pre style="padding-left: 60px">161   // Combine an iterator with itself, making it infinite<br/>162   // When it reaches its end, it starts again<br/>163   let some_numbers: Vec&lt;_&gt; = (1..4).cycle().take(10).collect();<br/>164   // Reader exercise: Try to guess what this will print<br/>165   println!("some_numbers: {:?}", some_numbers);<br/>166 <br/>167   // Combine two iterators by putting them after another<br/>168   let some_numbers: Vec&lt;_&gt; = (1..4).chain(10..14).collect();<br/>169   println!("some_numbers: {:?}", some_numbers);<br/>170 <br/>171   // Zip two iterators together by grouping their first items<br/>172   // together, their second items together, etc.<br/>173   let swiss_post_codes = [8957, 5000, 5034];<br/>174   let swiss_towns = ["Spreitenbach", "Aarau", "Suhr"];<br/>175   let zipped: Vec&lt;_&gt; =<br/>        swiss_post_codes.iter().zip(swiss_towns.iter()).collect();<br/>176   println!("zipped: {:?}", zipped);<br/>177 <br/>178   // Because zip is lazy, you can use two infine ranges<br/>179   let zipped: Vec&lt;_&gt; = (b'A'..)<br/>180     .zip(1..)<br/>181     .take(10)<br/>182     .map(|(ch, num)| (ch as char, num))<br/>183     .collect();<br/>184   println!("zipped: {:?}", zipped);</pre>
<ol start="9">
<li>Apply functions to all items:</li>
</ol>
<pre style="padding-left: 60px">188   // Change the items' types<br/>189   let numbers_as_strings: Vec&lt;_&gt; = (1..11).map(|x|<br/>        x.to_string()).collect();<br/>190   println!("numbers_as_strings: {:?}", numbers_as_strings);<br/>191 <br/>192   // Access all items<br/>193   println!("First ten squares:");<br/>194   (1..11).for_each(|x| print!("{} ", x));<br/>195   println!();<br/>196 <br/>197   // filter and map items at the same time!<br/>198   let squares: Vec&lt;_&gt; = (1..50)<br/>199     .filter_map(|x| if x % 3 == 0 { Some(x * x) } else { None })<br/>200     .collect();<br/>201   println!(<br/>202     "Squares of all numbers under 50 that are divisible by 3: <br/>203      {:?}", squares<br/>204   );</pre>
<ol start="10">
<li>The real strength of iterators comes from combining them:</li>
</ol>
<pre style="padding-left: 60px">208   // Retrieve the entire alphabet in lower and uppercase:<br/>209   let alphabet: Vec&lt;_&gt; = (b'A' .. b'z' + 1) // Start as u8<br/>210     .map(|c| c as char) // Convert all to chars<br/>211     .filter(|c| c.is_alphabetic()) // Filter only alphabetic chars<br/>212     .collect(); // Collect as Vec&lt;char&gt;<br/>213   println!("alphabet: {:?}", alphabet);<br/>214 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><em>This recipe is incredibly important</em>. No matter what you do, or which library you use, it's going to use iterators somewhere. All of the operations presented can be used on any collection and all types that implement the <kbd>iterator</kbd> trait.</p>
<p>In the first section, we looked at different ways to create iterators. I mention that ranges are <em>limited</em>Â because, in order to be iterable, the range-type has to implement <kbd>Step</kbd>. <kbd>char</kbd> doesn't, so you wouldn't be able to use <kbd>'A'..'D'</kbd> as an iterator. For this reason, in line [209], we iterate over the characters as bytes:</p>
<pre>    let alphabet: Vec&lt;_&gt; = (b'A' .. b'z' + 1) // Start as u8<br/>        .map(|c| c as char)            // Convert all to chars<br/>        .filter(|c| c.is_alphabetic()) // Filter only alphabetic chars<br/>        .collect(); // Collect as Vec&lt;char&gt;</pre>
<p>We have to set the limit of the range to <kbd>b'z' + 1</kbd>, because ranges are non-inclusive. You might have noticed that this fact makes using ranges confusing sometimes. This is why, on the nightly compiler, you can use inclusive ranges (<a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml">Chapter 10</a>, <em>Using Experimental Nightly Features</em>, <em>Iterating over an inclusive range</em>).</p>
<p>Let's return to our recipe here, though. While iterating, you have the option to use <kbd>enumerate</kbd> in order to get an iteration counter [22]. This is the reason thatÂ Rust gets away with not supporting traditional, C-style <kbd>for</kbd> loop syntax. You most probably have seen some variation of the following C code in some language or another:</p>
<pre style="padding-left: 30px">for (int i = 0; i &lt; some_length; i++) { <br/>    ... <br/>}</pre>
<p>Rust disallows this, because a range-based <kbd>for</kbd> loop is almost always cleaner to use, which you are going to know if you come from a Python background, as it pioneered this restriction. In fact, most programming languages have shifted their paradigm to promote range-based loops. In the rare cases where you really actually would like to know your iteration count, you can use <kbd>enumerate</kbd> to emulate this behavior.</p>
<p>When accessing single items with <kbd>nth</kbd>[41], you have to keep two things in mind:</p>
<ul>
<li>It accesses an item by going through all items until it reaches the one you want. In the worst case, this is anÂ <img class="fm-editor-equation" src="assets/792fb25a-7101-4b90-9b5c-555fc2e85980.png" style="width:2.25em;height:1.25em;"/>access. If you can, use your collection's native access method (most of the time, this would be <kbd>.get()</kbd>).</li>
<li>It consumes the iterator up to the specified index. This means that calling <kbd>nth</kbd> twice with the exact same parameters is going to result in two different returned values [54]. Don't let this catch you by surprise.</li>
</ul>
<p>Another thing to take note of when using an iterator's various accessors is that they all return an <kbd>Option</kbd> that will be <kbd>None</kbd> if the iterator has no more items left.</p>
<p>When collecting an iterator into a collection, the following two forms of annotation are completely equivalent:</p>
<pre style="padding-left: 30px">let nums: Vec&lt;_&gt; = (1..10).collect();<br/>let nums = (1..10).collect::&lt;Vec&lt;_&gt;&gt;();</pre>
<p>Just use the one that you like most. In this book, we stick to the first form because of personal preference. The second form, by the way, is called the <em>turbofish</em>. This is because <kbd>::&lt;&gt;</kbd> kinda looks like a certain family of fish. Cute, isn't it? Both forms are also able to deduce their exact type automatically, so you don't need to write <kbd>Vec&lt;i32&gt;</kbd>. The inner type can be omitted with an underscore (<kbd>_</kbd>), as shown.</p>
<p><kbd>cycle</kbd> [163] takes an iterator and repeats it endlessly. <kbd>[1, 2, 3]</kbd> would become <kbd>[1, 2, 3, 1, 2, 3, 1, ...]</kbd>.</p>
<p><kbd>zip</kbd> [175] takes two iterators and creates one out of them by putting items that are at the same index into a tuple, and then chaining them. If the iterators have different sizes, it just ignores the extra items of the longer one. For example, <kbd>[1, 2, 3]</kbd> zipped with <kbd>['a', 'b', 'c', 'd']</kbd> would become <kbd>[(1, 'a'), (2, 'b'), (3, 'c')]</kbd>, because <kbd>'d'</kbd> will be thrown away as it has no partner to zip with. If you zip two infinite ranges, you will have no problem, as <kbd>zip</kbd> is lazy, which means it will only actually start zipping your iterators when it's really necessary; for example, when using <kbd>take</kbd> to extract the first few tuples [81].</p>
<p>If you need to mutate all of your items, you can use <kbd>map</kbd>. It can also be used to change the underlying type of the iterator, as shown in line [182]. <kbd>for_each</kbd> is really similar, with one big difference: it doesn't return anything. It's basically the same as manually using a <kbd>for</kbd> loop on an iterator. The intended use case for it is situations in which you have a lot of chained method calls on an iterator, where it can be more elegant to chain <kbd>for_each</kbd> as well, as a kind of <em>consumer</em>.</p>
<div class="packt_tip">Iterators are very often chained together to weave complex transformations together. If you find yourself calling many methods on a single iterator, don't worry, as this is exactly what you should be doing. On the other hand, when you see yourself doing a lot of complicated stuff in a <kbd>for</kbd> loop, you should probably rewrite that code with iterators.</div>
<p>When using <kbd>filter_map</kbd>[199], you can keep an item by returning it, wrapped in <kbd>Some</kbd>. If you want to filter it out, return <kbd>None</kbd>. Before that, you're allowed to change the item in whatever way you want, which is the <kbd>map</kbd> part of the deal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><kbd>iter()</kbd> creates an iterator that <em>borrows</em> items. If you want to create an iterator that <em>consumes</em> items<span>â</span>for example, takes ownership of them by moving themÂ <span>â</span>Â you can use <kbd>into_iter()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>The Iterating over an inclusive range</em> recipe inÂ </span><a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml">Chapter 10</a>, <em>Using Experimental Nightly Features</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a VecDeque</h1>
                </header>
            
            <article>
                
<p>When you need to insert or remove elements regularly into or from the beginning of the vector, your performance might take quite a hit, as it will force the vector to reallocate all data that comes after it. This is especially bothersome when implementing a queue. For this reason, Rust provides you with the <kbd>VecDeque</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>vecdeque.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin vecdeque</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   use std::collections::VecDeque;<br/>2 <br/>3   fn main() {<br/>4     // A VecDeque is best thought of as a<br/>5     // First-In-First-Out (FIFO) queue<br/>6 <br/>7     // Usually, you will use it to push_back data<br/>8     // and then remove it again with pop_front<br/>9     let mut orders = VecDeque::new();<br/>10    println!("A guest ordered oysters!");<br/>11    orders.push_back("oysters");<br/>12 <br/>13    println!("A guest ordered fish and chips!");<br/>14    orders.push_back("fish and chips");<br/>15 <br/>16    let prepared = orders.pop_front();<br/>17    if let Some(prepared) = prepared {<br/>18      println!("{} are ready", prepared);<br/>19    }<br/>20 <br/>21    println!("A guest ordered mozarella sticks!");<br/>22    orders.push_back("mozarella sticks");<br/>23 <br/>24    let prepared = orders.pop_front();<br/>25    if let Some(prepared) = prepared {<br/>26      println!("{} are ready", prepared);<br/>27    }<br/>28 <br/>29    println!("A guest ordered onion rings!");<br/>30    orders.push_back("onion rings");<br/>31 <br/>32    let prepared = orders.pop_front();<br/>33    if let Some(prepared) = prepared {<br/>34      println!("{} are ready", prepared);<br/>35    }<br/>36 <br/>37    let prepared = orders.pop_front();<br/>38    if let Some(prepared) = prepared {<br/>39      println!("{} are ready", prepared);<br/>40    }<br/>41 <br/>42    // You can freely switch your pushing<br/>43    // from front to back and vice versa<br/>44    let mut sentence = VecDeque::new();<br/>45    sentence.push_back("a");<br/>46    sentence.push_front("had");<br/>47    sentence.push_back("little");<br/>48    sentence.push_front("Mary");<br/>49    sentence.push_back("Lamb");<br/>50    println!("sentence: {:?}", sentence);<br/>51 <br/>52    // The same applies to popping data<br/>53    sentence.pop_front();<br/>54    sentence.push_front("Jimmy");<br/>55    sentence.pop_back();<br/>56    sentence.push_back("Cat");<br/>57    println!("sentence: {:?}", sentence);<br/>58 <br/>59 <br/>60    // The rest of the VecDeque's methods are<br/>61    // pretty much the same as the vector's<br/>62    // However, the VecDeque has additional options<br/>63    // when swap removing!<br/>64    let mut some_queue = VecDeque::with_capacity(5);<br/>65    some_queue.push_back("A");<br/>66    some_queue.push_back("B");<br/>67    some_queue.push_back("C");<br/>68    some_queue.push_back("D");<br/>69    some_queue.push_back("E");<br/>70    println!("some_queue: {:?}", some_queue);<br/>71 <br/>72    // This is the same as Vec's swap_remove<br/>73    some_queue.swap_remove_back(2);<br/>74    println!("some_quere after swap_remove_back: {:?}",<br/>        some_queue);<br/>75 <br/>76    // This is the nearly the same, but swaps the removed<br/>77    // element with the first one instead of the last one<br/>78    some_queue.swap_remove_front(2);<br/>79    println!("some_quere after swap_remove_front: {:?}",<br/>        some_queue);<br/>80    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Most of the interface of <kbd>VecDeque</kbd> is identical to <kbd>Vec</kbd>. You can even optimize them the same way with <kbd>with_capacity</kbd> and its <kbd>swap_remove</kbd> equivalents. The differences come from the fact that <kbd>VecDeque</kbd> is more oriented around access from both ends. As such, multiple methods from <kbd>Vec</kbd> that implicitly affect the last element have two equivalents in <kbd>VecDeque</kbd>: one for the front, and one for the back. These are:</p>
<ul>
<li><kbd>push</kbd>, which becomes <kbd>push_front</kbd> [46] and <kbd>push_back</kbd> [11]</li>
<li><kbd>pop</kbd>, which becomes <kbd>pop_front</kbd> [16] and <kbd>pop_back</kbd> [55]</li>
<li><kbd>swap_remove</kbd>, which becomes <kbd>remove_front</kbd> [78] and <kbd>remove_back</kbd> [73]</li>
</ul>
<p>A <kbd>VecDeque</kbd> has the ability to freely append or remove elements from both ends in a performant way, which makes it an ideal candidate for a <strong>First In, First Out</strong> (<strong>FIFO</strong>) queue [24]. In fact, this is how it's nearly always used.</p>
<p>When you see yourself in a situation where you want to respond to any kind of requests in the order they arrive in and remove them again afterwards, a <kbd>VecDeque</kbd> is an ideal tool for the job.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Internally, the <kbd>VecDeque</kbd> is implemented as a <em>ring buffer</em>, also known as aÂ <em>circular buffer</em>. It's called like this because it behaves like a circle: the end touches the beginning.</p>
<p>It works by allocating a continuous block of memory, like the <kbd>Vec</kbd>; however, where the <kbd>Vec</kbd> always leaves its extra capacity at the end of the block, the <kbd>VecDeque</kbd> has nothing against leaving spots inside the block empty. It follows that when you remove the first element, the <kbd>VecDeque</kbd> doesn't move all elements to the left, but simply leaves the first spot empty. If you then push an element into the beginning via <kbd>push_front</kbd>, it will take the spot freed earlier while leaving the elements after it untouched.</p>
<p>The circular catch in the story is that if you have some capacity in the front of the block but none in the back while using <kbd>push_back</kbd>, the <kbd>VecDeque</kbd> will simply use that space to allocate the extra element, leading to the following situation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ecba1589-7d12-447b-8b59-88bc93e537c1.jpg" style="width:32.50em;height:13.92em;"/></div>
<p class="mce-root">This is great, because you will not have to worry about this at all while using it, as its iterating methods hide the implementation by always showing you the <em>correct</em>Â order!</p>
<p>Like the vector, <kbd>VecDeque</kbd> will resize itself and move all its elements into a new block when its capacity runs out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a HashMap</h1>
                </header>
            
            <article>
                
<p>If you imagine a <kbd>Vec</kbd> as a collection that assigns an index (0, 1, 2, and so on) to data, the <kbd>HashMap</kbd> is a collection that assigns any data to any data. It allows you to map arbitrary, hashable data to other arbitrary data. Hashing and mapping, that's where the name comes from!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>hashmap.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin hashmap</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   use std::collections::HashMap; <br/>2 <br/>3   fn main() {<br/>4     // The HashMap can map any hashable type to any other<br/>5     // The first type is called the "key"<br/>6     // and the second one the "value"<br/>7     let mut tv_ratings = HashMap::new();<br/>8     // Here, we are mapping &amp;str to i32<br/>9     tv_ratings.insert("The IT Crowd", 8);<br/>10    tv_ratings.insert("13 Reasons Why", 7);<br/>11    tv_ratings.insert("House of Cards", 9);<br/>12    tv_ratings.insert("Stranger Things", 8);<br/>13    tv_ratings.insert("Breaking Bad", 10);<br/>14 <br/>15    // Does a key exist?<br/>16    let contains_tv_show = tv_ratings.contains_key("House of<br/>        Cards");<br/>17    println!("Did we rate House of Cards? {}", contains_tv_show);<br/>18    let contains_tv_show = tv_ratings.contains_key("House");<br/>19    println!("Did we rate House? {}", contains_tv_show);<br/>20 <br/>21    // Access a value<br/>22    if let Some(rating) = tv_ratings.get("Breaking Bad") {<br/>23      println!("I rate Breaking Bad {} out of 10", rating);<br/>24    }<br/>25 <br/>26    // If we insert a value twice, we overwrite it<br/>27    let old_rating = tv_ratings.insert("13 Reasons Why", 9);<br/>28    if let Some(old_rating) = old_rating {<br/>29      println!("13 Reasons Why's old rating was {} out of 10",<br/>          old_rating);<br/>30    }<br/>31    if let Some(rating) = tv_ratings.get("13 Reasons Why") {<br/>32      println!("But I changed my mind, it's now {} out of 10",<br/>          rating);<br/>33    }<br/>34 <br/>35    // Remove a key and its value<br/>36    let removed_value = tv_ratings.remove("The IT Crowd");<br/>37    if let Some(removed_value) = removed_value {<br/>38       println!("The removed series had a rating of {}",<br/>           removed_value);<br/>39    }<br/>40 <br/>41    // Iterating accesses all keys and values<br/>42    println!("All ratings:");<br/>43    for (key, value) in &amp;tv_ratings {<br/>44      println!("{}\t: {}", key, value);<br/>45    }<br/>46 <br/>47    // We can iterate mutably<br/>48    println!("All ratings with 100 as a maximum:");<br/>49    for (key, value) in &amp;mut tv_ratings {<br/>50      *value *= 10;<br/>51      println!("{}\t: {}", key, value);<br/>52    }<br/>53 <br/>54    // Iterating without referencing the HashMap moves its<br/>        contents<br/>55    for _ in tv_ratings {}<br/>56    // tv_ratings is not usable anymore</pre>
<p style="padding-left: 30px">If you don't need to access both keys and values at the same time, you can iterate over either individually:</p>
<pre style="padding-left: 60px">58    // Like with the other collections, you can preallocate a size<br/>59    // to gain some performance<br/>60    let mut age = HashMap::with_capacity(10);<br/>61    age.insert("Dory", 8);<br/>62    age.insert("Nemo", 5);<br/>63    age.insert("Merlin", 10);<br/>64    age.insert("Bruce", 9);<br/>65 <br/>66    // Iterate over all keys<br/>67    println!("All names:");<br/>68    for name in age.keys() {<br/>69      println!("{}", name);<br/>70    }<br/>71 <br/>72    // Iterate over all values<br/>73    println!("All ages:");<br/>74    for age in age.values() {<br/>75      println!("{}", age);<br/>76    }<br/>77 <br/>78    // Iterate over all values and mutate them<br/>79    println!("All ages in 10 years");<br/>80    for age in age.values_mut() {<br/>81      *age += 10;<br/>82      println!("{}", age);<br/>83    }<br/>84</pre>
<p style="padding-left: 30px">You can use the entry API to assign default values to keys if they're not yet in the <kbd>HashMap</kbd>:</p>
<pre>87    {<br/>88      let age_of_coral = age.entry("coral").or_insert(11);<br/>89      println!("age_of_coral: {}", age_of_coral);<br/>90    }<br/>91    let age_of_coral = age.entry("coral").or_insert(15);<br/>92    println!("age_of_coral: {}", age_of_coral);<br/>93 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, a <kbd>HashMap</kbd> is a collection to map one type of data to another. You do this by calling <kbd>insert</kbd>, and passing your key and its value [9]. If the key already had a value, it will be overwritten. This is why <kbd>insert</kbd> returns an <kbd>Option</kbd>: if there was a value before, it returns the old value [27], or otherwise <kbd>None</kbd>. If you want to make sure that you're not overwriting anything, make sure to check the result of <kbd>contains_key</kbd> [16] before inserting your value.</p>
<p>Both <kbd>get</kbd> and <kbd>remove</kbd> won't crash when called with an invalid key. Instead, they return a <kbd>Result</kbd>. In the case of <kbd>remove</kbd>, said <kbd>Result</kbd> contains the removed value.</p>
<p>As with most collections, you have the options to iterate over your data, by borrowing the key-value pairs[43], borrowing the keys while mutating the values [49], or moving them all [55]. Due to its nature, <kbd>HashMap</kbd> additionally allows you three more options: borrowing all values [74], mutating all values [80], or borrowing all keys [68]. You probably noticed that one combination is missing: you cannot mutate a key. Ever. This is part of the contract you sign when using a <kbd>HashMap</kbd>. Further down, where we explain how <kbd>HashMap</kbd> is implemented, you're going to see that, because the key's hash is actually an index, mutating a key is equivalent to deleting an entry and recreating it. This is reflected nicely in the design choice of not letting you modify keys.</p>
<p>Last but not least, the <kbd>Entry</kbd> API lets you access an abstraction of a value that might or might not be there. Most of the time, it's used while being paired with <kbd>or_insert</kbd> in order to insert a default value if the key was not found [88]. If you want to insert a default value based on a closure, you can use <kbd>or_insert_with</kbd>. Another use for the entry object is to match it against its variants: <kbd>Occupied</kbd>, or <kbd>Vacant</kbd>. This results in the same thing as calling <kbd>get</kbd> directly on a key. Note that in our example, we had to scope the entry access like so:</p>
<pre>    {<br/>        let age_of_coral = age.entry("coral").or_insert(11);<br/>        println!("age_of_coral: {}", age_of_coral);<br/>    }<br/>    let age_of_coral = age.entry("coral").or_insert(15);<br/>    println!("age_of_coral: {}", age_of_coral);</pre>
<p>This is because <kbd>or_insert</kbd> returns a mutable reference to a value. If we had omitted the scope, the second call of <kbd>entry</kbd> would have borrowed our <kbd>age</kbd> object at the same time as a mutable reference to it existed, which is an error in Rust's borrowing concept in order to guarantee data race-free access to resources.</p>
<p>If you need to fine-tune your <kbd>HashMap</kbd> for performance, you can call your usual friends â<kbd>with_capacity</kbd> [60], <kbd>shrink_to_fit</kbd>, and <kbd>reserve</kbd> are also available for it, and work the same way as in other collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Internally, you can imagine the <kbd>HashMap</kbd> as being implemented as two vectors: a table, and a buffer. Of course, we're simplifying here; there are actually no vectors in the implementation. But this analogy is accurate enough.</p>
<div class="packt_infobox">If you want to look at the actual implementation, feel free to do so, as Rust is completely open source: <a href="https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs">https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs.</a></div>
<p>In the background, the buffer stores our values in a sequential fashion. In the front, we have a table storing buckets that don't do much more than point to the element they stand for. When you insert a key-value pair, what happens is:</p>
<ol>
<li>The value gets put in the buffer.</li>
<li>The key goes through a hashing function and becomes an index.</li>
<li>The table creates a bucket at said index that points to the actual value:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/5f00482e-36a3-42ad-8d5d-3c297234858a.jpg" style="width:27.33em;height:23.83em;"/></div>
<div class="packt_infobox">Rust's hashing algorithm doesn't actually generate unique indices, for performance reasons. Instead, Rust uses a clever way to handle hash collisions called <strong>Robin Hood bucket stealing</strong> (<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>).</div>
<p>The default hashing algorithm of the standard library has been chosen specifically to protect you from HashDoS attacks (<a href="https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/">https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/</a>). If you want to squeeze out every bit of performance, you can do that, of your <kbd>HashMap</kbd> without caring about this particular risk, or you can specify a custom hasher by constructing it with <kbd>with_hasher</kbd>.</p>
<div class="packt_tip">Many people have already implemented various hashers on <a href="https://crates.io/">crates.io</a>, so make sure to check them out before rolling with your own solution.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a HashSet</h1>
                </header>
            
            <article>
                
<p>The best way to describe a <kbd>HashSet</kbd> is by describing how it's implemented: <kbd>HashMap&lt;K, ()&gt;</kbd>. It's just a <kbd>HashMap</kbd> without any values!</p>
<p>The two best reasons to choose a <kbd>HashSet</kbd> are:</p>
<ul>
<li>You don't want to deal with duplicate values at all, as it doesn't even include them.</li>
<li>You plan on doing a lot (and I mean aÂ <em>lot</em>) of item lookup - that is the question,Â <em>Does my collection contain this particular item?</em>. In a vector, this is done in <img class="fm-editor-equation" src="assets/c56fbb37-99dd-43e3-ade3-62e3fa3b3bbb.png" style="width:2.08em;height:1.17em;"/>, while a <kbd>HashSet</kbd> can do it in <img class="fm-editor-equation" src="assets/935f6d04-873f-475c-9118-f78c55c2738a.png" style="width:2.00em;height:1.17em;"/>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>hashset.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin hashset</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   use std::collections::HashSet;<br/>2 <br/>3   fn main() {<br/>4     // Most of the interface of HashSet<br/>5     // is the same as HashMap, just without<br/>6     // the methods that handle values<br/>7     let mut books = HashSet::new();<br/>8     books.insert("Harry Potter and the Philosopher's Stone");<br/>9     books.insert("The Name of the Wind");<br/>10    books.insert("A Game of Thrones");<br/>11 <br/>12    // A HashSet will ignore duplicate entries<br/>13    // but will return if an entry is new or not<br/>14    let is_new = books.insert("The Lies of Locke Lamora");<br/>15    if is_new {<br/>16      println!("We've just added a new book!");<br/>17    }<br/>18 <br/>19    let is_new = books.insert("A Game of Thrones");<br/>20    if !is_new {<br/>21      println!("Sorry, we already had that book in store");<br/>22    }<br/>23 <br/>24    // Check if it contains a key<br/>25    if !books.contains("The Doors of Stone") {<br/>26      println!("We sadly don't have that book yet");<br/>27    }<br/>28 <br/>29    // Remove an entry<br/>30    let was_removed = books.remove("The Darkness that comes<br/>        before");<br/>31    if !was_removed {<br/>32      println!("Couldn't remove book; We didn't have it to begin <br/>          with");<br/>33    }<br/>34    let was_removed = books.remove("Harry Potter and the <br/>        Philosopher's Stone");<br/>35    if was_removed {<br/>36      println!("Oops, we lost a book");<br/>37    }</pre>
<ol start="3">
<li>Compare different <kbd>HashSet</kbd>s:</li>
</ol>
<pre style="padding-left: 60px">41    let one_to_five: HashSet&lt;_&gt; = (1..6).collect();<br/>42    let five_to_ten: HashSet&lt;_&gt; = (5..11).collect();<br/>43    let one_to_ten: HashSet&lt;_&gt; = (1..11).collect();<br/>44    let three_to_eight: HashSet&lt;_&gt; = (3..9).collect();<br/>45 <br/>46    // Check if two HashSets have no elements in common<br/>47    let is_disjoint = one_to_five.is_disjoint(&amp;five_to_ten);<br/>48    println!(<br/>49      "is {:?} disjoint from {:?}?: {}",<br/>50       one_to_five,<br/>51       five_to_ten,<br/>52       is_disjoint<br/>53    );<br/>54    let is_disjoint = one_to_five.is_disjoint(&amp;three_to_eight);<br/>55    println!(<br/>56      "is {:?} disjoint from {:?}?: {}",<br/>57       one_to_five,<br/>58       three_to_eight,<br/>59       is_disjoint<br/>60    );<br/>61 <br/>62    // Check if a HashSet is fully contained in another<br/>63    let is_subset = one_to_five.is_subset(&amp;five_to_ten);<br/>64    println!(<br/>65      "is {:?} a subset of {:?}?: {}",<br/>66       one_to_five,<br/>67       five_to_ten,<br/>68       is_subset<br/>69    );<br/>70    let is_subset = one_to_five.is_subset(&amp;one_to_ten);<br/>71    println!(<br/>72      "is {:?} a subset of {:?}?: {}",<br/>73       one_to_five,<br/>74       one_to_ten,<br/>75       is_subset<br/>76    );<br/>77 <br/>78    // Check if a HashSet fully contains another<br/>79    let is_superset = three_to_eight.is_superset(&amp;five_to_ten);<br/>80    println!(<br/>81      "is {:?} a superset of {:?}?: {}",<br/>82      three_to_eight,<br/>83      five_to_ten,<br/>84      is_superset<br/>85    );<br/>86    let is_superset = one_to_ten.is_superset(&amp;five_to_ten);<br/>87    println!(<br/>88    "is {:?} a superset of {:?}?: {}",<br/>89      one_to_ten,<br/>90      five_to_ten,<br/>91      is_superset<br/>92    );</pre>
<ol start="4">
<li>Join two <kbd>HashSet</kbd>s in various ways:</li>
</ol>
<pre style="padding-left: 60px">96    // Get the values that are in the first HashSet<br/>97    // but not in the second<br/>98    let difference = one_to_five.difference(&amp;three_to_eight);<br/>99    println!(<br/>100     "The difference between {:?} and {:?} is {:?}",<br/>101      one_to_five,<br/>102      three_to_eight,<br/>103      difference<br/>104   );<br/>105 <br/>106   // Get the values that are in either HashSets, but not in both<br/>107   let symmetric_difference = <br/>        one_to_five.symmetric_difference(&amp;three_to_eight);<br/>108   println!(<br/>109     "The symmetric difference between {:?} and {:?} is {:?}",<br/>110      one_to_five,<br/>111      three_to_eight,<br/>112      symmetric_difference<br/>113   );<br/>114 <br/>115   // Get the values that are in both HashSets<br/>116   let intersection = one_to_five.intersection(&amp;three_to_eight);<br/>117   println!(<br/>118     "The intersection difference between {:?} and {:?} is {:?}",<br/>119      one_to_five,<br/>120      three_to_eight,<br/>121      intersection<br/>122   );<br/>123 <br/>124   // Get all values in both HashSets<br/>125   let union = one_to_five.union(&amp;three_to_eight);<br/>126   println!(<br/>127     "The union difference between {:?} and {:?} is {:?}",<br/>128      one_to_five,<br/>129      three_to_eight,<br/>130      union<br/>131   );<br/>132 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">As a <kbd>HashSet</kbd> is a kind of <kbd>HashMap</kbd>, most of its interface is pretty similar. The major difference is that the methods that would return a key's value in the <kbd>HashMap</kbd> instead simply return a <kbd>bool</kbd> on the <kbd>HashSet</kbd> in order to tell if a key already existed or not [14].</p>
<p>Additionally, <kbd>HashSet</kbd> brings a few methods for analyzing two sets [46 to 92] and joining them [96 to 131]. If you've ever heard of set theory or Venn diagrams, or done a bit of SQL, you're going to recognize it all. Otherwise, I advise you to run the example, and study the outputs in combination with the relevant comments.</p>
<p>Some illustrations might help you. For the analytical methods, the dark green part is the object of reference:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/10d70a1a-add1-4a70-9aa8-4171a0333bfc.png" style="width:34.75em;height:12.00em;"/></div>
<p>For the selecting methods, the dark green part is the one that is returned:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8e2fe489-c9f3-4564-bdeb-5ccc79a72941.png" style="width:28.08em;height:17.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>No big surprises in the implementation of the <kbd>HashSet</kbd>, since it's exactly the same as the <kbd>HashMap</kbd>, just without any values!</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3cdac45c-92c6-467d-9886-0dab7038cbaa.jpg" style="width:32.08em;height:13.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an own iterator</h1>
                </header>
            
            <article>
                
<p>When you create an infinitely applicable algorithm or a collection-like structure, it's really nice to have the dozens of methods that an iterator provides at your disposal. For this, you will have to know how to tell Rust to implement them for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>own_iterator.rs</kbd>.</li>
<li>Add the following code, and run it with <kbd>cargo run --bin own_iterator</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   fn main() {<br/>2     let fib: Vec&lt;_&gt; = fibonacci().take(10).collect();<br/>3     println!("First 10 numbers of the fibonacci sequence: {:?}", <br/>        fib);<br/>4 <br/>5     let mut squared_vec = SquaredVec::new();<br/>6     squared_vec.push(1);<br/>7     squared_vec.push(2);<br/>8     squared_vec.push(3);<br/>9     squared_vec.push(4);<br/>10    for (index, num) in squared_vec.iter().enumerate() {<br/>11      println!("{}^2 is {}", index + 1, num);<br/>12    }<br/>13  }<br/>14 <br/>15 <br/>16  fn fibonacci() -&gt; Fibonacci {<br/>17    Fibonacci { curr: 0, next: 1 }<br/>18  }<br/>19  struct Fibonacci {<br/>20  curr: u32,<br/>21  next: u32,<br/>22  }<br/>23  // A custom iterator has to implement<br/>24  // only one method: What comes next<br/>25  impl Iterator for Fibonacci {<br/>26    type Item = u32;<br/>27    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {<br/>28      let old = self.curr;<br/>29      self.curr = self.next;<br/>30      self.next += old;<br/>31      Some(old)<br/>32    }<br/>33  }<br/>34 <br/>35 <br/>36  use std::ops::Mul;<br/>37  struct SquaredVec&lt;T&gt;<br/>38  where<br/>39  T: Mul + Copy,<br/>40  {<br/>41    vec: Vec&lt;T::Output&gt;,<br/>42  }<br/>43  impl&lt;T&gt; SquaredVec&lt;T&gt;<br/>44  where<br/>45  T: Mul + Copy,<br/>46  {<br/>47    fn new() -&gt; Self {<br/>48    SquaredVec { vec: Vec::new() }<br/>49  }<br/>50  fn push(&amp;mut self, item: T) {<br/>51    self.vec.push(item * item);<br/>52  }<br/>53 }<br/>54 <br/>55  // When creating an iterator over a collection-like struct<br/>56  // It's best to just allow it to be convertible into<br/>57  // a slice of your underlying type.<br/>58  // This way you automatically implemented a bunch of methods<br/>59  // and are flexible enough to change your implementation later<br/>      on<br/>60  use std::ops::Deref;<br/>61  impl&lt;T&gt; Deref for SquaredVec&lt;T&gt;<br/>62  where<br/>63  T: Mul + Copy,<br/>64  {<br/>65    type Target = [T::Output];<br/>66    fn deref(&amp;self) -&gt; &amp;Self::Target {<br/>67    &amp;self.vec<br/>68  }<br/>69 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In our little example here, we are going to look at two different uses for an iterator:</p>
<ul>
<li><kbd>fibonacci()</kbd>, which returns an infinite range of the <strong>Fibonacci sequence</strong></li>
<li><kbd>SquaredVec</kbd>, which implements a (very) small subset of a <kbd>Vec</kbd> with a twist: it squares all items</li>
</ul>
<div class="packt_infobox">The Fibonacci sequence is defined as a series of numbers, starting from 0 and 1, where the next number is the sum of the last two. It starts like this: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.<br/>
The first two are 0 and 1 per definition. The next one is their sum âÂ <em>0 + 1 = 1</em>. After that comes <em>1 + 1 = 2</em>. Then <em>2 + 1 = 3</em>. <em>3 + 2 = 5</em>. Repeat ad infinitum.</div>
<p>An algorithm can be turned into an iterator by implementing the <kbd>Iterator</kbd> trait. This is pretty simple, as it only expects you to provide the type you're iterating over and a single method, <kbd>next</kbd>, which fetches the next item. If the iterator doesn't have any items left, it should return <kbd>None</kbd>, otherwise <kbd>Some</kbd>. Our Fibonacci iterator always returns <kbd>Some</kbd> item, which makes it an infinite iterator [31].</p>
<p>Our <kbd>SquaredVec</kbd>, on the other hand, is more of a collection than an algorithm. In lines [37] to [53], we wrap the minimum of the <kbd>Vec</kbd> interface â we can create a <kbd>SquaredVec</kbd>, and we can fill it. Our type constraints <kbd>Mul + Copy</kbd> mean that the item the user wants to store has to be able to be copied and to be multiplied. We need this in order to square it, but it's not relevant for the iterator. <kbd>T::Output</kbd> is just the type that a multiplication would return, which most of the time is going to be <kbd>T</kbd> itself.</p>
<p>We could implement the <kbd>Iterator</kbd> trait again, but there's an easier option that will provide you with even more methods. We can allow our struct to be implicitly convertible into a slice <kbd>[T]</kbd>, which will not only implement <kbd>Iterator</kbd> for you, but also a whole bunch of other methods. Because <kbd>Vec</kbd> implements it already, you can just return it like that [67]. If your underlying collection didn't provide a slice conversion, you could still go the same way as before and implement the <kbd>Iterator</kbd> trait manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you have a lot of complex logic to perform in the iterator and want to separate it a bit from your collection, you can do so by providing your collection with the <kbd>IntoIterator</kbd> trait instead. This would allow you to return a struct specifically made for your iteration, which itself provides the <kbd>Iterator</kbd> trait.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a slab</h1>
                </header>
            
            <article>
                
<p>Some algorithms require you to hold access tokens to data that may or may not exist. This could be solved in Rust by usingÂ Â <kbd>Vec&lt;Option&lt;T&gt;&gt;</kbd>, and treating the index of your data as a token. But we can do better!Â <kbd>slab</kbd> is an optimized abstraction of exactly this concept.</p>
<p>While it is not meant as a general-purpose collection, <kbd>slab</kbd> can help you a lot if you use it in the right places.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">slab = "0.4.0"</pre>
<ol start="3">
<li>If you want, you can go to slab's crates.io page (<a href="https://crates.io/crates/slab">https://crates.io/crates/slab</a>) to check for the newest version, and use that one instead.</li>
<li>
<p>In the folder <kbd>bin</kbd>, create a file called <kbd>slab.rs</kbd>.</p>
</li>
<li>
<p>Add the following code, and run it with <kbd>cargo run --bin slab</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   extern crate slab;<br/>2   use slab::{Slab, VacantEntry};<br/>3 <br/>4   fn main() {<br/>5     // A slab is meant to be used as a limited buffer<br/>6     // As such, you should initialize it with a pre-<br/>7     // defined capacity<br/>8     const CAPACITY: usize = 1024;<br/>9     let mut slab = Slab::with_capacity(CAPACITY);<br/>10 <br/>11    // You cannot simply access a slab's entry by<br/>12    // index or by searching it. Instead, every<br/>13    // insert gives you a key that you can use to<br/>14    // access its entry<br/>15    let hello_key = slab.insert("hello");<br/>16    let world_key = slab.insert("world");<br/>17 <br/>18    println!("hello_key -&gt; '{}'", slab[hello_key],);<br/>19    println!("world_key -&gt; '{}'", slab[world_key],);<br/>20 <br/>21 <br/>22    // You can pass an "empty spot" around<br/>23    // in order to be filled<br/>24    let data_key = {<br/>25    let entry = slab.vacant_entry();<br/>26      fill_some_data(entry)<br/>27    };<br/>28    println!("data_key -&gt; '{}'", slab[data_key],);<br/>29 <br/>30    // When iterating, you get a key-value pair<br/>31    for (key, val) in &amp;slab {<br/>32      println!("{} -&gt; {}", key, val);<br/>33    }<br/>34 <br/>35    // If you want to keep your slab at a constant<br/>36    // capacity, you have to manually check its<br/>37    // length before inserting data<br/>38    if slab.len() != slab.capacity() {<br/>39      slab.insert("the slab is not at capacity yet");<br/>40    }<br/>41  }<br/>42 <br/>43 <br/>44  fn fill_some_data(entry: VacantEntry&lt;&amp;str&gt;) -&gt; usize {<br/>45    let data = "Some data";<br/>46    // insert() consumes the entry<br/>47    // so we need to get the key before<br/>48    let key = entry.key();<br/>49    entry.insert(data);<br/>50    key<br/>51  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A slab is very similar to a vector, with one quintessential difference: you don't get to choose your index. Instead, when inserting data [15], you receive the data's index as a kind of <em>key</em> that you can use to access it again. It is your responsibility to store this key somewhere; otherwise, the only way to retrieve your data is by iterating over your slab. The flipside is that you don't have to provide any key either. In contrast to a <kbd>HashMap</kbd>, you don't need any hashable objects at all.</p>
<p>A situation in which this is useful is in a connection pool: if you have multiple clients who want to access individual resources, you can store said resources in a slab and provide the clients with their key as a kind of token.</p>
<p>This example suits the second use case of a slab really well. Suppose you only accept a certain amount of connections at a given time. When accepting a connection, you don't care about the exact index, or the way it is stored. Instead, you care only that it is stored in a retrievable way, and that it doesn't exceed your limit. This fits the bill of the slab quite nicely, which is why most of the time you won't be creating a slab with <kbd>Slab::new()</kbd>, but with <kbd>with_capacity</kbd>, set to a constant upper limit [9].</p>
<p>The slab, however, does not impose this limit by itself, as it behaves exactly like the vector in the way it handles capacity: as soon as the length exceeds the capacity, the slab reallocates all objects to a bigger block of memory and ups the capacity. This is why, when dealing with upper bonds, you should insert your data with some kind of variation of line [38]:</p>
<pre>    if slab.len() != slab.capacity() {<br/>        slab.insert("the slab is not at capacity yet");<br/>    }</pre>
<p>Other valid approaches would be to wrap an insertion in a function that returns a <kbd>Result</kbd>, or an <kbd>Option</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>A slab is backed by a <kbd>Vec&lt;Entry&gt;</kbd>. You might remember the <kbd>Entry</kbd> from our recipe about the <kbd>HashMap</kbd> earlier. It is the same as an <kbd>Option</kbd>, with the difference that its variants are not called <kbd>Some(...)</kbd> and <kbd>None</kbd>, butÂ <kbd>Occupied(...)</kbd> and <kbd>Vacant</kbd>. This means that, in a nutshell, a slab is implemented as a vector with holes in it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cbef86f3-406c-4974-b3a9-5779da64a90e.jpg" style="width:34.92em;height:23.33em;"/></div>
<p class="mce-root">Additionally, in order to guarantee fast occupation of vacant spots, the slab keeps a linked list of all vacant entries.</p>


            </article>

            
        </section>
    </body></html>