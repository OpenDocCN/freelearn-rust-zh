<html><head></head><body>
		<div><h1 id="_idParaDest-152"><em class="italic"><a id="_idTextAnchor153"/>Chapter 15</em>: Improving the Rocket Application</h1>
			<p>Now that we have finished the simple application, in this final chapter, we will explore the improvements we can make to the Rocket application.</p>
			<p>In this chapter, we will learn about adding various technologies such as logging, tracing, and monitoring to bring the Rocket application up to the standard of modern web development. We will explore techniques to scale the Rocket application.</p>
			<p>We will also explore other web frameworks for the Rust language. One web framework might not be the best tool for everything, so by knowing about other web frameworks, we can broaden our knowledge of the Rust web ecosystem. </p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Extending the Rocket application</li>
				<li>Scaling the Rocket application</li>
				<li>Exploring alternative Rust web frameworks</li>
			</ul>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor154"/>Technical requirements</h1>
			<p>The technical requirements for this chapter are very simple: the Rust compiler, the Cargo command line, and a web browser.</p>
			<p>You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter15</a>.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Extending the Rocket application</h1>
			<p>We have successfully created a simple Rocket application<a id="_idIndexMarker753"/> from scratch, starting with a basic Rocket concept such as routing. There are a lot of things that can be done to improve the application. In this section, we are going to discuss some of the libraries<a id="_idIndexMarker754"/> we can use to add functionality and improvements to the system.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Adding logging</h2>
			<p>A good web application in a modern setup<a id="_idIndexMarker755"/> usually requires logging and monitoring systems to obtain information about the system itself. Previously, we learned how to add logging to the Rocket application. The logging system writes to <code>stdout</code> and to a file. We can improve the logging system by using a distributed logging system in which the application sends the log to another server to create an ongoing record of application events.</p>
			<p>We can create a Rocket fairing that sends log events to a third-party logging server such as Logstash, Fluentd, or Datadog. The logs can then be extracted, transformed, aggregated, filtered, and searched for further analysis.</p>
			<p>An example of a crate that can be used to send a log to Fluentd is at <a href="https://github.com/tkrs/poston">https://github.com/tkrs/poston</a>. Using a <code>poston</code> crate, we can create a worker pool to send data periodically to a Fluentd server.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Expanding logging to tracing</h2>
			<p>After setting logging<a id="_idIndexMarker756"/> for the Rocket application, we can improve the logging functionality further with the tracing concept. Where logging is usually concerned with recording an individual event, tracing is concerned with the workflow of an application. There are several terminologies that are commonly used, including <strong class="bold">log</strong>, <strong class="bold">event</strong>, <strong class="bold">span</strong>, and <strong class="bold">trace</strong>.</p>
			<p>A <strong class="bold">log</strong> is a single piece<a id="_idIndexMarker757"/> of information used by programmers to capture data, while an <strong class="bold">event</strong> is the structured form<a id="_idIndexMarker758"/> of a log. For example, let's say<a id="_idIndexMarker759"/> we have a log using the <strong class="bold">Common Log Format</strong> (<a href="https://en.wikipedia.org/wiki/Common_Log_Format">https://en.wikipedia.org/wiki/Common_Log_Format</a>) as shown here:</p>
			<pre>127.0.0.1 user-identifier frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326</pre>
			<p>We can convert the log into an event as follows:</p>
			<pre>{
    "request.host": "127.0.0.1",
    "request.ident": "user-identifier",
    "request.authuser": "frank",
    "request.date": "2000-10-10 13:55:36-07",
    "request.request": "GET /apache_pb.gif HTTP/1.0",
    "request.status": 200,
    "request.bytes": 2326,
}</pre>
			<p>A <strong class="bold">span</strong> is a type of log, but instead<a id="_idIndexMarker760"/> of information from a single point in time, a span covers a duration. And, finally, a <strong class="bold">trace</strong> is a collection<a id="_idIndexMarker761"/> of spans that can be used to create<a id="_idIndexMarker762"/> a workflow of application parts.</p>
			<p>Suppose we have a Rocket application with a fairing named <code>Trace</code>, we can implement tracing by using the <code>Trace</code> fairing and following these steps:</p>
			<ol>
				<li>Create a struct that implements a Rocket request guard, for example, <code>RequestID</code>.</li>
				<li>When a request arrives, the <code>Trace</code> fairing assigns <code>request_id</code> (an instance of <code>RequestID</code>) to the <code>Request</code> instance. </li>
				<li>The <code>Trace</code> fairing then creates a log with the <code>request_id</code> and <code>start_time</code> information.</li>
				<li>A route handling function then retrieves <code>request_id</code> as a parameter because the struct implements the Rocket request guard.</li>
				<li>Inside the route handling function, the first thing we want the application to do is to create a log with <code>request_id</code> and the <code>function_start_time</code> information.</li>
				<li>We can add various logs inside the function to record the timing; for example, before we send a query to the database, we create a log with <code>request_id</code> and time information. Later, we can create a log again when we receive the response from the database. </li>
				<li>We can then add a log again before the function returns with the <code>request_id</code> and time to mark the end of the function.</li>
				<li>Finally, in the <code>Trace</code> fairing, we create a log again with <code>request_id</code> and <code>end_time</code>.</li>
			</ol>
			<p>By transforming and analyzing<a id="_idIndexMarker763"/> the logs, we can construct the logs with the same <code>request_id</code> into spans. Finally, we can construct the trees of the spans into a trace that records the timing of each event of a request in the Rocket request-response life cycle. By using tracing information, we can determine which parts of the application can be improved further.</p>
			<p>There are a couple of crates<a id="_idIndexMarker764"/> that we can use to do the tracing, for example, <a href="https://docs.rs/tracing/latest/tracing/">https://docs.rs/tracing/latest/tracing/</a> and <a href="https://docs.rs/tracing-log/latest/tracing_log/">https://docs.rs/tracing-log/latest/tracing_log/</a>, which bridge the Rust<a id="_idIndexMarker765"/> logging functionality to the tracing functionality.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Setting monitoring</h2>
			<p>Where logging and tracing are used <a id="_idIndexMarker766"/>to obtain information for the Rocket application, then monitoring is the process to obtain information for the system to evaluate the system's capabilities itself. For example, we collect our server CPU usage for the Rocket application.</p>
			<p>For monitoring, we can use tools such as Prometheus with Grafana as the visualizer, Datadog, or other third-party applications. We usually install an agent, an application that collects and sends various system information to a distributed monitoring server.</p>
			<p>Even though there's no direct connection to the Rocket application, usually, a monitoring system also collects information about the application itself. For example, in a containerized environment, there are liveness and readiness concepts that make sure a container is ready to receive its intended function.</p>
			<p>We can set a route in the Rocket application that returns a <code>200</code> HTTP status code, or a route that pings the database and returns a <code>200</code> HTTP status code. We can then tell the monitoring system to periodically check the response from the Rocket application. If there's a response, it means the application still works correctly, but if there's no response, it means there's something wrong with the Rocket application.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Setting up a mailing and alerting system</h2>
			<p>Sometimes, we need mailing functionality<a id="_idIndexMarker767"/> in a web application. For example, when<a id="_idIndexMarker768"/> a user registers on a website, the system then sends an email for verification. There are a couple of libraries to send an email for Rust. An example is the Lettre crate (<a href="https://crates.io/crates/lettre">https://crates.io/crates/lettre</a>). Let's take a look at the sample code for sending an email.</p>
			<p>In <code>Cargo.toml</code>, add the following dependencies:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">lettre = "0.9"</pre>
			<pre class="source-code">lettre_email = "0.9"</pre>
			<p>In the application, for example in <code>src/lib.rs</code>, we can add the following function to send an email:</p>
			<pre class="source-code">use lettre::{SmtpClient, Transport};</pre>
			<pre class="source-code">use lettre_email::EmailBuilder;</pre>
			<pre class="source-code">fn send_email(email: &amp;str, name: &amp;str) -&gt; Result&lt;String, String&gt; {</pre>
			<pre class="source-code">    let email = EmailBuilder::new()</pre>
			<pre class="source-code">        .to((email, name))</pre>
			<pre class="source-code">        .from("admin@our_application.com")</pre>
			<pre class="source-code">        .subject("Hi, welcome to our_application")</pre>
			<pre class="source-code">        .text("Hello, thank you for joining our_</pre>
			<pre class="source-code">        application.")</pre>
			<pre class="source-code">        .build()</pre>
			<pre class="source-code">        .unwrap();</pre>
			<pre class="source-code">    let mut mailer = SmtpClient::new_unencrypted_</pre>
			<pre class="source-code">    localhost().unwrap().transport();</pre>
			<pre class="source-code">    mailer</pre>
			<pre class="source-code">        .send(email.into())</pre>
			<pre class="source-code">        .map(|_| String::from("Successfuly sent email"))</pre>
			<pre class="source-code">        .map_err(|_| String::from("Couldn't send email"))</pre>
			<pre class="source-code">}</pre>
			<p>One more thing we can add to the application<a id="_idIndexMarker769"/> is an alerting system for when something<a id="_idIndexMarker770"/> goes wrong. We can use a third-party notification system or use the mailing system to send a notification if something goes wrong.</p>
			<p>Now that we have looked at several ways to improve the Rocket application, let's scale our application.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Scaling the Rocket application</h1>
			<p>After developing the Rocket application<a id="_idIndexMarker771"/> and deploying it to a production environment, the application might need to be scaled up due to increasing usage. There are a couple of ways to scale the web application, and they can be categorized into two categories: vertical scaling and horizontal scaling.</p>
			<p><strong class="bold">Vertical scaling</strong> means increasing the resources<a id="_idIndexMarker772"/> for a single node. For example, we replace the CPU of the computer that runs the Rocket application with a CPU with higher speed. Another example of vertical scaling is increasing the amount of RAM in the computer that runs the Rocket application.</p>
			<p><strong class="bold">Horizontal scaling</strong> is scaling the application by adding<a id="_idIndexMarker773"/> more nodes or more computers to handle the workload. An example of horizontal scaling is running two servers and setting up a Rocket web server on each server.</p>
			<p>Suppose we have the following system:</p>
			<div><div><img src="img/Figure_15.1_B16825.jpg" alt=" Figure 15.1 – Simple Rocket application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 15.1 – Simple Rocket application</p>
			<p> We can first move the database to another server as follows:</p>
			<div><div><img src="img/Figure_15.2_B16825.jpg" alt="Figure 15.2 – Separating the database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – Separating the database</p>
			<p>Then, we can add a load balancer<a id="_idIndexMarker774"/> as in the following:</p>
			<div><div><img src="img/Figure_15.3_B16825.jpg" alt="Figure 15.3 – Adding a load balancer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – Adding a load balancer</p>
			<p>The load balancer can be a hardware load balancer, an IaaS (Infrastructure as a service) load balancer such as AWS Load Balancer, a Kubernetes load balancer, or a software load balancer such as HAProxy or NGINX.</p>
			<p>After we add the load balancer, we can then add other machines, each with their own Rocket server instance, as follows:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_15.4_B16825.jpg" alt="Figure 15.4 – Scaling the Rocket application horizontally&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – Scaling the Rocket application horizontally</p>
			<p>There are a couple of things <a id="_idIndexMarker775"/>we need to take care of if we want to load balance the Rocket server, for example, make sure <code>"secret_key"</code> in <code>Rocket.toml</code> is the same for all the Rocket server instances. Another thing we can do is make sure our session libraries and cookies are not storing the content on the memory of each instance, but on shared storage, such as a database.</p>
			<p>Yet another idea to improve Rocket application scaling is hosting static files or assets on their own server. The static files server can be a general-purpose web server such as an Apache HTTP Server or NGINX or a service such as AWS S3 or Azure Storage. One thing we need to take care of is that when generating a Rocket response, we need to set the static assets into the correct server. For example, instead of setting the HTML CSS to <code>"./mini-default.css"</code>, we have to set <code>"</code><a href="https://static.example.com/mini-default.css">https://static.example.com/mini-default.css</a><code>"</code>.</p>
			<p>A diagram of the static server along with the load balancer can be seen in the following figure:</p>
			<div><div><img src="img/Figure_15.5_B16825.jpg" alt="Figure 15.5 – Adding a static files server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5 – Adding a static files server</p>
			<p>We<a id="_idIndexMarker776"/> can also add a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>) to distribute the load<a id="_idIndexMarker777"/> on the system, as follows: </p>
			<div><div><img src="img/Figure_15.6_B16825.jpg" alt="Figure 15.6 – Adding a CDN&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.6 – Adding a CDN</p>
			<p>The CDN can be from the IaaS, such as AWS CloudFront or GCP Cloud CDN, or a third-party CDN provider such as Fastly, Akamai, or Cloudflare. These CDNs provide servers in various geographical locations and can provide caching and a faster network connection to make our application faster.</p>
			<p>After basic scaling, the system can be scaled further, such as by adding database replications or clusters, or <a id="_idIndexMarker778"/>adding caching systems such as Redis or Redis cache clusters. An example of such a system is shown here:</p>
			<div><div><img src="img/Figure_15.7_B16825.jpg" alt="Figure 15.7 – Adding a database cluster and cache cluster&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7 – Adding a database cluster and cache cluster</p>
			<p>An important part of scaling the system is identifying which part's specification can be improved or which part can be isolated into its own server, for example, increasing the CPU of the computer that runs the Rocket server or moving the database into its own server and then later scaling the database itself from a single server into a database cluster.</p>
			<p>Now that we have learned the basic techniques of scaling a Rocket application, let's discuss some other software that's similar to the Rocket web framework in the next section.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor161"/>Exploring alternative Rust web frameworks</h1>
			<p>Rocket is a good web framework for the Rust programming language, but sometimes, we require other tools to build<a id="_idIndexMarker779"/> a web application. In this section, we are going to explore some alternatives to the Rocket web framework. The alternative frameworks are Actix Web, Tide, and Warp. Let's check the web frameworks one by one.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>Actix Web</h2>
			<p>One good alternative<a id="_idIndexMarker780"/> to Rocket is Actix Web (<a href="https://actix.rs/">https://actix.rs/</a>). Just like Rocket, Actix Web<a id="_idIndexMarker781"/> is a web framework. Originally, it was created on top of the Actix crate, an actor framework. These days, the functionality from Actix is not used anymore as Rust's futures and <code>async</code>/<code>await</code> ecosystem is maturing.</p>
			<p>Just like Rocket, Actix Web<a id="_idIndexMarker782"/> includes concepts such as routing, request extractor, form handler, response handler, and a middleware system. Actix Web also provides conveniences such as a static file handler, a database connection, templating, and many more.</p>
			<p>Let's take a look at a code sample for Actix Web to see the similarities with Rocket.</p>
			<p>In <code>Cargo.toml</code>, add the following:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">actix-web = "4.0.1"</pre>
			<p>And, in <code>src/main.rs</code>, add the following:</p>
			<pre class="source-code">use actix_web::{get, web, App, HttpServer, Responder};</pre>
			<pre class="source-code">#[get("/users/{name}")]</pre>
			<pre class="source-code">async fn user(name: web::Path&lt;String&gt;) -&gt; impl Responder {</pre>
			<pre class="source-code">    format!("Hello {name}!")</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[actix_web::main]</pre>
			<pre class="source-code">async fn main() -&gt; std::io::Result&lt;()&gt; {</pre>
			<pre class="source-code">    HttpServer::new(|| {</pre>
			<pre class="source-code">        App::new()</pre>
			<pre class="source-code">            .route("/hello_world", web::get().to(|| async { </pre>
			<pre class="source-code">            "Hello World!" }))</pre>
			<pre class="source-code">            .service(user)</pre>
			<pre class="source-code">    })</pre>
			<pre class="source-code">    .bind(("127.0.0.1", 8080))?</pre>
			<pre class="source-code">    .run()</pre>
			<pre class="source-code">    .await</pre>
			<pre class="source-code">}</pre>
			<p>Try running the application<a id="_idIndexMarker783"/> and opening <code>http://127.0.0.1:8080/hello_world</code> or <code>http://127.0.0.1:8080/users/world</code> to see the result.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Tide</h2>
			<p>Another Rust web framework<a id="_idIndexMarker784"/> alternative is Tide (<a href="https://github.com/http-rs/tide">https://github.com/http-rs/tide</a>). Unlike Rocket or Actix Web, this framework provides only basic functions, such as request type, result type, sessions, and middleware.</p>
			<p>Let's take a look at a code sample for Tide to see the similarities with Rocket.</p>
			<p>In <code>Cargo.toml</code>, add the following:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">tide = "0.16.0"</pre>
			<pre class="source-code">async-std = { version = "1.8.0", features = ["attributes"] }</pre>
			<p>And, in <code>src/main.rs</code>, add the following:</p>
			<pre class="source-code">use tide::Request;</pre>
			<pre class="source-code">async fn hello_world(_: Request&lt;()&gt;) -&gt; tide::Result {</pre>
			<pre class="source-code">    Ok(String::from("Hello World!").into())</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">#[async_std::main]</pre>
			<pre class="source-code">async fn main() -&gt; tide::Result&lt;()&gt; {</pre>
			<pre class="source-code">    let mut app = tide::new();</pre>
			<pre class="source-code">    app.at("/hello_world").get(hello_world);</pre>
			<pre class="source-code">    app.listen("127.0.0.1:8080").await?;</pre>
			<pre class="source-code">    Ok(())</pre>
			<pre class="source-code">}</pre>
			<p>Try running the application<a id="_idIndexMarker785"/> by running <code>cargo run</code> on the command line and opening <code>http://127.0.0.1:8080/hello_world</code> in the browser.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Warp</h1>
			<p>Another Rust web framework alternative is Warp (<a href="https://github.com/seanmonstar/warp">https://github.com/seanmonstar/warp</a>). This framework provides various<a id="_idIndexMarker786"/> functionalities on top of its filter function. By using the filter, it can perform path routing, extract parameters and headers, deserialize query strings, and parse various request bodies such as forms, multipart form data, and JSON. Warp also supports serving static files, directories, WebSocket, logging, middleware, and a basic compression system.</p>
			<p>Let's take a look at an example application using Warp. In the <code>Cargo.toml</code> file, add the following:</p>
			<pre class="source-code">[dependencies]</pre>
			<pre class="source-code">tokio = {version = "1", features = ["full"]}</pre>
			<pre class="source-code">warp = "0.3"</pre>
			<p>And, in the <code>src/main.rs</code> file, add the following:</p>
			<pre class="source-code">use warp::Filter;</pre>
			<pre class="source-code">#[tokio::main]</pre>
			<pre class="source-code">async fn main() {</pre>
			<pre class="source-code">    let hello = warp::path!("hello_world")</pre>
			<pre class="source-code">        .and(warp::path::end())</pre>
			<pre class="source-code">        .map(|| format!("Hello world!"));</pre>
			<pre class="source-code">    warp::serve(hello).run(([127, 0, 0, 1], 8080)).await;</pre>
			<pre class="source-code">}</pre>
			<p>Again, like the Tide and Warp<a id="_idIndexMarker787"/> examples, try opening <code>http://127.0.0.1:8080/hello_world</code> in the browser.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this final chapter, we have learned how to improve and scale a Rocket application. We can use various tools to improve Rocket applications, such as adding logging, tracing, monitoring, and mailers. We also learned a little bit about principles for scaling Rocket applications.</p>
			<p>Finally, we learned about alternative Rust web frameworks such as Actix Web, Tide, 13 and Warp. </p>
			<p>We started this book by learning how to create and build Rust application, and tools for working with Rust such as Cargo. We then learned the basics of Rocket applications such as the life cycle of requests and how to configure a Rocket application.</p>
			<p>We then continued by learning about more concepts such as Rocket routes, and route parts such as HTTP method, path, format, and data. To handle a route, we have to create a function that receives the request object and returns the response object. </p>
			<p>Continuing the basics of Rocket, we learned more about Rocket components such as state, connecting a database with Rocket, and fairings.</p>
			<p>After that, we learned how to organize Rust modules to create more complex applications. We then designed an application and implemented the routes to manage entities such as user and post. To manage entities, we learned how to write queries to the database to add, get, modify, or delete items.</p>
			<p>We then discussed more advanced topics such as Rust error handling and its implementation in a Rocket application. Continuing the more advanced topics, we also learned about Rocket functionalities such as serving static assets and using templates to generate a response. We also discussed how to use forms and how to protect forms from malicious attackers using CSRF.</p>
			<p>After learning how to handle form data, we learned about the Rust generic and how to apply the Rust generic in a Rocket application to render <code>Post</code> with the same trait. To handle the variants of <code>Post</code>, we learned more about advanced Rust programming, including lifetime and memory safety. We also learned more about <code>async</code> programming and multithreading when we implemented processing of the variants of <code>Post</code>.</p>
			<p>In order to use Rocket as a modern web framework, we also learned how to allow a Rocket application to handle APIs and JSON, protect the application using authentication and authorization, and learned how to use JWT to secure an API.</p>
			<p>To make sure our Rocket application worked as intended, we then learned how to test Rust and Rocket applications. After making sure the application worked as intended, we learned how to deploy the application in different ways, such as putting the Rocket application behind a general-purpose web server and using Docker to build and serve the Rocket application.</p>
			<p>To complement the backend application, we learned how to use Rust to create a WebAssembly application in the frontend. And finally, we learned more about how to scale Rocket applications, as well as how to find alternatives to the Rocket web framework.</p>
			<p>Now that we have learned all the foundations for building Rust and Rocket applications, we can implement Rust and Rocket web framework skills in production-grade web applications. To expand upon your knowledge from this book, you can learn more from the Rust or Rocket websites and forums. Don't hesitate to experiment and make great applications using the Rust language and Rocket web framework.</p>
		</div>
	</body></html>