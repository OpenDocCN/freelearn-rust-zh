<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Learning the Basics</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Concatenating strings</li>
<li class="mce-root">Using the format! macro</li>
<li class="mce-root">Providing a default implementation</li>
<li class="mce-root">Using the constructor pattern</li>
<li>Using the builder pattern</li>
<li class="mce-root">Parallelism through simple threads</li>
<li class="mce-root">Generating random numbers</li>
<li class="mce-root">Querying with regexes</li>
<li class="mce-root">Accessing the command line</li>
<li class="mce-root">Interacting with environment variables</li>
<li class="mce-root">Reading from stdin</li>
<li>Accepting a variable number of arguments</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are some code snippets and patterns of thought that prove time and again to be the bread and butter of a certain programming language. We will start this book by looking at a handful of such techniques in Rust. They are so quintessential for elegant and flexible code that you will use at least some of them in just about any project you tackle.</p>
<p>The next chapters will then build on this foundation and work hand in hand with Rust's zero costs abstractions, which are as powerful as the ones in higher-level languages. We are also going to look at the intricate inner aspects of the standard library and implement our own similar constructs with the help of fearless concurrency and careful use of <kbd>unsafe</kbd> blocks, which enable us to work at the same low level that some system languages, such as C, operate at.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concatenating strings</h1>
                </header>
            
            <article>
                
<p>String manipulation is typically a bit less straightforward in system programming languages than in scripting languages, and Rust is no exception. There are multiple ways to do it, all managing the involved resources differently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will assume for the rest of the book that you have an editor open, the newest Rust compiler ready, and a command line available. As of the time of writing, the newest version is <kbd>1.24.1</kbd>. Because of Rust's strong guarantees about backward compatibility, you can rest assured that all of the recipes shown (with the exception of <a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml">Chapter 10</a>, <em>Using Experimental Nightly Features</em>) are always going to work the same way. You can download the newest compiler with its command-line tools at <a href="https://www.rustup.rs">https://www.rustup.rs</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a Rust project to work on during this chapter with <kbd>cargo new chapter-one</kbd></li>
<li>Navigate to the newly created <kbd>chapter-one</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory</li>
<li>Inside the <kbd>src</kbd> folder, create a new folder called <kbd>bin</kbd></li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library</li>
<li>In the <kbd>src/bin</kbd> folder, create a file called <kbd>concat.rs</kbd></li>
<li>Add the following code and run it with <kbd>cargo run --bin concat</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2   by_moving();<br/>3   by_cloning();<br/>4   by_mutating();<br/>5  }<br/>6<br/>7  fn by_moving() {<br/>8   let hello = "hello ".to_string();<br/>9   let world = "world!";<br/>10<br/>11   // Moving hello into a new variable<br/>12   let hello_world = hello + world;<br/>13   // Hello CANNOT be used anymore<br/>14   println!("{}", hello_world); // Prints "hello world!"<br/>15  }<br/>16<br/>17  fn by_cloning() {<br/>18   let hello = "hello ".to_string();<br/>19   let world = "world!";<br/>20<br/>21   // Creating a copy of hello and moving it into a new variable<br/>22   let hello_world = hello.clone() + world;<br/>23   // Hello can still be used<br/>24   println!("{}", hello_world); // Prints "hello world!"<br/>25  }<br/>26<br/>27  fn by_mutating() {<br/>28   let mut hello = "hello ".to_string();<br/>29   let world = "world!";<br/>30<br/>31   // hello gets modified in place<br/>32   hello.push_str(world);<br/>33   // hello is both usable and modifiable<br/>34   println!("{}", hello); // Prints "hello world!"<br/>35  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In all functions, we start by allocating memory for a string of variable length.<br/>
We do this by creating a string slice (<kbd>&amp;str</kbd>) and applying the <kbd>to_string</kbd> function on it [8, 18 and 28].<br/>
The first way to concatenate strings in Rust, as shown in the <kbd>by_moving</kbd> function, is by taking said allocated memory and <strong>moving</strong> it, together with an additional string slice, into a new variable [12]. This has a couple of advantages:</p>
<ul>
<li>It's very straightforward and clear to look at, as it follows the common programming convention of concatenating with the <kbd>+</kbd> operator</li>
<li>It uses only immutable data. Remember to always try to write code in a style that creates as little stateful behavior as possible, as it results in more robust and reusable code bases</li>
<li>It reuses the memory allocated by <kbd>hello</kbd> [8], which makes it very performant</li>
</ul>
<p>As such, this way of concatenating should be preferred whenever possible.<br/>
So, why would we even list other ways to concatenate strings? Well, I'm glad you asked, dear reader. Although elegant, this approach comes with two downsides:</p>
<ul>
<li><kbd>hello</kbd> is no longer usable after line [12], as it was moved. This means you can no longer read it in any way</li>
<li>Sometimes you may actually prefer mutable data in order to use state in small, contained environments</li>
</ul>
<p>The two remaining functions address one concern each.<br/>
<kbd>by_cloning</kbd>[17] looks nearly identical to the first function, but it clones the allocated string [22] into a temporary object, allocating new memory in the process, which it then moves, leaving the original <kbd>hello</kbd> untouched and still accessible. Of course, this comes at the price of redundant memory allocations at runtime.<br/>
<br/>
<kbd>by_mutating</kbd>[27] is the stateful way of solving our problem. It performs the involved memory management in-place, which means that the performance should be the same as in <kbd>by_moving</kbd>. In the end, it leaves <kbd>hello</kbd> mutable, ready for further changes. You may notice that this function doesn't look as elegant as the others, as it doesn't use the <kbd>+</kbd> operator. This is intentional, as Rust tries to push you through its design towards moving data in order to create new variables without mutating existing ones. As mentioned before, you should only do this if you really need mutable data or want to introduce state in a very small and manageable context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the format! macro</h1>
                </header>
            
            <article>
                
<p>There is an additional way to combine strings, which can also be used to combine them with other data types, such as numbers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the <kbd>src/bin</kbd> folder, create a file called <kbd>format.rs</kbd></li>
<li>Add the following code and run it with <kbd>cargo run --bin format</kbd></li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2    let colour = "red";<br/>3    // The '{}' it the formatted string gets replaced by the<br/>   parameter<br/>4    let favourite = format!("My favourite colour is {}", colour);<br/>5    println!("{}", favourite);<br/>6     <br/>7    // You can add multiple parameters, which will be<br/>8    // put in place one after another<br/>9    let hello = "hello ";<br/>10   let world = "world!";<br/>11   let hello_world = format!("{}{}", hello, world);<br/>12   println!("{}", hello_world); // Prints "hello world!"<br/>13     <br/>14   // format! can concatenate any data types that<br/>15   // implement the 'Display' trait, such as numbers<br/>16   let favourite_num = format!("My favourite number is {}", 42);<br/>17   println!("{}", favourite_num); // Prints "My favourite number<br/>     is 42"<br/>18     <br/>19   // If you want to include certain parameters multiple times<br/>20   // into the string, you can use positional parameters<br/>21   let duck_duck_goose = format!("{0}, {0}, {0}, {1}!", "duck",<br/>     "goose");<br/>22   println!("{}", duck_duck_goose); // Prints "duck, duck, duck,<br/>     goose!"<br/>23     <br/>24   // You can even name your parameters!<br/>25   let introduction = format!(<br/>26     "My name is {surname}, {forename} {surname}",<br/>27     surname="Bond",<br/>28     forename="James"<br/>29   );<br/>30   println!("{}", introduction) // Prints "My name is Bond, James<br/>     Bond"<br/>31  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>format!</kbd> macro combines strings by accepting a format string filled with formatting parameters (example, <kbd>{}</kbd>, <kbd>{0}</kbd>, or <kbd>{foo}</kbd>) and a list of arguments, which are then inserted into the <em>placeholders</em>.<br/>
We are now going to show this on the example in line [16]:</p>
<pre style="padding-left: 30px">format!("My favourite number is {}", 42);</pre>
<p>Let's break down the preceding line of code:</p>
<ul>
<li><kbd>"My favourite number is {}"</kbd> is the format string</li>
<li><kbd>{}</kbd> is the formatting parameter</li>
<li><kbd>42</kbd> is the argument</li>
</ul>
<p>As demonstrated, <kbd>format!</kbd> works not only with strings, but also with numbers. In fact, it works with all <kbd>structs</kbd> that implement the <kbd>Display</kbd> trait. This means that, by providing such an implementation by yourself, you can easily make your own data structures printable however you want.<br/>
<br/>
By default, <kbd>format!</kbd> replaces one parameter after another. If you want to override this behavior, you can use positional parameters like <kbd>{0}</kbd> [21]. With the knowledge that the positions are zero-indexed, the behavior here is pretty straightforward, <kbd>{0}</kbd> gets replaced by the first argument, <kbd>{1}</kbd> gets replaced by the second, and so on.<br/>
<br/>
At times, this can become a bit unwieldy when using a lot of parameters. For this purpose, you can use named arguments [26], just like in Python. Keep in mind that all of your unnamed arguments have to be placed before your named ones. For example, the following is invalid:</p>
<pre style="padding-left: 30px">format!("{message} {}", message="Hello there,", "friendo")</pre>
<p>It should be rewritten as:</p>
<pre style="padding-left: 30px">format!("{message} {}", "friendo", message="Hello there,")<br/> // Returns "hello there, friendo"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can combine positional parameters with normal ones, but it's probably not a good idea, as it can quite easily become confusing to look at. The behavior, in this case, is as follows—imagine that <kbd>format!</kbd> internally uses a counter to determine which argument is the next to be placed. This counter is increased whenever <kbd>format!</kbd> encounters a <kbd>{}</kbd> <em>without</em> a position in it. This rule results in the following:</p>
<pre style="padding-left: 30px">format!("{1} {} {0} {}", "a", "b") // Returns "b a a b"</pre>
<p>There are also a ton of extra formatting options if you want to display your data in different formats. <kbd>{:?}</kbd> prints the implementation of the <kbd>Debug</kbd> trait for the respective argument, often resulting in a more verbose output. <kbd>{:.*}</kbd> lets you specify the decimal precision of floating point numbers via the argument, like so:</p>
<pre style="padding-left: 30px">format!("{:.*}", 2, 1.234567) // Returns "1.23"</pre>
<p>For a complete list, visit <a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>.</p>
<p>All of the information in this recipe applies to <kbd>println!</kbd> and <kbd>print!</kbd> as well, as it is essentially the same macro. The only difference is that <kbd>println!</kbd> doesn't return its processed string but instead, well, prints it!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a default implementation</h1>
                </header>
            
            <article>
                
<p>Often, when dealing with structures that represent configurations, you don't care about certain values and just want to silently assign them a standard value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>default.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin default</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2    // There's a default value for nearly every primitive type<br/>3    let foo: i32 = Default::default();<br/>4    println!("foo: {}", foo); // Prints "foo: 0"<br/>5 <br/>6 <br/>7    // A struct that derives from Default can be initialized like<br/>     this<br/>8    let pizza: PizzaConfig = Default::default();<br/>9    // Prints "wants_cheese: false<br/>10   println!("wants_cheese: {}", pizza.wants_cheese);<br/>11 <br/>12   // Prints "number_of_olives: 0"<br/>13   println!("number_of_olives: {}", pizza.number_of_olives);<br/>14 <br/>15   // Prints "special_message: "<br/>16   println!("special message: {}", pizza.special_message);<br/>17 <br/>18   let crust_type = match pizza.crust_type {<br/>19     CrustType::Thin =&gt; "Nice and thin",<br/>20     CrustType::Thick =&gt; "Extra thick and extra filling",<br/>21   };<br/>22   // Prints "crust_type: Nice and thin"<br/>23   println!("crust_type: {}", crust_type);<br/>24 <br/>25 <br/>26   // You can also configure only certain values<br/>27   let custom_pizza = PizzaConfig {<br/>28     number_of_olives: 12,<br/>29     ..Default::default()<br/>30   };<br/>31 <br/>32   // You can define as many values as you want<br/>33   let deluxe_custom_pizza = PizzaConfig {<br/>34     number_of_olives: 12,<br/>35     wants_cheese: true,<br/>36     special_message: "Will you marry me?".to_string(),<br/>37     ..Default::default()<br/>38   };<br/>39<br/>40 }<br/>41 <br/>42  #[derive(Default)]<br/>43  struct PizzaConfig {<br/>44    wants_cheese: bool,<br/>45    number_of_olives: i32,<br/>46    special_message: String,<br/>47    crust_type: CrustType,<br/>48  }<br/>49 <br/>50  // You can implement default easily for your own types<br/>51  enum CrustType {<br/>52    Thin,<br/>53    Thick,<br/>54  }<br/>55  impl Default for CrustType {<br/>56    fn default() -&gt; CrustType {<br/>57      CrustType::Thin<br/>58    }<br/>59  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Nearly every type in Rust has a <kbd>Default</kbd> implementation. When you define your own <kbd>struct</kbd> that only contains elements that already have a <kbd>Default</kbd>, you have the option to derive from <kbd>Default</kbd> as well [42]. In the case of enums or complex structs, you can easily write your own implementation of <kbd>Default</kbd> instead [55], as there's only one method you have to provide. After this, the <kbd>struct</kbd> returned by <kbd>Default::default()</kbd> is implicitly inferrable as yours, if you tell the compiler what your type actually is. This is why in line [3] we have to write <kbd>foo: i32</kbd>, or else Rust wouldn't know what type the default object actually should become.</p>
<p>If you only want to specify some elements and leave the others at the default, you can use the syntax in line [29]. Keep in mind that you can configure and skip as many values as you want, as shown in lines [33 to 37].</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the constructor pattern</h1>
                </header>
            
            <article>
                
<p>You may have asked yourself how to idiomatically initialize complex structs in Rust, considering it doesn't have constructors. The answer is simple, there is a constructor, it's just a convention rather than a rule. Rust's standard library uses this pattern very often, so we need to understand it if we want to use the std effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this recipe, we are going to talk about how a <strong>user</strong> interacts with a <kbd>struct</kbd>. When we say <em>user</em> in this context, we don't mean the end user that clicks on the GUI of the app you're writing. We're referring to the programmer that instantiates and manipulates the <kbd>struct</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>constructor.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin constructor</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2    // We don't need to care about<br/>3    // the internal structure of NameLength<br/>4    // Instead, we can just call it's constructor<br/>5    let name_length = NameLength::new("John");<br/>6 <br/>7    // Prints "The name 'John' is '4' characters long"<br/>8    name_length.print();<br/>9  }<br/>10 <br/>11  struct NameLength {<br/>12    name: String,<br/>13    length: usize,<br/>14  }<br/>15 <br/>16  impl NameLength {<br/>17    // The user doesn't need to setup length<br/>18    // We do it for him!<br/>19    fn new(name: &amp;str) -&gt; Self {<br/>20      NameLength {<br/>21        length: name.len(),<br/>22        name,<br/>23      }<br/>24    }<br/>25 <br/>26    fn print(&amp;self) {<br/>27      println!(<br/>28        "The name '{}' is '{}' characters long",<br/>29          self.name,<br/>30          self.length<br/>31      );<br/>32    }<br/>33  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If a <kbd>struct</kbd> provides a method called <kbd>new</kbd> that returns <kbd>Self</kbd>, the user of the <kbd>struct</kbd> will not configure or depend upon the members of the <kbd>struct</kbd>, as they are considered to be in an internal <em>hidden</em> state.</p>
<p>In other words, if you see a <kbd>struct</kbd> that has a <kbd>new</kbd> function, always use it to create the structure.<br/>
This has the nice effect of enabling you to change as many members of the struct as you want without the user noticing anything, as they are not supposed to look at them anyway.</p>
<p>The other reason to use this pattern is to guide the user to the correct way of instantiating a <kbd>struct</kbd>. If one has nothing but a big list of members that have to be filled with values, one might feel a bit lost. If one, however, has a method with only a few self-documenting parameters, it feels way more inviting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">You might have noticed that for our example we really didn't need a <kbd>length</kbd> member and could have just calculated a length whenever we print. We use this pattern anyway, to illustrate the point of its usefulness in hiding implementations. Another good use for it is when the members of a <kbd>struct</kbd> themselves have their own constructors and one needs to <em>cascade</em> the constructor calls. This happens, for example, when we have a <kbd>Vec</kbd> as a member, as we will see later in the book, in the, <em>Using a vector</em> section in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml">Chapter 2</a>, <em>Working with Collections</em>.</p>
<p>Sometimes, your structs might need more than one way to initialize themselves. When this happens, try to still provide a <kbd>new()</kbd> method as your default way of construction and name the other options according to how they differ from the default. A good example of this is again vector, which not only provides a <kbd>Vec::new()</kbd> constructor but also a <kbd>Vec::with_capacity(10)</kbd>, which initializes it with enough space for <kbd>10</kbd> items. More on that again in the Using a vector section in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em>.</p>
<p>When accepting a kind of string (either <kbd>&amp;str</kbd>, that is, a borrowed string slice, or <kbd>String</kbd>, that is, an owned string) with plans to store it in your <kbd>struct</kbd>, like we do in our example, also considering a <kbd>Cow</kbd>. No, not the big milk animal friends. A <kbd>Cow</kbd> in Rust is a <em>Clone On Write</em> wrapper around a type, which means that it will try to borrow a type for as long as possible and only make an owned clone of the data when absolutely necessary, which happens at the first mutation. The practical effect of this is that, if we rewrote our <kbd>NameLength</kbd> struct in the following way, it would not care whether the called passed a <kbd>&amp;str</kbd> or a <kbd>String</kbd> to it, and would instead try to work in the most efficient way possible:</p>
<pre>use std::borrow::Cow;<br/>struct NameLength&lt;'a&gt; {<br/>    name: Cow&lt;'a, str&gt;,<br/>    length: usize,<br/>}<br/><br/>impl&lt;'a&gt; NameLength&lt;'a&gt; {<br/>    // The user doesn't need to setup length<br/>    // We do it for him!<br/>    fn new&lt;S&gt;(name: S) -&gt; Self<br/>    where<br/>        S: Into&lt;Cow&lt;'a, str&gt;&gt;,<br/>    {<br/>        let name: Cow&lt;'a, str&gt; = name.into();<br/>        NameLength {<br/>            length: name.len(),<br/>            name,<br/>        }<br/>    }<br/><br/>    fn print(&amp;self) {<br/>        println!(<br/>            "The name '{}' is '{}' characters long",<br/>            self.name, self.length<br/>        );<br/>    }<br/>}</pre>
<p>If you want to read more about <kbd>Cow</kbd>, check out this easy-to-understand blog post by Joe Wilm: <a href="https://jwilm.io/blog/from-str-to-cow/">https://jwilm.io/blog/from-str-to-cow/</a>.</p>
<p>The <kbd>Into</kbd> trait used in the <kbd>Cow</kbd> code is going to be explained in the Converting types into each other section in <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <em>Advanced Data Structures</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank"/><span><em>Using a vector</em> recipe in</span> <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
<li><span><em>Converting types into each other</em> recipe in</span> <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank"/><em>Advanced Data Structures</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the builder pattern</h1>
                </header>
            
            <article>
                
<p>Sometimes you need something between the customization of the constructor and the implicitness of the default implementation. Enter the builder pattern, another technique frequently used by the Rust standard library, as it allows a caller to fluidly chain together configurations that they care about and lets them ignore details that they don't care about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>builder.rs</kbd></p>
</li>
<li>
<p>Add all of the following code and run it with <kbd>cargo run --bin builder</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1  fn main() {<br/>2    // We can easily create different configurations<br/>3    let normal_burger = BurgerBuilder::new().build();<br/>4    let cheese_burger = BurgerBuilder::new()<br/>       .cheese(true)<br/>       .salad(false)<br/>       .build();<br/>5    let veggie_bigmac = BurgerBuilder::new()<br/>       .vegetarian(true)<br/>       .patty_count(2)<br/>       .build();<br/>6<br/>7    if let Ok(normal_burger) = normal_burger {<br/>8      normal_burger.print();<br/>9    }<br/>10   if let Ok(cheese_burger) = cheese_burger {<br/>11     cheese_burger.print();<br/>12   }<br/>13   if let Ok(veggie_bigmac) = veggie_bigmac {<br/>14     veggie_bigmac.print();<br/>15   }<br/>16<br/>17   // Our builder can perform a check for<br/>18   // invalid configurations<br/>19   let invalid_burger = BurgerBuilder::new()<br/>       .vegetarian(true)<br/>       .bacon(true)<br/>       .build();<br/>20   if let Err(error) = invalid_burger {<br/>21     println!("Failed to print burger: {}", error);<br/>22   }<br/>23<br/>24   // If we omit the last step, we can reuse our builder<br/>25   let cheese_burger_builder = BurgerBuilder::new().cheese(true);<br/>26   for i in 1..10 {<br/>27     let cheese_burger = cheese_burger_builder.build();<br/>28     if let Ok(cheese_burger) = cheese_burger {<br/>29       println!("cheese burger number {} is ready!", i);<br/>30       cheese_burger.print();<br/>31     }<br/>32   }<br/>33 }</pre>
<p style="padding-left: 60px">This is the configurable object:</p>
<pre style="padding-left: 60px">35 struct Burger {<br/>36    patty_count: i32,<br/>37    vegetarian: bool,<br/>38    cheese: bool,<br/>39    bacon: bool,<br/>40    salad: bool,<br/>41 }<br/>42 impl Burger {<br/>43    // This method is just here for illustrative purposes<br/>44    fn print(&amp;self) {<br/>45        let pretty_patties = if self.patty_count == 1 {<br/>46            "patty"<br/>47        } else {<br/>48            "patties"<br/>49        };<br/>50        let pretty_bool = |val| if val { "" } else { "no " };<br/>51        let pretty_vegetarian = if self.vegetarian { "vegetarian " <br/>           }<br/>          else { "" };<br/>52        println!(<br/>53            "This is a {}burger with {} {}, {}cheese, {}bacon and<br/>              {}salad",<br/>54            pretty_vegetarian,<br/>55            self.patty_count,<br/>56            pretty_patties,<br/>57            pretty_bool(self.cheese),<br/>58            pretty_bool(self.bacon),<br/>59            pretty_bool(self.salad)<br/>60        )<br/>61    }<br/>62 }</pre>
<p style="padding-left: 60px">And this is the builder itself. It is used to configure and create a <kbd>Burger</kbd>:</p>
<pre style="padding-left: 60px">64  struct BurgerBuilder {<br/>65    patty_count: i32,<br/>66    vegetarian: bool,<br/>67    cheese: bool,<br/>68    bacon: bool,<br/>69    salad: bool,<br/>70  }<br/>71  impl BurgerBuilder {<br/>72    // in the constructor, we can specify<br/>73    // the standard values<br/>74    fn new() -&gt; Self {<br/>75      BurgerBuilder {<br/>76        patty_count: 1,<br/>77        vegetarian: false,<br/>78        cheese: false,<br/>79        bacon: false,<br/>80        salad: true,<br/>81      }<br/>82    }<br/>83<br/>84    // Now we have to define a method for every<br/>85    // configurable value<br/>86    fn patty_count(mut self, val: i32) -&gt; Self {<br/>87      self.patty_count = val;<br/>88      self<br/>89    }<br/>90<br/>91    fn vegetarian(mut self, val: bool) -&gt; Self {<br/>92      self.vegetarian = val;<br/>93      self<br/>94    }<br/>95    fn cheese(mut self, val: bool) -&gt; Self {<br/>96      self.cheese = val;<br/>97      self<br/>98    }<br/>99    fn bacon(mut self, val: bool) -&gt; Self {<br/>100     self.bacon = val;<br/>101     self<br/>102   }<br/>103   fn salad(mut self, val: bool) -&gt; Self {<br/>104     self.salad = val;<br/>105     self<br/>106   }<br/>107<br/>108   // The final method actually constructs our object<br/>109   fn build(&amp;self) -&gt; Result&lt;Burger, String&gt; {<br/>110     let burger = Burger {<br/>111       patty_count: self.patty_count,<br/>112       vegetarian: self.vegetarian,<br/>113       cheese: self.cheese,<br/>114       bacon: self.bacon,<br/>115       salad: self.salad,<br/>116   };<br/>117   // Check for invalid configuration<br/>118   if burger.vegetarian &amp;&amp; burger.bacon {<br/>119     Err("Sorry, but we don't server vegetarian bacon<br/>             yet".to_string())<br/>120     } else {<br/>121       Ok(burger)<br/>122     }<br/>123   }<br/>124 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Whew, that's a lot of code! Let's start by breaking it up.</p>
<p>In the first part, we illustrate how to use this pattern to effortlessly configure a complex object. We do this by relying on sensible standard values and only specifying what we really care about:</p>
<pre style="padding-left: 30px">let normal_burger = BurgerBuilder::new().build();<br/>let cheese_burger = BurgerBuilder::new()<br/>    .cheese(true)<br/>    .salad(false)<br/>    .build();<br/>let veggie_bigmac = BurgerBuilder::new()<br/>    .vegetarian(true)<br/>    .patty_count(2)<br/>    .build();</pre>
<p>The code reads pretty nicely, doesn't it?</p>
<p>In our version of the builder pattern, we return the object wrapped in a <kbd>Result</kbd> in order to tell the world that there are certain invalid configurations and that our builder might not always be able to produce a valid product. Because of this, we have to check the validity of our burger before accessing it[7, 10 and 13].</p>
<p>Our invalid configuration is <kbd>vegetarian(true)</kbd> and <kbd>bacon(true)</kbd>. Unfortunately, our restaurant doesn't serve vegetarian bacon yet! When you start the program, you will see that the following line will print an error:</p>
<pre style="padding-left: 30px">if let Err(error) = invalid_burger {<br/>    println!("Failed to print burger: {}", error);<br/>}</pre>
<p>If we omit the final <kbd>build</kbd> step, we can reuse the builder in order to build as many objects as we want. [25 to 32]</p>
<p>Let's see how we implemented all of this. The first thing after the <kbd>main</kbd> function is the definition of our <kbd>Burger</kbd> struct. No surprises here, it's just plain old data. The <kbd>print</kbd> method is just here to provide us with some nice output during runtime. You can ignore it if you want.</p>
<p>The real logic is in the <kbd>BurgerBuilder</kbd>[64]. It should have one member for every value you want to configure. As we want to configure every aspect of our burger, we will have the exact same members as <kbd>Burger</kbd>. In the constructor [74], we can specify some default values. We then create one method for every configuration. In the end, in <kbd>build()</kbd> [109], we first perform some error checking. If the configuration is OK, we return a <kbd>Burger</kbd> made out of all of our members [121]. Otherwise, we return an error [119].</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you want your object to be constructable without a builder, you could also provide <kbd>Burger</kbd> with a <kbd>Default</kbd> implementation. <kbd>BurgerBuilder::new()</kbd> could then just return <kbd>Default::default()</kbd>.</p>
<p>In <kbd>build()</kbd>, if your configuration can inherently not be invalid, you can, of course, return the object directly without wrapping it in a <kbd>Result</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallelism through simple threads</h1>
                </header>
            
            <article>
                
<p>Every year, parallelism and concurrency become more important as processors tend to have more and more physical cores. In most languages, writing parallel code is tricky. Very tricky. Not so in Rust, as it has been designed around the principle of <em>fearless concurrency</em> since the beginning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>parallelism.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin parallelism</kbd></p>
</li>
</ol>
<pre style="padding-left: 60px">1   use std::thread;<br/>2<br/>3   fn main() {<br/>4     // Spawning a thread lets it execute a lambda<br/>5     let child = thread::spawn(|| println!("Hello from a new<br/>      thread!"));<br/>6     println!("Hello from the main thread!");<br/>7     // Joining a child thread with the main thread means<br/>8     // that the main thread waits until the child has<br/>9     // finished it's work<br/>10    child.join().expect("Failed to join the child thread");<br/>11 <br/>12    let sum = parallel_sum(&amp;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);<br/>13    println!("The sum of the numbers 1 to 10 is {}", sum);<br/>14  }<br/>15 <br/>16  // We are going to write a function that<br/>17  // sums the numbers in a slice in parallel<br/>18  fn parallel_sum(range: &amp;[i32]) -&gt; i32 {<br/>19    // We are going to use exactly 4 threads to sum the numbers<br/>20    const NUM_THREADS: usize = 4;<br/>21     <br/>22    // If we have less numbers than threads,<br/>23    // there's no point in multithreading them<br/>24    if range.len() &lt; NUM_THREADS {<br/>25      sum_bucket(range)<br/>26    } else {<br/>27        // We define "bucket" as the amount of numbers<br/>28        // we sum in a single thread<br/>29        let bucket_size = range.len() / NUM_THREADS;<br/>30        let mut count = 0;<br/>31        // This vector will keep track of our threads<br/>32        let mut threads = Vec::new();<br/>33        // We try to sum as much as possible in other threads<br/>34        while count + bucket_size &lt; range.len() {<br/>35          let bucket = range[count..count +<br/>                               bucket_size].to_vec();<br/>36          let thread = thread::Builder::new()<br/>37            .name("calculation".to_string())<br/>38            .spawn(move || sum_bucket(&amp;bucket))<br/>39            .expect("Failed to create the thread");<br/>40          threads.push(thread);<br/>41             <br/>42          count += bucket_size<br/>43    }<br/>44    // We are going to sum the rest in the main thread<br/>45    let mut sum = sum_bucket(&amp;range[count..]);<br/>46         <br/>47    // Time to add the results up<br/>48    for thread in threads {<br/>49      sum += thread.join().expect("Failed to join thread");<br/>50    }<br/>51    sum<br/>52  }<br/>53 }<br/>54 <br/>55  // This is the function that will be executed in the threads<br/>56  fn sum_bucket(range: &amp;[i32]) -&gt; i32 {<br/>57    let mut sum = 0;<br/>58    for num in range {<br/>59      sum += *num;<br/>60    }<br/>61     sum<br/>62  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You can create a new thread by calling <kbd>thread::spawn</kbd>, which will then begin executing the provided lambda. This will return a <kbd>JoinHandle</kbd>, which you can use to, well, join the thread. Joining a thread means waiting for the thread to finish its work. If you don't join a thread, you have no guarantee of it actually ever finishing. This might be valid though when setting up threads to do <span>tasks that never complete</span>, such as listening for incoming connections.</p>
<p>Keep in mind that you cannot predetermine the order in which your threads will complete any work. In our example, it is impossible to foretell whether <em>Hello from a new thread!</em> or <em>Hello from the main thread!</em> is going to be printed first, although most of the time it will probably be the main thread, as the operating system needs to put some effort into spawning a new thread. This is the reason why small algorithms can be faster when not executed in parallel. Sometimes, the overhead of letting the OS spawn and manage new threads is just not worth it.</p>
<p>As demonstrated by line [49], joining a thread will return a <kbd>Result</kbd> that contains the value your lambda returned.</p>
<p>Threads can also be given names. Depending on your OS, in case of a crash, the name of the responsible thread will be displayed. In line [37], we call our new summation threads <em>calculation</em>. If one of them were to crash, we would be able to quickly identify the issue. Try it out for yourself, insert a call to <kbd>panic!();</kbd> at the beginning of <kbd>sum_bucket</kbd> in order to intentionally crash the program and run it. If your OS supports named threads, you will now be told that your thread <em>calculation</em> panicked with an <em>explicit panic</em>.</p>
<p><kbd>parallel_sum</kbd> is a function that takes a slice of integers and adds them together in parallel on four threads. If you have limited experience in working with parallel algorithms, this function will be hard to grasp at first. I invite you to copy it by hand into your text editor and play around with it in order to get a grasp on it. If you still feel a bit lost, don't worry, we will revisit parallelism again later.</p>
<p>Adapting algorithms to run in parallel normally comes at the risk of data races. A data race is defined as the behavior in a system where the output is dependent on the random timing of external events. In our case, having a data race would mean that multiple threads try to access and modify a resource at the same time. Normally, programmers have to analyze their usage of resources and use external tools in order to catch all of the data races. In contrast, Rust's compiler is smart enough to catch data races at compile time and stops if it finds one. This is the reason why we had to call <kbd>.to_vec()</kbd> in <span>line [35]:</span></p>
<pre style="padding-left: 30px">let bucket = range[count..count + bucket_size].to_vec();</pre>
<p>We will cover vectors in a later recipe (the <em>Using a vector</em> section in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml">Chapter 2</a>, <em>Working with Collections</em>), so if you're curious about what is happening here, feel free to jump to <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em> and come back again. The essence of it is that we're copying the data into <kbd>bucket</kbd>. If we instead passed a reference into <kbd>sum_bucket</kbd> in our new thread, we would have a problem, the memory referenced by <kbd>range</kbd> is only guaranteed to live inside of <kbd>parallel_sum</kbd>, but the threads we spawn are allowed to outlive their parent threads. This would mean that in theory, if we didn't <kbd>join</kbd> the threads at the right time, <kbd>sum_bucket</kbd> might get unlucky and get called late enough for <kbd>range</kbd> to be invalid.</p>
<p>This would then be a data race, as the outcome of our function would depend on the uncontrollable sequence in which our operating system decides to launch the threads.</p>
<p>But don't just take my word for it, try it yourself. Simply replace the aforementioned line with <kbd>let bucket = &amp;range[count..count + bucket_size];</kbd> and try to compile it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you're experienced with parallelism, you might have noticed how suboptimal our algorithm here is. This is intentional, as the elegant and efficient way of writing <kbd>parallel_sum</kbd> would require using techniques we have not discussed yet. We will revisit this algorithm in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em>, and rewrite it in a professional manner. In that chapter, we will also learn how to concurrently modify resources using locks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Access resources in parallel with RwLocks</em>, <span>recipe in </span> <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating random numbers</h1>
                </header>
            
            <article>
                
<p>As described in the preface, the Rust core team left some functionality intentionally out of the standard and put it into its own external crate. Generating pseudo-random numbers is one such functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root"><span>Open the</span> <kbd>Cargo.toml</kbd> <span>file that was generated earlier for you</span></li>
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">rand = "0.3"</pre>
<ol start="3">
<li>If you want, you can go to rand's crates.io page (<a href="https://crates.io/crates/rand">https://crates.io/crates/rand</a>) to check for the newest version and use that one instead</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>rand.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin rand</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   extern crate rand;<br/>2 <br/>3   fn main() {<br/>4     // random_num1 will be any integer between<br/>5     // std::i32::MIN and std::i32::MAX<br/>6     let random_num1 = rand::random::&lt;i32&gt;();<br/>7     println!("random_num1: {}", random_num1);<br/>8     let random_num2: i32 = rand::random();<br/>9     println!("random_num2: {}", random_num2);<br/>10    // The initialization of random_num1 and random_num2<br/>11    // is equivalent.<br/>12 <br/>13    // Every primitive data type can be randomized<br/>14    let random_char = rand::random::&lt;char&gt;();<br/>15    // Altough random_char will probably not be<br/>16    // representable on most operating systems<br/>17    println!("random_char: {}", random_char);<br/>18 <br/>19 <br/>20    use rand::Rng;<br/>21    // We can use a reusable generator<br/>22    let mut rng = rand::thread_rng();<br/>23    // This is equivalent to rand::random()<br/>24    if rng.gen() {<br/>25      println!("This message has a 50-50 chance of being<br/>                  printed");<br/>26    }<br/>27    // A generator enables us to use ranges<br/>28    // random_num3 will be between 0 and 9<br/>29    let random_num3 = rng.gen_range(0, 10);<br/>30    println!("random_num3: {}", random_num3);<br/>31 <br/>32    // random_float will be between 0.0 and 0.999999999999...<br/>33    let random_float = rng.gen_range(0.0, 1.0);<br/>34    println!("random_float: {}", random_float);<br/>35 <br/>36    // Per default, the generator uses a uniform distribution,<br/>37    // which should be good enough for nearly all of your<br/>38    // use cases. If you require a particular distribution,<br/>39    // you specify it when creating the generator:<br/>40    let mut chacha_rng = rand::ChaChaRng::new_unseeded();<br/>41    let random_chacha_num = chacha_rng.gen::&lt;i32&gt;();<br/>42    println!("random_chacha_num: {}", random_chacha_num);<br/>43  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before you can use <kbd>rand</kbd>, you have to tell Rust that you're using the <kbd>crate</kbd> by writing:</p>
<pre>extern crate rand;</pre>
<p>After that, <kbd>rand</kbd> will provide a random generator. We can access it by either calling <kbd>rand::random();</kbd> [6] or by accessing it directly with <kbd>rand::thread_rng();</kbd> [22].</p>
<p>If we go the first route, the generator will need to be told what type to generate. You can either explicitly state the type in the method call [6] or annotate the type of the resulting variable [8]. Both are equal and result in the exact same thing. Which one you use is up to you. In this book, we will use the first convention.</p>
<p>As you can see in lines [29 and 33], you need neither if the type is unambiguous in the called context.</p>
<p>The generated value will be between its type's <kbd>MIN</kbd> and <kbd>MAX</kbd> constants. In the case of <kbd>i32</kbd>, this would be <kbd>std::i32::MIN</kbd> and <kbd>std::i32::MAX</kbd>, or, in concrete numbers, -2147483648 and 2147483647. You can verify these numbers easily by calling the following:</p>
<pre>println!("min: {}, max: {}", std::i32::MIN, std::i32::MAX);</pre>
<p>As you can see, these are very big numbers. For most purposes, you will probably want to define custom limits. You can go the second route discussed earlier and use <kbd>rand::Rng</kbd> for that[22]. It has a <kbd>gen</kbd> method, which is actually implicitly called by <kbd>rand::random()</kbd>, but also a <kbd>gen_range()</kbd> that accepts a minimum and maximum value. Keep in mind that this range is non-inclusive, which means that the maximum value can never be reached. This is why in line [29], <kbd>rng.gen_range(0, 10)</kbd> will only generate the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, without the 10.</p>
<p>All of the described ways of generating random values use <strong>uniform distribution</strong>, which means that every number in the range has the same chance of being generated. In some contexts, it makes sense to use other distributions. You can specify a generator's distribution during its creation[40]. As of the time of publication, the rand crate supports the ChaCha and ISAAC distributions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you want to randomly populate an entire <kbd>struct</kbd>, you use the <kbd>rand_derive</kbd> helper crate in order to derive it from <strong>Rand</strong>. You can then generate your own <kbd>struct</kbd>, just as you would generate any other type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying with regexes</h1>
                </header>
            
            <article>
                
<p>When parsing simple data formats, it is often easier to write regular expressions (or <em>regex</em> for short) than use a parser. Rust has pretty decent support for this through its <kbd>regex</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In order to really understand this chapter, you should be familiar with regexes. There are countless free online resources for this, like regexone (<a href="https://www.regexone.com/">https://www.regexone.com/</a>).</p>
<div class="packt_infobox">This recipe will not conform to clippy, as we kept the regexes intentionally <em>too</em> simple because we want to keep the focus of the recipe on the code, not the regex. Some of the examples shown could have been rewritten to use <kbd>.contains()</kbd> instead.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following line:</li>
</ol>
<pre style="padding-left: 60px">regex = "0.2"</pre>
<ol start="3">
<li>If you want, you can go to regex's crates.io page (<a href="https://crates.io/crates/regex">https://crates.io/crates/regex</a>) to check for the newest version and use that one instead</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>regex.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin regex</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   extern crate regex;<br/>2<br/>3   fn main() {<br/>4     use regex::Regex;<br/>5     // Beginning a string with 'r' makes it a raw string,<br/>6     // in which you don't need to escape any symbols<br/>7     let date_regex =<br/>        Regex::new(r"^\d{2}.\d{2}.\d{4}$").expect("Failed<br/>          to create regex");<br/>8     let date = "15.10.2017";<br/>9     // Check for a match<br/>10    let is_date = date_regex.is_match(date);<br/>11    println!("Is '{}' a date? {}", date, is_date);<br/>12<br/>13    // Let's use capture groups now<br/>14    let date_regex = Regex::new(r"(\d{2}).(\d{2})<br/>        .(\d{4})").expect("Failed to create regex");<br/>15    let text_with_dates = "Alan Turing was born on 23.06.1912 and<br/>          died on 07.06.1954. \<br/>16      A movie about his life called 'The Imitation Game' came out<br/>          on 14.11.2017";<br/>17    // Iterate over the matches<br/>18    for cap in date_regex.captures_iter(text_with_dates) {<br/>19      println!("Found date {}", &amp;cap[0]);<br/>20      println!("Year: {} Month: {} Day: {}", &amp;cap[3], &amp;cap[2],<br/>          &amp;cap[1]);<br/>21    }<br/>22    // Replace the date format<br/>23    println!("Original text:\t\t{}", text_with_dates);<br/>24    let text_with_indian_dates =<br/>        date_regex.replace_all(text_with_dates, "$1-$2-$3");<br/>25    println!("In indian format:\t{}", text_with_indian_dates);<br/>26<br/>27    // Replacing groups is easier when we name them<br/>28    // ?P&lt;somename&gt; gives a capture group a name<br/>29    let date_regex = Regex::new(r"(?P&lt;day&gt;\d{2}).(?P&lt;month&gt;\d{2})<br/>        .(?P&lt;year&gt;\d{4})")<br/>30      .expect("Failed to create regex");<br/>31    let text_with_american_dates =<br/>        date_regex.replace_all(text_with_dates,<br/>          "$month/$day/$year");<br/>32    println!("In american format:\t{}", <br/>      text_with_american_dates);<br/>33    let rust_regex = Regex::new(r"(?i)rust").expect("Failed to<br/>        create regex");<br/>34    println!("Do we match RuSt? {}", <br/>      rust_regex.is_match("RuSt"));<br/>35    use regex::RegexBuilder;<br/>36    let rust_regex = RegexBuilder::new(r"rust")<br/>37      .case_insensitive(true)<br/>38      .build()<br/>39      .expect("Failed to create regex");<br/>40    println!("Do we still match RuSt? {}",<br/>        rust_regex.is_match("RuSt"));<br/>41  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You can construct a regex object by calling <kbd>Regex::new()</kbd> with a valid regex string[7]. Most of the time, you will want to pass a <em>raw string</em> in the form of <kbd>r"..."</kbd>. Raw means that all symbols in the string are taken at literal value without being escaped. This is important because of the backslash (<kbd>\</kbd>) character that is used in regex to represent a couple of important concepts, such as digits(<kbd>\d</kbd>) or whitespace (<kbd>\s</kbd>). However, Rust already uses the backslash to escape special <em>non-printable</em> symbols, such as the newline (<kbd>\n</kbd>) or the tab (<kbd>\t</kbd>)[23]. If we wanted to use a backslash in a normal string, we would have to escape it by repeating it ( <kbd>\\</kbd>). Or the regex on line [14] would have to be rewritten as:</p>
<pre style="padding-left: 30px">"(\\d{2}).(\\d{2}).(\\d{4})"</pre>
<p>Worse yet, if we wanted to match for the backslash itself, we would have to escape it as well because of regex. With normal strings, we would have to quadruple-escape it! ( <kbd>\\\\</kbd>)<br/>
We can save ourselves the headache of missing readability and confusion by using raw strings and write our regex normally. In fact, it is considered good style to use raw strings in <em>every</em> regex, even when it doesn't have any backslashes [33]. This is a help for your future self if you notice down the line that you actually would like to use a feature that requires a backslash.</p>
<p>We can iterate over the results of our regex [18]. The object we get on every match is a collection of our capture groups. Keep in mind that the zeroeth index is always the entire capture [19]. The first index is then the string from our first capture group, the second index is the string of the second capture group, and so on. [20]. Unfortunately, we do not get a compile-time check on our index, so if we accessed <kbd>&amp;cap[4]</kbd>, our program would compile but then crash during runtime.</p>
<p>When replacing, we follow the same concept: <kbd>$0</kbd> is the entire match, <kbd>$1</kbd> the result of the first capture group, and so on. To make our life easier, we can give the capture groups names by starting them with <kbd>?P&lt;somename&gt;</kbd>[29] and then use this name when replacing [31].</p>
<p>There are many flags that you can specify, in the form of <kbd>(?flag)</kbd>, for fine-tuning, such as <kbd>i</kbd>, which makes the match case insensitive [33], or <kbd>x</kbd>, which ignores whitespace in the regex string. If you want to read up on them, visit their documentation (<a href="https://doc.rust-lang.org/regex/regex/index.html">https://doc.rust-lang.org/regex/regex/index.html</a>). Most of the time though, you can get the same result by using the <kbd>RegexBuilder</kbd> that is also in the regex crate [36]. Both of the <kbd>rust_regex</kbd> objects we generate in lines [33] and [36] are equivalent. While the second version is definitely more verbose, it is also way easier to understand at first glance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The regexes work by compiling their strings into the equivalent Rust code on creation. For performance reasons, you are advised to reuse your regexes instead of creating them anew every time you use them. A good way of doing this is by using the <kbd>lazy_static</kbd> crate, which we will look at later in the book, in the Creating lazy static objects section in <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <em>Advanced Data Structures</em>.</p>
<div class="packt_tip">Be careful not to overdo it with regexes. As they say, "When all you have is a hammer, everything looks like a nail." If you parse complicated data, regexes can quickly become an unbelievably complex mess. When you notice that your regex has become too big to understand at first glance, try to rewrite it as a parser.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Creating lazy static objects</em> recipe in</span> <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml" target="_blank">Chapter 5</a>, <em><em>Advanced Data Structures</em></em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the command line</h1>
                </header>
            
            <article>
                
<p>Sooner or later, you'll want to interact with the user in some way or another. The most basic way to do this is by letting the user pass parameters while calling the application through the command line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>cli_params.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin cli_params some_option some_other_option</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px"><span>1   use std::env;</span><br/>2<br/>3   fn main() {<br/>4     // env::args returns an iterator over the parameters<br/>5     println!("Got following parameters: ");<br/>6     for arg in env::args() {<br/>7       println!("- {}", arg);<br/>8     }<br/>9<br/>10    // We can access specific parameters using the iterator API<br/>11    let mut args = env::args();<br/>12    if let Some(arg) = args.nth(0) {<br/>13      println!("The path to this program is: {}", arg);<br/>14    }<br/>15    if let Some(arg) = args.nth(1) {<br/>16        println!("The first parameter is: {}", arg);<br/>17    }<br/>18    if let Some(arg) = args.nth(2) {<br/>19        println!("The second parameter is: {}", arg);<br/>20    }<br/>21<br/>22    // Or as a vector<br/>23    let args: Vec&lt;_&gt; = env::args().collect();<br/>24    println!("The path to this program is: {}", args[0]);<br/>25    if args.len() &gt; 1 {<br/>26        println!("The first parameter is: {}", args[1]);<br/>27    }<br/>28    if args.len() &gt; 2 {<br/>29        println!("The second parameter is: {}", args[2]);<br/>30    }<br/>31  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Calling <kbd>env::args()</kbd> returns an iterator over the provided parameters[6]. By convention, the first command-line parameter on most operating systems is the path to the executable itself [12].</p>
<p>We can access specific parameters in two ways: keep them as an iterator [11] or <kbd>collect</kbd> them into a collection such as <kbd>Vec</kbd>[23]. Don't worry, we are going to talk about them in detail in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em>. For now, it's enough for you to know that:</p>
<ul>
<li>
<p>Accessing an iterator forces you to check at compile time whether the element exists, for example, an <kbd>if let</kbd> binding [12]</p>
</li>
<li>
<p>Accessing a vector checks the validity at runtime</p>
</li>
</ul>
<p>This means that we could have executed lines [26] and [29] without checking for their validity first in [25] and [28]. Try it yourself, add the <kbd>&amp;args[3];</kbd> line at the end of the program and run it.</p>
<div class="packt_infobox">We check the length anyways because it is considered good style to check whether the expected parameters were provided. With the iterator way of accessing parameters, you don't have to worry about forgetting to check, as it forces you to do it. On the other hand, by using a vector, you can check for the parameters once at the beginning of the program and not worry about them afterward.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you are building a serious command-line utility in the style of *nix tools, you will have to parse a lot of different parameters. Instead of reinventing the wheel, you should take a look at third-party libraries, such as clap (<a href="https://crates.io/crates/clap">https://crates.io/crates/clap</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with environment variables</h1>
                </header>
            
            <article>
                
<p>According to the Twelve-Factor App (<a href="https://12factor.net/">https://12factor.net/</a>), you should store your configuration in the environment (<a href="https://12factor.net/config">https://12factor.net/config</a>). This means that you should pass values that could change between deployments, such as ports, domains, or database handles, as environment variables. Many programs also use environment variables to communicate with each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>env_vars.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin env_vars</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   use std::env;<br/>2<br/>3   fn main() {<br/>4     // We can iterate over all the env vars for the current<br/>      process<br/>5     println!("Listing all env vars:");<br/>6     for (key, val) in env::vars() {<br/>7       println!("{}: {}", key, val);<br/>8     }<br/>9<br/>10    let key = "PORT";<br/>11    println!("Setting env var {}", key);<br/>12    // Setting an env var for the current process<br/>13    env::set_var(key, "8080");<br/>14<br/>15    print_env_var(key);<br/>16<br/>17    // Removing an env var for the current process<br/>18    println!("Removing env var {}", key);<br/>19    env::remove_var(key);<br/>20<br/>21    print_env_var(key);<br/>22  }<br/>23<br/>24  fn print_env_var(key: &amp;str) {<br/>25    // Accessing an env var<br/>26    match env::var(key) {<br/>27      Ok(val) =&gt; println!("{}: {}", key, val),<br/>28      Err(e) =&gt; println!("Couldn't print env var {}: {}", key, e),<br/>29    }<br/>30  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>With <kbd>env::vars()</kbd>, we can access an iterator over all the <kbd>env var</kbd> that were set for the current process at the time of execution [6]. This list is pretty huge though, as you'll see when running the code, and for the most part, irrelevant for us.</p>
<p>It's more practical to access a single <kbd>env var</kbd> with <kbd>env::var()</kbd> [26], which returns an <kbd>Err</kbd> if the requested var is either not present or doesn't contain valid Unicode. We can see this in action in line [21], where we try to print a variable that we just deleted.</p>
<p>Because your <kbd>env::var</kbd> returns a <kbd>Result</kbd>, you can easily set up default values for them by using <kbd>unwrap_or_default</kbd>. One real-life example of this, involving the address of a running instance of the popular Redis (<a href="https://redis.io/">https://redis.io/</a>) <span>key-value storage</span><span>, looks like this:</span></p>
<pre>redis_addr = env::var("REDIS_ADDR")<br/>    .unwrap_or_default("localhost:6379".to_string());</pre>
<p>Keep in mind that creating an <kbd>env var</kbd> with <kbd>env::set_var()</kbd> [13] and deleting it with <kbd>env::remove_var()</kbd> [19] both only change the <kbd>env var</kbd> for our current process. This means that the created <kbd>env var</kbd> are not going to be readable by other programs. It also means that if we accidentally remove an important <kbd>env var</kbd>, the rest of the operating system is not going to care, as it can still access it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>At the beginning of this recipe, I wrote about storing your configuration in the environment. The industry standard way to do this is by creating a file called <kbd>.env</kbd> that contains said config in the form of key-value-pairs, and loading it into the process at some point during the build. One easy way to do this in Rust is by using the dotenv (<a href="https://crates.io/crates/dotenv">https://crates.io/crates/dotenv</a>) third-party crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading from stdin</h1>
                </header>
            
            <article>
                
<p>If you want to create an interactive application, it's easy to prototype your functionality with the command line. For CLI programs, this will be all the interaction you need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>stdin.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin stdin</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   use std::io;<br/>2   use std::io::prelude::*;<br/>3<br/>4   fn main() {<br/>5     print_single_line("Please enter your forename: ");<br/>6     let forename = read_line_iter();<br/>7<br/>8     print_single_line("Please enter your surname: ");<br/>9     let surname = read_line_buffer();<br/>10<br/>11    print_single_line("Please enter your age: ");<br/>12    let age = read_number();<br/>13<br/>14    println!(<br/>15      "Hello, {} year old human named {} {}!",<br/>16      age, forename, surname<br/>17    );<br/>18  }<br/>19<br/>20  fn print_single_line(text: &amp;str) {<br/>21    // We can print lines without adding a newline<br/>22    print!("{}", text);<br/>23    // However, we need to flush stdout afterwards<br/>24    // in order to guarantee that the data actually displays<br/>25    io::stdout().flush().expect("Failed to flush stdout");<br/>26  }<br/>27<br/>28  fn read_line_iter() -&gt; String {<br/>29    let stdin = io::stdin();<br/>30    // Read one line of input iterator-style<br/>31    let input = stdin.lock().lines().next();<br/>32    input<br/>33      .expect("No lines in buffer")<br/>34      .expect("Failed to read line")<br/>35      .trim()<br/>36      .to_string()<br/>37  }<br/>38<br/>39  fn read_line_buffer() -&gt; String {<br/>40    // Read one line of input buffer-style<br/>41    let mut input = String::new();<br/>42    io::stdin()<br/>43      .read_line(&amp;mut input)<br/>44      .expect("Failed to read line");<br/>45    input.trim().to_string()<br/>46  }<br/>47<br/>48  fn read_number() -&gt; i32 {<br/>49    let stdin = io::stdin();<br/>50    loop {<br/>51      // Iterate over all lines that will be inputted<br/>52      for line in stdin.lock().lines() {<br/>53        let input = line.expect("Failed to read line");<br/>54        // Try to convert a string into a number<br/>55        match input.trim().parse::&lt;i32&gt;() {<br/>56          Ok(num) =&gt; return num,<br/>57            Err(e) =&gt; println!("Failed to read number: {}", e),<br/>58        }<br/>59      }<br/>60    }<br/>61  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">In order to read from the standard console input, <kbd>stdin</kbd>, we first need to obtain a handle to it. We do this by calling <kbd>io::stdin()</kbd> [29]. Imagine the returned object as a reference to a global <kbd>stdin</kbd> object. This global buffer is managed by a <kbd>Mutex</kbd>, which means that only one thread can access it at a time (more on that later in the book, in the <span>Parallelly accessing resources with Mutexes section in</span> <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a><span>,</span> <em>Parallelism and Rayon</em><span>). We get this access by locking (using</span> <kbd>lock()</kbd><span>) the buffer, which returns a new handle [31]. After we have done this, we can call the</span> <kbd>lines</kbd> <span>method on it, which returns an iterator over the lines the user will write [31 and 52]. More on iterators in the <em>Accessing collections as Iterators</em> section in</span> <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a><span>,</span> <em>Working with Collections</em><span>.</span></p>
<p class="mce-root">Finally, we can iterate over as many submitted lines as we want until some kind of break condition is reached, otherwise the iteration would go on forever. In our example, we break the number-checking loop as soon as a valid number has been entered [56].</p>
<p>If we're not particularly picky about our input and just want the next line, we have two options:</p>
<ul>
<li>
<p>We can continue using the infinite iterator provided by <kbd>lines()</kbd>, but simply call next on it in order to just take the first one. This comes with an additional error check as, generally speaking, we cannot guarantee that there is a next element.</p>
</li>
<li>
<p>We can use <kbd>read_line</kbd> in order to populate an existing buffer [43]. This doesn't require that we <kbd>lock</kbd> the handler first, as it is done implicitly.</p>
</li>
</ul>
<p>Although they both result in the same end effect, you should choose the first option. It is more idiomatic as it uses iterators instead of a mutable state, which makes it more maintainable and readable.</p>
<p>On a side note, we are using <kbd>print!</kbd> instead of <kbd>println!</kbd> in some places in this recipe for aesthetic reasons [22]. If you prefer the look of newlines before user input, you can refrain from using them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This recipe is written with the assumption that you want to use stdin for live interaction over the <kbd>cli</kbd>. If you plan on instead piping some data into it (for example, <kbd>cat foo.txt | stdin.rs</kbd> on *nix), you can stop treating the iterator returned by <kbd>lines()</kbd> as infinite and retrieve the individual lines, not unlike how you retrieved the individual parameters in the last recipe.</p>
<p>There are various calls to <kbd>trim()</kbd> in our recipe [35, 45 and 55]. This method removes leading and trailing whitespace in order to enhance the user-friendliness of our program. We are going to look at it in detail in the <em>Using a string</em> section in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Interacting with environment variables</em> recipe in</span> <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><span><em>Using a string</em> and <em>Accessing collections as iterators recipe</em> in</span> <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
<li><span><em>Parallelly accessing resources with Mutexes</em> recipe in</span> <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accepting a variable number of arguments</h1>
                </header>
            
            <article>
                
<p>Most of the time, when you want to operate on a dataset, you will design a function that takes a collection. In some cases, however, it is nice to have functions that just accept an unbound amount of parameters, like JavaScript's <em>rest parameters</em>. This concept is called <strong>variadic functions</strong> and is not supported by Rust. However, we can implement it ourselves by defining a recursive macro.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>The code in this recipe might be small, but it will look like gibberish if you're not familiar with macros. If you have not yet learned about macros or need a refresh, I recommend that you take a quick look at the relevant chapter in the official Rust book (<a href="https://doc.rust-lang.org/stable/book/first-edition/macros.html">https://doc.rust-lang.org/stable/book/first-edition/macros.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the <kbd>src/bin</kbd> folder, create a file called <kbd>variadic.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin variadic</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   macro_rules! multiply {<br/>2     // Edge case<br/>3     ( $last:expr ) =&gt; { $last };<br/>4<br/>5     ( $head:expr, $($tail:expr), +) =&gt; {<br/>6       // Recursive call<br/>7       $head * multiply!($($tail),+)<br/>8     };<br/>9   }<br/>10<br/>11  fn main() {<br/>12    // You can call multiply! with<br/>13    // as many parameters as you want<br/>14    let val = multiply!(2, 4, 8);<br/>15    println!("2*4*8 = {}", val)<br/>16  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start with our intention: we want to create a macro called multiply that accepts an undefined amount of parameters and multiplies them all together. In macros, this is done via recursion. We begin every recursive definition with the <strong>edge case</strong>, that is, the parameters where the recursion should stop. Most of the time, this is where a function call stops making sense. In our case, this is the single parameter. Think about it, what should <kbd>multiply!(3)</kbd> return? It doesn't make sense to multiply it with anything, since we have no other parameter to multiply it with. Our best reaction is to simply return the parameter unmodified.</p>
<p>Our other condition is a match against more than one parameter, a <kbd>$head</kbd> and a comma-separated list of parameters inside of a <kbd>$tail</kbd>. Here, we just define the return value as the <kbd>$head</kbd> multiplied with the multiplication of the <kbd>$tail</kbd>. This will call <kbd>multiply!</kbd> with the <kbd>$tail</kbd> and without the <kbd>$head</kbd>, which means that on every call we process one parameter less until we finally reach our edge case, one single parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Keep in mind that you should use this technique sparingly. Most of the time, it is clearer to just accept and operate on a slice instead. However, it makes sense to use this in combination with other macros and higher kinds of concepts where the analogy of <em>a graspable list of things</em> breaks down. Finding a good example for this is difficult since they tend to be extremely specific. You can find one of them at the end of the book though.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Composing functions</em> recipe in</span> <a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml" target="_blank">Chapter 10</a>, <em>Using Experimental Nightly Features</em></li>
</ul>


            </article>

            
        </section>
    </body></html>