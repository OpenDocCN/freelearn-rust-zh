<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-36"><em class="italic"><a id="_idTextAnchor035"/>Chapter 2</em>: Structuring Code in Rust</h1>&#13;
			<p>Now that we have gotten to grips with the basics of Rust, we can move on to structuring code over several files so we can actually solve problems with Rust. In order to do this, we will have to understand how to manage dependencies as well as how to compile a basic and structured application. We also have to consider the isolation of code so we can reuse it and keep the development of the application agile, enabling us to make changes quickly without much pain. After covering this, we will also get the application to interact with the user directly by accepting user commands. We will also utilize Rust crates. A crate is a binary or library that we import and use. </p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Managing our code with crates and Cargo instead of <code>pip</code></li>&#13;
				<li>Structuring code over multiple files and modules </li>&#13;
				<li>Building module interfaces </li>&#13;
				<li>Interacting with the environment</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Technical requirements</h1>&#13;
			<p>We are no longer going to be implementing simple single-page applications that do not rely on any third-party dependencies as we did in the first chapter. As a result, you will have to directly install Rust onto your computer. We will also be managing third-party dependencies through Cargo. You can install Rust and Cargo on your computer here: https://www.rust-lang.org/tools/install.</p>&#13;
			<p>At the time of writing this, the best <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) by far for writing Rust is Visual Studio Code. It has a range of Rust plugins that can help you keep track of and check your Rust code. It can be installed using this link: <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a>.</p>&#13;
			<p>You can find all the code files in the GitHub repository for this chapter: <a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_two</a>.</p>&#13;
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Managing our code with crates and Cargo instead of pip</h1>&#13;
			<p>Building <a id="_idIndexMarker094"/>our <a id="_idIndexMarker095"/>own application<a id="_idIndexMarker096"/> is going<a id="_idIndexMarker097"/> to involve the following steps:</p>&#13;
			<ol>&#13;
				<li>Create a simple Rust file and run it.</li>&#13;
				<li>Create a simple application using Cargo. </li>&#13;
				<li>Run our application using Cargo.</li>&#13;
				<li>Manage dependencies with Cargo.</li>&#13;
				<li>Use a third-party crate to serialize JSON.</li>&#13;
				<li>Document our application with Cargo.</li>&#13;
			</ol>&#13;
			<p>Before we start structuring our program with Cargo, we should compile a basic Rust script and run it:</p>&#13;
			<ol>&#13;
				<li value="1">To do this, make a file called <code>hello_world.rs</code> with the main function housing the <code>println!</code> function with a string, as we can see here:<pre>fn main() {
    println!("hello world");
}</pre></li>&#13;
				<li>Once this is done, we can navigate to the file and run the <code>rustc</code> command:<pre><strong class="bold">rustc hello_world.rs </strong></pre></li>&#13;
				<li>This command compiles the file into a binary to be run. If we compile on Windows, we can run the binary with the following command:<pre><strong class="bold">.\hello_world.exe</strong></pre></li>&#13;
				<li>If we compile it on Linux or Mac, we can run it with the following command:<pre><strong class="bold">./hello_world</strong></pre><p>The console should then print out the string. While this can come in useful when building a standalone file, it is not recommended for managing programs spanning multiple files. It is not even recommended when relying on dependencies. This is where Cargo comes in. Cargo manages everything – the running, testing, documentation, building, and dependency out of the box – with a few simple commands.</p></li>&#13;
			</ol>&#13;
			<p>Now that we have a basic understanding of how to compile a basic file, we can move on to building a fully fledged application:</p>&#13;
			<ol>&#13;
				<li value="1">In your <a id="_idIndexMarker098"/>terminal, navigate<a id="_idIndexMarker099"/> to <a id="_idIndexMarker100"/>where <a id="_idIndexMarker101"/>you want your application to sit, and create a new project called <code>wealth_manager</code> as follows:<pre><code>Cargo.toml</code> file. </p><p>In order to perform Cargo commands on this application, our terminal is going to have to be in the same directory as the <code>Cargo.toml</code> file. The code that we are going to be altering that makes up our application is housed in the <code>src</code> directory. Our entry point for the whole application is in the <code>main.rs</code> file. In Python, we can have multiple entry points, and we will explore these in <a href="B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Building pip Modules in Python</em>, where we will build pure Python packages for the first time. If we open the <code>.gitignore</code> file, we should have the following:</p><pre><code>/target</code></pre><p>This is not a mistake; this is how clean Rust is. Everything that Cargo produces when it comes to compiling, documenting, caching, and so on is all stored in the target directory. </p></li>&#13;
				<li>Right now, all we have is the main file that has a printout to the console saying <em class="italic">"hello world."</em> We can run this with the following command:<pre><strong class="bold">cargo run</strong></pre></li>&#13;
				<li>With <a id="_idIndexMarker102"/>this <a id="_idIndexMarker103"/>command, we<a id="_idIndexMarker104"/> get <a id="_idIndexMarker105"/>the following output in the terminal:<pre><code>target/debug/wealth_manager</code>, and this is then run, resulting in the <code>hello_world.rs</code> output. </p></li>&#13;
				<li>If we want to run a release, we simply run the following command:<pre><code>./target/release/</code> directory under the binary <code>wealth_manager</code>. If we just want to compile our application without running it, we can simply swap the <code>run</code> command for <code>build</code>.</p></li>&#13;
			</ol>&#13;
			<p>Now that we<a id="_idIndexMarker106"/> have<a id="_idIndexMarker107"/> got <a id="_idIndexMarker108"/>our <a id="_idIndexMarker109"/>application running, let's explore how we manage the metadata around it. This can all be done by editing the <code>Cargo.toml</code> file. When we open this, we get the following:</p>&#13;
			<pre>[package]</pre>&#13;
			<pre>name = "wealth_manager"</pre>&#13;
			<pre>version = "0.1.0"</pre>&#13;
			<pre>authors = ["maxwellflitton"]</pre>&#13;
			<pre>edition = "2018"</pre>&#13;
			<pre>[dependencies]</pre>&#13;
			<p>The name, version, and authors are fairly straightforward. Here are the effects each section has on the project: </p>&#13;
			<ul>&#13;
				<li>If we change the <code>name</code> value in the <code>Cargo.toml</code> file, then new binaries with that name will be made when we build or run our application. The old ones will still be there too. </li>&#13;
				<li><code>version</code> is for distribution on services such as <code>crates.io</code> if we want to open source our application for others to use. The authors are required for this as well, and our application will still compile and run locally if it's not there. </li>&#13;
				<li><code>edition</code> is the edition of Rust that we are using. Rust gets updated frequently. These updates accumulate through time, and every two to three years, the smoothed-out new features are packaged, documented, and added to a new edition. The latest edition (2021) is available at <a href="https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/">https://devclass.com/2021/10/27/rust-1-56-0-arrives-delivering-rust-2021-edition-support/</a>. </li>&#13;
				<li>We also have <code>dependencies</code>. This is where we can import third-party crates. </li>&#13;
			</ul>&#13;
			<p>To see how this works, let's use a crate to convert a data structure of stock into JSON and then print it. Writing the code ourselves would be a bit of a headache. Luckily, we can install the <code>serde</code> crate and use the <code>json!</code> macro. In order for Cargo to download and <a id="_idIndexMarker110"/>install<a id="_idIndexMarker111"/> the crate, we <a id="_idIndexMarker112"/>fill<a id="_idIndexMarker113"/> our dependencies section in our <code>Cargo.toml</code> file with the code given here:</p>&#13;
			<pre>[dependencies]</pre>&#13;
			<pre>serde="1.0.117"</pre>&#13;
			<pre>serde_json="1.0.59"</pre>&#13;
			<p>In our <code>main.rs</code> file, we then import the macro and struct needed to convert data about a stock into JSON and then print it out in the following code:</p>&#13;
			<pre>use serde_json::{json, Value};</pre>&#13;
			<pre>fn main() {</pre>&#13;
			<pre>    let stock: Value = json!({</pre>&#13;
			<pre>        "name": "MonolithAi",</pre>&#13;
			<pre>        "price": 43.7,</pre>&#13;
			<pre>        "history": [19.4, 26.9, 32.5]</pre>&#13;
			<pre>    });</pre>&#13;
			<pre>    println!("first price: {}", stock["history"][0]);</pre>&#13;
			<pre>    println!("{}", stock.to_string());</pre>&#13;
			<pre>}</pre>&#13;
			<p>It is important to note that we are returning a <code>Value</code> struct from the <code>serde_json </code>value. In order to see how we can use the return value, we can explore the documentation<a id="_idIndexMarker114"/> of the struct. This is when we get to see that Rust's<a id="_idIndexMarker115"/> documentation system is <a id="_idIndexMarker116"/>very<a id="_idIndexMarker117"/> comprehensive. We can find the documentation of the struct here: <a href="https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html">https://docs.rs/serde_json/1.0.64/serde_json/enum.Value.html</a>. </p>&#13;
			<p>We can see in <em class="italic">Figure 2.1</em> that the documentation covers all of the functions that the struct supports. Our <code>json!</code> macro is returning <code>Object(Map&lt;String, Value&gt;)</code>. We also have a range of other values, depending on how we call the <code>json!</code> macro. The documentation also covers a range of functions that we can exploit to check what type the value is, whether the JSON value is <code>null</code>, and ways in which we can cast the JSON value as a particular type:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_2.01_B17720.jpg" alt="Figure 2.1 – Documentation of the serde_json value &#13;&#10;" width="1354" height="1279"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.1 – Documentation of the serde_json value </p>&#13;
			<p>When <a id="_idIndexMarker118"/>we <a id="_idIndexMarker119"/>perform <a id="_idIndexMarker120"/>a <a id="_idIndexMarker121"/>Cargo <code>run</code> command, we will see Cargo compiling the crates that we defined in the dependencies. We then see the compilation of our own app, and the printout of the price and the data related to the stock, as shown here:</p>&#13;
			<pre>first price: 19.4</pre>&#13;
			<pre>{"history":[19.4,26.9,32.5], "name":"MonolithAi",\ </pre>&#13;
			<pre>  "price":43.7}</pre>&#13;
			<p>Going back to the documentation, we can create our own. This is straightforward; we do not have to install anything. All we have to do is create documentation in the code, like <strong class="bold">docstrings</strong> in Python. In order to demonstrate this, we can create a function that adds two variables<a id="_idIndexMarker122"/> together <a id="_idIndexMarker123"/>and<a id="_idIndexMarker124"/> defines<a id="_idIndexMarker125"/> the docstring, as seen in the following code:</p>&#13;
			<pre>/// Adds two numbers together. </pre>&#13;
			<pre>/// </pre>&#13;
			<pre>/// # Arguments</pre>&#13;
			<pre>/// * one (i32): one of the numbers to be added</pre>&#13;
			<pre>/// * two (i32): one of the numbers to be added</pre>&#13;
			<pre>/// </pre>&#13;
			<pre>/// # Returns</pre>&#13;
			<pre>/// (i32): the sum of param one and param two</pre>&#13;
			<pre>/// </pre>&#13;
			<pre>/// # Usage</pre>&#13;
			<pre>/// The function can be used by the following code:</pre>&#13;
			<pre>/// </pre>&#13;
			<pre>/// '''rust</pre>&#13;
			<pre>/// result: i32 = add_numbers(2, 5);</pre>&#13;
			<pre>/// '''</pre>&#13;
			<pre>fn add_numbers(one: i32, two: i32) -&gt; i32 {</pre>&#13;
			<pre>    return one + two</pre>&#13;
			<pre>}</pre>&#13;
			<p>We can see that this documentation is Markdown! This example is overkill for this type of function. A standard developer should be able to implement this function without any examples. For more complex functions and structs, it is worth noting that there is nothing stopping us from documenting code examples on how to implement what we are documenting. Building the documentation only requires the command here:</p>&#13;
			<pre>cargo doc</pre>&#13;
			<p>After the process has finished, we can open the documentation with the following command:</p>&#13;
			<pre>cargo doc --open</pre>&#13;
			<p>This opens <a id="_idIndexMarker126"/>up<a id="_idIndexMarker127"/> the<a id="_idIndexMarker128"/> documentation <a id="_idIndexMarker129"/>in a web browser, as shown in <em class="italic">Figure 2.2</em>:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.02_B17720.jpg" alt="Figure 2.2 – Documentation view of our module&#13;&#10;" width="1396" height="712"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.2 – Documentation view of our module</p>&#13;
			<p>What we can see here is that our <code>main</code> and <code>add_numbers</code> functions are available. We can also see on the left that the dependencies that were installed are also available. If we click on our <code>add_numbers</code> function, we get to see the Markdown that we wrote, as shown in <em class="italic">Figure 2.3</em>:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.03_B17720.jpg" alt="Figure 2.3 – Documentation view of our add_numbers function&#13;&#10;" width="1410" height="773"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.3 – Documentation view of our add_numbers function</p>&#13;
			<p>Here we have it – we can create interactive documentation of our code as we build our application. It has to be noted that the rest of the book will not have Markdown in the code snippets; otherwise, this would simply extend the book to an unnecessary length. However, it is good practice to document all structs and functions as you code. </p>&#13;
			<p>Now that we <a id="_idIndexMarker130"/>have<a id="_idIndexMarker131"/> run our <a id="_idIndexMarker132"/>code, set <a id="_idIndexMarker133"/>up a basic application structure, and documented our code, we are ready to move on to the next section of structuring our application over multiple files.</p>&#13;
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Structuring code over multiple files and modules  </h1>&#13;
			<p>In order<a id="_idIndexMarker134"/> to build our module, we are going to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Map out our file and folder structure.</li>&#13;
				<li>Create our <code>Stock</code> structs.</li>&#13;
				<li>Link our <code>Stock</code> struct to the main file.</li>&#13;
				<li>Use our <code>stocks</code> module in the main file.</li>&#13;
				<li>Add code from another module.</li>&#13;
			</ol>&#13;
			<p>Now that we are at the stage of building out our application over multiple files, we have to define our first module in our <a id="_idIndexMarker135"/>application, which is the <strong class="bold">stocks module</strong>: </p>&#13;
			<ol>&#13;
				<li value="1">We can<a id="_idIndexMarker136"/> make our module have the structure defined as follows:<pre>├── main.rs
└── stocks
    ├── mod.rs
    └── structs
        ├── mod.rs
        └── stock.rs</pre><p>We have taken this structure to enable flexibility; if we need to add more structs, we can do so in the <code>structs</code> directory. We can also add other directories alongside the <code>structs</code> directory. For instance, we might want to build a mechanism for storing the data for our stocks. This can be achieved by adding a <code>storage</code> directory in the <code>stocks</code> directory and using this throughout the module as and when it is needed. </p></li>&#13;
				<li>For now, we simply want to create a stock struct in our <code>stocks</code> module, import it into our <code>main.rs</code> file, and use it. Our first step is to define our <code>Stock</code> struct in our <code>stock.rs</code> file with this code:<pre>pub struct Stock {
    pub name: String,
    pub open_price: f32,
    pub stop_loss: f32,
    pub take_profit: f32,
    pub current_price: f32
}</pre><p>This looks familiar, as it is the same as the <code>Stock</code> struct that we defined in the previous chapter. However, there is a slight difference. We must note that there is a <code>pub</code> keyword <a id="_idIndexMarker137"/>before the struct definition and each field definition. This is because we have to declare them public before we can use them outside the file. This also applies to functions implemented in the same file, as shown in the following code:</p><pre>impl Stock {
    pub fn new(stock_name: &amp;str, price: f32) -&gt; \
      Stock {
        return Stock{
            name: String::from(stock_name), 
            open_price: price,
            stop_loss: 0.0,
            take_profit: 0.0,
            current_price: price
        }
    }
    pub fn with_stop_loss(mut self, value: f32) \
      -&gt; Stock {
        self.stop_loss = value;
        return self
    }
    pub fn with_take_profit(mut self, value: f32) \
      -&gt; Stock {
        self.take_profit = value;
        return self
    }
    pub fn update_price(&amp;mut self, value: f32) {
        self.current_price = value;
    }
}</pre><p>We can see <a id="_idIndexMarker138"/>that we now have a public struct that is available with all its functions. </p></li>&#13;
			</ol>&#13;
			<p>We now have to enable our struct to be used in the <code>main.rs</code> file. This is where the <code>mod.rs</code> files come in. <code>mod.rs</code> files are essentially <code>__init__.py</code> files in Python. They show that the directory is a module. However, unlike Python, Rust data structures need to be publicly declared in order to be accessed from other files. We can see how the struct is passed through our <code>stocks</code> module to our <code>main.rs</code> file in <em class="italic">Figure 2.4</em>:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.04_B17720.jpg" alt="Figure 2.4 – How a struct is passed through modules&#13;&#10;" width="787" height="609"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.4 – How a struct is passed through modules</p>&#13;
			<p>Here, we can<a id="_idIndexMarker139"/> see that we are merely publicly declaring the struct in the module furthest away from <code>main.rs</code> in the <code>mod.rs</code> file belonging to that directory. We then publicly declare the <code>structs</code> module in the <code>stocks</code> <code>mod.rs</code> file. Here is a good time to explore the <code>mod</code> expression that declares modules. If we want to, we can declare multiple modules in a single file. It must be stressed that this is not happening in our example. We could declare module one and module two in a single file with the following code:</p>&#13;
			<pre>mod one {</pre>&#13;
			<pre>    . . . </pre>&#13;
			<pre>}</pre>&#13;
			<pre>Mod two {</pre>&#13;
			<pre>    . . .</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now that we have defined our modules in our main example project, we just declare the <code>stocks</code> module in the <code>main.rs</code> file. The reason why this is not a public declaration is that the <code>main.rs</code> file is the entry point of our application; we will not be importing this module into anything else: </p>&#13;
			<ol>&#13;
				<li value="1">Now that our struct is available, we can simply use it as we would if it was defined in the same file with the following:<pre>mod stocks;
use stocks::structs::stock::Stock;
fn main() {
    let stock: Stock = Stock::new("MonolithAi", 36.5);
    println!("here is the stock name: {}",\
      stock.name);
    println!("here is the stock name: {}",\
      stock.current_price);
}</pre></li>&#13;
				<li>Running <a id="_idIndexMarker140"/>this code unsurprisingly gives us this:<pre><strong class="bold">here is the stock name: MonolithAi</strong>
<strong class="bold">here is the stock name: 36.5</strong></pre></li>&#13;
			</ol>&#13;
			<p>Now that we have the basics of using structs from different files covered, we can move on to exploring other pathways of accessing data structures from other files in order to be more flexible: </p>&#13;
			<ol>&#13;
				<li value="1">The first concept we have to explore is accessing from files in the same directory. In order to demonstrate this, we can do a throwaway example of building a print function in the structs. In a new file with the <code>src/stocks/structs/utils.rs</code> path, we can create a toy function that merely prints out that the constructor for the struct is firing, as shown in the following code:<pre>pub fn constructor_shout(stock_name: &amp;str) -&gt; () {
    println!("the constructor for the {} is firing", \
      stock_name);
}</pre></li>&#13;
				<li>We then declare it in our <code>src/stocks/structs/mod.rs</code> file with the following code:<pre>pub mod stock;
mod utils;</pre><p>It must be noted that we are not making it public; we just declare it instead. Nothing is stopping us from making it public; however, with the non-public approach, we only allow files within the directory of <code>src/stocks/structs/</code> to access it. </p></li>&#13;
				<li>We now want our <code>Stock</code> struct to access it and use it in our constructor, which can be <a id="_idIndexMarker141"/>done with an import in <code>src/stocks/structs/stock.rs</code> with the following line: <pre>use super::utils::constructor_shout;</pre></li>&#13;
				<li>If we want to move our reference to the <code>src/stocks/</code> directory, we can use <code>super::super</code>. We can chain as many supers as we want, depending on how deep the tree is. It has to be noted that we can only access what is declared in the <code>mod.rs</code> file of the directory. In our <code>src/stocks/structs/stock.rs</code> file, we can now use the function in our constructor with the following code:<pre>pub fn new(stock_name: &amp;str, price: f32) -&gt; Stock {
    constructor_shout(stock_name);
    return Stock{
        name: String::from(stock_name), 
        open_price: price,
        stop_loss: 0.0,
        take_profit: 0.0,
        current_price: price
    }
}</pre></li>&#13;
				<li>Now, if we run our application, we will get the following printout in the terminal:<pre><code>util</code> function that we imported from. If we create another module, we can access our <code>stocks</code> module from it, because the <code>stocks</code> module is defined in the <code>main.rs</code> file.</p></li>&#13;
			</ol>&#13;
			<p>While we have managed to access data structures from different files and modules, this is not very<a id="_idIndexMarker142"/> scalable, and there are going to be some rules in which we implement stocks. In order to enable us to write scalable safe code, we need to lock down the functionality with interfaces in the next section.   </p>&#13;
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Building module interfaces  </h1>&#13;
			<p>Unlike Python, where<a id="_idIndexMarker143"/> we can import anything we want from anywhere and at the most our IDE will just give us a syntax highlight, Rust will actively not compile if we try and access data structures that have not explicitly been made public. This gives us an opportunity to really lock down our modules and enforce functionality through an interface. </p>&#13;
			<p>However, before we get started with this, let's fully explore what functionality we will be locking down. It is good practice to keep modules as isolated as possible. In our <code>stocks</code> module, the logic should only be around how to handle stocks and nothing else. This might seem a little overkill, but when we think about it, we quickly realize that this module is going to scale when it comes to complexity. </p>&#13;
			<p>For the demonstrative purposes of this chapter, let's just build the functionality for a stock order. We can either buy or sell a stock. These stock orders come in multiples. It's fairly common to buy <em class="italic">n</em> stocks of a company. We will also have to check to see whether the stock order is short or long. With a short order, we borrow money from the broker, buy stocks with that money, sell them instantly, and then buy the stocks back at a later date. If the stock price goes down, we make money, as we keep the difference when repaying to the broker. If we go long, we just buy the stock and hold it. If it goes up, we make money, so depending on the order, there will be different outcomes. </p>&#13;
			<p>We have to remember that this is not a book for developing software around stock markets, so we need to keep the details simple to avoid losing ourselves. A simple approach for us to take to demonstrate interfaces is to take a layered approach, as described<a id="_idIndexMarker144"/> in <em class="italic">Figure 2.5</em>:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.05_B17720.jpg" alt="Figure 2.5 – Approach to a simple module interface&#13;&#10;" width="732" height="672"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.5 – Approach to a simple module interface</p>&#13;
			<p>In order to achieve this approach, we can carry out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Structure the module layout with the right files. </li>&#13;
				<li>Create an enum for the different types of orders.</li>&#13;
				<li>Build an order struct.</li>&#13;
				<li>Install the <code>chrono</code> crate needed for <code>datetime</code> objects.</li>&#13;
				<li>Create an order constructor that utilizes the <code>chrono</code> crate.</li>&#13;
				<li>Create dynamic values for the struct.</li>&#13;
				<li>Create a close order interface.</li>&#13;
				<li>Create an open order interface.</li>&#13;
				<li>Use the order interfaces in the main file.</li>&#13;
			</ol>&#13;
			<p>Let's get started:</p>&#13;
			<ol>&#13;
				<li value="1">Here, we only allow ourselves to access the stock struct through the order struct. Again, there are other ways to approach this problem, which is a demonstration of <a id="_idIndexMarker145"/>how to build interfaces in Rust. In order to achieve this in the code, we have the file structure defined as follows:<pre>├── main.rs
└── stocks
    ├── enums
    │   ├── mod.rs
    │   └── order_types.rs
    ├── mod.rs
    └── structs
        ├── mod.rs
        ├── order.rs
        └── stock.rs</pre></li>&#13;
				<li>First of all, we can define our enum order types in our <code>enums/order_types.rs</code> file with the following code:<pre>pub enum OrderType {
    Short,
    Long
}</pre></li>&#13;
				<li>We will use this in our order and interfaces. In order to make this enum type available to the rest of the module, we have to declare it in our <code>enums/mod.rs</code> file with the following code:<pre>pub mod order_types;</pre></li>&#13;
				<li>Now that we have built our enum type, it is time to put it to work. We can now build our <a id="_idIndexMarker146"/>order struct in our <code>stocks/structs/order.rs</code> file with the following code:<pre>use chrono::{Local, DateTime};
use super::stock::Stock;
use super::super::enums::order_types::OrderType;
pub struct Order {
    pub date: DateTime&lt;Local&gt;,
    pub stock: Stock,
    pub number: i32,
    pub order_type: OrderType
}</pre></li>&#13;
				<li>Here, we use the <code>chrono</code> crate to define when the order was placed; we also have to note what stock the order is for, the number of stocks that we are buying, and the type of order. We have to remember to define our <code>chrono</code> dependency on our <code>Cargo.toml</code> file with the following code: <pre>[dependencies]
serde="1.0.117"
serde_json="1.0.59"
chrono="0.4.19"</pre><p>The reason why we have kept our stock struct separate from the order struct is to allow flexibility. For instance, there are other things that we can do with stock data that is not an order. We may want to build a struct that houses stocks on the user watch list and the user hasn't actually bought anything, but they still want to see the stocks available. </p></li>&#13;
				<li>There are other use cases for stock data, however. Considering this, we can see that keeping the data and methods around a stock in an individual stock struct helps to not<a id="_idIndexMarker147"/> only reduce the amount of code we have to write if we add more features but also standardizes the data around a stock. This also makes it easier for us to maintain the code. If we add or delete a field, or change a method for stock data, we only have to change it in one place as opposed to multiple places. Our constructor for our order struct can be made in the same file with the following code:<pre>impl Order {
    pub fn new(stock: Stock, number: i32, \ 
      order_type: OrderType) -&gt; Order {
      let today: DateTime&lt;Local&gt; = Local::now();
        return Order{date: today, stock, number, \
          order_type}
    }
}</pre><p>Here we create an <code>Order</code> struct by accepting <code>stock</code>, <code>number</code>, and <code>order_type</code> arguments and creating a <code>datetime</code> struct. </p></li>&#13;
				<li>Because our order focuses on the logic around pricing the order as it houses the number of stocks brought in an order, in our <code>impl</code> block, we can build our current value of the order with the following code:<pre>    pub fn current_value(&amp;self) -&gt; f32 {
        return self.stock.current_price * self \
          .number as f32
    }</pre><p>It has to be noted that we have used <code>&amp;self</code> as a parameter instead of just using <code>self</code>. This enables us to use the function multiple times. If the parameter was not a reference, then we would move the struct into the function. We would not be able to calculate the value multiple times, and it's going to be useful to do<a id="_idIndexMarker148"/> so unless the type is <code>Copy</code>. </p></li>&#13;
				<li>We can also build on this function to calculate the current profit in the <code>impl</code> block with the following code:<pre>    pub fn current_profit(&amp;self) -&gt; f32 {
        let current_price: f32 = self.current_value();
        let initial_price: f32 = self.stock. \
          open_price * self.number as f32;
        match self.order_type {
          OrderType::Long =&gt; return current_price -\
            initial_price,
          OrderType::Short =&gt; return initial_price -\
            current_price
        }
    }</pre><p>Here, we get the current price and the initial price. We then match the order type, as this will change how the profit is calculated. Now our structs are complete, we have to ensure that the structs are available by defining them in the <code>stocks/structs/mod.rs</code> file with the following code:</p><pre>pub mod stock;
pub mod order;</pre></li>&#13;
				<li>We are now ready to create our interfaces. In order to build our interface in our <code>stocks</code> <code>/mod.rs</code> file, we initially have to import everything that we need, as shown in <a id="_idIndexMarker149"/>the following code:<pre>pub mod structs;
pub mod enums;
use structs::stock::Stock;
use structs::order::Order;
use enums::order_types::OrderType;</pre></li>&#13;
				<li>Now that we have everything to build our interface, we can build our close order interface with the following code:<pre>pub fn close_order(order: Order) -&gt; f32 {
    println!("order for {} is being closed", \
      &amp;order.stock.name);
    return order.current_profit()
}</pre></li>&#13;
				<li>This is a fairly simple interface; we could do more, such as a database or API call, but for this demonstration, we merely print that the stock is being sold and return the current profit that we have made. With this in mind, we can build our more complex interface by opening an order in the same file with the following code:<pre>pub fn open_order(number: i32, order_type: OrderType,\ 
                  stock_name: &amp;str, open_price: f32,\
                  stop_loss: Option&lt;f32&gt;, \
                    take_profit: Option&lt;f32&gt;) -&gt; \
                      Order { \
    println!("order for {} is being made", \ 
      &amp;stock_name);              
    let mut stock: Stock = Stock::new(stock_name, \ 
      open_price);
    match stop_loss {
        Some(value) =&gt; stock = \ 
          stock.with_stop_loss(value),
        None =&gt; {}
    }
    match take_profit {
        Some(value) =&gt; stock = \
          stock.with_take_profit(value),
        None =&gt; {}
    }
    return Order::new(stock, number, order_type)
}</pre><p>Here, we take<a id="_idIndexMarker150"/> in all of the parameters that we need. We have also introduced the <code>Option&lt;f32&gt;</code> argument type, which is implemented as an enum type. This allows us to pass in a <code>None</code> value. We then create a mutable stock (as the price will vary and we will have to update it), and then check to see whether the <code>stop_loss</code> value is provided; if it is, we then add the stop loss to the stock. We then check to see whether the <code>take_profit</code> value is provided, updating the stock with this if it is.</p></li>&#13;
				<li>Now that we have built all our interfaces, all we need to do is to use them in the <code>main.rs</code> file. In the main file, we need to import the needed structs and interfaces to utilize them with the following code:<pre>mod stocks;
use stocks::{open_order, close_order};
use stocks::structs::order::Order;
use stocks::enums::order_types::OrderType;</pre></li>&#13;
				<li>In our main <a id="_idIndexMarker151"/>function, we can start putting these interfaces to work by creating a new mutable order with the following code:<pre>println!("hello stocks");
let mut new_order: Order = open_order(20, \
    OrderType::Long, "bumper", 56.8, None, None);</pre></li>&#13;
				<li>Here, we have set <code>take_profit</code> and <code>stop_loss</code> to <code>None</code>, but we can add them if we need to. To clarify what we have just bought, we can print out the current value and profit with the following code:<pre>println!("the current price is: {}", 
    &amp;new_order.current_value());
println!("the current profit is: {}", 
    &amp;new_order.current_profit());</pre></li>&#13;
				<li>We then get some movement in the stock market, which we can simulate by updating the price and printing the value of our investment at each change with the following code:<pre>new_order.stock.update_price(43.1);
println!("the current price is: {}", \ 
    &amp;new_order.current_value());
println!("the current profit is: {}", \ 
    &amp;new_order.current_profit());
new_order.stock.update_price(82.7);
println!("the current price is: {}", \
         &amp;new_order.current_value());
println!("the current profit is: {}", \
         &amp;new_order.current_profit());</pre></li>&#13;
				<li>We now <a id="_idIndexMarker152"/>have a profit, and we will sell our stock to close the order and print out the profit with the following code:<pre>let profit: f32 = close_order(new_order);
println!("we made {} profit", profit);</pre></li>&#13;
				<li>Now, our interfaces, module, and main file are built. Running the Cargo <code>run</code> command gives us the following printout:<pre><strong class="bold">hello stocks</strong>
<strong class="bold">the constructor for the bumper is firing</strong>
<strong class="bold">the current price is: 1136</strong>
<strong class="bold">the current profit is: 0</strong>
<strong class="bold">the current price is: 862</strong>
<strong class="bold">the current profit is: -274</strong>
<strong class="bold">the current price is: 1654</strong>
<strong class="bold">the current profit is: 518</strong>
<strong class="bold">order for bumper is being closed</strong>
<strong class="bold">we made 518 profit</strong></pre></li>&#13;
			</ol>&#13;
			<p>As we can see, our module works and it has a clean interface. For this book, our example stops here, as we have shown how we can build modules in Rust with interfaces. However, if you want to go further with building out the application, we can take the approach seen in <em class="italic">Figure 2.6</em>:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.06_B17720.jpg" alt="Figure 2.6 – Building out our application&#13;&#10;" width="572" height="493"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.6 – Building out our application</p>&#13;
			<p>In the account <a id="_idIndexMarker153"/>module, we would build data structures around keeping track of the amount the user has through trades. We would then build a storage module that has read and write interfaces for accounts and stocks. The reason why storage is a separate module is that we can keep the interfaces the same, and chop and change the storage logic under the hood. </p>&#13;
			<p>For instance, we could start with a simple JSON file storage system for development and local usage; however, the application then gets put onto a server, and loads of users start making trades and accessing their accounts. We can switch the file reading and write for a database driver with database model mapping. The system then gets a lot of traffic and the application gets split into a cluster of microservices. One application would still be talking to a database, while another one for frequently requested stocks/accounts could be talking to a Redis cache. </p>&#13;
			<p>Considering this, keeping the storage separate keeps us flexible. Changing the requirements for the storage is not going to break the build. In fact, a configuration file could enable the switching of different methods, depending on the environment. As long as the <a id="_idIndexMarker154"/>interfaces remain the same, refactoring will not be a huge task.</p>&#13;
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Benefits of documentation when coding  </h2>&#13;
			<p>As our module<a id="_idIndexMarker155"/> spans multiple files, we are now referencing functions and structs that are in different files. This is where the importance of documentation can be seen. We can revisit our point in the technical requirements of using Visual Studio Code. The code in GitHub is fully documented. If the Rust plugins are installed, merely hovering the mouse over the struct or function will pop up the documentation, allowing us to see what is needed in our interface, as shown in <em class="italic">Figure 2.7</em>:</p>&#13;
			<p class="figure-caption"> </p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_2.07_B17720.jpg" alt="Figure 2.7 – Popup documentation in Visual Studio Code&#13;&#10;" width="748" height="460"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 2.7 – Popup documentation in Visual Studio Code</p>&#13;
			<p>There is a reason why badly structured code that isn't documented is referred to as <em class="italic">tech debt</em>, and this is because it collects interest over time. Poorly structured code with no documentation is quick to develop, however, and as the size of the application grows, it's going to get harder to change things and understand what is going on. A well-structured module with good Markdown Rust documentation is a great way to keep you and your team's productivity high. </p>&#13;
			<p>We now have a functioning application that spans multiple pages and is clean and scalable. However, a user cannot dynamically use it, as everything has to be hardcoded. This is not <a id="_idIndexMarker156"/>practical. In the next section, we interact with the environment so we can pass arguments into the program.</p>&#13;
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Interacting with the environment</h1>&#13;
			<p>We are at the <a id="_idIndexMarker157"/>stage in which the only thing that is holding us back from building a fully functioning command-line application is interacting with the environment. As stated in the previous section, this is an open-ended subject that spans anything from taking command-line arguments to interacting with servers and databases. As in the previous section, we will cover enough in order to get an understanding of how to structure Rust code that accepts data from the outside and processes it. </p>&#13;
			<p>In order to explore this, we are going to get our stock application to take in command-line arguments from the user so that we can either buy or sell a stock. We will not over-complicate things by choosing whether to go short or go long, and we will not introduce storage. </p>&#13;
			<p>However, by the end of this section, we will be equipped to approach building code that scales and accepts data from the outside world. With this, further reading on crates that connect to databases or read/write files will enable us to seamlessly add them to our well-structured code. In terms of databases, we will cover how to mirror the schema of a database and connect to it in <a href="B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182"><em class="italic">Chapter 10</em></a>, <em class="italic">Injecting Rust into a Python Flask App</em>. </p>&#13;
			<p>For our toy example, we will be generating a random number for our sale stock price in order to calculate whether we sell at a profit or loss. We will do this by adding the <code>Cargo.toml</code> file with <code>rand="0.8.3"</code>. We can interact with our environment by carrying out the following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Import all the required crates. </li>&#13;
				<li>Collect the inputs from the environment.</li>&#13;
				<li>Process our inputs with orders.</li>&#13;
			</ol>&#13;
			<p>Let's get started:</p>&#13;
			<ol>&#13;
				<li value="1">Now that our <code>rand</code> crate has been added, we can add all the extra imports that we need in the <code>main.rs</code> file with the following code:<pre>use std::env;
use rand::prelude::*;
use std::str::FromStr;</pre><p>We are using <code>env</code> to get the arguments passed into Cargo. We import everything from the prelude of the <code>rand</code> crate so that we can generate random numbers, and we import <code>FromStr</code> trait so that we can convert strings passed in from the<a id="_idIndexMarker159"/> command-line arguments into numbers. </p></li>&#13;
				<li>In our main function, we initially collect the arguments passed in from the command line with the following code:<pre>let args: Vec&lt;String&gt; = env::args().collect();
let action: &amp;String = &amp;args[1];
let name: &amp;String = &amp;args[2];
let amount: i32 = i32::from_str(&amp;args[3]).unwrap();
let price: f32 = f32::from_str(&amp;args[4]).unwrap();</pre><p>We state that we are going to collect the command-line arguments in a vector of strings. We do this because pretty much everything can be represented as a string. We then define all the parameters that we need. We have to note that we start at index <code>1</code> instead of <code>0</code>. This is because index <code>0</code> is populated with the <code>run</code> command. We can also see that we are converting the strings into numbers when we need them and directly unwrapping them. This is a little dangerous; we should ideally match the result of the <code>from_str</code> function and give better information to the user if we were building a proper production command-line tool. </p></li>&#13;
				<li>Now that we have everything we need, we create a new order with the data we collected using the following code:<pre>let mut new_order: Order = open_order(amount, \
    OrderType::Long, &amp;name.as_str(), price, \ 
        None, None);</pre><p>We are creating a new order every time even if it is a sell because we do not have storage, and we need to have all the structured data and logic around our stock <a id="_idIndexMarker160"/>position. We then match our actions. If we are going to sell our stock, we generate a new price for the stock before selling. Considering this, we can see whether we make a profit or not with the following code:</p><pre>match action.as_str() {
    "buy" =&gt; {
        println!("the value of your investment is:\
          {}", new_order.current_value());
    }
    "sell" =&gt; {
        let mut rng = rand::thread_rng();
        
        let new_price_ref: f32 = rng.gen(); 
        let new_price: f32 = new_price_ref * 100 as \
          f32;
        new_order.stock.update_price(new_price);
        let sale_profit: f32 = close_order(new_order);
        println!("here is the profit you made: {}", \
            sale_profit);
    }
    _ =&gt; {
        panic!("Only 'buy' and 'sell' actions are \
          supported");
    }
}</pre><p>It must be noted that we have a <code>_</code> at the end of the match expression. This is because the<a id="_idIndexMarker161"/> string could theoretically be anything and Rust is a safe language. It will not allow us to compile the code if we did not account for every outcome. The <code>_</code> is a catch-all pattern. If not all of the match patterns are made, then this is executed. For us, we merely raise an error, stating that only sell and buy are supported. </p></li>&#13;
				<li>In order to run this program, we perform the following command:<pre><strong class="bold">cargo run sell monolithai 26 23.4</strong></pre></li>&#13;
				<li>Running this will give us the following outcome:<pre><strong class="bold">order for monolithai is being made</strong>
<strong class="bold">order for monolithai is being closed</strong>
<strong class="bold">here is the profit you made: 1825.456</strong></pre><p>The profit you make will be different, as the number generated will be random. </p></li>&#13;
			</ol>&#13;
			<p>Here we have it – our application is interactive and scalable. If you want to build more comprehensive command-line interfaces with help menus, it is recommended that you read and utilize the <code>clap</code> crate. </p>&#13;
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Summary</h1>&#13;
			<p>In this chapter, we went through the basics of Cargo. With Cargo, we managed to build basic applications, document them, compile them, and run them. Looking at how clean and easy this implementation was, it is clear to see why Rust is one of the most favored languages. Managing all the functionality, documentation, and dependencies in one file with a few lines of code speeds up the whole process. Combining this with a strict, helpful compiler makes Rust a no-brainer when it comes to managing complex projects. We managed our complexity by wrapping our module in easy-to-use interfaces and interacting with the user's inputs through the command line. </p>&#13;
			<p>Right now, as you stand, you can start building Rust code to solve a range of problems. If you want to build an application that interacts as a Rust web server with a frontend and database, I recommend that you read my other book on web development in Rust, <em class="italic">Rust Web Programming</em>, and start at <a href="B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, as you have now covered enough Rust fundamentals to start building Rust servers. </p>&#13;
			<p>In the next chapter of this book, we will cover how to exploit Rust's concurrency. </p>&#13;
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">As we continue to code, how do we document it?</li>&#13;
				<li>Why is it important to keep modules isolated to a single concept?</li>&#13;
				<li>How do we enable our modules to keep the advantages of isolated modules?</li>&#13;
				<li>How do we manage dependencies in our application?</li>&#13;
				<li>How do we ensure that all outcomes in a match expression are accounted for when there is theoretically an infinite number of outcomes, such as matching different strings?</li>&#13;
				<li>Let's say that we have a struct called <code>SomeStruct</code> in a <code>some_file/some_struct.rs</code> file. How do we make this available outside of the directory that it is in? </li>&#13;
				<li>Let's say that we have changed our mind about our <code>SomeStruct</code> struct in question 6 and we want it only available in the <code>some_file/</code> directory. How would we do this?</li>&#13;
				<li>How can we access our <code>SomeStruct</code> struct in the <code>some_file/another_struct.rs</code> file?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1">Our docstrings can support Markdown while we are building our structs and functions. Because it's Markdown, we can document ways in which we can implement the struct or function. If we are using Visual Studio Code, this also helps our productivity, as merely hovering the mouse over the function or struct throws up the documentation.</li>&#13;
				<li>Keeping our modules constrained to a single concept increases the flexibility of the application, enabling us to chop and change modules as and when they are needed.</li>&#13;
				<li>In order to keep our modules isolated, we need to keep the interfaces of the module the same; this means that we can change logic inside the module without having to alter anything in the rest of the application. If we delete the module, we only have to look for implementations of the interface throughout the application as opposed to the implementation of all functions and structs in the module.</li>&#13;
				<li>We manage our dependencies in the <code>Cargo.toml</code> file. Just running Cargo will install the requirements we have when it is compiling before running.</li>&#13;
				<li>We can account for everything by catching anything that hasn't satisfied all our matches. This is done by implementing a <code>_</code> pattern at the end of our match expression, executing the code attached to that.</li>&#13;
				<li>We make it publicly available by writing <code>pub mod some_struct;</code> in the <code>some_file/mod.rs</code> file.</li>&#13;
				<li>We make it available only in the <code>some_file/</code> directory by writing <code>mod some_struct;</code> in the <code>some_file/mod.rs</code> file.</li>&#13;
				<li>We can access the <code>SomeStruct</code> by typing <code>use super::some_struct::SomeStruct;</code> in the <code>some_file/another_struct.rs</code> file.</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">Rust Web Programming</em>, <em class="italic">Maxwell Flitton</em>, <em class="italic">Packt Publishing</em> (2021)</li>&#13;
				<li><em class="italic">Mastering Rust</em>, <em class="italic">Rahul Sharma and Vesa Kaihlavirta</em>, <em class="italic">Packt Publishing</em> (2019)</li>&#13;
				<li><em class="italic">The Rust Programming Language</em>, Rust Foundation: <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> (2018)</li>&#13;
				<li><em class="italic">The Clap documentation</em>, Clap Docs: <a href="https://docs.rs/clap/2.33.3/clap/">https://docs.rs/clap/2.33.3/clap/</a> (2021)</li>&#13;
				<li><em class="italic">The standard file documentation</em>, Rust Foundation: <a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a> (2021)</li>&#13;
				<li><em class="italic">The chrono DateTime documentation</em>, Rust Foundation: ,https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html (2021)</li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>