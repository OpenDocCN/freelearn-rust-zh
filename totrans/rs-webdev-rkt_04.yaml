- en: '*Chapter 3*: Rocket Requests and Responses'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss Rocket **requests** and **responses** more in this chapter.
    The first section will discuss how Rocket handles incoming requests in the form
    of routes. We will learn about various parts of a route including HTTP methods,
    URIs, and paths. Then, we will create an application that uses various parts in
    routes. We will also talk about Rust **traits** and implement a Rust trait to
    create a request handler.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to discuss responses in a Rocket route handler and implement
    returning responses. After that, we will talk more about various built-in responder
    implementations and learn how to create an error handler to create a custom error
    when a route handler fails. Finally, we will implement a generic error handler
    to handle common HTTP status codes such as `404` and `500`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will be able to create the most important part
    of the Rocket framework: functions to handle incoming requests and return responses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Rocket routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing route handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making default error handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have the same technical requirements from [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application* for this chapter. We require a Rust
    compiler to be installed, along with a text editor, and an HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Rocket routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin our chapter by discussing how Rocket handles incoming requests in
    the form of routes. We write functions that can be used to handle incoming requests,
    put route attribute above those functions, and attach the route handling functions
    to the Rocket. A route has an HTTP method and a `src/main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines are the `route` attributes. You can only put the `route`
    attribute in a free function and not in a method inside `impl` of a `Struct`.
    Now, let's discuss the route parts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first parameter you see inside the route definition is the HTTP method.
    The HTTP method is defined in the `rocket::http::Method` enum. The enum has the
    `GET`, `PUT`, `POST`, `DELETE`, `OPTIONS`, `HEAD`, `TRACE`, `CONNECT`, and `PATCH`
    members, which all correspond to valid HTTP methods defined in RFCs (Request For
    Comments).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use other attributes to denote a route besides using the `#[route...]`
    macro. We can directly use method-specific route attributes such as `#[get...]`.
    There are seven method-specific route attributes: `get`, `put`, `post`, `delete`,
    `head`, `options`, and `patch`. We can rewrite the previous route attributes into
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It looks simple, right? Unfortunately, we still have to use the `#[route...]`
    attribute if we want to handle `HTTP CONNECT` or `TRACE` as there are no method-specific
    route attributes for these two methods.
  prefs: []
  type: TYPE_NORMAL
- en: URI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the route attribute, we can see the `?`) is the path and the part after
    the question mark is the query.
  prefs: []
  type: TYPE_NORMAL
- en: Both the path and the query can be divided into `/`), as in `/segment1/segment2`.
    The query is segmented by an ampersand (`&`), as in `?segment1&segment2`.
  prefs: []
  type: TYPE_NORMAL
- en: A segment can be `/static` or `?static`. The dynamic segment is defined inside
    angle brackets (`<>`), as in `/<dynamic>` or `?<dynamic>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you declare a dynamic segment, you must use the segment as a function parameter
    in the function following the route attribute. The following is an example of
    how we can use the dynamic segment by writing a new application and adding this
    route and function handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The argument type in the handler function for the path must implement the `rocket::request::FromParam`
    trait. You might be wondering why we used `u8` as a function argument in the previous
    example. The answer is because Rocket has already implemented the `FromParam`
    trait for important types, such as `u8`. The following is a list of all types
    that have already implemented the `FromParam` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types such as `f32`, `f64`, `isize`, `i8`, `i16`, `i32`, `i64`, `i128`,
    `usize`, `u8`, `u16`, `u32`, `u64`, `u128`, and `bool`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust standard library numerical types in the `std::num` module, such as `NonZeroI8`,
    `NonZeroI16`, `NonZeroI32`, `NonZeroI64`, `NonZeroI128`, `NonZeroIsize`, `NonZeroU8`,
    `NonZeroU16`, `NonZeroU32`, `NonZeroU64`, `NonZeroU128`, and `NonZeroUsize`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust standard library `net` types in the `std::net` module, such as `IpAddr`,
    `Ipv4Addr`, `Ipv6Addr`, `SocketAddrV4`, `SocketAddrV6`, and `SocketAddr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&str` and `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Option<T>` and `Result<T, T::Error>` where `T:FromParam`. If you are new to
    Rust, this syntax is for a generic type. T:FromParam means that we can use any
    type `T`, as long as that type implements `FromParam`. For example, we can create
    a `User` struct, implement `FromParam` for `User`, and use `Option<User>` as an
    argument in the function handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write a dynamic segment path, you must use the argument in the handler
    function, or else the code will fail to compile. The code will also fail if the
    argument type does not implement the `FromParam` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the error if we don''t use the argument in the handler function
    by removing `id: u8` from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s write the dynamic segment, which does not implement `FromParam`.
    Define an empty struct and use that as an argument in the handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the compiler output that type `S` must implement the `FromParam`
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: There is another dynamic form in angle brackets but trailed with two full stops
    (`..`), as in `/<dynamic..>`. This dynamic form is called **multiple segments**.
  prefs: []
  type: TYPE_NORMAL
- en: If a regular dynamic segment must implement the `FromParam` trait, multiple
    segments must implement the `rocket::request::FromSegments` trait. Rocket only
    provides `FromSegments` implementations for the Rust standard library `std::path::PathBuf`
    type. `PathBuf` is a type for representing a file path in the operating system.
    This implementation is very useful for serving a static file from the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: You might think serving from a specific path is dangerous because any person
    can try a path traversal such as `"../../../password.txt"`. Fortunately, the `FromSegments`
    implementation for `PathBuf` has already thought about the security problem. As
    a result, access to sensitive paths has been disabled, for example, `".."`, `"."`,
    or `"*"`.
  prefs: []
  type: TYPE_NORMAL
- en: Another segment type is the `<_>` or `<_..>`. If you declare an ignored segment,
    it will not show in the function argument list. You must declare ignored multiple
    segments as the last argument in a path, just like regular multiple segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'An ignored segment is useful if you want to build an HTTP path that matches
    a lot of things, but you don''t want to process it. For example, if you have the
    following lines of code, you can have a website that handles any path. It will
    handle `/`, `/some`, `/1/2/3`, or anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like a path, a query segment can be a static segment or dynamic segment
    (such as `"?<query1>&<query2>"`) or can be in a multiple `"?<query..>` form. The
    multiple query form is called `"?<_>"`, or ignored trailing parameters such as
    `"?<_..>"`.
  prefs: []
  type: TYPE_NORMAL
- en: Neither dynamic queries nor trailing parameters are supposed to implement `FromParam`,
    but both must implement `rocket::form::FromForm` instead. We will discuss implementing
    `FromForm` more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101), *Serving
    Static Assets and Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Rank
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The path and query segments in a URI can be grouped into three **colors**:
    **static**, **partial**, or **wild**. If all segments of the path are static,
    the path is called a static path. If all segments of the query are static, we
    say the query has a static color. If all segments of the path or query are dynamic,
    we call the path or query wild. The partial color is when a path or query has
    both static and dynamic segments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need these colors? They are required to determine the next parameter
    of the route, which is the **rank**. If we have multiple routes handling the same
    path, then Rocket will rank the functions and *start checking from the rank with
    the lowest number*. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see we have two functions handling the same path, but with two different
    function signatures. Since Rust does not support function overloading, we created
    the functions with two different names. Let''s try calling each of the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the application log in the other terminal, we can see how Rocket
    chose the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Try reversing the rank in the source code and think about what would happen
    if you called it with `u8` as the parameter. After that, try requesting the endpoint
    to see whether your guess is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall Rocket''s URI colors. Rocket ranks the colors of both path and
    query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: static path, static query = -12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: static path, partial query = -11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: static path, wild query = -10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: static path, none query = -9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: partial path, static query = -8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: partial path, partial query = -7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: partial path, wild query = -6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: partial path, none query = -5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wild path, static query = -4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wild path, partial query = -3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wild path, wild query = -2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wild path, none query = -1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the path has a lower rank, static is lower than partial, and finally,
    partial is lower than the wild color. Keep this in mind when you create multiple
    routes, as the output might not be what you expect because your route may have
    a lower or higher ranking.
  prefs: []
  type: TYPE_NORMAL
- en: Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another parameter we can use in a route is `format`. In requests with the HTTP
    method with a payload, such as `POST`, `PUT`, `PATCH` and `DELETE`, the HTTP request
    `Content-Type` is checked against the value of this parameter. When handling HTTP
    requests without payloads, such as `GET`, `HEAD`, and `OPTIONS`, Rocket checks
    and matches the route's format with the HTTP requests' `Accept` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example for the `format` parameter. Create a new application
    and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pay attention closely, the format for the `/get` endpoint uses the `"text/plain"`
    IANA (Internet Assigned Numbers Authority) media type, but the format for the
    `/post` endpoint is not the correct IANA media type. This is because Rocket accepts
    the following shorthand and converts them to the correct IANA media type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"any"` → `"*/*"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"binary"` → `"application/octet-stream"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"bytes"` → `"application/octet-stream"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"html"` → `"text/html; charset=utf-8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"plain"` → `"text/html; charset=utf-8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"text"` → `"text/html; charset=utf-8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"json"` → `"application/json"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"msgpack"` → `"application/msgpack"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"form"` → `"application/x-www-form-urlencoded"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"js"` → `"application/javascript"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"css"` → `"text/css; charset=utf-8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"multipart"` → `"multipart/form-data"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"xml"` → `"text/xml; charset=utf-8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"pdf"` → `"application/pdf"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, run the application and call each of the two endpoints to see how they
    behave. First, call the `/get` endpoint with both the correct and incorrect `Accept`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The request with the correct `Accept` header returns the correct response,
    while the request with the incorrect `Accept` header returns `404` but with a
    `"Content-Type: application/json"` response header. Now, send the `POST` requests
    to the `/post` endpoint to see the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Our application outputs the expected response, but the `Content-Type` of the
    response is not what we expected. We will learn how to create a default error
    handler later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `data` parameter in the route is for processing the request body. The data
    must be in a dynamic form such as a dynamic `<something>` URI segment. After that,
    the declared attribute must be included as a parameter in the function following
    the route attribute. For example, look at the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you do not include `data` as a parameter in the function following the route,
    Rust will complain about it at compile time. Try removing the `data` parameters
    in the function signature and try compiling it to see the compiler error output
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about data later when we implement forms and upload files
    to the server. Now that we have learned about Rocket routes, let's make an application
    to implement a route that handles a request.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing route handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will make an application that handles a route. We are reusing the first
    code that we wrote in this chapter. The idea is that we have several user data,
    and we want to send requests that will select and return the selected user data
    according to the ID sent in the request. In this part, we will implement the request
    and selecting part of the route handlers. In the next section, we will learn how
    to create a custom response type. In the subsequent section, we will create a
    handler for when the request does not match any user data we have. And finally,
    in the last section, we will create a default error handler to handle invalid
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by copying the first code into a new folder. After that, in `src/main.rs`,
    add a `User` struct after the `Filter` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: For the `User` struct, we are using `uuid` for object identification. The reason
    is that if we use `usize` or another numeric type as an ID without any authentication,
    we might fall into the **Insecure Direct Object References** (**IDOR**) security
    vulnerability where an unauthorized user can easily guess any number as an ID.
    The UUID as an identifier is harder to guess.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in real-world applications, we should probably create transparent encryption
    for the *name* and *age* as such information can be considered personally identifiable
    information, but let's skip it in this book for the sake of learning.
  prefs: []
  type: TYPE_NORMAL
- en: We also add the `#[derive(Debug)]` attribute on top of the struct. The attribute
    automatically creates an implementation for the struct to be printed using `fmt::Debug`.
    We can then use it in code, such as `format!("{:?}", User)`. One of the requirements
    for the `Debug` attribute is that all type members must implement `Debug` as well;
    however, this is not a problem in our case, as all Rust standard library types
    already implement the `Debug` trait.
  prefs: []
  type: TYPE_NORMAL
- en: As for the next step, we want to store several `User` data in a collection data
    structure. We can store them in a `[User; 5]` array or a growable `std::vec::Vec`
    array type. To find user data inside the array, we can iterate the array or Vec
    one by one until the end or until a match is found, but this is not ideal as it
    is time-consuming for a large array.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, there are better data structures in which we can store
    data and easily find objects by their index, such as a hash map. Rust has many
    libraries that implement various data structures, and a hash map is one of them.
    In the standard library, we can find it in `std::collections::HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides using a standard library, we can use other alternatives, since the Rust
    community has already created a lot of data structure-related libraries. Try searching
    in [https://crates.io](https://crates.io) or [https://lib.rs](https://lib.rs).
    For example, if we are not using the standard library, we can use an alternative
    crate such as `hashbrown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement it in our `src/main.rs` file after the `User` struct declaration.
    Unfortunately, the `HashMap` creation requires heap allocation, so we cannot assign
    `HashMap` to a static variable. Adding the following code will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to assign `HashMap` to a static variable, but the best
    suggestion is to use the `lazy_static!` macro from the `lazy_static` crate, which
    runs the code at runtime and performs heap allocation. Let''s add it to our code.
    First, add `lazy_static` in the `Cargo.toml` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, use and implement it in the code as follows. Feel free to add extra
    users if you want to test it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify `fn user(...)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We want the function to return something when we call it, therefore, we add
    `-> String` in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: '`HashMap` has many methods, such as `insert()` for inserting a new key and
    value, or `keys()`, which returns an iterator for the keys in `HashMap`. We are
    just using `get()`, which returns `std::option::Option`. Remember, `Option` is
    just an enum, which can be `None`, or `Some(T)` if it contains a value. Finally,
    the `match` control flow operator returns a string appropriately depending on
    whether the value is `None` or `Some(u)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we try to send a `GET` request to `http://127.0.0.1:8000/user/3e3dd4ae-3c37-40c6-aa64-7061f284ce28`,
    we can see that it will return the correct response, and if we send a `GET` request
    to `http://127.0.0.1:8000/user/other`, it will return `"User not found"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `users()` function. Let''s recall the original signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Because `u8` already implements `FromParam`, we can just use it as it is. But,
    we want to see how we can implement `FromParam` for a custom type. Let's change
    our use case to have a path such as `"/users/<name_grade>?<filters...>"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a custom `NameGrade` struct. The `''r` annotation means that
    this struct should only live as long as the referenced string in its name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to implement a trait, we have to look at the signature of that trait.
    The Rust compiler requires a type to implement all methods and a type placeholder
    in a trait. We can find the trait definition for `FromParam` from the Rocket API
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type Error: Debug;` is called a type placeholder. Some traits require
    the implementation to have a certain type. Any type that implements this trait
    should use a concrete type, which also has a debug trait. Because we just want
    to show an error message, we can use `&''static str` as the `Error` type for this
    implementation. Then, write the trait implementation signature for `NameGrade`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, add the message that we want to show to the app user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s split the input parameter at the `''_''` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The `name_grade_vec` length will be either `2` or `other`, so we can use `match`
    on it. As `name_grade_vec[0]` is a string, we can use it as it is, but for the
    second member, we have to parse it. And, since the result can be anything, we
    have to use a special syntax that is formed as in `::<Type>`. This syntax is fondly
    called **turbofish** by the Rust community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `Option`, `Result` is just an enum which can either be `Ok(T)` or
    `Err(E)`. If the program successfully parses `u8`, the method can return `Ok(NameGrade{...})`,
    or else the function can return `Err("...")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have implemented `FromParam` for `NameGrade`, we can use `NameGrade`
    as the parameter in the `users()` function. We also want `String` as the return
    type of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, write the routine that filters the `USERS` hash map with
    `name_grade` and `filters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '`HashMap` has the `values()` method, which returns `std::collections::hash_map::Values`.
    `Values` implements `std::iter::Iterator`, so we can filter it using the `filter()`
    method. The `filter()` method accepts a *closure*, which returns Rust bool type.
    The `filter()` method itself returns `std::iter::Filter`, which implements the
    `Iterator` trait. The `Iterator` trait has the `collect()` method, which can be
    used to collect items into the collection. Sometimes, you have to use the `::<Type>`
    turbofish in `collect::<Type>()` if the result type cannot be inferred by the
    compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can convert the collected users into `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, run the application and try calling the `users()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, but the problem with this is that the query parameters are cumbersome;
    we want `Filters` to be optional. Let''s modify the code a little bit. Change
    the signature of `fn users` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be confused by this piece of code: `if let Some(fts) = &filters`.
    It''s one of the destructuring syntaxes in Rust, just like this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented the requests part for these two endpoints, `user()` and
    `users()`, but the return type for those two endpoints is the Rust standard library
    type, `String`. We want to use our own custom type. So, let's see how we can create
    a response from the `User` struct directly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement a custom response for the `User` type. In Rocket, all types
    that implement `rocket::response::Responder` can be used as a return type in a
    function that handles routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the signature of the `Responder` trait. This trait requires
    two lifetimes, `''r` and `''o`. The result `''o` lifetime must at least be equal
    to the `''r` lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we can include the required module to be used for implementing the `Responder`
    trait for the `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the implementation signature for the `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we use `rocket::response::{self...}` instead of `rocket::response::{Result...}`?
    If we return `-> Result`, we cannot use `std::result::Result`, which is a pretty
    ubiquitous type in Rust. Write the following lines in the `respond_to()` method
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The application generates a user `String` from the `User` object, then generates
    `rocket::response::Builder` by calling `Response::build()`. We can set various
    payloads for the `Builder` instance; for example, the `sized_body()` method adds
    the body of the response, `raw_header()` and `header()` add the HTTP header, and
    finally, we generate `response::Result()` using the `finalize()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `sized_body()` method is `Option`, and the parameter
    can be `None`. As a result, the `sized_body()` method requires the second parameter
    to implement the `tokio::io::AsyncRead + tokio::io::AsyncSeek` trait to automatically
    determine the size. Fortunately, we can wrap the body in `std::io::Cursor` as
    Tokio already implements those traits for `Cursor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a common pattern that we can observe when we implement the `std::iter::Iterator`
    trait and `rocket::response::Builder`, called the `Something` instance by chaining
    the command, such as `Something.new().func1().func2()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Let's also modify the `users()` function to return a new `Responder`. We are
    defining a new type, which is commonly known as a **newtype** idiom. This idiom
    is useful if we want to wrap a collection or work around **orphan rules**.
  prefs: []
  type: TYPE_NORMAL
- en: Orphan rules mean neither `type` nor `impl` are in our application or crate.
    For example, we cannot implement `impl Responder for Iterator` in our application.
    The reason is that `Iterator` is defined in the standard library, and `Responder`
    is defined in the Rocket crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the newtype idiom as in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the struct has a `struct NewType(type1, type2, ...)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also call a struct with a nameless field a `(type1, type2, type3)`. We
    then can access the struct's field by its index, such as `self.0`, `self.1`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the newtype definition, add the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Responder` implementation for the `User` type, in the `Responder`
    implementation for `NewUser`, we basically iterate a collection of users again,
    collect them as a String, and build the `response::Result` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s use both the `User` and `NewUser` structs as a response type
    in the `user()` and `users()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've learned how to implement the `Responder` trait for a type, let's
    learn more about the wrappers that Rocket offers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Responder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rocket has two modules that can be used to wrap the returned `Responder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first module is `rocket::response::status`, which has the following structs:
    `Accepted`, `BadRequest`, `Conflict`, `Created`, `Custom`, `Forbidden`, `NoContent`,
    `NotFound`, and `Unauthorized`. All the responders except `Custom` set the status
    just like their corresponding HTTP response code. For example, we can modify the
    previous `user()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Custom` type can be used to wrap a response with other HTTP code not available
    in the other structs. For example, take a look at the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The other module, `rocket::response::content`, has the following structs: `Css`,
    `Custom`, `Html`, `JavaScript`, `Json`, `MsgPack`, `Plain`, and `Xml`. Like the
    `status` module, the `content` module is used to set `Content-Type` of the response.
    For example, we can modify our code to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine both modules as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this using `rocket::http::Status` and `rocket::http::ContentType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you might be wondering how those structs can create HTTP `Status` and
    `Content-Type` and use another `Responder` implementor body. The answer is because
    the `Response` struct has two methods: `join()` and `merge()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume there are two `Response` instances: `original` and `override`.
    The `original.join(override)` method merges the `override` body and status if
    it''s not already present in `original`. The `join()` method also adjoins the
    same headers from `override`.'
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, the `merge()` method replaces the `original` body and status with
    that of `override`, and replaces the `original` header if it exists in `override`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our application to use a default response. This time we want
    to add a new HTTP header, `"X-CUSTOM-ID"`. To do so, implement the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `Responder` implementation for the `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the `Responder` implementation for `NewUser`. But this time,
    we want to add extra values: the `"X-CUSTOM-ID"` header. We can do that using
    the `join()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Try opening the URL for `user` and `users` again; you should see the correct
    `Content-Type` and `X-CUSTOM-ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Built-in implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides `content` and `status` wrappers, Rocket already implemented the `Responder`
    trait for several types to make it easier for developers. The following is a list
    of types already implementing the `Responder` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::option::Option` – We can return `Option<T>` for any type of `T` that
    already implements `Responder`. If the returned variant is `Some(T)`, then `T`
    is returned to the client. We already see the example of this return type in the
    `user()` and `users()` functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::result::Result` – Both variants `T` and `E` in `Result<T, E>` should
    implement `Responder`. For example, we can change our `user()` implementation
    to return `status::NotFound` as in the following lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`&str` and `String` – These types are returned with the text content as the
    response body and `Content-Type "text/plain"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket::fs::NamedFile` – This `Responder` trait automatically returns a file
    specified with `Content-Type` based on the file content. For example, we have
    the `"static/favicon.png"` file and we want to serve it in our application. Take
    a look at the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`rocket::response::Redirect` – `Redirect` is used to return a `redirect` response
    to the client. We will discuss `Redirect` more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101),
    *Serving Static Assets and Templates*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket_dyn_templates::Template` – This responder returns a dynamic template.
    We will discuss templating more in [*Chapter 8*](B16825_08_ePub.xhtml#_idTextAnchor101),
    *Serving Static Assets and Templates*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket::serde::json::Json` – This type makes it easy to return the JSON type.
    To use this responder implementation, you must enable the `"json"` feature in
    `Cargo.toml` as follows: `rocket = {version = "0.5.0-rc.1", features = ["json"]}`.
    We will discuss more about JSON in [*Chapter 11*](B16825_11_ePub.xhtml#_idTextAnchor125),
    *Securing and Adding an API and JSON*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket::response::Flash` – `Flash` is a type of cookie that will be erased
    after a client accesses it. We will learn how to use this type in [*Chapter 11*](B16825_11_ePub.xhtml#_idTextAnchor125),
    *Securing and Adding an API and JSON*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rocket::serde::msgpack::MsgPack` – `"msgpack"` feature in `Cargo.toml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various `stream` responders in the `rocket::response::stream` module – We will
    learn more about these responders in [*Chapter 9*](B16825_09_ePub.xhtml#_idTextAnchor109),
    *Displaying Users' Post*, and [*Chapter 10*](B16825_10_ePub.xhtml#_idTextAnchor118),
    *Uploading and Processing Posts*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already implemented a couple of routes, derived `FromParam`, and created
    types that implemented the `Responder` trait. In the next section, we will learn
    how to make a default error catcher for the same kind of HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: Making default error catchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application should be able to handle an error that may occur anytime during
    processing. In a web application, the standardized way to return an error to a
    client is by using an HTTP status code. Rocket provides a way to handle returning
    errors to clients in the form of `rocket::Catcher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The catcher handler works just like a route handler, with a few exceptions.
    Let''s modify our last application to see how it works. Let''s recall how we implemented
    the `user()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'If we request `GET /user/wrongid`, the application will return an HTTP response
    with code `404`, a `"text/plain"` content type, and a `"User not found"` body.
    Let''s change the function back to the return `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'A function returning `Option` where the variant is `None` will use the default
    `404` error handler. After that, we can implement the default `404` handler as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `#[catch(404)]` attribute above the function. It looks like a route
    directive. We can use any valid HTTP status code between `200` to `599` or `default`.
    If we put `default`, it will be used for any HTTP status code not declared in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Like `route`, the `catch` attribute must be put above a free function. We cannot
    put the `catch` attribute above a method inside the `impl` block. Also like the
    route handling function, the catcher function must return a type that implements
    `Responder`.
  prefs: []
  type: TYPE_NORMAL
- en: The function handling an error can have zero, one, or two parameters. If the
    function has one parameter, the parameter type must be `&rocket::Request`. If
    the function has two parameters, the first parameter type must be `rocket::http::Status`
    and the second parameter must be `&Request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the catcher function connects to Rocket is a little bit different.
    Where we use `mount()` and the `routes!` macro for the route handling functions,
    we use `register()` and the `catchers!` macro for catcher functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we tell a route handling function to use a catcher? Let''s say a catcher
    has been defined and registered as in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then return `rocket::http::Status` directly on the route handling function.
    The status will then be forwarded to any registered catcher or Rocket built-in
    catcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Try calling the `GET` request to this endpoint and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: The application returns the string from the `403` default handler and the correct
    HTTP status is also returned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored one of the most important parts of the Rocket framework.
    We learned about a route and its parts such as HTTP methods, URIs, path, query,
    rank, and data. We also implemented a couple of routes and various types related
    to routes in an application. After that, we explored ways to create responder
    types and learned about various wrappers and types already implemented in the
    `Responder` trait. Finally, we learned how to create a catcher and connect it
    to a Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about other Rocket components such as states
    and fairings. We will learn the initialization process of a Rocket application,
    and how we can use those states and fairings to create more modern and complex
    applications.
  prefs: []
  type: TYPE_NORMAL
