["```rs\n├── Cargo.toml\n├── docker-compose.yml\n└── src\n    ├── main.rs\n    └── tasks\n        ├── add.rs\n        ├── mod.rs\n        ├── multiply.rs\n        └── subtract.rs\n```", "```rs\n[dependencies]\nbincode = \"1.0\"\nbytes = \"1.2.1\"\nredis = \"0.22.1\"\nserde_json = \"1.0.86\"\ntokio = { version = \"1\", features = [\"full\"] }\nhyper = { version = \"0.14.20\", features = [\"full\"] }\nserde = { version = \"1.0.136\", features = [\"derive\"] }\n```", "```rs\nuse hyper::{Body, Request, Response, Server};\nuse hyper::body;\nuse hyper::service::{make_service_fn, service_fn};\nuse std::net::SocketAddr;\nuse std::env;\nuse serde::{Serialize, Deserialize};\nuse serde_json;\nuse bytes::{BufMut, BytesMut};\n```", "```rs\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IncomingBody {\n    pub one: String,\n    pub two: i32\n}\n```", "```rs\nasync fn handle(req: Request<Body>) -> \n    Result<Response<Body>, &'static str> {\n    let bytes = body::to_bytes(req.into_body()).await\n                                               .unwrap();\n    let response_body: IncomingBody = \n        serde_json::from_slice(&bytes).unwrap();\n    let mut buf = BytesMut::new().writer();\n    serde_json::to_writer(&mut buf, \n                          &response_body).unwrap();\n    Ok(Response::new(Body::from(buf.into_inner().freeze())))\n}\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let app_type = env::var(\"APP_TYPE\").unwrap();\n    match app_type.as_str() {\n        \"server\" => {\n            . . .\n        },\n        \"worker\" => {\n            println!(\"worker not defined yet\");\n        }\n        _ => {\n            panic!(\"{} app type not supported\", app_type);\n        }\n    }\n}\n```", "```rs\nlet addr = SocketAddr::from(([0, 0, 0, 0], 3000));\nlet server = Server::bind(&addr).serve(make_service_fn( |_conn| {\n    async {\n        Ok::<_, hyper::Error>(service_fn( move |req| {\n            async {handle(req).await}\n        }))\n    }\n}));\nif let Err(e) = server.await {\n    eprintln!(\"server error: {}\", e);\n}\n```", "```rs\nAPP_TYPE=server cargo run\n```", "```rs\nuse std::{thread, time};\n```", "```rs\nmatch app_type.as_str() {\n    \"server\" => {\n        . . .\n    },\n    \"worker\" => {\n      // worker code is going to be inserted here\n        . . .\n    }\n    _ => {\n        panic!(\"{} app type not supported\", app_type);\n    }\n}\n```", "```rs\nlet client = \n    redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nloop {\n    . . .\n}\n```", "```rs\nlet body = IncomingBody{one: \"one\".to_owned(), two: 2};\nlet bytes = bincode::serialize(&body).unwrap();\n```", "```rs\nlet outcome: Option<Vec<u8>>;\n{\n    let mut con = client.get_connection().unwrap();\n    let _ : () = redis::cmd(\"LPUSH\").arg(\"some_queue\")\n                                    .arg(bytes.clone())\n                                    .query(&mut con)\n                                    .unwrap();\n    // pop our task from the queue\n    outcome = redis::cmd(\"LPOP\").arg(\"some_queue\")\n                                .query(&mut con)\n                                .unwrap();\n}\n```", "```rs\nmatch outcome {\n    Some(data) => {\n        . . .\n    },\n    None => {\n        . . .\n    }\n}\n```", "```rs\nlet deserialized_struct: IncomingBody = \n    bincode::deserialize(&data).unwrap();\nprintln!(\"{:?}\", deserialized_struct);\n```", "```rs\nlet five_seconds = time::Duration::from_secs(5);\ntokio::time::sleep(five_seconds).await;\n```", "```rs\nversion: \"3.7\"\nservices:\n    redis:\n      container_name: 'queue-redis'\n      image: 'redis'\n      ports:\n        - '6379:6379'\n```", "```rs\nexport APP_TYPE=worker\n```", "```rs\ncargo run\n```", "```rs\nIncomingBody { one: \"one\", two: 2 }\nIncomingBody { one: \"one\", two: 2 }\nIncomingBody { one: \"one\", two: 2 }\nIncomingBody { one: \"one\", two: 2 }\n. . .\n```", "```rs\nuse std::{thread, time};\nuse serde::{Serialize, Deserialize};\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AddTask {\n    pub one: i32,\n    pub two: i32\n}\nimpl AddTask {\n    pub fn run(self) -> i32 {\n        let duration = time::Duration::from_secs(20);\n        thread::sleep(duration);\n        return self.one + self.two\n    }\n}\n```", "```rs\nimpl MultiplyTask {\n    pub fn run(self) -> i32 {\n        let duration = time::Duration::from_secs(20);\n        thread::sleep(duration);\n        return self.one * self.two\n    }\n}\n```", "```rs\nimpl SubtractTask {\n    pub fn run(self) -> i32 {\n        let duration = time::Duration::from_secs(20);\n        thread::sleep(duration);\n        return self.one - self.two\n    }\n}\n```", "```rs\npub mod add;\npub mod multiply;\npub mod subtract;\n```", "```rs\nmod tasks;\nuse tasks::{\n    add::AddTask, \n    subtract::SubtractTask, \n    multiply::MultiplyTask\n};\n```", "```rs\nlet body = AddTask{one: 1, two: 2};\n```", "```rs\nlet deserialized_struct: AddTask = \n    bincode::deserialize(&data).unwrap();\nprintln!(\"{:?}\", deserialized_struct.run());\n```", "```rs\n3\n```", "```rs\nuse serde::{Serialize, Deserialize};\n```", "```rs\n#[derive(Debug, Clone, Serialize, Deserialize)]\nuse add::AddTask;\nuse multiply::MultiplyTask;\nuse subtract::SubtractTask;\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum TaskType {\n    ADD(AddTask),\n    MULTIPLY(MultiplyTask),\n    SUBTRACT(SubtractTask)\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskMessage {\n    pub task: TaskType\n}\n```", "```rs\nmod tasks;\nuse tasks::{\n    add::AddTask, \n    TaskType, \n    TaskMessage\n};\n```", "```rs\nlet body = AddTask{one: 1, two: 2};\nlet message = TaskMessage{task: TaskType::ADD(body)};\nlet serialized_message = bincode::serialize(&message).unwrap();\n```", "```rs\nlet mut con = client.get_connection().unwrap();\nlet _ : () = redis::cmd(\"LPUSH\").arg(\"some_queue\")\n                                .arg(serialized_message\n                                .clone())\n                                .query(&mut con).unwrap();\n```", "```rs\nlet outcome: Option<Vec<u8>> = \n    redis::cmd(\"RPOP\").arg(\"some_queue\").query(&mut con)\n    .unwrap();\nstd::mem::drop(con);\n```", "```rs\nlet deserialized_message: TaskMessage = \n    bincode::deserialize(&data).unwrap();\nmatch deserialized_message.task {\n    TaskType::ADD(task) => {\n        println!(\"{:?}\", task.run());\n    },\n    TaskType::MULTIPLY(task) => {\n        println!(\"{:?}\", task.run());\n    },\n    TaskType::SUBTRACT(task) => {\n        println!(\"{:?}\", task.run());\n    }\n}\n```", "```rs\nuse hyper::body;\nuse hyper::http::StatusCode;\n```", "```rs\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IncomingBody {\n    pub one: i32,\n    pub two: i32\n}\n```", "```rs\nlet client = \n    redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nlet task_type = req.uri().to_string().replace(\"/\", \"\")\"\");\nlet body_bytes = \n    body::to_bytes(req.into_body()).await.unwrap();\nlet body: IncomingBody = \n    _json::from_slice(&body_bytes).unwrap();\n```", "```rs\nlet message_type: TaskType;\nmatch task_type.as_str() {\n    \"add\" => {\n        let body = AddTask{one: body.one, \n                           two: body.two};\n        message_type = TaskType::ADD(body);\n    },\n    \"multiply\" => {\n        let body = MultiplyTask{one: body.one, \n                                two: body.two};\n        message_type = TaskType::MULTIPLY(body);\n    },\n    \"subtract\" => {\n        let body = SubtractTask{one: body.one, \n                                two: body.two};\n        message_type = TaskType::SUBTRACT(body);\n    },\n    _ => {\n        . . .\n    }\n}\n```", "```rs\nlet response = \n    Response::builder().status(StatusCode::NOT_FOUND)\n    .body(Body::from(\"task not found\"));\nreturn Ok(response.unwrap())\n```", "```rs\nlet message = TaskMessage{task_type: message_type, \n    task: bytes};\nlet serialized_message = \n    bincode::serialize(&message).unwrap();\n```", "```rs\nlet mut con = client.get_connection().unwrap();\nlet _ : () = redis::cmd(\"LPUSH\").arg(\"some_queue\")\n                                .arg(serialized_message\n                                .clone())\n                                .query(&mut con).unwrap();\n```", "```rs\nOk(Response::new(Body::from(\"task sent\")))\n```", "```rs\nlet client = \n    redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nloop {\n    let outcome: Option<Vec<u8>> = {\n        let mut con = client.get_connection()\n                            .unwrap();\n        redis::cmd(\"RPOP\").arg(\"some_queue\")\n                          .query(&mut con)\n                          .unwrap()\n    };\n    match outcome {\n        . . .\n    }\n}\n```", "```rs\nFROM rust:1.62.1 as build\nENV PKG_CONFIG_ALLOW_CROSS=1\nWORKDIR /app\nCOPY . .\ncargo build --release \nFROM gcr.io/distroless/cc-debian10\nCOPY --from=build /app/target/release/task_queue \n/usr/local/bin/task_queue\nEXPOSE 3000\nENTRYPOINT [\"task_queue\"]\n```", "```rs\n./target\n.github\n```", "```rs\nversion: \"3.7\"\nservices:\n    server_1:\n        . . .\n    worker_1:\n        . . .\n    worker_2:\n        . . .\n    worker_3:\n        . . .\n    redis:\n      container_name: 'queue-redis'\n      image: 'redis'\n      ports:\n        - '6379:6379'\n```", "```rs\nserver_1:\n    container_name: server_1\n    image: server_1\n    build: \n      context: .\n    environment:\n      - 'APP_TYPE=server'\n      - 'REDIS_URL=redis://redis:6379'\n    depends_on:\n        redis:\n          condition: service_started\n    restart: on-failure\n    ports:\n    - \"3000:3000\"\n    expose:\n      - 3000\n```", "```rs\nworker_1:\n    container_name: worker_1\n    image: worker_1\n    build: \n      context: .\n    environment:\n      - 'APP_TYPE=worker'\n      - 'REDIS_URL=redis://redis:'\n    depends_on:\n        redis:\n          condition: service_started\n    restart: on-failure\n```", "```rs\nlet client = \n    redis::Client::open(env::var(\"REDIS_URL\").unwrap())\n    .unwrap();\n```", "```rs\n. . .\nqueue-redis  | 1:M 30 Oct 2022 18:42:52.334 * \nRDB memory usage when created 0.85 Mb\nqueue-redis  | 1:M 30 Oct 2022 18:42:52.334 * \nDone loading RDB, keys loaded: 0, keys expired: 0.\nqueue-redis  | 1:M 30 Oct 2022 18:42:52.334 * \nDB loaded from disk: 0.002 seconds\nqueue-redis  | 1:M 30 Oct 2022 18:42:52.334 * \nReady to accept connections\nworker_1     | empty queue\nworker_3     | empty queue\nworker_1     | empty queue\nworker_3     | empty queue\nworker_2     | multiply: 9\nworker_3     | multiply: 25\nworker_1     | multiply: 8\nworker_3     | empty queue\nworker_3     | empty queue\nworker_2     | multiply: 4\nworker_2     | empty queue\n. . .\n```"]