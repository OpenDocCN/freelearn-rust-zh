["```rs\nfn my_function() \n{ \n    let mypi = 3.14f32; \n} \n```", "```rs\nfn my_second_function() \n{ \n    let myvec = vec![1.1f32, 2.2f32, 3.14f32]; \n} \n```", "```rs\nlet myvar = 10i32; \n```", "```rs\nconst int myvar = 32; \n```", "```rs\nlet myvec = vec![1i32, 2i32, 3i32]; \nlet myothervec = myvec; \n```", "```rs\nfn transfer_vec(v: Vec<i32>)  \n{ \n    println!(\"v[0] in transfer_vec = {}\", v[0]); \n} \n\nfn main()  \n{ \n    let myvec = vec![1i32, 2i32, 3i32];  \n    transfer_vec(myvec);  \n    println!(\"myvec[0] is: {}\", myvec[0]); \n} \n```", "```rs\nlet myvar = 32i32; \n```", "```rs\nlet myvartwo = myvar; \n```", "```rs\nlet vectwo = myvec; \n```", "```rs\nvar myList = new List<int>{1,2,3,4,5,6}; \nvar dupVar = myList; \ndupVar.Remove(4); // 4 \nforeach(var n in myList) \n    Console.WriteLine(n); \n```", "```rs\nfn do_something(number: i32) -> i32  \n{ \n    number + 32 \n} \n\nfn main()  \n{ \n    let num = 10i32;  \n    let numtwo = do_something(num);  \n    println!(\"num is: {}\", num); \n    println!(\"numtwo is : {}\", numtwo); \n} \n```", "```rs\nfn sumprod(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) \n{ \n    let sum = v1.iter().fold(0i32, |a, &b| a + b); \n    let product = v2.iter().fold(1i32, |a, &b| a * b); \n    return (v1, v2, sum + product); // return ownership \n} \n\nfn main()  \n{ \n    let vecone = vec![2,3,5]; \n    let vectwo = vec![3,5];  \n    let (vecone, vectwo, ans) = sumprod(vecone, vectwo); // pass ownership  \n    println!(\"ans = {}\", ans); \n} \n```", "```rs\nfn sumprod(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 \n{ \n    let sum = v1.iter().fold(0i32, |a, &b| a + b); \n    let product = v2.iter().fold(1i32, |a, &b| a * b); \n    return sum + product;  \n} \n\nfn main()  \n{ \n    let vecone = vec![2,3,5]; \n    let vectwo = vec![3,5];  \n    let ans = sumprod(&vecone, &vectwo);  \n    println!(\"ans = {}\", ans); \n} \n```", "```rs\nfn main()  \n{ \n    let mut mutvar = 5; \n    { \n        println!(\"{}\", mutvar); // outputs 5 \n        let y = &mut mutvar; // creates the mutable ref to mutvar \n        *y += 1; // adds one to the reference and passes it back in to mutvar \n    } \n    println!(\"{}\", mutvar); // outputs 6 \n} \n```", "```rs\nlet mut mutvar = 5; \nlet y = &mut mutvar;  \n*y += 1;  \nprintln!(\"{}\", mutvar); \n```", "```rs\nfn main()  \n{ \n    let mut mutvar = 5; \n    { \n        println!(\"{}\", mutvar); // outputs 5 \n        let y = &mut mutvar; // creates mutable reference to mutvar \n        *y += 1; // adds 1 and passes result back in to mutvar \n    } \n    println!(\"{}\", mutvar); // outputs 6 \n} \n```", "```rs\nfn main()  \n{ \n    let mut myvec = vec![5i32, 10i32, 15i32, 20i32, 25i32, 30i32]; \n\n    for i in &myvec \n    { \n        println!(\"i = {}\", i); \n        myvec.push(35i32);  \n    } \n} \n```", "```rs\nlet varname: &f32; \n{ \n    let x = 3.14f32; \n    varname = &x; \n} \nprintln!(\"varname = {}\", varname); \n```", "```rs\nlet y: &f32; \n{ \n    let x_squared = x * x; \n    let x_cube = x_squared * x; \n    y = &(x_cube + x_squared + x); \n}; \nprintln!(\"Y = {}\", *y); \n```", "```rs\nfn myfunction(pi: &f32) \n{ \n    // do something \n} \n```", "```rs\nfn expfunction<'a>(pi: &'a f32) \n{ \n    // do something \n} \n```", "```rs\nstruct MyStruct \n{ \n    a: i32, \n    b: f32, \n    c: bool, \n} \n```", "```rs\nstruct<'a> MyStruct \n{ \n    lifetimevar: &'a f32, \n    nvar: i32, \n} \n```", "```rs\nfn mylifetime<'a>(life: &'a i32, universe: &'a i32) -> &'a i32 \n{ \n     // do something, return an i32 value \n} \n```", "```rs\nfn mymultilife<'a, 'b>(foo: &'a f32, bar: &'b i32) \n{ \n    // do something \n} \n```", "```rs\nstruct MyStruct<'a> { \n    lifea: &'a i32, \n} \n\nfn main()  \n{ \n    let x;  \n    {   \n        let y = &5; // means let y = 5; let y = &y; \n        let f = MyStruct { lifea: y };  \n        x = &f.lifea  \n    }  \n    println!(\"{}\", x);  \n} \n```", "```rs\nlet version: &'static str = \"v1.3, 22nd May 2016\";  \n```", "```rs\nlet version = \"v1.3, 22nd May 2016\"; \n```", "```rs\nfn inponlyfn<'a>(inp: &'a as i32) {...} \n```", "```rs\nfn outonlyfn<'a>() -> &'a as i32 {...} \n```", "```rs\nfn inandout<'a>(inp: &'a str) -> &'a str {...} \n```"]