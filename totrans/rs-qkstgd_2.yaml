- en: Basics of the Rust Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, we're ready to actually begin writing some Rust code. In this chapter,
    we're going to look at how Rust programs are structured, and how an assortment
    of common programming elements are expressed in the language. We'll start with
    functions and modules, then move on to fundamental language features, such as
    branching, looping, and data structures. Almost everything we're covering in this
    chapter has an equivalent in most other programming languages; these are the fundamentals
    of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, this chapter describes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions, which are somewhat like miniature programs that are part of the larger
    program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules, which are used to organize the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions, which are how we tell the program to actually do specific things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching, which is how we tell the program to make a decision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping, which is how we tell the program to perform extended actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures, which is how we organize information for the program to process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching functions to structures or other data types, to make them more useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a couple of functions, in passing, in the last chapter when we looked
    at the automatically generated boilerplate code created by `cargo new`. What were
    we actually seeing, though?
  prefs: []
  type: TYPE_NORMAL
- en: A **function** is a sequence of instructions for the computer to follow. It's
    sort of like a recipe. We don't have to tell a person how much flour, sugar, and
    milk to use to bake cookies, if we know that they already have a cookie recipe.
    We can just say: *Bake some cookies, please*. It's similar with a function. We
    don't have to tell the computer exactly how to save some information to a database;
    if there's a `save_to_database` function, we can use it to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, instructions that can tell the computer to take action can *only* be
    written inside of functions. It all starts with a function called `main`, which
    can cause other functions to run, which can in turn cause yet more functions to
    run, and so on. Using our recipe analogy again, it's like a pie recipe saying: *Use
    the recipe on page 57 to make dough for the crust*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, a function starts off with the `fn` keyword. A keyword is a sequence
    of letters or symbols which has a fixed meaning in the language. Nothing we do
    in our program can change the meaning of a keyword, and the libraries we use can't
    change the meaning either. Keywords occasionally have different meaning in clearly
    different contexts, but they always mean the same thing when used in the same
    way. Keywords are the solid foundation that everything else is built on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `fn` keyword is used to tell the Rust compiler that we''re about to
    tell it about a new function. After that, separated by a space, comes the function''s
    name. There are rules for what the function name can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It must be made up of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: English letters (the letters `A` through `Z`, in their lowercase or CAPITAL
    forms)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arabic numerals (the digits `0` through `9`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscores(`_`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can't start with a number (so `7samurai` is not a valid name)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it starts with an underscore, it must have at least one further character
    (`_` by itself has a special meaning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then comes an open parenthesis `(` and a close parenthesis `)`, with a list
    of parameters between them. We're going to gloss over the parameter list for now
    and come back to that later. There doesn't have to be anything between the parenthesis
    if the function does not need parameters, and that's how we'll do it for now.
  prefs: []
  type: TYPE_NORMAL
- en: After the close parenthesis of the parameter list, we can optionally include
    a `→` symbol followed by a return type, another thing which we'll go into in more
    detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes a `{` symbol, which tells Rust that we're about to begin a sequence
    of commands, followed by as many commands as we need in order to tell Rust how
    to do what we want the function to do, and then finally a `}` symbol to mark the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the boilerplate code, Let''s take a look at the automatically
    generated `main` function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the `fn` keyword, function name, and empty parameter list.
    The optional return type has been omitted. Then, between the `{` and `}`, we see
    a single instruction, which tells the computer that we want it to print out Hello,
    world! whenever we tell it to run the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's not a lot more to say about functions until we have some understanding
    of what kinds of instructions we can give the computer, between those `{` and
    `}` symbols. The main idea is that we can bundle up many instructions into a function,
    and then use a single instruction elsewhere in the program to tell the computer
    *to do all that stuff*.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules give us a way to organize our functions (and other items that have names,
    such as data structures) into categories. This helps us keep things organized,
    and allows us to use the same name more than once, as long as we only use it once
    per module. It also lets us use shorter versions of a thing's name most of the
    time, but gives us a longer version we can use when those short names might be
    confusing or ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining a module is easy. In any `.rs` file which the compiler is going to
    be looking at, we can use the `mod` keyword to start a new module. There are two
    different ways to use that keyword, though, depending on whether we want to define
    the module as a section of the current file or as a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: A module as a section of a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a module as a section of a file, we use the `mod` keyword followed
    by a name and then a `{` symbol, then the contents of the module, and then a `}`
    symbol to finish it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we define a new module containing a couple of functions, it would look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've created a module named `module_a` and put the `a_thing` and `a_second_thing`
    functions inside of it. We haven't seen it previously, but the line in `a_second_thing`
    that says `a_thing();` is an instruction to the computer to run the `a_thing`
    function. So, when `a_second_thing` runs, the first thing it does is run `a_thing`,
    and then it prints out its own message afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: The `pub` keyword means that `module_a` is part of the public interface of the
    current module, rather than just being internal data. We'll talk more about that
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: A module as a separate file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More often than not, we''re going to want to give our modules their own files.
    It''s just nicer to keep things separated and contained as much as possible, because
    it helps keep the code manageable. Fortunately, this is just as easy. In our `.rs`
    file, we can just write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That looks a lot like the previous example, except that it doesn''t have the
    module contents right there between `{` and `}`. Instead, the Rust compiler goes
    looking for a file called either `module_b.rs` or `module_b/mod.rs`, and uses
    the whole file as the contents of the `module_b` module. So, if the file contains
    a couple of functions similar to the ones we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then `module_b` will contain two functions named `a_thing` and `a_second_thing`.
    It's not a problem that those functions have the same names as functions in the
    `module_a` module from before, because they're in a different module.
  prefs: []
  type: TYPE_NORMAL
- en: Why did the compiler look in two places for the source code of `module_b`? This
    allows us to be more flexible in how we lay out our directory structure for our
    program's source code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing module contents from outside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *A module as a section of a file* section, the `a_second_thing` function
    is part of the same module as `a_thing`, so it's automatically allowed to use
    the short version of the other function's name to refer to it. However, code outside
    of the module needs to use the full name to refer to items inside the module.
    There are two ways this can be done. It can either be done directly, which is
    a good choice if we don't expect to be referring to the item often, or we can
    tell Rust that we want to use the short name for an item in a different module,
    which is a good choice if we're going to be using that item often in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the item's full name directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An item's full name consists of the module name, a `::` symbol, and then the
    item's short name. If we have several layers of modules that we need to get through
    before we find the item we want, we list those modules' names in order, with a
    `::` between each name. For example, we might refer to `std::path::Path` to get
    the `Path` item from the `path` module of the `std` module.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the full name anywhere and be completely unambiguous as to what item
    we're talking about.
  prefs: []
  type: TYPE_NORMAL
- en: Using the item's short name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use the `use` keyword to tell Rust that we want to refer to an item
    in a different module by its short name. This is done by just writing `use` followed
    by the full name of the item we want to use. For example, `use std::path::Path;`
    allows us to use just the short name for that item (`Path` in this example) in
    the following instructions, until we come to the `}` that closes the section of
    code where our `use` keyword was written (or we come to the end of the module
    file, which amounts to the same thing).
  prefs: []
  type: TYPE_NORMAL
- en: We can use the same syntax to tell Rust that we want to use the name of a module,
    rather than an item in a module. For example, `std::path` is a valid command.
    That would allow us to use `path::Path` as the name of the `Path` item in subsequent
    code. This is frequently convenient, since it still keeps the external items boxed
    up and separate, while providing reasonably short and informative names to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private module items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many of the preceding examples, we saw a `pub` keyword. That keyword makes
    the item it's attached to *public*, meaning that it is available to code that
    is not part of the same module. If we omit the `pub` keyword on an item, that
    item is `private`, meaning that it can only be accessed within the module where
    it is defined. Private is the default, so we need to explicitly mark those items
    that we want to have as part of the module's externally accessible interface as
    public by using the `pub` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Making an item private is not a security mechanism. If you're worried that your
    code will be linked with hostile code that might misuse your code or data, making
    the code or data private will not protect against such attacks. Rather, the distinction
    between public and private exists in order to help us make it plain which parts
    of the code are *intended* for use outside of the current module, and which are
    meant to be used only internally. This helps us maintain our software, because
    we are free to make whatever changes we want to to private items, whereas with
    public items, we have to be careful that our changes do not break external things
    we might not even be aware exist.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The instructions that tell the computer to do something in a Rust program are
    almost all expressions. An expression tells the computer how to compute a particular
    value, and produces that value as its result. In math, *2 + 2* is an expression
    with a resulting value of 4\. Similarly, *(2 + 2) - 1* is an expression with a
    resulting value of 3, which is itself made up of an addition expression and a
    subtraction expression. In Rust, the same basic idea applies: expressions tell
    the computer how to find a value, and they can be combined together, because using
    an expression that produces a value has the same result as using that value directly,
    just as writing (2 + 2) - 1 has the same result as writing 4 - 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all expressions in Rust look like math, though. Rust is a programming language,
    not just a calculator. It's the idea of expressions, which combine values to produce
    new values, that matters.
  prefs: []
  type: TYPE_NORMAL
- en: Literal expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest of Rust's expressions are the ones where we just write out the
    representation of the value we want. For example, when Rust sees `2` it knows
    we are asking it for the number `2`. Similarly, when Rust sees `"Hello, world!"`
    it knows we're asking it to produce the sequence of letters that spells out *Hello,
    world!*
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust recognizes the following literal expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoted text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Unicode points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers can be written as integers or decimal numbers or in engineering notation,
    and there are a few variants for quoted text and byte sequences, too. Boolean
    values are written as either `true` or `false`. In this book, we're not going
    to need any of the variants of quoted text, and we won't need byte sequences at
    all, so we won't go into those in more detail. See [https://doc.rust-lang.org/](https://doc.rust-lang.org/)
    if you're curious.
  prefs: []
  type: TYPE_NORMAL
- en: Operator expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, like math, Rust has a number of symbolic **operators** that can be applied
    to values to transform them into some new value. For example, `+` is a Rust operator
    that adds two values together. So, `2 + 2` is a Rust expression adding the number
    2 to itself, producing the number 4\. Rust also uses `-` as the subtraction operator,
    `*` as the multiplication operator, `/` as the division operator, and `%` as the
    remainder operator.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is not limited to mathematical operators, though. In Rust, `&` means *and*,
    `|` means *or*, `^` means *exclusive or*, `!` means *not* (`!true` is `false`,
    for example), `<<` means *leftward bit shift*, and `>>` means *rightward bit shift*.
    Sometimes the meanings of those operations depends on the type of value that they're
    acting on. For example, `|` means *bitwise or* when applied to integers, but *logical
    or* when applied to Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are the comparison operators. The `==` operator means *check whether
    two values are equal*. An expression built around the `==` operator produces the
    Boolean value `true` if the two values being compared are equal, and `false` if
    they are not. So, for example, `5 == 4` is an expression producing `false` as
    its result. Similarly, `!=` means *not equal*, `>` means *greater than*, `<` means
    *less than*, `>=` means *greater than or equal*, and `<=` means *less than or
    equal*. All of them produce `true` when the relationship is correct, and `false`
    when it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Rust recognizes `&&` and `||` operators. These can only be applied
    to Boolean (`true` or `false`) values, and produce the same results as `&` and
    `|` do when applied to the same values. The difference is that `&&` and `||` are
    what is called *lazy* or *short-circuit* operators, which means that they will
    not bother evaluating their right-side operand if the left-side operand provides
    enough information to determine the operator's produced value. For example, for
    the expression `false && some_expensive_calculation()`, Rust will never bother
    to run the `some_expensive_calculation` function, because no matter what the function
    produced as its result, the result of the `&&` operation is going to be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations where we'd use `&` or `|` on Boolean values, we should use
    `&&` or `||` instead, since it allows Rust to be a little more efficient, especially
    if we're mindful enough to put the more expensive operations on the right side
    of the operator.
  prefs: []
  type: TYPE_NORMAL
- en: These are not a full list of Rust's operators, and we'll see some of the more
    specialized ones as we move onward through the language. These are the operators
    we need for expressing the majority of calculations, computations, and decisions
    in our programs, though.
  prefs: []
  type: TYPE_NORMAL
- en: Array and tuple expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **array** is a sequential collection of data values. There are many ways
    to use and manipulate them, but here we're interested in the specialized expressions
    that create them and access their internal data values. To tell Rust that we want
    to create a new array, all we have to do is write a `[` symbol, and then a comma-separated
    list of expressions that produce the values we want to store in the array, and
    then a `]` symbol. There doesn't have to be anything between the beginning and
    ending symbols if we want an empty array. So, we can write `[]` as an expression
    producing an empty array, or `[1, 3, 5]` as an expression producing an array containing
    three numbers. All of the values stored in an array need to have the same data
    type—integers in this case—so trying to set the second element to a text string
    such as `"nope"` would produce a compiler error when we tried to compile the program.
  prefs: []
  type: TYPE_NORMAL
- en: That's really nice for cases where we need to create a short array, but imagine
    writing out an expression for an array containing a thousand values! We wouldn't
    want to write them out one by one. Fortunately, we can instead do something like
    `[0; 1000]`, which produces an array containing a thousand zero values. Some other
    part of our code can then fill in different values in those slots.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an array value, we often need access to the values stored inside
    it. That too is achieved using the `[` and `]` symbols. If we have an array named
    `an_array` (we'll see how to give values names in the *Variables, types, and mutability*
    section of this chapter), we can access the first value in the array as `an_array[0]`,
    the second value as `an_array[1]`, and so on. Notice that the first value is numbered
    with `0`, while the second is `1`. Many programming languages count this way,
    because it simplifies some of the math that they frequently need to do with respect
    to arrays and other sequences of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to arrays, Rust allows us to make **tuples**. The expression to
    create a tuple is similar to that for arrays: `(1, "wow", true)` is a tuple containing
    the number value `1`, the text value `wow`, and the Boolean `true`. If we have
    a tuple named `a_tuple`, then `a_tuple.1` produces the second value in the tuple,
    in this case the word `wow`. There''s no simplified way to create a tuple containing
    a thousand duplicates, though, because that''s not what they''re for. Unlike arrays,
    a single tuple can contain values of more than one value type, and they are intended
    to serve as lightweight data structures, rather than as a collection of many similar
    data values.'
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, the contents of a tuple cannot be changed. That's not how
    it works in Rust, though, where tuples follow the same rules for that sort of
    thing as any other data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to make a tuple with only one contained value (which is not common,
    because the whole point of a tuple is to associate multiple values together),
    we need to include a comma after the value. So, a single-element tuple containing
    the number 5 looks like this: `(5,)`'
  prefs: []
  type: TYPE_NORMAL
- en: Block expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the necessary steps to figure out an expression's result value just
    don't fit into a single expression of the sorts we've looked at before. Maybe
    they need to store a data value for a little while in order to execute efficiently,
    or are otherwise too complex to be reasonably written in the *1 + ((2 * 57) /
    13)* style.
  prefs: []
  type: TYPE_NORMAL
- en: That's where block expressions come in. Block expressions look a lot like the
    body of a function because the body of a function *is* a block expression. They
    start with `{` and end with `}`. Between those two markers, we can write whatever
    instructions we need, including doing things like defining variables or other
    named items.
  prefs: []
  type: TYPE_NORMAL
- en: At the very end of the block should come the expression that produces the final
    result value of the block. So, for example, the block expression `{ 2 + 2; 19
    % 3; println!("In a block"); true}` is a (kind of silly) block expression that
    produces the Boolean `true` as its result, but not until after it has calculated
    that 2 plus 2 equals 4, and calculated that the remainder of 19 over 3 is 1, and
    printed out *In a block* to the console.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the Rust compiler will warn us about that block expression, because
    it calculates two values and then just discards them. That's wasteful, so Rust
    points it out. If optimizations are enabled, the compiler will actually skip generating
    code to calculate the values at all, but that's an optimization, and the program
    and compiler are still supposed to act as if they did perform the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the semicolons (`;`) in the block expression. Every top-level instruction
    in the block has a semicolon after it, *except the last one*. That's because the
    semicolon tells Rust that the expression before it should be treated as a **statement**,
    which basically means that it won't produce a value, or if it does, we don't care
    what that value is. In some cases, the semicolon can be left off of expressions
    prior to the last one in a block, but I don't recommend it, because explicitly
    discarding the results of expressions whose results we're not going to use allows
    the compiler more freedom to make inferences and optimizations, and can help avoid
    some fairly obscure compiler errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put a `;` after the final expression in a block, we''re saying that the
    block doesn''t have a meaningful resulting value at all. In that case, it ends
    up having `()` as its resulting value. That''s an empty tuple, which is a pretty
    good way of saying: *Nothing to see here, folks*. `()` is used that way throughout
    the Rust language and libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Branch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the things that makes programs truly useful is the ability for them
    to make decisions. We can do that in Rust by using an `if` expression. An `if`
    expression looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you're familiar with other programming languages, you might be wondering
    where the parenthesis are around the condition expression. Rust's syntax doesn't
    call for parenthesis there. In fact, if we place the condition in parenthesis,
    the compiler will warn us that they're not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What we have here is an expression that shows off all the features of an `if`.
    It starts off with the keyword `if`, followed by a *condition expression* that
    produces either `true` or `false`, and then a block expression. If the condition
    expression produces `true`, the block expression is run, but if the condition
    expression produces `false`, the block expression is not run.
  prefs: []
  type: TYPE_NORMAL
- en: Using `3 > 4` as our condition expression is not very useful. We might as well
    just write `false`, or leave that block expression out entirely since it will
    never run. However, in real code, we would use a condition expression whose result
    we would not know at the time we were writing the code. *Is it between the hours
    of 8 A.M. and 5 P.M.*, *Did the user select this value from the menu*, and *Does
    the value match what is stored in the database* are examples of more realistic
    conditions, though of course they would have to be expressed in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we have an `else if` and another condition expression and block.
    That means that, if the first condition expression produced `false`, the computer
    should check whether the second one produces `true`, and if it does, run the associated
    block expression.
  prefs: []
  type: TYPE_NORMAL
- en: We can chain as many `else if` expressions as we want after an initial `if`,
    so there's no limit to the number of different options we can make available to
    the computer. However, only one of them will run after any given decision. The
    computer will start with the initial `if` and check the values of the conditional
    expressions one at a time until it finds one that produces `true`, then it will
    run the associated block expression, and then it will be done with the if expression
    and move on to the subsequent instructions.
  prefs: []
  type: TYPE_NORMAL
- en: After an `if` and any `else if` we might wish to include, we are allowed to
    put an `else` followed by a block expression. This is a branch without a condition,
    and what it means is *if none of the condition expressions produced* `true`, *do
    this*. In other words, it allows us to tell the computer what to do by default,
    if none of the special cases we provided apply.
  prefs: []
  type: TYPE_NORMAL
- en: Loop expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another of the basic abilities that make programs useful is looping. Rust has
    several different kinds of loops, but we''re going to look at two of them here:
    `while` loops and `for` loops.'
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `while` loop is a lot like an `if` expression. The difference is, instead
    of checking the condition expression once and then either running the block expression
    or not, and then being done, a `while` loop keeps repeating the process until
    the condition expression produces `false`. So, if the condition expression results
    in `false` right away, the block expression never runs. On the other hand, if
    the condition expression produces `true` on the first check, the block expression
    gets run, and then the condition expression is evaluated again. If it produces
    `true` again, the block runs again, and so on, until the condition expression
    finally produces `false`.
  prefs: []
  type: TYPE_NORMAL
- en: That means that it's very important for the block expression to change something
    that affects the condition expression's result. If the condition expression produces
    `true` and the block doesn't have any chance of changing that, the program will
    be stuck looping through that block over and over until the program is forcefully
    terminated. This is the easiest way to cause your program to freeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s a simple `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We're using a variable named `i` here, which we'll talk about more in the *Variables
    and mutability* section of this chapter. For now, just think of `i` as a name
    that we can assign different values to at different times, sort of like how we
    can ask different people to sit in the same chair at different times.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have the `while` keyword followed by a condition expression. This condition
    expression uses a variable, which we change the value of in the block expression,
    so we''re not in danger of looping forever. If `i` starts with the value `0`,
    we should see the block expression run three times: once when `i` is `0`, once
    when `i` is `1`, and once when `i` is `2`. When `i` gets to `3`, the condition
    expression produces `false` as its result (3 is not less than 3), and the loop
    stops.'
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, `while` loops are exactly what we need, but the two most common needs
    for looping are to loop a specific number of times or to use a loop to process
    each element contained in an array or similar data structure. In both of these
    cases, `for` loops work better.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop runs its block expression once for each value produced by an **iterator**.
    An iterator is a special kind of data value that has the job of returning a sequence
    of values, one at a time. An iterator for an array, for example, produces a different
    member of the array each time we ask it for a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To loop a specific number of times, we can use a `for` loop along with a **range
    expression**, which is an expression that produces an iterator over a sequence
    of numbers. Let''s look at a concrete example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We started off with the `for` keyword and then `num`, which is the name which
    is going to be given to each value that the iterator produces, one at a time,
    as those values are processed by the `for` loop. Then comes another keyword, `in`.
    Finally, the expression that produces our iterator. In this case, we have a range
    expression, which represents the values `3`, `4`, `5`, and `6`. Notice that `7`
    is not included in the range. As with counting from zero, this makes some of the
    math easier for the computer to do, and in this case, it makes things easier for
    us most of the time as well. If we want to loop seven times, we could just write
    `0..7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a variant we could use that would include the final number in the
    output, should we need it: `3..=7`. Just remember that if you loop through `0..=7`,
    you''re going to be running the block expression eight times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other time when `for` loops shine is when we have a collection of actual
    values that we want to process, as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This loop prints out each of the words in the array, each on their own line. The
    `word` name is set to the first value produced by the iterator, `"Hello"`, and
    the block expression is run. Then `word` is set to the second value produced by
    the iterator, `"world"`, and the block expression is run again. This continues
    until the iterator runs out of values to produce, and then stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, our iterator is producing the values stored in an array. The `.iter()`
    part of that expression is saying, basically: *Arrays know how to make iterators
    for themselves, so ask the array to give us an iterator*. We''ll see more about
    how to implement functions that are specific to a data type in a later chapter,
    but for now, we just need to know that that''s what the `.` symbol means: the
    thing on the right of the dot is specific to the thing on the left. We are asking
    the computer to run, not just any `iter` function, but the `iter` function that
    is associated with our array.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables, types, and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable is a named box in which a data value can be stored. The variable
    itself isn't the data value, just like a carton of milk is not the same thing
    as milk (it's waxed cardboard and such *containing* milk).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if somebody needs milk and you hand them a full milk carton,
    they're not going to complain, and the same goes for Rust. If a Rust expression
    needs an integer, and we provide a variable containing an integer, Rust will be
    perfectly happy with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are most often created using the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let x = 10;`'
  prefs: []
  type: TYPE_NORMAL
- en: This statement creates a variable called `x` containing the `10` value in it.
    Once that's done, we can refer to `x` as part of the expressions. For example,
    `x + 5` is now a valid expression, with a resulting value of `15`.
  prefs: []
  type: TYPE_NORMAL
- en: The names that `for` loops use are also variables, as are function parameters,
    although they are not created with the `let` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to having a name, variables are characterized by the type of value
    they can store. Each variable can store one kind of value, and can never store
    any other type of information. Rust can often figure out what type of information
    a given variable can store, but we always have the option of being explicit about
    it. If we tell Rust that `let x: i32 = 99;`then Rust will make sure that the `x`
    variable can store a 32-bit signed integer and report an error if we try to store
    something else there. On the other hand, `let x: f64 = 999.0;`tells Rust that
    we want `x` to store a 64-bit floating-point number and that trying to store anything
    else there is an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have to provide an initial value for a variable. For example, we
    could say `let x: u16;`to tell Rust that the `x` variable needs to be able to
    store 16-bit unsigned integers. That''s fine. However, if it''s even possible
    that some of our code will try to use the contents of the variable without first
    having stored some contents there to be used, the Rust compiler will consider
    that an error. It''s usually easier to just provide a starting value when we create
    a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables are called **variables** because the values they contain can be changed.
    Except in Rust, by default, they can't. Rust allows us to use multiple `let` statements
    to create new variables with the same names as old variables, but we can't just
    assign a new value to an existing variable, unless that variable is **mutable**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new variable with the same name as an existing variable is called **shadowing** the
    old variable. A shadowed variable still contains the value it did before, but
    cannot be accessed by name any more, because that name now belongs to a different
    variable. If there are any references to the old variable still in play, they
    will still be accessing the old variable, though, not the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being mutable just means that the variable will accept changes, up to and including
    a whole new value. We use the `mut` keyword to tell Rust that a variable should
    be mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let mut x = 17;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `x` variable is mutable. That means we can modify its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x = 0;`'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of containing `17`, `x` now contains `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equal symbol (`=`) that we''re using for variables is not a statement of
    mathematical equality. It doesn''t mean: *These two things are defined as being
    the same*. Instead it means: *Right here, right now, the value produced by the
    expression on the right side of the* `=` *is to be stored in the variable on the
    left*. This would be nonsense in math, but it makes perfect sense in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Rust has quite a lot of built-in data types. We've seen `i32`, `f64`, and `u16`,
    which are 32-bit signed integer, 64-bit floating point, and 16-bit unsigned integer,
    respectively. There are also more types following the same pattern, such as `u64`
    for an unsigned 64-bit integer, as well as types such as `bool` for Boolean values;
    `isize` and `usize` for signed and unsigned integers that take up the same number
    of bits as a memory address on the target architecture; and `char` and `str` for
    single Unicode code points and sequences of them.
  prefs: []
  type: TYPE_NORMAL
- en: These are known as primitive types, because they're inherent to the language.
    However, Rust also allows us to create new types, and so the Rust standard library
    contains many more data types that are suited to various specific uses, and there
    are even more available in third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we noticed earlier, we can specify the type of a variable, but we often
    don''t have to. That''s because Rust has a feature called type inference, which
    often lets it figure out what type a variable is by looking at what we do with
    it. For example, if we were using the Tokio networking library, we might use code
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We didn't specify what type the `addr` variable should have. Even more interesting,
    we didn't tell the text address what kind of information we needed it to parse
    into.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parsing** means *transforming a representation into usable data*, approximately.
    Lots of things can be represented as a string of text, if you know how to parse
    that text into the information you really want.'
  prefs: []
  type: TYPE_NORMAL
- en: The question marks in this example are part of Rust's error handling mechanism,
    and the ampersand is an operator that affects how the `addr` variable is shared
    with the function. We'll see more on both of those soon.
  prefs: []
  type: TYPE_NORMAL
- en: However, Rust can see that we're passing the `addr` variable (or rather, a reference
    to it, but more on that in the next chapter) as a parameter of the `TcpListener::bind`
    function, and it knows that that function needs a reference to a `SocketAddr`,
    so `addr` must be a `SocketAddr`. Then, since it has figured out that `addr` is
    a `SocketAddr`, it takes it a step further and determines that it should use the
    string parsing function that produces a `SocketAddr` as its resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference can save an amazing amount of time in a language as strict as
    Rust. On the other hand, it can be surprising if you see an error message about
    a data type you've never heard of, because Rust decided that it was the one you
    needed. If that happens, try assigning the type you actually expect to your variable
    and see what the Rust compiler has to say afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a data structure is one of the ways to add a new data type to Rust.
    A data structure is a group of variables that have been attached to each other,
    resulting in a single new data type that means *all of these, together*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new structure is defined using the `struct` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice the commas after each contained variable is defined. It can be tempting
    to use semicolons there, but that would cause a compiler error. The final comma
    is optional, but recommended, because it means that the lines can be rearranged
    without having to pay attention to where a comma might be missing, among other
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've defined a structure called `Constrained`, which is made up of three
    different 32-bit unsigned integer variables. The structure itself is public, meaning
    that it can be used outside of the module where it's defined.
  prefs: []
  type: TYPE_NORMAL
- en: The `min` and `max` contained variables are also public, but that means something
    slightly different. It means that anywhere we have a `Constrained` value, we can
    access the `min` and `max` contained values directly. The `current` value, on
    the other hand, is private, which means that it can be directly accessed only
    within the module where the structure is defined. We can define functions in that
    module with the express purpose of accessing the data contained in private structure
    members, but the members themselves are not part of the structure's public interface,
    even if the structure itself is public.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access `min` and `max`, we can use the same `.` symbol that we''ve seen
    previously in a few places. So, if `cons` is a mutable `Constrained` value, then
    we can do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Mutability of data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot use the `mut` keyword to make the contained values within a structure
    mutable, and leaving the keyword off does not make them immutable. Instead, the
    entire structure is mutable or immutable on a case-by-case basis. See the following,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means that there are two variables, both with `Constrained`
    as their data type, but the value stored in `change_no` is immutable while the
    value stored in `change_yes` is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: More about functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're going to fill in the blanks left in the earlier discussion of functions
    by talking about parameters and return types.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters allow us to provide information to a function at the time when we
    ask it to run.
  prefs: []
  type: TYPE_NORMAL
- en: Asking a function to run is called *calling* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define a function, we can tell it the variable names and types we want
    it to use for receiving parameters, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll talk about `self` in the *Implementing behavior for types* section of
    this chapter. For now, ignore it and take a look at `value`. Here, we've provided
    a name and data type, just as we would if we were using `let` to create a new
    variable. What we have not done is provide a value for the `value` variable, because
    that happens when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen function calls all along, but for the sake of clarity, they look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In that example, `some_function` is the name of a function, and the values that
    are assigned to its parameters are the results of the expressions `2 + 2` and
    `false`. The parameter expressions are evaluated *before* the function is called,
    so the actual values of the parameters are the number `4` and the Boolean, `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Return types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling a function is an expression, which means it produces a resulting value.
    We''ve been ignoring that until now. If a function is going to produce a resulting
    value, we have to tell the compiler what data type that result will have. We do
    that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's a longish example, but for now we're focusing on the first line. After
    the function parameters, we see `->  i32`. That tells Rust that the `get` function
    has `i32` as the data type of its result. Once it knows that, the compiler will
    make sure that it's true. In this example, there's no path through the function
    that doesn't produce an `i32` value, so the compiler is happy with it.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `return` keyword in that example. A `return` statement stops
    the currently running function (meaning that any instructions that would have
    run after the `return` statement do not in fact get run) and provides the resulting
    value for the function call expression. In this example, if the current value
    is less than the minimum value, the minimum value is returned. If the current
    value is greater than the maximum value, the maximum value is returned. Otherwise,
    the current value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that in Rust, function bodies are block expressions, and `if`
    along with its riders is also an expression, which means they all produce a resulting
    value naturally, even when we don''t use the `return` keyword. That means that
    we could have written the example function this way and gotten the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the difference? Before, we used `return` to specifically terminate
    the function and provide a resulting value. Here, the resulting value of the function's
    block expression is the resulting value of the `if` expression, which is the resulting
    value of the block expression for whichever branch it follows, which is either
    `self.min`, `self.max` or `self.current`. The end result is the same, but it's
    expressed differently.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we can anticipate the possibility that something could go wrong,
    or we're using a library function that knows it might not succeed. When that happens,
    we'll find ourselves using the special `Result` data type. The result is a **generic
    type**, which we'll talk about in a later chapter, but it's so integral to using
    functions that we're going to see how to use it here in a rote way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that can fail will have a return type something like this: `Result<i32, &''static str>`.
    This looks kind of nuts at first glance, I admit. Let''s break it down. The type
    starts off with `Result` followed by a `<`, then `i32`, then a `,`, then `&''static
    str`, and finally a `>`. What that means is that the function will produce an
    `i32` if it succeeds, and an `&''static str` if it fails. `&''static str` happens
    to be the type for a literal text expression, like `oops, it broke`, so what we''re
    really saying here is that the function will return an integer or an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: It's common to have a data type specifically for representing errors, such as
    an `Error` structure, rather than just using a textual error message.
  prefs: []
  type: TYPE_NORMAL
- en: Using Result to signal success or failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expanding on our example, how do we write a function that can either succeed
    or fail? See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we set up the return type to use `Result`, then, in the body of the function,
    we use either `Ok()` or `Err()` to signal that we're returning a valid value or
    an error, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function might fail, but doesn''t have any meaningful return value if
    it succeeds, we can use `()` as the successful return type. So, in that case the
    return type might look like this: `Result<(), &''static str>`. The successful
    return value would be `Ok(())`.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions that return Result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call a function that returns `Result`, the return value is—as requested—a `Result`,
    rather than the data type we really need. There are several ways of working with
    that, depending on our specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to deal with a `Result` is to use the `?` operator, which
    extracts the stored value from a successful `Result`, or returns a `Result` containing
    the error value if the `Result` it''s looking at indicates an error. Because `?`
    might return from the current function in the same way that a `return` statement
    would, `?` can only be used in functions that themselves return `Result` and use
    the same data type to represent errors. Using `?` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're calling the `new_constrained` function, which returns either a successful
    result or an error message. However, the variable we're assigning to has `Constrained`
    as its type, not `Result`. That works because of the `?` at the end, which pulls
    out the `Constrained` value if the function call succeeds, and returns if the
    function call fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next easiest way to deal with a returned `Result` is to use the `expect`
    function. This function does something similar to the `?`, pulling out the success
    value if Result indicates success, but it handles failure differently. Instead
    of returning an error from the current function, `expect` terminates the whole
    program and prints out an error message. Functions that use `expect` don''t have
    to return a `Result`, so it can be used in some situations where `?` is unavailable.
    Using `expect` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The parameter passed to `expect` is the error message it should display on failure.
    There are some other functions, similar to `expect`, that handle errors in various
    ways, such as calling an error handler function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can actually handle the errors ourselves, by checking whether the
    returned `Result` is an `Ok` or an `Err`. That is done by using the `match` or
    `if let` expressions, which we will learn about in [Chapter 4](700c26ca-e1de-4069-afaf-d9acb22dd6ab.xhtml), the
    *Making Decisions by Pattern Matching*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behavior for types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous examples, we''ve seen what appeared to be calls to functions that
    were contained within data values, such as `"127.0.0.1:12345".parse()` or `["Hello",
    "world", "of", "loops"].iter()`. Those are functions that have been **implemented**
    on the type of those values. Implementing functions on a type looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is an implementation block (which is *not* a block expression) for a data
    type, in this case the `Constrained` type that we created earlier. Implementation
    blocks are introduced with the `impl` keyword, then they have the name of the
    type that we want to place our functions *inside of*, and then the functions we
    want to add to the data type, between the `{` and `}` symbols.
  prefs: []
  type: TYPE_NORMAL
- en: While we can access functions that were implemented on a type as if they were
    variables contained in data values of that type, they're not actually stored within
    the memory holding the data value. There's no need for each data value to have
    copies of the functions, since the copies would all be identical anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Functions implemented on a type can be public or private, depending on whether
    we want them to be used by external users of the data type, or only by other functions
    within the current module.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is implemented on a type, the first parameter is special. It's
    automatically provided to the function, even though it is not passed as a function
    parameter when we call the function. This automatic parameter is traditionally
    called `self`. It is the job of `self` to give the function access to the data
    value that it is being called through, meaning that if we do something like `"127.0.0.1".parse()`,
    the parse function receives `"127.0.0.1"` as its `self` parameter. The `self`
    parameter can be written as `self`, `&self`, or `&mut self`, a choice that we'll
    discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of an implementation block allows us to specify which data type we're
    implementing functions on. Could we implement functions on types we didn't create,
    such as `i32` or `SocketAddr`? The answer is yes, but only if we create a *trait*.
    We'll see more about traits in [Chapter 5](6c390ac8-f3c8-495d-a97a-29426925531a.xhtml), *One
    data Type Representing Multiple Kinds of Data*. Without using traits, we're only
    able to implement functions on data types we created within the same project,
    although they do not have to be in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we put the things we've learned in this chapter into practice, our grasp
    on them will solidify. We've learned about the basic structure of Rust programs,
    as well as how to write functions, loops, and branches. In addition, we've learned
    about Rust's type system and how to attach behavior to a data type. These things
    give us a foundation to build on, while we learn about the things that make Rust
    truly different from other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to look at how the fundamental Rust concepts
    of ownership and borrowing work.
  prefs: []
  type: TYPE_NORMAL
