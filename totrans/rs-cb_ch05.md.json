["```rs\n        //-- #########################\n        //-- Task: Passing values to a thread in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        use std::thread;\n\n```", "```rs\n        fn main() { \n          let x = 1;  let handle = thread::spawn(move || {(x)}); \n\n          println!(\"{:?}\", handle.join().unwrap()); \n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Passing values to a thread in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        use std::thread;\n\n```", "```rs\n        fn main() {\n          thread::spawn(move || {\n          println!(\"Hello from spawned thread\");\n          });\n\n          let join_handle = thread::spawn(move || {\n          println!(\"Hello from second spawned thread\");\n          17\n          });\n\n          println!(\"Hello from the main thread\");\n\n          match join_handle.join() {\n            Ok(x) => println!(\"Second spawned thread returned {}\", x),\n            Err(_) => println!(\"Second spawned thread panicked\")\n          }\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Spawning 10 threads in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Using the standard thread crate\n        use std::thread;\n\n        // static value NO_THREADS\n        static NO_THREADS: i32 = 10;\n\n```", "```rs\n        // Main thread starts here\n        fn main() {\n          // Make a mutable vector named thread_holder to hold the\n          threads spawned\n          let mut thread_holder = vec![];\n\n          for i in 0..NO_THREADS {\n            // Spin up another thread\n            thread_holder.push(thread::spawn(move || {\n            println!(\"Thread number is {}\", i);\n            i\n            }));\n          }\n\n        println!(\"***************************\");\n\n        for thread_elements in thread_holder {\n          // Wait for the thread to finish. Returns a result.\n          println!(\"Thread returned {:?}\",\n          thread_elements.join().unwrap()); \n        }\n      }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Using channels to perform safe pass of data between\n        threads\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Using standard libraries\n        use std::sync::mpsc::{Sender, Receiver};\n        use std::sync::mpsc;\n        use std::thread;\n\n```", "```rs\n        // Declaring number of threads\n        static NO_THREADS: i32 = 3;\n\n```", "```rs\n        // Main thread starts\n        fn main() {\n          // Creating endpoints of the channel\n          let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();\n\n```", "```rs\n        for thread_no in 0..NO_THREADS {\n          // Cloing the Sender\n          let thread_tx = tx.clone();\n\n          // Sending threads via the channel\n          thread::spawn(move || {\n          // thread sends the message to the channel\n          thread_tx.send(thread_no).unwrap();\n          println!(\"thread {} finished\", thread_id);\n          });\n        }\n\n```", "```rs\n        // Collecting all the threads\n        let mut thread_holder = Vec::with_capacity(NO_THREADS as\n        usize);\n        for i in 0..NO_THREADS {\n        // Get the message from channel\n        thread_holder.push(rx.recv());\n        }\n\n        // Print the execution order\n        println!(\"{:?}\", thread_holder);\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Safe Mutable access across threads for preventing\n        data races\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Call the standard library\n        use std::sync::{Arc, Mutex};\n        use std::thread;\n        use std::time::Duration;\n\n```", "```rs\n        // Main thread\n        fn main() {\n        // Declaring a Arc type data\n        let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n\n```", "```rs\n        // Creating 3 threads and implementing lock\n        for i in 0..3 {\n          let data = data.clone();\n          thread::spawn(move || {\n          let mut data = data.lock().unwrap();\n          data[0] += i;\n          println!(\"Thread id :{:?}\",i );\n          println!(\"Data value :{:?}\", data[0]);\n          });\n        }\n\n        thread::sleep(Duration::from_millis(10));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: To call a child process\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Call the standard library\n        use std::process::Command;\n\n```", "```rs\n        // Main execution of the code\n        fn main() {\n          // Command to be executed\n          let output = Command::new(\"rustc\")\n          .arg(\"--version\")\n          .output().unwrap_or_else(|e| {\n          panic!(\"failed to execute process: {}\", e)\n          });\n\n```", "```rs\n        // printing the output values\n        if output.status.success() {\n          let s = String::from_utf8_lossy(&output.stdout);\n\n          print!(\"rustc succeeded and stdout was:n{}\", s);\n        } \n        else {\n          let s = String::from_utf8_lossy(&output.stderr);\n\n          print!(\"rustc failed and stderr was:n{}\", s);\n        }\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Waiting for a child process\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Calling the standard libraries\n        use std::process::Command;\n\n```", "```rs\n        // Main execution starts here\n        fn main() {\n          // Creating a child process\n          let mut child =\n          Command::new(\"sleep\").arg(\"5\").spawn().unwrap();\n\n```", "```rs\n        // Waiting for the child process to complete\n        let _result = child.wait().unwrap();\n\n        // printing the status of child process\n        print!(\"Status if child process {} \\n\", _result);\n        // Marking the end of the main function \n        println!(\"reached end of main\");\n        }\n\n```", "```rs\n cargo new sample_rayon --bin\n\n```", "```rs\n cd sample_rayon/ && tree .\n\n```", "```rs\n nano Cargo.toml\n\n```", "```rs\n cargo build\n\n```", "```rs\n ls && tree .\n\n```", "```rs\n        //-- #########################\n        //-- Task: Making sequential code parallel\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 19 March 17\n        //-- #########################\n\n```", "```rs\n        // Calling the rayon crate\n        extern crate rayon;\n        use rayon::prelude::*;\n\n```", "```rs\n        // Sum of squares function\n        fn sum_of_squares(input: &[i32]) -> i32 {\n          input.par_iter()\n          .map(|&i| i * i)\n          .sum()\n        }\n\n```", "```rs\n        // Main execution of code\n        fn main() {\n          // Declaring a random variable of 10\n          let rand_val = 10;\n          // Calling the method to get sum_of_squares\n          let sum_sq = sum_of_squares(&[rand_val]);\n          // Printing the result\n          println!(\"Sum of squares of {0} is {1}\",rand_val,sum_sq);\n        }\n\n```"]