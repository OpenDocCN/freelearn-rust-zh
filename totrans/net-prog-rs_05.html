<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Application Layer Protocols</h1>
                
            
            
                
<p class="calibre2">As we saw in the previous few chapters, two hosts in a network exchange bytes, either in a stream or in discrete packets. It is often up to a higher-level application to process those bytes to something that makes sense to the application. These applications define a new layer of protocol over the transport layer, often called application layer protocols. In this chapter, we will look into some of those protocols.</p>
<p class="calibre2">There are a number of important considerations for designing application layer protocols. An implementation needs to know at least the following details:</p>
<ul class="calibre7">
<li class="calibre8">Is the communication broadcast or point-to-point? In the first case, the underlying transport protocol must be UDP. In the second case, it can be either TCP or UDP.</li>
<li class="calibre8">Does the protocol need a reliable transport? If yes, TCP is the only option. Otherwise, UDP might be suitable, too.</li>
<li class="calibre8">Does the application need a byte stream (TCP), or can it work on packet-by-packet basis (UDP)?</li>
<li class="calibre8">What signals the end of input between the parties?</li>
<li class="calibre8">What is the data format and encoding used?</li>
</ul>
<p class="calibre2">Some very commonly used application layer protocols are DNS (which we studied in the previous chapters) and HTTP (which we will study in a subsequent chapter). Other than these, a very important application layer toolset commonly used for microservice-based architectures is gRPC. Another application layer protocol everyone has used at least a few times is SMTP, the protocol that powers email.</p>
<p class="calibre2">In this chapter, we will study the following topics:</p>
<ul class="calibre7">
<li class="calibre8">How RPC works. Specifically, we will look at gRPC and write a small server and client using the toolkit.</li>
<li class="calibre8">We will take a look at a crate caller <kbd class="calibre11">lettre</kbd> that can be used to send emails programmatically.</li>
<li class="calibre8">The last topic will be on writing a simple FTP client and a TFTP server in Rust.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction to RPC</h1>
                
            
            
                
<p class="calibre2">In regular programming, it is often useful to encapsulate frequently used logic in a function so that it can be reused in multiple places. With the rise of networked and distributed systems, it became necessary to let a common set of operations be accessible over a network, so that validated clients can call them. This is often called a <strong class="calibre1">Remote Procedure Call</strong> (<strong class="calibre1">RPC</strong>). In <a href="part0053.html#1IHDQ0-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 4</a><em class="calibre16">,</em> <em class="calibre16">Data Serialization, De-Serialization, and Parsing</em>, we saw a simple example of this when a server returned the distance of a given point from the origin. Real world RPC has a number of application layer protocols defined, which are far more complex. One of the most popular RPC implementations is gRPC, which was initially introduced by Google and later moved to an open source model. gRPC offers high performance RPC over internet scale networks and is widely used in a number of projects, including Kubernetes.</p>
<p class="calibre2">Before digging deeper into gRPC, let's look at protocol buffers, a related tool. It is a set of mechanisms to build language and platform neutral exchanging structured data between applications. It defines its own <strong class="calibre1">Interface Definition Language</strong> (<strong class="calibre1">IDL</strong>) to describe the data format, and a compiler that can take that format and generate code to convert to and from it. The IDL also allows for defining abstract services: input and output message formats that the compiler can use to generate stubs in a given language. We will see an example of a definition of a data format in a subsequent example. The compiler has plugins to generate output code in a large number of languages, including Rust. In our example, we will use such a plugin in a build script to autogenerate Rust modules. Now, gRPC uses protocol buffers to define the underlying data and messages. Messages are exchanged over HTTP/2 on top of TCP/IP. This mode of communication is often faster in practice, since it can make better use of existing connections, and also since HTTP/2 supports bidirectional asynchronous connections. gRPC, being an opinionated system, makes a lot of assumptions about the considerations we discussed in the previous section, on our behalf. Most of these defaults (like HTTP/2 over TCP) were chosen because they support the advanced features gRPC offers (like bidirectional streaming). Some other defaults, like using <kbd class="calibre11">protobuf</kbd>, can be swapped for another message format implementation.</p>
<p class="calibre2">For our gRPC example, we will build a service that is a lot like Uber. It has a central server where clients (cabs) can record their names and locations. And then, when a user requests a cab with their location, the server sends back a list of cabs near that user. Ideally, this server should have two classes of clients, one for cabs and one for users. But for simplicity's sake, we will assume that we have only one type of client.</p>
<p class="calibre2">Let us start with setting up the project. Like always, we will use Cargo CLI to initialize the project:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin grpc_example</strong>
protoc-rust-grpc</kbd> crate. Hence, we will need to add that as a build dependency:</pre>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "grpc_example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>protobuf = "1.4.1"<br class="title-page-name"/>grpc = "0.2.1"<br class="title-page-name"/>tls-api = "0.1.8"<br class="title-page-name"/><br class="title-page-name"/>[build-dependencies]<br class="title-page-name"/>protoc-rust-grpc = "0.2.1"</pre>
<p class="calibre2">The following script is our build script. It is simply a Rust executable (which has a main function) that Cargo builds and runs right before calling the compiler on the given project. Note that the default name for this script is <kbd class="calibre11">build.rs</kbd>, and it must be located in the project root. However, these parameters can be configured in the Cargo config file:</p>
<pre class="calibre17">// ch5/grpc/build.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate protoc_rust_grpc;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    protoc_rust_grpc::run(protoc_rust_grpc::Args {<br class="title-page-name"/>        out_dir: "src",<br class="title-page-name"/>        includes: &amp;[],<br class="title-page-name"/>        input: &amp;["foobar.proto"],</pre>
<pre class="calibre17">        rust_protobuf: true,<br class="title-page-name"/>    }).expect("Failed to generate Rust src");<br class="title-page-name"/>}</pre>
<p>One of the most common use cases for build scripts is code generation (like our current project). They can also be used to find and configure native libraries on the host, and so on.</p>
<p class="calibre2">In the script, we use the <kbd class="calibre11">protoc_rust_grpc</kbd> crate to generate Rust modules from our <kbd class="calibre11">proto</kbd> file (called <kbd class="calibre11">foobar.proto</kbd>). We also set the <kbd class="calibre11">rust_protobuf</kbd> flag to make it generate protobuf messages. Note that the <kbd class="calibre11">protoc</kbd> binary must be available in <kbd class="calibre11">$PATH</kbd> for this to work. This is a part of the protobuf package. Follow these steps to install it from the source:</p>
<ol class="calibre13">
<li value="1" class="calibre8">Download the pre-built binaries from GitHub:</li>
</ol>
<pre class="mce-root"><strong class="calibre1">$ curl -Lo https://github.com/google/protobuf/releases/download/v3.5.1/protoc-3.5.1-linux-x86_64.zip</strong></pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre8">Unzip the archive:</li>
</ol>
<pre class="mce-root"><strong class="calibre1">$ unzip protoc-3.5.1-linux-x86_64.zip -d protoc3</strong></pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Copy the binary to somewhere in <kbd class="calibre11">$PATH</kbd>:</li>
</ol>
<pre class="mce-root"><strong class="calibre1">$ sudo mv protoc3/bin/* /usr/local/bin/</strong></pre>
<p>This current example has been tested on Ubuntu 16.04 with protoc version 3.5.1.</p>
<p class="calibre2">Next, we will need the protocol definition, as shown in the following code snippet:</p>
<pre class="calibre17">// ch5/grpc/foobar.proto<br class="title-page-name"/><br class="title-page-name"/>syntax = "proto3";<br class="title-page-name"/><br class="title-page-name"/>package foobar;<br class="title-page-name"/><br class="title-page-name"/>// Top level gRPC service with two RPC calls<br class="title-page-name"/>service FooBarService {<br class="title-page-name"/>    rpc record_cab_location(CabLocationRequest) returns<br class="title-page-name"/>    (CabLocationResponse);<br class="title-page-name"/>    rpc get_cabs(GetCabRequest) returns (GetCabResponse);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A request to record location of a cab<br class="title-page-name"/>// Name: unique name for a cab<br class="title-page-name"/>// Location: current location of the given cab<br class="title-page-name"/>message CabLocationRequest {<br class="title-page-name"/>    string name = 1;<br class="title-page-name"/>    Location location = 2;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A response for a CabLocationRequest<br class="title-page-name"/>// Accepted: a boolean indicating if this<br class="title-page-name"/>// request was accepted for processing<br class="title-page-name"/>message CabLocationResponse {<br class="title-page-name"/>    bool accepted = 1;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A request to return cabs at a given location<br class="title-page-name"/>// Location: a given location<br class="title-page-name"/>message GetCabRequest {<br class="title-page-name"/>    Location location = 1;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A response for GetCabLocation<br class="title-page-name"/>// Cabs: list of cabs around the given location<br class="title-page-name"/>message GetCabResponse {<br class="title-page-name"/>    repeated Cab cabs = 1;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Message that the CabLocationRequest passes<br class="title-page-name"/>// to the server<br class="title-page-name"/>message Cab {<br class="title-page-name"/>    string name = 1;<br class="title-page-name"/>    Location location = 2;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Message with the location of a cab<br class="title-page-name"/>message Location {<br class="title-page-name"/>    float latitude = 1;<br class="title-page-name"/>    float longitude = 2;<br class="title-page-name"/>}</pre>
<p class="calibre2">The proto file starts with a declaration of the version of protobuf IDP spec; we will be using version 3. The package declaration indicates that all the generated code will be placed in a Rust module called <kbd class="calibre11">foobar</kbd>, and all other generated code will be placed in a module called <kbd class="calibre11">foobar_grpc</kbd>. We define a service called <kbd class="calibre11">FooBarService</kbd> that has two RPC functions; <kbd class="calibre11">record_cab_location</kbd> records the location of a cab, given its name and location, and <kbd class="calibre11">get_cabs</kbd> returns a set of cabs, given a location. We will also need to define all associated <kbd class="calibre11">protobuf</kbd> messages for each of the requests and responses. The spec also defines a number of built-in data types that closely correspond to those in a programming language (string, float, and so on). </p>
<p class="calibre2">Having set up everything related to the <kbd class="calibre11">protobuf</kbd> message formats and functions, we can use Cargo to generate actual Rust code. The generated code will be located in the <kbd class="calibre11">src</kbd> directory and will be called <kbd class="calibre11">foobar.rs</kbd> and <kbd class="calibre11">foobar_grpc.rs</kbd>. These names are automatically assigned by the compiler. The <kbd class="calibre11">lib.rs</kbd> file should re-export those using the pub mod syntax. Note that Cargo build will not modify the <kbd class="calibre11">lib.rs</kbd> file for us; that needs to be done by hand. Let us move on to our server and client. Here is what the server will look:</p>
<pre class="calibre17">// ch5/grpc/src/bin/server.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate grpc_example;<br class="title-page-name"/>extern crate grpc;<br class="title-page-name"/>extern crate protobuf;<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/><br class="title-page-name"/>use grpc_example::foobar_grpc::*;<br class="title-page-name"/>use grpc_example::foobar::*;<br class="title-page-name"/><br class="title-page-name"/>struct FooBarServer;<br class="title-page-name"/><br class="title-page-name"/>// Implementation of RPC functions<br class="title-page-name"/>    impl FooBarService for FooBarServer {<br class="title-page-name"/>    fn record_cab_location(&amp;self,<br class="title-page-name"/>                       _m: grpc::RequestOptions,<br class="title-page-name"/>                       req: CabLocationRequest)<br class="title-page-name"/>                       -&gt;<br class="title-page-name"/>        grpc::SingleResponse&lt;CabLocationResponse&gt; {<br class="title-page-name"/>        let mut r = CabLocationResponse::new();<br class="title-page-name"/><br class="title-page-name"/>        println!("Recorded cab {} at {}, {}", req.get_name(),<br class="title-page-name"/>        req.get_location().latitude, req.get_location().longitude);<br class="title-page-name"/><br class="title-page-name"/>        r.set_accepted(true);<br class="title-page-name"/>        grpc::SingleResponse::completed(r)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fn get_cabs(&amp;self,<br class="title-page-name"/>                      _m: grpc::RequestOptions,<br class="title-page-name"/>                      _req: GetCabRequest)<br class="title-page-name"/>                      -&gt; grpc::SingleResponse&lt;GetCabResponse&gt; {<br class="title-page-name"/>        let mut r = GetCabResponse::new();<br class="title-page-name"/><br class="title-page-name"/>        let mut location = Location::new();<br class="title-page-name"/>        location.latitude = 40.7128;<br class="title-page-name"/>        location.longitude = -74.0060;<br class="title-page-name"/><br class="title-page-name"/>        let mut one = Cab::new();<br class="title-page-name"/>        one.set_name("Limo".to_owned());<br class="title-page-name"/>        one.set_location(location.clone());<br class="title-page-name"/><br class="title-page-name"/>        let mut two = Cab::new();<br class="title-page-name"/>        two.set_name("Merc".to_owned());<br class="title-page-name"/>        two.set_location(location.clone());<br class="title-page-name"/><br class="title-page-name"/>        let vec = vec![one, two];<br class="title-page-name"/>        let cabs = ::protobuf::RepeatedField::from_vec(vec);<br class="title-page-name"/><br class="title-page-name"/>        r.set_cabs(cabs);<br class="title-page-name"/><br class="title-page-name"/>        grpc::SingleResponse::completed(r)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut server = grpc::ServerBuilder::new_plain();<br class="title-page-name"/>    server.http.set_port(9001);<br class="title-page-name"/>    server.add_service(FooBarServiceServer::new_service_def(FooBarServer));<br class="title-page-name"/>    server.http.set_cpu_pool_threads(4);<br class="title-page-name"/>    let _server = server.build().expect("Could not start server");<br class="title-page-name"/>    loop {<br class="title-page-name"/>        thread::park();<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that this server is very different from the servers we wrote in previous chapters. This is because <kbd class="calibre11">grpc::ServerBuilder</kbd> encapsulates a lot of the complexity in writing servers. <kbd class="calibre11">FooBarService</kbd> is the service <kbd class="calibre11">protobuf</kbd> compiler generated for us, defined as a trait in the file <kbd class="calibre11">foobar_grpc.rs</kbd>. As expected, this trait has two methods: <kbd class="calibre11">record_cab_location</kbd> and <kbd class="calibre11">get_cabs</kbd>. Thus, for our server, we will need to implement this trait on a struct and pass that struct to <kbd class="calibre11">ServerBuilder</kbd> to run on a given port.</p>
<p class="calibre2">In our toy example, we will not actually record cab locations. A real world app would want to put these in a database to be looked up later. Instead, we will just print a message saying that we received a new location. We also need to work with some boilerplate code here, to make sure all gRPC semantics are fulfilled. In the <kbd class="calibre11">get_cabs</kbd> function, we always return a static list of cabs for all requests. Note that since all <kbd class="calibre11">protobuf</kbd> messages are generated for us, we get a bunch of utility functions, like <kbd class="calibre11">get_name</kbd> and <kbd class="calibre11">get_location</kbd>, for free. Finally, in the <kbd class="calibre11">main</kbd> function, we pass our server struct to gRPC to create a new server on a given port and run it on an infinite loop.</p>
<p class="calibre2">Our client is actually defined as a struct in the source generated by the <kbd class="calibre11">protobuf</kbd> compiler. We just need to make sure the client has the same port number we are running our server on. We use the <kbd class="calibre11">new_plain</kbd> method on the client struct and pass an address and port to it, along with some default options. We can then call the <kbd class="calibre11">record_cab_location</kbd> and <kbd class="calibre11">get_cabs</kbd> methods over RPC and process the responses:</p>
<pre class="calibre17">// ch5/grpc/src/bin/client.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate grpc_example;<br class="title-page-name"/>extern crate grpc;<br class="title-page-name"/><br class="title-page-name"/>use grpc_example::foobar::*;<br class="title-page-name"/>use grpc_example::foobar_grpc::*;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // Create a client to talk to a given server<br class="title-page-name"/>    let client = FooBarServiceClient::new_plain("127.0.0.1", 9001,<br class="title-page-name"/>    Default::default()).unwrap();<br class="title-page-name"/><br class="title-page-name"/>    let mut req = CabLocationRequest::new();<br class="title-page-name"/>    req.set_name("foo".to_string());<br class="title-page-name"/><br class="title-page-name"/>    let mut location = Location::new();<br class="title-page-name"/>    location.latitude = 40.730610;<br class="title-page-name"/>    location.longitude = -73.935242;<br class="title-page-name"/>    req.set_location(location);<br class="title-page-name"/><br class="title-page-name"/>    // First RPC call<br class="title-page-name"/>    let resp = client.record_cab_location(grpc::RequestOptions::new(),<br class="title-page-name"/>    req);<br class="title-page-name"/>    match resp.wait() {<br class="title-page-name"/>        Err(e) =&gt; panic!("{:?}", e),<br class="title-page-name"/>        Ok((_, r, _)) =&gt; println!("{:?}", r),<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    let mut nearby_req = GetCabRequest::new();<br class="title-page-name"/>    let mut location = Location::new();<br class="title-page-name"/>    location.latitude = 40.730610;<br class="title-page-name"/>    location.longitude = -73.935242;<br class="title-page-name"/>    nearby_req.set_location(location);<br class="title-page-name"/><br class="title-page-name"/>    // Another RPC call<br class="title-page-name"/>    let nearby_resp = client.get_cabs(grpc::RequestOptions::new(),<br class="title-page-name"/>    nearby_req);<br class="title-page-name"/>    match nearby_resp.wait() {<br class="title-page-name"/>        Err(e) =&gt; panic!("{:?}", e),<br class="title-page-name"/>        Ok((_, cabs, _)) =&gt; println!("{:?}", cabs),<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"> Here is how a run of the client will look like. As noted before, this is not as dynamic as it should be, since it returns only hardcoded values:<br class="title-page-name"/></p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --bin client</strong><br class="title-page-name"/>   Blocking waiting for file lock on build directory<br class="title-page-name"/>   Compiling grpc_example v0.1.0 (file:///rust-book/src/ch5/grpc)<br class="title-page-name"/>   Finished dev [unoptimized + debuginfo] target(s) in 3.94 secs<br class="title-page-name"/>     Running `/rust-book/src/ch5/grpc/target/debug/client`<br class="title-page-name"/>accepted: true<br class="title-page-name"/>cabs {name: "Limo" location {latitude: 40.7128 longitude: -74.006}} cabs {name: "Merc" location {latitude: 40.7128 longitude: -74.006}}</pre>
<p class="calibre2">Notice how it exits right after talking to the server. The server, on the other hand, runs in an infinite loop, and does not exit till it gets a signal:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run --bin server</strong><br class="title-page-name"/>   Compiling grpc_example v0.1.0 (file:///rust-book/src/ch5/grpc)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 5.93 secs<br class="title-page-name"/>     Running `/rust-book/src/ch5/grpc/target/debug/server`<br class="title-page-name"/>Recorded cab foo at 40.73061, -73.93524</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction to SMTP</h1>
                
            
            
                
<p class="calibre2">Internet email uses a protocol called <strong class="calibre1">Simple Mail Transfer Protocol </strong>(<strong class="calibre1">SMTP</strong>), which is an IETF standard. Much like HTTP, it is a simple text protocol over TCP, using port <kbd class="calibre11">25</kbd> by default. In this section, we will look at a small example of using <kbd class="calibre11">lettre</kbd> for sending emails. For this to work, let us set up our project first:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin lettre-example</strong></pre>
<p class="calibre2">Now, our <kbd class="calibre11">Cargo.toml</kbd> file should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "lettre-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>lettre = "0.7"<br class="title-page-name"/>uuid = "0.5.1"<br class="title-page-name"/>native-tls = "0.1.4"</pre>
<p class="calibre2">Let's say we want to send crash reports for a server automatically. For this to work, we need to have an SMTP server running somewhere accessible. We also need to have a user who can authenticate using a password set up on that server. Having set those up, our code will look like this:</p>
<pre class="calibre17">// ch5/lettre-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate uuid;<br class="title-page-name"/>extern crate lettre;<br class="title-page-name"/>extern crate native_tls;<br class="title-page-name"/><br class="title-page-name"/>use std::env;<br class="title-page-name"/>use lettre::{SendableEmail, EmailAddress, EmailTransport};<br class="title-page-name"/>use lettre::smtp::{SmtpTransportBuilder, SUBMISSION_PORT};<br class="title-page-name"/>use lettre::smtp::authentication::Credentials;<br class="title-page-name"/>use lettre::smtp::client::net::ClientTlsParameters;<br class="title-page-name"/><br class="title-page-name"/>use native_tls::TlsConnector;<br class="title-page-name"/><br class="title-page-name"/>// This struct represents our email with all the data<br class="title-page-name"/>// we want to send.<br class="title-page-name"/>struct CrashReport {<br class="title-page-name"/>    to: Vec&lt;EmailAddress&gt;,<br class="title-page-name"/>    from: EmailAddress,<br class="title-page-name"/>    message_id: String,<br class="title-page-name"/>    message: Vec&lt;u8&gt;,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A simple constructor for our email.<br class="title-page-name"/>impl CrashReport {<br class="title-page-name"/>    pub fn new(from_address: EmailAddress,<br class="title-page-name"/>        to_addresses: Vec&lt;EmailAddress&gt;,<br class="title-page-name"/>        message_id: String,<br class="title-page-name"/>        message: String) -&gt; CrashReport {<br class="title-page-name"/>            CrashReport { from: from_address,<br class="title-page-name"/>            to: to_addresses,<br class="title-page-name"/>            message_id: message_id,<br class="title-page-name"/>            message: message.into_bytes()<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;'a&gt; SendableEmail&lt;'a, &amp;'a [u8]&gt; for CrashReport {<br class="title-page-name"/>    fn to(&amp;self) -&gt; Vec&lt;EmailAddress&gt; {<br class="title-page-name"/>        self.to.clone()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fn from(&amp;self) -&gt; EmailAddress {<br class="title-page-name"/>        self.from.clone()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fn message_id(&amp;self) -&gt; String {<br class="title-page-name"/>        self.message_id.clone()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    fn message(&amp;'a self) -&gt; Box&lt;&amp;[u8]&gt; {<br class="title-page-name"/>        Box::new(self.message.as_slice())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let server = "smtp.foo.bar";<br class="title-page-name"/>    let connector = TlsConnector::builder().unwrap().build().unwrap();<br class="title-page-name"/>    let mut transport = SmtpTransportBuilder::new((server, SUBMISSION_PORT), lettre::ClientSecurity::Opportunistic(&lt;ClientTlsParameters&gt;::new(server.to_string(), connector)))<br class="title-page-name"/>.expect("Failed to create transport")<br class="title-page-name"/>    .credentials(Credentials::new(env::var("USERNAME").unwrap_or_else(|_| "user".to_string()),<br class="title-page-name"/>env::var("PASSWORD").unwrap_or_else<br class="title-page-name"/>(|_| "password".to_string())))<br class="title-page-name"/>    .build();<br class="title-page-name"/>    let report = CrashReport::new(EmailAddress::<br class="title-page-name"/>    new("foo@bar.com".to_string()), vec!   <br class="title-page-name"/>    [EmailAddress::new("foo@bar.com".to_string())]<br class="title-page-name"/>    , "foo".to_string(), "OOPS!".to_string());<br class="title-page-name"/>    transport.send(&amp;report).expect("Failed to send the report");<br class="title-page-name"/>}</pre>
<p class="calibre2">Our email is represented by the <kbd class="calibre11">CrashReport</kbd> struct; as expected, it has a <kbd class="calibre11">from</kbd> email address. The <kbd class="calibre11">to</kbd> field is a vector of email addresses, enabling us to send an email to multiple addresses. We implement a constructor for the struct. The crate <kbd class="calibre11">lettre</kbd> defines a trait called <kbd class="calibre11">SendableEmail</kbd> that has a bunch of properties an SMTP server needs to send an email. For a user-defined email to be sendable, it needs to implement that trait. In our case, <kbd class="calibre11">CrashReport</kbd> needs to implement it. We go on to implement all required methods in the trait. At this point, a new instance of <kbd class="calibre11">CrashReport</kbd> should be sendable as an email.</p>
<p class="calibre2">In our main function, we will need to <kbd class="calibre11">auth</kbd> against the SMTP server to send our emails. We create a transport object which has all of the required info to talk to the SMTP server. The username and password can be passed as environment variables (or defaults). We then create an instance of our <kbd class="calibre11">CrashReport</kbd> and use the <kbd class="calibre11">send</kbd> method of the transport to send it. Running this does not output any information (if it ran successfully).</p>
<p class="calibre2">One might have noticed that the API exposed by <kbd class="calibre11">lettre</kbd> is not very easy to use. This is primarily because the library is largely immature, being at version 0.7 at the time of writing. Thus, one should expect breaking changes in the API till it reaches a 1.0 release.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction to FTP and TFTP</h1>
                
            
            
                
<p class="calibre2">Another common application layer protocol is the <strong class="calibre1">File Transfer Protocol</strong> (<strong class="calibre1">FTP</strong>). This is a text-based protocol, where the server and clients exchange text commands to upload and download files. The Rust ecosystem has a crate called rust-ftp to interact with FTP servers programmatically. Let us look at an example of its use. We set up our project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin ftp-example</strong></pre>
<p class="calibre2">Our <kbd class="calibre11">Cargo.toml</kbd> should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "ftp-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies.ftp]<br class="title-page-name"/>version = "2.2.1"</pre>
<p class="calibre2">For this example to work, we will need a running FTP server somewhere. Once we have set that up and made sure a regular FTP client can connect to it, we can move on to our main code:</p>
<pre class="calibre17">// ch5/ftp-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate ftp;<br class="title-page-name"/><br class="title-page-name"/>use std::str;<br class="title-page-name"/>use std::io::Cursor;<br class="title-page-name"/>use ftp::{FtpStream, FtpError};<br class="title-page-name"/><br class="title-page-name"/>fn run_ftp(addr: &amp;str, user: &amp;str, pass: &amp;str) -&gt; Result&lt;(), FtpError&gt; {<br class="title-page-name"/>    let mut ftp_stream = FtpStream::connect((addr, 21))?;<br class="title-page-name"/>    ftp_stream.login(user, pass)?;<br class="title-page-name"/>    println!("current dir: {}", ftp_stream.pwd()?);<br class="title-page-name"/><br class="title-page-name"/>    let data = "A random string to write to a file";<br class="title-page-name"/>    let mut reader = Cursor::new(data);<br class="title-page-name"/>    ftp_stream.put("my_file.txt", &amp;mut reader)?;<br class="title-page-name"/><br class="title-page-name"/>    ftp_stream.quit()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    run_ftp("ftp.dlptest.com", "dlpuser@dlptest.com", "eiTqR7EMZD5zy7M").unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">For our example, we will connect to a free public FTP server, located at <kbd class="calibre11">ftp.dlptest.com</kbd>. The credentials for using the server are in this website: <a href="https://dlptest.com/ftp-test/" class="calibre10">https://dlptest.com/ftp-test/</a>. Our helper function, called <kbd class="calibre11">run_ftp</kbd>, takes in the address of an FTP server, with its username and password as strings. It then connects to the server on port <kbd class="calibre11">21</kbd> (the default port for FTP). It goes on to log in using the given credentials, and then prints the current directory (which should be <kbd class="calibre11">/</kbd>). We then write a file there using the <kbd class="calibre11">put</kbd> function, and, at the end, close our connection to the server. In our <kbd class="calibre11">main</kbd> function, we simply call the helper with the required parameters.</p>
<p class="calibre2">A thing to note here is the usage of <kbd class="calibre11">cursor</kbd>; it represents an inmemory buffer and provides implementations of <kbd class="calibre11">Read</kbd>, <kbd class="calibre11">Write</kbd>, and <kbd class="calibre11">Seek</kbd> over that buffer. The <kbd class="calibre11">put</kbd> function expects an input that implements <kbd class="calibre11">Read</kbd>; wrapping our data in a <kbd class="calibre11">Cursor</kbd> automatically does that for us.</p>
<p class="calibre2">Here is what we see on running this example:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling ftp-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch5/ftp-example)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.5 secs<br class="title-page-name"/>     Running `target/debug/ftp-example`<br class="title-page-name"/>current dir: /</pre>
<p>We have used an open FTP server in this example. Since this server is not under our control, it might be taken offline without notice. If that happens, the example will need to be modified to use another server.</p>
<p class="calibre2">A protocol closely related to FTP is called <strong class="calibre1">Trivial File Transfer Protocol </strong>(<strong class="calibre1">TFTP</strong>). TFTP is text-based, like FTP, but unlike FTP, it is way simpler to implement and maintain. It uses UDP for transport and does not provide any authentication primitives. Since it is faster and lighter, it is frequently implemented in embedded systems and boot protocols, like PXE and BOOTP. Let us look at a simple TFTP server using the crate called <kbd class="calibre11">tftp_server</kbd>. For this example, we will start with Cargo, like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin tftp-example</strong></pre>
<p class="calibre2">Our manifest is very simple and looks like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "tftp-example"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>tftp_server = "0.0.2"</pre>
<p class="calibre2">Our main file will look like this:</p>
<pre class="calibre17">// ch5/tftp-example/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate tftp_server;<br class="title-page-name"/><br class="title-page-name"/>use tftp_server::server::TftpServer;<br class="title-page-name"/><br class="title-page-name"/>use std::net::SocketAddr;<br class="title-page-name"/>use std::str::FromStr;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let addr = format!("0.0.0.0:{}", 69);<br class="title-page-name"/>    let socket_addr = SocketAddr::from_str(addr.as_str()).expect("Error<br class="title-page-name"/>    parsing address");<br class="title-page-name"/>    let mut server =<br class="title-page-name"/>    TftpServer::new_from_addr(&amp;socket_addr).expect("Error creating<br class="title-page-name"/>    server");<br class="title-page-name"/>    match server.run() {<br class="title-page-name"/>        Ok(_) =&gt; println!("Server completed successfully!"),</pre>
<pre class="calibre17">        Err(e) =&gt; println!("Error: {:?}", e),<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This can be easily tested on any Unix machine that has a TFTP client installed. If we run this on one terminal and run the client on another, we will need to connect the client to a localhost on port <kbd class="calibre11">69</kbd>. We should then be able to download a file from the server.</p>
<p>Running this might require root privileges. If that is the case, use <kbd class="calibre31">sudo</kbd>.<br class="calibre22"/>
<strong class="calibre19">$ sudo ./target/debug/tftp-example</strong></p>
<p class="calibre2">An example session is as follows:</p>
<pre class="calibre17"><strong class="calibre1">$ tftp</strong><br class="title-page-name"/>tftp&gt; connect 127.0.0.1 69<br class="title-page-name"/>tftp&gt; status<br class="title-page-name"/>Connected to 127.0.0.1.<br class="title-page-name"/>Mode: netascii Verbose: off Tracing: off<br class="title-page-name"/>Rexmt-interval: 5 seconds, Max-timeout: 25 seconds<br class="title-page-name"/>tftp&gt; get Cargo.toml<br class="title-page-name"/>Received 144 bytes in 0.0 seconds<br class="title-page-name"/>tftp&gt; ^D</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we built upon what we studied previously. In essence, we moved the network stack up to the application layer. We studied some major considerations for building application layer protocols. We then looked at RPC, and in particular, gRPC, studying how it enables developers to build large-scale networked services. We then looked at a Rust crate that can be used to send emails via an SMTP server. The last few examples were on writing an FTP client and a TFTP server. Along with other application layer protocols covered elsewhere in this book, we should have a good standing in understanding these protocols.</p>
<p class="calibre2">HTTP is one text-based application layer protocol that deserves a chapter of its own. In the next chapter, we will take a closer look at it and write some code to make it work.</p>


            

            
        
    </body></html>