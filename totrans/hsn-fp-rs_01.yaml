- en: Functional Programming – a Comparison
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程 – 一种比较
- en: '**Functional programm****ing** (**FP**) is the second most popular programming
    paradigm, behind only **obje****ct-oriented programming** (**OOP**). For many
    years, these two paradigms have been separated into different languages, so as
    not to be mixed. Multi-paradigm languages have attempted to support both approaches.
    Rust is one such language.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**（**FP**）是继**面向对象编程**（**OOP**）之后的第二大流行编程范式。多年来，这两个范式被分离到不同的语言中，以避免混合。多范式语言试图支持这两种方法。Rust就是这样一种语言。'
- en: As a broad definition, functional programming emphasizes the use of composable
    and maximally reusable functions to define program behavior. Using these techniques,
    we will show how functional programming has adapted clever solutions to many common
    yet difficult problems. This chapter will outline most of the concepts presented
    in this book. The remaining chapters will be dedicated to helping you master each
    technique.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，函数式编程强调使用可组合和最大可重用函数来定义程序行为。使用这些技术，我们将展示函数式编程如何巧妙地解决了许多常见但困难的问题。本章将概述本书中提出的多数概念。剩余的章节将致力于帮助您掌握每种技术。
- en: 'The learning outcomes we hope to provide are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供的成果如下：
- en: Being able to use functional style to reduce code weight and complexity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用函数式风格来减少代码的重量和复杂性
- en: Being able to write robust safe code by utilizing safe abstractions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过利用安全抽象编写健壮且安全的代码
- en: Being able to engineer complex projects using functional principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用函数式原则来构建复杂的项目
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided, and can
    be found here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要一个较新的Rust版本，可以在以下链接找到：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub, here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在GitHub上找到，链接如下：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的`README.md`文件中也包含了具体的安装和构建说明。
- en: Reducing code weight and complexity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少代码的重量和复杂性
- en: Functional programming can greatly reduce the amount and complexity of code
    required to accomplish tasks. Particularly in Rust, proper application of functional
    principles may simplify the often complex design requirements, and make programming
    a much more productive and rewarding experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程可以大大减少完成任务所需的代码量和复杂性。特别是在Rust中，正确应用函数式原则可能会简化通常复杂的设计要求，并使编程成为一种更加高效和有回报的体验。
- en: Making generics more generic
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使泛型更加通用
- en: Making generics more generic relates to the practice of parameterizing data
    structures and functions originated in functional languages. In Rust, and other
    languages, this is called **generics**. Types and functions can all be parameterized.
    One or more constraints may be placed on generic types to indicate requirements
    of a trait or lifetime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使泛型更加通用与起源于函数式语言的参数化数据结构和函数的实践相关。在Rust和其他语言中，这被称为**泛型**。类型和函数都可以进行参数化。可以在泛型类型上放置一个或多个约束，以指示特性和生命周期的要求。
- en: 'Struct definitions can become redundant without generics. Here is a definition
    of three structs that define a common concept of a `Point`. However, the structs
    use different numerical types, so the singular concept is expanded into three
    separate `PointN` type definitions in `intro_generics.rs`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有泛型的情况下，结构定义可能会变得冗余。以下是对三个定义了“点”这一公共概念的结构的定义。然而，这些结构使用了不同的数值类型，因此单一的概念在`intro_generics.rs`中扩展成了三个独立的`PointN`类型定义：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Instead, we can use generics to remove duplicate code and make the code more
    robust. Generic code is more easily adaptable to new requirements because many
    behaviors (and thus requirements) can be parameterized. If a change is needed,
    it is better to only change one line rather than a hundred.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用泛型来删除重复代码并使代码更加健壮。泛型代码更容易适应新的要求，因为许多行为（以及因此的需求）可以被参数化。如果需要更改，最好是只更改一行而不是一百行。
- en: 'This code snippet defines a parameterized `Point` struct. Now, a single definition
    can capture all possible numerical types for a `Point` in `intro_generics.rs`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了一个参数化的 `Point` 结构体。现在，单个定义可以捕获 `Point` 在 `intro_generics.rs` 中所有可能的数值类型：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functions are also problematic without generics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 没有泛型，函数也存在问题。
- en: 'Here is a simple function to square a number. However, to capture possible
    numerical types, we define three different functions in `intro_generics.rs`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的平方数字的函数。然而，为了捕获可能的数值类型，我们在 `intro_generics.rs` 中定义了三个不同的函数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Function parameters, such as this one, may need trait bounds (a constraint specifying
    one or more traits) to permit any behavior on that type that is used in the function
    body.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数，如这个例子所示，可能需要特质界限（指定一个或多个特质的约束）以允许在函数体中使用该类型上的任何行为。
- en: 'Here is the `foo` function, redefined with a parameterized type. A single function
    can define the operation for all numerical types. Explicit bounds must be set
    for even basic operations, such as multiply or even copy, in `intro_generics.rs`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是重新定义的 `foo` 函数，带有参数化类型。单个函数可以定义所有数值类型的操作。在 `intro_generics.rs` 中，甚至对于乘法或复制等基本操作，也必须显式设置界限：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even functions can be sent as parameters. We call these higher-order functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身也可以作为参数传递。我们称之为高阶函数。
- en: 'Here is a trivial function that accepts a function and argument, then calls
    the function with the argument, returning the result. Note the trait bound  `Fn`,
    indicating that the provided function is a closure. For an object to be callable,
    it must implement one of the `fn`, `Fn`, `FnMut`, or `FnOnce` traits in `intro_generics.rs`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接受函数和参数的简单函数，然后使用参数调用该函数，并返回结果。注意特质界限 `Fn`，表示提供的函数是一个闭包。为了使对象可调用，它必须在 `intro_generics.rs`
    中实现 `fn`、`Fn`、`FnMut` 或 `FnOnce` 中的一个特质：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Functions as values
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为值
- en: Functions are nominally the big feature of functional programming. Specifically,
    functions as values are the keystone of the whole paradigm. Glossing over much
    detail, we will also introduce the term **closure** here for future reference.
    A closure is an object that acts as a function, implementing `fn`, `Fn`, `FnMut`,
    or `FnOnce`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是函数式编程的主要特性。具体来说，函数作为值是整个范式的基石。忽略许多细节，我们还将在此处引入术语 **闭包** 以供将来参考。闭包是一个充当函数的对象，实现了
    `fn`、`Fn`、`FnMut` 或 `FnOnce`。
- en: Simple closures can be defined with the built-in closure syntax. This syntax
    is also beneficial because the `fn`, `Fn`, `FnMut`, and `FnOnce` traits are automatically
    implemented if permitted. This syntax is great for shorthand manipulation of data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置的闭包语法定义简单的闭包。这种语法的好处是，如果允许，`fn`、`Fn`、`FnMut` 和 `FnOnce` 特质将自动实现。这种语法非常适合简短的数据操作。
- en: 'Here is an iterator over the range `0` to `10`, mapped to the squared value.
    The square operation is applied using an inline closure definition sent to the
    `map` function of the iterator. The result of this expression will be an iterator.
    Here is an expression in `intro_functions.rs`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从 `0` 到 `10` 的范围迭代器，映射到平方值。平方操作是通过将内联闭包定义发送到迭代器的 `map` 函数来应用的。此表达式的结果将是一个迭代器。以下是在
    `intro_functions.rs` 中的一个表达式：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Closures can also have complex bodies with statements if the block syntax is
    used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用块语法，闭包也可以有复杂的主体和语句。
- en: 'Here is an iterator from `0` to `10`, mapped with a complex equation. The closure
    provided to map includes a function definition and a variable binding in `intro_functions.rs`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从 `0` 到 `10` 的迭代器，使用复杂方程映射。提供的映射闭包包括一个函数定义和一个变量绑定，在 `intro_functions.rs`
    中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is possible to define functions or methods that accept closures as arguments.
    To use the closure as a callable function, a bound of `Fn`, `FnMut`, or `FnOnce`
    must be specified.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义接受闭包作为参数的函数或方法。为了将闭包用作可调用的函数，必须指定 `Fn`、`FnMut` 或 `FnOnce` 的界限。
- en: 'Here is a HoF definition accepting a function `g` and an argument `x`. The
    definition constrains `g` and `x` to process `u32` types, and defines some mathematical
    operations involving calls to `g`. An invocation of the `f` HoF is also provided,
    as follows, using a simple inline closure definition in `intro_functions.rs`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接受函数 `g` 和参数 `x` 的 HoF 定义。该定义将 `g` 和 `x` 限制为处理 `u32` 类型，并定义了一些涉及调用 `g`
    的数学运算。还提供了一个 `f` HoF 的调用示例，如下所示，使用 `intro_functions.rs` 中的简单内联闭包定义：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Many parts of the standard library, particularly iterators, encourage heavy
    use of functions as arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的许多部分，尤其是迭代器，鼓励大量使用函数作为参数。
- en: 'Here is an iterator from `0` to `10` followed by many chained iterator combinators.
    The `map` function returns a new value from an original. `inspect` looks at a
    value, does not change it, but permits side-effects. `filter` omits all values
    that do not satisfy a predicate. `filter_map` filters and maps with a single function.
    The `fold` reduces all results to a single value, starting from an initial value,
    working left to right. Here is the expression in `intro_functions.rs`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从 `0` 到 `10` 的迭代器，后面跟着许多链式迭代器组合器。`map` 函数从原始值返回一个新值。`inspect` 查看一个值，不改变它，但允许副作用。`filter`
    跳过所有不满足谓词的值。`filter_map` 使用单个函数进行过滤和映射。`fold` 从一个初始值开始，向左向右工作，将所有结果减少到一个单一值。以下是在
    `intro_functions.rs` 中的表达式：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Iterators
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Iterators are a common feature of OOP languages, and Rust supports this concept
    well. Rust iterators are also designed with functional programming in mind, allowing
    programmers to write more legible code. The specific concept emphasized here is
    **composability**. When iterators can be manipulated, transformed, and combined,
    the mess of `for` loops can be replaced by individual function calls. These examples
    can be found in the `intro_iterators.rs` file. This is depicted in the following
    table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是面向对象语言的一个常见特性，Rust 良好地支持这个概念。Rust 迭代器也是以函数式编程为设计理念的，允许程序员编写更易读的代码。这里强调的具体概念是
    **可组合性**。当迭代器可以被操作、转换和组合时，`for` 循环的混乱可以被单个函数调用所取代。这些例子可以在 `intro_iterators.rs`
    文件中找到。这如下表所示：
- en: '| **Function name with description** | **Example** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **带有描述的功能名称** | **示例** |'
- en: '| Chain concatenates two iterators: `first...second` | `(0..10).chain(10..20);`
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 连接两个迭代器：`first...second` | `(0..10).chain(10..20);` |'
- en: '| The `zip` function combines two iterators into tuple pairs, iterating until
    the end of the shortest iterator: (a1,b1), (a2, b2), ... | `(0..10).zip(10..20);`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `zip` 函数将两个迭代器组合成元组对，迭代到最短迭代器的末尾：(a1,b1), (a2, b2), ... | `(0..10).zip(10..20);`
    |'
- en: '| The `enumerate` function is a special case of `zip` that creates numbered
    tuples (0, a1),(1,a2), … | `(0..10).enumerate();` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate` 函数是 `zip` 的一个特例，它创建带编号的元组 (0, a1),(1,a2), … | `(0..10).enumerate();`
    |'
- en: '| The `inspect` function applies a function to all values in the iterator during
    iteration | `(0..10).inspect(&#124;x&#124;{ println!("value {}", *x) });` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` 函数在迭代过程中将一个函数应用于迭代器中的所有值 | `(0..10).inspect(|x| { println!("value
    {}", *x) });` |'
- en: '| The `map` function applies a function to each element, returning the result
    in place | `(0..10).map(&#124;x&#124; x*x);` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `map` 函数将一个函数应用于每个元素，返回结果 | `(0..10).map(|x| x*x);` |'
- en: '| The `filter` function restricts elements to those satisfying a predicate
    | `(0..10).filter(&#124;x&#124; *x<3);` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `filter` 函数限制元素为满足谓词的元素 | `(0..10).filter(|x| *x<3);` |'
- en: '| The `fold` function accumulates all values into a single result | `(0..10).fold(0,
    &#124;x,y&#124; x+y);` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `fold` 函数将所有值累积到一个单一的结果中 | `(0..10).fold(0, |x,y| x+y);` |'
- en: '| When you want to apply the iterator, you can use a `for` loop or call `collect`
    | `for i in (0..10) {}`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '| 当你想应用迭代器时，你可以使用 `for` 循环或调用 `collect` | `for i in (0..10) {}`'
- en: '`(0..10).collect::<Vec<u64>>();` |'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`(0..10).collect::<Vec<u64>>();` |'
- en: Compact legible expressions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧凑易读的表达式
- en: In functional languages, all terms are expressions. There are no statements
    in function bodies, only a single expression. All control flow operators are then
    formulated as expressions with a return value. In Rust, this is almost the case;
    the only non-expressions are `let` statements and item declarations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，所有项都是表达式。函数体中没有语句，只有一个单独的表达式。所有控制流运算符随后都表示为具有返回值的表达式。在 Rust 中，这几乎就是情况；唯一不是表达式的是
    `let` 语句和项目声明。
- en: 'Both of these statements can be wrapped in blocks to create an expression along
    with any other term. An example for this is the following, in `intro_expressions.rs`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句都可以包裹在块中，以创建一个表达式以及任何其他项。以下是一个例子，在 `intro_expressions.rs` 中：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This nested format is uncommon in the wild, but it illustrates the permissive
    nature of Rust grammar.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套格式在野外不常见，但它说明了 Rust 语法宽容的本质。
- en: Returning to the concept of functional style expressions, the emphasis should
    always be on writing legible literate code without much hassle or bloat. When
    someone else, or you at a later time, comes to read your code, it should be immediately
    understandable. Ideally, the  code should document itself. If you find yourself
    constantly writing code twice, once in code and again as comments, then you should
    reconsider how effective your programming practices really are.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到函数式风格表达式的概念，重点始终应该放在编写易于阅读的代码上，无需太多麻烦或冗余。当其他人，或者你自己在以后的时间，来阅读你的代码时，它应该立即就能理解。理想情况下，代码应该能够自我说明。如果你发现自己不断地在代码和注释中重复写相同的代码，那么你应该重新考虑你的编程实践是否真正有效。
- en: To start with some examples of functional expressions, let's look at an expression
    that exists in most languages, the ternary conditional operator. In a normal `if`
    statement, the condition must occupy its own line and thus cannot be used as a
    sub-expression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一些函数式表达式的例子，让我们看看大多数语言中存在的一个表达式，三元条件运算符。在一个普通的`if`语句中，条件必须占据它自己的行，因此不能用作子表达式。
- en: 'The following is a traditional `if` statement, initializing a variable in `intro_expressions.rs`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个传统的`if`语句，在`intro_expressions.rs`中初始化一个变量：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the ternary operator, this assignment can be moved to a single line, shown
    as follows in `intro_expressions.rs`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符，这个赋值可以移动到一行，如下所示在`intro_expressions.rs`中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Almost every statement from OOP in Rust is also an expression—`if`, `for`,
    `while`, and so on. One of the more unique expressions to see in Rust that is
    uncommon in OOP languages is direct constructor expressions. All Rust types can
    be instantiated by single expressions. Constructors are only necessary in specific
    cases, for example, when an internal field requires complex initialization. The
    following is a simple `struct` and an equivalent tuple in `intro_expressions.rs`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎Rust中的每个从面向对象编程（OOP）来的语句也是一个表达式——`if`、`for`、`while`等等。在Rust中可以看到的一个更独特的表达式，在面向对象语言中不常见的是直接构造表达式。所有Rust类型都可以通过单个表达式实例化。构造器只在特定情况下是必要的，例如，当内部字段需要复杂的初始化时。以下是一个简单的`struct`和`intro_expressions.rs`中的等效元组：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another distinctive expression from functional languages is pattern matching.
    Pattern matching can be thought of as a more powerful version of a `switch` statement.
    Any expression can be sent into a pattern expression and de-structured to bind internal
    information into local variables before executing a `branch` expression. Pattern
    expressions are uniquely suited for working with enums. The two make a perfect
    pair.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言中的另一个独特表达式是模式匹配。模式匹配可以被认为是一个更强大的`switch`语句版本。任何表达式都可以发送到一个模式表达式中，并在执行`分支`表达式之前解构以将内部信息绑定到局部变量中。模式表达式非常适合与枚举一起工作。这两者是一对完美的搭档。
- en: 'The following snippet defines a `Term` as a tagged union of expression options.
    In the main function, a `Term` `t` is constructed, then matched with a pattern
    expression. Note the syntax similarity between the definition of a tagged union
    and the matching inside of a pattern expression in `intro_expressions.rs`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了一个`Term`，作为一个标记联合的表达式选项。在主函数中，构建了一个`Term` `t`，然后与一个模式表达式进行匹配。注意`intro_expressions.rs`中标记联合的定义与模式表达式内部的匹配的语法相似性：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Strict abstraction means safe abstraction
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格的抽象意味着安全的抽象
- en: Having a stricter type system does not imply that code will have more requirements
    or be any more complex. Rather than strict typing, consider using the term expressive
    typing. Expressive typing provides more information to the compiler. This extra
    information allows the compiler to provide extra assistance while programming.
    This extra information also permits a very rich metaprogramming system. This is
    all in addition to the obvious benefit of safer, more robust code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更严格的类型系统并不意味着代码会有更多的要求或更复杂。与其说是严格的类型，不如考虑使用“表达性类型”这个术语。表达性类型为编译器提供了更多信息。这些额外的信息允许编译器在编程时提供额外的帮助。这些额外的信息还允许一个非常丰富的元编程系统。所有这些都是在更安全、更健壮的代码的明显好处之上。
- en: Scoped data binding
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域数据绑定
- en: Variables in Rust are treated much more strictly than in most other languages.
    Global variables are almost entirely disallowed. Local variables are put under
    close watch to ensure that allocated data structures are properly deconstructed
    before going out of scope, but not sooner. This concept of tracking a variable's
    proper scope is known as **ownership** and **lifetime**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的变量比大多数其他语言处理得更为严格。全局变量几乎完全不允许。局部变量受到密切监控，以确保在超出作用域之前，分配的数据结构被正确地解构，但不是更早。这种跟踪变量适当作用域的概念被称为**所有权**和**生命周期**。
- en: 'In a simple example, data structures that allocate memory will deconstruct
    automatically when they go out of scope. No manual memory management is required
    in `intro_binding.rs`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的例子中，分配内存的数据结构在超出作用域时会自动解构。在`intro_binding.rs`文件中不需要手动内存管理：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In a slightly more complex example, allocated data structures can be passed
    around as return values, or referenced, and so on. These exceptions to simple
    scoping must also be accounted for in `intro_binding.rs`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个稍微复杂一点的例子中，分配的数据结构可以作为返回值传递，或者被引用，等等。这些简单的作用域的例外也必须在`intro_binding.rs`文件中考虑到：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This usage tracking can get complicated (and undecidable), so Rust has some
    rules that restrict when a variable can escape a context. We call this **complex
    rules ownership**. It can be explained with the following code, in `intro_binding.rs`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用跟踪可能会变得复杂（且不可决），因此Rust有一些规则来限制变量何时可以逃离上下文。我们称之为**复杂规则所有权**。它可以以下面的代码来解释，在`intro_binding.rs`文件中：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When it is not possible or desirable to transfer ownership, the `clone` trait
    is encouraged to create a duplicate copy of whatever data is referenced in `intro_binding.rs`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法或不需要转移所有权时，`clone`特质鼓励在`intro_binding.rs`文件中创建被引用数据的副本：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Cloning or copying is not a perfect solution, and comes with a performance
    overhead. To make Rust faster, and it is pretty fast, we also have the concept
    of borrowing. Borrowing is a mechanism to receive a direct reference to some data
    with the promise that ownership will be returned by some specific point. References
    are indicated by an ampersand. Consider the following example, in `intro_binding.rs`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆或复制并不是一个完美的解决方案，并且会带来性能开销。为了使Rust更快，它已经相当快了，我们还有借用这个概念。借用是一种机制，它承诺在某个特定点将所有权返回，以直接引用某些数据。引用由一个和号表示。考虑以下示例，在`intro_binding.rs`文件中：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another benefit of strict ownership is safe concurrency. Each binding is owned
    by a particular thread, and that ownership can be transferred to new threads with
    the `move` keyword. This has been explained with the following code, in `intro_binding.rs`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的拥有权的另一个好处是安全的并发。每个绑定都由一个特定的线程拥有，并且可以使用`move`关键字将这种所有权转移到新的线程。这已经在以下代码中解释过，在`intro_binding.rs`文件中：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To share information between threads, programmers have two main options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在线程之间共享信息，程序员有两个主要的选择。
- en: 'First, programmers may use the traditional combination of locks and atomic
    references. This is explained with the following code, in `intro_binding.rs`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序员可以使用传统的锁和原子引用的组合。这已经在以下代码中解释过，在`intro_binding.rs`文件中：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Second, channels provide a nice mechanism for message passing and job queuing
    between threads. The `send` trait is also implemented automatically for most objects.
    Consider the following code, in `intro_binding.rs`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通道提供了一个很好的机制，用于线程之间的消息传递和作业排队。`send`特质也自动应用于大多数对象。考虑以下代码，在`intro_binding.rs`文件中：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of this concurrency is type-safe and compiler-enforced. Use threads as much
    as you want, and if you accidentally try to create a race condition or simple
    deadlock, then the compiler will stop you. We call this **fearless concurrency**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些并发都是类型安全的，并且由编译器强制执行。你可以尽可能多地使用线程，如果你不小心尝试创建竞态条件或简单的死锁，编译器会阻止你。我们称之为**无畏并发**。
- en: Algebraic datatypes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: In addition to structs/objects and functions/methods, Rust functional programming
    includes some rich additions to definable types and structures. Tuples provide
    a shorthand for defining simple anonymous structs. Enums provide a type-safe approach
    to unions of complex data structures with the added bonus of a constructor tag
    to help in pattern matching. The standard library has extensive support for generic
    programming, from base types to collections. Even the object system traits are
    a hybrid cross between the OOP concept of a class and the FP concept of type classes.
    Functional style lurks around every corner, and even if you don't seek them in
    Rust, you will probably find yourself unknowingly using the features.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构/对象和函数/方法之外，Rust的函数式编程还包括对可定义类型和结构的丰富扩展。元组提供了定义简单匿名结构的简写。枚举提供了一种类型安全的联合复杂数据结构的方法，并增加了构造标签以帮助模式匹配的额外好处。标准库对泛型编程有广泛的支持，从基本类型到集合。甚至对象系统特性也是面向对象（OOP）概念中的类和函数式编程（FP）概念中的类型类的混合。函数式风格无处不在，即使你不在Rust中寻找，你也可能会不知不觉地使用这些功能。
- en: 'The `type` aliases can be helpful to create shorthand names for complex types.
    Alternatively, the `newtype` struct pattern can be used to create an alias with
    different non-equivalent types. Consider the following example, in `intro_datatypes.rs`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`别名可以帮助创建复杂类型的简称。或者，可以使用`newtype`结构模式来创建具有不同非等效类型的别名。以下是一个例子，在`intro_datatypes.rs`文件中：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A `struct`, even when parameterized, can be repetitive when used simply to
    store multiple values into a single object. This can be seen in `intro_datatypes.rs`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`struct`，即使参数化，当仅用于将多个值存储到单个对象中时，也可能变得重复。这可以在`intro_datatypes.rs`文件中看到：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A tuple helps eliminate redundant struct definitions. No prior type definitions
    are necessary to use tuples. Consider the following example, in `intro_datatypes.rs`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 元组有助于消除冗余的结构定义。使用元组不需要先前的类型定义。以下是一个例子，在`intro_datatypes.rs`文件中：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Standard operators can be implemented for any type by implementing the correct
    trait. Consider the following example for this, in `intro_datatypes.rs`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过实现正确的特性为任何类型实现标准运算符。以下是一个例子，在`intro_datatypes.rs`文件中：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Standard library collections and many other built-in types are generic, such as
    `HashMap` in `intro_datatypes.rs`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库集合和许多其他内置类型都是泛型的，例如`intro_datatypes.rs`中的`HashMap`：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Enums are a type-safe union of multiple types. Note that recursive `enum` definitions
    must wrap the inner value in a container such as `Box`, otherwise the size would
    be infinite. This is depicted as follows, in `intro_datatypes.rs`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是多个类型的类型安全联合。请注意，递归的`enum`定义必须将内部值包裹在容器中，如`Box`，否则大小将是无限的。以下是如何表示的，在`intro_datatypes.rs`文件中：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Tagged unions are also used for more complex data structures. Consider the
    following code, in `intro_datatypes.rs`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标签联合也用于更复杂的数据结构。以下是一个例子，在`intro_datatypes.rs`文件中：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Traits are a bit like object classes (OOP), shown with the following code example,
    in `intro_datatypes.rs`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特性有点像面向对象中的类（OOP），以下是一个代码示例，在`intro_datatypes.rs`文件中：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Traits are also like type classes (FP), shown with the following code snippet,
    in `intro_datatypes.rs`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也像类型类（FP），以下是一个代码片段，在`intro_datatypes.rs`文件中：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mixing object-oriented programming and functional programming
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合面向对象编程和函数式编程
- en: As mentioned before, Rust supports much of both object-oriented and functional
    programming styles. Datatypes and functions are neutral to either paradigm. Traits
    specifically support a hybrid blend of both styles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Rust支持面向对象和函数式编程风格的许多方面。数据类型和函数对任何范式都是中立的。特性和特质专门支持这两种风格的混合。
- en: 'First, in an object-oriented style, defining a simple class with a constructor
    and some methods can be accomplished with a `struct`, `trait`, and `impl`. This
    is explained using the following code snippet, in `intro_mixoopfp.rs`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在面向对象风格中，使用`struct`、`trait`和`impl`定义一个简单的类和构造函数以及一些方法可以完成。这通过以下代码片段进行解释，在`intro_mixoopfp.rs`文件中：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding support for functional programming onto an object is as simple as defining
    traits and methods that use functional language features. For example, accepting
    a closure can become a great abstraction when used appropriately. Consider the
    following example, in `intro_mixoopfp.rs`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上添加对函数式编程的支持就像定义特性和使用函数式语言特性的方法一样简单。例如，接受一个闭包可以成为当适当使用时的一种很好的抽象。以下是一个例子，在`intro_mixoopfp.rs`文件中：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Improving project architecture
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进项目架构
- en: Functional programs encourage good project architecture and principled design
    patterns. Using the building blocks of functional programming often reduces the
    number of design choices to be made in such a way that good options become obvious.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序鼓励良好的项目架构和原则性设计模式。使用函数式编程的构建块通常可以减少需要做出的设计选择，使得好的选项变得明显。
- en: '"There should be one - and preferably only one - obvious way to do it."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “应该只有一个 - 最好是唯一一个 - 明显的方法来做这件事。”
- en: – *PEP 20*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: – *PEP 20*
- en: File hierarchy, modules, and namespace design
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件层次结构、模块和命名空间设计
- en: 'Rust programs are compiled primarily in one of two ways. The first is to use
    `rustc` to compile individual files. The second is to describe an entire package
    for compilation using `cargo`. We will assume here that projects are built using
    `cargo`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 程序主要以两种方式编译。第一种是使用 `rustc` 编译单个文件。第二种是使用 `cargo` 描述整个包以进行编译。我们假设这里的项目是使用
    `cargo` 构建的，如下所示：
- en: 'To start a package, you first create a `Cargo.toml` file in a directory. That
    directory will be your package directory from now on. This is a configuration
    file that will tell the compiler what code, assets, and extra information should
    be included into the package:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始一个包，你首先在一个目录中创建一个 `Cargo.toml` 文件。从现在起，这个目录将是你的包目录。这是一个配置文件，它将告诉编译器应该将哪些代码、资源和额外信息包含到包中：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After this basic configuration, you can now use `cargo build` to compile the
    entire project. Where you decide to place your code files, and what to name them,
    is determined by how you want to refer to them in the module namespace. Each file
    will be given its own module `mod`. You can also nest modules inside files:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成基本配置之后，你现在可以使用 `cargo build` 来编译整个项目。你决定将代码文件放在哪里，以及如何命名它们，取决于你如何在模块命名空间中引用它们。每个文件都会被赋予自己的模块
    `mod`。你还可以在文件内部嵌套模块：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After these steps, projects can then be added as cargo dependencies, and namespaces
    can be used inside of modules to expose public symbols. Consider the following
    code snippet:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些步骤之后，项目可以作为 cargo 依赖项添加，模块内部可以使用命名空间来公开符号。考虑以下代码片段：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These are the basic building blocks of Rust modules, but what does this have
    to do with functional programming?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Rust 模块的基本构建块，但这与函数式编程有什么关系呢？
- en: Architecting a project in functional style is a process, and lends itself to
    certain routines. Typically, the project architect will start by designing the
    core data structures and in complex cases also the physical structure (where code/services
    will operationally be run). Once the data layout has been outlined in sufficient
    detail, then core functions/routines can be planned (such as how the program behaves).
    Up to this point, there may be code left unimplemented if coding is happening
    during the architecting stage. The final stage involves replacing this mock code
    with correct behaviors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以函数式风格设计项目是一个过程，并且适合某些常规。通常，项目架构师会首先设计核心数据结构，在复杂情况下也会设计物理结构（代码/服务将在此处运行）。一旦数据布局被详细概述，就可以规划核心函数/常规（例如程序的行为）。到这一点，如果在架构阶段进行编码，可能会有一些代码尚未实现。最终阶段涉及用正确的行为替换这个模拟代码。
- en: 'Following this stage-by-stage development process, we can also see an archetypical
    file layout forming. It is common to see these stages written top to bottom in
    actual programs. Though it is unlikely the authors went through planning in these
    explicit stages, it still is a common pattern due to simplicity''s sake. Consider
    the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个分阶段的发展过程，我们还可以看到典型的文件布局正在形成。在实际程序中，通常将这些阶段从上到下书写。尽管作者们不太可能在这些明确的阶段中进行规划，但由于简单起见，这仍然是一个常见的模式。考虑以下示例：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Grouping definitions like this may be helpful to standardize file layout and
    improve readability. Searching back and forth through a long file for symbol definitions
    is a common but unpleasant part of programming. It is also a preventable problem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将定义分组如下可能有助于标准化文件布局并提高可读性。在长文件中来回搜索符号定义是编程中常见但令人不快的一部分。这同样也是一个可以预防的问题。
- en: Functional design patterns
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: 'Aside from file layout, there are a number of functional design patterns that
    help reduce code weight and redundancy. When used properly, these principles can
    help clarify design decisions and also enable robust architecture. Most design
    patterns are variants of the single responsibility principle. This can take many
    forms depending on the context, but the intent is the same; write code that does
    one thing well, then reuse that code as needed. I have explained this as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件布局之外，还有许多功能设计模式有助于减少代码重量和冗余。当正确使用时，这些原则可以帮助阐明设计决策，并使架构更加健壮。大多数设计模式都是单一责任原则的变体。这可以有多种形式，具体取决于上下文，但意图是相同的；编写做一件事做得好的代码，然后根据需要重用这段代码。我已如下解释：
- en: '**Pure functions**: These are functions with no side effects or logical dependencies
    other than function arguments. A side effect is a change of state that affects
    anything outside of the function, aside from the return value. Pure functions
    are useful because they can be tossed around and combined and generally used carelessly
    without the risk of unintended effects.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：这些是没有副作用或逻辑依赖（除了函数参数之外）的函数。副作用是指影响函数之外任何内容的状态变化，除了返回值。纯函数很有用，因为它们可以被随意抛来抛去，组合，并且通常可以不加顾虑地使用，而不会产生意外的影响。'
- en: The worst thing that can go wrong with a pure function is a bad return value
    or, in extreme cases, a stack overflow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可能出现的最糟糕的事情是返回值不好，或者在极端情况下，栈溢出。
- en: 'It is harder to cause bugs with pure functions, even when used recklessly.
    Consider the following example of pure functions, in `intro_patterns.rs`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数，即使使用不当，也难以引发错误。考虑以下纯函数的示例，在`intro_patterns.rs`中：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Immutability**: Immutability is a pattern that helps encourage pure functions.
    Rust variable bindings are immutable by default. This is Rust''s not-so-subtle
    way of encouraging you to avoid mutable state. Don''t do it. If you absolutely
    must, it is possible to tag variables with the `mut` keyword to allow reassignment.
    This is shown with the following example, in `intro_patterns.rs`:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：不可变性是一种有助于鼓励纯函数的模式。Rust变量绑定默认是不可变的。这是Rust鼓励你避免可变状态的一种不太微妙的方式。不要这样做。如果你绝对必须，可以使用`mut`关键字标记变量以允许重新赋值。这可以通过以下示例在`intro_patterns.rs`中展示：'
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Functional composition**: Functional composition is a pattern where the output
    of one function is connected to the input of another function. In this fashion,
    functions can be chained together to create complex effects from simple steps.
    This is shown with the following code snippet, in `intro_patterns.rs`:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数组合**：函数组合是一种模式，其中一个函数的输出连接到另一个函数的输入。以这种方式，函数可以串联起来，通过简单的步骤创建复杂的效果。这可以通过以下代码片段在`intro_patterns.rs`中展示：'
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Higher-order functions**: These have already been mentioned before, but we
    haven''t used the term yet. A HoF is a function that accepts a function as a parameter.
    Many iterator methods are HoFs. Consider the following example, in `intro_patterns.rs`:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶函数**：这些之前已经提到过，但我们还没有使用这个术语。高阶函数是接受一个函数作为参数的函数。许多迭代器方法都是高阶函数。考虑以下示例，在`intro_patterns.rs`中：'
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Functors**: If you can get past the name, these are a simple and effective
    design pattern. They are also very versatile. The concept is somewhat difficult
    to capture in its entirety, but you may think of functors as *the inverse of functions*.
    A function defines a transformation, accepts data, and returns the result of the
    transformation. A functor defines data, accepts a function, and returns the result
    of the transformation. A common example of a functor is the bound `map` method
    that frequently appears on containers, such as for a `Vec`. Here is an example,
    in `intro_patterns.rs`:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函子**：如果你能越过这个名字，这些是一个简单而有效的设计模式。它们也非常灵活。这个概念在整体上可能难以捕捉，但你可能将函子视为*函数的逆*。一个函数定义了一个转换，接受数据，并返回转换的结果。函子定义数据，接受一个函数，并返回转换的结果。函子的一个常见例子是绑定在容器上的`map`方法，例如在`Vec`上。以下是一个示例，在`intro_patterns.rs`中：'
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '"A monad is a monoid in the category of endofunctors, what''s the problem?"'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “单子是端内函子的范畴中的幺半群，问题是什么？”
- en: – *Philip Wadler*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: – *菲利普·瓦德勒*
- en: '**Monads**: Monads are a common stumbling block for people learning FP. Monads
    and functors are maybe the first words that you may encounter on a journey that
    goes deep into theoretical mathematics. We won''t go there. For our purposes,
    monads are simply a `trait` with two methods. This is shown in the following code,
    in `intro_patterns.rs`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Monads**：Monads是学习FP的人常见的绊脚石。Monads和functors可能是你深入理论数学之旅中可能遇到的第一个词。我们不会深入那个领域。对我们来说，monads只是一个有两个方法的`trait`。以下代码展示了这一点，位于`intro_patterns.rs`文件中：'
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If that doesn't help clarify things (and it probably doesn't), a monad has two
    methods. The first method is the constructor. The second method lets you bind
    an operation to create another monad. Many common traits have hidden semi-monads
    but, by making the concept explicit, the concept becomes a strong design pattern
    instead of a messy anti-pattern. Don't try to reinvent what you don't have to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不能帮助你澄清问题（很可能不能），monad有两个方法。第一个方法是构造函数。第二个方法允许你绑定一个操作以创建另一个monad。许多常见的特性都有隐藏的半monad，但通过使概念明确化，这个概念就变成了一个强大的设计模式，而不是一个混乱的反模式。不要试图重新发明你不需要的东西。
- en: '**Function currying**: Function currying is a technique that may seem strange
    for anyone coming from a background in object-oriented or imperative languages.
    The reason for this confusion is that in many functional languages, functions
    are curried by default, whereas this is not the case for other languages. Rust
    functions are not curried by default.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数currying**：对于来自面向对象或命令式语言背景的人来说，函数currying可能是一个陌生的技术。这种混淆的原因是，在许多函数式语言中，函数默认是curry的，而其他语言则不是这样。Rust函数默认不是curry的。'
- en: 'The difference between curried and non-curried functions are that curried functions
    send in parameters one by one, whereas non-curried functions send in parameters
    all at once. Looking at a normal Rust function definition, we can see that it
    is not curried. Consider the following code, in `intro_patterns.rs`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: curry函数和非curry函数的区别在于curry函数是逐个传入参数，而非curry函数则是一次性传入所有参数。观察一个普通的Rust函数定义，我们可以看到它并不是curry函数。考虑以下代码，位于`intro_patterns.rs`文件中：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A `curried` function takes each parameter one by one, as shown in the following,
    in `intro_patterns.rs`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`curried`函数逐个接受参数，如下所示，位于`intro_patterns.rs`文件中：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Curried functions can be used as a function factory. The first few arguments
    configure how the final function should behave. The result is a pattern that allows
    shorthand configuration of complex operators. Currying complements all the other
    design patterns by converting individual functions into multiple components.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Curry函数可以用作函数工厂。前几个参数配置了最终函数应该如何表现。结果是允许简短配置复杂操作符的模式。Currying通过将单个函数转换为多个组件来补充所有其他设计模式。
- en: '**Lazy evaluation**: Lazy evaluation is a pattern that is technically possible
    in other languages. However, it is uncommon to see it outside of FP, due to language
    barriers. The difference between a normal expression and a lazy expression is
    that a lazy expression will not be evaluated until accessed. Here is a simple implementation
    of laziness, implemented behind a function call in `intro_patterns.rs`:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性评估**：惰性评估在其他语言中在技术上也是可能的。然而，由于语言障碍，它很少在FP之外看到。正常表达式和惰性表达式的区别在于惰性表达式只有在被访问时才会被评估。以下是一个简单的惰性实现，位于`intro_patterns.rs`文件中的函数调用之后：'
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second expression will not be evaluated until the function is called, at
    which point the code resolves. For lazy expressions, side effects happen at time
    of resolution instead of at initialization. This is a poor implementation of laziness,
    so we will go into further detail in later chapters. The pattern is fairly common,
    and some operators and data structures require laziness to work. A simple example
    of necessary laziness is a lazy list that may not otherwise be possible to create.
    The built-in Rust numerical iterator (lazy list) uses this well: `(0..)`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表达式只有在函数被调用时才会被评估，此时代码才会解析。对于惰性表达式，副作用发生在解析时而不是初始化时。这是一个懒惰实现的糟糕例子，因此我们将在后面的章节中进一步详细说明。这种模式相当常见，一些操作符和数据结构需要惰性才能工作。一个必要的惰性例子是可能无法以其他方式创建的惰性列表。内置的Rust数值迭代器（惰性列表）很好地使用了这一点：（0..）。
- en: 'Memoization is the last pattern that we will introduce here. It may be considered
    as more of an optimization than design pattern, but due to how common it is, we
    should mention it here. A memoized function only computes unique results once.
    A simple implementation would be a function guarded by a hash table. If the parameters
    and result are already in the hash table, then skip the function call and directly
    return the result from the hash table. Otherwise, compute the result, put it in
    the hash table, and return. This process can be implemented manually in any language,
    but Rust macros allow us to write the memoization code once, and reuse that code
    by applying this macro. This is shown using the following code snippet, in `intro_patterns.rs`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存（Memoization）是我们在这里将要介绍的最后一个模式。它可能更多地被视为一种优化而不是设计模式，但由于其普遍性，我们在这里应该提到它。一个缓存的函数只计算一次唯一的结果。一个简单的实现是使用哈希表来保护函数。如果参数和结果已经在哈希表中，则跳过函数调用并直接从哈希表中返回结果。否则，计算结果，将其放入哈希表，并返回。这个过程可以在任何语言中手动实现，但
    Rust 宏允许我们一次性编写缓存代码，并通过应用此宏来重用该代码。这可以通过以下代码片段展示，位于 `intro_patterns.rs` 文件中：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example makes use of two crates and many macros. We won't fully explain
    everything that is happening here until the very end of this book. There is much
    that is possible with macros and metaprogramming. Caching function results is
    just a start.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了两个 crate 和许多宏。我们不会在本书的最后一部分完全解释这里发生的一切。宏和元编程有很多可能性。缓存函数结果是起点。
- en: Metaprogramming
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: 'The term metaprogramming in Rust often overlaps with the term macros. There
    are two primary types of macros available in Rust:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，元编程这个术语经常与宏（macros）这个术语重叠。Rust 中有两种主要的宏类型可用：
- en: Recursive
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Procedural
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程式
- en: Both types of macros take as input an **abstract syntax tree** (**AST**), and
    produce one or more AST.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的宏都接受一个**抽象语法树**（**AST**）作为输入，并生成一个或多个 AST。
- en: 'A commonly used macro is `println`. A variable number of arguments and types
    are joined with the format string through the use of a macro to produce formatted
    output. To invoke recursive macros like this, invoke the macro just like a function
    with the addition of a `!` before the arguments. Macro applications may alternatively
    be surrounded by `[]` or `{}`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的宏是 `println`。通过宏将可变数量的参数和类型与格式字符串连接起来，以产生格式化的输出。要调用这样的递归宏，就像调用函数一样调用宏，只是在参数前加上一个
    `!`。宏应用可以由 `[]` 或 `{}` 包围：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Recursive macros are defined by `macro_rules!` statements. The inside of a
    `macro_rules` definition is very similar to that of a pattern-matching expression.
    The only difference is that `macro_rules!` matches syntax instead of data. We
    can use this format to define a reduced version of the `vec` macro. This is shown
    in the following code snippet, in `intro_metaprogramming.rs`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 递归宏通过 `macro_rules!` 语句定义。`macro_rules` 定义内部的格式与模式匹配表达式非常相似。唯一的区别是 `macro_rules!`
    匹配语法而不是数据。我们可以使用此格式来定义 `vec` 宏的简化版本。以下是在 `intro_metaprogramming.rs` 文件中的代码片段展示：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This definition accepts and matches only one pattern. It expects a comma-separated
    list of expressions. The syntax pattern `( $( $x: expr ),* )` matches against
    a comma-separated list of expressions and stores the result in the plural variable
    `$x`. In the body of the expression, there is a single block. The block defines
    a new `vec`, then iterates through `$x*` to push each `$x` into the `vec`, and,
    finally, the block returns the `vec` as its result. The macro and its expansion
    are as follows, in `intro_metaprogramming.rs`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '此定义仅接受并匹配一个模式。它期望一个逗号分隔的表达式列表。语法模式 `( $( $x: expr ),* )` 匹配逗号分隔的表达式列表，并将结果存储在复数变量
    `$x` 中。在表达式的主体中，有一个单独的块。该块定义了一个新的 `vec`，然后通过迭代 `$x*` 将每个 `$x` 推入 `vec`，最后，该块将其结果作为返回值。以下是在
    `intro_metaprogramming.rs` 文件中的宏及其展开：'
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is important to note that expressions are moved as code, not as values, so
    side effects will be moved to the evaluating context, not the defining context.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，表达式作为代码移动，而不是作为值移动，因此副作用将移动到评估上下文，而不是定义上下文。
- en: 'Recursive macro patterns match against token strings. It is possible to execute
    separate branches depending on which tokens are matched. A simple case match looks
    like the following, in `intro_metaprogramming.rs`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 递归宏模式匹配标记字符串。根据匹配的标记执行不同的分支是可能的。一个简单的匹配案例如下，位于 `intro_metaprogramming.rs` 文件中：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The name recursive macros comes from recursion in the macros, so of course
    we can call into the macro that we are defining. Recursive macros could be a quick
    way to define a domain-specific language. Consider the following code snippet,
    in `intro_metaprogramming.rs`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 递归宏的名字来源于宏中的递归，所以当然我们可以调用我们正在定义的宏。递归宏可以是一种快速定义领域特定语言的途径。考虑以下代码片段，在`intro_metaprogramming.rs`中：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The second form of macro definitions is procedural macros. Recursive macros
    can be thought of as a nice syntax to help define procedural macros. Procedural
    macros, on the other hand, are the most general form. There are many things you
    can do with procedural macros that are simply impossible with the recursive form.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义的第二种形式是过程宏。递归宏可以被认为是一种好的语法，有助于定义过程宏。另一方面，过程宏是最通用的形式。你可以用过程宏做很多递归形式不可能做到的事情。
- en: 'Here, we can grab the `TypeName` of a `struct` and use that to automatically
    generate a trait implementation. Here is the macro definition, in `intro_metaprogramming.rs`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以获取`struct`的`TypeName`，并使用它来自动生成特质实现。以下是宏定义，在`intro_metaprogramming.rs`中：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The corresponding macro invocation looks like the following, in `intro_metaprogramming.rs`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的宏调用在`intro_metaprogramming.rs`中看起来如下：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, procedural macros are a bit more complicated to set up. However,
    the benefit is then that all processing is done directly with normal Rust code.
    These macros permit use of any syntactic information in unstructured format to
    generate more code structures before compilation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，过程宏的设置稍微复杂一些。然而，好处是所有处理都是直接用正常的Rust代码完成的。这些宏允许在编译前以非结构化格式使用任何语法信息来生成更多的代码结构。
- en: Procedural macros are handled as separate modules to be precompiled and executed
    during normal compiler execution. The information provided to each macro is localized,
    so
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏被处理为独立的模块，在正常的编译器执行期间预编译和执行。提供给每个宏的信息是局部化的，所以
- en: whole program consideration is not possible. However, the available local information
    is sufficient to achieve some fairly complicated effects.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序的考虑是不可能的。然而，可用的本地信息足以实现一些相当复杂的效果。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we briefly outlined the major concepts that will appear throughout
    this book. From the code examples, you should now be able to visually identify
    functional style. We also mentioned some of the reasons why these concepts are
    useful. In the remaining chapters, we will provide full context to when and why
    each technique would be appropriate. In that context, we will also provide the
    knowledge required to master the techniques and start using functional practices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要概述了本书中将要出现的主要概念。从代码示例中，你现在应该能够直观地识别函数式风格。我们还提到了一些为什么这些概念有用的原因。在接下来的章节中，我们将提供完整的环境，说明何时以及为什么每种技术是合适的。在那个环境中，我们还将提供掌握这些技术并开始使用函数式实践所需的知识。
- en: From this chapter, we learned to parameterize as much as possible, and that
    functions can be used as parameters, to define complex behavior by combining simple
    behaviors, and that it is safe to use threads however you want in Rust as long
    as it compiles.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中，我们学会了尽可能地进行参数化，并且知道函数可以用作参数，通过组合简单行为来定义复杂行为，并且在Rust中只要编译通过，就可以随意使用线程。
- en: This book is structured to introduce simpler concepts first, then, as the book
    continues, some concepts may become more abstract or technical. Also, all techniques
    will be introduced in the context of an ongoing project. The project will control
    an elevator system, and the requirements will gradually become more demanding
    as the book progresses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的结构是先介绍简单的概念，然后随着书的继续，一些概念可能会变得更加抽象或技术化。此外，所有技术都将在一个持续的项目环境中介绍。该项目将控制电梯系统，随着书的进展，需求将逐渐变得更加严格。
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a function?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数是什么？
- en: What is a functor?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函子是什么？
- en: What is a tuple?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是元组？
- en: What control flow expression was designed for use with tagged unions?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为标记联合设计了哪种控制流表达式？
- en: What is the name for a function with a function as a parameter?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数作为参数的函数叫什么名字？
- en: How many times will `fib` be called in memoized `fib(20)`?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在记忆化的`fib(20)`中，`fib`会被调用多少次？
- en: What datatypes can be sent over a channel?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过通道发送哪些数据类型？
- en: Why do functions need to be boxed when returned from a function?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么函数在从函数返回时需要装箱？
- en: What does the `move` keyword do?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`move`关键字的作用是什么？'
- en: How could two variables share ownership of a single variable?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个变量怎么可能共享一个单一变量的所有权？
- en: Further reading
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has many other great resources for learning Rust:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Packt 为学习 Rust 提供了许多其他优秀资源：
- en: '[https://www.packtpub.com/application-development/rust-programming-example](https://www.packtpub.com/application-development/rust-programming-example)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/rust-programming-example](https://www.packtpub.com/application-development/rust-programming-example)'
- en: '[https://www.packtpub.com/application-development/learning-rust](https://www.packtpub.com/application-development/learning-rust)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/learning-rust](https://www.packtpub.com/application-development/learning-rust)'
- en: 'For basic documentation and a tutorial, please refer here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本文档和教程，请参考此处：
- en: 'Tutorial: [https://doc.rust-lang.org/book/first-edition/](https://doc.rust-lang.org/book/first-edition/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：[https://doc.rust-lang.org/book/first-edition/](https://doc.rust-lang.org/book/first-edition/)
- en: Documentation: [https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档：[https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/)
