- en: Functional Programming – a Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programm****ing** (**FP**) is the second most popular programming
    paradigm, behind only **obje****ct-oriented programming** (**OOP**). For many
    years, these two paradigms have been separated into different languages, so as
    not to be mixed. Multi-paradigm languages have attempted to support both approaches.
    Rust is one such language.'
  prefs: []
  type: TYPE_NORMAL
- en: As a broad definition, functional programming emphasizes the use of composable
    and maximally reusable functions to define program behavior. Using these techniques,
    we will show how functional programming has adapted clever solutions to many common
    yet difficult problems. This chapter will outline most of the concepts presented
    in this book. The remaining chapters will be dedicated to helping you master each
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'The learning outcomes we hope to provide are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to use functional style to reduce code weight and complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to write robust safe code by utilizing safe abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to engineer complex projects using functional principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided, and can
    be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing code weight and complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming can greatly reduce the amount and complexity of code
    required to accomplish tasks. Particularly in Rust, proper application of functional
    principles may simplify the often complex design requirements, and make programming
    a much more productive and rewarding experience.
  prefs: []
  type: TYPE_NORMAL
- en: Making generics more generic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making generics more generic relates to the practice of parameterizing data
    structures and functions originated in functional languages. In Rust, and other
    languages, this is called **generics**. Types and functions can all be parameterized.
    One or more constraints may be placed on generic types to indicate requirements
    of a trait or lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Struct definitions can become redundant without generics. Here is a definition
    of three structs that define a common concept of a `Point`. However, the structs
    use different numerical types, so the singular concept is expanded into three
    separate `PointN` type definitions in `intro_generics.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Instead, we can use generics to remove duplicate code and make the code more
    robust. Generic code is more easily adaptable to new requirements because many
    behaviors (and thus requirements) can be parameterized. If a change is needed,
    it is better to only change one line rather than a hundred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet defines a parameterized `Point` struct. Now, a single definition
    can capture all possible numerical types for a `Point` in `intro_generics.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Functions are also problematic without generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple function to square a number. However, to capture possible
    numerical types, we define three different functions in `intro_generics.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Function parameters, such as this one, may need trait bounds (a constraint specifying
    one or more traits) to permit any behavior on that type that is used in the function
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `foo` function, redefined with a parameterized type. A single function
    can define the operation for all numerical types. Explicit bounds must be set
    for even basic operations, such as multiply or even copy, in `intro_generics.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even functions can be sent as parameters. We call these higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a trivial function that accepts a function and argument, then calls
    the function with the argument, returning the result. Note the trait bound  `Fn`,
    indicating that the provided function is a closure. For an object to be callable,
    it must implement one of the `fn`, `Fn`, `FnMut`, or `FnOnce` traits in `intro_generics.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Functions as values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are nominally the big feature of functional programming. Specifically,
    functions as values are the keystone of the whole paradigm. Glossing over much
    detail, we will also introduce the term **closure** here for future reference.
    A closure is an object that acts as a function, implementing `fn`, `Fn`, `FnMut`,
    or `FnOnce`.
  prefs: []
  type: TYPE_NORMAL
- en: Simple closures can be defined with the built-in closure syntax. This syntax
    is also beneficial because the `fn`, `Fn`, `FnMut`, and `FnOnce` traits are automatically
    implemented if permitted. This syntax is great for shorthand manipulation of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an iterator over the range `0` to `10`, mapped to the squared value.
    The square operation is applied using an inline closure definition sent to the
    `map` function of the iterator. The result of this expression will be an iterator.
    Here is an expression in `intro_functions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Closures can also have complex bodies with statements if the block syntax is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an iterator from `0` to `10`, mapped with a complex equation. The closure
    provided to map includes a function definition and a variable binding in `intro_functions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to define functions or methods that accept closures as arguments.
    To use the closure as a callable function, a bound of `Fn`, `FnMut`, or `FnOnce`
    must be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a HoF definition accepting a function `g` and an argument `x`. The
    definition constrains `g` and `x` to process `u32` types, and defines some mathematical
    operations involving calls to `g`. An invocation of the `f` HoF is also provided,
    as follows, using a simple inline closure definition in `intro_functions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Many parts of the standard library, particularly iterators, encourage heavy
    use of functions as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an iterator from `0` to `10` followed by many chained iterator combinators.
    The `map` function returns a new value from an original. `inspect` looks at a
    value, does not change it, but permits side-effects. `filter` omits all values
    that do not satisfy a predicate. `filter_map` filters and maps with a single function.
    The `fold` reduces all results to a single value, starting from an initial value,
    working left to right. Here is the expression in `intro_functions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterators are a common feature of OOP languages, and Rust supports this concept
    well. Rust iterators are also designed with functional programming in mind, allowing
    programmers to write more legible code. The specific concept emphasized here is
    **composability**. When iterators can be manipulated, transformed, and combined,
    the mess of `for` loops can be replaced by individual function calls. These examples
    can be found in the `intro_iterators.rs` file. This is depicted in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name with description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Chain concatenates two iterators: `first...second` | `(0..10).chain(10..20);`
    |'
  prefs: []
  type: TYPE_TB
- en: '| The `zip` function combines two iterators into tuple pairs, iterating until
    the end of the shortest iterator: (a1,b1), (a2, b2), ... | `(0..10).zip(10..20);`
    |'
  prefs: []
  type: TYPE_TB
- en: '| The `enumerate` function is a special case of `zip` that creates numbered
    tuples (0, a1),(1,a2), … | `(0..10).enumerate();` |'
  prefs: []
  type: TYPE_TB
- en: '| The `inspect` function applies a function to all values in the iterator during
    iteration | `(0..10).inspect(&#124;x&#124;{ println!("value {}", *x) });` |'
  prefs: []
  type: TYPE_TB
- en: '| The `map` function applies a function to each element, returning the result
    in place | `(0..10).map(&#124;x&#124; x*x);` |'
  prefs: []
  type: TYPE_TB
- en: '| The `filter` function restricts elements to those satisfying a predicate
    | `(0..10).filter(&#124;x&#124; *x<3);` |'
  prefs: []
  type: TYPE_TB
- en: '| The `fold` function accumulates all values into a single result | `(0..10).fold(0,
    &#124;x,y&#124; x+y);` |'
  prefs: []
  type: TYPE_TB
- en: '| When you want to apply the iterator, you can use a `for` loop or call `collect`
    | `for i in (0..10) {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(0..10).collect::<Vec<u64>>();` |'
  prefs: []
  type: TYPE_NORMAL
- en: Compact legible expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional languages, all terms are expressions. There are no statements
    in function bodies, only a single expression. All control flow operators are then
    formulated as expressions with a return value. In Rust, this is almost the case;
    the only non-expressions are `let` statements and item declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these statements can be wrapped in blocks to create an expression along
    with any other term. An example for this is the following, in `intro_expressions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This nested format is uncommon in the wild, but it illustrates the permissive
    nature of Rust grammar.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the concept of functional style expressions, the emphasis should
    always be on writing legible literate code without much hassle or bloat. When
    someone else, or you at a later time, comes to read your code, it should be immediately
    understandable. Ideally, the  code should document itself. If you find yourself
    constantly writing code twice, once in code and again as comments, then you should
    reconsider how effective your programming practices really are.
  prefs: []
  type: TYPE_NORMAL
- en: To start with some examples of functional expressions, let's look at an expression
    that exists in most languages, the ternary conditional operator. In a normal `if`
    statement, the condition must occupy its own line and thus cannot be used as a
    sub-expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a traditional `if` statement, initializing a variable in `intro_expressions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the ternary operator, this assignment can be moved to a single line, shown
    as follows in `intro_expressions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost every statement from OOP in Rust is also an expression—`if`, `for`,
    `while`, and so on. One of the more unique expressions to see in Rust that is
    uncommon in OOP languages is direct constructor expressions. All Rust types can
    be instantiated by single expressions. Constructors are only necessary in specific
    cases, for example, when an internal field requires complex initialization. The
    following is a simple `struct` and an equivalent tuple in `intro_expressions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Another distinctive expression from functional languages is pattern matching.
    Pattern matching can be thought of as a more powerful version of a `switch` statement.
    Any expression can be sent into a pattern expression and de-structured to bind internal
    information into local variables before executing a `branch` expression. Pattern
    expressions are uniquely suited for working with enums. The two make a perfect
    pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet defines a `Term` as a tagged union of expression options.
    In the main function, a `Term` `t` is constructed, then matched with a pattern
    expression. Note the syntax similarity between the definition of a tagged union
    and the matching inside of a pattern expression in `intro_expressions.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Strict abstraction means safe abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a stricter type system does not imply that code will have more requirements
    or be any more complex. Rather than strict typing, consider using the term expressive
    typing. Expressive typing provides more information to the compiler. This extra
    information allows the compiler to provide extra assistance while programming.
    This extra information also permits a very rich metaprogramming system. This is
    all in addition to the obvious benefit of safer, more robust code.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables in Rust are treated much more strictly than in most other languages.
    Global variables are almost entirely disallowed. Local variables are put under
    close watch to ensure that allocated data structures are properly deconstructed
    before going out of scope, but not sooner. This concept of tracking a variable's
    proper scope is known as **ownership** and **lifetime**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simple example, data structures that allocate memory will deconstruct
    automatically when they go out of scope. No manual memory management is required
    in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In a slightly more complex example, allocated data structures can be passed
    around as return values, or referenced, and so on. These exceptions to simple
    scoping must also be accounted for in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This usage tracking can get complicated (and undecidable), so Rust has some
    rules that restrict when a variable can escape a context. We call this **complex
    rules ownership**. It can be explained with the following code, in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When it is not possible or desirable to transfer ownership, the `clone` trait
    is encouraged to create a duplicate copy of whatever data is referenced in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Cloning or copying is not a perfect solution, and comes with a performance
    overhead. To make Rust faster, and it is pretty fast, we also have the concept
    of borrowing. Borrowing is a mechanism to receive a direct reference to some data
    with the promise that ownership will be returned by some specific point. References
    are indicated by an ampersand. Consider the following example, in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another benefit of strict ownership is safe concurrency. Each binding is owned
    by a particular thread, and that ownership can be transferred to new threads with
    the `move` keyword. This has been explained with the following code, in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To share information between threads, programmers have two main options.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, programmers may use the traditional combination of locks and atomic
    references. This is explained with the following code, in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, channels provide a nice mechanism for message passing and job queuing
    between threads. The `send` trait is also implemented automatically for most objects.
    Consider the following code, in `intro_binding.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All of this concurrency is type-safe and compiler-enforced. Use threads as much
    as you want, and if you accidentally try to create a race condition or simple
    deadlock, then the compiler will stop you. We call this **fearless concurrency**.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to structs/objects and functions/methods, Rust functional programming
    includes some rich additions to definable types and structures. Tuples provide
    a shorthand for defining simple anonymous structs. Enums provide a type-safe approach
    to unions of complex data structures with the added bonus of a constructor tag
    to help in pattern matching. The standard library has extensive support for generic
    programming, from base types to collections. Even the object system traits are
    a hybrid cross between the OOP concept of a class and the FP concept of type classes.
    Functional style lurks around every corner, and even if you don't seek them in
    Rust, you will probably find yourself unknowingly using the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `type` aliases can be helpful to create shorthand names for complex types.
    Alternatively, the `newtype` struct pattern can be used to create an alias with
    different non-equivalent types. Consider the following example, in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A `struct`, even when parameterized, can be repetitive when used simply to
    store multiple values into a single object. This can be seen in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A tuple helps eliminate redundant struct definitions. No prior type definitions
    are necessary to use tuples. Consider the following example, in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard operators can be implemented for any type by implementing the correct
    trait. Consider the following example for this, in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard library collections and many other built-in types are generic, such as
    `HashMap` in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Enums are a type-safe union of multiple types. Note that recursive `enum` definitions
    must wrap the inner value in a container such as `Box`, otherwise the size would
    be infinite. This is depicted as follows, in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Tagged unions are also used for more complex data structures. Consider the
    following code, in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Traits are a bit like object classes (OOP), shown with the following code example,
    in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Traits are also like type classes (FP), shown with the following code snippet,
    in `intro_datatypes.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Mixing object-oriented programming and functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, Rust supports much of both object-oriented and functional
    programming styles. Datatypes and functions are neutral to either paradigm. Traits
    specifically support a hybrid blend of both styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in an object-oriented style, defining a simple class with a constructor
    and some methods can be accomplished with a `struct`, `trait`, and `impl`. This
    is explained using the following code snippet, in `intro_mixoopfp.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding support for functional programming onto an object is as simple as defining
    traits and methods that use functional language features. For example, accepting
    a closure can become a great abstraction when used appropriately. Consider the
    following example, in `intro_mixoopfp.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Improving project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programs encourage good project architecture and principled design
    patterns. Using the building blocks of functional programming often reduces the
    number of design choices to be made in such a way that good options become obvious.
  prefs: []
  type: TYPE_NORMAL
- en: '"There should be one - and preferably only one - obvious way to do it."'
  prefs: []
  type: TYPE_NORMAL
- en: – *PEP 20*
  prefs: []
  type: TYPE_NORMAL
- en: File hierarchy, modules, and namespace design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust programs are compiled primarily in one of two ways. The first is to use
    `rustc` to compile individual files. The second is to describe an entire package
    for compilation using `cargo`. We will assume here that projects are built using
    `cargo`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a package, you first create a `Cargo.toml` file in a directory. That
    directory will be your package directory from now on. This is a configuration
    file that will tell the compiler what code, assets, and extra information should
    be included into the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After this basic configuration, you can now use `cargo build` to compile the
    entire project. Where you decide to place your code files, and what to name them,
    is determined by how you want to refer to them in the module namespace. Each file
    will be given its own module `mod`. You can also nest modules inside files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After these steps, projects can then be added as cargo dependencies, and namespaces
    can be used inside of modules to expose public symbols. Consider the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These are the basic building blocks of Rust modules, but what does this have
    to do with functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: Architecting a project in functional style is a process, and lends itself to
    certain routines. Typically, the project architect will start by designing the
    core data structures and in complex cases also the physical structure (where code/services
    will operationally be run). Once the data layout has been outlined in sufficient
    detail, then core functions/routines can be planned (such as how the program behaves).
    Up to this point, there may be code left unimplemented if coding is happening
    during the architecting stage. The final stage involves replacing this mock code
    with correct behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this stage-by-stage development process, we can also see an archetypical
    file layout forming. It is common to see these stages written top to bottom in
    actual programs. Though it is unlikely the authors went through planning in these
    explicit stages, it still is a common pattern due to simplicity''s sake. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Grouping definitions like this may be helpful to standardize file layout and
    improve readability. Searching back and forth through a long file for symbol definitions
    is a common but unpleasant part of programming. It is also a preventable problem.
  prefs: []
  type: TYPE_NORMAL
- en: Functional design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aside from file layout, there are a number of functional design patterns that
    help reduce code weight and redundancy. When used properly, these principles can
    help clarify design decisions and also enable robust architecture. Most design
    patterns are variants of the single responsibility principle. This can take many
    forms depending on the context, but the intent is the same; write code that does
    one thing well, then reuse that code as needed. I have explained this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions**: These are functions with no side effects or logical dependencies
    other than function arguments. A side effect is a change of state that affects
    anything outside of the function, aside from the return value. Pure functions
    are useful because they can be tossed around and combined and generally used carelessly
    without the risk of unintended effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The worst thing that can go wrong with a pure function is a bad return value
    or, in extreme cases, a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is harder to cause bugs with pure functions, even when used recklessly.
    Consider the following example of pure functions, in `intro_patterns.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Immutability**: Immutability is a pattern that helps encourage pure functions.
    Rust variable bindings are immutable by default. This is Rust''s not-so-subtle
    way of encouraging you to avoid mutable state. Don''t do it. If you absolutely
    must, it is possible to tag variables with the `mut` keyword to allow reassignment.
    This is shown with the following example, in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Functional composition**: Functional composition is a pattern where the output
    of one function is connected to the input of another function. In this fashion,
    functions can be chained together to create complex effects from simple steps.
    This is shown with the following code snippet, in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Higher-order functions**: These have already been mentioned before, but we
    haven''t used the term yet. A HoF is a function that accepts a function as a parameter.
    Many iterator methods are HoFs. Consider the following example, in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Functors**: If you can get past the name, these are a simple and effective
    design pattern. They are also very versatile. The concept is somewhat difficult
    to capture in its entirety, but you may think of functors as *the inverse of functions*.
    A function defines a transformation, accepts data, and returns the result of the
    transformation. A functor defines data, accepts a function, and returns the result
    of the transformation. A common example of a functor is the bound `map` method
    that frequently appears on containers, such as for a `Vec`. Here is an example,
    in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '"A monad is a monoid in the category of endofunctors, what''s the problem?"'
  prefs: []
  type: TYPE_NORMAL
- en: – *Philip Wadler*
  prefs: []
  type: TYPE_NORMAL
- en: '**Monads**: Monads are a common stumbling block for people learning FP. Monads
    and functors are maybe the first words that you may encounter on a journey that
    goes deep into theoretical mathematics. We won''t go there. For our purposes,
    monads are simply a `trait` with two methods. This is shown in the following code,
    in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If that doesn't help clarify things (and it probably doesn't), a monad has two
    methods. The first method is the constructor. The second method lets you bind
    an operation to create another monad. Many common traits have hidden semi-monads
    but, by making the concept explicit, the concept becomes a strong design pattern
    instead of a messy anti-pattern. Don't try to reinvent what you don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function currying**: Function currying is a technique that may seem strange
    for anyone coming from a background in object-oriented or imperative languages.
    The reason for this confusion is that in many functional languages, functions
    are curried by default, whereas this is not the case for other languages. Rust
    functions are not curried by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The difference between curried and non-curried functions are that curried functions
    send in parameters one by one, whereas non-curried functions send in parameters
    all at once. Looking at a normal Rust function definition, we can see that it
    is not curried. Consider the following code, in `intro_patterns.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A `curried` function takes each parameter one by one, as shown in the following,
    in `intro_patterns.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Curried functions can be used as a function factory. The first few arguments
    configure how the final function should behave. The result is a pattern that allows
    shorthand configuration of complex operators. Currying complements all the other
    design patterns by converting individual functions into multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation**: Lazy evaluation is a pattern that is technically possible
    in other languages. However, it is uncommon to see it outside of FP, due to language
    barriers. The difference between a normal expression and a lazy expression is
    that a lazy expression will not be evaluated until accessed. Here is a simple implementation
    of laziness, implemented behind a function call in `intro_patterns.rs`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second expression will not be evaluated until the function is called, at
    which point the code resolves. For lazy expressions, side effects happen at time
    of resolution instead of at initialization. This is a poor implementation of laziness,
    so we will go into further detail in later chapters. The pattern is fairly common,
    and some operators and data structures require laziness to work. A simple example
    of necessary laziness is a lazy list that may not otherwise be possible to create.
    The built-in Rust numerical iterator (lazy list) uses this well: `(0..)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoization is the last pattern that we will introduce here. It may be considered
    as more of an optimization than design pattern, but due to how common it is, we
    should mention it here. A memoized function only computes unique results once.
    A simple implementation would be a function guarded by a hash table. If the parameters
    and result are already in the hash table, then skip the function call and directly
    return the result from the hash table. Otherwise, compute the result, put it in
    the hash table, and return. This process can be implemented manually in any language,
    but Rust macros allow us to write the memoization code once, and reuse that code
    by applying this macro. This is shown using the following code snippet, in `intro_patterns.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This example makes use of two crates and many macros. We won't fully explain
    everything that is happening here until the very end of this book. There is much
    that is possible with macros and metaprogramming. Caching function results is
    just a start.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term metaprogramming in Rust often overlaps with the term macros. There
    are two primary types of macros available in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both types of macros take as input an **abstract syntax tree** (**AST**), and
    produce one or more AST.
  prefs: []
  type: TYPE_NORMAL
- en: 'A commonly used macro is `println`. A variable number of arguments and types
    are joined with the format string through the use of a macro to produce formatted
    output. To invoke recursive macros like this, invoke the macro just like a function
    with the addition of a `!` before the arguments. Macro applications may alternatively
    be surrounded by `[]` or `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursive macros are defined by `macro_rules!` statements. The inside of a
    `macro_rules` definition is very similar to that of a pattern-matching expression.
    The only difference is that `macro_rules!` matches syntax instead of data. We
    can use this format to define a reduced version of the `vec` macro. This is shown
    in the following code snippet, in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition accepts and matches only one pattern. It expects a comma-separated
    list of expressions. The syntax pattern `( $( $x: expr ),* )` matches against
    a comma-separated list of expressions and stores the result in the plural variable
    `$x`. In the body of the expression, there is a single block. The block defines
    a new `vec`, then iterates through `$x*` to push each `$x` into the `vec`, and,
    finally, the block returns the `vec` as its result. The macro and its expansion
    are as follows, in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that expressions are moved as code, not as values, so
    side effects will be moved to the evaluating context, not the defining context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursive macro patterns match against token strings. It is possible to execute
    separate branches depending on which tokens are matched. A simple case match looks
    like the following, in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The name recursive macros comes from recursion in the macros, so of course
    we can call into the macro that we are defining. Recursive macros could be a quick
    way to define a domain-specific language. Consider the following code snippet,
    in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The second form of macro definitions is procedural macros. Recursive macros
    can be thought of as a nice syntax to help define procedural macros. Procedural
    macros, on the other hand, are the most general form. There are many things you
    can do with procedural macros that are simply impossible with the recursive form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can grab the `TypeName` of a `struct` and use that to automatically
    generate a trait implementation. Here is the macro definition, in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding macro invocation looks like the following, in `intro_metaprogramming.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, procedural macros are a bit more complicated to set up. However,
    the benefit is then that all processing is done directly with normal Rust code.
    These macros permit use of any syntactic information in unstructured format to
    generate more code structures before compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural macros are handled as separate modules to be precompiled and executed
    during normal compiler execution. The information provided to each macro is localized,
    so
  prefs: []
  type: TYPE_NORMAL
- en: whole program consideration is not possible. However, the available local information
    is sufficient to achieve some fairly complicated effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly outlined the major concepts that will appear throughout
    this book. From the code examples, you should now be able to visually identify
    functional style. We also mentioned some of the reasons why these concepts are
    useful. In the remaining chapters, we will provide full context to when and why
    each technique would be appropriate. In that context, we will also provide the
    knowledge required to master the techniques and start using functional practices.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter, we learned to parameterize as much as possible, and that
    functions can be used as parameters, to define complex behavior by combining simple
    behaviors, and that it is safe to use threads however you want in Rust as long
    as it compiles.
  prefs: []
  type: TYPE_NORMAL
- en: This book is structured to introduce simpler concepts first, then, as the book
    continues, some concepts may become more abstract or technical. Also, all techniques
    will be introduced in the context of an ongoing project. The project will control
    an elevator system, and the requirements will gradually become more demanding
    as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What control flow expression was designed for use with tagged unions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name for a function with a function as a parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many times will `fib` be called in memoized `fib(20)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What datatypes can be sent over a channel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do functions need to be boxed when returned from a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `move` keyword do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could two variables share ownership of a single variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has many other great resources for learning Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/rust-programming-example](https://www.packtpub.com/application-development/rust-programming-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/learning-rust](https://www.packtpub.com/application-development/learning-rust)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For basic documentation and a tutorial, please refer here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tutorial: [https://doc.rust-lang.org/book/first-edition/](https://doc.rust-lang.org/book/first-edition/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation: [https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
