<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with Rust</h1>
                
            
            
                
<p>Learning a new language is like building a house – the foundation needs to be strong. With a language that changes the way you think and reason about your code, there's always more effort involved in the beginning, and it's important to be aware of that. The end result, however, is that you get to shift your thinking with these new-found concepts and tools.</p>
<p>This chapter will give you a whirlwind tour on the design philosophy of Rust, an overview of its syntax and the type system. We assume that you have a basic knowledge of mainstream languages such as C, C++, or Python, and the ideas that surround object-oriented programming. Each section will contain example code, along with an explanation of it. There will be ample code examples and output from the compiler, that will help you become familiar with the language. We'll also delve into a brief history of the language and how it continues to evolve.</p>
<p>Getting familiar with a new language requires perseverance, patience, and practice. I highly recommend to all readers that you manually write and don't copy/paste the code examples listed here. The best part of writing and fiddling with Rust code is the precise and helpful error messages you get from the compiler, which the Rust community often likes to call error-driven development. We'll see these errors frequently throughout this book to understand how the compiler thinks of our code.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is Rust and why should you care?</li>
<li>Installing the Rust compiler and the toolchain</li>
<li>A brief tour of the language and its syntax</li>
<li>A final exercise, where we'll put what we've learned together</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">What is Rust and why should you care?</h1>
                
            
            
                
<p>" Rust is technology from the past came to save the future from itself. "<br/>
<em>                                                                                                                                                                                                                                                                                                                                                                                                                                               - Graydon Hoare</em></p>
<p>Rust is a fast, concurrent, safe, and empowering programming language originally started and developed by <em>Graydon Hoare</em> in ­2006. It's now an open source language that's developed mainly by a team from Mozilla with collaboration from lots of open source folks. The first stable version, 1.0, was released in May 2015. The project began with the hope of mitigating memory safety issues that came up in <strong>gecko</strong> with the use of C++. Gecko is the browser engine that's used in Mozilla's Firefox browser. C++ is not an easy language to tame and has concurrency abstractions that can be easily misused. With gecko using C++, a couple of attempts were made (in 2009 and 2011) to parallelize its <strong>cascading style sheets</strong> (<strong>CSS</strong>) parsing code to leverage modern parallel CPUs. They failed, as the concurrent C++ code was too hard to maintain and reason about. With a large number of developers collaborating on the mammoth code base that gecko has, writing concurrent code with C++ is not a joyride. In the hope of incrementally removing the painful parts of C++, Rust was born and, with it, Servo, a new research project of creating a browser engine from scratch was initiated. The Servo project provides feedback to the language team by using the bleeding edge language features that, in turn, influences the evolution of the language. Around November 2017, parts of the Servo project, particularly the <strong>stylo</strong> project (a parallel CSS parser in Rust) started shipping to the latest Firefox release (Project Quantum), which is a great feat in such a short amount of time. Servo's end goal is to incrementally replace components in gecko with its components.</p>
<p class="mce-root">Rust is inspired by a multitude of languages, the notable ones being Cyclone (a safe dialect of C language) for its ideas on region-based memory management techniques; C++ for its RAII principle, and Haskell for its type system, error handling types, and typeclasses.</p>
<div><strong>RAII</strong> stands for <strong>Resource Acquisition Is Initialization</strong>, a paradigm suggesting that resources must be acquired during the initialization of an object and must be released when their destructors are called or when they are deallocated.</div>
<p class="mce-root">The language has a very minimal runtime, does not need garbage collection, and prefers stack allocation by default over heap allocation (an overhead) for any value that's declared in a program. We'll explain all of this in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory Management and Safety</em>. The Rust compiler, <strong>rustc</strong>, was originally written in Ocaml (a functional language) and became a self-hosting one in 2011 after being written in itself.</p>
<p>Self-hosting is when a compiler is built by compiling its own source code. This process is known as bootstrapping a compiler. Compiler its own source code acts as a really good test case for the compiler.</p>
<p class="mce-root">Rust is openly developed on GitHub at <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a> and continues to evolve at a fast pace. New features are added to the language through a community-driven <strong>Request For Comments</strong> (<strong>RFC</strong>) process where anybody can propose new language features. These are then described in detail in an RFC document. A consensus is then sought after for the RFC and if agreed upon, the implementation phase begins for the feature. The implemented feature then gets reviewed by the community, where it is eventually merged to the master branch after undergoing several tests by users in nightly releases. Getting feedback from the community is crucial for the language's evolution. Every six weeks, a new stable version of the compiler is released. Along with fast moving incremental updates, Rust also has this notion of editions, which is proposed to provide a consolidated update to the language. This includes tooling, documentation, its ecosystem, and to phase in any breaking changes. So far, there have been two editions: <em>Rust 2015</em>, which had a focus on stability, and <em>Rust 2018</em>, which is the current edition at the time of writing this book and focuses on productivity.</p>
<p>While being a general purpose multi-paradigm language, it is aiming for systems programming domain where C and C++ have been predominant. This means that you can write operating systems, game engines, and many performance critical applications with it. At the same time, it is also expressive enough that you can build high-performance web applications, network services, type-safe database <strong>Object Relational Mapper</strong> (<strong>ORM</strong>) libraries, and can also run on the web by compiling down to WebAssembly. Rust has also gained a fair share of interest in building safety-critical, real-time applications for embedded platforms such as the Arm's Cortex-M based microcontrollers, a domain mostly dominated by C at present. This gamut of applicability in various domains – which Rust exhibits quite well – is something that very rare to find in a single programming language. Moreover, established companies Cloudflare, Dropbox<em>,</em> Chuckfish<em>,</em> npm,<em> </em>and many more are already using it in production for their high-stakes projects.</p>
<p>Rust is characterized as a statically and strongly typed language. The static property means that the compiler has information about all of the variables and their types at compile time and does most of its checks at compile time, leaving very minimal type checking at runtime. Its strong nature means that it does not allow things such as auto-conversion between types, and that a variable pointing to an integer cannot be changed to point to a string later in code. For example, in weakly typed languages such as JavaScript, you can easily do something like <kbd>two = "2"; two = 2 + two;</kbd>. JavaScript weakens the type of <kbd>2</kbd> to be a string at runtime, thus storing <kbd>22</kbd> as a string in <kbd>two</kbd>, something totally contrary to your intent and meaningless. In Rust, the same code, that is, <kbd>let mut two = "2"; two = 2 + two;</kbd>, would get caught at compile time, throwing the following error: <kbd>cannot add `&amp;str` to `{integer}`</kbd>. This property enables safe refactoring of code and catches most bugs at compile time rather than causing issues at runtime.</p>
<p>Programs written in Rust are very expressive as well as performant, in the sense that you can have most of the features of high-level functional style languages such as higher-order functions and lazy iterators, yet it compiles down to efficient code like a C/C++ program. The defining principles that underline many of its design decisions are compile-time memory safety, fearless concurrency, and zero cost abstractions. Let's elaborate on these ideas.</p>
<p><strong>Compile time memory safety</strong>: The Rust compiler can track variables owning a resource in your program at compile time and does all of this without a garbage collector.</p>
<p>Resources can be memory address, a variable holding a value, shared memory reference, file handles, network sockets, or database connection handles.</p>
<p>This means that you can't have infamous problems with pointers use after free, double free, or dangling pointers at runtime. Reference types in Rust (types with <kbd>&amp;</kbd> before them) are implicitly associated with a lifetime tag (<kbd>'foo</kbd>) and sometimes annotated explicitly by the programmer. Through lifetimes, the compiler can track places in code where a reference is safe to use, reporting an error at compile time if it's illegal. To achieve this, Rust runs a borrow/reference checking algorithm by using these lifetime tags on references to ensure that you can never access a memory address that has been freed. It also does this so that you cannot free any pointer while it is being used by some other variable. We will go into the details of this in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory management and Safety</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><strong>Zero-cost abstractions</strong>: Programming is all about managing complexity, which is facilitated by good abstractions. Let's go through a fine example of abstraction in both Rust and Kotlin (a language targeting <strong>Java virtual machines</strong> (<strong>JVM</strong>) that lets us write high-level code and is easy to read and reason about. We'll compare Kotlin's streams and Rust's iterators in manipulating a list of numbers and contrast the zero cost abstraction principle that Rust provides. The abstraction here is to be able to use methods that take other methods as arguments to filter numbers based on a condition without using manual loops. Kotlin is used here for its visual similarity with Rust. The code is fairly simple to understand and we aim to give a high-level explanation. We'll be glossing over the details in code as the whole point of this example is to understand the zero cost property.</p>
<p>First, let's look at the code in Kotlin (the following code can be run online: <a href="https://try.kotlinlang.org/#/UserProjects/p1dcj8hnumcloa96jsq9t8q8ba/bjptps10adpigeoe1k4bdg1m46" target="_blank">https://try.kotlinlang.org</a>):</p>
<pre class="mce-root">1. import java.util.stream.Collectors<br/>2. <br/>3. fun main(args: Array&lt;String&gt;) {<br/>5.     // Create a stream of numbers<br/>6.     val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).stream()<br/>7.     val evens = numbers.filter { it -&gt; it % 2 == 0 } <br/>8.     val evenSquares = evens.map { it -&gt; it * it }  <br/>9.     val result = evenSquares.collect(Collectors.toList())<br/>10.    println(result)       // prints [4,16,36,64,100]<br/>11.    <br/>12.    println(evens)<br/>13.    println(evenSquares)<br/>14. }</pre>
<p class="mce-root">We create a stream of numbers (line 6) and call a chain of methods (<kbd>filter</kbd> and <kbd>map</kbd>) to transform the elements to collect only squares of even numbers. These methods can take a closure or a function (that is, <kbd>it -&gt; it * it</kbd> at line 8) to transform each element in the collection. In functional style languages, when we call these methods on the stream/iterator, for every such call, the language creates an intermediate object to keep any state or metadata in regard to the operation being performed. As a result, <kbd>evens</kbd> and <kbd>evenSquares</kbd> will be two different intermediate objects that are allocated on the JVM heap. Allocating things on the heap incurs a memory overhead. That's the extra cost of abstraction we have to pay in Kotlin !</p>
<p class="mce-root">When we print the value of <kbd>evens</kbd> and <kbd>evenSquares</kbd>, we indeed get different objects, as show here:</p>
<p class="mce-root"><kbd>java.util.stream.ReferencePipeline$Head@51521cc1</kbd> </p>
<p class="mce-root"><kbd>java.util.stream.ReferencePipeline$3@1b4fb997</kbd></p>
<p>The hex value after the <kbd>@</kbd> is the object's hash code on the JVM. Since the hash codes are different, they are different objects.</p>
<p>In Rust, we do the same thing (the following code can be run online: <a href="https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa">https://gist.github.com/rust-play/e0572da05d999cfb6eb802d003b33ffa</a>):</p>
<pre class="mce-root">1. fn main() {<br/>2.     let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter();<br/>3.     let evens = numbers.filter(|x| *x % 2 == 0);<br/>4.     let even_squares = evens.clone().map(|x| x * x);<br/>5.     let result = even_squares.clone().collect::&lt;Vec&lt;_&gt;&gt;();<br/>6.     println!("{:?}", result);      // prints [4,16,36,64,100]<br/>7.     println!("{:?}\n{:?}", evens, even_squares);<br/>8. }</pre>
<p class="mce-root">Glossing over the details, on line 2 we call <kbd>vec![]</kbd> to create a list of numbers on the heap, followed by calling <kbd>into_iter()</kbd> to make it a iterator/stream of numbers. The <kbd>into_iter()</kbd> method creates a wrapper Iterator type, <kbd>IntoIter([1,2,3,4,5,6,7,8,9,10])</kbd>, out of a collection (here, <kbd>Vec &lt;i32&gt;</kbd> is a list of signed 32 bit integers). This iterator type references the original list of numbers. We then perform filter and map transformations (lines 3 and 4), just like we did in Kotlin. Lines 7 and 8 print the type of <kbd>evens</kbd> and <kbd>even_squares</kbd>, as follows (some details have been omitted for brevity):</p>
<table style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><kbd>evens:<br/></kbd></td>
<td><kbd> Filter { iter: IntoIter( &lt;numbers&gt; ) } </kbd></td>
</tr>
<tr>
<td><kbd>even_squares:</kbd></td>
<td><kbd> Map { iter: Filter { iter: IntoIter( &lt;numbers&gt; ) }}</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The intermediate objects, <kbd>Filter</kbd> and <kbd>Map</kbd>, are wrapper types (not allocated on the heap) on the base iterator structure, which itself is a wrapper that holds a reference to the original list of numbers at line 2. The wrapper structures on lines 4 and 5 that get created on calling <kbd>filter</kbd> and <kbd>map</kbd>, respectively, do not have any pointer indirection in between and impose no heap allocation overhead, as was the case with Kotlin. All of this boils down to efficient assembly code, which would be equivalent to the manually written version using loops.</p>
<p><strong>Fearless concurrency</strong>: When we said Rust is concurrent-safe, we meant that the language has <strong>Application Programming Interface</strong> (<strong>API</strong>) and abstractions that make it really easy to write correct and safe concurrent code. Contrasting this with C++, the possibility of making mistakes in concurrent code is quite high. When synchronizing data access to multiple threads in C++, you are responsible for calling <kbd>mutex.lock()</kbd> every time you enter the critical section, and <kbd>mutex.unlock()</kbd> when you exit this section:</p>
<pre class="mce-root">// C++<br/><br/>mutex.lock();                         // Mutex locked, good to go <br/> // Do super critical stuff<br/>mutex.unlock();                       // We're done</pre>
<p>Critical section: This is a group of instructions/statements that need to be executed atomically. Here, atomically means no other thread can interrupt the currently executing thread in the critical section, and no intermediate value is perceived by any thread during execution of code in the critical section.</p>
<p class="mce-root">In a large code base with many developers collaborating on the code, you might forget to call <kbd>mutex.lock()</kbd> before accessing the shared object from multiple threads, which can lead to data races. Others cases, you might forget to unlock the <kbd>mutex</kbd> and starve the other threads that want access to the data.</p>
<p class="mce-root">Rust has a different take on this. Here, you wrap your data in a <kbd>Mutex</kbd> type to ensuring synchronized mutable access to data from multiple threads:</p>
<pre class="mce-root">// Rust<br/><br/>use std::sync::Mutex;<br/><br/>fn main() {<br/>    let value = Mutex::new(23);<br/>    *value.lock().unwrap() += 1;   // modify<br/>}                                  // unlocks here automatically</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In the preceding code, we were able to modify the data after calling <kbd>lock()</kbd> on <kbd>value</kbd>. Rust uses the notion of protecting the shared data itself and not code. The interaction with <kbd>Mutex</kbd> and the protected data is not independent, as is the case with C++. You cannot access the inner data without calling <kbd>lock</kbd> on the <kbd>Mutex</kbd> type. What about releasing the <kbd>lock</kbd> ? Well, calling <kbd>lock()</kbd> returns something called  <kbd>MutexGuard</kbd>, which automatically releases the lock when the variable goes out of scope. It's one of the many safe concurrency abstractions Rust provides. We'll go into detail on them in <a href="8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml">Chapter 8</a>, <em>Concurrency</em>. Another novel idea is the notion of marker traits, which validate and ensure synchronized and safe access to data in concurrent code at compile time. Traits are described in detail in <a href="93373ddb-63dc-4b4c-a42f-7a099818705c.xhtml">Chapter 4</a>, <em>Types, Generics, and Traits</em>. Types are annotated with marker traits called <kbd>Send</kbd> and <kbd>Sync</kbd> to indicate whether they are safe to send to threads or safe to share between threads, respectively. When a program sends a value to a thread, the compiler checks whether the value implements the required marker trait and forbids the usage of the value if it isn't the case. In this way, Rust allows you to write concurrent code without fear, where the compiler catches mistakes in multi-threaded code at compile time. Writing concurrent code is already hard. With C/C++, it gets even harder and more arcane. CPUs aren't getting more clock rates; instead, we have more cores being added. As a result, concurrent programming is the way forward. Rust makes it a breeze to write concurrent code and lowers the bar for many people to get into writing safe, concurrent code.</p>
<p>Rust also employs C++'s RAII idiom for resource initialization. This technique basically ties a resource's lifetime to objects' lifetimes, whereas the deallocation of heap allocated types is performed through the <kbd>drop</kbd> method, which is provided by the <kbd>drop</kbd> trait. This is automatically called when the variable goes out of scope. It also replaces the concept of null pointers with <kbd>Result</kbd> and <kbd>Option</kbd> types, which we'll go into detail in <a href="35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml"/><a href="35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml">Chapter 6</a>, <em>Error Handling</em>. This means that Rust doesn't allow null/undefined values in code, except when interacting with other languages through foreign function interfaces and when using unsafe code. The language also puts emphasis on composition over inheritance and has a trait system, which is implemented by data types and is similar to <strong>Haskell</strong> typeclasses, also known as Java interfaces on steroids. Traits in Rust are the backbone to many of its features, as we'll see in upcoming chapters.</p>
<p>Last but not least, Rust's community is quite active and friendly, and the language has comprehensive documentation, which can be found at <a href="https://doc.rust-lang.org">https://doc.rust-lang.org</a>. For the third year in a row (2016, 2017, and 2018), Stack Overflow's Developer Survey highlights Rust as the most-loved programming language, so it can be said that the overall programming community is very interested in it. To summarize, you should care about Rust if you aim to write high performing software with less bugs while enjoying many modern language features and an awesome community!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing the Rust compiler and toolchain</h1>
                
            
            
                
<p>The Rust toolchain has two major components: the compiler, <strong>rustc</strong>, and the package manager, <strong>cargo</strong>, which helps manage Rust projects. The toolchain comes in three release channels:</p>
<ul>
<li><strong>Nightly</strong>: The daily successful build from the master development branch. This contains all the latest features, many of which are unstable.</li>
<li><strong>Beta</strong>: This is released every six weeks. A new beta branch is taken from nightly. It contains only features that are flagged as stable.</li>
<li><strong>Stable</strong>: This is released every six weeks. The previous beta branch becomes the new stable release.</li>
</ul>
<p>Developers are encouraged to use the stable release channel. However, the nightly version enables bleeding edge features, and some libraries and programs require it. You can change to the nightly toolchain easily with rustup. We'll see how we can do that in a moment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using rustup.rs</h1>
                
            
            
                
<p>Rustup is a tool to that installs the Rust compiler on all supported platforms. To make it easier for developers on different platforms to download and use the language, the Rust team developed rustup. It's a command-line tool written in Rust that provides an easy way to install pre-built binaries of the compiler and binary builds of the standard library for cross compiling needs. It can also install other components, such as the Rust source code, documentation, <strong>Rust formatting tool</strong> (<strong>rustfmt</strong>), <strong>Rust Language Server</strong> (<strong>RLS</strong> for IDEs), and other developer tools, and it runs on all platforms, including Windows.</p>
<p>From their official page at <a href="https://rustup.rs">https://rustup.rs</a>, the recommended way to install the toolchain is to run the following command:</p>
<pre><strong>curl https://sh.rustup.rs -sSf | sh</strong></pre>
<p>By default, the installer installs the stable version of the Rust compiler, its package manager, Cargo, and the language's standard library documentation so that it can be viewed offline. These are installed by default under the <kbd>~/.cargo</kbd> directory. Rustup also updates your <kbd>PATH</kbd> environment variable to point to this directory.</p>
<p>The following is a screenshot of running the preceding command on Ubuntu 16.04:</p>
<div><img src="img/deb3c4ac-0769-4a91-817e-a205e3b7ae38.png"/></div>
<p>If you need to make any changes to your installation, choose 2. However, the defaults are fine for us, so we'll go ahead and choose 1. Here's the output after the installation:</p>
<div><img src="img/d3465186-00cd-43e2-ae62-70af647a7760.png"/> </div>
<p>Rustup also has other capabilities, such as updating the toolchain to the latest version, which can be done by running <kbd>rustup update</kbd>. It can also update itself via <kbd>rustup self update</kbd>. It also provides directory-specific toolchain configuration. The default toolchain is set globally to whatever toolchain gets installed, which in most cases is the stable toolchain. You can view the default one by invoking <kbd>rustup show</kbd>. If you want to use the latest nightly toolchain for one of your projects, you can tell rustup to switch to nightly for that particular directory by running <kbd>rustup override set nightly</kbd>. If, for some reason, someone wants to use an older version of the toolchain or downgrade (say, the nightly build on 2016-06-03), rustup can also download that if we were to run <kbd>rustup install nightly-2016-06-03</kbd>, followed by setting the same using the <kbd>override</kbd> sub-command. More information on rustup can be found at <a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>.</p>
<div><strong>Note</strong>: All of the code examples and projects in this book are based on compiler version <kbd>rustc 1.32.0 (9fda7c223 2019-01-16)</kbd>.</div>
<p>Now, you should have everything you need to compile and run programs written in Rust. Let's get Rusty!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A tour of the language</h1>
                
            
            
                
<p>For the fundamental language features, Rust does not stray far from what you are used to in other languages. At a high level, a Rust program is organized into modules, with the root module containing a <kbd>main()</kbd> function. For executables, the root module is usually a <kbd>main.rs</kbd> file and for libraries, a <kbd>lib.rs</kbd> file. Within a module, you can define functions, import libraries, define types, create constants, write tests and macros, or even create nested modules. We'll see all of them, but let's start with the basics. Here's a simple Rust program that greets you:</p>
<pre>// greet.rs<br/><br/>1. use std::env;<br/>2. <br/>3. fn main() {<br/>4.    let name = env::args().skip(1).next();<br/>5.    match name {<br/>6.       Some(n) =&gt; println!("Hi there ! {}", n),<br/>7.       None =&gt; panic!("Didn't receive any name ?")<br/>8.    }<br/>9. }</pre>
<p>Let's compile and run this program. Write it to a file called <kbd>greet.rs</kbd> and run <kbd>rustc</kbd> with the file name, and pass your name as the argument. I passed the name <kbd>Ferris</kbd><em>,</em> Rust's unofficial mascot,<em> </em>and got the following output on my machine:</p>
<div><img src="img/6afa2bf0-2c92-4cae-b1dc-8548dec8d03c.jpg" style="width:15.42em;height:5.83em;"/></div>
<p>Awesome! It greets <kbd>Ferris</kbd>. Let's get a cursory view of this program, line by line.</p>
<p>On line 1, we import a module called <kbd>env</kbd> from the <kbd>std</kbd> crate (libraries are called <strong>crates</strong>). <kbd>std</kbd> is the standard library for Rust. On line 3, we have our usual function <kbd>main</kbd>. Then, on line 4, we call the function <kbd>args()</kbd> from the <kbd>env</kbd> module, which returns an iterator (sequence) of arguments that has been passed to our program. Since the first argument contains our program name, we want to skip it, so we call <kbd>skip</kbd> and pass in a number, which is how many elements (<kbd>1</kbd>) we want to skip. As iterators are lazy and do not pre-compute things in Rust, we have to explicitly ask it to give the next element, so we call <kbd>next()</kbd>, which returns an enum type called <kbd>Option</kbd>. This can be either a <kbd>Some(value)</kbd> value or a <kbd>None</kbd> value because a user might forget to provide an argument.</p>
<p>On line 5, we use Rust's awesome <kbd>match</kbd> expression on the variable <kbd>name</kbd> and check whether it's a <kbd>Some(n)</kbd> or a <kbd>None</kbd> value. <kbd>match</kbd> is like the <kbd>if else</kbd> construct, but more powerful. On line 6, when it's a <kbd>Some(n)</kbd>, we call <kbd>println!()</kbd>, passing in our inner string variable <kbd>n</kbd> (this gets auto-declared when using match expressions), which then greets our user. The <kbd>println!</kbd> call is not a function, but a <em>macro</em> (they all end with a !). Finally, on line 7, if it's a <kbd>None</kbd> variant of the enum, we just <kbd>panic!()</kbd> (another macro), which aborts the program, making it leave an error message.</p>
<p>The <kbd>println!</kbd> macro, as we saw, accepts a string, which can contain placeholders for items using the <kbd>"{}"</kbd> syntax. These strings are called <strong>format strings</strong>, while the <kbd>"{}"</kbd> in the string are called <strong>format specifiers</strong>. For printing simple types such as primitives, we can use the <kbd>"{}"</kbd> format specifier, whereas for other types, we use the <kbd>"{:?}"</kbd> format specifier. There are more details to this, though. When <kbd>println!</kbd> encounters a format specifier, that is, <kbd>"{}"</kbd>, and a corresponding substitution value, it calls a method on that value, which returns a string representation of it. This method is part of a trait. For the <kbd>"{}"</kbd> specifier, it calls a method from the <kbd>Display</kbd> trait, whereas for <kbd>"{:?}"</kbd>, it calls a method from the <kbd>Debug</kbd> trait. The latter is mostly used for debugging, while the former is for displaying a human readable output of data types. It is somewhat similar to the <kbd>toString()</kbd> method in Java. When developing, you usually need to print your data types for debugging. The cases where these methods are not available on a type when using the <kbd>"{:?}"</kbd> specifier, we then need to add a <kbd>#[derive(Debug)]</kbd> <strong>attribute</strong> over the type to get those methods. We'll explain attributes in detail in subsequent chapters, but expect to see this in future code examples. We'll also revisit the <kbd>println!</kbd> macro in  <a href="7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml">Chapter 9</a>, <em>Metaprogramming with Macros</em>.</p>
<p>Running <strong>rustc</strong> manually is not how you will do this for real programs, but it will do for these small programs in this chapter. In subsequent chapters, we will be using Rust's package manager to build and run our programs. Apart from running the compiler locally, another tool that can be used to run the code examples is the official online compiler called <strong>Rust playground</strong>, which can be found at <a href="http://play.rust-lang.org">http://play.rust-lang.org</a>. Following is the screenshot from my machine:</p>
<div><img src="img/0cf8b8e7-fc8d-4094-b323-3ef24a75dfea.png"/></div>
<p>The Rust playground also supports external libraries to be imported and to be used when trying out sample programs.</p>
<p>With the previous example, we got a high-level overview of a basic Rust program, but did not dive into all of the details and the syntax. In the following section, we will explain the language features separately and their syntax. The explanations that follow are here to give you enough context so that you can quickly get up and running in regard to writing Rust programs without going through all of the use cases exhaustively. To make it brief, each section also contains references to chapters that explain these concepts in more detail. Also, the Rust documentation page at <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a> will help you get into the details and is very readable with its built-in search feature. You are encouraged to proactively search for any of the constructs that are explained in the following sections. This will help you gain more context about the concepts you're learning about.</p>
<p> All of the code examples in this chapter can be found in this book's GitHub repository (<a href="https://github.com/PacktPublishing/Mastering-RUST-Second-Edition">PacktPublishing/Mastering-RUST-Second-Edition</a>). For this chapter, they are in <a href="d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml">Chapter 1</a>, <em>Getting Started with Rust</em> <em>Directory</em> – the same convention is followed for the rest of the chapters in this book.</p>
<p>Some of the code files are deliberately presented to not compile so that you can fix them yourselves with the help of the compiler.</p>
<p>With that said, let's start with the fundamental primitive types in Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Primitive types</h1>
                
            
            
                
<p>Rust has the following built-in primitive types:</p>
<ul>
<li><kbd>bool</kbd>: These are the usual booleans and can be either <kbd>true</kbd> or <kbd>false</kbd> .</li>
<li><kbd>char</kbd>: Characters, such as <kbd>e</kbd>.</li>
<li>Integer types: These are characterized by the bit width. Rust supports integers that are up to 128 bits wide:<br/>
<table border="1">
<tbody>
<tr style="height: 27px">
<td style="height: 27px;width: 174.417px">signed</td>
<td style="height: 27px;width: 189.233px">unsigned</td>
</tr>
<tr style="height: 27px">
<td style="height: 27px;width: 174.417px"><kbd>i8</kbd></td>
<td style="height: 27px;width: 189.233px"><kbd>u8</kbd></td>
</tr>
<tr style="height: 26px">
<td style="height: 26px;width: 174.417px"><kbd>i16</kbd></td>
<td style="height: 26px;width: 189.233px"><kbd>u16</kbd></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 174.417px"><kbd>i32</kbd></td>
<td style="height: 32px;width: 189.233px"><kbd>u32</kbd></td>
</tr>
<tr style="height: 25px">
<td style="height: 25px;width: 174.417px"><kbd>i64</kbd></td>
<td style="height: 25px;width: 189.233px"><kbd>u64</kbd></td>
</tr>
<tr style="height: 25px">
<td style="height: 25px;width: 174.417px"><kbd>i128</kbd></td>
<td style="height: 25px;width: 189.233px"><kbd>u128</kbd></td>
</tr>
</tbody>
</table>
</li>
<li><kbd>isize</kbd>: The pointer-sized signed integer type. Equivalent to <kbd>i32</kbd> on 32-bit CPU and <kbd>i64</kbd> on 64-bit CPU.</li>
<li><kbd>usize</kbd>: The pointer-sized unsigned integer type. Equivalent to <kbd>i32</kbd> on 32-bit CPU and <kbd>i64</kbd> on 64-bit CPU.</li>
<li><kbd>f32</kbd>: The 32-bit floating point type. Implements the IEEE 754 standard for floating point representation.</li>
<li><kbd>f64</kbd>: The 64-bit floating point type.</li>
<li><kbd>[T; N]</kbd>: A fixed-size array, for the element type, <kbd>T</kbd>, and the non-negative compile-time constant size N.</li>
</ul>
<ul>
<li><kbd>[T]</kbd>: A dynamically-sized view into a contiguous sequence, for any type <kbd>T</kbd>.</li>
<li><kbd>str</kbd>: String slices, mainly used as a reference, that is, <kbd>&amp;str</kbd>.</li>
<li><kbd>(T, U, ..)</kbd>: A finite sequence, (T, U, ..) where T and U can be different types.</li>
<li><kbd>fn(i32) -&gt; i32</kbd>: A function that takes an <kbd>i32</kbd> and returns an <kbd>i32</kbd>. Functions also have a type.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring variables and immutability</h1>
                
            
            
                
<p>Variables allow us to store a value and easily refer to it later in code. In Rust, we use the <kbd>let</kbd> keyword to declare variables. We already had a glimpse of it in the <kbd>greet.rs</kbd> example in the previous section. In mainstream imperative languages such as C or Python, initializing a variable does not stop you from reassigning it to some other value. Rust deviates from the mainstream here by making variables immutable by default, that is, you cannot assign the variable to some other value after you have initialized it. If you need a variable to point to something else (of the same type) later, you need to put the <kbd>mut</kbd> keyword before it. Rust asks you to be explicit about your intent as much as possible. Consider the following code:</p>
<pre>// variables.rs<br/> <br/>fn main() {<br/>    let target = "world";<br/>    let mut greeting = "Hello";<br/>    println!("{}, {}", greeting, target);<br/>    greeting = "How are you doing";<br/>    target = "mate";<br/>    println!("{}, {}", greeting, target);<br/>}</pre>
<p>We declared two variables, <kbd>target</kbd> and <kbd>greeting</kbd>. <kbd>target</kbd> is an immutable binding, while <kbd>greeting</kbd> has a <kbd>mut</kbd> before it, which makes it a mutable binding. If we run this program, though, we get the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e56e927a-9f3e-4f25-baef-6b460b72baba.png" style="width:28.92em;height:11.25em;"/></p>
<p class="mce-root"/>
<p>As you can see from the preceding error message, Rust does not let you assign to <kbd>target</kbd> again. To make this program compile, we'll need to add <kbd>mut</kbd> before <kbd>target</kbd> in the <kbd>let</kbd> statement and compile and run it again. The following is the output when you run the program:</p>
<pre><strong>$ rustc variables.rs</strong><br/><strong>$ ./variables</strong><br/>Hello, world<br/>How are you doing, mate</pre>
<p><kbd>let</kbd> does much more than assign variables. It is a pattern-matching statement in Rust. In <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts,</em> we'll take a closer look at <kbd>let</kbd>. Next, we'll look at functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions</h1>
                
            
            
                
<p>Functions abstract a bunch of instructions into named entities, which can be invoked later by other code and help manage complexity. We already used a function in our <kbd>greet.rs</kbd> program, that is, the <kbd>main</kbd> function. Let's look at how we can define another one:</p>
<pre>// functions.rs<br/><br/>fn add(a: u64, b: u64) -&gt; u64 {<br/>    a + b<br/>}<br/><br/>fn main() {<br/>    let a: u64 = 17;<br/>    let b = 3;<br/>    let result = add(a, b);<br/>    println!("Result {}", result);<br/>}</pre>
<p>In the preceding code, we created a new function named <kbd>add</kbd>. The <kbd>fn</kbd> keyword is used to create functions followed by its name, <kbd>add</kbd>, its parameters inside parentheses <kbd>a</kbd> and <kbd>b</kbd>, and the function body inside <kbd>{}</kbd> braces. The parameters have their type on the right, after the colon <kbd>:</kbd>. Return types in functions are specified using a <kbd>-&gt;</kbd>, followed by the type, <kbd>u64</kbd>, which can be omitted if the function has nothing to return. Functions also have types. The type of our <kbd>add</kbd> function is denoted as <kbd>fn(u64, u64) -&gt; u64</kbd>. They can also be stored in variables and passed to other functions.</p>
<p>If you look at the body of <kbd>add</kbd>, we don't need a <kbd>return</kbd> keyword to return <kbd>a + b</kbd> as in other languages. The last expression is returned automatically. However, we do have the <kbd>return</kbd> keyword available for early returns. Functions are basically expressions that return a value, which is a <kbd>()</kbd> (Unit) type by default, akin to the <em>void</em> return type in C/C++. They can also be declared within other functions. The use case for that is when you have a functionality within a function (say, <kbd>foo</kbd>) that is hard to reason as a sequence of statements. In this case, one can extract those lines in a local function, <kbd>bar</kbd>, which is then defined within the parent function, <kbd>foo.</kbd></p>
<p>In <kbd>main</kbd>, we declared two variables, <kbd>a</kbd> and <kbd>b</kbd>, using the <kbd>let</kbd> keyword. As is the case with <kbd>b</kbd>, we can even omit specifying the type as Rust is able to infer types of variables in most cases by examining your code. This is also the case with the <kbd>result</kbd>, which is a <kbd>u64</kbd> value. This feature helps prevent type signature clutter and improves the readability of code, especially when your types are nested inside several other types that have long names.</p>
<p>Rust's type inference is based on the Hindly Milner type system. It's a set of rules and algorithms that enable type inference in a programming language. It's an efficient type inference method that performs in linear time, making it practical to type check large programs.</p>
<p>We can also have functions that modify their arguments. Consider the following code:</p>
<pre>// function_mut.rs<br/><br/>fn increase_by(mut val: u32, how_much: u32) {<br/>    val += how_much;<br/>    println!("You made {} points", val);<br/>}<br/><br/>fn main() {<br/>    let score = 2048;<br/>    increase_by(score, 30);<br/>}</pre>
<p>We declare a  <kbd>score</kbd> variable with <kbd>2048</kbd> as the value, and call the <kbd>increase_by</kbd> function, passing score and the value <kbd>30</kbd> as the second argument. In the <kbd>increase_by</kbd> function, we have specified the first parameter as <kbd>mut val</kbd>, indicating that the parameter should be taken as mutable, which allows the variable to be mutated from inside the function. Our <kbd>increase_by</kbd> function modifies the <kbd>val</kbd> binding and prints the value. Following is the output when running the program:</p>
<pre><strong>$ rustc function_mut.rs </strong><br/><strong>$ ./function_mut </strong><br/>You made 2078 points</pre>
<p>Next, let's look at closures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Closures</h1>
                
            
            
                
<p>Rust also has support for closures. Closures are like functions but have more information of the environment or scope in which they are declared. While functions have names associated with them, closures are defined without a name, but they can be assigned to a variable. Another advantage of Rust's type inference is that, in most cases, you can specify parameters for a closure without their type. Here's the the simplest possible closure: <kbd>let my_closure = || ();</kbd>. We just defined a no-parameter closure that does nothing. We can call this by invoking <kbd>my_closure()</kbd>, just like functions. The two vertical bars <kbd>||</kbd> hold the parameters for the closure (if any), such as <kbd>|a, b|</kbd>. Specifying the types of parameters (<kbd>|a: u32|</kbd>) is sometimes required when Rust cannot figure out the proper types. Like functions, closures can also be stored in variables and invoked later or passed to other functions. The body of the closure, however, can either have a single line expression or a pair of braces for multi-line expressions. A more involved closure would be as follows:</p>
<pre>// closures.rs<br/><br/>fn main() {<br/>    let doubler = |x| x * 2;<br/>    let value = 5;<br/>    let twice = doubler(value);<br/>    println!("{} doubled is {}", value, twice);<br/><br/>    let big_closure = |b, c| {<br/>        let z = b + c;<br/>        z * twice<br/>    };<br/><br/>    let some_number = big_closure(1, 2);<br/>    println!("Result from closure: {}", some_number);<br/>}</pre>
<p>In the preceding code, we have defined two closures: <kbd>doubler</kbd> and <kbd>big_closure</kbd>. <kbd>doubler</kbd> doubles a value given to it; in this case, it is passed <kbd>value</kbd> from the parent scope or environment, that is, the function <kbd>main</kbd>. Similarly, in <kbd>big_closure</kbd>, we use the variable <kbd>twice</kbd> from its environment. This closure has multi-line expressions within braces and needs to end with a semi-colon to allow us to assign it to the  <kbd>big_closure</kbd> variable. Later, we call <kbd>big_closure</kbd>, passing in <kbd>1, 2</kbd>, and print <kbd>some_number</kbd>.</p>
<p>The major use case for closures are as parameters to higher-order functions. A higher-order function is a function that takes another function or closure as its argument. For example, the <kbd>thread::spawn</kbd> function from the standard library takes in a closure where you can write code you want to run in another thread. Another example where closures provide a convenient abstraction is when you have a function that operates on collection such as <kbd>Vec</kbd> and you want to filter the items based on some condition. Rust's <kbd>Iterator</kbd> trait has a method called <kbd>filter</kbd>, which takes in a closure as an argument. This closure is defined by the user and it returns either <kbd>true</kbd> or <kbd>false</kbd>, depending on how the user wants to filter the items in the collection. We'll get more in-depth with closures in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Strings</h1>
                
            
            
                
<p>Strings are one of the most frequently used data types in any programming language. In Rust, they are usually found in two forms: the <kbd>&amp;str</kbd> type (pronounced <em>stir</em>) and the <kbd>String</kbd> type. Rust strings are guaranteed to be valid UTF-8 encoded byte sequences. They are not null terminated as in C strings and can contain null bytes in-between them. The following program shows the two types in action:</p>
<pre class="playpen">// strings.rs<br/><br/>fn main() {<br/>    let question = "How are you ?";            // a &amp;str type<br/>    let person: String = "Bob".to_string();<br/>    let namaste = String::from("नमस्ते");        // unicodes yay!<br/><br/>    println!("{}! {} {}", namaste, question, person);<br/>}</pre>
<p>In the preceding code, <kbd>person</kbd> and <kbd>namaste</kbd> are of type <kbd>String</kbd>, while <kbd>question</kbd> is of type <kbd>&amp;str</kbd>. There are multiple ways you can create <kbd>String</kbd> types. Strings are allocated on the heap, while <kbd>&amp;str</kbd> types are usually pointers to an existing string, which could either be on stack, the heap, or a string in the data segment of the compiled object code. The <kbd>&amp;</kbd> is an operator that is used to create a pointer to any type. After initializing the strings in the preceding code, we then use the <kbd>println!</kbd> macro to print them together using format strings. That's the very basics of strings. Strings are covered in detail in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>,  <em>Advanced Concepts</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conditionals and decision making</h1>
                
            
            
                
<p>Conditionals are also similar to how they're found in other languages. They follow the C-like <kbd>if {} else {}</kbd> structure:</p>
<pre>// if_else.rs<br/><br/>fn main() {<br/>    let rust_is_awesome = true;<br/>    if rust_is_awesome {<br/>        println!("Indeed");<br/>    } else {<br/>        println!("Well, you should try Rust !");<br/>    }<br/>}</pre>
<p>In Rust, the <kbd>if</kbd> construct is not a statement, but an expression. In general programming parlance, <em>statements</em> do not return any value, but an <em>expression</em> does. This distinction means that <kbd>if else</kbd> conditionals in Rust always return a value. The value may be an empty <kbd>()</kbd> unit type, or it may be an actual value. Whatever remains in the last line inside the braces becomes the return value of the <kbd>if else</kbd> expression. It is important to note that both <kbd>if</kbd> and <kbd>else</kbd> branches should have the same return type. Also, we don't need parentheses around the if condition expression, as you can see in the preceding code. We can even assign the value of <kbd>if else</kbd> blocks to a variable:</p>
<pre>// if_assign.rs<br/><br/>fn main() {<br/>    let result = if 1 == 2 { <br/>        "Wait, what ?" <br/>    } else { <br/>        "Rust makes sense" <br/>    };<br/><br/>    println!("You know what ? {}.", result);<br/>}</pre>
<p>When assigning values that have been returned from an <kbd>if else</kbd> expression, we need to end them with a semicolon. For example, <kbd>if { ...</kbd> is an expression, while <kbd>let</kbd> is a statement that expects us to have a semicolon at the end. In the case of assignment, if we were to remove the <kbd>else {}</kbd> block from the preceding code, the compiler would throw an error, like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ebd5760a-e52a-4c04-93ba-9d6d9d43deab.png"/></p>
<p>Without the <kbd>else</kbd> block, if the <kbd>if</kbd> condition evaluates to <kbd>false</kbd>, then the result will be <kbd>()</kbd>, and there would be two possible values for the <kbd>result</kbd> variable, that is, <kbd>()</kbd> and <kbd>&amp;str</kbd>. Rust does not allow multiple types to be stored in one variable. So, in this case, we need both the <kbd>if {}</kbd> and <kbd>else {}</kbd> blocks returning the same types. Also, adding a semicolon in the conditional branches changes the meaning of the code. By adding a semicolon after the strings in the <kbd>if</kbd> block in the following code, the compiler would interpret it as you wanting to throw the value away:</p>
<pre>// if_else_no_value.rs<br/><br/>fn main() { <br/>    let result = if 1 == 2 { <br/>        "Nothing makes sense"; <br/>    } else { <br/>        "Sanity reigns"; <br/>    };<br/><br/>    println!("Result of computation: {:?}", result); <br/>}</pre>
<p>In this case, the result will be an empty <kbd>()</kbd>, which is why we had to change the <kbd>println!</kbd> expression slightly (the <kbd>{:?}</kbd>); this type cannot be printed out in the regular way. Now, for the more complex multi-valued decision making; Rust has another powerful construct called <kbd>match</kbd> expressions, which we'll look at next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Match expressions</h1>
                
            
            
                
<p>Rust's <kbd>match</kbd> expressions are quite a joy to use. It's basically C's <kbd>switch</kbd> statement on steroids and allows you to make decisions, depending on what value the variable has and whether it has advanced filtering capabilities. Here's a program that uses match expressions:</p>
<pre>// match_expression.rs<br/><br/>fn req_status() -&gt; u32 {<br/>    200<br/>}<br/><br/>fn main() {<br/>    let status = req_status();<br/>    match status {<br/>        200 =&gt; println!("Success"),<br/>        404 =&gt; println!("Not Found"),<br/>        other =&gt; {<br/>            println!("Request failed with code: {}", other);<br/>            // get response from cache<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding code, we have a  <kbd>req_status</kbd>, function that returns a dummy HTTP request status code of <kbd>200</kbd>, which we call in <kbd>main</kbd> and assign to <kbd>status</kbd>. We then match on this value using the <kbd>match</kbd> keyword, followed by the variable we want to check the value of (<kbd>status</kbd>), followed by a pair of braces. Within braces, we write expressions – these are called <strong>match arms</strong><em>.</em> These arms represent the possible values that the variable being matched can take. Each match arm is written by writing the possible value of the variable, followed by a <kbd>=&gt;</kbd>, and then the expression on the right. To the right, you can either have a single line expression or a multi-line expression within <kbd>{}</kbd> braces. When written in a single line expression, they need to be delimited with a comma. Also, every match arm must return the same type. In this case, each match arm returns a Unit type <kbd>()</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Another nice feature or you can call guarantee of <kbd>match</kbd> expressions is that we have to match exhaustively against all possible cases of the value we are matching against. In our case, this would be listing all the numbers up until the maximum value of <kbd>i32</kbd>. However, practically, this is not possible, so Rust allows us to either ignore the rest of the possibilities by using a <kbd>catch all</kbd> variable (here, this is <kbd>other</kbd>) or an <kbd>_</kbd> (underscore) if we want to ignore the value. Match expressions are a primary way to make decisions around values when you have more than one possible value and they are very concise to write. Like <kbd>if else</kbd> expressions, the return value of a match expression can also be assigned to a variable in a <kbd>let</kbd> statement when it's delimited with a semicolon, with all match arms returning the same types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loops</h1>
                
            
            
                
<p>Repeating things in Rust can be done using three constructs, namely <kbd>loop</kbd>, <kbd>while</kbd>, and <kbd>for</kbd>. In all of them, we have the usual <kbd>continue</kbd> and <kbd>break</kbd> keywords, which allow you to skip and break out of a loop, respectively. Here's an example of using <kbd>loop</kbd>, which is equivalent to C's <kbd>while(true)</kbd>:</p>
<pre>// loops.rs <br/><br/>fn main() { <br/>    let mut x = 1024;<br/>    loop { <br/>        if x &lt; 0 { <br/>            break; <br/>        } <br/>        println!("{} more runs to go", x); <br/>        x -= 1; <br/>    } <br/>}</pre>
<p><kbd>loop</kbd> represents an infinite loop. In the preceding code, we simply decrement the value <kbd>x</kbd> until it hits the if condition <kbd>x &lt; 0</kbd>, where we break out of the loop. An extra feature of using <kbd>loop</kbd> in Rust is being able to tag the <kbd>loop</kbd> block with a name. This can be used in cases where you have two or more nested loops and want to break out from any one of them and not just the loop immediately enclosing the <kbd>break</kbd> statement. The following is an example of using loop labels to break out of the <kbd>loop</kbd>:</p>
<pre>// loop_labels.rs<br/><br/>fn silly_sub(a: i32, b: i32) -&gt; i32 {<br/>    let mut result = 0;<br/>    'increment: loop {<br/>        if result == a {<br/>            let mut dec = b;<br/>            'decrement: loop {<br/>                if dec == 0 {<br/>                    // breaks directly out of 'increment loop<br/>                    break 'increment;<br/>                } else {<br/>                    result -= 1;<br/>                    dec -= 1;<br/>                }<br/>            }<br/>        } else {<br/>            result += 1;<br/>        }<br/>    }<br/>    result<br/>}<br/><br/>fn main() {<br/>    let a = 10;<br/>    let b = 4;<br/>    let result = silly_sub(a, b);<br/>    println!("{} minus {} is {}", a, b, result);<br/>}</pre>
<p>In the preceding code, we are doing a very inefficient subtraction just to demonstrate the usage of labels with nested loops. In the inner <kbd>'decrement</kbd> label, when <kbd>dec</kbd> equals <kbd>0</kbd>, we can pass a label to break (here, this is <kbd>'increment</kbd>) and break out of the outer <kbd>'increment</kbd> loop instead.</p>
<p>Now, let's take a look at <kbd>while</kbd> loops. Nothing fancy here:</p>
<pre>// while.rs <br/><br/>fn main() { <br/>    let mut x = 1000; <br/>    while x &gt; 0 { <br/>        println!("{} more runs to go", x); <br/>        x -= 1;     <br/>    }<br/>}</pre>
<p>Rust also has a <kbd>for</kbd> keyword and is similar to for loops used in other languages, but they are quite different in their implementation. Rust's <kbd>for</kbd> is basically a syntax sugar for a more powerful repetition construct known as <em>iterators</em>. We'll discuss them in more detail in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>. To put it simply, for loops in Rust only work on types that can be converted into iterators. One such type is the <kbd>Range</kbd> type. The <kbd>Range</kbd> type can refer to a range of numbers, such as <kbd>(0..10)</kbd>. They can be used in <kbd>for</kbd> loops like so:</p>
<pre>// for_loops.rs<br/><br/>fn main() {<br/>    // does not include 10<br/>    print!("Normal ranges: ");<br/>    for i in 0..10 {<br/>        print!("{},", i);<br/>    }<br/><br/>    println!();       // just a newline<br/>    print!("Inclusive ranges: ");<br/>    // counts till 10<br/>    for i in 0..=10 {<br/>        print!("{},", i);<br/>    }<br/>}</pre>
<p>Apart from the normal range syntax, that is, <kbd>0..10</kbd>, which does not include <kbd>10</kbd>, Rust also has inclusive range syntax <kbd>0..=10</kbd>, which iterates all the way until <kbd>10</kbd>, as can be seen in the second <kbd>for</kbd> loop. Now, let's move on to user-defined data types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">User-defined types</h1>
                
            
            
                
<p>As the name says, user-defined types are types that are defined by you. These can be composed of several types. They may either be a wrapper over a primitive type or a composition of several user defined types. They come in three forms: structures, enumerations, and unions, or more commonly known as <strong>structs</strong>, <strong>enums</strong>, and <strong>unions</strong>. They allow you to easily express you data. The naming convention for user-defined types follows the CamelCase style. Structs and enums are more powerful than C's structs and enums, while unions in Rust are very close to C and are there mainly to interact with C code bases. We'll cover structs and enums in this section, while unions are covered in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Structs</h1>
                
            
            
                
<p>In Rust, there are three forms of structs that we can declare. The simplest of them is the <strong>unit struct</strong>, which is written with the <kbd>struct</kbd> keyword, followed by its name and a semicolon at the end. The following code example defines a unit struct:</p>
<pre>// unit_struct.rs<br/><br/>struct Dummy;<br/><br/>fn main() {<br/>    let value = Dummy;<br/>}</pre>
<p class="mce-root">We have defined a unit struct called <kbd>Dummy</kbd> in the preceding code. In <kbd>main</kbd>, we can initialize this type using only its name. <kbd>value</kbd> now contains an instance of <kbd>Dummy</kbd> and is a zero sized value. Unit structs do not take any size at runtime as they have no data associated with them. There are very few use cases for unit structs. They can be used to model entities with no data or state associated with them. Another use case is to use them to represent error types, where the struct itself is sufficient to understand the error without needing a description of it. Another use case is to represent states in a state machine implementation. Next, let's look at the second form of structs.</p>
<p>The second form of struct is the <strong>tuple struct</strong>, which has associated data. Here, the individual fields are not named, but are referred to by their position in the definition. Let's say you are writing a color conversion/calculation library for use in your graphics application and want to represent <em>RGB</em> color values in code. We can represent our <kbd>Color</kbd> type and the related items like so:</p>
<pre>// tuple_struct.rs <br/><br/>struct Color(u8, u8, u8);<br/><br/>fn main() {<br/>    let white = Color(255, 255, 255);<br/>    <br/>    // You can pull them out by index<br/>    let red = white.0;<br/>    let green = white.1;<br/>    let blue = white.2;<br/><br/>    println!("Red value: {}", red);<br/>    println!("Green value: {}", green);<br/>    println!("Blue value: {}\n", blue);<br/><br/>    let orange = Color(255, 165, 0);<br/><br/>    // You can also destructure the fields directly<br/>    let Color(r, g, b) = orange;<br/>    println!("R: {}, G: {}, B: {} (orange)", r, g, b);<br/><br/>    // Can also ignore fields while destructuring<br/>    let Color(r, _, b) = orange;<br/>}</pre>
<p>In the preceding code, <kbd>Color(u8, u8, u8)</kbd> is a tuple struct that was created and stored in <kbd>white</kbd>. We then access the individual color components in <kbd>white</kbd> using the <kbd>white.0</kbd> syntax. Fields within the tuple struct can be accessed by the <kbd>variable.&lt;index&gt;</kbd> syntax, where the <kbd>index</kbd> refers to the position of the field in the struct, which starts with <kbd>0</kbd>. Another way to access the individual fields of a struct is by destructuring the struct using the <kbd>let</kbd> statement. In the second part, we created a color <kbd>orange</kbd>. Following that, we wrote the <kbd>let</kbd> statement with <kbd>Color(r, g, b)</kbd> on the left-hand side and to the right we put our <kbd>orange</kbd>. This results in three fields in <kbd>orange</kbd> getting stored within the <kbd>r</kbd>, <kbd>g</kbd>, and <kbd>b</kbd> variables. The types of <kbd>r</kbd>, <kbd>g</kbd>, and <kbd>b</kbd> are also inferred automatically for us.</p>
<p>The tuple struct is an ideal choice when you need to model data that has less than four or five attributes. Anything more than that hinders readability and reasoning. For a data type that has more than three fields cases, it's recommended to use a C-like struct, which is the third form and the most commonly used one. Consider the following code:</p>
<pre>// structs.rs<br/><br/>struct Player {<br/>    name: String,<br/>    iq: u8,<br/>    friends: u8,<br/>    score: u16<br/>}<br/><br/>fn bump_player_score(mut player: Player, score: u16) {<br/>    player.score += 120;<br/>    println!("Updated player stats:");<br/>    println!("Name: {}", player.name);<br/>    println!("IQ: {}", player.iq);<br/>    println!("Friends: {}", player.friends);<br/>    println!("Score: {}", player.score);<br/>}<br/><br/>fn main() {<br/>    let name = "Alice".to_string();<br/>    let player = Player { name,<br/>                          iq: 171,<br/>                          friends: 134,<br/>                          score: 1129 };<br/><br/>   bump_player_score(player, 120);<br/>}</pre>
<p>In the preceding code, structs  are created in the same way as tuple structs, that is, by writing the <kbd>struct</kbd> keyword followed by the name of the struct. However, they start with braces and their field declarations are named. Within braces, we can write fields as <kbd>field: type</kbd> comma-separated pairs. Creating an instance of a struct is also simple; we write <kbd>Player</kbd>, followed by a pair of braces, which contains comma-separated field initializations. When initializing a field from a variable that has the same name as the field name, we can use the <strong>field init shorthand</strong> feature, which is the case with the <kbd>name</kbd> field in the preceding code. We can then access the fields from the created instance easily by using the <kbd>struct.field_name</kbd> syntax. In the preceding code, we also have a function called <kbd>bump_player_score</kbd>, which takes the struct <kbd>Player</kbd> as a parameter. Function arguments are immutable by default, so when we want to modify the score of the player, we need to change the parameter to <kbd>mut player</kbd> in our function, which allows us to modify any of its fields. Having a <kbd>mut</kbd> on the struct implies mutability for all of its fields.</p>
<p>The advantage of using a struct rather than a tuple struct is that we can initialize the fields in any order. It also allows us to provide meaningful names to the fields. As a side note, the size of a struct is simply the sum of its individual field members, along with any data alignment padding, if required. They don't have any extra metadata size overhead associated with them. Next, let's look at enumerations, also known as enums.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enums</h1>
                
            
            
                
<p>When you need to model something that can be of different kinds, enums are the way to go. They are created using the <kbd>enum</kbd> keyword, followed by the name of the enum, followed by a pair of braces. Within braces, we can write all the possibilities of the type, which are called <strong>variants</strong>. These variants can be defined with or without data contained in them, and the data contained can be any primitive type, structs, tuple structs, or even an enum. However, in the recursive case, where you have an enum, <kbd>Foo</kbd>, and also a variant which holds <kbd>Foo</kbd>, the variant needs to be behind a pointer (<kbd>Box</kbd>, <kbd>Rc</kbd>, and so on) type to avoid having recursively infinite type definitions. Because enums can also be created on the stack, they need to have a predetermined size, and infinite type definitions makes it impossible to determine the size at compile time. Now, let's take a look at how to create one:</p>
<pre>// enums.rs<br/><br/>enum Direction { <br/>    N, <br/>    E, <br/>    S, <br/>    W<br/>}<br/><br/>enum PlayerAction {<br/>    Move {<br/>        direction: Direction,<br/>        speed: u8<br/>    },<br/>    Wait, <br/>    Attack(Direction)   <br/>}<br/><br/>fn main() {<br/>    let simulated_player_action = PlayerAction::Move {<br/>        direction: Direction::N,<br/>        speed: 2,<br/>    };<br/>    match simulated_player_action {<br/>        PlayerAction::Wait =&gt; println!("Player wants to wait"),<br/>        PlayerAction::Move { direction, speed } =&gt; {<br/>          println!("Player wants to move in direction {:?} with speed {}",<br/>                direction, speed)<br/>        }<br/>        PlayerAction::Attack(direction) =&gt; {<br/>            println!("Player wants to attack direction {:?}", direction)<br/>        }<br/>    };<br/>}</pre>
<p>The preceding code defines two enum types: <kbd>Direction</kbd> and <kbd>PlayerAction</kbd>. We then create an instance of them by choosing any variant, such as <kbd>Direction::N</kbd> or <kbd>PlayerAction::Wait</kbd> using the double colon <kbd>::</kbd> in between. Note that we can't have something like an uninitialized enum, and it needs to be one of the variants. Given an enum value, to see what variant an enum instance has, we use pattern matching by using <em>match</em> expressions. When we match on enums, we can directly destructure the contents of the variants by putting variables in place of fields such as <kbd>direction</kbd> in <kbd>PlayerAction::Attack(direction)</kbd>, which in turn means that we can use them inside our match arms.</p>
<p>As you can see in our preceding <kbd>Direction</kbd> enum, we have a <kbd>#[derive(Debug)]</kbd> annotation. This is an attribute and it allows <kbd>Direction</kbd> instances to be printed using the <kbd>{:?}</kbd> format string in <kbd>println!()</kbd>. This is done by generating methods from a trait called <kbd>Debug</kbd>. The compiler tells us whether the <kbd>Debug</kbd> trait is missing and gives suggestions about how to fix it, and so we need the attribute there:</p>
<div><img src="img/0298324f-454c-4e88-b751-b4b5aa75fd08.png"/></div>
<p class="mce-root"/>
<p>From a functional programmer's perspective, structs and enums are also known as <strong>Algebraic Data Types (ADTs)</strong> because the possible range of values they can represent can be expressed using the rules of algebra. For instance, an enum is called a <strong>sum type</strong> because the range of values that it can hold is basically the sum of the range of values of its variants, while a struct is called a <strong>product type</strong> because its range of possible values is the cartesian product of their individual fields' range of values. We'll sometime refer to them as ADTs when talking about them in general.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions and methods on types</h1>
                
            
            
                
<p>Types without behavior can be limiting, and it's often the case that we want to have functions or methods on types so that we can return new instances of them rather than constructing them manually or so that we have the ability to the manipulate fields of a user-defined type. We can do this via <strong>impl</strong> <strong>blocks</strong>, which is read as providing implementations for a type. We can provide implementations for all user-defined types or any wrapper type. First, let's take a look at how to write implementations for a struct.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Impl blocks on structs</h1>
                
            
            
                
<p>We can add behavior to our previously defined <kbd>Player</kbd> struct with two functionalities: a constructor-like function that takes a name and sets default values for the remaining fields in <kbd>Person</kbd>, and getter and setter methods for the friend count of <kbd>Person</kbd>:</p>
<pre>// struct_methods.rs<br/><br/>struct Player {<br/>    name: String,<br/>    iq: u8,<br/>    friends: u8<br/>}<br/><br/>impl Player {<br/>    fn with_name(name: &amp;str) -&gt; Player {<br/>        Player {<br/>            name: name.to_string(),<br/>            iq: 100,<br/>            friends: 100<br/>        }<br/>    }<br/><br/>    fn get_friends(&amp;self) -&gt; u8 {<br/>        self.friends<br/>    }<br/><br/>    fn set_friends(&amp;mut self, count: u8) {<br/>        self.friends = count;<br/>    }<br/>}<br/><br/>fn main() {<br/>    let mut player = Player::with_name("Dave");<br/>    player.set_friends(23);<br/>    println!("{}'s friends count: {}", player.name, player.get_friends());<br/>    // another way to call instance methods.<br/>    let _ = Player::get_friends(&amp;player);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We use the <kbd>impl</kbd> keyword, followed by the type we are implementing the methods for, followed by braces. Within braces, we can write two kinds of methods:</p>
<ul>
<li><strong>Associated methods</strong>: Methods without a <kbd>self</kbd> type as their first parameter. The <kbd>with_name</kbd> method is called an associated method because it does not have <kbd>self</kbd> as the first parameter. It is similar to a static method in object-oriented languages. These methods are available on the type themselves and do not need an instance of the type to invoke them. Associated methods are invoked by prefixing the method name with the struct name and double colons, like so:</li>
</ul>
<pre>      Player::with_name("Dave");</pre>
<ul>
<li><strong>Instance methods</strong>: Functions that take a <kbd>self</kbd> value as its first argument. The <kbd>self</kbd> symbol here is similar to <em>self</em> in Python and points to the instance on which the method is implemented (here, this is <kbd>Player</kbd>). Therefore, the <kbd>get_friends()</kbd> method can only be called on already created instances of the struct:</li>
</ul>
<pre>      let player = Player::with_name("Dave");<br/>      player.get_friends();</pre>
<p>If we were to call <kbd>get_friends</kbd> with the associated method syntax, that is, <kbd>Player::get_friends()</kbd>, the compiler gives the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1e8237b1-c8a1-49c6-bd57-fd1a5e94069f.png" style="width:51.83em;height:16.25em;"/></p>
<p>The error is misleading here, but it indicates that instance methods are basically associated methods with <kbd>self</kbd> as the first parameter and that <kbd>instance.foo()</kbd> is a syntax sugar. This means that we can call it like this, too: <kbd>Player::get_friends(&amp;player);</kbd>. In this invocation, we pass the method an instance of <kbd>Player</kbd>, that is, <kbd>&amp;self</kbd> is <kbd>&amp;player</kbd>.</p>
<p>There are three variants of instance methods that we can implement on types:</p>
<ul>
<li><kbd>self</kbd> as the first parameter. In this case, calling this method won't allow you to use the type later.</li>
<li><kbd>&amp;self</kbd> as the first parameter. This method only provides read access to the instance of a type.</li>
<li><kbd>&amp;mut self</kbd> as the first parameter. This method provides mutable access to the instance of a type.</li>
</ul>
<p>Our <kbd>set_friends</kbd> method is a <kbd>&amp;mut self</kbd> method, which allows us to mutate the fields of <kbd>player</kbd>. We need the <kbd>&amp;</kbd> operator before <kbd>self</kbd>, meaning that <kbd>self</kbd> is borrowed for the duration of the method, which is exactly what we want here. Without the ampersand, the caller would move the ownership to the method, which means that the value would get de-allocated after <kbd>get_friends</kbd> returns and we would not get to use our <kbd>Player</kbd> instance anymore. Don't worry if the terms move and borrowing does not make sense as we explain all of this in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory Management and Safety</em>.</p>
<p>Now, onto implementations for enums.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Impl blocks for enums</h1>
                
            
            
                
<p>We can also provide implementations for enums. For example, consider a payments library built in Rust, which exposes a single API called <kbd>pay</kbd>:</p>
<pre>// enum_methods.rs<br/><br/>enum PaymentMode {<br/>    Debit,<br/>    Credit,<br/>    Paypal<br/>}<br/><br/>// Bunch of dummy payment handlers<br/><br/>fn pay_by_credit(amt: u64) {<br/>    println!("Processing credit payment of {}", amt);<br/>}<br/>fn pay_by_debit(amt: u64) {<br/>    println!("Processing debit payment of {}", amt);<br/>}<br/>fn paypal_redirect(amt: u64) {<br/>    println!("Redirecting to paypal for amount: {}", amt);<br/>}<br/><br/>impl PaymentMode {<br/>    fn pay(&amp;self, amount: u64) {<br/>        match self {<br/>            PaymentMode::Debit =&gt; pay_by_debit(amount),<br/>            PaymentMode::Credit =&gt; pay_by_credit(amount),<br/>            PaymentMode::Paypal =&gt; paypal_redirect(amount)<br/>        }<br/>    }<br/>}<br/><br/>fn get_saved_payment_mode() -&gt; PaymentMode {<br/>    PaymentMode::Debit<br/>}<br/><br/>fn main() {<br/>    let payment_mode = get_saved_payment_mode();<br/>    payment_mode.pay(512);<br/>}</pre>
<p>The preceding code has a method called <kbd>get_saved_payment_mode()</kbd>, which returns a user's saved payment mode. This can either be a <em>Credit</em> <em>Card</em>, <em>Debit Card</em>, or <em>Paypal</em>. This is best modeled as an enum, where different payment methods can be added as its variants. The library then provides us with a single <kbd>pay()</kbd> method to which we can conveniently provide an amount to pay. This method determines which variant of the enum it is and dispatches methods accordingly to the correct payment service provider, without the library consumer worrying about checking which payment method to use.</p>
<p>Enums are also widely used for modeling state machines, and when combined with match statements, they make state transition code very concise to write. They are also used to model custom error types. When enum variants don't have any data associated with them, they can be used like C enums, where the variants implicitly have integer values starting with <kbd>0</kbd>, but can also be manually tagged with integer (<kbd>isize</kbd>) values. This is useful when interacting with foreign C libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modules, imports, and use statements</h1>
                
            
            
                
<p>Languages often provide a way to split large code bases into multiple files to manage complexity. Java follows the convention of a single public class per <kbd>.java</kbd> file, while C++ provides us with header files and include statements. Rust is no different and provides us with <strong>modules</strong>. Modules are a way to namespace or organize code in a Rust program. To allow flexibility in organizing our code, there are multiple ways to create modules. Modules are a complex topic to understand and to make it brief for this section, we'll highlight only the important aspects about using them. Modules are covered in detail in <a href="41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml">Chapter 2</a>, <em>Managing Projects with Cargo</em>. The following are the key takeaways about modules in Rust:</p>
<ul>
<li>Every Rust program needs to have a root module. In executables, it is usually the <kbd>main.rs</kbd> file, and for libraries, it is <kbd>lib.rs</kbd>.</li>
<li>Modules can be declared within other modules or can be organized as files and directories.</li>
<li>To let the compiler know about our module, we need to declare it using the <kbd>mod</kbd> keyword, as in <kbd>mod my_module;</kbd>, in our root module.</li>
<li>To use any of the items within the module, we need to use the <kbd>use</kbd> keyword, along with the name of the module. This is known as bringing the item into scope.</li>
<li>Items defined within modules are private by default, and you need to use the <kbd>pub</kbd> keyword to expose them to their consumers.</li>
</ul>
<p>That was modules in brief. Some of the advanced aspects of modules are also covered in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>. Next, let's look at the commonly used collection types that are available in the standard library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collections</h1>
                
            
            
                
<p>It's often the case that your program has to process more than one instance of data. For that, we have collection types. Depending on what you want and where your data resides in memory, Rust provides many kinds of built-in types to store a collection of data. First, we have <em>arrays</em> and <em>tuples</em>. Then, we have dynamic collection types in the standard library, of which we'll cover the most commonly used ones, that is, <em>vectors</em> (list of items) and <em>maps</em> (key/value items). Then, we also have references to collection types, called <em>slices</em>, which are basically a view into a contiguous piece of data owned by some other variable. Let's start with arrays first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Arrays</h1>
                
            
            
                
<p>Arrays have a fixed length that can store items of the same type. They are denoted by <kbd>[T, N]</kbd>, where <kbd>T</kbd> is any type and <kbd>N</kbd> is the number of elements in array. The size of the array cannot be a variable, but has to be a literal <kbd>usize</kbd> value:</p>
<pre>// arrays.rs<br/><br/>fn main() { <br/>    let numbers: [u8; 10] = [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]; <br/>    let floats = [0.1f64, 0.2, 0.3]; <br/><br/>    println!("Number: {}", numbers[5]);<br/>    println!("Float: {}", floats[2]);<br/>}</pre>
<p>In the preceding code, we declared an array, <kbd>numbers</kbd>, which contains <kbd>10</kbd> elements for which we specified the type on the left. In the second array, <kbd>floats</kbd>, we specified the type as a suffix to the first item of the array, that is, <kbd>0.1f64</kbd>. This is another way to specify types. Next, let's look at tuples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tuples</h1>
                
            
            
                
<p>Tuples differ from arrays in the way that elements of an array have to be of the same type, while items in a tuple can be a mix of types. They are heterogeneous collections and are useful for storing distinct types together. They can also be used when returning multiple values from a function. Consider the following code that uses tuples:</p>
<pre>// tuples.rs<br/><br/>fn main() { <br/>    let num_and_str: (u8, &amp;str) = (40, "Have a good day!");<br/>    println!("{:?}", num_and_str);<br/>    let (num, string) = num_and_str;<br/>    println!("From tuple: Number: {}, String: {}", num, string);<br/>}</pre>
<p>In the preceding code, <kbd>num_and_str</kbd> is a tuple of two items, <kbd>(u8, &amp;str)</kbd>. We can also extract values from an already declared tuple into individual variables. After printing the tuple, we destructure it on the next line into the  <kbd>num</kbd> and <kbd>string</kbd> variables, and their types are inferred automatically. That's pretty neat.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vectors</h1>
                
            
            
                
<p>Vectors are like arrays, except that their content or length doesn't need to be known in advance and can grow on demand. They are allocated on the heap. They can be created by either calling the <kbd>Vec::new</kbd> constructor or by using the <kbd>vec![]</kbd> macro:</p>
<pre>// vec.rs<br/><br/>fn main() {<br/>    let mut numbers_vec: Vec&lt;u8&gt; = Vec::new(); <br/>    numbers_vec.push(1); <br/>    numbers_vec.push(2); <br/><br/>    let mut vec_with_macro = vec![1]; <br/>    vec_with_macro.push(2);<br/>    let _ = vec_with_macro.pop();    // value ignored with `_`<br/><br/>    let message = if numbers_vec == vec_with_macro {<br/>        "They are equal"<br/>    } else {<br/>        "Nah! They look different to me"<br/>    };<br/><br/>    println!("{} {:?} {:?}", message, numbers_vec, vec_with_macro); <br/>}</pre>
<p>In the preceding code, we created two vectors, <kbd>numbers_vec</kbd> and <kbd>vec_with_macro</kbd>, in different ways. We can push elements to our vector using <kbd>push()</kbd> method and can remove elements using <kbd>pop()</kbd>. There are more methods for you to explore if you go to their documentation page: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a> . Vectors can also be iterated using the <kbd>for</kbd> loop syntax as they also implement the <kbd>Iterator</kbd> trait.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hashmaps</h1>
                
            
            
                
<p>Rust also provides us with maps, which can be used to store key-value data. They come from the <kbd>std::collections</kbd> module and are named <kbd>HashMap</kbd>. They are created with the <kbd>HashMap::new</kbd> constructor function:</p>
<pre>// hashmaps.rs<br/><br/>use std::collections::HashMap; <br/><br/>fn main() { <br/>    let mut fruits = HashMap::new(); <br/>    fruits.insert("apple", 3);<br/>    fruits.insert("mango", 6);<br/>    fruits.insert("orange", 2);<br/>    fruits.insert("avocado", 7);<br/>    for (k, v) in &amp;fruits {<br/>        println!("I got {} {}", v, k);<br/>    }<br/><br/>    fruits.remove("orange");<br/>    let old_avocado = fruits["avocado"];<br/>    fruits.insert("avocado", old_avocado + 5);<br/>    println!("\nI now have {} avocados", fruits["avocado"]);<br/>}</pre>
<p>In the preceding code, we created a new <kbd>HashMap</kbd> called <kbd>fruits</kbd>. We then insert some fruits into our <kbd>fruits</kbd> map, along with their count, using the <kbd>insert</kbd> method. Following that, we iterate over the key value pairs using <kbd>for</kbd> loop, where in we take a reference to our fruit map by <kbd>&amp;fruits</kbd>, because we only want read access to the key and value. By default, the value will be consumed by the <kbd>for</kbd> loop. The <kbd>for</kbd> loop in this case returns a two field tuple (<kbd>(k ,v)</kbd>). There are also seperate methods <kbd>keys()</kbd> and <kbd>values()</kbd> available to iterate over just keys and values, respectively. The hashing algorithm used for hashing the keys of the <kbd>HashMap</kbd> type is based on the <em>Robin hood</em> open addressing scheme, but can be replaced with a custom hasher depending on the use case and performance. That's about it.</p>
<p>Next, let's look at slices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Slices</h1>
                
            
            
                
<p>Slices are a generic way to get a view into a collection type. Most use cases are to get a read only access to a certain range of items in a collection type. A slice is basically a pointer or a reference that points to a continuous range in an existing collection type that's owned by some other variable. Under the hood, slices are fat pointers to existing data somewhere in the stack or the heap. By fat pointer, it means that they also have information on how many elements they are pointing to, along with the pointer to the data.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Slices are denoted by <kbd>&amp;[T]</kbd>, where <kbd>T</kbd> is any type. They are quite similar to arrays in terms of usage:</p>
<div><pre>// slices.rs<br/><br/>fn main() {<br/>    let mut numbers: [u8; 4] = [1, 2, 3, 4];<br/>    {<br/>        let all: &amp;[u8] = &amp;numbers[..];<br/>        println!("All of them: {:?}", all);<br/>    }<br/><br/>    {<br/>        let first_two: &amp;mut [u8] = &amp;mut numbers[0..2];<br/>        first_two[0] = 100;<br/>        first_two[1] = 99;<br/>    }<br/><br/>    println!("Look ma! I can modify through slices: {:?}", numbers);<br/>}</pre></div>
<p>In the preceding code, we have an array of <kbd>numbers</kbd>, which is a stack allocated value. We then take a slice into the array <kbd>numbers</kbd> using the <kbd>&amp;numbers[..]</kbd> syntax and store in <kbd>all</kbd>, which has the type <kbd>&amp;[u8]</kbd>. The <kbd>[..]</kbd> at the end means that we want to take a full slice of the collection. We need the <kbd>&amp;</kbd> here as we can't have slices as bare values – only behind a pointer. This is because slices are <strong>unsized types</strong>. We'll cover them in detail in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>. We can also provide ranges (<kbd>[0..2]</kbd>) to get a slice from anywhere in-between or all of them. Slices can also be mutably acquired. <kbd>first_two</kbd> is a mutable slice through which we can modify the original <kbd>numbers</kbd> array.</p>
<p>To the astute observer, you can see that we have used extra pair of braces in the preceding code when taking slices. They are there to isolate code that takes mutable reference of the slice from the immutable reference. Without them, the code won't compile. These concepts will be made clearer to you in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory Management and Safety</em>.</p>
<div><strong>Note</strong>: The <kbd>&amp;str</kbd> type also comes under the category of a slice type (a <kbd>[u8]</kbd>). The only distinction from other byte slices is that they are guaranteed to be UTF-8. Slices can also be taken on Vecs or Strings.</div>
<p>Next, let's look at iterators.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterators</h1>
                
            
            
                
<p>An iterator is a construct that provides an efficient way to act on elements of collection types. They are not a new concept, though. In many imperative languages, they are implemented as <em>objects</em> that are constructed from collection types such as lists or maps. For instance, Python's <kbd>iter(some_list)</kbd> or C++'s <kbd>vector.begin()</kbd> are ways to construct iterators from an existing collection. The main motivation for iterators to exist in the first place is that they provide a higher level abstraction of walking through items of a collection instead of using manual <kbd>for</kbd> loops, which are very much prone to off by one errors. Another advantage is that iterators do not read the whole collection in memory and are lazy. By lazy, we mean that the iterator only evaluates or accesses an element in a collection when needed. Iterators can also be chained with multiple transformation operations, such as filtering elements based on a condition, and do not evaluate the transformations until you need them. To access these items when you need them, iterators provide a <kbd>next()</kbd> method, which tries to read the next item from the collection. This occurs when the iterator evaluates the chain of computation.</p>
<p>In Rust, an iterator is any type that implements the <kbd>Iterator</kbd> trait. This type can then be used in a <kbd>for</kbd> loop to walk over its items. They are implemented for most standard library collection types such as <kbd>Vector</kbd>, <kbd>HashMap</kbd>, <kbd>BTreeMap</kbd>, and many more and one can also implement it for their own types.</p>
<div><strong>Note</strong>: It only makes sense to implement the <kbd>Iterator</kbd> trait if the type has a collection, such as semantics. For instance, it doesn't make sense to implement the iterator trait for a <kbd>()</kbd> unit type.</div>
<p>Iterators are frequently used whenever we are dealing with collection types in Rust. In fact, Rust's <kbd>for</kbd> loop is desugared into a normal match expression with <kbd>next</kbd> calls on the object being iterated over. Also, we can convert most collection types into an iterator by calling <kbd>iter()</kbd> or <kbd>into_iter()</kbd> on them. That's enough information on iterators – now, we can tackle the following exercise. We'll go deep into iterators and implement one ourselves in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise – fixing the word counter</h1>
                
            
            
                
<p>Armed with the basics, it's time to put our knowledge to use! Here, we have a program that counts instances of words in a text file, which is passed to it as an argument. It's almost complete, but has a few bugs that the compiler catches and a couple of subtle ones. Here's our incomplete program:</p>
<div><pre>// word_counter.rs<br/><br/>use std::env;<br/>use std::fs::File;<br/>use std::io::prelude::BufRead;<br/>use std::io::BufReader;<br/><br/>#[derive(Debug)]<br/>struct WordCounter(HashMap&lt;String, u64&gt;);<br/><br/>impl WordCounter {<br/>    fn new() -&gt; WordCounter {<br/>        WordCounter(HashMap::new());<br/>    }<br/><br/>    fn increment(word: &amp;str) {<br/>        let key = word.to_string();<br/>        let count = self.0.entry(key).or_insert(0);<br/>        *count += 1;<br/>    }<br/><br/>    fn display(self) {<br/>        for (key, value) in self.0.iter() {<br/>            println!("{}: {}", key, value);<br/>        }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let arguments: Vec&lt;String&gt; = env::args().collect();<br/>    let filename = arguments[1];<br/>    println!("Processing file: {}", filename);<br/>    <br/>    let file = File::open(filenam).expect("Could not open file");<br/>    let reader = BufReader::new(file);<br/>    <br/>    let mut word_counter = WordCounter::new();<br/><br/>    for line in reader.lines() {<br/>        let line = line.expect("Could not read line");<br/>        let words = line.split(" ");<br/>        for word in words {<br/>            if word == "" {<br/>                continue<br/>            } else {<br/>                word_counter.increment(word);<br/>            }<br/>        }<br/>    }<br/>    <br/>    word_counter.display();<br/>}<br/></pre></div>
<p>Go ahead and type the program into a file; try to compile and fix all the bugs with the help of the compiler. Try to fix one bug at a time and get feedback from the compiler by recompiling the code. The point of this exercise, in addition to covering the topics of this chapter, is to make you more comfortable with the error messages from the compiler, which is an important mental exercise in getting to know more about the compiler and how it analyzes your code. You might also be surprised to see how the compiler is quite smart in helping you removing errors from the code.</p>
<p>Once you are done fixing the code, here are some exercises for you to try so that you can flex your muscles a bit further:</p>
<ul>
<li>Add a <kbd>filter</kbd> parameter to the <kbd>display</kbd> method of <kbd>WordCounter</kbd> for filtering the output based on the count. In other words, display a key/value pair only if the value is greater than that filtering value.</li>
<li>Since HashMaps store their values randomly, the output is also random every time you run the program. Try to sort the output. The HashMap's <kbd>values</kbd> method may be useful.</li>
<li>Take a look at the <kbd>display</kbd> method's <kbd>self</kbd> parameter. What happens if you remove the <kbd>&amp;</kbd> operator before <kbd>self</kbd>?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We covered so many topics in this chapter. We got to know a bit about the history of Rust and the motivations behind the language. We had a brief walkthrough on its design principles and the basic features of the language. We also got a glimpse of how Rust provides rich abstractions through its type system. We learned how to install the language toolchain, and how to use <kbd>rustc</kbd> to build and run trivial example programs.</p>
<p>In the next chapter, we'll take a look at the standard way of building Rust applications and libraries using its dedicated package manager, and also set up our Rust development environment with a code editor, which will provide the foundation for all the subsequent exercises and projects in this book.</p>


            

            
        
    </body></html>