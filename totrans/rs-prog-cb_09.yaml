- en: Systems Programming Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust was originally envisioned as a systems programming language in the same
    way as C (and maybe C++). Although its appeal led to significant growth outside
    this field (somewhat like C/C++), there are still many features that significantly
    facilitate working on low-level projects. We suspect that the novelty aspect (as
    well as the powerful compiler, error messages, and community) led to very interesting
    projects in that space—such as operating systems. One of them is intermezzOS ([https://intermezzos.github.io/](https://intermezzos.github.io/)),
    an operating system for learning programming (in Rust); another is Redox OS ([https://www.redox-os.org/](https://www.redox-os.org/)),
    a microkernel effort in pure Rust. However, it doesn't stop there—the Rust embedded
    working group has compiled a list of resources and highlight projects on their
    GitHub ([https://github.com/rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)).
  prefs: []
  type: TYPE_NORMAL
- en: Linux is the most widely adopted operating system for embedded devices, but
    we tried to show the principles without requiring you to run Linux. In order to
    fully implement, for example, an I2C device driver, macOS and Windows users can
    use virtual machines with Hyper-V ([https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/)), VirtualBox
    ([https://www.virtualbox.org/](https://www.virtualbox.org/)), or Parallels ([https://www.parallels.com/](https://www.parallels.com/)),
    or rent a machine on the cloud ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)).
    With the exception of the first recipe, the recipes in this chapter work across
    OSes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list is truly awesome, and we are aiming to get you to a place where you
    can start building embedded drivers and cross-compile them to various CPU architectures.
    With that in mind, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from these drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Surprisingly, one of the more challenging aspects of implementing low-level
    projects is cross-compilation. Thanks to its LLVM underpinnings, `rustc` comes
    with a lot of toolchains for different CPU architectures. However, cross-compiling
    an application means that its (native) dependencies have to be available for this
    CPU architecture as well. This is challenging for small projects since it requires
    lots of management for versions across architectures and grows more and more complex
    with every added requirement. This is why there have been several tools that relate
    to this issue. In this recipe, we will explore at a few tools and learn how to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is highly platform-specific; at the time of writing, cross-compiling
    Rust on platforms other than Linux is tricky. On macOS and Windows, you can use
    virtual machines with Hyper-V ([https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/)), VirtualBox
    ([https://www.virtualbox.org/](https://www.virtualbox.org/)), or Parallels ([https://www.parallels.com/](https://www.parallels.com/)),
    or rent a machine from your favorite cloud provider ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)).
  prefs: []
  type: TYPE_NORMAL
- en: The **Windows Subsystem for Linux** (**WSL**) on Windows 10 doesn't support
    Docker at the time of writing. There might be ways around this limitation, but
    we will leave the required tinkering to our readers. If you find a solution, be
    sure to share it on our GitHub repository ([https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook)).
  prefs: []
  type: TYPE_NORMAL
- en: Then, install Docker ([https://docs.docker.com/install/](https://docs.docker.com/install/)) and
    make sure you can run Docker without **`sudo`** ([https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/))
    to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Docker available, take these steps to cross-compile to many targets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project using `cargo new cross-compile` for a binary executable and
    open the folder using VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/main.rs` and replace the default with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `cargo run` to see if it works and what architecture you are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do some cross-compilation. First, install a tool called cross using
    `cargo install cross`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in the `rust-cross` ([https://github.com/rust-embedded/cross](https://github.com/rust-embedded/cross))
    repository, start the Docker daemon to run a cross-build for `ARMv7`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a Raspberry Pi 2 (or later), you can then run the binary there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, how does `rust-cross` compile the code? Why use Docker? Let's look at how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are creating a simple binary (*step 1* and *step 2*) with
    a conditional compilation that matches the target architecture in order to see
    if it worked. *Step 3* should show your architecture (typically `x64` or `x86_64`);
    we install the cross-compilation toolkit in *step 4* to try and get it to run
    on a Raspberry Pi 2 and above (*step 5*). After compiling the binary, we transfer
    it to the device (ARM binaries won't work on `x86_64` instruction sets) for execution
    (*step 6*).
  prefs: []
  type: TYPE_NORMAL
- en: QEMU, a popular virtualization framework, also supports emulating ARM instructions,
    so a device is not strictly required. Check out their wiki ([https://wiki.qemu.org/Documentation/Platforms/ARM](https://wiki.qemu.org/Documentation/Platforms/ARM))
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Keep reading if you are interested in more details about cross-compiling an
    application. If not, feel free to move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cross-compilation is a very specific process where all of the following have
    to fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU instruction set, that is, assembler instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible libraries for linking (for example, the standard library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible toolchains (compiler, linker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to LLVM's architecture and the GNU compiler collection, we do not need
    to worry much about the CPU instruction set since it is largely provided by default,
    which is also the reason why it's tricky to run on Windows. As we have seen in
    many recipes in [Chapter 7](ccc55197-effc-4a8a-833f-c8a5607d06d5.xhtml), *Integrating
    Rust with Other Languages*, Windows and macOS use different toolchains, which
    makes compiling for other CPU instruction sets trickier. Our feeling is that it's
    easier to work smoothly in a virtualized environment these days instead of setting
    everything up locally.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Fedora or any other SELinux-enabled distribution, the cross-build
    may fail with a permission error. Right now, the solution is to disable SELinux
    (`sudo setenforce 0`), but a fix is underway ([https://github.com/rust-embedded/cross/issues/112](https://github.com/rust-embedded/cross/issues/112)).
  prefs: []
  type: TYPE_NORMAL
- en: Considering the target toolchain, `rustup` allows us to quickly install other
    targets (`rustup target add armv7-unknown-linux-gnueabihf`), yet some other aspects
    (for example, the C standard library ([https://www.gnu.org/software/libc/](https://www.gnu.org/software/libc/)))
    still need to be natively installed. Along with the number of targets available,
    managing the number of native libraries is going to be a full-time job (we are
    disregarding the various library versions entirely here).
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to contain these dependencies, versions, and more, `rust-cross`
    ([https://github.com/rust-embedded/cross#usage](https://github.com/rust-embedded/cross#usage)) (and others
    ([https://github.com/dlecan/rust-crosscompiler-arm](https://github.com/dlecan/rust-crosscompiler-arm))),
    use Docker containers that come prepared with a basic set of libraries. Typically,
    these containers can be customized ([https://github.com/rust-embedded/cross#custom-docker-images](https://github.com/rust-embedded/cross#custom-docker-images)) to
    add any certificates, configurations, libraries, and more you need for your use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, we can move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating I2C device drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating with devices in Linux happens at different levels. The most basic
    layer of drivers is the kernel module. Among other things, these modules have
    unrestricted access to the operating system and, if necessary, provide access
    to users via interfaces such as block devices. This is where the I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)) driver
    offers the as `/dev/i2c-1` bus (for example) that you can write to and read from.
    Using Rust, we can use this interface to create a driver for a sensor device that
    is connected to that bus. Let's see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Device drivers can be implemented in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a binary project: `cargo new i2cdevice-drivers`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the folder in VS Code and add some code to the `src/main.rs` file to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to implement the actual sensor driver. Create a file named `src/sensor.rs` to
    implement all aspects of the sensor driver. Let''s start by setting up a few basics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add a mock device that represents the bus system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we implement the actual sensor code that the user sees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to encapsulate the behavior of the sensor into a proper function,
    let''s implement the `Thermometer` trait we created at the top of `sensor.rs`.
    The way raw data is transformed into a usable temperature is typically stated
    in a manual or tech specification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to adapt the `Cargo.toml` configuration to add the random number
    generator crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we want to see the program in action. Use `cargo run` to see it printing
    what we pretend to be the temperature (stop it by pressing *Ctrl + C*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After implementing this, you are probably curious about why and how this works.
    Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we showed how to implement a very simple device driver that
    is available on a bus such as the I2C ([https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)).
    Since the I2C is a comparatively sophisticated bus (which makes implementing drivers
    simpler), a driver implements a protocol for reading and write operations to assumed
    registers and encapsulates them in a nice API. In this recipe, we did not actually
    use an I2C bus crate to provide the `struct` device, since it would impact OS
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we create the main loop to read from the sensor in a very simplistic
    way (check the *Efficiently reading hardware sensors *recipe), using sleep to
    control reading speed. In a typical fashion, we instantiate the driver by creating
    the block device abstraction using the *nix path (`/dev/i2c-1`) and the device's
    hardware address (defined by the manufacturer).
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3*, we add some constructs to make our lives easier and better structured:
    the `Thermometer` trait is good practice for bundling capabilities together if
    there are more devices or features on that sensor. Abstracting `Result` is a common
    strategy for reducing code verbosity.'
  prefs: []
  type: TYPE_NORMAL
- en: Only in *step 4* do we create a mock for the bus, providing a read and write
    function for single bytes. Since we are not actually reading from or writing to
    a bus, these functions read random numbers and write to nowhere. For an idea of
    how this is done in real life (for example, reading several bytes at once), check
    out the real `i2cdev` crate ([https://github.com/rust-embedded/rust-i2cdev](https://github.com/rust-embedded/rust-i2cdev)).
    So far, we have only gotten it to work on Linux, however.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* creates the abstraction API. Whenever we implement a driver from scratch,
    we are communicating with the device by writing specific binary commands into
    predefined registers. This could be to change the power state of the device, to
    change the sampling rate, or to ask for a particular measurement (if the device
    has multiple sensors and triggers hardware processes on the actual device). After
    this write operation, we can then read a specified data registry (all of the addresses
    and values can be found in the device''s specification) to transform the value
    into something usable (such as °C). This involves things such as shifting bits
    around, reading several calibration registries, and multiplying with overflows.
    Any such process varies from sensor to sensor. For a real-life example, check
    out the `bmp085` device driver ([https://github.com/celaus/rust-bmp085](https://github.com/celaus/rust-bmp085)),
    which shows a real-world driver implementation in Rust, and watch a talk on the
    driver at the following URL: [https://www.youtube.com/watch?v=VMaKQ8_y_6s](https://www.youtube.com/watch?v=VMaKQ8_y_6s).'
  prefs: []
  type: TYPE_NORMAL
- en: The following step then shows implementing and getting the actual temperature
    from the device and creating a usable number from the random number the raw device
    mock provides. This should be a simplification of what is typically done with
    raw values to get them into a usable form.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we then see how it works and verify that the temperatures
    is generally spread nicely in realistic values, although with a frightening rate
    of change.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and find out how we can read these sensor values more efficiently
    than with a pure loop.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently reading hardware sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating efficient I/O-based applications is tricky—they have to provide exclusive
    access to a resource as quickly as possible and as often as required. It's a resource
    scheduling problem. The basis of solving this type of problem is to handle and
    queue requests, as with reading a sensor value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use I/O loops to read things efficiently in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a binary project: `cargo new reading-hardware`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the folder in VS Code and create a `src/sensor.rs` file to add the code
    from the *Creating I2C device drivers* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, a raw device abstraction is provided by the hardware protocol drivers
    used. In our case, we mock up such a type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For proper encapsulation, it''s a good idea to create a `struct` that wraps
    the raw device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the implementation of the `Thermometer` trait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `src/main.rs` and replace the default with something more interesting.
    Let''s start with imports and helper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the actual event loop and the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, we should add some dependencies to `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to finish up the recipe, we also want to see it run and print out
    some mock readings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Great! Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of the naive busy waiting loop we created in the *Creating I2C device
    drivers* recipe, we now use a `tokio-rs` stream (effectively an asynchronous iterator)
    of events on which we can register a handler. Let's see how this more efficient
    structure is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: First, in *step 2*, we recreate the sensor code from the *Creating I2C device
    drivers* recipe in order to have a sensor to use. In short, the code simulates
    an I2C-connected temperature sensor with a random number generator to show how
    a bus-connected device driver operates.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we are preparing to use the driver to read a value and send it
    to a worker thread using a channel. Therefore, we create a `Reading` struct that
    saves a sensor reading at a certain timestamp. Only in *step 4* do we create the
    `tokio-rs` task runner and a stream. This stream is a construct that represents
    an iterator over asynchronous events that need to be handled. Each event corresponds
    to a timed interval every second, starting now (`Instant::now()`), and since we
    don't want to run forever in this recipe, we limit the number of events to five
    (`.take(5)`)—just as we would with any other iterator. `tokio::run()` takes this
    stream and starts executing the events on its event loop and thread pool, and
    blocks while there is something to execute.
  prefs: []
  type: TYPE_NORMAL
- en: In concurrent applications, the usage of something like `std::thread::sleep`
    is considered an anti-pattern. Why? Because it prevents the entire thread from
    doing *anything* while it is sleeping. In fact, the thread pauses and the OS's
    CPU scheduler context-switches to do some other stuff. Only after *at least* the
    specified time does the scheduler rotate the thread back into active mode to continue
    working. Drivers sometimes require some waiting time (several milliseconds to
    do the measuring), and `sleep` is typically used. Since devices can only be accessed
    from a single thread, `sleep()` is appropriate here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for_each` closure implements the handler for each event and receives an
    `Instant` instance as a parameter. Inside the closure, we read from the sensor
    and send it through a channel ([https://doc.rust-lang.org/std/sync/mpsc/](https://doc.rust-lang.org/std/sync/mpsc/)) to
    a receiving thread that we created earlier—a pattern that we saw in [Chapter 4](eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml), *Fearless
    Concurrency*. While we could process the data right away in the handler, pushing
    it into a queue for processing enables us to create batches and minimize the stream
    delay. This is especially important when the potential required time to finish
    processing is unknown, very large (that is, it comprises web requests or other
    moving parts), or requires extensive error handling (such as exponential backoff
    ([https://docs.microsoft.com/en-us/azure/architecture/patterns/retry](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry))).
    This will not only separate concerns and make maintenance easier, it also allows
    us to execute the reading operation more precisely. To visualize this, let''s
    look at the big picture for *step 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60ed9da9-0221-48e2-bcbe-1a2896c84324.png)'
  prefs: []
  type: TYPE_IMG
- en: In *step 5*, we add the required dependencies, and *step 6* shows the output—take
    note of the timestamp to see it really does fire every second and the stream is
    processed in the order they appear.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our in-depth journey into device drivers; if this was your first
    foray into the field, you have now learned about de-coupling reading sensor data
    from processing it; how device drivers are built in the first place; and, once
    ready, how to get them onto the desired device. In the next chapter, we return
    to a higher level of abstraction and work on more practical recipes.
  prefs: []
  type: TYPE_NORMAL
