["```rs\nenum RedHatBoyState {\n    Jumping,\n    Running,\n    Sliding,\n}\n```", "```rs\nstruct RedHatBoy {\n    state_machine: RedHatBoyStateMachine,\n    sprite_sheet: Sheet,\n    image: HtmlImageElement,\n}\n```", "```rs\n#[derive(Copy, Clone)]\nenum RedHatBoyStateMachine {\n    Idle(RedHatBoyState<Idle>),\n    Running(RedHatBoyState<Running>),\n}\n```", "```rs\nstruct RedHatBoy {\n    state: RedHatBoyState<Idle>,\n    sprite_sheet: Sheet,\n}\n```", "```rs\nstruct RedHatBoy<T> {\n    state: RedHatBoyState<T>,\n    sprite_sheet: Sheet,\n}\n```", "```rs\nmod red_hat_boy_states {\n    use crate::engine::Point;\n    #[derive(Copy, Clone)]\n    pub struct RedHatBoyState<S> {\n        context: RedHatBoyContext,\n        _state: S,\n    }\n    #[derive(Copy, Clone)]\n    pub struct RedHatBoyContext {\n        frame: u8,\n        position: Point,\n        velocity: Point,\n    }\n}\n```", "```rs\nerror[E0412]: cannot find type 'Idle' in this scope\n  --> src/game.rs:19:25\n   |\n19 |     Idle(RedHatBoyState<Idle>),\n   |                                    ^^^^ not found in \n   this scope\n```", "```rs\n#[derive(Copy, Clone)]\nstruct Idle;\n#[derive(Copy, Clone)]\nstruct Running;\n```", "```rs\nmod red_hat_boy_states {\n    ....\n    impl RedHatBoyState<Idle> {\n        pub fn run(self) -> RedHatBoyState<Running> {\n            RedHatBoyState {\n                context: self.context,\n                _state: Running {},\n            }\n        }\n    }\n```", "```rs\n#[derive(Copy, Clone)]\nenum RedHatBoyStateMachine {\n    Idle(RedHatBoyState<Idle>),\n    Running(RedHatBoyState<Running>),\n}\nimpl RedHatBoyStateMachine {\n    fn run(self) -> Self {\n        match self {\n            RedHatBoyStateMachine::Idle(state) => \n             RedHatBoyStateMachine::Running(state.run()),\n            _ => self,\n        }\n    }\n}\n```", "```rs\n#[derive(Copy, Clone)]\nenum RedHatBoyStateMachine {\n    Idle(RedHatBoyState<Idle>),\n    Running(RedHatBoyState<Running>),\n}\npub enum Event {\n    Run,\n}\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            (RedHatBoyStateMachine::Idle(state), \n             Event::Run) => {\n                RedHatBoyStateMachine::Running(state.run())\n            }\n            _ => self,\n        }\n    }\n}\n```", "```rs\nimpl From<RedHatBoyState<Running>> for RedHatBoyStateMachine {\n    fn from(state: RedHatBoyState<Running>) -> Self {\n        RedHatBoyStateMachine::Running(state)\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            (RedHatBoyStateMachine::Idle(state), \n             Event::Run) => state.run().into(),\n            _ => self,\n        }\n    }\n    ...\n```", "```rs\npub struct WalkTheDog {\n    image: Option<HtmlImageElement>,\n    sheet: Option<Sheet>,\n    frame: u8,\n    position: Point,\n    rhb: Option<RedHatBoy>,\n}\n...\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog {\n            image: None,\n            sheet: None,\n            frame: 0,\n            position: Point { x: 0, y: 0 },\n            rhb: None,\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    use crate::engine::Point;\n    const FLOOR: i16 = 475;\n    ...\n    impl RedHatBoyState<Idle> {\n        pub fn new() -> Self {\n            RedHatBoyState {\n                context: RedHatBoyContext {\n                    frame: 0,\n                    position: Point { x: 0, y: FLOOR },\n                    velocity: Point { x: 0, y: 0 },\n                },\n                _state: Idle {},\n            }\n        }\n        ...\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        let sheet: Option<Sheet> = browser::fetch_json(\n         \"rhb.json\").await?.into_serde()?;\n        let image = Some(engine::load_image(\n         \"rhb.png\").await?);\n        Ok(Box::new(WalkTheDog {\n            image: image.clone(),\n            sheet: sheet.clone(),\n            frame: self.frame,\n            position: self.position,\n            rhb: Some(RedHatBoy::new(\n                sheet.clone().ok_or_else(|| anyhow!\n                    (\"No Sheet Present\"))?,\n                image.clone().ok_or_else(|| anyhow!\n                    (\"No Image Present\"))?,\n            )),\n        }))\n    }\n...\n```", "```rs\n#[derive(Deserialize, Clone)]\npub struct SheetRect {\n    pub x: i16,\n    pub y: i16,\n    pub w: i16,\n    pub h: i16,\n}\n#[derive(Deserialize, Clone)]\npub struct Cell {\n    pub frame: SheetRect,\n}\n#[derive(Deserialize, Clone)]\npub struct Sheet {\n    pub frames: HashMap<String, Cell>,\n}\n```", "```rs\nimpl RedHatBoy {\n    fn new(sheet: Sheet, image: HtmlImageElement) -> Self {\n        RedHatBoy {\n            state_machine: RedHatBoyStateMachine::Idle(\n             RedHatBoyState::new()),\n            sprite_sheet: sheet,\n            image,\n        }\n    }\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        let frame_name = format!(\n            \"{} ({}).png\",\n            self.state_machine.frame_name(),\n            (self.state_machine.context().frame / 3) + 1\n        );\n        let sprite = self\n            .sprite_sheet\n            .frames\n            .get(&frame_name)\n            .expect(\"Cell not found\");\n        renderer.draw_image(\n            &self.image,\n            &Rect {\n                x: sprite.frame.x.into(),\n                y: sprite.frame.y.into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n            &Rect {\n                x: self.state_machine.context()\n                 .position.x.into(),\n                y: self.state_machine.context()\n                 .position.y.into(),\n                width: sprite.frame.w.into(),\n                height: sprite.frame.h.into(),\n            },\n        );\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    ...\n    fn frame_name(&self) ->&str {\n        match self {\n            RedHatBoyStateMachine::Idle(state) => \n             state.frame_name(),\n            RedHatBoyStateMachine::Running(state) => \n             state.frame_name(),\n        }\n    }\n    fn context(&self) ->&RedHatBoyContext {\n        match self {\n            RedHatBoyStateMachine::Idle(state) \n             =>&state.context(),\n            RedHatBoyStateMachine::Running(state) \n             =>&state.context(),\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    use crate::engine::Point;\n    const FLOOR: i16 = 475;\n    const IDLE_FRAME_NAME: &str = \"Idle\";\n    const RUN_FRAME_NAME: &str = \"Run\";\n    impl RedHatBoyState<Idle> {\n        ...\n        pub fn frame_name(&self) -> &str {\n            IDLE_FRAME_NAME\n        }\n    }\n    ...\n    impl RedHatBoyState<Running> {\n        pub fn frame_name(&self) -> &str {\n            RUN_FRAME_NAME\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    ....\n    #[derive(Copy, Clone)]\n    pub struct RedHatBoyState<S> {\n        context: RedHatBoyContext,\n        _state: S,\n    }\n    impl<S> RedHatBoyState<S> {\n        pub fn context(&self) -> &RedHatBoyContext {\n            &self.context\n        }\n}\n...\n```", "```rs\nmod red_hat_boy_states {\n    ...\n    #[derive(Copy, Clone)]\n    pub struct RedHatBoyContext {\n        pub frame: u8,\n        pub position: Point,\n        pub velocity: Point,\n        }\n        ...\n```", "```rs\nfn draw(&self, renderer: &Renderer) {\n    ...\n    self.rhb.as_ref().unwrap().draw(renderer);\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n....\n        if self.frame < 23 {\n            self.frame += 1;\n        } else {\n            self.frame = 0;\n        }\n        self.rhb.as_mut().unwrap().update();\n    }\n}\nimpl RedHatBoy {\n    ...\n    fn update(&mut self) {\n        self.state_machine = self.state_machine.update();\n    }\n}\nimpl RedHatBoyStateMachine {\n    ...\n    fn update(self) -> Self {\n        match self {\n            RedHatBoyStateMachine::Idle(mut state) => {\n                if state.context.frame < 29 {\n                    state.context.frame += 1;\n                } else {\n                    state.context.frame = 0;\n                }\n                RedHatBoyStateMachine::Idle(state)\n            }\n            RedHatBoyStateMachine::Running(_) => self,\n        }\n    }\n}\n```", "```rs\nself.rhb.as_mut().unwrap().update();\n```", "```rs\nimpl RedHatBoyStateMachine {\n    ...\n    fn update(self) -> Self {\n        match self {\n            ...\n            RedHatBoyStateMachine::Running(mut state) => {\n                if state.context.frame < 23 {\n                    state.context.frame += 1;\n                } else {\n                    state.context.frame = 0;\n                }\n                RedHatBoyStateMachine::Running(state)\n            }\n        }\n    }\n}\n```", "```rs\nconst IDLE_FRAMES: u8 = 29;\nconst RUNNING_FRAMES: u8 = 23;\n...\nimpl RedHatBoyStateMachine {\n    fn update(self) -> Self {\n        match self {\n            RedHatBoyStateMachine::Idle(mut state) => {\n                state.context = \n                 state.context.update(IDLE_FRAMES);\n                RedHatBoyStateMachine::Idle(state)\n            }\n            RedHatBoyStateMachine::Running(mut state) \n             => {\n                state.context = state.context.update(\n                 RUNNING_FRAMES);\n                RedHatBoyStateMachine::Running(state)\n            }\n        }\n    }\n}\nmod red_hat_boy_states {\n    ...\n    impl RedHatBoyContext {\n        pub fn update(mut self, frame_count: u8) -> \n         Self {\n            if self.frame < frame_count {\n                self.frame += 1;\n            } else {\n                self.frame = 0;\n            }\n            self\n        }\n    } \n```", "```rs\nmod red_hat_boy_states {\n    ...\n    const IDLE_FRAMES: u8 = 29;\n    const RUNNING_FRAMES: u8 = 23;\n    ....\n    impl RedHatBoyState<Idle> {\n        ....\n        pub fn update(&mut self) {\n            self.context = self.context.update(\n             IDLE_FRAMES);\n        }\n    }\n    impl RedHatBoyState<Running> {\n         ...\n         pub fn update(&mut self) {\n            self.context = self.context.update(\n             RUNNING_FRAMES);\n        }\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    ....\n    fn update(self) -> Self {\n        match self {\n            RedHatBoyStateMachine::Idle(mut state) => \n            {\n                state.update();\n                RedHatBoyStateMachine::Idle(state)\n            }\n            RedHatBoyStateMachine::Running(mut state) \n             => {\n                state.update();\n                RedHatBoyStateMachine::Running(state)\n            }\n        }\n    }\n}\n```", "```rs\nfn update(mut self, frame_count: u8) -> Self {\n    ...\n    self.position.x += self.velocity.x;\n    self.position.y += self.velocity.y;\n    self\n}\n```", "```rs\n    impl RedHatBoyContext {\n        ...\n        fn reset_frame(mut self) -> Self {\n            self.frame = 0;\n            self\n        }\n    }\n    impl RedHatBoyState<Idle> {\n        ....\n        pub fn run(self) -> RedHatBoyState<Running> {\n            RedHatBoyState {\n                context: self.context.reset_frame(),\n                _state: Running {},\n            }\n        }\n    }\n```", "```rs\nmod red_hat_boy_states {\n....\nconst RUNNING_SPEED: i16 = 3;\n...\nimpl RedHatBoyContext {\n    ...\n        fn run_right(mut self) -> Self {\n            self.velocity.x += RUNNING_SPEED;\n            self\n        }\n    }\n    impl RedHatBoyState<Idle> {\n        pub fn run(self) -> RedHatBoyState<Running> {\n            RedHatBoyState {\n                context: self.context.reset_frame()\n                 .run_right(),\n                _state: Running {},\n            }\n        }\n    }\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    if keystate.is_pressed(\"ArrowRight\") {\n        velocity.x += 3;\n        self.rhb.as_mut().unwrap().run_right();\n    }\n}\nimpl RedHatBoy {\n    ...\n    fn run_right(&mut self) {\n        self.state = self.state.transition(\n         Event::Run);\n    }\n}\n```", "```rs\npub struct WalkTheDog {\n   rhb: Option<RedHatBoy>,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    fn update(&mut self, keystate: &KeyState) {\n        ...\n        if keystate.is_pressed(\"ArrowDown\") {\n            self.rhb.as_mut().unwrap().slide();\n        }\n    }\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn slide(&mut self) {\n        self.state_machine = self.state_machine.transition(\n         Event::Slide);\n    }\n}\n```", "```rs\nenum Event {\n    ....\n    Slide,\n}\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            ...\n            (RedHatBoyStateMachine::Running(state), \n             Event::Slide) => state.slide().into(),\n            _ => self,\n        }\n    }\n    ...\n```", "```rs\nmod red_hat_boy_states {\n    ...\n    impl RedHatBoyState<Running> {\n        ...\n        pub fn slide(self) -> RedHatBoyState<Sliding> {\n            RedHatBoyState {\n                context: self.context.reset_frame(),\n                _state: Sliding {},\n            }\n        }\n    }\n```", "```rs\nenum RedHatBoyStateMachine {\n    ...\n    Sliding(RedHatBoyState<Sliding>),\n}\nimpl From<RedHatBoyState<Sliding>> for RedHatBoyStateMachine {\n    fn from(state: RedHatBoyState<Sliding>) -> Self {\n        RedHatBoyStateMachine::Sliding(state)\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    ...   \n    fn frame_name(&self) -> &str {\n        match self {\n            ...\n            RedHatBoyStateMachine::Sliding(state) => \n             state.frame_name(),\n        }\n    }\n    fn context(&self) ->&RedHatBoyContext{\n        match self {\n            ...\n            RedHatBoyStateMachine::Sliding(state) \n             => &state.context(),\n        }\n    }\n    fn update(self) -> Self {\n        match self {\n            RedHatBoyStateMachine::Sliding(mut state) => {\n                state.update();\n                RedHatBoyStateMachine::Sliding(state)\n            }\n        }\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    const SLIDING_FRAMES: u8 = 14;\n    const SLIDING_FRAME_NAME: &str = \"Slide\";\n    ...\n   #[derive(Copy, Clone)]\n    struct Sliding;\n    impl RedHatBoyState<Sliding> {\n        pub fn frame_name(&self) -> &str {\n            SLIDING_FRAME_NAME\n        }\n        pub fn update(&mut self) {\n            self.context = self.context.update(\n             SLIDING_FRAMES);\n        }\n    }\n}\n```", "```rs\nfn update(self) -> Self {\n    match self {\n        ...\n        RedHatBoyStateMachine::Sliding(mut state) => {\n            state.update(SLIDING_FRAMES);\n            if state.context().frame >= SLIDING_FRAMES {\n                RedHatBoyStateMachine::Running(\n                 state.stand())\n            } else {\n                RedHatBoyStateMachine::Sliding(state)\n            }\n        }\n    }\n}\n```", "```rs\npub enum Event {\n    ...\n    Update,\n}\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            (RedHatBoyStateMachine::Idle(state), \n             Event::Run) => state.run().into(),\n            (RedHatBoyStateMachine::Running(state), \n             Event::Slide) => state.slide().into(),\n            (RedHatBoyStateMachine::Idle(state), \n             Event::Update) => state.update().into(),\n(RedHatBoyStateMachine::Running(state), \n             Event::Update) => state.update().into(),\n            _ => self,\n        }\n    }\n    ...\n    fn update(self) -> Self {\n        self.transition(Event::Update)\n    }\n}\n```", "```rs\nerror[E0277]: the trait bound 'RedHatBoyStateMachine: From<()>' is not satisfied\n   --> src/game.rs:155:83\n    |\n155 |             (RedHatBoyStateMachine::Idle(state), Event::Update) => state.update().into(),\n    |                                                                                  ^^^^ the trait 'From<()>' is not implemented for 'RedHatBoyStateMachine'\n```", "```rs\nmod red_hat_boy_states {\n    impl RedHatBoyState<Idle> {\n        ...\n        pub fn update(mut self) -> Self {\n            self.context = self.context.update(\n             IDLE_FRAMES);\n            self\n        }\n}\n...\nimpl RedHatBoyState<Running> {\n    ...\n    pub fn update(mut self) -> Self {\n        self.context = self.context.update(RUNNING_FRAMES);\n        self\n    }\n}\n...\n```", "```rs\nthe trait 'From<red_hat_boy_states::RedHatBoyState<red_hat_boy_states::Idle>>' is not implemented for 'RedHatBoyStateMachine'\n```", "```rs\nimpl From<RedHatBoyState<Idle>> for RedHatBoyStateMachine {\n    fn from(state: RedHatBoyState<Idle>) -> Self {\n        RedHatBoyStateMachine::Idle(state)\n    }\n}\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            ...\n            (RedHatBoyStateMachine::Sliding(state), \n             Event::Update) => state.update().into(),\n            _ => self,\n        }\n    }\n```", "```rs\nthe trait 'From<()>' is not implemented for 'RedHatBoyStateMachine'\n```", "```rs\nmod red_hat_boy_states {\n    ...\n    impl RedHatBoyState<Sliding> {\n        ...\n        pub fn update(mut self) -> SlidingEndState {\n            self.context = self.context.update(\n             SLIDING_FRAMES);\n            if self.context.frame >= SLIDING_FRAMES {\n                SlidingEndState::Complete(self.stand())\n            } else {\n                SlidingEndState::Sliding(self)\n            }\n        }\n    }\n}\n```", "```rs\nimpl RedHatBoyState<Sliding> {\n    ...\n    pub fn stand(self) -> RedHatBoyState<Running> {\n        RedHatBoyState {\n            context: self.context.reset_frame(),\n            _state: Running,\n        }\n    }\n}\npub enum SlidingEndState {\n    Complete(RedHatBoyState<Running>),\n    Sliding(RedHatBoyState<Sliding>),\n}\n```", "```rs\nthe trait 'From<SlidingEndState>' is not implemented for 'RedHatBoyStateMachine'\n```", "```rs\nimpl From<SlidingEndState> for RedHatBoyStateMachine {\n    fn from(end_state: SlidingEndState) -> Self {\n        match end_state {\n            SlidingEndState::Complete(running_state) => \n             running_state.into(),\n            SlidingEndState::Sliding(sliding_state) => \n             sliding_state.into(),\n        }\n    }\n}\n```", "```rs\npub enum WalkTheDog {\n    Loading,\n    Loaded(RedHatBoy),\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                let json = browser::fetch_json(\n                 \"rhb.json\").await?;\n                let rhb = RedHatBoy::new(\n                    json.into_serde::<Sheet>()?,\n                    engine::load_image(\"rhb.png\").await?,\n                );\n                Ok(Box::new(WalkTheDog::Loaded(rhb)))\n            }\n            WalkTheDog::Loaded(_) => Err(anyhow!\n                (\"Error: Game is already initialized!\")),\n        }\n}\n...\n```", "```rs\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog::Loading\n    }\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(rhb) = self {\n            if keystate.is_pressed(\"ArrowRight\") {\n                rhb.run_right();\n            }\n            if keystate.is_pressed(\"ArrowDown\") {\n                rhb.slide();\n            }\n            rhb.update();\n        }\n    }\n    fn draw(&self, renderer: &Renderer) {\n        ...\n        if let WalkTheDog::Loaded(rhb) = self {\n            rhb.draw(renderer);\n        }\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(rhb) = self {\n            ...\n            if keystate.is_pressed(\"Space\") {\n                rhb.jump();\n            }\n        }\n    }\n}\nimpl RedHatBoy {\n    ...\n    fn jump(&mut self) {\n        self.state_machine = self.state_machine.transition(\n         Event::Jump);\n    }\n}\n```", "```rs\nmod red_hat_boy_states {\n    ...\n    const JUMP_SPEED: i16 = -25;\n    ...\n    impl RedHatBoyState<Running> {\n        ...\n        pub fn jump(self) -> RedHatBoyState<Jumping> {\n            RedHatBoyState {\n                context: self.context.set_vertical_\n                 velocity(JUMP_SPEED).reset_frame(),\n                _state: Jumping {},\n            }\n        }\n        ...\n    impl RedHatBoyContext {\n        ...\n        fn set_vertical_velocity(mut self, y: i16) -> \n         Self {\n            self.velocity.y = y;\n            self\n        }\n```", "```rs\nmod red_hat_boy_states {\n...\nconst GRAVITY: i16 = 1;\n    impl RedHatBoyContext {\n        fn update(mut self, frame_count: u8) -> Self {\n             self.velocity.y += GRAVITY;\n```", "```rs\n    impl RedHatBoyContext {\n        pub fn update(mut self, frame_count: u8) -> \n        Self {\n            ...\n            self.position.x += self.velocity.x;\n            self.position.y += self.velocity.y;\n            if self.position.y > FLOOR {\n                self.position.y = FLOOR;\n            }\n```", "```rs\nimpl RedHatBoyState<Jumping> {\n    ...\n    pub fn update(mut self) -> JumpingEndState {\n        self.context = self.context.update(\n         JUMPING_FRAMES);\n        if self.context.position.y >= FLOOR {\n            JumpingEndState::Complete(self.land())\n        } else {\n            JumpingEndState::Jumping(self)\n        }\n    }\n}\n```", "```rs\nerror[E0599]: no method named 'land' found for struct 'red_hat_boy_states::RedHatBoyState' in the current scope\n   --> src/game.rs:413:48\n    |\n258 |     pub struct RedHatBoyState<S> {\n    |     ---------------------------- method 'land' not found for this\n```"]