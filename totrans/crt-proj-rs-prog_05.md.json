["```rs\ncargo install cargo-web\n```", "```rs\nYou can access the web server at `http://127.0.0.1:8000`.\n```", "```rs\n yew::start_app::<Model>();\n```", "```rs\nyew = \"0.6\"\n```", "```rs\nstruct Model {\n    value: u64,\n}\n\n```", "```rs\nenum Msg {\n    Increment,\n    Reset,\n    KeyDown(String),\n}\n```", "```rs\nimpl Component for Model {\n    type Message = Msg;\n    type Properties = ();\n    fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {\n        Self { value: 0 }\n    }\n    fn update(&mut self, msg: Self::Message) -> ShouldRender { ... }\n}\n```", "```rs\nmatch msg {\n    Msg::Increment => {\n        self.value += 1;\n        true\n    }\n    Msg::Reset => {\n        self.value = 0;\n        true\n    }\n```", "```rs\nMsg::KeyDown(s) => match s.as_ref() {\n    \"+\" => {\n        self.value += 1;\n        true\n    }\n    \"0\" => {\n        self.value = 0;\n        true\n    }\n    _ => false,\n}\n```", "```rs\nimpl Renderable<Model> for Model {\n    fn view(&self) -> Html<Self> {\n        html! { ... }\n    }\n}\n```", "```rs\n<div>\n    <button onclick=|_| Msg::Increment,>{\"Increment\"}</button>\n    <button onclick=|_| Msg::Reset,>{\"Reset\"}</button>\n    <input\n        readonly=\"true\",\n        value={self.value},\n        onkeydown=|e| Msg::KeyDown(e.key()),\n    />\n</div>\n```", "```rs\n<div>\n    <button onclick=\"notify(Increment)\">Increment</button>\n    <button onclick=\"notify(Reset)\">Reset</button>\n    <input\n        readonly=\"true\"\n        value=\"[value]\"\n        onkeydown=\"notify(KeyDown, [key])\"),\n    />\n</div>\n```", "```rs\n#![recursion_limit = \"128\"]\n#[macro_use]\nextern crate yew;\n```", "```rs\naddend1: String,\naddend2: String,\nsum: Option<f64>,\n```", "```rs\n ChangedAddend1(String),\n ChangedAddend2(String),\n ComputeSum,\n```", "```rs\nself.sum = match (self.addend1.parse::<f64>(), self.addend2.parse::<f64>()) {\n    (Ok(a1), Ok(a2)) => Some(a1 + a2),\n    _ => None,\n};\n```", "```rs\nMsg::ChangedAddend1(value) => {\n    self.addend1 = value;\n    self.sum = None;\n}\n```", "```rs\n let numeric = \"text-align: right;\";\n```", "```rs\n<input type=\"number\", style=numeric,\n    oninput=|e| Msg::ChangedAddend1(e.value),/>\n```", "```rs\n<input type=\"number\",\n\n    style=numeric.to_string()\n        + \"background-color: \"\n        + if self.sum.is_some() { \"lightgreen;\" } else { \"yellow;\" },\n         readonly=\"true\", value={\n        match self.sum { Some(n) => n.to_string(), None => \"\".to_string() }\n    },\n/>\n```", "```rs\n#[derive(PartialEq, Clone)]\npub struct DbConnection {\n    users: Vec<User>,\n}\n```", "```rs\npub enum DbPrivilege {\n    CanRead,\n    CanWrite,\n}\n\npub struct User {\n    pub username: String,\n    pub password: String,\n    pub privileges: Vec<DbPrivilege>,\n}\n```", "```rs\npub fn new() -> DbConnection {\n    DbConnection {\n        users: vec![\n            User {\n                username: \"joe\".to_string(),\n                password: \"xjoe\".to_string(),\n                privileges: vec![DbPrivilege::CanRead],\n            },\n            User {\n                username: \"susan\".to_string(),\n                password: \"xsusan\".to_string(),\n                privileges: vec![DbPrivilege::CanRead, \n                 DbPrivilege::CanWrite],\n            },\n        ],\n    }\n}\n```", "```rs\npub fn get_user_by_username(&self, username: &str) -> Option<&User> {\n    if let Some(u) = self.users.iter().find(|u| \n     u.username == username) {\n        Some(u)\n    } else {\n        None\n    }\n}\n```", "```rs\nmod login;\n\nenum Page {\n    Login,\n    PersonsList,\n}\n```", "```rs\nstruct MainModel {\n    page: Page,\n    current_user: Option<String>,\n    can_write: bool,\n    db_connection: std::rc::Rc<std::cell::RefCell<DbConnection>>,\n}\n```", "```rs\nenum MainMsg {\n    LoggedIn(User),\n    ChangeUserPressed,\n}\n```", "```rs\nmatch msg {\n    MainMsg::LoggedIn(user) => {\n        self.page = Page::PersonsList;\n        self.current_user = Some(user.username);\n        self.can_write = user.privileges.contains(&DbPrivilege::CanWrite);\n    }\n    MainMsg::ChangeUserPressed => self.page = Page::Login,\n```", "```rs\nPage::Login => html! {\n    <LoginModel:\n        current_username=&self.current_user,\n        when_logged_in=|u| MainMsg::LoggedIn(u),\n        db_connection=Some(self.db_connection.clone()),\n    />\n},\nPage::PersonsList => html! {\n    <h2>{ \"Page to be implemented\" }</h2>\n},\n```", "```rs\npub struct LoginModel {\n    dialog: DialogService,\n    username: String,\n    password: String,\n    when_logged_in: Option<Callback<User>>,\n    db_connection: std::rc::Rc<std::cell::RefCell<DbConnection>>,\n}\n```", "```rs\npub enum LoginMsg {\n    UsernameChanged(String),\n    PasswordChanged(String),\n    LoginPressed,\n}\n```", "```rs\npub struct LoginProps {\n    pub current_username: Option<String>,\n    pub when_logged_in: Option<Callback<User>>,\n    pub db_connection: \n     Option<std::rc::Rc<std::cell::RefCell<DbConnection>>>,\n}\n```", "```rs\nimpl Default for LoginProps {\n    fn default() -> Self {\n        LoginProps {\n            current_username: None,\n            when_logged_in: None,\n            db_connection: None,\n        }\n    }\n}\n```", "```rs\nimpl Component for LoginModel {\n    type Message = LoginMsg;\n    type Properties = LoginProps;\n```", "```rs\nfn create(props: Self::Properties, _link: ComponentLink<Self>)\n-> Self {\n    LoginModel {\n        dialog: DialogService::new(),\n        username: props.current_username.unwrap_or(String::new()),\n        password: String::new(),\n        when_logged_in: props.when_logged_in,\n        db_connection: props.db_connection.unwrap(),\n    }\n}\n```", "```rs\nif let Some(user) = self.db_connection.borrow()\n    .get_user_by_username(&self.username)\n{\n    if user.password == self.password {\n        if let Some(ref go_to_page) = self.when_logged_in {\n            go_to_page.emit(user.clone());\n        }\n    } else {\n        self.dialog.alert(\"Invalid password for the specified user.\");\n    }\n} else {\n    self.dialog.alert(\"User not found.\");\n}\n```", "```rs\nfn change(&mut self, props: Self::Properties) -> ShouldRender {\n    self.username = props.current_username.unwrap_or(String::new());\n    self.when_logged_in = props.when_logged_in;\n    self.db_connection = props.db_connection.unwrap();\n    true\n}\n```", "```rs\npub struct PersonsListModel {\n    dialog: DialogService,\n    id_to_find: Option<u32>,\n    name_portion: String,\n    filtered_persons: Vec<Person>,\n    selected_ids: std::collections::HashSet<u32>,\n    can_write: bool,\n    go_to_one_person_page: Option<Callback<Option<Person>>>,\n    db_connection: std::rc::Rc<std::cell::RefCell<DbConnection>>,\n}\n```", "```rs\npub enum PersonsListMsg {\n    IdChanged(String),\n    FindPressed,\n    PartialNameChanged(String),\n    FilterPressed,\n    DeletePressed,\n    AddPressed,\n    SelectionToggled(u32),\n    EditPressed(u32),\n}\n```", "```rs\npub struct PersonsListProps {\n    pub can_write: bool,\n    pub go_to_one_person_page: Option<Callback<Option<Person>>>,\n    pub db_connection: \n     Option<std::rc::Rc<std::cell::RefCell<DbConnection>>>,\n}\n```", "```rs\nmodel.filtered_persons = model.db_connection.borrow()\n    .get_persons_by_partial_name(\"\");\n```", "```rs\nself.id_to_find = id_str.parse::<u32>().ok(),\n```", "```rs\nmatch self.id_to_find {\n    Some(id) => { self.update(PersonsListMsg::EditPressed(id)); }\n    None => { self.dialog.alert(\"No id specified.\"); }\n},\n```", "```rs\nself.filtered_persons = self\n    .db_connection\n    .borrow()\n    .get_persons_by_partial_name(&self.name_portion);\n```", "```rs\nif self\n    .dialog\n    .confirm(\"Do you confirm to delete the selected persons?\") {\n    {\n        let mut db = self.db_connection.borrow_mut();\n        for id in &self.selected_ids {\n            db.delete_by_id(*id);\n        }\n    }\n    self.update(PersonsListMsg::FilterPressed);\n    self.dialog.alert(\"Deleted.\");\n}\n```", "```rs\nif let Some(ref go_to_page) = self.go_to_one_person_page {\n    go_to_page.emit(None);\n}\n```", "```rs\nif self.selected_ids.contains(&id) {\n    self.selected_ids.remove(&id);\n} else {\n    self.selected_ids.insert(id);\n}\n```", "```rs\nmatch self.db_connection.borrow().get_person_by_id(id) {\n    Some(person) => {\n        if let Some(ref go_to_page) = self.go_to_one_person_page {\n            go_to_page.emit(Some(person.clone()));\n        }\n    }\n    None => self.dialog.alert(\"No person found with the indicated id.\"),\n}\n```", "```rs\nfor self.filtered_persons.iter().map(|p| {\n    let id = p.id;\n    let name = p.name.clone();\n    html! {\n        ...\n    }\n})\n```", "```rs\npub struct OnePersonModel {\n    id: Option<u32>,\n    name: String,\n    can_write: bool,\n    is_inserting: bool,\n    go_to_persons_list_page: Option<Callback<()>>,\n    db_connection: std::rc::Rc<std::cell::RefCell<DbConnection>>,\n}\n```", "```rs\npub enum OnePersonMsg {\n    NameChanged(String),\n    SavePressed,\n    CancelPressed,\n}\n```", "```rs\npub struct OnePersonProps {\n    pub id: Option<u32>,\n    pub name: String,\n    pub can_write: bool,\n    pub go_to_persons_list_page: Option<Callback<()>>,\n    pub db_connection: \n     Option<std::rc::Rc<std::cell::RefCell<DbConnection>>>,\n}\n```", "```rs\ncargo web start\n```", "```rs\nYou can access the web server at `http://127.0.0.1:8000`.\n```", "```rs\ncargo run\n```", "```rs\ncargo run --release\n```", "```rs\n Listening at address 127.0.0.1:8080\n```", "```rs\nactix-cors = \"0.1\"\n```", "```rs\n.wrap(\n    actix_cors::Cors::new()\n        .allowed_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\"])\n)\n```", "```rs\nfailure = \"0.1\"\nserde = \"1\"\nserde_derive = \"1\"\nurl = \"1\"\nbase64 = \"0.10\"\n```", "```rs\nself.fetching = true;\nself.console.log(&format!(\"EditPressed: {:?}.\", id));\nlet callback =\n    self.link\n        .send_back(move |response: Response<Json<Result<Person, Error>>>| {\n            let (meta, Json(data)) = response.into_parts();\n            if meta.status.is_success() {\n                PersonsListMsg::ReadyPersonToEdit(data)\n            } else {\n                PersonsListMsg::Failure(\n                    \"No person found with the indicated id\".to_string(),\n                )\n            }\n        });\n```", "```rs\nlet mut request = Request::get(format!(\"{}person/id/{}\", BACKEND_SITE, id))\n    .body(Nothing)\n    .unwrap();\n\nadd_auth(&self.username, &self.password, &mut request);\nself.ft = Some(self.fetch_service.fetch(request, callback));\n```", "```rs\nself.fetching = false;\nlet person = person.unwrap_or(Person {\n    id: 0,\n    name: \"\".to_string(),\n});\nif let Some(ref go_to_page) = self.go_to_one_person_page {\n    self.console\n        .log(&format!(\"ReadyPersonToEdit: {:?}.\", person));\n    go_to_page.emit(Some(person.clone()));\n}\n```", "```rs\nself.fetching = false;\nself.console.log(&format!(\"Failure: {:?}.\", msg));\nself.dialog.alert(&msg);\nreturn false;\n```"]