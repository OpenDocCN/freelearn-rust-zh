<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-83"><em class="italic"><a id="_idTextAnchor083"/>Chapter 6</em>: Implementing User CRUD</h1>
			<p>In the previous chapter, we created a rough outline for the application. In this chapter, we are going to implement the endpoints for managing users. By implementing the endpoints in this chapter, you are going to learn about HTTP basic operations for an entity, that is, creating, reading, updating, and deleting an entity.</p>
			<p>In addition, you are going to learn how to construct HTML and an HTML form, send the form payload to the server, validate and sanitize the form payload, hash the password payload, and handle failure by redirecting to another endpoint with a message.</p>
			<p>Along with implementing the endpoints, you will also learn how to query single and multiple rows from the database, and how to insert, update, and delete a row from the database.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Implementing GET user</li>
				<li>Implementing GET users</li>
				<li>Implementing POST user</li>
				<li>Implementing PUT and PATCH user</li>
				<li>Implementing DELETE user</li>
			</ul>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06</a>.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Implementing GET user</h1>
			<p>Let's look <a id="_idIndexMarker330"/>at the steps to implement this:</p>
			<ol>
				<li>We'll start with the basics by implementing the <strong class="source-inline">get_user()</strong> function in <strong class="source-inline">src/routes/user.rs</strong>:<p class="source-code">#[get("/users/&lt;_uuid&gt;", format = "text/html")]</p><p class="source-code">pub async fn get_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {</p><p class="source-code">    todo!("will implement later")</p><p class="source-code">}</p></li>
			</ol>
			<p>Before we implement <strong class="source-inline">get_user()</strong>, we want to prepare the other routines that we will use. For example, we want to return HTML, so we need to create a <strong class="source-inline">const</strong> of <strong class="source-inline">&amp;'static str</strong> in the same <strong class="source-inline">src/routes/user.rs</strong> file as our HTML template.</p>
			<ol>
				<li value="2">We will create two separate instances of <strong class="source-inline">const</strong> so we can insert different contents between the HTML prefix and suffix:<p class="source-code">const USER_HTML_PREFIX: &amp;str = r#"&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">&lt;meta charset="utf-8" /&gt;</p><p class="source-code">&lt;title&gt;Our Application User&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;"#;</p><p class="source-code">const USER_HTML_SUFFIX: &amp;str = r#"&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;"#;</p></li>
			</ol>
			<p>After that, we will create two methods for a <strong class="source-inline">User</strong> struct. The first one is the find method to find the entry in the database server, and the second one is to create an HTML string for a <strong class="source-inline">User</strong> instance.</p>
			<ol>
				<li value="3">In the <strong class="source-inline">src/models/user.rs</strong> file, add the following lines to the <strong class="source-inline">use</strong> directives:<p class="source-code">use rocket_db_pools::sqlx::{FromRow<strong class="bold">, PgConnection</strong>};</p><p class="source-code"><strong class="bold">use std::error::Error;</strong></p></li>
				<li>Then, create an <strong class="source-inline">impl</strong> block for <strong class="source-inline">User</strong>:<p class="source-code">impl User{}</p></li>
				<li>Inside the <a id="_idIndexMarker331"/>block, add the <strong class="source-inline">find()</strong> method:<p class="source-code">pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {</p><p class="source-code">    let parsed_uuid = Uuid::parse_str(uuid)?;</p><p class="source-code">    let query_str = "SELECT * FROM users WHERE uuid = </p><p class="source-code">    $1";</p><p class="source-code">    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .fetch_one(connection)</p><p class="source-code">        .await?)</p><p class="source-code">}</p></li>
			</ol>
			<p>We created a similar method before. The first thing we do is parse the UUID (Universal Unique Identifier) <strong class="source-inline">&amp;str</strong> into a <strong class="source-inline">Uuid</strong> instance and use the question mark operator (<strong class="source-inline">?</strong>) to quickly return <strong class="source-inline">Box&lt;dyn Error&gt;</strong>. After that, we define the SQL query string, <strong class="source-inline">query_str</strong>, and finally, we return the <strong class="source-inline">User</strong> instance.</p>
			<p>One thing a little different here is that we are passing the mutable reference to <strong class="source-inline">PgConnection</strong> itself, instead of a mutable reference to <strong class="source-inline">Connection&lt;DBConnection&gt;</strong>.</p>
			<p>Remember previously, we used <strong class="source-inline">Connection&lt;DBConnection&gt;</strong> as in the following:</p>
			<p class="source-code">pub async fn find(<strong class="bold">db: &amp;mut Connection&lt;DBConnection&gt;</strong>, uuid: &amp;str) -&gt; ... {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">        .fetch_one<strong class="bold">(&amp;mut *db</strong>)</p>
			<p class="source-code">        .await?)</p>
			<p class="source-code">}</p>
			<p>We first dereference <strong class="source-inline">db</strong> using an asterisk (<strong class="source-inline">*</strong>) operator. The connection implements <strong class="source-inline">std::ops::Deref</strong>, and its implementation exposes the new type, <strong class="source-inline">DBConnection</strong>, which is a wrapper for <strong class="source-inline">sqlx::PgPool</strong>, an alias to <strong class="source-inline">sqlx::Pool&lt;sqlx::Postgres&gt;</strong>.</p>
			<p>The <strong class="source-inline">sqlx::Executor</strong> trait is implemented for <strong class="source-inline">sqlx::PgConnection</strong>, a struct that <a id="_idIndexMarker332"/>implements the <strong class="source-inline">sqlx::Connection</strong> trait, representing a single connection to the database. The <strong class="source-inline">sqlx::Executor</strong> trait is also implemented for <strong class="source-inline">&amp;sqlx::Pool</strong>, an asynchronous pool of SQLx database connections.</p>
			<p>Since various <strong class="source-inline">sqlx</strong> methods (such as <strong class="source-inline">fetch_all</strong>, <strong class="source-inline">fetch_one</strong>, <strong class="source-inline">fetch_many</strong>, <strong class="source-inline">fetch</strong>, <strong class="source-inline">execute</strong>, and <strong class="source-inline">execute_many</strong>) accept the generic type <strong class="source-inline">E</strong>, which is bound by the <strong class="source-inline">sqlx::Executor</strong> trait, we can use either the reference to the pool itself or the connection obtained from the pool in those methods.</p>
			<p>There's a problem with the <strong class="source-inline">find()</strong> method since <strong class="source-inline">OurDateTime</strong> is a type unknown by <strong class="source-inline">sqlx</strong>.</p>
			<ol>
				<li value="6">Add the following directive in <strong class="source-inline">src/models/our_date_time.rs</strong>:<p class="source-code">#[derive(Debug<strong class="bold">, sqlx::Type</strong>)]</p><p class="source-code"><strong class="bold">#[sqlx(transparent)]</strong></p><p class="source-code">pub struct OurDateTime(DateTime&lt;Utc&gt;);</p></li>
			</ol>
			<p>The <strong class="source-inline">transparent</strong> directive automatically generates implementations referring to the implementation of the inner type, which in our case is <strong class="source-inline">DateTime&lt;Utc&gt;</strong>.</p>
			<ol>
				<li value="7">Beside the <strong class="source-inline">find()</strong> method, let's <a id="_idIndexMarker333"/>implement another method to convert <strong class="source-inline">User</strong> to an HTML <strong class="source-inline">String</strong>:<p class="source-code">pub fn to_html_string(&amp;self) -&gt; String {</p><p class="source-code">    format!(</p><p class="source-code">        r#"&lt;div&gt;&lt;span class="label"&gt;UUID: </p><p class="source-code">        &lt;/span&gt;{uuid}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Username: &lt;/span&gt;{username}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Email: &lt;/span&gt;{email}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Description: &lt;/span&gt;{description}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Status: &lt;/span&gt;{status}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Created At: &lt;/span&gt;{created_at}&lt;/div&gt;</p><p class="source-code">&lt;div&gt;&lt;span class="label"&gt;Updated At: &lt;/span&gt;{updated_at}&lt;/div&gt;"#,</p><p class="source-code">        uuid = self.uuid,</p><p class="source-code">        username = self.username,</p><p class="source-code">        email = self.email,</p><p class="source-code">        description = self.description.as_ref().</p><p class="source-code">        unwrap_or(&amp;String::from("")),</p><p class="source-code">        status = self.status.to_string(),</p><p class="source-code">        created_at = self.created_at.0.to_rfc3339(),</p><p class="source-code">        updated_at = self.updated_at.0.to_rfc3339(),</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>Since the <strong class="source-inline">OurDateTime</strong> member is private but we access it like <strong class="source-inline">self.created_at.</strong><strong class="bold">0</strong><strong class="source-inline">.to_rfc3339()</strong>, it's going to create an error when we compile it. To resolve it, convert the member of <strong class="source-inline">OurDateTime</strong> in <strong class="source-inline">src/models/our_date_time.rs</strong> to public:<p class="source-code">pub struct OurDateTime(<strong class="bold">pub </strong>DateTime&lt;Utc&gt;);</p></li>
			</ol>
			<p>We need <a id="_idIndexMarker334"/>to implement the <strong class="source-inline">to_string()</strong> method for <strong class="source-inline">UserStatus</strong> as well. We can choose to implement <strong class="source-inline">to_string()</strong>, or we can implement <strong class="source-inline">std::fmt::Display</strong>, which automatically provides <strong class="source-inline">to_string()</strong>. As a bonus, with the <strong class="source-inline">Display</strong> trait, we can also use it in the <strong class="source-inline">format!("{}", something)</strong> macro.</p>
			<ol>
				<li value="9">Modify <strong class="source-inline">src/models/user_status.rs</strong> as follows:<p class="source-code">use std::fmt;</p><p class="source-code">...</p><p class="source-code">impl fmt::Display for UserStatus {</p><p class="source-code">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; </p><p class="source-code">    fmt::Result {</p><p class="source-code">        match *self {</p><p class="source-code">            UserStatus::Inactive =&gt; write!(f, </p><p class="source-code">           "Inactive"),</p><p class="source-code">            UserStatus::Active =&gt; write!(f, "Active"),</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>It's time <a id="_idIndexMarker335"/>to implement the <strong class="source-inline">get_user()</strong> function in <strong class="source-inline">src/routes/user.rs</strong>:<p class="source-code"><strong class="bold">use rocket::http::Status;</strong></p><p class="source-code"><strong class="bold">use rocket::response::content::RawHtml;</strong></p><p class="source-code">use rocket_db_pools::{<strong class="bold">sqlx::Acquire</strong>, Connection};</p><p class="source-code">#[get("/users/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]</p><p class="source-code">pub async fn get_user(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;, <strong class="bold">uuid</strong>: &amp;str) -&gt; HtmlResponse {</p><p class="source-code">    let connection = db</p><p class="source-code">        .acquire()</p><p class="source-code">        .await</p><p class="source-code">        .map_err(|_| Status::InternalServerError)?;</p><p class="source-code">}</p></li>
			</ol>
			<p>First, we add the required <strong class="source-inline">use</strong> directives, and then we remove the underscore from <strong class="source-inline">_db</strong> and <strong class="source-inline">_uuid</strong> to mark it as a used variable. Then, we acquire a single connection from the database pool or return <strong class="source-inline">InternalServerError</strong> if there's something wrong.</p>
			<ol>
				<li value="11">After we set the connection variable, we can execute the <strong class="source-inline">find()</strong> method we defined previously:<p class="source-code">...</p><p class="source-code">    let user = User::find(connection, uuid)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(|_| Status::NotFound)?;</p></li>
			</ol>
			<p>We only expose a simple error, <strong class="source-inline">NotFound</strong>, for this case, but a more complex application should handle the error properly, such as logging the error and returning the proper error status and error messages.</p>
			<ol>
				<li value="12">Finally, we can <a id="_idIndexMarker336"/>construct the HTML string and return it:<p class="source-code">...</p><p class="source-code">    let mut html_string = String::from(USER_HTML_PREFIX);</p><p class="source-code">    html_string.push_str(&amp;user.to_html_string());</p><p class="source-code">    html_string.push_str(format!(r#"&lt;a href="</p><p class="source-code">    /users/edit/{}"&gt;Edit User&lt;/a&gt;"#, </p><p class="source-code">    user.uuid).as_ref());</p><p class="source-code">    html_string.push_str(r#"&lt;a href="/users"&gt;User </p><p class="source-code">    List&lt;/a&gt;"#);</p><p class="source-code">    html_string.push_str(USER_HTML_SUFFIX);</p><p class="source-code">    Ok(RawHtml(html_string))</p></li>
			</ol>
			<p>Notice we added two links for editing this user and to go to <strong class="source-inline">/users</strong>.</p>
			<p>In the next section, we are going to implement the <strong class="source-inline">get_users()</strong> function so the application can handle a <strong class="source-inline">/users</strong> endpoint.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Implementing GET users</h1>
			<p>Now, let's <a id="_idIndexMarker337"/>implement <strong class="source-inline">get_users()</strong>. Here is a quick reminder of what the function looked like in the previous chapter:</p>
			<pre class="source-code">#[get("/users?&lt;_pagination&gt;", format = "text/html")]</pre>
			<pre class="source-code">pub async fn get_users(</pre>
			<pre class="source-code">    mut _db: Connection&lt;DBConnection&gt;,</pre>
			<pre class="source-code">    _pagination: Option&lt;Pagination&gt;,</pre>
			<pre class="source-code">) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>As before, we should <a id="_idIndexMarker338"/>prepare the routines we're going to use:</p>
			<ol>
				<li value="1">In <strong class="source-inline">src/models/user.rs</strong>, create a method called <strong class="source-inline">find_all</strong>, as in the following:<p class="source-code"><strong class="bold">use super::pagination::{Pagination};</strong></p><p class="source-code"><strong class="bold">use crate::fairings::db::DBConnection;</strong></p><p class="source-code"><strong class="bold">use rocket_db_pools::Connection;</strong></p><p class="source-code">use rocket_db_pools::sqlx::{<strong class="bold">Acquire,</strong> FromRow, PgConnection};</p><p class="source-code">...</p><p class="source-code">impl User {</p><p class="source-code">...</p><p class="source-code">    <strong class="bold">pub async fn find_all(</strong></p><p class="source-code"><strong class="bold">        db: &amp;mut Connection&lt;DBConnection&gt;,</strong></p><p class="source-code"><strong class="bold">        pagination: Option&lt;Pagination&gt;,</strong></p><p class="source-code"><strong class="bold">    ) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), </strong></p><p class="source-code"><strong class="bold">    Box&lt;dyn Error&gt;&gt; {</strong></p><p class="source-code"><strong class="bold">        if pagination.is_some() {</strong></p><p class="source-code"><strong class="bold">            return Self::find_all_with_pagination(db, </strong></p><p class="source-code"><strong class="bold">            &amp;(pagination.unwrap())).await;</strong></p><p class="source-code"><strong class="bold">        } else {</strong></p><p class="source-code"><strong class="bold">            return Self::find_all_without_</strong></p><p class="source-code"><strong class="bold">            pagination(db).await;</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The parameter for <strong class="source-inline">find_all</strong> is <strong class="source-inline">Connection</strong>, which has the connection pool and the optional <strong class="source-inline">Pagination</strong>.</p>
			<p>If the function <a id="_idIndexMarker339"/>is successful, we want to return a vector of <strong class="source-inline">User</strong> and <strong class="source-inline">Pagination</strong>. We can wrap it as a <em class="italic">tuple</em> in parentheses <strong class="source-inline">()</strong>, but there's a possibility that there's no further row in the database, so we wrap the returned <strong class="source-inline">Pagination</strong> in <strong class="source-inline">Option</strong>. We then split it into two methods to make it easier to read: <strong class="source-inline">find_all_without_pagination</strong> and <strong class="source-inline">find_all_with_pagination</strong>.</p>
			<ol>
				<li value="2">Let's modify <strong class="source-inline">src/models/pagination.rs</strong> a little bit, and add <strong class="source-inline">DEFAULT_LIMIT</strong> to limit the number of users we want to fetch at a single time:<p class="source-code">pub const DEFAULT_LIMIT: usize = 10;</p></li>
				<li>We can then create and implement the function for the base case in <strong class="source-inline">src/models/user.rs</strong>, <strong class="source-inline">find_all_without_pagination</strong>:<p class="source-code">use super::pagination::{Pagination, <strong class="bold">DEFAULT_LIMIT</strong>};</p><p class="source-code">...</p><p class="source-code">async fn find_all_without_pagination(db: &amp;mut Connection&lt;DBConnection&gt;) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), Box&lt;dyn Error&gt;&gt; {</p><p class="source-code">    <strong class="bold">let query_str = "SELECT * FROM users ORDER BY </strong></p><p class="source-code"><strong class="bold">    created_at DESC LIMIT $1";</strong></p><p class="source-code"><strong class="bold">    let connection = db.acquire().await?;</strong></p><p class="source-code"><strong class="bold">    let users = sqlx::query_as::&lt;_, Self&gt;(query_str)</strong></p><p class="source-code"><strong class="bold">        .bind(DEFAULT_LIMIT as i32)</strong></p><p class="source-code"><strong class="bold">        .fetch_all(connection)</strong></p><p class="source-code"><strong class="bold">        .await?;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Like the <strong class="source-inline">find()</strong> method, we define <strong class="source-inline">query_str</strong> and execute the query, and bind the <strong class="source-inline">Vec&lt;User&gt;</strong> result to the <strong class="source-inline">users</strong> variable. But, why do we pass the <strong class="source-inline">&amp;mut Connection&lt;DBConnection&gt;</strong> database connection pool this time? Let's <a id="_idIndexMarker340"/>continue the function first:</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    let mut new_pagination: Option&lt;Pagination&gt; = None;</p>
			<p class="source-code">    if users.len() == DEFAULT_LIMIT {</p>
			<p class="source-code">        let query_str = "SELECT EXISTS(SELECT 1 FROM </p>
			<p class="source-code">        users WHERE created_at &lt; $1 ORDER BY </p>
			<p class="source-code">        created_at DESC LIMIT 1)";</p>
			<p class="source-code">        let connection = db.acquire().await?;</p>
			<p class="source-code">        let exists = sqlx::query_as::&lt;_,</p>
			<p class="source-code">        BoolWrapper&gt;(query_str)</p>
			<p class="source-code">            .bind(&amp;users.last().unwrap().created_at)</p>
			<p class="source-code">            .fetch_one(connection)</p>
			<p class="source-code">            .await?;</p>
			<p class="source-code">        if exists.0 {</p>
			<p class="source-code">            new_pagination = Some(Pagination {</p>
			<p class="source-code">                next: users.last().unwrap().</p>
			<p class="source-code">                created_at.to_owned(),</p>
			<p class="source-code">                limit: DEFAULT_LIMIT,</p>
			<p class="source-code">            });</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Ok((users, new_pagination))</p>
			<p class="source-code">}</p>
			<p>We then prepare the returned pagination, setting it to <strong class="source-inline">None</strong> first. If the fetched users are equal to <strong class="source-inline">DEFAULT_LIMIT</strong>, there's a possibility of a next row, so we do the <a id="_idIndexMarker341"/>second query to the database. Since we cannot reuse a single connection, we have to obtain a new connection again from the database pool. That's why we pass <strong class="source-inline">&amp;mut Connection&lt;DBConnection&gt;</strong> to <strong class="source-inline">find_all</strong> and <strong class="source-inline">find_all_without_pagination</strong> instead of <strong class="source-inline">&amp;mut PgConnection</strong>. If there's the next row, we can return the pagination wrapped in <strong class="source-inline">Some()</strong>. But, what is <strong class="source-inline">BoolWrapper</strong>? We need to set a type to put the result of the <strong class="source-inline">"SELECT EXISTS..."</strong> query.</p>
			<ol>
				<li value="4">Add <strong class="source-inline">pub mod bool_wrapper;</strong> to <strong class="source-inline">src/models/mod.rs</strong> and create a new file, <strong class="source-inline">src/models/bool_wrapper.rs</strong>, with the following content:<p class="source-code">use rocket_db_pools::sqlx::FromRow;</p><p class="source-code">#[derive(FromRow)]</p><p class="source-code">pub struct BoolWrapper(pub bool);</p></li>
			</ol>
			<p>Don't forget to add <strong class="source-inline">use super::bool_wrapper::BoolWrapper;</strong> to <strong class="source-inline">src/models/user.rs</strong>.</p>
			<ol>
				<li value="5">Now, it's time to implement <strong class="source-inline">find_all_with_pagination</strong>:<p class="source-code">async fn find_all_with_pagination(db: &amp;mut Connection&lt;DBConnection&gt;, pagination: &amp;Pagination) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), Box&lt;dyn Error&gt;&gt; {</p><p class="source-code">    let query_str =</p><p class="source-code">        "SELECT * FROM users WHERE created_at &lt; $1 </p><p class="source-code">         ORDER BY created_at DESC LIMIT </p><p class="source-code">2";</p><p class="source-code">    let connection = db.acquire().await?;</p><p class="source-code">    let users = sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(&amp;pagination.next)</p><p class="source-code">        .bind(DEFAULT_LIMIT as i32)</p><p class="source-code">        .fetch_all(connection)</p><p class="source-code">        .await?;</p><p class="source-code">    let mut new_pagination: Option&lt;Pagination&gt; = None;</p><p class="source-code">    if users.len() == DEFAULT_LIMIT {</p><p class="source-code">        let query_str = "SELECT EXISTS(SELECT 1 FROM </p><p class="source-code">        users WHERE created_at &lt; $1 ORDER BY </p><p class="source-code">        created_at DESC LIMIT 1)";</p><p class="source-code">        let connection = db.acquire().await?;</p><p class="source-code">        let exists = sqlx::query_as::&lt;_, </p><p class="source-code">        BoolWrapper&gt;(query_str)</p><p class="source-code">            .bind(&amp;users.last().unwrap().created_at)</p><p class="source-code">            .fetch_one(connection)</p><p class="source-code">            .await?;</p><p class="source-code">        if exists.0 {</p><p class="source-code">            new_pagination = Some(Pagination {</p><p class="source-code">                next: users.last().unwrap().</p><p class="source-code">                created_at.to_owned(),</p><p class="source-code">                limit: DEFAULT_LIMIT,</p><p class="source-code">            });</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Ok((users, new_pagination))</p><p class="source-code">}</p></li>
			</ol>
			<p>The private method works like <strong class="source-inline">find_all_without_pagination</strong>, but we add a <strong class="source-inline">WHERE</strong> condition to start querying from a certain point.</p>
			<ol>
				<li value="6">Now, it's time <a id="_idIndexMarker342"/>to implement the <strong class="source-inline">get_users()</strong> function:<p class="source-code">#[get("/users?&lt;<strong class="bold">pagination</strong>&gt;", format = "text/html")]</p><p class="source-code">pub async fn get_users(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,</p><p class="source-code">    <strong class="bold">pagination</strong>: Option&lt;Pagination&gt;) -&gt; HtmlResponse {</p><p class="source-code">    <strong class="bold">let (users, new_pagination) = User::find_all(&amp;mut </strong></p><p class="source-code"><strong class="bold">    db, pagination)</strong></p><p class="source-code"><strong class="bold">        .await</strong></p><p class="source-code"><strong class="bold">        .map_err(|_| Status::NotFound)?;</strong></p><p class="source-code">}</p></li>
				<li>After we have obtained <strong class="source-inline">users</strong> and <strong class="source-inline">new_pagination</strong>, we can construct the HTML for the return value:<p class="source-code">...</p><p class="source-code">let mut html_string = String::from(USER_HTML_PREFIX);</p><p class="source-code">for user in users.iter() {</p><p class="source-code">    html_string.push_str(&amp;user.to_html_string());</p><p class="source-code">    html_string</p><p class="source-code">        .push_str(format!(r#"&lt;a href="/users/{}"&gt;See </p><p class="source-code">         User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref());</p><p class="source-code">    html_string.push_str(</p><p class="source-code">        format!(r#"&lt;a href="/users/edit/{}"&gt;Edit </p><p class="source-code">        User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref(),</p><p class="source-code">    );</p><p class="source-code">}</p></li>
				<li>Append <a id="_idIndexMarker343"/>the link to the next page if we have <strong class="source-inline">new_pagination</strong>:<p class="source-code">if let Some(pg) = new_pagination {</p><p class="source-code">    html_string.push_str(</p><p class="source-code">        format!(</p><p class="source-code">            r#"&lt;a href="/users?pagination.next={}&amp;</p><p class="source-code">            pagination.limit={}"&gt;Next&lt;/a&gt;&lt;br/&gt;"#,</p><p class="source-code">            &amp;(pg.next.0).timestamp_nanos(),</p><p class="source-code">            &amp;pg.limit,</p><p class="source-code">        )</p><p class="source-code">        .as_ref(),</p><p class="source-code">    );</p><p class="source-code">}</p></li>
			</ol>
			<p>Notice we use <strong class="source-inline">timestamp_nanos()</strong> to convert time to <strong class="source-inline">i64</strong> to make it easier to transport in the HTML.</p>
			<ol>
				<li value="9">To finalize the function, append the following lines:<p class="source-code">html_string.push_str(r#"&lt;a href="/users/new"&gt;New user&lt;/a&gt;"#);</p><p class="source-code">html_string.push_str(USER_HTML_SUFFIX);</p><p class="source-code">Ok(RawHtml(html_string))</p></li>
				<li>Now, we have to implement <strong class="source-inline">FromFormField</strong> for <strong class="source-inline">OurDateTime</strong> since we are using <strong class="source-inline">OurDateTime</strong> in the pagination. In <strong class="source-inline">src/models/our_date_time.rs</strong>, add the required <strong class="source-inline">use</strong> directives:<p class="source-code">use chrono::{offset::Utc, DateTime, <strong class="bold">TimeZone</strong>};</p><p class="source-code"><strong class="bold">use rocket::data::ToByteUnit;</strong></p></li>
				<li>Because <a id="_idIndexMarker344"/>we are cloning <strong class="source-inline">OurDateTime</strong> inside the <strong class="source-inline">User</strong> implementation (<strong class="source-inline">users.last().unwrap().created_at</strong><strong class="bold">.to_owned()</strong>), we also need to derive <strong class="source-inline">Clone</strong> for <strong class="source-inline">OurDateTime</strong>:<p class="source-code">#[derive(Debug, sqlx::Type<strong class="bold">, Clone</strong>)]</p></li>
				<li>For the <strong class="source-inline">from_value</strong> implementation, we are just parsing <strong class="source-inline">i64</strong> from the request parameter and converting it to the <strong class="source-inline">OurDateTime</strong> object:<p class="source-code"> impl&lt;'r&gt; FromFormField&lt;'r&gt; for OurDateTime {</p><p class="source-code">    fn from_value(<strong class="bold">field</strong>: ValueField&lt;'r&gt;) -&gt; form::</p><p class="source-code">    Result&lt;'r, Self&gt; {</p><p class="source-code">        <strong class="bold">let timestamp = field.value.parse::&lt;i64&gt;()?;</strong></p><p class="source-code"><strong class="bold">        Ok(OurDateTime(</strong></p><p class="source-code"><strong class="bold">        Utc.timestamp_nanos(timestamp)))</strong></p><p class="source-code">    }</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>But, for <strong class="source-inline">from_data</strong>, we have to be more involved because we have to convert the request to <strong class="source-inline">bytes</strong>, convert it again into <strong class="source-inline">&amp;str</strong>, and finally, into <strong class="source-inline">i64</strong>. First, we get the Rocket limit for the form:<p class="source-code">async fn from_data(<strong class="bold">field</strong>: DataField&lt;'r, '_&gt;) -&gt; form::Result&lt;'r, Self&gt; {</p><p class="source-code"><strong class="bold">    let limit = field</strong></p><p class="source-code"><strong class="bold">        .request</strong></p><p class="source-code"><strong class="bold">        .limits()</strong></p><p class="source-code"><strong class="bold">        .get("form")</strong></p><p class="source-code"><strong class="bold">        .unwrap_or_else(|| 8.kibibytes());</strong></p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Then, get the <strong class="source-inline">bytes</strong> from the request:<p class="source-code">let bytes = field.data.open(limit).into_bytes().await?;</p><p class="source-code">if !bytes.is_complete() {</p><p class="source-code">    return Err((None, Some(limit)).into());</p><p class="source-code">}</p><p class="source-code">let bytes = bytes.into_inner();</p></li>
				<li>And finally, we <a id="_idIndexMarker345"/>convert <strong class="source-inline">bytes</strong> to <strong class="source-inline">&amp;str</strong>, parse it as <strong class="source-inline">i64</strong>, and convert it to <strong class="source-inline">OurDateTime</strong>:<p class="source-code">let time_string = std::str::from_utf8(&amp;bytes)?;</p><p class="source-code">let timestamp = time_string.parse::&lt;i64&gt;()?;</p><p class="source-code">Ok(OurDateTime(Utc.timestamp_nanos(timestamp)))</p></li>
			</ol>
			<p>Now, <strong class="source-inline">get_user</strong> and <strong class="source-inline">get_users</strong> are ready, but we do not have any data yet. In the next section, we are going to implement the <strong class="source-inline">new_user</strong> and <strong class="source-inline">create_user</strong> functions so we can insert user data through an HTML form.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Implementing POST user</h1>
			<p>To create <a id="_idIndexMarker346"/>a user, we are going to use the <strong class="source-inline">new_user</strong> and <strong class="source-inline">create_user</strong> functions. The <strong class="source-inline">new_user()</strong> function is relatively easy to implement; we just need to serve an HTML page with a form for a user to fill in.</p>
			<p>Let's look at the steps:</p>
			<ol>
				<li value="1">Implement <a id="_idIndexMarker347"/>the <strong class="source-inline">new_user()</strong> function in <strong class="source-inline">src/routes/user.rs</strong>:<p class="source-code">#[get("/users/new", format = "text/html")]</p><p class="source-code">pub async fn new_user() -&gt; HtmlResponse {</p><p class="source-code">    let mut html_string = String::from(USER_HTML_</p><p class="source-code">    PREFIX);</p><p class="source-code">    html_string.push_str(</p><p class="source-code">        r#"&lt;form accept-charset="UTF-8" <strong class="bold">action="/</strong></p><p class="source-code"><strong class="bold">        users"</strong> autocomplete="off" <strong class="bold">method="POST"</strong>&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;label for="username"&gt;Username:&lt;/label&gt;</p><p class="source-code">        &lt;input name="username" type="text"/&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;label for="email"&gt;Email:&lt;/label&gt;</p><p class="source-code">        &lt;input name="email" type="email"/&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;label for="password"&gt;Password:&lt;/label&gt;</p><p class="source-code">        &lt;input name="password" type="password"/&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;label for="password_confirmation"&gt;Password </p><p class="source-code">        Confirmation:&lt;/label&gt;</p><p class="source-code">        &lt;input name="password_confirmation" </p><p class="source-code">        type="password"/&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;label for="description"&gt;Tell us a little bit </p><p class="source-code">        more about yourself:&lt;/label&gt;</p><p class="source-code">        &lt;textarea name="description"&gt;&lt;/textarea&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;button type="submit" value="Submit"&gt;Submit&lt;/</p><p class="source-code">     button&gt;</p><p class="source-code">&lt;/form&gt;"#,</p><p class="source-code">    );</p><p class="source-code">    html_string.push_str(USER_HTML_SUFFIX);</p><p class="source-code">    Ok(RawHtml(html_string))</p><p class="source-code">}</p></li>
			</ol>
			<p>In the HTML, we <a id="_idIndexMarker348"/>set the <strong class="source-inline">form</strong> tag <strong class="source-inline">action</strong> attribute to <strong class="source-inline">"/users"</strong> and the <strong class="source-inline">method</strong> attribute to <strong class="source-inline">"POST"</strong>. This corresponds to the <strong class="source-inline">create_user</strong> route in our application. On the HTML page, we have fields for <strong class="source-inline">username</strong>, <strong class="source-inline">email</strong>, <strong class="source-inline">password</strong>, <strong class="source-inline">password_confirmation</strong>, and <strong class="source-inline">description</strong>. We then insert the button to submit and serve the <strong class="source-inline">html_string</strong> to the client application.</p>
			<ol>
				<li value="2">Try running the application now and open <strong class="source-inline">http://127.0.0.1:8000/users/new</strong> in the web browser. Finally, we have something we can render in the browser:</li>
			</ol>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_6.1_B16825.jpg" alt="Figure 6.1 ‒ New user page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 ‒ New user page</p>
			<ol>
				<li value="3">As previously, before <a id="_idIndexMarker349"/>implementing the <strong class="source-inline">create_user()</strong> function, we want to create other routines first. Since the HTML form has no one-to-one mapping to a <strong class="source-inline">User</strong> struct, we create another struct. Put this struct in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">#[derive(Debug, FromForm)]</p><p class="source-code">pub struct NewUser&lt;'r&gt; {</p><p class="source-code">    #[field(validate = len(5..20).or_else(msg!("name </p><p class="source-code">    cannot be empty")))]</p><p class="source-code">    pub username: &amp;'r str,</p><p class="source-code">    pub email: &amp;'r str,</p><p class="source-code">    pub password: &amp;'r str,</p><p class="source-code">    #[field(validate = eq(self.password).or_</p><p class="source-code">    else(msg!("password confirmation mismatch")))]</p><p class="source-code">    pub password_confirmation: &amp;'r str,</p><p class="source-code">    #[field(default = "")]</p><p class="source-code">    pub description: Option&lt;&amp;'r str&gt;,</p><p class="source-code">}</p></li>
			</ol>
			<p>We set the derive <strong class="source-inline">FromForm</strong> trait for <strong class="source-inline">NewUser</strong>, so on top of the struct fields, we use the <strong class="source-inline">field</strong> directive. This directive can be used to match the request payload field name to the struct field name, set the default value, and validate the content of the field.</p>
			<p>If we have HTML form field that is different from the struct field name, we can rename the field using field directive like <a id="_idIndexMarker350"/> the following:</p>
			<p class="source-code">#[field(name = uncased("html-field-name"))]</p>
			<p>It can also be done as follows:</p>
			<p class="source-code">#[field(name = "some-other-name")]</p>
			<p>If you use uncased macro, then the payload HTML field name containing any case, such as <strong class="source-inline">HTML-FIELD-NAME</strong>, will be matched to the struct field name.</p>
			<p>For setting the default value, the syntax is as follows:</p>
			<p class="source-code">#[field(default = "default value")]</p>
			<p>And, for validation, the syntax is as follows:</p>
			<p class="source-code">#[field(validate = validation_function())]</p>
			<p>There are a couple of built-in validation functions in the <strong class="source-inline">rocket::form::validate</strong> module:</p>
			<ul>
				<li><strong class="source-inline">contains</strong>: This function succeeds when the field as a string has this substring, or the field as a <strong class="source-inline">Vec</strong> contains this item, or <strong class="source-inline">Option</strong> has <strong class="source-inline">Some(value)</strong>, or <strong class="source-inline">rocket::form::Result</strong> has <strong class="source-inline">Ok(value)</strong> – for example, <strong class="source-inline">contains("foo")</strong>.</li>
				<li><strong class="source-inline">eq</strong>: This function succeeds when the field value is equal to the function parameters. A type in Rust can be compared if the type implements <strong class="source-inline">std::cmp::PartialEq</strong>. You can see the example in the <strong class="source-inline">NewUser</strong> struct, <strong class="source-inline">eq(self.password)</strong>.</li>
				<li><strong class="source-inline">ext</strong>: This function succeeds if the field type is <strong class="source-inline">rocket::fs::TempFile</strong> and the content type matches the function parameter – for example, <strong class="source-inline">ext(rocket::http::ContentType::JavaScript)</strong>.</li>
				<li><strong class="source-inline">len</strong>: This function succeeds if the length of the field value is within the parameter range. You can see the example in our <strong class="source-inline">NewUser</strong> struct, <strong class="source-inline">len(5..20)</strong>. In Rust, we define the range as <strong class="source-inline">from..to</strong>, but we can omit the <strong class="source-inline">to</strong> part.</li>
				<li><strong class="source-inline">ne</strong>: This function succeeds if the field value is not equal (<strong class="source-inline">!=</strong>) to the provided parameter. A type implementing the <strong class="source-inline">std::cmp::PartialEq</strong> trait can also use the inequality operator.</li>
				<li><strong class="source-inline">omits</strong>: This function is the opposite of <strong class="source-inline">contains</strong>.</li>
				<li><strong class="source-inline">one_of</strong>: This function succeeds if the value contains one of the items in the supplied parameter. The parameter must be an iterator.</li>
				<li><strong class="source-inline">range</strong>: This function is like <strong class="source-inline">len</strong>, but it matches the value of the field instead of the value of the length of the field.</li>
				<li><strong class="source-inline">with</strong>: We can pass a function or closure with the Boolean return type, and the function succeeds when the passed function or closure returns <strong class="source-inline">true</strong>.</li>
			</ul>
			<p>Besides those <a id="_idIndexMarker351"/>functions, there are three more functions we can use. The functions work almost the same, but with different messages:</p>
			<ul>
				<li><strong class="source-inline">dbg_contains</strong>: This <a id="_idIndexMarker352"/>function also returns the field value in the error message.</li>
				<li><strong class="source-inline">dbg_eq</strong>: This function <a id="_idIndexMarker353"/>also returns the item value in the error message.</li>
				<li><strong class="source-inline">dbg_omits</strong>: This function <a id="_idIndexMarker354"/>also returns the item value in the error message.</li>
			</ul>
			<p>In the <strong class="source-inline">NewUser</strong> struct, we can see that we can also set a custom error message by combining the validation function with <strong class="source-inline">.or_else("other message"</strong>, as shown in the following example:</p>
			<p class="source-code">#[field(validate = len(5..20).or_else(msg!("name cannot be empty")))]</p>
			<p>Besides the provided functions, we can create a custom validation function. The function should return <strong class="source-inline">form::Result&lt;'_, ()&gt;</strong>. We want to implement custom validation for checking the strength of the password and the correctness of the email.</p>
			<p>The first validation <a id="_idIndexMarker355"/>is password validation. We are going to use a crate called <strong class="source-inline">zxcvbn</strong>. This crate is a Rust port of the <strong class="source-inline">npm</strong> module of the same name created by Dropbox. The inspiration for the <strong class="source-inline">zxcvbn</strong> library is based on an <strong class="bold">xkcd</strong> comic strip (<a href="https://xkcd.com/936/">https://xkcd.com/936/</a>), which said that random joined words we can remember, such as <strong class="source-inline">"CorrectHorseBatteryStaple"</strong>, are easier to remember and harder to crack compared to some rule such as <em class="italic">must contain a minimum of eight characters, of which one is upper case, one lower case, and one is a number</em>.</p>
			<ol>
				<li value="4">Add <strong class="source-inline">zxcvbn = "2"</strong> to the <strong class="source-inline">Cargo.toml</strong> dependencies, then create the following function in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">use rocket::form::{<strong class="bold">self, Error as FormError,</strong> FromForm};</p><p class="source-code">use zxcvbn::zxcvbn;</p><p class="source-code">...</p><p class="source-code">fn validate_password(password: &amp;str) -&gt; form::Result&lt;'_, ()&gt; {</p><p class="source-code">    let entropy = zxcvbn(password, &amp;[]);</p><p class="source-code">    if entropy.is_err() || entropy.unwrap().score()</p><p class="source-code">    &lt; 3 {</p><p class="source-code">        return Err(FormError::validation("weak </p><p class="source-code">        password").into());</p><p class="source-code">    }</p><p class="source-code">    Ok(())</p><p class="source-code">}</p></li>
			</ol>
			<p>You can set the scoring strength up to four, but it means we cannot send a weak password to the server. Right now, we just set the threshold of the password score to two.</p>
			<ol>
				<li value="5">After that, we can <a id="_idIndexMarker356"/>implement the validation for email correctness. First, add <strong class="source-inline">regex = "1.5.4"</strong> to <strong class="source-inline">Cargo.toml</strong> and add this function in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">use regex::Regex;</p><p class="source-code">...</p><p class="source-code">fn validate_email(email: &amp;str) -&gt; form::Result&lt;'_, ()&gt; {</p><p class="source-code">    const EMAIL_REGEX: &amp;str = r#"(?:[a-z0-9!#$%&amp;</p><p class="source-code">    '*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]</p><p class="source-code">    +)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\</p><p class="source-code">    x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\</p><p class="source-code">    x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[</p><p class="source-code">    a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-</p><p class="source-code">    z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][</p><p class="source-code">    0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][</p><p class="source-code">    0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08</p><p class="source-code">    \x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01</p><p class="source-code">    -\x09\x0b\x0c\x0e-\x7f])+)\])"#;</p><p class="source-code">    let email_regex = Regex::new(EMAIL_REGEX).</p><p class="source-code">    unwrap();</p><p class="source-code">    if !email_regex.is_match(email) {</p><p class="source-code">        return Err(FormError::validation("invalid </p><p class="source-code">        email").into());</p><p class="source-code">    }</p><p class="source-code">    Ok(())</p><p class="source-code">}</p></li>
				<li>If the <a id="_idIndexMarker357"/>email <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>) is hard to type, you <a id="_idIndexMarker358"/>can also copy and paste it from the source code on GitHub. We can now use the validations in the <strong class="source-inline">NewUser</strong> struct:<p class="source-code">pub struct NewUser&lt;'r&gt; {</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">#[field(validate = validate_email().</strong></p><p class="source-code"><strong class="bold">    or_else(msg!("invalid email")))]</strong></p><p class="source-code">    pub email: &amp;'r str,</p><p class="source-code">    <strong class="bold">#[field(validate = validate_password()</strong></p><p class="source-code"><strong class="bold">    .or_else(msg!("weak password")))]</strong></p><p class="source-code">    pub password: &amp;'r str,</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>Next, we can implement the <strong class="source-inline">create()</strong> method for the <strong class="source-inline">User</strong> struct. For security purposes, we will hash the password using the secure password-hashing function. In 2021, people considered <strong class="source-inline">md5</strong> as a very insecure hashing function, and <strong class="source-inline">sha1</strong> and <strong class="source-inline">sha3</strong> as insecure hashing functions, so we will not use those functions. People usually consider using <strong class="source-inline">bcrypt</strong>, <strong class="source-inline">scrypt</strong>, or <strong class="source-inline">argon2</strong> instead. Now, <strong class="source-inline">argon2</strong> has a version, <strong class="source-inline">argon2id</strong>, which is resistant to side-channel attacks and GPU cracking attacks, so we will use <strong class="source-inline">argon2</strong> as a password-hashing implementation.</li>
			</ol>
			<p>There is <a id="_idIndexMarker359"/>another possible attack on the <strong class="source-inline">create()</strong> method: <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>). For example, a user can input <strong class="source-inline">"&lt;script&gt;console.log("hack")&lt;/script&gt;"</strong> as a description. We can rectify this problem by using an HTML sanitization library called <strong class="source-inline">ammonia</strong>.</p>
			<p>To add <strong class="source-inline">argon2</strong> and <strong class="source-inline">ammonia</strong> for the <strong class="source-inline">create()</strong> method, add these lines in <strong class="source-inline">Cargo.toml</strong>:</p>
			<p class="source-code">ammonia = "3.1.2"</p>
			<p class="source-code">argon2 = "0.3"</p>
			<p class="source-code">rand_core = {version = "0.6", features = ["std"]}</p>
			<ol>
				<li value="8">We can create <a id="_idIndexMarker360"/>a function to sanitize HTML in <strong class="source-inline">src/models/mod.rs</strong>:<p class="source-code">use ammonia::Builder;</p><p class="source-code">use std::collections::hash_set::HashSet;</p><p class="source-code">pub fn clean_html(src: &amp;str) -&gt; String {</p><p class="source-code">    Builder::default()</p><p class="source-code">        .tags(HashSet::new())</p><p class="source-code">        .clean(src)</p><p class="source-code">        .to_string()</p><p class="source-code">}</p></li>
			</ol>
			<p>The default cleaner from <strong class="source-inline">ammonia::Builder::default</strong> allows many HTML tags, and people can still deface the site. To rectify this problem, we are passing an empty <strong class="source-inline">HashSet</strong> to disallow any HTML tag.</p>
			<ol>
				<li value="9">After the password hashing and HTML sanitization are ready, it is time to implement the <strong class="source-inline">create()</strong> method for the <strong class="source-inline">User</strong> struct. Add the required <strong class="source-inline">use</strong> directives in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">use super::clean_html;</p><p class="source-code">use argon2::{password_hash::{rand_core::OsRng, PasswordHasher, SaltString},Argon2};</p></li>
				<li>Put these <a id="_idIndexMarker361"/>lines in the <strong class="source-inline">impl User</strong> block:<p class="source-code">pub async fn create&lt;'r&gt;(</p><p class="source-code">    connection: &amp;mut PgConnection,</p><p class="source-code">    new_user: &amp;'r NewUser&lt;'r&gt;,</p><p class="source-code">) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {</p><p class="source-code">    let uuid = Uuid::new_v4();</p><p class="source-code">    let username = &amp;(clean_html(new_user.username));</p><p class="source-code">    let description = &amp;(new_user.description.map(</p><p class="source-code">    |desc| clean_html(desc)));</p><p class="source-code">}</p></li>
			</ol>
			<p>We generate a new UUID for the new <strong class="source-inline">User</strong> instance. After that, we clean the username value and description value. We don't clean the email and password because we already validate the content of the email using a regex and we will not show any password in the HTML.</p>
			<ol>
				<li value="11">Next, append the following lines to hash the password:<p class="source-code">let salt = SaltString::generate(&amp;mut OsRng);</p><p class="source-code">let argon2 = Argon2::default();</p><p class="source-code">let password_hash = argon2.hash_password(new_user.password.as_bytes(), &amp;salt);</p><p class="source-code">if password_hash.is_err() {</p><p class="source-code">    return Err("cannot create password hash".into());</p><p class="source-code">}</p></li>
				<li>Next, we <a id="_idIndexMarker362"/>send the <strong class="source-inline">INSERT</strong> statement to our database server and return the inserted row. Append the following lines:<p class="source-code">let query_str = r#"INSERT INTO users</p><p class="source-code">(uuid, username, email, password_hash, description, status)</p><p class="source-code">VALUES</p><p class="source-code">($1, $2, $3, $4, $5, $6)</p><p class="source-code">RETURNING *"#;</p><p class="source-code">Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">    .bind(uuid)</p><p class="source-code">    .bind(username)</p><p class="source-code">    .bind(new_user.email)</p><p class="source-code">    .bind(password_hash.unwrap().to_string())</p><p class="source-code">    .bind(description)</p><p class="source-code">    .bind(UserStatus::Inactive)</p><p class="source-code">    .fetch_one(connection)</p><p class="source-code">    .await?)</p></li>
				<li>When the <strong class="source-inline">User::create()</strong> method is ready, we can implement the <strong class="source-inline">create_user()</strong> function. When the application successfully creates a user, it's better to show the result by redirecting to <strong class="source-inline">get_user</strong>. For this purpose, we can use the <strong class="source-inline">rocket::response::Redirect</strong> type instead of <strong class="source-inline">RawHtml</strong>.</li>
			</ol>
			<p>Also, if there's an error, it's better to redirect to <strong class="source-inline">new_user()</strong> and show the error so the user can fix the input error. We can do this by getting the error of the <strong class="source-inline">NewUser</strong> validations or any other error, and redirecting to the <strong class="source-inline">new_user()</strong> function with embedded error information.</p>
			<p>We can <a id="_idIndexMarker363"/>get the errors for the request form value using <strong class="source-inline">rocket::form::Contextual</strong>, a proxy for the form type that contains error information. We also going to use <strong class="source-inline">rocket::response::Flash</strong> to send a one-time cookie to the web browser and retrieve the message on a route using <strong class="source-inline">rocket::request::FlashMessage</strong>. Append these lines to <strong class="source-inline">src/routes/user.rs</strong>:</p>
			<p class="source-code">use crate::models::{pagination::Pagination, user::{<strong class="bold">NewUser,</strong> User}};</p>
			<p class="source-code">use rocket::form::{<strong class="bold">Contextual</strong>, Form};</p>
			<p class="source-code"><strong class="bold">use rocket::request::FlashMessage;</strong></p>
			<p class="source-code">use rocket::response::{content::RawHtml, <strong class="bold">Flash, Redirect</strong>};</p>
			<ol>
				<li value="14">Change the signature of the <strong class="source-inline">create_user()</strong> function to the following:<p class="source-code">#[post("/users", format = "<strong class="bold">application/x-www-form-urlencoded</strong>", data = "&lt;<strong class="bold">user_context</strong>&gt;")]</p><p class="source-code">pub async fn create_user&lt;'r&gt;(</p><p class="source-code">    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,</p><p class="source-code">    <strong class="bold">user_context: Form&lt;Contextual&lt;'r, NewUser&lt;'r&gt;&gt;&gt;,</strong></p><p class="source-code">) -&gt; <strong class="bold">Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</strong> {}</p></li>
			</ol>
			<p>Because we are sending <strong class="source-inline">POST</strong> data, the browser will send <strong class="source-inline">Content-Type</strong> as <strong class="source-inline">"application/x-www-form-urlencoded"</strong>, so we have to change the format accordingly.</p>
			<p>Also, take a look at the request parameter; instead of <strong class="source-inline">Form&lt;NewUser&lt;'r&gt;&gt;</strong>, we are inserting the <strong class="source-inline">Contextual</strong> type in the middle of the parameter. We are also changing the return value to <strong class="source-inline">Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</strong>.</p>
			<ol>
				<li value="15">Now, let's <a id="_idIndexMarker364"/>implement the function body. Append the following lines to the function body:<p class="source-code">if user_context.value.is_none() {</p><p class="source-code">    let error_message = format!(</p><p class="source-code">        "&lt;div&gt;{}&lt;/div&gt;",</p><p class="source-code">        user_context</p><p class="source-code">            .context</p><p class="source-code">            .errors()</p><p class="source-code">            .map(|e| e.to_string())</p><p class="source-code">            .collect::&lt;Vec&lt;_&gt;&gt;()</p><p class="source-code">            .join("&lt;br/&gt;")</p><p class="source-code">    );</p><p class="source-code">    return Err(Flash::error(Redirect::to("/</p><p class="source-code">    users/new"), error_message));</p><p class="source-code">}</p></li>
			</ol>
			<p>If <strong class="source-inline">user_context</strong> has <strong class="source-inline">value</strong>, it means that Rocket successfully converted the request payload and put it inside the <strong class="source-inline">value</strong> attribute. We are branching and returning <strong class="source-inline">Error</strong> with a <strong class="source-inline">Flash</strong> message and <strong class="source-inline">Redirect</strong> directive to <strong class="source-inline">"/users/new"</strong>.</p>
			<ol>
				<li value="16">The next implementation is if Rocket successfully parses <strong class="source-inline">NewUser</strong>. Append the following lines in the <strong class="source-inline">true</strong> branch:<p class="source-code">let new_user = user_context.value.as_ref().unwrap();</p><p class="source-code">let connection = db.acquire().await.map_err(|_| {</p><p class="source-code">    Flash::error(</p><p class="source-code">        Redirect::to("/users/new"),</p><p class="source-code">        "&lt;div&gt;Something went wrong when creating </p><p class="source-code">         user&lt;/div&gt;",</p><p class="source-code">    )</p><p class="source-code">})?;</p><p class="source-code">let user = User::create(connection, new_user).await.map_err(|_| {</p><p class="source-code">    Flash::error(</p><p class="source-code">        Redirect::to("/users/new"),</p><p class="source-code">        "&lt;div&gt;Something went wrong when creating </p><p class="source-code">        user&lt;/div&gt;",</p><p class="source-code">    )</p><p class="source-code">})?;</p><p class="source-code">Ok(Flash::success(</p><p class="source-code">    Redirect::to(format!("/users/{}", user.uuid)),</p><p class="source-code">    "&lt;div&gt;Successfully created user&lt;/div&gt;",</p><p class="source-code">))</p></li>
			</ol>
			<p>Just like <a id="_idIndexMarker365"/>the <strong class="source-inline">get_user()</strong> function, we create a routine to get the database connection, perform an <strong class="source-inline">INSERT</strong> operation to the database server, and generate the successful <strong class="source-inline">Redirect</strong> response. But, when an error occurs, instead of returning HTML, we generate the <strong class="source-inline">Redirect</strong> directive with the appropriate path and message.</p>
			<ol>
				<li value="17">We now need to change the <strong class="source-inline">new_user()</strong> and <strong class="source-inline">get_user()</strong> functions to be able to handle incoming <strong class="source-inline">FlashMessage</strong> request guards. First, for the <strong class="source-inline">new_user()</strong> function, change the signature to the following:<p class="source-code">get_user(</p><p class="source-code">    mut db: Connection&lt;DBConnection&gt;,</p><p class="source-code">    uuid: &amp;str,</p><p class="source-code">    <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;,</strong></p><p class="source-code">)</p></li>
				<li>Because the <a id="_idIndexMarker366"/>flash message may not always exist, we wrap it in <strong class="source-inline">Option</strong>. After <strong class="source-inline">let mut html_string = String::from(USER_HTML_PREFIX);</strong>, append the following lines in the function body:<p class="source-code">if flash.is_some() {</p><p class="source-code">    html_string.push_str(flash.unwrap().message());</p><p class="source-code">}</p></li>
				<li>We change the <strong class="source-inline">new_user()</strong> function almost the same. Change the function signature to this:<p class="source-code">new_user(<strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;</strong>)</p></li>
			</ol>
			<p>Then, append the following lines after <strong class="source-inline">USER_HTML_PREFIX</strong>:</p>
			<p class="source-code">if flash.is_some() {</p>
			<p class="source-code">    html_string.push_str(flash.unwrap().message());</p>
			<p class="source-code">}</p>
			<ol>
				<li value="20">Now, it's time to try creating the user data. If everything is correct, you should see screens like the following. The error message looks as follows:</li>
			</ol>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_6.2_B16825.jpg" alt="Figure 6.2 ‒ Error message when failed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 ‒ Error message when failed</p>
			<p>The success <a id="_idIndexMarker367"/>message looks like the following:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_6.3_B16825.jpg" alt="Figure 6.3 ‒ Success message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 ‒ Success message</p>
			<p>In the next sections, we are going to continue with updating the user and deleting a user.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Implementing PUT and PATCH user</h1>
			<p>To update the user, we need a page such as <strong class="source-inline">new_user()</strong>, but we want the form pre-populated <a id="_idIndexMarker368"/>with existing data. We also want to add another field <a id="_idIndexMarker369"/>for the user to confirm the old password. Let's look at the steps:</p>
			<ol>
				<li value="1">Change the <strong class="source-inline">edit_user()</strong> function signature to the following:<p class="source-code">#[get("/users/edit/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]</p><p class="source-code">pub async fn edit_user(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,    <strong class="bold">uuid</strong>: &amp;str, <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;</strong>) -&gt; HtmlResponse {}</p></li>
				<li>To get the existing user, append the following lines inside the function body block:<p class="source-code">let connection = db</p><p class="source-code">    .acquire()</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| Status::InternalServerError)?;</p><p class="source-code">let user = User::find(connection, uuid)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| Status::NotFound)?;</p></li>
				<li>After that, we can append the HTML, such as <strong class="source-inline">new_user()</strong>, but this time, we also include the existing data from the user. Append the following lines inside the <strong class="source-inline">edit_user()</strong> function body:<p class="source-code">let mut html_string = String::from(USER_HTML_PREFIX);</p><p class="source-code">if flash.is_some() {</p><p class="source-code">    html_string.push_str(flash.unwrap().message());</p><p class="source-code">}</p><p class="source-code">html_string.push_str(</p><p class="source-code">    format!(</p><p class="source-code">        r#"&lt;form accept-charset="UTF-8" action="/</p><p class="source-code">        users/{}" autocomplete="off" method="POST"&gt;</p><p class="source-code">&lt;input type="hidden" name="_METHOD" value="PUT"/&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="username"&gt;Username:&lt;/label&gt;</p><p class="source-code">    &lt;input name="username" type="text" value="{}"/&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="email"&gt;Email:&lt;/label&gt;</p><p class="source-code">    &lt;input name="email" type="email" value="{}"/&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="old_password"&gt;Old password:&lt;/label&gt;</p><p class="source-code">    &lt;input name="old_password" type="password"/&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="password"&gt;New password:&lt;/label&gt;</p><p class="source-code">    &lt;input name="password" type="password"/&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="password_confirmation"&gt;Password </p><p class="source-code">    Confirmation:&lt;/label&gt;</p><p class="source-code">    &lt;input name="password_confirmation" type=</p><p class="source-code">    "password"/&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;div&gt;</p><p class="source-code">    &lt;label for="description"&gt;Tell us a little bit more </p><p class="source-code">    about yourself:&lt;/label&gt;</p><p class="source-code">    &lt;textarea name="description"&gt;{}&lt;/textarea&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;button type="submit" value="Submit"&gt;Submit&lt;/button&gt;</p><p class="source-code">&lt;/form&gt;"#,</p><p class="source-code">        &amp;user.uuid,</p><p class="source-code">        &amp;user.username,</p><p class="source-code">        &amp;user.email,</p><p class="source-code">        &amp;user.description.unwrap_or_else(|| </p><p class="source-code">        "".to_string()),</p><p class="source-code">    )</p><p class="source-code">    .as_ref(),</p><p class="source-code">);</p><p class="source-code">html_string.push_str(USER_HTML_SUFFIX);</p><p class="source-code">Ok(RawHtml(html_string))</p></li>
			</ol>
			<p>After this, all previous <a id="_idIndexMarker370"/>links to <strong class="source-inline">"/users/edit/{}"</strong> that we <a id="_idIndexMarker371"/>implemented in the previous pages should work.</p>
			<p>If you look at the code, we see the form's <strong class="source-inline">method</strong> attribute has a <strong class="source-inline">"POST"</strong> value. The reason is that the HTML standard says that a form method can only be <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>. Most web browsers will just change the invalid method, such as <strong class="source-inline">PUT</strong> and <strong class="source-inline">PATCH</strong>, to <strong class="source-inline">POST</strong>.</p>
			<p>Some web frameworks work around this limitation by sending an <strong class="bold">XMLHttpRequest</strong> using JavaScript, or a newer API such as the JavaScript Fetch API. Other web applications send a <strong class="source-inline">POST</strong> request but include a hidden value in the request payload. We are going to use the second way to implement updating the user by adding a new field, <strong class="source-inline">name="_METHOD"</strong>, with the <strong class="source-inline">"PUT"</strong> value.</p>
			<p>Just like <strong class="source-inline">create_user()</strong>, we want to execute <strong class="source-inline">update_function()</strong> to redirect to <strong class="source-inline">edit_user()</strong> again if there's something wrong.  We also want to execute <strong class="source-inline">update_function()</strong> to redirect to the user page again after successfully updating the user.</p>
			<p>Since we <a id="_idIndexMarker372"/>are adding new payloads, <strong class="source-inline">_METHOD</strong> and <strong class="source-inline">old_password</strong>, we need a <a id="_idIndexMarker373"/>new type that is different from <strong class="source-inline">NewUser</strong>:</p>
			<ol>
				<li value="1">Create a new struct called <strong class="source-inline">EditedUser</strong> in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">#[derive(Debug, FromForm)]</p><p class="source-code">pub struct EditedUser&lt;'r&gt; {</p><p class="source-code">    #[field(name = "_METHOD")]</p><p class="source-code">    pub method: &amp;'r str,</p><p class="source-code">    #[field(validate = len(5..20).or_else(msg!("name </p><p class="source-code">    cannot be empty")))]</p><p class="source-code">    pub username: &amp;'r str,</p><p class="source-code">    #[field(validate = validate_email()</p><p class="source-code">    .or_else(msg!("invalid email")))]</p><p class="source-code">    pub email: &amp;'r str,</p><p class="source-code">    pub old_password: &amp;'r str,</p><p class="source-code">    pub password: &amp;'r str,</p><p class="source-code">    pub password_confirmation: &amp;'r str,</p><p class="source-code">    #[field(default = "")]</p><p class="source-code">    pub description: Option&lt;&amp;'r str&gt;,</p><p class="source-code">}</p></li>
				<li>We want <a id="_idIndexMarker374"/>to skip updating the password if there's no value in <strong class="source-inline">old_password</strong>, but if there is a value in <strong class="source-inline">old_password</strong>, we want to <a id="_idIndexMarker375"/>make sure the <strong class="source-inline">password</strong> strength is adequate and <strong class="source-inline">password_confirmation</strong> has the same content as <strong class="source-inline">password</strong>. Create a function in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">fn skip_validate_password&lt;'v&gt;(password: &amp;'v str, old_password: &amp;'v str, password_confirmation: &amp;'v str) -&gt; form::Result&lt;'v, ()&gt; {</p><p class="source-code">    if old_password.is_empty() {</p><p class="source-code">        return Ok(());</p><p class="source-code">    }</p><p class="source-code">    validate_password(password)?;</p><p class="source-code">    if password.ne(password_confirmation) {</p><p class="source-code">        return Err(FormError::validation("password </p><p class="source-code">        confirmation mismatch").into());</p><p class="source-code">    }</p><p class="source-code">    Ok(())</p><p class="source-code">}</p></li>
				<li>Then, use the validation function in the directive above the password field:<p class="source-code"><strong class="bold">#[field(validate = skip_validate_password(self.old_password, self.password_confirmation))]</strong></p><p class="source-code">pub password: &amp;'r str,</p></li>
			</ol>
			<p>We need a method for <strong class="source-inline">User</strong> to update the database row based on the <strong class="source-inline">EditedUser</strong> content. This method will also verify the hash of <strong class="source-inline">old_password</strong> to make sure <strong class="source-inline">EditedUser</strong> is valid.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">use</strong> directive in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">use argon2::{password_hash::{rand_core::OsRng, PasswordHash, <strong class="bold">PasswordHasher, PasswordVerifier,</strong> SaltString}, Argon2};</p><p class="source-code"><strong class="bold">use chrono::offset::Utc;</strong></p></li>
				<li>Create a <a id="_idIndexMarker376"/>new method inside the <strong class="source-inline">impl User</strong> block in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">pub async fn update&lt;'r&gt;(db: &amp;mut Connection&lt;DBConnection&gt;, uuid: &amp;'r str, user: &amp;'r EditedUser&lt;'r&gt;) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {}</p></li>
				<li>Inside <a id="_idIndexMarker377"/>the method, fetch the old user data from the database:<p class="source-code">let connection = db.acquire().await?;</p><p class="source-code">let old_user = Self::find(connection, uuid).await?;</p></li>
				<li>Prepare the data for updating:<p class="source-code">let now = OurDateTime(Utc::now());</p><p class="source-code">let username = &amp;(clean_html(user.username));</p><p class="source-code">let description = &amp;(user.description.map(|desc| clean_html(desc)));</p></li>
				<li>Because we can change the password or skip changing the password depending on whether or not we have <strong class="source-inline">old_password or not</strong>, prepare the query items:<p class="source-code">let mut set_strings = vec![</p><p class="source-code">    "username = $1",</p><p class="source-code">    "email = $2",</p><p class="source-code">    "description = $3",</p><p class="source-code">    "updated_at = $4",</p><p class="source-code">];</p><p class="source-code">let mut where_string = "$5";</p><p class="source-code">let mut password_string = String::new();</p><p class="source-code">let is_with_password = !user.old_password.is_empty();</p></li>
				<li>If we are <a id="_idIndexMarker378"/>updating <strong class="source-inline">password</strong>, we need to verify <strong class="source-inline">old_password</strong> with the <a id="_idIndexMarker379"/>existing password. We also want to hash a new password and add the password to <strong class="source-inline">set_strings</strong>. Append the following lines:<p class="source-code">if is_with_password {</p><p class="source-code">    let old_password_hash = PasswordHash::</p><p class="source-code">    new(&amp;old_user.password_hash)</p><p class="source-code">        .map_err(|_| "cannot read password hash")?;</p><p class="source-code">    let argon2 = Argon2::default();</p><p class="source-code">    argon2</p><p class="source-code">        .verify_password(user.password.as_bytes(), </p><p class="source-code">        &amp;old_password_hash)</p><p class="source-code">        .map_err(|_| "cannot confirm old password")?;</p><p class="source-code">    let salt = SaltString::generate(&amp;mut OsRng);</p><p class="source-code">    let new_hash = argon2</p><p class="source-code">        .hash_password(user.password.as_bytes(), </p><p class="source-code">        &amp;salt)</p><p class="source-code">        .map_err(|_| "cannot create password hash")?;</p><p class="source-code">    password_string.push_str(</p><p class="source-code">    new_hash.to_string().as_ref());</p><p class="source-code">    set_strings.push("password_hash = $5");</p><p class="source-code">    where_string = "$6";</p><p class="source-code">}</p></li>
				<li>We can <a id="_idIndexMarker380"/>then construct the <strong class="source-inline">UPDATE</strong> statement to update <a id="_idIndexMarker381"/>the user, execute the statement, and return the <strong class="source-inline">User</strong> instance:<p class="source-code">let query_str = format!(</p><p class="source-code">    r#"UPDATE users SET {} WHERE uuid = {} RETURNING </p><p class="source-code">    *"#,</p><p class="source-code">    set_strings.join(", "),</p><p class="source-code">    where_string,</p><p class="source-code">);</p><p class="source-code">let connection = db.acquire().await?;</p><p class="source-code">let mut binded = sqlx::query_as::&lt;_, Self&gt;(&amp;query_str)</p><p class="source-code">    .bind(username)</p><p class="source-code">    .bind(user.email)</p><p class="source-code">    .bind(description)</p><p class="source-code">    .bind(&amp;now);</p><p class="source-code">if is_with_password {</p><p class="source-code">    binded = binded.bind(&amp;password_string);</p><p class="source-code">}</p><p class="source-code">let parsed_uuid = Uuid::parse_str(uuid)?;</p><p class="source-code">Ok(binded.bind(parsed_uuid).fetch_one(connection).await?)</p></li>
				<li>Now, it's time to use <strong class="source-inline">EditedUser</strong> and implement <strong class="source-inline">update_user()</strong>. Append <strong class="source-inline">EditedUser</strong> in the <strong class="source-inline">use</strong> directive:<p class="source-code">use crate::models::{pagination::Pagination, user::{<strong class="bold">EditedUser</strong>, NewUser, User}};</p></li>
				<li>Create the <strong class="source-inline">update_user()</strong> function in <strong class="source-inline">src/routes/user.rs</strong>:<p class="source-code">#[post("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]</p><p class="source-code">pub async fn update_user&lt;'r&gt;(db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {}</p></li>
				<li>In the <a id="_idIndexMarker382"/>function, we need to check whether the form is <a id="_idIndexMarker383"/>correct or not. Append the following lines:<p class="source-code">if user_context.value.is_none() {</p><p class="source-code">    let error_message = format!(</p><p class="source-code">        "&lt;div&gt;{}&lt;/div&gt;",</p><p class="source-code">        user_context</p><p class="source-code">            .context</p><p class="source-code">            .errors()</p><p class="source-code">            .map(|e| e.to_string())</p><p class="source-code">            .collect::&lt;Vec&lt;_&gt;&gt;()</p><p class="source-code">            .join("&lt;br/&gt;")</p><p class="source-code">    );</p><p class="source-code">    return Err(Flash::error(</p><p class="source-code">        Redirect::to(format!("/users/edit/{}", uuid)),</p><p class="source-code">        error_message,</p><p class="source-code">    ));</p><p class="source-code">}</p></li>
				<li>We can tell the application to process depending on <strong class="source-inline">"_METHOD"</strong>. Append the following lines:<p class="source-code">let user_value = user_context.value.as_ref().unwrap();</p><p class="source-code">match user_value.method {</p><p class="source-code">    "PUT" =&gt; put_user(db, uuid, user_context).await,</p><p class="source-code">    "PATCH" =&gt; patch_user(db, uuid, user_</p><p class="source-code">    context).await,</p><p class="source-code">    _ =&gt; Err(Flash::error(</p><p class="source-code">        Redirect::to(format!("/users/edit/{}", uuid)),</p><p class="source-code">        "&lt;div&gt;Something went wrong when updating </p><p class="source-code">        user&lt;/div&gt;",</p><p class="source-code">    )),</p><p class="source-code">}</p></li>
			</ol>
			<p>We don't <a id="_idIndexMarker384"/>waste the functions we defined before. We are <a id="_idIndexMarker385"/>using the <strong class="source-inline">put_user()</strong> and <strong class="source-inline">patch_user()</strong> functions.</p>
			<ol>
				<li value="15">Now, it's time to implement the <strong class="source-inline">put_user()</strong> function. Change the signature of the <strong class="source-inline">put_user()</strong> function:<p class="source-code">#[put("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]</p><p class="source-code">pub async fn put_user&lt;'r&gt;(mut db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {}</p></li>
			</ol>
			<p>Then, implement the function as follows:</p>
			<p class="source-code">let user_value = user_context.value.as_ref().unwrap();</p>
			<p class="source-code">let user = User::update(&amp;mut db, uuid, user_value).await.map_err(|_| {</p>
			<p class="source-code">    Flash::error(</p>
			<p class="source-code">        Redirect::to(format!("/users/edit/{}", uuid)),</p>
			<p class="source-code">        "&lt;div&gt;Something went wrong when updating </p>
			<p class="source-code">        user&lt;/div&gt;",</p>
			<p class="source-code">    )</p>
			<p class="source-code">})?;</p>
			<p class="source-code">Ok(Flash::success(</p>
			<p class="source-code">    Redirect::to(format!("/users/{}", user.uuid)),</p>
			<p class="source-code">    "&lt;div&gt;Successfully updated user&lt;/div&gt;",</p>
			<p class="source-code">))</p>
			<ol>
				<li value="16">For the <strong class="source-inline">patch_user()</strong> function, we <a id="_idIndexMarker386"/>can just reuse <a id="_idIndexMarker387"/>the <strong class="source-inline">put_user()</strong> function. Write the code for <strong class="source-inline">patch_user()</strong>:<p class="source-code">#[patch("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]</p><p class="source-code">pub async fn patch_user&lt;'r&gt;(db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    put_user(db, uuid, user_context).await</p><p class="source-code">}</p></li>
				<li>Finally, append the new route in <strong class="source-inline">src/main.rs</strong>:<p class="source-code">user::edit_user,</p><p class="source-code"><strong class="bold">user::update_user,</strong></p><p class="source-code">user::put_user,</p></li>
			</ol>
			<p>The only endpoint left is for deleting the user. Let's continue with that in the next section.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Implementing DELETE user</h1>
			<p>The first <a id="_idIndexMarker388"/>thing we want to do to delete a user is to create a method for the <strong class="source-inline">User</strong> struct. Let's look at the steps:</p>
			<ol>
				<li value="1">Write the method to delete a user in the <strong class="source-inline">impl User</strong> block in <strong class="source-inline">src/models/user.rs</strong>:<p class="source-code">pub async fn destroy(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {</p><p class="source-code">    let parsed_uuid = Uuid::parse_str(uuid)?;</p><p class="source-code">    let query_str = "DELETE FROM users WHERE uuid = </p><p class="source-code">    $1";</p><p class="source-code">    sqlx::query(query_str)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .execute(connection)</p><p class="source-code">        .await?;</p><p class="source-code">    Ok(())</p><p class="source-code">}</p></li>
			</ol>
			<p>Then, we can implement the <strong class="source-inline">delete_user()</strong> function in <strong class="source-inline">src/routes/user.rs</strong>:</p>
			<p class="source-code">#[delete("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded")]</p>
			<p class="source-code">pub async fn delete_user(</p>
			<p class="source-code">    mut db: Connection&lt;DBConnection&gt;,</p>
			<p class="source-code">    uuid: &amp;str,</p>
			<p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p>
			<p class="source-code">    let connection = db.acquire().await.map_err(|_| {</p>
			<p class="source-code">        Flash::error(</p>
			<p class="source-code">            Redirect::to("/users"),</p>
			<p class="source-code">            "&lt;div&gt;Something went wrong when deleting </p>
			<p class="source-code">            user&lt;/div&gt;",</p>
			<p class="source-code">        )</p>
			<p class="source-code">    })?;</p>
			<p class="source-code">    User::destroy(connection, uuid).await.map_err(|_| {</p>
			<p class="source-code">        Flash::error(</p>
			<p class="source-code">            Redirect::to("/users"),</p>
			<p class="source-code">            "&lt;div&gt;Something went wrong when deleting </p>
			<p class="source-code">            user&lt;/div&gt;",</p>
			<p class="source-code">        )</p>
			<p class="source-code">    })?;</p>
			<p class="source-code">    Ok(Flash::success(</p>
			<p class="source-code">        Redirect::to("/users"),</p>
			<p class="source-code">        "&lt;div&gt;Successfully deleted user&lt;/div&gt;",</p>
			<p class="source-code">    ))</p>
			<p class="source-code">}</p>
			<ol>
				<li value="2">The problem <a id="_idIndexMarker389"/>is that neither the link nor the form in HTML are allowed to use the <strong class="source-inline">DELETE</strong> method. We cannot use the link, as any bot seeing it will crawl on it and could perform resource deletion accidentally. As with updating the user, we can use the form and send a <strong class="source-inline">POST</strong> request to a new endpoint. Add a new function in <strong class="source-inline">src/routes/user.rs</strong>:<p class="source-code">#[post("/users/delete/&lt;uuid&gt;", format = "application/x-www-form-urlencoded")]</p><p class="source-code">pub async fn delete_user_entry_point(</p><p class="source-code">    db: Connection&lt;DBConnection&gt;,</p><p class="source-code">    uuid: &amp;str,</p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {</p><p class="source-code">    delete_user(db, uuid).await</p><p class="source-code">}</p></li>
				<li>Don't forget to add the route in <strong class="source-inline">src/main.rs</strong>:<p class="source-code">user::delete_user,</p><p class="source-code"><strong class="bold">user::delete_user_entry_point,</strong></p></li>
				<li>Now, where <a id="_idIndexMarker390"/>can we create a form to delete the user? Let's do that on the <strong class="source-inline">get_user()</strong> page. Append the HTML for the form as follows:<p class="source-code">html_string</p><p class="source-code">    .push_str(format!(r#"&lt;a href="/users/edit/{}"&gt;Edit </p><p class="source-code">    User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref());</p><p class="source-code">html_string.push_str(</p><p class="source-code">    format!(</p><p class="source-code">        r#"&lt;form accept-charset="UTF-8" action="/</p><p class="source-code">        users/delete/{}" autocomplete="off" </p><p class="source-code">        method="POST"&gt;&lt;button type="submit" </p><p class="source-code">        value="Submit"&gt;Delete&lt;/button&gt;&lt;/form&gt;"#,</p><p class="source-code">        user.uuid</p><p class="source-code">    )</p><p class="source-code">    .as_ref(),</p><p class="source-code">);</p></li>
			</ol>
			<p>We have now completed all of the endpoints used to manage users. Try adding users and see <a id="_idIndexMarker391"/>how pagination works or try improving the HTML. You can also try activating users for a challenge!</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Summary</h1>
			<p>In this chapter, we have learned about the basic operations for user entities by implementing the creation, reading, updating, and deleting of user routes.</p>
			<p>We also learned more about various modules of the Rocket framework such as RawHtml, Redirect, Contextual, Flash, Form, and FlashMessage.</p>
			<p>Along with implementing the endpoints, we also learned more about database operations such as querying, inserting, updating, and deleting objects on a database server.</p>
			<p>In the next chapter, we are going to learn more about error handling and creating our own error types.</p>
		</div>
	</body></html>