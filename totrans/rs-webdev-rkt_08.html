<html><head></head><body>
		<div><h1 id="_idParaDest-83"><em class="italic"><a id="_idTextAnchor083"/>Chapter 6</em>: Implementing User CRUD</h1>
			<p>In the previous chapter, we created a rough outline for the application. In this chapter, we are going to implement the endpoints for managing users. By implementing the endpoints in this chapter, you are going to learn about HTTP basic operations for an entity, that is, creating, reading, updating, and deleting an entity.</p>
			<p>In addition, you are going to learn how to construct HTML and an HTML form, send the form payload to the server, validate and sanitize the form payload, hash the password payload, and handle failure by redirecting to another endpoint with a message.</p>
			<p>Along with implementing the endpoints, you will also learn how to query single and multiple rows from the database, and how to insert, update, and delete a row from the database.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Implementing GET user</li>
				<li>Implementing GET users</li>
				<li>Implementing POST user</li>
				<li>Implementing PUT and PATCH user</li>
				<li>Implementing DELETE user</li>
			</ul>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>For this chapter, we have the same technical requirements as the previous chapter. We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database server.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06</a>.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Implementing GET user</h1>
			<p>Let's look <a id="_idIndexMarker330"/>at the steps to implement this:</p>
			<ol>
				<li>We'll start with the basics by implementing the <code>get_user()</code> function in <code>src/routes/user.rs</code>:<pre>#[get("/users/&lt;_uuid&gt;", format = "text/html")]
pub async fn get_user(mut _db: Connection&lt;DBConnection&gt;, _uuid: &amp;str) -&gt; HtmlResponse {
    todo!("will implement later")
}</pre></li>
			</ol>
			<p>Before we implement <code>get_user()</code>, we want to prepare the other routines that we will use. For example, we want to return HTML, so we need to create a <code>const</code> of <code>&amp;'static str</code> in the same <code>src/routes/user.rs</code> file as our HTML template.</p>
			<ol>
				<li value="2">We will create two separate instances of <code>const</code> so we can insert different contents between the HTML prefix and suffix:<pre>const USER_HTML_PREFIX: &amp;str = r#"&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Our Application User&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;"#;
const USER_HTML_SUFFIX: &amp;str = r#"&lt;/body&gt;
&lt;/html&gt;"#;</pre></li>
			</ol>
			<p>After that, we will create two methods for a <code>User</code> struct. The first one is the find method to find the entry in the database server, and the second one is to create an HTML string for a <code>User</code> instance.</p>
			<ol>
				<li value="3">In the <code>src/models/user.rs</code> file, add the following lines to the <code>use</code> directives:<pre>use rocket_db_pools::sqlx::{FromRow<strong class="bold">, PgConnection</strong>};
<strong class="bold">use std::error::Error;</strong></pre></li>
				<li>Then, create an <code>impl</code> block for <code>User</code>:<pre>impl User{}</pre></li>
				<li>Inside the <a id="_idIndexMarker331"/>block, add the <code>find()</code> method:<pre>pub async fn find(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {
    let parsed_uuid = Uuid::parse_str(uuid)?;
    let query_str = "SELECT * FROM users WHERE uuid = 
    $1";
    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(parsed_uuid)
        .fetch_one(connection)
        .await?)
}</pre></li>
			</ol>
			<p>We created a similar method before. The first thing we do is parse the UUID (Universal Unique Identifier) <code>&amp;str</code> into a <code>Uuid</code> instance and use the question mark operator (<code>?</code>) to quickly return <code>Box&lt;dyn Error&gt;</code>. After that, we define the SQL query string, <code>query_str</code>, and finally, we return the <code>User</code> instance.</p>
			<p>One thing a little different here is that we are passing the mutable reference to <code>PgConnection</code> itself, instead of a mutable reference to <code>Connection&lt;DBConnection&gt;</code>.</p>
			<p>Remember previously, we used <code>Connection&lt;DBConnection&gt;</code> as in the following:</p>
			<pre>pub async fn find(<strong class="bold">db: &amp;mut Connection&lt;DBConnection&gt;</strong>, uuid: &amp;str) -&gt; ... {
    ...
        .fetch_one<strong class="bold">(&amp;mut *db</strong>)
        .await?)
}</pre>
			<p>We first dereference <code>db</code> using an asterisk (<code>*</code>) operator. The connection implements <code>std::ops::Deref</code>, and its implementation exposes the new type, <code>DBConnection</code>, which is a wrapper for <code>sqlx::PgPool</code>, an alias to <code>sqlx::Pool&lt;sqlx::Postgres&gt;</code>.</p>
			<p>The <code>sqlx::Executor</code> trait is implemented for <code>sqlx::PgConnection</code>, a struct that <a id="_idIndexMarker332"/>implements the <code>sqlx::Connection</code> trait, representing a single connection to the database. The <code>sqlx::Executor</code> trait is also implemented for <code>&amp;sqlx::Pool</code>, an asynchronous pool of SQLx database connections.</p>
			<p>Since various <code>sqlx</code> methods (such as <code>fetch_all</code>, <code>fetch_one</code>, <code>fetch_many</code>, <code>fetch</code>, <code>execute</code>, and <code>execute_many</code>) accept the generic type <code>E</code>, which is bound by the <code>sqlx::Executor</code> trait, we can use either the reference to the pool itself or the connection obtained from the pool in those methods.</p>
			<p>There's a problem with the <code>find()</code> method since <code>OurDateTime</code> is a type unknown by <code>sqlx</code>.</p>
			<ol>
				<li value="6">Add the following directive in <code>src/models/our_date_time.rs</code>:<pre>#[derive(Debug<strong class="bold">, sqlx::Type</strong>)]
<strong class="bold">#[sqlx(transparent)]</strong>
pub struct OurDateTime(DateTime&lt;Utc&gt;);</pre></li>
			</ol>
			<p>The <code>transparent</code> directive automatically generates implementations referring to the implementation of the inner type, which in our case is <code>DateTime&lt;Utc&gt;</code>.</p>
			<ol>
				<li value="7">Beside the <code>find()</code> method, let's <a id="_idIndexMarker333"/>implement another method to convert <code>User</code> to an HTML <code>String</code>:<pre>pub fn to_html_string(&amp;self) -&gt; String {
    format!(
        r#"&lt;div&gt;&lt;span class="label"&gt;UUID: 
        &lt;/span&gt;{uuid}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Username: &lt;/span&gt;{username}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Email: &lt;/span&gt;{email}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Description: &lt;/span&gt;{description}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Status: &lt;/span&gt;{status}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Created At: &lt;/span&gt;{created_at}&lt;/div&gt;
&lt;div&gt;&lt;span class="label"&gt;Updated At: &lt;/span&gt;{updated_at}&lt;/div&gt;"#,
        uuid = self.uuid,
        username = self.username,
        email = self.email,
        description = self.description.as_ref().
        unwrap_or(&amp;String::from("")),
        status = self.status.to_string(),
        created_at = self.created_at.0.to_rfc3339(),
        updated_at = self.updated_at.0.to_rfc3339(),
    )
}</pre></li>
				<li>Since the <code>OurDateTime</code> member is private but we access it like <code>self.created_at.</code><code>.to_rfc3339()</code>, it's going to create an error when we compile it. To resolve it, convert the member of <code>OurDateTime</code> in <code>src/models/our_date_time.rs</code> to public:<pre>pub struct OurDateTime(<strong class="bold">pub </strong>DateTime&lt;Utc&gt;);</pre></li>
			</ol>
			<p>We need <a id="_idIndexMarker334"/>to implement the <code>to_string()</code> method for <code>UserStatus</code> as well. We can choose to implement <code>to_string()</code>, or we can implement <code>std::fmt::Display</code>, which automatically provides <code>to_string()</code>. As a bonus, with the <code>Display</code> trait, we can also use it in the <code>format!("{}", something)</code> macro.</p>
			<ol>
				<li value="9">Modify <code>src/models/user_status.rs</code> as follows:<pre>use std::fmt;
...
impl fmt::Display for UserStatus {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; 
    fmt::Result {
        match *self {
            UserStatus::Inactive =&gt; write!(f, 
           "Inactive"),
            UserStatus::Active =&gt; write!(f, "Active"),
        }
    }
}</pre></li>
				<li>It's time <a id="_idIndexMarker335"/>to implement the <code>get_user()</code> function in <code>src/routes/user.rs</code>:<pre><strong class="bold">use rocket::http::Status;</strong>
<strong class="bold">use rocket::response::content::RawHtml;</strong>
use rocket_db_pools::{<strong class="bold">sqlx::Acquire</strong>, Connection};
#[get("/users/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]
pub async fn get_user(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;, <strong class="bold">uuid</strong>: &amp;str) -&gt; HtmlResponse {
    let connection = db
        .acquire()
        .await
        .map_err(|_| Status::InternalServerError)?;
}</pre></li>
			</ol>
			<p>First, we add the required <code>use</code> directives, and then we remove the underscore from <code>_db</code> and <code>_uuid</code> to mark it as a used variable. Then, we acquire a single connection from the database pool or return <code>InternalServerError</code> if there's something wrong.</p>
			<ol>
				<li value="11">After we set the connection variable, we can execute the <code>find()</code> method we defined previously:<pre>...
    let user = User::find(connection, uuid)
        .await
        .map_err(|_| Status::NotFound)?;</pre></li>
			</ol>
			<p>We only expose a simple error, <code>NotFound</code>, for this case, but a more complex application should handle the error properly, such as logging the error and returning the proper error status and error messages.</p>
			<ol>
				<li value="12">Finally, we can <a id="_idIndexMarker336"/>construct the HTML string and return it:<pre>...
    let mut html_string = String::from(USER_HTML_PREFIX);
    html_string.push_str(&amp;user.to_html_string());
    html_string.push_str(format!(r#"&lt;a href="
    /users/edit/{}"&gt;Edit User&lt;/a&gt;"#, 
    user.uuid).as_ref());
    html_string.push_str(r#"&lt;a href="/users"&gt;User 
    List&lt;/a&gt;"#);
    html_string.push_str(USER_HTML_SUFFIX);
    Ok(RawHtml(html_string))</pre></li>
			</ol>
			<p>Notice we added two links for editing this user and to go to <code>/users</code>.</p>
			<p>In the next section, we are going to implement the <code>get_users()</code> function so the application can handle a <code>/users</code> endpoint.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Implementing GET users</h1>
			<p>Now, let's <a id="_idIndexMarker337"/>implement <code>get_users()</code>. Here is a quick reminder of what the function looked like in the previous chapter:</p>
			<pre class="source-code">#[get("/users?&lt;_pagination&gt;", format = "text/html")]</pre>
			<pre class="source-code">pub async fn get_users(</pre>
			<pre class="source-code">    mut _db: Connection&lt;DBConnection&gt;,</pre>
			<pre class="source-code">    _pagination: Option&lt;Pagination&gt;,</pre>
			<pre class="source-code">) -&gt; HtmlResponse {</pre>
			<pre class="source-code">    todo!("will implement later")</pre>
			<pre class="source-code">}</pre>
			<p>As before, we should <a id="_idIndexMarker338"/>prepare the routines we're going to use:</p>
			<ol>
				<li value="1">In <code>src/models/user.rs</code>, create a method called <code>find_all</code>, as in the following:<pre><strong class="bold">use super::pagination::{Pagination};</strong>
<strong class="bold">use crate::fairings::db::DBConnection;</strong>
<strong class="bold">use rocket_db_pools::Connection;</strong>
use rocket_db_pools::sqlx::{<strong class="bold">Acquire,</strong> FromRow, PgConnection};
...
impl User {
...
    <strong class="bold">pub async fn find_all(</strong>
<strong class="bold">        db: &amp;mut Connection&lt;DBConnection&gt;,</strong>
<strong class="bold">        pagination: Option&lt;Pagination&gt;,</strong>
<strong class="bold">    ) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), </strong>
<strong class="bold">    Box&lt;dyn Error&gt;&gt; {</strong>
<strong class="bold">        if pagination.is_some() {</strong>
<strong class="bold">            return Self::find_all_with_pagination(db, </strong>
<strong class="bold">            &amp;(pagination.unwrap())).await;</strong>
<strong class="bold">        } else {</strong>
<strong class="bold">            return Self::find_all_without_</strong>
<strong class="bold">            pagination(db).await;</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>The parameter for <code>find_all</code> is <code>Connection</code>, which has the connection pool and the optional <code>Pagination</code>.</p>
			<p>If the function <a id="_idIndexMarker339"/>is successful, we want to return a vector of <code>User</code> and <code>Pagination</code>. We can wrap it as a <em class="italic">tuple</em> in parentheses <code>()</code>, but there's a possibility that there's no further row in the database, so we wrap the returned <code>Pagination</code> in <code>Option</code>. We then split it into two methods to make it easier to read: <code>find_all_without_pagination</code> and <code>find_all_with_pagination</code>.</p>
			<ol>
				<li value="2">Let's modify <code>src/models/pagination.rs</code> a little bit, and add <code>DEFAULT_LIMIT</code> to limit the number of users we want to fetch at a single time:<pre>pub const DEFAULT_LIMIT: usize = 10;</pre></li>
				<li>We can then create and implement the function for the base case in <code>src/models/user.rs</code>, <code>find_all_without_pagination</code>:<pre>use super::pagination::{Pagination, <strong class="bold">DEFAULT_LIMIT</strong>};
...
async fn find_all_without_pagination(db: &amp;mut Connection&lt;DBConnection&gt;) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), Box&lt;dyn Error&gt;&gt; {
    <strong class="bold">let query_str = "SELECT * FROM users ORDER BY </strong>
<strong class="bold">    created_at DESC LIMIT $1";</strong>
<strong class="bold">    let connection = db.acquire().await?;</strong>
<strong class="bold">    let users = sqlx::query_as::&lt;_, Self&gt;(query_str)</strong>
<strong class="bold">        .bind(DEFAULT_LIMIT as i32)</strong>
<strong class="bold">        .fetch_all(connection)</strong>
<strong class="bold">        .await?;</strong>
}</pre></li>
			</ol>
			<p>Like the <code>find()</code> method, we define <code>query_str</code> and execute the query, and bind the <code>Vec&lt;User&gt;</code> result to the <code>users</code> variable. But, why do we pass the <code>&amp;mut Connection&lt;DBConnection&gt;</code> database connection pool this time? Let's <a id="_idIndexMarker340"/>continue the function first:</p>
			<pre>{
    ...
    let mut new_pagination: Option&lt;Pagination&gt; = None;
    if users.len() == DEFAULT_LIMIT {
        let query_str = "SELECT EXISTS(SELECT 1 FROM 
        users WHERE created_at &lt; $1 ORDER BY 
        created_at DESC LIMIT 1)";
        let connection = db.acquire().await?;
        let exists = sqlx::query_as::&lt;_,
        BoolWrapper&gt;(query_str)
            .bind(&amp;users.last().unwrap().created_at)
            .fetch_one(connection)
            .await?;
        if exists.0 {
            new_pagination = Some(Pagination {
                next: users.last().unwrap().
                created_at.to_owned(),
                limit: DEFAULT_LIMIT,
            });
        }
    }
    Ok((users, new_pagination))
}</pre>
			<p>We then prepare the returned pagination, setting it to <code>None</code> first. If the fetched users are equal to <code>DEFAULT_LIMIT</code>, there's a possibility of a next row, so we do the <a id="_idIndexMarker341"/>second query to the database. Since we cannot reuse a single connection, we have to obtain a new connection again from the database pool. That's why we pass <code>&amp;mut Connection&lt;DBConnection&gt;</code> to <code>find_all</code> and <code>find_all_without_pagination</code> instead of <code>&amp;mut PgConnection</code>. If there's the next row, we can return the pagination wrapped in <code>Some()</code>. But, what is <code>BoolWrapper</code>? We need to set a type to put the result of the <code>"SELECT EXISTS..."</code> query.</p>
			<ol>
				<li value="4">Add <code>pub mod bool_wrapper;</code> to <code>src/models/mod.rs</code> and create a new file, <code>src/models/bool_wrapper.rs</code>, with the following content:<pre>use rocket_db_pools::sqlx::FromRow;
#[derive(FromRow)]
pub struct BoolWrapper(pub bool);</pre></li>
			</ol>
			<p>Don't forget to add <code>use super::bool_wrapper::BoolWrapper;</code> to <code>src/models/user.rs</code>.</p>
			<ol>
				<li value="5">Now, it's time to implement <code>find_all_with_pagination</code>:<pre>async fn find_all_with_pagination(db: &amp;mut Connection&lt;DBConnection&gt;, pagination: &amp;Pagination) -&gt; Result&lt;(Vec&lt;Self&gt;, Option&lt;Pagination&gt;), Box&lt;dyn Error&gt;&gt; {
    let query_str =
        "SELECT * FROM users WHERE created_at &lt; $1 
         ORDER BY created_at DESC LIMIT 
2";
    let connection = db.acquire().await?;
    let users = sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(&amp;pagination.next)
        .bind(DEFAULT_LIMIT as i32)
        .fetch_all(connection)
        .await?;
    let mut new_pagination: Option&lt;Pagination&gt; = None;
    if users.len() == DEFAULT_LIMIT {
        let query_str = "SELECT EXISTS(SELECT 1 FROM 
        users WHERE created_at &lt; $1 ORDER BY 
        created_at DESC LIMIT 1)";
        let connection = db.acquire().await?;
        let exists = sqlx::query_as::&lt;_, 
        BoolWrapper&gt;(query_str)
            .bind(&amp;users.last().unwrap().created_at)
            .fetch_one(connection)
            .await?;
        if exists.0 {
            new_pagination = Some(Pagination {
                next: users.last().unwrap().
                created_at.to_owned(),
                limit: DEFAULT_LIMIT,
            });
        }
    }
    Ok((users, new_pagination))
}</pre></li>
			</ol>
			<p>The private method works like <code>find_all_without_pagination</code>, but we add a <code>WHERE</code> condition to start querying from a certain point.</p>
			<ol>
				<li value="6">Now, it's time <a id="_idIndexMarker342"/>to implement the <code>get_users()</code> function:<pre>#[get("/users?&lt;<strong class="bold">pagination</strong>&gt;", format = "text/html")]
pub async fn get_users(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,
    <strong class="bold">pagination</strong>: Option&lt;Pagination&gt;) -&gt; HtmlResponse {
    <strong class="bold">let (users, new_pagination) = User::find_all(&amp;mut </strong>
<strong class="bold">    db, pagination)</strong>
<strong class="bold">        .await</strong>
<strong class="bold">        .map_err(|_| Status::NotFound)?;</strong>
}</pre></li>
				<li>After we have obtained <code>users</code> and <code>new_pagination</code>, we can construct the HTML for the return value:<pre>...
let mut html_string = String::from(USER_HTML_PREFIX);
for user in users.iter() {
    html_string.push_str(&amp;user.to_html_string());
    html_string
        .push_str(format!(r#"&lt;a href="/users/{}"&gt;See 
         User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref());
    html_string.push_str(
        format!(r#"&lt;a href="/users/edit/{}"&gt;Edit 
        User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref(),
    );
}</pre></li>
				<li>Append <a id="_idIndexMarker343"/>the link to the next page if we have <code>new_pagination</code>:<pre>if let Some(pg) = new_pagination {
    html_string.push_str(
        format!(
            r#"&lt;a href="/users?pagination.next={}&amp;
            pagination.limit={}"&gt;Next&lt;/a&gt;&lt;br/&gt;"#,
            &amp;(pg.next.0).timestamp_nanos(),
            &amp;pg.limit,
        )
        .as_ref(),
    );
}</pre></li>
			</ol>
			<p>Notice we use <code>timestamp_nanos()</code> to convert time to <code>i64</code> to make it easier to transport in the HTML.</p>
			<ol>
				<li value="9">To finalize the function, append the following lines:<pre>html_string.push_str(r#"&lt;a href="/users/new"&gt;New user&lt;/a&gt;"#);
html_string.push_str(USER_HTML_SUFFIX);
Ok(RawHtml(html_string))</pre></li>
				<li>Now, we have to implement <code>FromFormField</code> for <code>OurDateTime</code> since we are using <code>OurDateTime</code> in the pagination. In <code>src/models/our_date_time.rs</code>, add the required <code>use</code> directives:<pre>use chrono::{offset::Utc, DateTime, <strong class="bold">TimeZone</strong>};
<strong class="bold">use rocket::data::ToByteUnit;</strong></pre></li>
				<li>Because <a id="_idIndexMarker344"/>we are cloning <code>OurDateTime</code> inside the <code>User</code> implementation (<code>users.last().unwrap().created_at</code><code>Clone</code> for <code>OurDateTime</code>:<pre>#[derive(Debug, sqlx::Type<strong class="bold">, Clone</strong>)]</pre></li>
				<li>For the <code>from_value</code> implementation, we are just parsing <code>i64</code> from the request parameter and converting it to the <code>OurDateTime</code> object:<pre> impl&lt;'r&gt; FromFormField&lt;'r&gt; for OurDateTime {
    fn from_value(<strong class="bold">field</strong>: ValueField&lt;'r&gt;) -&gt; form::
    Result&lt;'r, Self&gt; {
        <strong class="bold">let timestamp = field.value.parse::&lt;i64&gt;()?;</strong>
<strong class="bold">        Ok(OurDateTime(</strong>
<strong class="bold">        Utc.timestamp_nanos(timestamp)))</strong>
    }
    ...
}</pre></li>
				<li>But, for <code>from_data</code>, we have to be more involved because we have to convert the request to <code>bytes</code>, convert it again into <code>&amp;str</code>, and finally, into <code>i64</code>. First, we get the Rocket limit for the form:<pre>async fn from_data(<strong class="bold">field</strong>: DataField&lt;'r, '_&gt;) -&gt; form::Result&lt;'r, Self&gt; {
<strong class="bold">    let limit = field</strong>
<strong class="bold">        .request</strong>
<strong class="bold">        .limits()</strong>
<strong class="bold">        .get("form")</strong>
<strong class="bold">        .unwrap_or_else(|| 8.kibibytes());</strong>
    ...
}</pre></li>
				<li>Then, get the <code>bytes</code> from the request:<pre>let bytes = field.data.open(limit).into_bytes().await?;
if !bytes.is_complete() {
    return Err((None, Some(limit)).into());
}
let bytes = bytes.into_inner();</pre></li>
				<li>And finally, we <a id="_idIndexMarker345"/>convert <code>bytes</code> to <code>&amp;str</code>, parse it as <code>i64</code>, and convert it to <code>OurDateTime</code>:<pre>let time_string = std::str::from_utf8(&amp;bytes)?;
let timestamp = time_string.parse::&lt;i64&gt;()?;
Ok(OurDateTime(Utc.timestamp_nanos(timestamp)))</pre></li>
			</ol>
			<p>Now, <code>get_user</code> and <code>get_users</code> are ready, but we do not have any data yet. In the next section, we are going to implement the <code>new_user</code> and <code>create_user</code> functions so we can insert user data through an HTML form.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Implementing POST user</h1>
			<p>To create <a id="_idIndexMarker346"/>a user, we are going to use the <code>new_user</code> and <code>create_user</code> functions. The <code>new_user()</code> function is relatively easy to implement; we just need to serve an HTML page with a form for a user to fill in.</p>
			<p>Let's look at the steps:</p>
			<ol>
				<li value="1">Implement <a id="_idIndexMarker347"/>the <code>new_user()</code> function in <code>src/routes/user.rs</code>:<pre>#[get("/users/new", format = "text/html")]
pub async fn new_user() -&gt; HtmlResponse {
    let mut html_string = String::from(USER_HTML_
    PREFIX);
    html_string.push_str(
        r#"&lt;form accept-charset="UTF-8" <strong class="bold">action="/</strong>
<strong class="bold">        users"</strong> autocomplete="off" <strong class="bold">method="POST"</strong>&gt;
    &lt;div&gt;
        &lt;label for="username"&gt;Username:&lt;/label&gt;
        &lt;input name="username" type="text"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="email"&gt;Email:&lt;/label&gt;
        &lt;input name="email" type="email"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="password"&gt;Password:&lt;/label&gt;
        &lt;input name="password" type="password"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="password_confirmation"&gt;Password 
        Confirmation:&lt;/label&gt;
        &lt;input name="password_confirmation" 
        type="password"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="description"&gt;Tell us a little bit 
        more about yourself:&lt;/label&gt;
        &lt;textarea name="description"&gt;&lt;/textarea&gt;
    &lt;/div&gt;
    &lt;button type="submit" value="Submit"&gt;Submit&lt;/
     button&gt;
&lt;/form&gt;"#,
    );
    html_string.push_str(USER_HTML_SUFFIX);
    Ok(RawHtml(html_string))
}</pre></li>
			</ol>
			<p>In the HTML, we <a id="_idIndexMarker348"/>set the <code>form</code> tag <code>action</code> attribute to <code>"/users"</code> and the <code>method</code> attribute to <code>"POST"</code>. This corresponds to the <code>create_user</code> route in our application. On the HTML page, we have fields for <code>username</code>, <code>email</code>, <code>password</code>, <code>password_confirmation</code>, and <code>description</code>. We then insert the button to submit and serve the <code>html_string</code> to the client application.</p>
			<ol>
				<li value="2">Try running the application now and open <code>http://127.0.0.1:8000/users/new</code> in the web browser. Finally, we have something we can render in the browser:</li>
			</ol>
			<div><div><img src="img/Figure_6.1_B16825.jpg" alt="Figure 6.1 ‒ New user page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 ‒ New user page</p>
			<ol>
				<li value="3">As previously, before <a id="_idIndexMarker349"/>implementing the <code>create_user()</code> function, we want to create other routines first. Since the HTML form has no one-to-one mapping to a <code>User</code> struct, we create another struct. Put this struct in <code>src/models/user.rs</code>:<pre>#[derive(Debug, FromForm)]
pub struct NewUser&lt;'r&gt; {
    #[field(validate = len(5..20).or_else(msg!("name 
    cannot be empty")))]
    pub username: &amp;'r str,
    pub email: &amp;'r str,
    pub password: &amp;'r str,
    #[field(validate = eq(self.password).or_
    else(msg!("password confirmation mismatch")))]
    pub password_confirmation: &amp;'r str,
    #[field(default = "")]
    pub description: Option&lt;&amp;'r str&gt;,
}</pre></li>
			</ol>
			<p>We set the derive <code>FromForm</code> trait for <code>NewUser</code>, so on top of the struct fields, we use the <code>field</code> directive. This directive can be used to match the request payload field name to the struct field name, set the default value, and validate the content of the field.</p>
			<p>If we have HTML form field that is different from the struct field name, we can rename the field using field directive like <a id="_idIndexMarker350"/> the following:</p>
			<pre>#[field(name = uncased("html-field-name"))]</pre>
			<p>It can also be done as follows:</p>
			<pre>#[field(name = "some-other-name")]</pre>
			<p>If you use uncased macro, then the payload HTML field name containing any case, such as <code>HTML-FIELD-NAME</code>, will be matched to the struct field name.</p>
			<p>For setting the default value, the syntax is as follows:</p>
			<pre>#[field(default = "default value")]</pre>
			<p>And, for validation, the syntax is as follows:</p>
			<pre>#[field(validate = validation_function())]</pre>
			<p>There are a couple of built-in validation functions in the <code>rocket::form::validate</code> module:</p>
			<ul>
				<li><code>contains</code>: This function succeeds when the field as a string has this substring, or the field as a <code>Vec</code> contains this item, or <code>Option</code> has <code>Some(value)</code>, or <code>rocket::form::Result</code> has <code>Ok(value)</code> – for example, <code>contains("foo")</code>.</li>
				<li><code>eq</code>: This function succeeds when the field value is equal to the function parameters. A type in Rust can be compared if the type implements <code>std::cmp::PartialEq</code>. You can see the example in the <code>NewUser</code> struct, <code>eq(self.password)</code>.</li>
				<li><code>ext</code>: This function succeeds if the field type is <code>rocket::fs::TempFile</code> and the content type matches the function parameter – for example, <code>ext(rocket::http::ContentType::JavaScript)</code>.</li>
				<li><code>len</code>: This function succeeds if the length of the field value is within the parameter range. You can see the example in our <code>NewUser</code> struct, <code>len(5..20)</code>. In Rust, we define the range as <code>from..to</code>, but we can omit the <code>to</code> part.</li>
				<li><code>ne</code>: This function succeeds if the field value is not equal (<code>!=</code>) to the provided parameter. A type implementing the <code>std::cmp::PartialEq</code> trait can also use the inequality operator.</li>
				<li><code>omits</code>: This function is the opposite of <code>contains</code>.</li>
				<li><code>one_of</code>: This function succeeds if the value contains one of the items in the supplied parameter. The parameter must be an iterator.</li>
				<li><code>range</code>: This function is like <code>len</code>, but it matches the value of the field instead of the value of the length of the field.</li>
				<li><code>with</code>: We can pass a function or closure with the Boolean return type, and the function succeeds when the passed function or closure returns <code>true</code>.</li>
			</ul>
			<p>Besides those <a id="_idIndexMarker351"/>functions, there are three more functions we can use. The functions work almost the same, but with different messages:</p>
			<ul>
				<li><code>dbg_contains</code>: This <a id="_idIndexMarker352"/>function also returns the field value in the error message.</li>
				<li><code>dbg_eq</code>: This function <a id="_idIndexMarker353"/>also returns the item value in the error message.</li>
				<li><code>dbg_omits</code>: This function <a id="_idIndexMarker354"/>also returns the item value in the error message.</li>
			</ul>
			<p>In the <code>NewUser</code> struct, we can see that we can also set a custom error message by combining the validation function with <code>.or_else("other message"</code>, as shown in the following example:</p>
			<pre>#[field(validate = len(5..20).or_else(msg!("name cannot be empty")))]</pre>
			<p>Besides the provided functions, we can create a custom validation function. The function should return <code>form::Result&lt;'_, ()&gt;</code>. We want to implement custom validation for checking the strength of the password and the correctness of the email.</p>
			<p>The first validation <a id="_idIndexMarker355"/>is password validation. We are going to use a crate called <code>zxcvbn</code>. This crate is a Rust port of the <code>npm</code> module of the same name created by Dropbox. The inspiration for the <code>zxcvbn</code> library is based on an <code>"CorrectHorseBatteryStaple"</code>, are easier to remember and harder to crack compared to some rule such as <em class="italic">must contain a minimum of eight characters, of which one is upper case, one lower case, and one is a number</em>.</p>
			<ol>
				<li value="4">Add <code>zxcvbn = "2"</code> to the <code>Cargo.toml</code> dependencies, then create the following function in <code>src/models/user.rs</code>:<pre>use rocket::form::{<strong class="bold">self, Error as FormError,</strong> FromForm};
use zxcvbn::zxcvbn;
...
fn validate_password(password: &amp;str) -&gt; form::Result&lt;'_, ()&gt; {
    let entropy = zxcvbn(password, &amp;[]);
    if entropy.is_err() || entropy.unwrap().score()
    &lt; 3 {
        return Err(FormError::validation("weak 
        password").into());
    }
    Ok(())
}</pre></li>
			</ol>
			<p>You can set the scoring strength up to four, but it means we cannot send a weak password to the server. Right now, we just set the threshold of the password score to two.</p>
			<ol>
				<li value="5">After that, we can <a id="_idIndexMarker356"/>implement the validation for email correctness. First, add <code>regex = "1.5.4"</code> to <code>Cargo.toml</code> and add this function in <code>src/models/user.rs</code>:<pre>use regex::Regex;
...
fn validate_email(email: &amp;str) -&gt; form::Result&lt;'_, ()&gt; {
    const EMAIL_REGEX: &amp;str = r#"(?:[a-z0-9!#$%&amp;
    '*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]
    +)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\
    x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\
    x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[
    a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-
    z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][
    0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][
    0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08
    \x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01
    -\x09\x0b\x0c\x0e-\x7f])+)\])"#;
    let email_regex = Regex::new(EMAIL_REGEX).
    unwrap();
    if !email_regex.is_match(email) {
        return Err(FormError::validation("invalid 
        email").into());
    }
    Ok(())
}</pre></li>
				<li>If the <a id="_idIndexMarker357"/>email <code>NewUser</code> struct:<pre>pub struct NewUser&lt;'r&gt; {
    ...
    <strong class="bold">#[field(validate = validate_email().</strong>
<strong class="bold">    or_else(msg!("invalid email")))]</strong>
    pub email: &amp;'r str,
    <strong class="bold">#[field(validate = validate_password()</strong>
<strong class="bold">    .or_else(msg!("weak password")))]</strong>
    pub password: &amp;'r str,
    ...
}</pre></li>
				<li>Next, we can implement the <code>create()</code> method for the <code>User</code> struct. For security purposes, we will hash the password using the secure password-hashing function. In 2021, people considered <code>md5</code> as a very insecure hashing function, and <code>sha1</code> and <code>sha3</code> as insecure hashing functions, so we will not use those functions. People usually consider using <code>bcrypt</code>, <code>scrypt</code>, or <code>argon2</code> instead. Now, <code>argon2</code> has a version, <code>argon2id</code>, which is resistant to side-channel attacks and GPU cracking attacks, so we will use <code>argon2</code> as a password-hashing implementation.</li>
			</ol>
			<p>There is <a id="_idIndexMarker359"/>another possible attack on the <code>create()</code> method: <code>"&lt;script&gt;console.log("hack")&lt;/script&gt;"</code> as a description. We can rectify this problem by using an HTML sanitization library called <code>ammonia</code>.</p>
			<p>To add <code>argon2</code> and <code>ammonia</code> for the <code>create()</code> method, add these lines in <code>Cargo.toml</code>:</p>
			<pre>ammonia = "3.1.2"
argon2 = "0.3"
rand_core = {version = "0.6", features = ["std"]}</pre>
			<ol>
				<li value="8">We can create <a id="_idIndexMarker360"/>a function to sanitize HTML in <code>src/models/mod.rs</code>:<pre>use ammonia::Builder;
use std::collections::hash_set::HashSet;
pub fn clean_html(src: &amp;str) -&gt; String {
    Builder::default()
        .tags(HashSet::new())
        .clean(src)
        .to_string()
}</pre></li>
			</ol>
			<p>The default cleaner from <code>ammonia::Builder::default</code> allows many HTML tags, and people can still deface the site. To rectify this problem, we are passing an empty <code>HashSet</code> to disallow any HTML tag.</p>
			<ol>
				<li value="9">After the password hashing and HTML sanitization are ready, it is time to implement the <code>create()</code> method for the <code>User</code> struct. Add the required <code>use</code> directives in <code>src/models/user.rs</code>:<pre>use super::clean_html;
use argon2::{password_hash::{rand_core::OsRng, PasswordHasher, SaltString},Argon2};</pre></li>
				<li>Put these <a id="_idIndexMarker361"/>lines in the <code>impl User</code> block:<pre>pub async fn create&lt;'r&gt;(
    connection: &amp;mut PgConnection,
    new_user: &amp;'r NewUser&lt;'r&gt;,
) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {
    let uuid = Uuid::new_v4();
    let username = &amp;(clean_html(new_user.username));
    let description = &amp;(new_user.description.map(
    |desc| clean_html(desc)));
}</pre></li>
			</ol>
			<p>We generate a new UUID for the new <code>User</code> instance. After that, we clean the username value and description value. We don't clean the email and password because we already validate the content of the email using a regex and we will not show any password in the HTML.</p>
			<ol>
				<li value="11">Next, append the following lines to hash the password:<pre>let salt = SaltString::generate(&amp;mut OsRng);
let argon2 = Argon2::default();
let password_hash = argon2.hash_password(new_user.password.as_bytes(), &amp;salt);
if password_hash.is_err() {
    return Err("cannot create password hash".into());
}</pre></li>
				<li>Next, we <a id="_idIndexMarker362"/>send the <code>INSERT</code> statement to our database server and return the inserted row. Append the following lines:<pre>let query_str = r#"INSERT INTO users
(uuid, username, email, password_hash, description, status)
VALUES
($1, $2, $3, $4, $5, $6)
RETURNING *"#;
Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)
    .bind(uuid)
    .bind(username)
    .bind(new_user.email)
    .bind(password_hash.unwrap().to_string())
    .bind(description)
    .bind(UserStatus::Inactive)
    .fetch_one(connection)
    .await?)</pre></li>
				<li>When the <code>User::create()</code> method is ready, we can implement the <code>create_user()</code> function. When the application successfully creates a user, it's better to show the result by redirecting to <code>get_user</code>. For this purpose, we can use the <code>rocket::response::Redirect</code> type instead of <code>RawHtml</code>.</li>
			</ol>
			<p>Also, if there's an error, it's better to redirect to <code>new_user()</code> and show the error so the user can fix the input error. We can do this by getting the error of the <code>NewUser</code> validations or any other error, and redirecting to the <code>new_user()</code> function with embedded error information.</p>
			<p>We can <a id="_idIndexMarker363"/>get the errors for the request form value using <code>rocket::form::Contextual</code>, a proxy for the form type that contains error information. We also going to use <code>rocket::response::Flash</code> to send a one-time cookie to the web browser and retrieve the message on a route using <code>rocket::request::FlashMessage</code>. Append these lines to <code>src/routes/user.rs</code>:</p>
			<pre>use crate::models::{pagination::Pagination, user::{<strong class="bold">NewUser,</strong> User}};
use rocket::form::{<strong class="bold">Contextual</strong>, Form};
<strong class="bold">use rocket::request::FlashMessage;</strong>
use rocket::response::{content::RawHtml, <strong class="bold">Flash, Redirect</strong>};</pre>
			<ol>
				<li value="14">Change the signature of the <code>create_user()</code> function to the following:<pre>#[post("/users", format = "<strong class="bold">application/x-www-form-urlencoded</strong>", data = "&lt;<strong class="bold">user_context</strong>&gt;")]
pub async fn create_user&lt;'r&gt;(
    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,
    <strong class="bold">user_context: Form&lt;Contextual&lt;'r, NewUser&lt;'r&gt;&gt;&gt;,</strong>
) -&gt; <strong class="bold">Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</strong> {}</pre></li>
			</ol>
			<p>Because we are sending <code>POST</code> data, the browser will send <code>Content-Type</code> as <code>"application/x-www-form-urlencoded"</code>, so we have to change the format accordingly.</p>
			<p>Also, take a look at the request parameter; instead of <code>Form&lt;NewUser&lt;'r&gt;&gt;</code>, we are inserting the <code>Contextual</code> type in the middle of the parameter. We are also changing the return value to <code>Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</code>.</p>
			<ol>
				<li value="15">Now, let's <a id="_idIndexMarker364"/>implement the function body. Append the following lines to the function body:<pre>if user_context.value.is_none() {
    let error_message = format!(
        "&lt;div&gt;{}&lt;/div&gt;",
        user_context
            .context
            .errors()
            .map(|e| e.to_string())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("&lt;br/&gt;")
    );
    return Err(Flash::error(Redirect::to("/
    users/new"), error_message));
}</pre></li>
			</ol>
			<p>If <code>user_context</code> has <code>value</code>, it means that Rocket successfully converted the request payload and put it inside the <code>value</code> attribute. We are branching and returning <code>Error</code> with a <code>Flash</code> message and <code>Redirect</code> directive to <code>"/users/new"</code>.</p>
			<ol>
				<li value="16">The next implementation is if Rocket successfully parses <code>NewUser</code>. Append the following lines in the <code>true</code> branch:<pre>let new_user = user_context.value.as_ref().unwrap();
let connection = db.acquire().await.map_err(|_| {
    Flash::error(
        Redirect::to("/users/new"),
        "&lt;div&gt;Something went wrong when creating 
         user&lt;/div&gt;",
    )
})?;
let user = User::create(connection, new_user).await.map_err(|_| {
    Flash::error(
        Redirect::to("/users/new"),
        "&lt;div&gt;Something went wrong when creating 
        user&lt;/div&gt;",
    )
})?;
Ok(Flash::success(
    Redirect::to(format!("/users/{}", user.uuid)),
    "&lt;div&gt;Successfully created user&lt;/div&gt;",
))</pre></li>
			</ol>
			<p>Just like <a id="_idIndexMarker365"/>the <code>get_user()</code> function, we create a routine to get the database connection, perform an <code>INSERT</code> operation to the database server, and generate the successful <code>Redirect</code> response. But, when an error occurs, instead of returning HTML, we generate the <code>Redirect</code> directive with the appropriate path and message.</p>
			<ol>
				<li value="17">We now need to change the <code>new_user()</code> and <code>get_user()</code> functions to be able to handle incoming <code>FlashMessage</code> request guards. First, for the <code>new_user()</code> function, change the signature to the following:<pre>get_user(
    mut db: Connection&lt;DBConnection&gt;,
    uuid: &amp;str,
    <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;,</strong>
)</pre></li>
				<li>Because the <a id="_idIndexMarker366"/>flash message may not always exist, we wrap it in <code>Option</code>. After <code>let mut html_string = String::from(USER_HTML_PREFIX);</code>, append the following lines in the function body:<pre>if flash.is_some() {
    html_string.push_str(flash.unwrap().message());
}</pre></li>
				<li>We change the <code>new_user()</code> function almost the same. Change the function signature to this:<pre>new_user(<strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;</strong>)</pre></li>
			</ol>
			<p>Then, append the following lines after <code>USER_HTML_PREFIX</code>:</p>
			<pre>if flash.is_some() {
    html_string.push_str(flash.unwrap().message());
}</pre>
			<ol>
				<li value="20">Now, it's time to try creating the user data. If everything is correct, you should see screens like the following. The error message looks as follows:</li>
			</ol>
			<div><div><img src="img/Figure_6.2_B16825.jpg" alt="Figure 6.2 ‒ Error message when failed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 ‒ Error message when failed</p>
			<p>The success <a id="_idIndexMarker367"/>message looks like the following:</p>
			<div><div><img src="img/Figure_6.3_B16825.jpg" alt="Figure 6.3 ‒ Success message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 ‒ Success message</p>
			<p>In the next sections, we are going to continue with updating the user and deleting a user.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Implementing PUT and PATCH user</h1>
			<p>To update the user, we need a page such as <code>new_user()</code>, but we want the form pre-populated <a id="_idIndexMarker368"/>with existing data. We also want to add another field <a id="_idIndexMarker369"/>for the user to confirm the old password. Let's look at the steps:</p>
			<ol>
				<li value="1">Change the <code>edit_user()</code> function signature to the following:<pre>#[get("/users/edit/&lt;<strong class="bold">uuid</strong>&gt;", format = "text/html")]
pub async fn edit_user(mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,    <strong class="bold">uuid</strong>: &amp;str, <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;</strong>) -&gt; HtmlResponse {}</pre></li>
				<li>To get the existing user, append the following lines inside the function body block:<pre>let connection = db
    .acquire()
    .await
    .map_err(|_| Status::InternalServerError)?;
let user = User::find(connection, uuid)
    .await
    .map_err(|_| Status::NotFound)?;</pre></li>
				<li>After that, we can append the HTML, such as <code>new_user()</code>, but this time, we also include the existing data from the user. Append the following lines inside the <code>edit_user()</code> function body:<pre>let mut html_string = String::from(USER_HTML_PREFIX);
if flash.is_some() {
    html_string.push_str(flash.unwrap().message());
}
html_string.push_str(
    format!(
        r#"&lt;form accept-charset="UTF-8" action="/
        users/{}" autocomplete="off" method="POST"&gt;
&lt;input type="hidden" name="_METHOD" value="PUT"/&gt;
&lt;div&gt;
    &lt;label for="username"&gt;Username:&lt;/label&gt;
    &lt;input name="username" type="text" value="{}"/&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="email"&gt;Email:&lt;/label&gt;
    &lt;input name="email" type="email" value="{}"/&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="old_password"&gt;Old password:&lt;/label&gt;
    &lt;input name="old_password" type="password"/&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="password"&gt;New password:&lt;/label&gt;
    &lt;input name="password" type="password"/&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="password_confirmation"&gt;Password 
    Confirmation:&lt;/label&gt;
    &lt;input name="password_confirmation" type=
    "password"/&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="description"&gt;Tell us a little bit more 
    about yourself:&lt;/label&gt;
    &lt;textarea name="description"&gt;{}&lt;/textarea&gt;
&lt;/div&gt;
&lt;button type="submit" value="Submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;"#,
        &amp;user.uuid,
        &amp;user.username,
        &amp;user.email,
        &amp;user.description.unwrap_or_else(|| 
        "".to_string()),
    )
    .as_ref(),
);
html_string.push_str(USER_HTML_SUFFIX);
Ok(RawHtml(html_string))</pre></li>
			</ol>
			<p>After this, all previous <a id="_idIndexMarker370"/>links to <code>"/users/edit/{}"</code> that we <a id="_idIndexMarker371"/>implemented in the previous pages should work.</p>
			<p>If you look at the code, we see the form's <code>method</code> attribute has a <code>"POST"</code> value. The reason is that the HTML standard says that a form method can only be <code>GET</code> or <code>POST</code>. Most web browsers will just change the invalid method, such as <code>PUT</code> and <code>PATCH</code>, to <code>POST</code>.</p>
			<p>Some web frameworks work around this limitation by sending an <code>POST</code> request but include a hidden value in the request payload. We are going to use the second way to implement updating the user by adding a new field, <code>name="_METHOD"</code>, with the <code>"PUT"</code> value.</p>
			<p>Just like <code>create_user()</code>, we want to execute <code>update_function()</code> to redirect to <code>edit_user()</code> again if there's something wrong.  We also want to execute <code>update_function()</code> to redirect to the user page again after successfully updating the user.</p>
			<p>Since we <a id="_idIndexMarker372"/>are adding new payloads, <code>_METHOD</code> and <code>old_password</code>, we need a <a id="_idIndexMarker373"/>new type that is different from <code>NewUser</code>:</p>
			<ol>
				<li value="1">Create a new struct called <code>EditedUser</code> in <code>src/models/user.rs</code>:<pre>#[derive(Debug, FromForm)]
pub struct EditedUser&lt;'r&gt; {
    #[field(name = "_METHOD")]
    pub method: &amp;'r str,
    #[field(validate = len(5..20).or_else(msg!("name 
    cannot be empty")))]
    pub username: &amp;'r str,
    #[field(validate = validate_email()
    .or_else(msg!("invalid email")))]
    pub email: &amp;'r str,
    pub old_password: &amp;'r str,
    pub password: &amp;'r str,
    pub password_confirmation: &amp;'r str,
    #[field(default = "")]
    pub description: Option&lt;&amp;'r str&gt;,
}</pre></li>
				<li>We want <a id="_idIndexMarker374"/>to skip updating the password if there's no value in <code>old_password</code>, but if there is a value in <code>old_password</code>, we want to <a id="_idIndexMarker375"/>make sure the <code>password</code> strength is adequate and <code>password_confirmation</code> has the same content as <code>password</code>. Create a function in <code>src/models/user.rs</code>:<pre>fn skip_validate_password&lt;'v&gt;(password: &amp;'v str, old_password: &amp;'v str, password_confirmation: &amp;'v str) -&gt; form::Result&lt;'v, ()&gt; {
    if old_password.is_empty() {
        return Ok(());
    }
    validate_password(password)?;
    if password.ne(password_confirmation) {
        return Err(FormError::validation("password 
        confirmation mismatch").into());
    }
    Ok(())
}</pre></li>
				<li>Then, use the validation function in the directive above the password field:<pre><strong class="bold">#[field(validate = skip_validate_password(self.old_password, self.password_confirmation))]</strong>
pub password: &amp;'r str,</pre></li>
			</ol>
			<p>We need a method for <code>User</code> to update the database row based on the <code>EditedUser</code> content. This method will also verify the hash of <code>old_password</code> to make sure <code>EditedUser</code> is valid.</p>
			<ol>
				<li value="4">Add the <code>use</code> directive in <code>src/models/user.rs</code>:<pre>use argon2::{password_hash::{rand_core::OsRng, PasswordHash, <strong class="bold">PasswordHasher, PasswordVerifier,</strong> SaltString}, Argon2};
<strong class="bold">use chrono::offset::Utc;</strong></pre></li>
				<li>Create a <a id="_idIndexMarker376"/>new method inside the <code>impl User</code> block in <code>src/models/user.rs</code>:<pre>pub async fn update&lt;'r&gt;(db: &amp;mut Connection&lt;DBConnection&gt;, uuid: &amp;'r str, user: &amp;'r EditedUser&lt;'r&gt;) -&gt; Result&lt;Self, Box&lt;dyn Error&gt;&gt; {}</pre></li>
				<li>Inside <a id="_idIndexMarker377"/>the method, fetch the old user data from the database:<pre>let connection = db.acquire().await?;
let old_user = Self::find(connection, uuid).await?;</pre></li>
				<li>Prepare the data for updating:<pre>let now = OurDateTime(Utc::now());
let username = &amp;(clean_html(user.username));
let description = &amp;(user.description.map(|desc| clean_html(desc)));</pre></li>
				<li>Because we can change the password or skip changing the password depending on whether or not we have <code>old_password or not</code>, prepare the query items:<pre>let mut set_strings = vec![
    "username = $1",
    "email = $2",
    "description = $3",
    "updated_at = $4",
];
let mut where_string = "$5";
let mut password_string = String::new();
let is_with_password = !user.old_password.is_empty();</pre></li>
				<li>If we are <a id="_idIndexMarker378"/>updating <code>password</code>, we need to verify <code>old_password</code> with the <a id="_idIndexMarker379"/>existing password. We also want to hash a new password and add the password to <code>set_strings</code>. Append the following lines:<pre>if is_with_password {
    let old_password_hash = PasswordHash::
    new(&amp;old_user.password_hash)
        .map_err(|_| "cannot read password hash")?;
    let argon2 = Argon2::default();
    argon2
        .verify_password(user.password.as_bytes(), 
        &amp;old_password_hash)
        .map_err(|_| "cannot confirm old password")?;
    let salt = SaltString::generate(&amp;mut OsRng);
    let new_hash = argon2
        .hash_password(user.password.as_bytes(), 
        &amp;salt)
        .map_err(|_| "cannot create password hash")?;
    password_string.push_str(
    new_hash.to_string().as_ref());
    set_strings.push("password_hash = $5");
    where_string = "$6";
}</pre></li>
				<li>We can <a id="_idIndexMarker380"/>then construct the <code>UPDATE</code> statement to update <a id="_idIndexMarker381"/>the user, execute the statement, and return the <code>User</code> instance:<pre>let query_str = format!(
    r#"UPDATE users SET {} WHERE uuid = {} RETURNING 
    *"#,
    set_strings.join(", "),
    where_string,
);
let connection = db.acquire().await?;
let mut binded = sqlx::query_as::&lt;_, Self&gt;(&amp;query_str)
    .bind(username)
    .bind(user.email)
    .bind(description)
    .bind(&amp;now);
if is_with_password {
    binded = binded.bind(&amp;password_string);
}
let parsed_uuid = Uuid::parse_str(uuid)?;
Ok(binded.bind(parsed_uuid).fetch_one(connection).await?)</pre></li>
				<li>Now, it's time to use <code>EditedUser</code> and implement <code>update_user()</code>. Append <code>EditedUser</code> in the <code>use</code> directive:<pre>use crate::models::{pagination::Pagination, user::{<strong class="bold">EditedUser</strong>, NewUser, User}};</pre></li>
				<li>Create the <code>update_user()</code> function in <code>src/routes/user.rs</code>:<pre>#[post("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]
pub async fn update_user&lt;'r&gt;(db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {}</pre></li>
				<li>In the <a id="_idIndexMarker382"/>function, we need to check whether the form is <a id="_idIndexMarker383"/>correct or not. Append the following lines:<pre>if user_context.value.is_none() {
    let error_message = format!(
        "&lt;div&gt;{}&lt;/div&gt;",
        user_context
            .context
            .errors()
            .map(|e| e.to_string())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join("&lt;br/&gt;")
    );
    return Err(Flash::error(
        Redirect::to(format!("/users/edit/{}", uuid)),
        error_message,
    ));
}</pre></li>
				<li>We can tell the application to process depending on <code>"_METHOD"</code>. Append the following lines:<pre>let user_value = user_context.value.as_ref().unwrap();
match user_value.method {
    "PUT" =&gt; put_user(db, uuid, user_context).await,
    "PATCH" =&gt; patch_user(db, uuid, user_
    context).await,
    _ =&gt; Err(Flash::error(
        Redirect::to(format!("/users/edit/{}", uuid)),
        "&lt;div&gt;Something went wrong when updating 
        user&lt;/div&gt;",
    )),
}</pre></li>
			</ol>
			<p>We don't <a id="_idIndexMarker384"/>waste the functions we defined before. We are <a id="_idIndexMarker385"/>using the <code>put_user()</code> and <code>patch_user()</code> functions.</p>
			<ol>
				<li value="15">Now, it's time to implement the <code>put_user()</code> function. Change the signature of the <code>put_user()</code> function:<pre>#[put("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]
pub async fn put_user&lt;'r&gt;(mut db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {}</pre></li>
			</ol>
			<p>Then, implement the function as follows:</p>
			<pre>let user_value = user_context.value.as_ref().unwrap();
let user = User::update(&amp;mut db, uuid, user_value).await.map_err(|_| {
    Flash::error(
        Redirect::to(format!("/users/edit/{}", uuid)),
        "&lt;div&gt;Something went wrong when updating 
        user&lt;/div&gt;",
    )
})?;
Ok(Flash::success(
    Redirect::to(format!("/users/{}", user.uuid)),
    "&lt;div&gt;Successfully updated user&lt;/div&gt;",
))</pre>
			<ol>
				<li value="16">For the <code>patch_user()</code> function, we <a id="_idIndexMarker386"/>can just reuse <a id="_idIndexMarker387"/>the <code>put_user()</code> function. Write the code for <code>patch_user()</code>:<pre>#[patch("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", data = "&lt;user_context&gt;")]
pub async fn patch_user&lt;'r&gt;(db: Connection&lt;DBConnection&gt;, uuid: &amp;str, user_context: Form&lt;Contextual&lt;'r, EditedUser&lt;'r&gt;&gt;&gt;) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    put_user(db, uuid, user_context).await
}</pre></li>
				<li>Finally, append the new route in <code>src/main.rs</code>:<pre>user::edit_user,
<strong class="bold">user::update_user,</strong>
user::put_user,</pre></li>
			</ol>
			<p>The only endpoint left is for deleting the user. Let's continue with that in the next section.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Implementing DELETE user</h1>
			<p>The first <a id="_idIndexMarker388"/>thing we want to do to delete a user is to create a method for the <code>User</code> struct. Let's look at the steps:</p>
			<ol>
				<li value="1">Write the method to delete a user in the <code>impl User</code> block in <code>src/models/user.rs</code>:<pre>pub async fn destroy(connection: &amp;mut PgConnection, uuid: &amp;str) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let parsed_uuid = Uuid::parse_str(uuid)?;
    let query_str = "DELETE FROM users WHERE uuid = 
    $1";
    sqlx::query(query_str)
        .bind(parsed_uuid)
        .execute(connection)
        .await?;
    Ok(())
}</pre></li>
			</ol>
			<p>Then, we can implement the <code>delete_user()</code> function in <code>src/routes/user.rs</code>:</p>
			<pre>#[delete("/users/&lt;uuid&gt;", format = "application/x-www-form-urlencoded")]
pub async fn delete_user(
    mut db: Connection&lt;DBConnection&gt;,
    uuid: &amp;str,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    let connection = db.acquire().await.map_err(|_| {
        Flash::error(
            Redirect::to("/users"),
            "&lt;div&gt;Something went wrong when deleting 
            user&lt;/div&gt;",
        )
    })?;
    User::destroy(connection, uuid).await.map_err(|_| {
        Flash::error(
            Redirect::to("/users"),
            "&lt;div&gt;Something went wrong when deleting 
            user&lt;/div&gt;",
        )
    })?;
    Ok(Flash::success(
        Redirect::to("/users"),
        "&lt;div&gt;Successfully deleted user&lt;/div&gt;",
    ))
}</pre>
			<ol>
				<li value="2">The problem <a id="_idIndexMarker389"/>is that neither the link nor the form in HTML are allowed to use the <code>DELETE</code> method. We cannot use the link, as any bot seeing it will crawl on it and could perform resource deletion accidentally. As with updating the user, we can use the form and send a <code>POST</code> request to a new endpoint. Add a new function in <code>src/routes/user.rs</code>:<pre>#[post("/users/delete/&lt;uuid&gt;", format = "application/x-www-form-urlencoded")]
pub async fn delete_user_entry_point(
    db: Connection&lt;DBConnection&gt;,
    uuid: &amp;str,
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {
    delete_user(db, uuid).await
}</pre></li>
				<li>Don't forget to add the route in <code>src/main.rs</code>:<pre>user::delete_user,
<strong class="bold">user::delete_user_entry_point,</strong></pre></li>
				<li>Now, where <a id="_idIndexMarker390"/>can we create a form to delete the user? Let's do that on the <code>get_user()</code> page. Append the HTML for the form as follows:<pre>html_string
    .push_str(format!(r#"&lt;a href="/users/edit/{}"&gt;Edit 
    User&lt;/a&gt;&lt;br/&gt;"#, user.uuid).as_ref());
html_string.push_str(
    format!(
        r#"&lt;form accept-charset="UTF-8" action="/
        users/delete/{}" autocomplete="off" 
        method="POST"&gt;&lt;button type="submit" 
        value="Submit"&gt;Delete&lt;/button&gt;&lt;/form&gt;"#,
        user.uuid
    )
    .as_ref(),
);</pre></li>
			</ol>
			<p>We have now completed all of the endpoints used to manage users. Try adding users and see <a id="_idIndexMarker391"/>how pagination works or try improving the HTML. You can also try activating users for a challenge!</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Summary</h1>
			<p>In this chapter, we have learned about the basic operations for user entities by implementing the creation, reading, updating, and deleting of user routes.</p>
			<p>We also learned more about various modules of the Rocket framework such as RawHtml, Redirect, Contextual, Flash, Form, and FlashMessage.</p>
			<p>Along with implementing the endpoints, we also learned more about database operations such as querying, inserting, updating, and deleting objects on a database server.</p>
			<p>In the next chapter, we are going to learn more about error handling and creating our own error types.</p>
		</div>
	</body></html>