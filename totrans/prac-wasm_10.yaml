- en: '*Chapter 7*: Integrating Rust with WebAssembly'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a system-level programming language. Being a system-level programming
    language, Rust provides low-level memory management and the ability to represent
    data efficiently. Thus, it provides complete control to programmers and better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, Rust also provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A friendly compiler** – The Rust compiler is your companion when writing
    Rust. The compiler corrects you, guides you, and ensures that you write memory-safe
    code almost always.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ownership model** – The ownership model ensures that we do not need garbage
    collection. This guarantees thread and memory safety in Rust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safety, speed, and concurrency** – Rust ensures safety and concurrency and
    makes you stay away from risks, crashes, and vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A modern language** – Rust provides modern language syntax and the language
    is built to provide a better developer experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features (along with thousands of others) ensure Rust is a general-purpose
    programming language. The highlight of the Rust language is that its compiler
    and community are always helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust provides first-class support for WebAssembly. Rust''s rich toolchain makes
    it easier to get started with WebAssembly. Rust does not need a runtime, which
    makes it a perfect candidate for WebAssembly. In this chapter, we will see how
    to install Rust and explore various ways to convert Rust into a WebAssembly module.
    We will cover the following sections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via `rustc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing wasm-bindgen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via `wasm-bindgen`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's hack into the Rust and WebAssembly world.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a compiled language and its compiler is called the **Rust compiler**
    (**rustc**). Rust also has its own package manager, called **Cargo**. Cargo is
    similar to npm for Node.js. Cargo downloads package dependencies and builds, compiles,
    packs, and uploads the artifacts into crates (Rust's version of packages).
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language provides an easy way to install and manage Rust via `rustup`.
    `rustup` helps to install, update, and remove `rustc`, Cargo, and `rustup` itself.
    It makes it easy to install and manage various versions of Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Let's install Rust using the `rustup` tool and see how we can manage Rust versions
    using `rustup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux or macOS, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The script will download and install the Rust language. Both `rustc` and Cargo
    are installed in `~/.cargo/bin` and delegate any access to the underlying toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, download and install the binaries from here: [https://forge.rust-lang.org/infra/other-installation-methods.html](https://forge.rust-lang.org/infra/other-installation-methods.html).
    Both `rustc` and Cargo are installed in the `users` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will require C++ build tools for Visual Studio 2013 or later. You can install
    them from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation is completed successfully, you can check it by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`rustup` is a toolchain multiplexer. It installs and manages many Rust toolchains
    and proxies them through the single set of tools installed at `.cargo/bin` in
    the home directory. Once `rustup` is installed, we can easily manage the `rustc`
    and `cargo` compilers. `rustup` also makes it easy to switch between nightly,
    stable, and beta versions of Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: Rust provides WebAssembly compilation support in its stable version. We will
    also switch to the nightly build to make sure we get all the latest benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch to the nightly version, we have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will switch the default `rustc` to the nightly version. The `rustc`
    proxy in `~/.cargo/bin` will run the nightly compiler instead of the stable compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update to the latest version of nightly, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successfully updated, we can check the current version installed by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rust supports WebAssembly as a first-class citizen. Thus, `rustc` is capable
    of compiling Rust code into WebAssembly modules. Let's see how to convert Rust
    into WebAssembly via `rustc`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via rustc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust uses the LLVM compiler we'll create now to generate machine-native code.
    `rustc` uses LLVM's capability to convert the native code into a WebAssembly module.
    We installed Rust in the previous section; let's start converting Rust into a
    WebAssembly module using `rustc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with Hello World:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `hello_world.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Spin up your favorite editor and start writing the Rust code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have defined a `main` function. Similar to C, `main` is a special function
    that marks the entry point to a program after it has been compiled as an executable.
  prefs: []
  type: TYPE_NORMAL
- en: '`fn` is the function keyword in Rust. `main()` is the function name.'
  prefs: []
  type: TYPE_NORMAL
- en: '`println!` is the macro. Macros in Rust allow us to abstract code at a syntactic
    level. A macro invocation is shorthand for an "expanded" syntactic form. This
    expansion happens early on in compilation, before any static checking.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros are an interesting feature but explaining them is beyond the scope of
    this book. You can find more information here: [https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass in the `Hello World!` string to the `println!` macro function. We can
    compile and generate the binary by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate a `hello` binary. We can execute the binary and that will
    print `Hello World!`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, compile Rust into a WebAssembly module with `rustc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the generated code in the browser using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your browser and head over to `http://localhost:8000`. Open the developer
    console to see `Hello World!` printed in it.
  prefs: []
  type: TYPE_NORMAL
- en: To convert Rust into a WebAssembly module, we have used the `--target` flag.
    This flag instructs the compiler to compile and build the binary such that it
    runs on the provided runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We passed in `wasm32-unknown-emscripten` as a value to the `--target` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm32` indicates that the address space is 32 bits large. `unknown` tells
    the compiler that you don''t know the system that you are compiling to. `emscripten`
    at the end notifies the compiler that you are targeting.'
  prefs: []
  type: TYPE_NORMAL
- en: So, with the `wasm32-unknown-emscripten` value, the compiler will compile on
    almost any machine but run only on the Emscripten runtime. Then, we specify the
    input file that needs to be compiled into the WebAssembly module. Finally, we
    specify the output with a `-o` flag.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand what `rustc` does.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Rust compilation steps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B14844.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Rust compilation steps
  prefs: []
  type: TYPE_NORMAL
- en: '`rustc` first parses the input and produces the **Abstract Syntax Tree** (**AST**).
    Once the AST is generated, the compiler then recursively resolves the paths, expanding
    macros and other references. Once the AST is completely resolved, it will be converted
    into the **High-level Intermediate Representation** (**HIR**). This intermediate
    representation is like a desugared variant of AST.'
  prefs: []
  type: TYPE_NORMAL
- en: The HIR is then analyzed for type checking. After type checking, the HIR is
    postprocessed and converted into the **Middle Intermediate Representation** (**MIR**).
    From MIR, the compiler generates the **LLVM Intermediate Representation** (**LLVM
    IR**). After that, LLVM does the required optimizations on them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with LLVM IR, it is easier to convert LLVM IR into WebAssembly modules.
    This is similar to how Emscripten converts C or C++ code into WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using the `wasm32-unknown-emscripten` flag here, we need `emcc`
    to be available for converting the LLVM IR generated from Rust code into a WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use `rustc` to generate WebAssembly modules. It uses Emscripten
    behind the scenes to create them. But Rust provides another abstraction to generate
    WebAssembly modules, via Cargo.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to convert Rust into WebAssembly using
    Cargo.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo makes it easier to create, run, download, compile, test, and run your
    project. The `cargo` command provides a wrapper that calls the `rustc` compiler
    to start the compilation. In order to create WebAssembly modules using Rust's
    toolchain, we will be using a different target, `wasm32-unknown-unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: The `wasm32-unknown-unknown` target adds zero runtime and toolchain footprint.
    `wasm32` makes the compiler assume that only the `wasm32` instruction set is present.
    The first `unknown` in `unknown-unknown` indicates the code can compile on any
    machine and the second indicates the code can run on any machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, let''s create a new project with Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A new project called `fib_wasm` is created. The new option creates a Rust project.
    The `--lib` flag informs Cargo to create a new library project rather than the
    default binary project.
  prefs: []
  type: TYPE_NORMAL
- en: The binary project will produce the executable binary. The library project will
    create the library module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spin up your favorite text editor and replace the contents of `src/lib.rs`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`#[no_mangle]` is a kind of annotation. This annotation informs the compiler
    not to mangle the names when generating the library.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the `add` function. The `add` function takes in two parameters,
    `x` and `y`. We define their types with `i32` following the variable and a colon
    (`:`). Finally, we define their return type using `-> i32`.
  prefs: []
  type: TYPE_NORMAL
- en: The function body has just `x + y`. Note, in Rust we do not need `return` keyword
    and `;` at the end of the last statement, this shorts to return.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo also generates `Cargo.toml`. This file holds all the meta-information
    about the project, how to compile the Rust code, and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cargo.toml` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It defines the package name, version, authors, and edition of Rust we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have to instruct the compiler what type of crate we are compiling.
    We can specify it under the `[lib]` segment and with the `crate-type` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Cargo.toml` and append the `crate-type` information inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`cdylib` here specifies a dynamic system library will be produced. This dynamic
    system library is used when the library has to be loaded from another language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile Rust into WebAssembly modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke `rustc` with the specified target. That will generate the WebAssembly
    module inside `/target/wasm32-unknown-unknown/`. Now, in order to run the WebAssembly
    module on the browser, let's manually create the HTML file and load it using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following content to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We defined the script inside the `<script>` tag. In HTML, we define JavaScript
    inside the `<script>` tag. We have added the `async` keyword. The `async` keyword
    specifies the function is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: First, we fetch the WebAssembly module. The WebAssembly module is generated
    in the `target/wasm32-unknown-unknown/debug/` folder with the same name as the
    package name defined in `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: The `await` keyword ensures the execution is awaited until we fetch the entire
    WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: We then convert the collected bytes (from the fetch call) using `bytes.arrayBuffer()`.
    The `response` object will now have the WebAssembly module inside `ArrayBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: We then instantiate the bytes array using the `WebAssembly.instantiate` function.
    The `result` object contains the entire WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly module `result` contains the `instance` property. The instance
    has the `exports` property. The `exports` property holds all the functions exported
    by the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Since we added `#[no_mangle]`, the exported function name is not changed. Hence,
    the `exports` property has the `add` function defined in it.
  prefs: []
  type: TYPE_NORMAL
- en: We have used async-await here to make the syntax more elegant and contextually
    easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the preceding code will give an output of `13`. You can check the
    output in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `cargo build` command invokes `rustc` and compiles the Rust code
    into MIR and then into LLVM IR. The generated LLVM IR is then converted into a
    WebAssembly module. Let''s make this function a bit more complicated. We can create
    a Fibonacci number generator with Rust and run the WebAssembly Module on the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and replace everything with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build it using `cargo build --target wasm32-unknown-unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, replace `index.html` such that we call the Fibonacci instead of the `add`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, spin up the HTML server and check the browser's console for the Fibonacci
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we have seen simple examples. But how can we pass functions and classes
    from JavaScript into WebAssembly and the other way around? In order to do more
    advanced bindings, Rust provides us with `wasm-bindgen`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing wasm-bindgen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wasm-bindgen` is used to bind entities from Rust into JavaScript and vice
    versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-bindgen` makes it more natural to import exported entities from Rust
    into JavaScript. JavaScript developers will find that `wasm-bindgen`''s use of
    WebAssembly is similar to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: This enables the use of richer and easier APIs while converting Rust into a
    WebAssembly module. `wasm-bindgen` uses these features and provides a simple API
    to use. It ensures that there is high-level interaction happening between wasm
    modules and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`wasm-bindgen` provides a channel between JavaScript and WebAssembly to communicate
    something other than numbers, such as objects, strings, and arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `wasm-bindgen-cli`, use the following `cargo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successfully installed, let''s run the `wasm-bindgen` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the various options `wasm-bindgen` supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the file in a particular directory and with a particular name,
    the tool has `--out-dir` and `--out-name`, respectively. To reduce or optimize
    the generated WebAssembly module size, `wasm-bindgen` has the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--debug`: The `--debug` option includes extra debugging information in the
    generated WebAssembly module. This will increase the size of the WebAssembly module
    but it is useful in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--keep-debug`: This WebAssembly module may or may not have custom sections.
    These custom sections can be used to hold the debugging information. These custom
    sections will be helpful while debugging the application (such as in browser developer
    tools). This will increase the size of the WebAssembly module. This is useful
    in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-demangle`: This flag tells `wasm-bindgen` not to demangle the Rust symbol
    names. Demangling allows the end user to use the same name that they have defined
    in the Rust file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--remove-name-section`: This will remove the debugging name section of the
    file. We will see more about the various sections in a WebAssembly module later.
    This will decrease the size of the WebAssembly module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--remove-producers-section`: WebAssembly modules can have a producer section.
    This section will hold information about how the file was produced or who produced
    the file. By default, producer sections are added to a generated WebAssembly module.
    With this flag, we can remove it. It saves a few more bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasm-bindgen` provides options to generate the binding file for both Node.js
    and the browser environment. Let''s see those flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--nodejs`: This generates output that only works for Node.js. No ESModules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--browser`: This generates output that only works for the browser. With ESModules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-modules`: This generates output that only works for the browser. No ESModules.
    Suitable for browsers that don''t support ESModules yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type definition files (`*.d.ts`) can be switched off by using the `--no-typescript`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have installed `wasm-bindgen`, let's take it for a spin.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Rust into WebAssembly via wasm-bindgen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a Hello World example with `wasm-bindgen`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project with Cargo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a new Rust project with all the necessary files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in your favorite editor. Open the `Cargo.toml` file to add
    `crate-type` and add the `wasm-bindgen` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the dependency under the `[dependencies]` table in the `toml` file.
    Open the `src/lib.rs` file and replace the contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `wasm_bindgen` library using `use wasm_bingen::prelude::*` and
    then annotate the function with `# [wasm_bindgen]`. The `hello` function returns
    `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the WebAssembly module, we will first run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the WebAssembly module. But this module cannot run by itself.
    WebAssembly only supports passing numbers between the native code and JavaScript.
    But we are returning a `String` here.
  prefs: []
  type: TYPE_NORMAL
- en: In order to pass any value (other than numbers), we need to create a binding
    JavaScript file. This binding file is nothing more than a translator that translates
    the `String` (and other types) into `start`, `length`, `arrayBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the binding files, we need to run the `wasm-bindgen` CLI
    tool on the generated WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We run `wasm-bindgen` and pass it to the generated `target/wasm32-unknown-unknown/debug/hello_world.wasm`
    WebAssembly module. The `--out-dir` flag tells the `wasm-bindgen` CLI tool where
    to save the generated files. Here, we are asking for the files to be generated
    in the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the files that are generated inside the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `cargo build` command generates the WebAssembly module. The `wasm-bindgen`
    CLI takes this WebAssembly module as input and generates the necessary bindings.
    The size of the binding JavaScript file is around 1.8 KB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly module (`hello_world_bg.wasm`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript binding file (`hello_world.js`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type definition file for the `WASM` (`hello_world.d.ts`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type definition file for the JavaScript (`hello_world_bg.d.ts`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript binding file is enough for us to load and run the WebAssembly
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is also a TypeScript file generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check what the binding file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The binding file imports the WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It then defines `TextDecoder`, to decode the string from the shared `ArrayBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since there are no input arguments available, there is no need for `TextEncoder`
    (that is, to encode the string from JavaScript into shared memory). `wasm-bindgen`
    will generate only the necessary things inside the binding file.
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have built-in `TextDecoder` and `TextEncoder` support. `wasm-bindgen`
    checks and uses the decoder if present; otherwise, it loads it using polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shared memory between JavaScript and the WebAssembly module need not be
    initialized every time. We can initialize it once and use it throughout the lifetime
    of the execution. We have the following two methods to load the memory once and
    use it throughout the lifetime of the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get a `String` from Rust to JavaScript. This `String` is passed via
    the shared memory. So, we can use the pointer to the offset and the length of
    the `String` to retrieve it. The following function is used for retrieving the
    `String` from the WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We define the heap at the very end. This is where we will store all the JavaScript
    variables referenceable from the WebAssembly module. The `__wbindgen_object_drop_ref`
    function is used to free up the slot occupied by the JavaScript reference count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `hello` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `hello` function is exported. We first get the pointer for the argument.
    This pointer refers to a location in the shared array buffer. Then, we call the
    `hello` function in the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are passing in a (pointer to the) argument here. But we have defined
    the function without any arguments on the Rust side. We will briefly see how `rustc`
    has rewritten the code.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get the shared memory. Note that this is a 32-bit array. We get the
    pointer in which the result is stored and the length of the output string. Note
    that these are stored successively.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will get the string from `rustptr` and `rustlen`. Once we have received
    the output, we will clear the allocated memory using `wasm.__wbindgen_free`.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what happens on the Rust side, let's use the `cargo-expand` command
    to expand the macro and see how the code is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Check [https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand)
    for how to install `cargo-expand`. It is not mandatory for the course of this
    book. But cargo-expand will help you understand what `wasm-bindgen` actually generates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal, go to the project''s base directory, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a file called `expanded.rs`. If you take
    a look in the file generated, you will see how the simple `#[wasm_bindgen]` annotation
    changes the verbose part of exposing the function. The wasm-bindgen adds all the
    necessary metadata that is required for the compiler to convert Rust code into
    a WebAssembly module. To load and run the generated files, we can use bundlers
    such as webpack or Parcel. We will see how these bundlers help in more detail
    in later chapters. For now, let''s see how to run and load the generated files:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The following setup is common and we will refer to it as the "default" webpack
    setup in future examples. Create a `webpack-config.js` file to tell webpack how
    to handle the files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard webpack configuration file with an `HTMLWebpackPlugin` plugin.
    This plugin helps us to generate a default `index.html` instead of manually creating
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `package.json` file to bundle the dependencies for running webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `index.js` file to load the binding JavaScript, which in turn loads
    the WebAssembly module generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head over to the terminal and install the npm dependencies using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `webpack-dev-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Go to the URL `http://localhost:8080` and open the developer console in the
    browser to see "Hello World" printed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to install Rust using `rustup`. `rustup` helps us
    to install, update, remove, and switch different versions of Rust. We saw how
    `rustc` works and then converted Rust into WebAssembly using `rustc`. After that,
    we explored Cargo, the package manager for Rust. Finally, we installed `wasm-bindgen`
    and compiled Rust code into a WebAssembly module using `wasm-bindgen`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore what `wasm-pack` is and how it helps to
    build and pack WebAssembly modules.
  prefs: []
  type: TYPE_NORMAL
