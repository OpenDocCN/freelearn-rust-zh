- en: '*Chapter 7*: Integrating Rust with WebAssembly'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：将 Rust 与 WebAssembly 集成'
- en: Rust is a system-level programming language. Being a system-level programming
    language, Rust provides low-level memory management and the ability to represent
    data efficiently. Thus, it provides complete control to programmers and better
    performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种系统级编程语言。作为系统级编程语言，Rust 提供了低级内存管理和高效表示数据的能力。因此，它为程序员提供了完全的控制权，并提高了性能。
- en: 'In addition to this, Rust also provides the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Rust 还提供了以下功能：
- en: '**A friendly compiler** – The Rust compiler is your companion when writing
    Rust. The compiler corrects you, guides you, and ensures that you write memory-safe
    code almost always.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**友好的编译器** – Rust 编译器是您编写 Rust 时的伴侣。编译器会纠正您，指导您，并确保您几乎总是编写内存安全的代码。'
- en: '**The ownership model** – The ownership model ensures that we do not need garbage
    collection. This guarantees thread and memory safety in Rust.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权模型** – 所有权模型确保我们不需要垃圾回收。这保证了 Rust 中的线程和内存安全。'
- en: '**Safety, speed, and concurrency** – Rust ensures safety and concurrency and
    makes you stay away from risks, crashes, and vulnerabilities.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性、速度和并发性** – Rust 确保安全性和并发性，并让您远离风险、崩溃和漏洞。'
- en: '**A modern language** – Rust provides modern language syntax and the language
    is built to provide a better developer experience.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现代语言** – Rust 提供了现代语言语法，并且语言是为了提供更好的开发者体验而构建的。'
- en: These features (along with thousands of others) ensure Rust is a general-purpose
    programming language. The highlight of the Rust language is that its compiler
    and community are always helpful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性（以及成千上万的其它特性）确保 Rust 是一种通用编程语言。Rust 语言的亮点在于其编译器和社区总是乐于助人。
- en: 'Rust provides first-class support for WebAssembly. Rust''s rich toolchain makes
    it easier to get started with WebAssembly. Rust does not need a runtime, which
    makes it a perfect candidate for WebAssembly. In this chapter, we will see how
    to install Rust and explore various ways to convert Rust into a WebAssembly module.
    We will cover the following sections in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 为 WebAssembly 提供了一级支持。Rust 丰富的工具链使得开始使用 WebAssembly 更加容易。Rust 不需要运行时，这使得它成为
    WebAssembly 的理想候选者。在本章中，我们将看到如何安装 Rust 并探索将 Rust 转换为 WebAssembly 模块的各种方法。本章将涵盖以下部分：
- en: Installing Rust
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Rust
- en: Converting Rust into WebAssembly via `rustc`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `rustc` 将 Rust 转换为 WebAssembly
- en: Converting Rust into WebAssembly via Cargo
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Cargo 将 Rust 转换为 WebAssembly
- en: Installing wasm-bindgen
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 wasm-bindgen
- en: Converting Rust into WebAssembly via `wasm-bindgen`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `wasm-bindgen` 将 Rust 转换为 WebAssembly
- en: Now let's hack into the Rust and WebAssembly world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入 Rust 和 WebAssembly 的世界。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章中存在的代码文件，网址为 [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)。
- en: Installing Rust
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rust
- en: Rust is a compiled language and its compiler is called the **Rust compiler**
    (**rustc**). Rust also has its own package manager, called **Cargo**. Cargo is
    similar to npm for Node.js. Cargo downloads package dependencies and builds, compiles,
    packs, and uploads the artifacts into crates (Rust's version of packages).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种编译型语言，其编译器被称为 **Rust 编译器**（**rustc**）。Rust 还有自己的包管理器，称为 **Cargo**。Cargo
    与 Node.js 的 npm 类似。Cargo 下载包依赖项并构建、编译、打包并将工件上传到 crate（Rust 的包版本）。
- en: The Rust language provides an easy way to install and manage Rust via `rustup`.
    `rustup` helps to install, update, and remove `rustc`, Cargo, and `rustup` itself.
    It makes it easy to install and manage various versions of Rust.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 语言提供了一个简单的方法通过 `rustup` 安装和管理 Rust。`rustup` 帮助安装、更新和删除 `rustc`、Cargo 和
    `rustup` 本身。这使得安装和管理 Rust 的各种版本变得容易。
- en: Let's install Rust using the `rustup` tool and see how we can manage Rust versions
    using `rustup`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `rustup` 工具安装 Rust，并看看我们如何使用 `rustup` 管理 Rust 版本。
- en: 'In Linux or macOS, use the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 macOS 上，请使用以下命令：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script will download and install the Rust language. Both `rustc` and Cargo
    are installed in `~/.cargo/bin` and delegate any access to the underlying toolchain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将下载并安装 Rust 语言。`rustc` 和 Cargo 都安装在 `~/.cargo/bin` 中，并委托对底层工具链的任何访问。
- en: 'For Windows, download and install the binaries from here: [https://forge.rust-lang.org/infra/other-installation-methods.html](https://forge.rust-lang.org/infra/other-installation-methods.html).
    Both `rustc` and Cargo are installed in the `users` folder.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，从这里下载并安装二进制文件：[https://forge.rust-lang.org/infra/other-installation-methods.html](https://forge.rust-lang.org/infra/other-installation-methods.html)。`rustc`
    和 Cargo 都安装在 `users` 文件夹中。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will require C++ build tools for Visual Studio 2013 or later. You can install
    them from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要 Visual Studio 2013 或更高版本的 C++ 构建工具。你可以从这里安装它们：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)。
- en: 'Once the installation is completed successfully, you can check it by running
    the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装成功完成，你可以通过运行以下命令来检查：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`rustup` is a toolchain multiplexer. It installs and manages many Rust toolchains
    and proxies them through the single set of tools installed at `.cargo/bin` in
    the home directory. Once `rustup` is installed, we can easily manage the `rustc`
    and `cargo` compilers. `rustup` also makes it easy to switch between nightly,
    stable, and beta versions of Rust.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustup` 是一个工具链多路复用器。它安装并管理许多 Rust 工具链，并通过位于主目录 `.cargo/bin` 中的单个工具集进行代理。一旦安装了
    `rustup`，我们就可以轻松地管理 `rustc` 和 `cargo` 编译器。`rustup` 还使得在夜间、稳定和测试版本之间切换 Rust 更加容易。'
- en: Rust provides WebAssembly compilation support in its stable version. We will
    also switch to the nightly build to make sure we get all the latest benefits.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在其稳定版本中提供了 WebAssembly 编译支持。我们还将切换到夜间构建，以确保我们获得所有最新的好处。
- en: 'To switch to the nightly version, we have to run the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到夜间版本，我们必须运行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will switch the default `rustc` to the nightly version. The `rustc`
    proxy in `~/.cargo/bin` will run the nightly compiler instead of the stable compiler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将默认的 `rustc` 切换到夜间版本。位于 `~/.cargo/bin` 的 `rustc` 代理将运行夜间编译器而不是稳定编译器。
- en: 'To update to the latest version of nightly, we can run the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新到最新版本的夜间版本，我们可以运行以下命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once successfully updated, we can check the current version installed by running
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功更新，我们可以通过运行以下命令来检查当前安装的版本：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rust supports WebAssembly as a first-class citizen. Thus, `rustc` is capable
    of compiling Rust code into WebAssembly modules. Let's see how to convert Rust
    into WebAssembly via `rustc`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 将 WebAssembly 作为一等公民支持。因此，`rustc` 能够将 Rust 代码编译成 WebAssembly 模块。让我们看看如何通过
    `rustc` 将 Rust 转换为 WebAssembly。
- en: Converting Rust into WebAssembly via rustc
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 rustc 将 Rust 转换为 WebAssembly
- en: Rust uses the LLVM compiler we'll create now to generate machine-native code.
    `rustc` uses LLVM's capability to convert the native code into a WebAssembly module.
    We installed Rust in the previous section; let's start converting Rust into a
    WebAssembly module using `rustc`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用我们即将创建的 LLVM 编译器来生成机器原生代码。`rustc` 使用 LLVM 的能力将原生代码转换为 WebAssembly 模块。我们在上一节中安装了
    Rust；现在让我们使用 `rustc` 开始将 Rust 转换为 WebAssembly 模块。
- en: 'We will start with Hello World:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Hello World 开始：
- en: 'Let''s create a file called `hello_world.rs`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `hello_world.rs` 的文件：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Spin up your favorite editor and start writing the Rust code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你最喜欢的编辑器并开始编写 Rust 代码：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have defined a `main` function. Similar to C, `main` is a special function
    that marks the entry point to a program after it has been compiled as an executable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个 `main` 函数。类似于 C，`main` 是一个特殊函数，它在编译成可执行文件后标记程序的入口点。
- en: '`fn` is the function keyword in Rust. `main()` is the function name.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` 是 Rust 中的函数关键字。`main()` 是函数名。'
- en: '`println!` is the macro. Macros in Rust allow us to abstract code at a syntactic
    level. A macro invocation is shorthand for an "expanded" syntactic form. This
    expansion happens early on in compilation, before any static checking.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 是一个宏。Rust 中的宏允许我们在语法级别抽象代码。宏调用是“展开”的语法形式的简写。这种展开发生在编译的早期阶段，在静态检查之前。'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Macros are an interesting feature but explaining them is beyond the scope of
    this book. You can find more information here: [https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是一个有趣的功能，但解释它们超出了本书的范围。你可以在以下位置找到更多信息：[https://doc.rust-lang.org/book/ch19-06-macros.html](https://doc.rust-lang.org/book/ch19-06-macros.html)。
- en: 'We pass in the `Hello World!` string to the `println!` macro function. We can
    compile and generate the binary by running the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `Hello World!` 字符串传递给 `println!` 宏函数。我们可以通过运行以下命令来编译并生成二进制文件：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will generate a `hello` binary. We can execute the binary and that will
    print `Hello World!`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个 `hello` 二进制文件。我们可以执行该二进制文件，它将打印 `Hello World!`：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, compile Rust into a WebAssembly module with `rustc`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `rustc` 将 Rust 编译成 WebAssembly 模块：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will generate the WebAssembly module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 WebAssembly 模块。
- en: 'Let''s run the generated code in the browser using the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在浏览器中运行生成的代码：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open your browser and head over to `http://localhost:8000`. Open the developer
    console to see `Hello World!` printed in it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并转到 `http://localhost:8000`。打开开发者控制台以查看其中打印的 `Hello World!`。
- en: To convert Rust into a WebAssembly module, we have used the `--target` flag.
    This flag instructs the compiler to compile and build the binary such that it
    runs on the provided runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Rust 转换为 WebAssembly 模块，我们使用了 `--target` 标志。此标志指示编译器编译和构建二进制文件，使其在提供的运行时上运行。
- en: We passed in `wasm32-unknown-emscripten` as a value to the `--target` flag.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `wasm32-unknown-emscripten` 作为值传递给 `--target` 标志。
- en: '`wasm32` indicates that the address space is 32 bits large. `unknown` tells
    the compiler that you don''t know the system that you are compiling to. `emscripten`
    at the end notifies the compiler that you are targeting.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm32` 表示地址空间大小为 32 位。`unknown` 告诉编译器您不知道要编译到的系统。最后的 `emscripten` 通知编译器您的目标。'
- en: So, with the `wasm32-unknown-emscripten` value, the compiler will compile on
    almost any machine but run only on the Emscripten runtime. Then, we specify the
    input file that needs to be compiled into the WebAssembly module. Finally, we
    specify the output with a `-o` flag.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `wasm32-unknown-emscripten` 值，编译器将在几乎任何机器上编译，但仅在 Emscripten 运行时上运行。然后，我们指定需要编译成
    WebAssembly 模块的需要编译的输入文件。最后，我们使用 `-o` 标志指定输出。
- en: It is important to understand what `rustc` does.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `rustc` 做了什么是很重要的。
- en: '![Figure 7.1 – Rust compilation steps'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – Rust 编译步骤'
- en: '](img/Figure_7.1_B14844.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B14844.jpg)'
- en: Figure 7.1 – Rust compilation steps
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Rust 编译步骤
- en: '`rustc` first parses the input and produces the **Abstract Syntax Tree** (**AST**).
    Once the AST is generated, the compiler then recursively resolves the paths, expanding
    macros and other references. Once the AST is completely resolved, it will be converted
    into the **High-level Intermediate Representation** (**HIR**). This intermediate
    representation is like a desugared variant of AST.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc` 首先解析输入并生成 **抽象语法树**（**AST**）。一旦生成了 AST，编译器随后递归解析路径，展开宏和其他引用。一旦 AST
    完全解析，它将被转换为 **高级中间表示**（**HIR**）。这种中间表示类似于 AST 的去糖版本。'
- en: The HIR is then analyzed for type checking. After type checking, the HIR is
    postprocessed and converted into the **Middle Intermediate Representation** (**MIR**).
    From MIR, the compiler generates the **LLVM Intermediate Representation** (**LLVM
    IR**). After that, LLVM does the required optimizations on them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对 HIR 进行类型检查。类型检查后，HIR 将进行后处理并转换为 **中间表示**（**MIR**）。从 MIR 中，编译器生成 **LLVM 中间表示**（**LLVM
    IR**）。之后，LLVM 对它们进行所需的优化。
- en: Now, with LLVM IR, it is easier to convert LLVM IR into WebAssembly modules.
    This is similar to how Emscripten converts C or C++ code into WebAssembly modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了 LLVM IR，将 LLVM IR 转换为 WebAssembly 模块变得更容易。这与 Emscripten 将 C 或 C++ 代码转换为
    WebAssembly 模块的方式类似。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are using the `wasm32-unknown-emscripten` flag here, we need `emcc`
    to be available for converting the LLVM IR generated from Rust code into a WebAssembly
    module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里使用了 `wasm32-unknown-emscripten` 标志，我们需要 `emcc` 可用，以便将 Rust 代码生成的 LLVM
    IR 转换为 WebAssembly 模块。
- en: We have seen how to use `rustc` to generate WebAssembly modules. It uses Emscripten
    behind the scenes to create them. But Rust provides another abstraction to generate
    WebAssembly modules, via Cargo.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `rustc` 生成 WebAssembly 模块。它在幕后使用 Emscripten 创建它们。但 Rust 提供了另一种抽象来生成
    WebAssembly 模块，通过 Cargo。
- en: In the next section, we will see how to convert Rust into WebAssembly using
    Cargo.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用 Cargo 将 Rust 转换为 WebAssembly。
- en: Converting Rust into WebAssembly via Cargo
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Cargo 将 Rust 转换为 WebAssembly
- en: Cargo makes it easier to create, run, download, compile, test, and run your
    project. The `cargo` command provides a wrapper that calls the `rustc` compiler
    to start the compilation. In order to create WebAssembly modules using Rust's
    toolchain, we will be using a different target, `wasm32-unknown-unknown`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 使创建、运行、下载、编译、测试和运行项目变得更容易。`cargo` 命令提供了一个包装器，它调用 `rustc` 编译器以启动编译。为了使用
    Rust 的工具链创建 WebAssembly 模块，我们将使用不同的目标，`wasm32-unknown-unknown`。
- en: The `wasm32-unknown-unknown` target adds zero runtime and toolchain footprint.
    `wasm32` makes the compiler assume that only the `wasm32` instruction set is present.
    The first `unknown` in `unknown-unknown` indicates the code can compile on any
    machine and the second indicates the code can run on any machine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm32-unknown-unknown`目标添加了零运行时和工具链占用。`wasm32`使编译器假设只有`wasm32`指令集存在。`unknown-unknown`中的第一个`unknown`表示代码可以在任何机器上编译，第二个表示代码可以在任何机器上运行。'
- en: 'To see it in action, let''s create a new project with Cargo:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到它的实际效果，让我们使用Cargo创建一个新的项目：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A new project called `fib_wasm` is created. The new option creates a Rust project.
    The `--lib` flag informs Cargo to create a new library project rather than the
    default binary project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个名为`fib_wasm`的新项目。新选项创建一个Rust项目。`--lib`标志通知Cargo创建一个新的库项目而不是默认的二进制项目。
- en: The binary project will produce the executable binary. The library project will
    create the library module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制项目将生成可执行的二进制文件。库项目将创建库模块。
- en: 'Spin up your favorite text editor and replace the contents of `src/lib.rs`
    with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您最喜欢的文本编辑器，并将`src/lib.rs`文件的内容替换为以下内容：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`#[no_mangle]` is a kind of annotation. This annotation informs the compiler
    not to mangle the names when generating the library.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[no_mangle]`是一种注释。这种注释通知编译器在生成库时不要更改名称。'
- en: Then, we define the `add` function. The `add` function takes in two parameters,
    `x` and `y`. We define their types with `i32` following the variable and a colon
    (`:`). Finally, we define their return type using `-> i32`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`add`函数。`add`函数接受两个参数，`x`和`y`。我们使用`i32`在变量后跟一个冒号（`:`）来定义它们的类型。最后，我们使用`->
    i32`定义它们的返回类型。
- en: The function body has just `x + y`. Note, in Rust we do not need `return` keyword
    and `;` at the end of the last statement, this shorts to return.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体只有`x + y`。注意，在Rust中我们不需要在最后一条语句的末尾使用`return`关键字和`;`，这可以简写为返回。
- en: Cargo also generates `Cargo.toml`. This file holds all the meta-information
    about the project, how to compile the Rust code, and their dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo还会生成`Cargo.toml`文件。此文件包含有关项目的所有元信息，如何编译Rust代码以及它们的依赖项。
- en: 'The `Cargo.toml` file looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`文件看起来像这样：'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It defines the package name, version, authors, and edition of Rust we are using.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了包名、版本、作者以及我们正在使用的Rust版本。
- en: Here, we have to instruct the compiler what type of crate we are compiling.
    We can specify it under the `[lib]` segment and with the `crate-type` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须指导编译器我们正在编译哪种类型的crate。我们可以在`[lib]`部分和`crate-type`属性中指定它。
- en: 'Open `Cargo.toml` and append the `crate-type` information inside:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Cargo.toml`文件，并在其中添加`crate-type`信息：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`cdylib` here specifies a dynamic system library will be produced. This dynamic
    system library is used when the library has to be loaded from another language.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdylib`在这里指定将生成一个动态系统库。当库需要从其他语言加载时，将使用此动态系统库。'
- en: 'Let''s compile Rust into WebAssembly modules:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译Rust到WebAssembly模块：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will invoke `rustc` with the specified target. That will generate the WebAssembly
    module inside `/target/wasm32-unknown-unknown/`. Now, in order to run the WebAssembly
    module on the browser, let's manually create the HTML file and load it using JavaScript.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用`rustc`并指定目标。这将生成`/target/wasm32-unknown-unknown/`中的WebAssembly模块。现在，为了在浏览器上运行WebAssembly模块，让我们手动创建HTML文件并使用JavaScript加载它。
- en: 'Let''s create an HTML file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个HTML文件：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following content to the file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到文件中：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We defined the script inside the `<script>` tag. In HTML, we define JavaScript
    inside the `<script>` tag. We have added the `async` keyword. The `async` keyword
    specifies the function is asynchronous.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`<script>`标签内定义了脚本。在HTML中，我们在`<script>`标签内定义JavaScript。我们添加了`async`关键字。`async`关键字指定函数是异步的。
- en: First, we fetch the WebAssembly module. The WebAssembly module is generated
    in the `target/wasm32-unknown-unknown/debug/` folder with the same name as the
    package name defined in `Cargo.toml`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取WebAssembly模块。WebAssembly模块在`target/wasm32-unknown-unknown/debug/`文件夹中生成，其名称与`Cargo.toml`中定义的包名相同。
- en: The `await` keyword ensures the execution is awaited until we fetch the entire
    WebAssembly module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`关键字确保执行被挂起，直到我们获取整个WebAssembly模块。'
- en: We then convert the collected bytes (from the fetch call) using `bytes.arrayBuffer()`.
    The `response` object will now have the WebAssembly module inside `ArrayBuffer`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`bytes.arrayBuffer()`将收集的字节（来自fetch调用）进行转换。现在`response`对象将包含在`ArrayBuffer`中的WebAssembly模块。
- en: We then instantiate the bytes array using the `WebAssembly.instantiate` function.
    The `result` object contains the entire WebAssembly module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `WebAssembly.instantiate` 函数实例化字节数组。`result` 对象包含整个 WebAssembly 模块。
- en: The WebAssembly module `result` contains the `instance` property. The instance
    has the `exports` property. The `exports` property holds all the functions exported
    by the WebAssembly module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模块 `result` 包含 `instance` 属性。该实例具有 `exports` 属性。`exports` 属性包含 WebAssembly
    模块导出的所有函数。
- en: Since we added `#[no_mangle]`, the exported function name is not changed. Hence,
    the `exports` property has the `add` function defined in it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了 `#[no_mangle]`，导出的函数名称没有改变。因此，`exports` 属性中定义了 `add` 函数。
- en: We have used async-await here to make the syntax more elegant and contextually
    easier to understand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了 async-await 来使语法更加优雅，并使上下文更容易理解。
- en: As expected, the preceding code will give an output of `13`. You can check the
    output in the browser console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，前面的代码将输出 `13`。您可以在浏览器控制台中检查输出。
- en: 'Here, the `cargo build` command invokes `rustc` and compiles the Rust code
    into MIR and then into LLVM IR. The generated LLVM IR is then converted into a
    WebAssembly module. Let''s make this function a bit more complicated. We can create
    a Fibonacci number generator with Rust and run the WebAssembly Module on the browser:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cargo build` 命令调用 `rustc` 并将 Rust 代码编译成 MIR，然后编译成 LLVM IR。生成的 LLVM IR 然后转换为
    WebAssembly 模块。让我们使这个函数更复杂一些。我们可以使用 Rust 创建一个斐波那契数生成器并在浏览器上运行 WebAssembly 模块：
- en: 'Open `src/lib.rs` and replace everything with the following content:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src/lib.rs` 并将其替换为以下内容：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Build it using `cargo build --target wasm32-unknown-unknown`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cargo build --target wasm32-unknown-unknown` 构建。
- en: 'Then, replace `index.html` such that we call the Fibonacci instead of the `add`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `index.html` 替换为调用斐波那契而不是 `add`：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, spin up the HTML server and check the browser's console for the Fibonacci
    value.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动 HTML 服务器并检查浏览器的控制台以获取斐波那契值。
- en: So far, we have seen simple examples. But how can we pass functions and classes
    from JavaScript into WebAssembly and the other way around? In order to do more
    advanced bindings, Rust provides us with `wasm-bindgen`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了简单的示例。但如何将函数和类从 JavaScript 传递到 WebAssembly，反之亦然？为了进行更高级的绑定，Rust
    为我们提供了 `wasm-bindgen`。
- en: Installing wasm-bindgen
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 wasm-bindgen
- en: '`wasm-bindgen` is used to bind entities from Rust into JavaScript and vice
    versa.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 用于将 Rust 中的实体绑定到 JavaScript，反之亦然。'
- en: '`wasm-bindgen` makes it more natural to import exported entities from Rust
    into JavaScript. JavaScript developers will find that `wasm-bindgen`''s use of
    WebAssembly is similar to JavaScript.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 使得从 Rust 导出实体到 JavaScript 更加自然。JavaScript 开发者会发现 `wasm-bindgen`
    对 WebAssembly 的使用与 JavaScript 类似。'
- en: This enables the use of richer and easier APIs while converting Rust into a
    WebAssembly module. `wasm-bindgen` uses these features and provides a simple API
    to use. It ensures that there is high-level interaction happening between wasm
    modules and JavaScript.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在将 Rust 转换为 WebAssembly 模块时可以使用更丰富和更简单的 API。`wasm-bindgen` 使用这些功能并提供了一个简单的
    API 以供使用。它确保 wasm 模块和 JavaScript 之间发生高级交互。
- en: '`wasm-bindgen` provides a channel between JavaScript and WebAssembly to communicate
    something other than numbers, such as objects, strings, and arrays.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 提供了 JavaScript 和 WebAssembly 之间的通道，用于传递除了数字之外的内容，例如对象、字符串和数组。'
- en: 'To install `wasm-bindgen-cli`, use the following `cargo` command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `wasm-bindgen-cli`，请使用以下 `cargo` 命令：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once successfully installed, let''s run the `wasm-bindgen` CLI:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，让我们运行 `wasm-bindgen` CLI：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's take a look at the various options `wasm-bindgen` supports.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `wasm-bindgen` 支持的各种选项。
- en: 'To generate the file in a particular directory and with a particular name,
    the tool has `--out-dir` and `--out-name`, respectively. To reduce or optimize
    the generated WebAssembly module size, `wasm-bindgen` has the following flags:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定目录和特定名称下生成文件，该工具分别有 `--out-dir` 和 `--out-name`。为了减少或优化生成的 WebAssembly 模块大小，`wasm-bindgen`
    有以下标志：
- en: '`--debug`: The `--debug` option includes extra debugging information in the
    generated WebAssembly module. This will increase the size of the WebAssembly module
    but it is useful in development.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--debug`：`--debug` 选项在生成的 WebAssembly 模块中包含额外的调试信息。这将增加 WebAssembly 模块的大小，但在开发中很有用。'
- en: '`--keep-debug`: This WebAssembly module may or may not have custom sections.
    These custom sections can be used to hold the debugging information. These custom
    sections will be helpful while debugging the application (such as in browser developer
    tools). This will increase the size of the WebAssembly module. This is useful
    in development.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--keep-debug`: 这个 WebAssembly 模块可能包含自定义部分，也可能不包含。这些自定义部分可以用来存储调试信息。这些自定义部分在调试应用程序时（例如在浏览器开发者工具中）将非常有用。这将增加
    WebAssembly 模块的大小。这在开发中很有用。'
- en: '`--no-demangle`: This flag tells `wasm-bindgen` not to demangle the Rust symbol
    names. Demangling allows the end user to use the same name that they have defined
    in the Rust file.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-demangle`: 这个标志告诉 `wasm-bindgen` 不要对 Rust 符号名称进行去混淆。去混淆允许最终用户使用他们在 Rust
    文件中定义的相同名称。'
- en: '`--remove-name-section`: This will remove the debugging name section of the
    file. We will see more about the various sections in a WebAssembly module later.
    This will decrease the size of the WebAssembly module.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--remove-name-section`: 这将移除文件的调试名称部分。我们将在稍后了解更多关于 WebAssembly 模块中各种部分的内容。这将减小
    WebAssembly 模块的大小。'
- en: '`--remove-producers-section`: WebAssembly modules can have a producer section.
    This section will hold information about how the file was produced or who produced
    the file. By default, producer sections are added to a generated WebAssembly module.
    With this flag, we can remove it. It saves a few more bytes.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--remove-producers-section`: WebAssembly 模块可以有一个生产者部分。这个部分将包含有关文件是如何生成或由谁生成的信息。默认情况下，生产者部分会被添加到生成的
    WebAssembly 模块中。使用这个标志，我们可以移除它。这可以节省更多字节。'
- en: '`wasm-bindgen` provides options to generate the binding file for both Node.js
    and the browser environment. Let''s see those flags:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 为 Node.js 和浏览器环境提供生成绑定文件的选项。让我们看看那些标志：'
- en: '`--nodejs`: This generates output that only works for Node.js. No ESModules.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--nodejs`: 这将生成仅适用于 Node.js 的输出。不使用 ES 模块。'
- en: '`--browser`: This generates output that only works for the browser. With ESModules.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--browser`: 这将生成仅适用于浏览器的输出。使用 ES 模块。'
- en: '`--no-modules`: This generates output that only works for the browser. No ESModules.
    Suitable for browsers that don''t support ESModules yet.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-modules`: 这将生成仅适用于浏览器的输出。不使用 ES 模块。适用于尚不支持 ES 模块的浏览器。'
- en: The type definition files (`*.d.ts`) can be switched off by using the `--no-typescript`
    flag.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `--no-typescript` 标志关闭类型定义文件（`*.d.ts`）。
- en: Now we have installed `wasm-bindgen`, let's take it for a spin.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 `wasm-bindgen`，让我们试一试。
- en: Converting Rust into WebAssembly via wasm-bindgen
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 wasm-bindgen 将 Rust 转换为 WebAssembly
- en: 'Let''s start with a Hello World example with `wasm-bindgen`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 `wasm-bindgen` 的 Hello World 示例开始：
- en: 'Create a new project with Cargo:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cargo 创建一个新项目：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create a new Rust project with all the necessary files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 Rust 项目，包含所有必要的文件。
- en: 'Open the project in your favorite editor. Open the `Cargo.toml` file to add
    `crate-type` and add the `wasm-bindgen` dependency:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的编辑器中打开项目。打开 `Cargo.toml` 文件以添加 `crate-type` 并添加 `wasm-bindgen` 依赖项：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We define the dependency under the `[dependencies]` table in the `toml` file.
    Open the `src/lib.rs` file and replace the contents with the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `toml` 文件中的 `[dependencies]` 表下定义依赖项。打开 `src/lib.rs` 文件，将其内容替换为以下内容：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We import the `wasm_bindgen` library using `use wasm_bingen::prelude::*` and
    then annotate the function with `# [wasm_bindgen]`. The `hello` function returns
    `String`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `use wasm_bingen::prelude::*` 导入 `wasm_bindgen` 库，然后使用 `# [wasm_bindgen]`
    注解函数。`hello` 函数返回 `String`。
- en: 'To generate the WebAssembly module, we will first run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 WebAssembly 模块，我们首先运行以下命令：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will generate the WebAssembly module. But this module cannot run by itself.
    WebAssembly only supports passing numbers between the native code and JavaScript.
    But we are returning a `String` here.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 WebAssembly 模块。但这个模块不能单独运行。WebAssembly 只支持在本地代码和 JavaScript 之间传递数字。但我们在这里返回的是一个
    `String`。
- en: In order to pass any value (other than numbers), we need to create a binding
    JavaScript file. This binding file is nothing more than a translator that translates
    the `String` (and other types) into `start`, `length`, `arrayBuffer`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传递任何值（除了数字），我们需要创建一个绑定 JavaScript 文件。这个绑定文件不过是一个翻译器，它将 `String`（和其他类型）转换为
    `start`、`length`、`arrayBuffer`。
- en: 'In order to generate the binding files, we need to run the `wasm-bindgen` CLI
    tool on the generated WebAssembly module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成绑定文件，我们需要在生成的 WebAssembly 模块上运行 `wasm-bindgen` CLI 工具：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We run `wasm-bindgen` and pass it to the generated `target/wasm32-unknown-unknown/debug/hello_world.wasm`
    WebAssembly module. The `--out-dir` flag tells the `wasm-bindgen` CLI tool where
    to save the generated files. Here, we are asking for the files to be generated
    in the current folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 `wasm-bindgen` 并将其传递给生成的 `target/wasm32-unknown-unknown/debug/hello_world.wasm`
    WebAssembly 模块。`--out-dir` 标志告诉 `wasm-bindgen` CLI 工具在哪里保存生成的文件。在这里，我们要求在当前文件夹中生成文件。
- en: 'We can see the files that are generated inside the folder:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到文件夹内生成的文件：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `cargo build` command generates the WebAssembly module. The `wasm-bindgen`
    CLI takes this WebAssembly module as input and generates the necessary bindings.
    The size of the binding JavaScript file is around 1.8 KB.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo build` 命令生成 WebAssembly 模块。`wasm-bindgen` CLI 将此 WebAssembly 模块作为输入并生成必要的绑定。绑定
    JavaScript 文件的大小约为 1.8 KB。'
- en: 'The generated files are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件如下：
- en: The WebAssembly module (`hello_world_bg.wasm`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 模块（`hello_world_bg.wasm`）
- en: The JavaScript binding file (`hello_world.js`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 绑定文件（`hello_world.js`）
- en: The type definition file for the `WASM` (`hello_world.d.ts`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WASM 的类型定义文件（`hello_world.d.ts`）
- en: The type definition file for the JavaScript (`hello_world_bg.d.ts`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的类型定义文件（`hello_world_bg.d.ts`）
- en: The JavaScript binding file is enough for us to load and run the WebAssembly
    module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 绑定文件就足够我们加载和运行 WebAssembly 模块了。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is also a TypeScript file generated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还生成了一个 TypeScript 文件。
- en: 'Let''s now check what the binding file contains:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查绑定文件包含的内容：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The binding file imports the WebAssembly module:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定文件导入了 WebAssembly 模块：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It then defines `TextDecoder`, to decode the string from the shared `ArrayBuffer`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它定义了 `TextDecoder`，用于从共享的 `ArrayBuffer` 解码字符串。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since there are no input arguments available, there is no need for `TextEncoder`
    (that is, to encode the string from JavaScript into shared memory). `wasm-bindgen`
    will generate only the necessary things inside the binding file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有可用的输入参数，不需要 `TextEncoder`（即从 JavaScript 编码字符串到共享内存）。`wasm-bindgen` 将只在绑定文件中生成必要的东西。
- en: Modern browsers have built-in `TextDecoder` and `TextEncoder` support. `wasm-bindgen`
    checks and uses the decoder if present; otherwise, it loads it using polyfill.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器内置了 `TextDecoder` 和 `TextEncoder` 支持。`wasm-bindgen` 会检查是否存在解码器，如果存在则使用它；否则，使用
    polyfill 加载它。
- en: 'The shared memory between JavaScript and the WebAssembly module need not be
    initialized every time. We can initialize it once and use it throughout the lifetime
    of the execution. We have the following two methods to load the memory once and
    use it throughout the lifetime of the execution:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 和 WebAssembly 模块之间的共享内存不需要每次都初始化。我们可以初始化一次，并在执行期间一直使用它。我们有以下两种方法来加载内存一次并在执行期间使用它：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we get a `String` from Rust to JavaScript. This `String` is passed via
    the shared memory. So, we can use the pointer to the offset and the length of
    the `String` to retrieve it. The following function is used for retrieving the
    `String` from the WebAssembly module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从 Rust 获取一个 `String` 到 JavaScript。这个 `String` 通过共享内存传递。因此，我们可以使用偏移量的指针和
    `String` 的长度来检索它。以下函数用于从 WebAssembly 模块中检索 `String`：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We define the heap at the very end. This is where we will store all the JavaScript
    variables referenceable from the WebAssembly module. The `__wbindgen_object_drop_ref`
    function is used to free up the slot occupied by the JavaScript reference count.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后定义堆。这是我们将在其中存储所有从 WebAssembly 模块可引用的 JavaScript 变量的地方。`__wbindgen_object_drop_ref`
    函数用于释放由 JavaScript 引用计数器占用的槽位。
- en: 'Finally, we have the `hello` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `hello` 函数：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `hello` function is exported. We first get the pointer for the argument.
    This pointer refers to a location in the shared array buffer. Then, we call the
    `hello` function in the WebAssembly module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 函数被导出。我们首先获取参数的指针。这个指针指向共享数组缓冲区中的一个位置。然后，我们在 WebAssembly 模块中调用 `hello`
    函数。'
- en: Note that we are passing in a (pointer to the) argument here. But we have defined
    the function without any arguments on the Rust side. We will briefly see how `rustc`
    has rewritten the code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里传递了一个（指向）参数。但在 Rust 端，我们没有为该函数定义任何参数。我们将简要地看看 `rustc` 如何重写代码。
- en: Then, we get the shared memory. Note that this is a 32-bit array. We get the
    pointer in which the result is stored and the length of the output string. Note
    that these are stored successively.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取共享内存。注意，这是一个 32 位数组。我们获取存储结果的指针和输出字符串的长度。注意，这些是连续存储的。
- en: Finally, we will get the string from `rustptr` and `rustlen`. Once we have received
    the output, we will clear the allocated memory using `wasm.__wbindgen_free`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从`rustptr`和`rustlen`获取字符串。一旦我们收到输出，我们将使用`wasm.__wbindgen_free`清除分配的内存。
- en: To understand what happens on the Rust side, let's use the `cargo-expand` command
    to expand the macro and see how the code is generated.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Rust端发生的情况，让我们使用`cargo-expand`命令展开宏，看看代码是如何生成的。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Check [https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand)
    for how to install `cargo-expand`. It is not mandatory for the course of this
    book. But cargo-expand will help you understand what `wasm-bindgen` actually generates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 检查[https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand)了解如何安装`cargo-expand`。这不是本书课程的强制性要求。但`cargo-expand`将帮助您理解`wasm-bindgen`实际上生成了什么。
- en: 'Open your terminal, go to the project''s base directory, and run the following
    command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的终端，进入项目的根目录，并运行以下命令：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding command will create a file called `expanded.rs`. If you take
    a look in the file generated, you will see how the simple `#[wasm_bindgen]` annotation
    changes the verbose part of exposing the function. The wasm-bindgen adds all the
    necessary metadata that is required for the compiler to convert Rust code into
    a WebAssembly module. To load and run the generated files, we can use bundlers
    such as webpack or Parcel. We will see how these bundlers help in more detail
    in later chapters. For now, let''s see how to run and load the generated files:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`expanded.rs`的文件。如果您查看生成的文件，您将看到简单的`#[wasm_bindgen]`注解是如何改变函数暴露的详细部分的。wasm-bindgen添加了编译器将Rust代码转换为WebAssembly模块所需的所有必要元数据。为了加载和运行生成的文件，我们可以使用webpack或Parcel等打包器。我们将在后面的章节中更详细地了解这些打包器是如何帮助的。现在，让我们看看如何运行和加载生成的文件：
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following setup is common and we will refer to it as the "default" webpack
    setup in future examples. Create a `webpack-config.js` file to tell webpack how
    to handle the files.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置是常见的，我们将在未来的示例中将其称为“默认”webpack设置。创建一个`webpack-config.js`文件来告诉webpack如何处理文件。
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a standard webpack configuration file with an `HTMLWebpackPlugin` plugin.
    This plugin helps us to generate a default `index.html` instead of manually creating
    it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的webpack配置文件，包含一个`HTMLWebpackPlugin`插件。此插件帮助我们生成默认的`index.html`，而不是手动创建它。
- en: 'Let''s add a `package.json` file to bundle the dependencies for running webpack:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`package.json`文件来打包运行webpack所需的依赖项：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create an `index.js` file to load the binding JavaScript, which in turn loads
    the WebAssembly module generated:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`index.js`文件来加载绑定JavaScript，它反过来加载生成的WebAssembly模块：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, head over to the terminal and install the npm dependencies using the following
    command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到终端并使用以下命令安装npm依赖项：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run `webpack-dev-server`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`webpack-dev-server`：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Go to the URL `http://localhost:8080` and open the developer console in the
    browser to see "Hello World" printed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前往URL `http://localhost:8080`，并在浏览器中打开开发者控制台以查看打印的“Hello World”。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to install Rust using `rustup`. `rustup` helps us
    to install, update, remove, and switch different versions of Rust. We saw how
    `rustc` works and then converted Rust into WebAssembly using `rustc`. After that,
    we explored Cargo, the package manager for Rust. Finally, we installed `wasm-bindgen`
    and compiled Rust code into a WebAssembly module using `wasm-bindgen`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用`rustup`安装Rust。`rustup`帮助我们安装、更新、删除和切换Rust的不同版本。我们看到了`rustc`是如何工作的，然后使用`rustc`将Rust转换为WebAssembly。之后，我们探讨了Rust的包管理器Cargo。最后，我们安装了`wasm-bindgen`，并使用`wasm-bindgen`将Rust代码编译成WebAssembly模块。
- en: In the next chapter, we will explore what `wasm-pack` is and how it helps to
    build and pack WebAssembly modules.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨`wasm-pack`是什么以及它是如何帮助构建和打包WebAssembly模块的。
