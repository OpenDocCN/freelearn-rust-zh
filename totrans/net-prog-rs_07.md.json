["```rs\ntrait Future {\n    type Item;\n    type Error;\n    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;\n    ...\n}\n```", "```rs\ntype Poll<T, E> = Result<Async<T>, E>;\n```", "```rs\npub enum Async<T> {\n    Ready(T),\n    NotReady,\n}\n```", "```rs\n$ cargo new --bin futures-example\n```", "```rs\n[package]\nname = \"futures-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nfutures = \"0.1.17\"\nfutures-cpupool = \"0.1.7\"\n```", "```rs\n// ch7/futures-example/src/main.rs\n\n#![feature(conservative_impl_trait)]\nextern crate futures;\nextern crate futures_cpupool;\n\nuse std::io;\nuse futures::Future;\nuse futures_cpupool::CpuPool;\n\n// This implementation returns a boxed future\nfn check_prime_boxed(n: u64) -> Box<Future<Item = bool, Error = io::Error>> {\n    for i in 2..n {\n        if n % i == 0 { return Box::new(futures::future::ok(false)); }\n    }\n    Box::new(futures::future::ok(true))\n}\n\n// This returns a future using impl trait\nfn check_prime_impl_trait(n: u64) -> impl Future<Item = bool, Error = io::Error> {\n        for i in 2..n {\n        if n % i == 0 { return futures::future::ok(false); }\n    }\n    futures::future::ok(true)\n}\n\n// This does not return a future\nfn check_prime(n: u64) -> bool {\n    for i in 2..n {\n        if n % i == 0 { return false }\n    }\n    true\n}\n\nfn main() {\n    let input: u64 = 58466453;\n    println!(\"Right before first call\");\n    let res_one = check_prime_boxed(input);\n    println!(\"Called check_prime_boxed\");\n    let res_two = check_prime_impl_trait(input);\n    println!(\"Called check_prime_impl_trait\");\n    println!(\"Results are {} and {}\", res_one.wait().unwrap(),\n    res_two.wait().unwrap());\n\n    let thread_pool = CpuPool::new(4);\n    let res_three = thread_pool.spawn_fn(move || {\n        let temp = check_prime(input);\n        let result: Result<bool, ()> = Ok(temp);\n        result\n    });\n    println!(\"Called check_prime in another thread\");\n    println!(\"Result from the last call: {}\", res_three.wait().unwrap());\n}\n```", "```rs\n$ cargo run\n   Compiling futures-example v0.1.0 (file:///src/ch7/futures-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.77 secs\n     Running `target/debug/futures-example`\nRight before first call\nCalled check_prime_boxed\nCalled check_prime_impl_trait\nResults are true and true\nCalled check_prime in another thread\nResult from the last call: true\n```", "```rs\n$ cargo new --bin futures-chaining\n```", "```rs\n[package]\nname = \"futures-chaining\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\ntokio-timer = \"0.1.2\"\nfutures = \"0.1.17\"\nfutures-cpupool = \"0.1.7\"\nrand = \"0.3.18\"\n```", "```rs\n// ch7/futures-chaining/src/main.rs\n\nextern crate futures;\nextern crate futures_cpupool;\nextern crate tokio_timer;\nextern crate rand;\n\nuse futures::future::select_ok;\nuse std::time::Duration;\n\nuse futures::Future;\nuse futures_cpupool::CpuPool;\nuse tokio_timer::Timer;\nuse std::thread;\nuse rand::{thread_rng, Rng};\n\n// First player, identified by the string \"player_one\"\nfn player_one() -> &'static str {\n    let d = thread_rng().gen_range::<u64>(1, 5);\n    thread::sleep(Duration::from_secs(d));\n    \"player_one\"\n}\n\n// Second player, identified by the string \"player_two\"\nfn player_two() -> &'static str {\n    let d = thread_rng().gen_range::<u64>(1, 5);\n    thread::sleep(Duration::from_secs(d));\n    \"player_two\"\n}\n\nfn main() {\n    let pool = CpuPool::new_num_cpus();\n    let timer = Timer::default();\n\n    // Defining the timeout future\n    let timeout = timer.sleep(Duration::from_secs(3))\n        .then(|_| Err(()));\n\n    // Running the first player in the pool\n    let one = pool.spawn_fn(|| {\n        Ok(player_one())\n    });\n\n    // Running second player in the pool\n    let two = pool.spawn_fn(|| {\n        Ok(player_two())\n    });\n\n    let tasks = vec![one, two];\n    // Combining the players with the timeout future\n    // and filtering out result\n    let winner = select_ok(tasks).select(timeout).map(|(result, _)|\n    result);\n    let result = winner.wait().ok();\n    match result {\n        Some((\"player_one\", _)) => println!(\"Player one won\"),\n        Some((\"player_two\", _)) => println!(\"Player two won\"),\n        Some((_, _)) | None => println!(\"Timed out\"),\n    }\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-chaining`\nPlayer two won\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-chaining`\nPlayer one won\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-chaining`\nTimed out\n```", "```rs\ntrait Stream {\n    type Item;\n    type Error;\n    fn poll(& mut self) -> Poll<Option<Self::Item>, Self::Error>;\n    ...\n}\n```", "```rs\n$ cargo new --bin streams\n```", "```rs\n[package]\nname = \"streams\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nfutures = \"0.1.17\"\nrand = \"0.3.18\"\n```", "```rs\n// ch7/streams/src/main.rs\n\nextern crate futures;\nextern crate rand;\n\nuse std::{io, thread};\nuse std::time::Duration;\nuse futures::stream::Stream;\nuse futures::{Poll, Async};\nuse rand::{thread_rng, Rng};\nuse futures::Future;\n\n// This struct holds the current state and the end condition\n// for the stream\n#[derive(Debug)]\nstruct CollatzStream {\n    current: u64,\n    end: u64,\n}\n\n// A constructor to initialize the struct with defaults\nimpl CollatzStream {\n    fn new(start: u64) -> CollatzStream {\n        CollatzStream {\n            current: start,\n            end: 1\n        }\n    }\n}\n\n// Implementation of the Stream trait for our struct\nimpl Stream for CollatzStream {\n    type Item = u64;\n    type Error = io::Error;\n    fn poll(&mut self) -> Poll<Option<Self::Item>, io::Error> {\n        let d = thread_rng().gen_range::<u64>(1, 5);\n        thread::sleep(Duration::from_secs(d));\n        if self.current % 2 == 0 {\n            self.current = self.current / 2;\n        } else {\n            self.current = 3 * self.current + 1;\n        }\n        if self.current == self.end {\n            Ok(Async::Ready(None))\n        } else {\n            Ok(Async::Ready(Some(self.current)))\n        }\n    }\n}\n\nfn main() {\n    let stream = CollatzStream::new(10);\n    let f = stream.for_each(|num| {\n        println!(\"{}\", num);\n        Ok(())\n    });\n    f.wait().ok();\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/streams`\n5\n16\n8\n4\n2\n```", "```rs\n$ cargo new --bin futures-ping-pong\n```", "```rs\n[package]\nname = \"futures-ping-pong\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nfutures = \"0.1\"\ntokio-core = \"0.1\"\nrand = \"0.3.18\"\n```", "```rs\n// ch7/futures-ping-pong/src/main\n\nextern crate futures;\nextern crate rand;\nextern crate tokio_core;\n\nuse std::thread;\nuse std::fmt::Debug;\nuse std::time::Duration;\nuse futures::Future;\nuse rand::{thread_rng, Rng};\n\nuse futures::sync::mpsc;\nuse futures::{Sink, Stream};\nuse futures::sync::mpsc::Receiver;\n\n// Randomly selects a sleep duration between 1 and 5 seconds. Then\n// randomly returns either \"ping\" or \"pong\"\nfn sender() -> &'static str {\n    let mut d = thread_rng();\n    thread::sleep(Duration::from_secs(d.gen_range::<u64>(1, 5)));\n    d.choose(&[\"ping\", \"pong\"]).unwrap()\n}\n\n// Receives input on the given channel and prints each item\nfn receiver<T: Debug>(recv: Receiver<T>) {\n    let f = recv.for_each(|item| {\n        println!(\"{:?}\", item);\n        Ok(())\n    });\n    f.wait().ok();\n}\n\nfn main() {\n    let (tx, rx) = mpsc::channel(100);\n    let h1 = thread::spawn(|| {\n        tx.send(sender()).wait().ok();\n    });\n    let h2 = thread::spawn(|| {\n        receiver::<&str>(rx);\n    });\n    h1.join().unwrap();\n    h2.join().unwrap();\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-ping-pong`\n\"ping\"\n```", "```rs\n$ cargo new --bin future-bilock\n```", "```rs\n// ch7/future-bilock/src/main.rs\n\nextern crate futures;\nextern crate rand;\n\nuse std::thread;\nuse std::fmt::Debug;\nuse std::time::Duration;\nuse futures::{Future, Async};\nuse rand::{thread_rng, Rng};\n\nuse futures::sync::{mpsc, BiLock};\nuse futures::{Sink, Stream};\nuse futures::sync::mpsc::Receiver;\n\n// Increments the shared counter if it can acquire a lock, then\n// sleeps for a random duration between 1 and 5 seconds, then\n// randomly returns either \"ping\" or \"pong\"\nfn sender(send: &BiLock<u64>) -> &'static str {\n    match send.poll_lock() {\n        Async::Ready(mut lock) => *lock += 1,\n        Async::NotReady => ()\n    }\n    let mut d = thread_rng();\n    thread::sleep(Duration::from_secs(d.gen_range::<u64>(1, 5)));\n    d.choose(&[\"ping\", \"pong\"]).unwrap()\n}\n\n// Tries to acquire a lock on the shared variable and prints it's\n// value if it got the lock. Then prints each item in the given\n// stream\nfn receiver<T: Debug>(recv: Receiver<T>, recv_lock: BiLock<u64>) {\n    match recv_lock.poll_lock() {\n        Async::Ready(lock) => println!(\"Value of lock {}\", *lock),\n        Async::NotReady => ()\n    }\n    let f = recv.for_each(|item| {\n        println!(\"{:?}\", item);\n        Ok(())\n    });\n    f.wait().ok();\n}\n\nfn main() {\n    let counter = 0;\n    let (send, recv) = BiLock::new(counter);\n    let (tx, rx) = mpsc::channel(100);\n    let h1 = thread::spawn(move || {\n        tx.send(sender(&send)).wait().ok();\n    });\n    let h2 = thread::spawn(|| {\n        receiver::<&str>(rx, recv);\n    });\n    h1.join().unwrap();\n    h2.join().unwrap();\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-bilock`\nthread '<unnamed>' panicked at 'no Task is currently running', libcore/option.rs:917:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Any', libcore/result.rs:945:5\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/futures-bilock`\nValue of lock 1\n\"pong\"\n```", "```rs\n$ cargo new --bin futures-loop\n```", "```rs\n[package]\nname = \"futures-loop\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nfutures = \"0.1\"\ntokio-core = \"0.1\"\n```", "```rs\n// ch7/futures-loop/src/main.rs\n\nextern crate futures;\nextern crate tokio_core;\n\nuse std::io;\nuse std::io::BufRead;\nuse futures::Future;\nuse tokio_core::reactor::Core;\n\nfn check_prime_boxed(n: u64) -> Box<Future<Item = bool, Error = io::Error>> {\n    for i in 2..n {\n        if n % i == 0 {\n            return Box::new(futures::future::ok(false));\n        }\n    }\n    Box::new(futures::future::ok(true))\n}\n\nfn main() {\n    let mut core = Core::new().expect(\"Could not create event loop\");\n    let stdin = io::stdin();\n\n    loop {\n        let mut line = String::new();\n        stdin\n            .lock()\n            .read_line(&mut line)\n            .expect(\"Could not read from stdin\");\n        let input = line.trim()\n            .parse::<u64>()\n            .expect(\"Could not parse input as u64\");\n        let result = core.run(check_prime_boxed(input))\n            .expect(\"Could not run future\");\n        println!(\"{}\", result);\n    }\n}\n```", "```rs\n$ cargo run\n12\nfalse\n13\ntrue\n991\ntrue\n```", "```rs\n$ cargo new --bin collatz-proto\n```", "```rs\n[package]\nname = \"collatz-proto\"\nversion = \"0.1.0\"\nauthors = [\"Foo<foo@bar.com>\"]\n\n[dependencies]\nbytes = \"0.4\"\nfutures = \"0.1\"\ntokio-io = \"0.1\"\ntokio-core = \"0.1\"\ntokio-proto = \"0.1\"\ntokio-service = \"0.1\"\n```", "```rs\n// ch7/collatz-proto/src/main.rs\n\nextern crate bytes;\nextern crate futures;\nextern crate tokio_io;\nextern crate tokio_proto;\nextern crate tokio_service;\n\nuse std::io;\nuse std::str;\nuse bytes::BytesMut;\nuse tokio_io::codec::{Encoder, Decoder};\nuse tokio_io::{AsyncRead, AsyncWrite};\nuse tokio_io::codec::Framed;\nuse tokio_proto::pipeline::ServerProto;\nuse tokio_service::Service;\nuse futures::{future, Future};\nuse tokio_proto::TcpServer;\n\n// Codec implementation, our codec is a simple unit struct\npub struct CollatzCodec;\n\n// Decoding a byte stream from the underlying socket\nimpl Decoder for CollatzCodec {\n    type Item = String;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<String>> {\n        // Since a newline denotes end of input, read till a newline\n        if let Some(i) = buf.iter().position(|&b| b == b'\\n') {\n            let line = buf.split_to(i);\n            // and remove the newline\n            buf.split_to(1);\n            // try to decode into an UTF8 string before passing\n            // to the protocol\n            match str::from_utf8(&line) {\n                Ok(s) => Ok(Some(s.to_string())),\n                Err(_) => Err(io::Error::new(io::ErrorKind::Other, \n                \"invalid UTF-8\")),\n            }\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n// Encoding a string to a newline terminated byte stream\nimpl Encoder for CollatzCodec {\n    type Item = String;\n    type Error = io::Error;\n\n    fn encode(&mut self, msg: String, buf: &mut BytesMut) -> \n    io::Result<()> {\n        buf.extend(msg.as_bytes());\n        buf.extend(b\"\\n\");\n        Ok(())\n    }\n}\n\n// Protocol implementation as an unit struct\npub struct CollatzProto;\n\nimpl<T: AsyncRead + AsyncWrite + 'static> ServerProto<T> for CollatzProto {\n    type Request = String;\n    type Response = String;\n    type Transport = Framed<T, CollatzCodec>;\n    type BindTransport = Result<Self::Transport, io::Error>;\n    fn bind_transport(&self, io: T) -> Self::BindTransport {\n        Ok(io.framed(CollatzCodec))\n    }\n}\n\n// Service implementation\npub struct CollatzService;\n\nfn get_sequence(n: u64) -> Vec<u64> {\n    let mut n = n.clone();\n    let mut result = vec![];\n    result.push(n);\n    while n > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        result.push(n);\n    }\n    result\n}\n\nimpl Service for CollatzService {\n    type Request = String;\n    type Response = String;\n    type Error = io::Error;\n    type Future = Box<Future<Item = Self::Response, Error = Self::Error>>;\n\n    fn call(&self, req: Self::Request) -> Self::Future {\n        match req.trim().parse::<u64>() {\n            Ok(num) => {\n                let res = get_sequence(num);\n                Box::new(future::ok(format!(\"{:?}\", res)))\n            }\n            Err(_) => Box::new(future::ok(\"Could not parse input as an\n            u64\".to_owned())),\n        }\n    }\n}\n\nfn main() {\n    let addr = \"0.0.0.0:9999\".parse().unwrap();\n    let server = TcpServer::new(CollatzProto, addr);\n    server.serve(|| Ok(CollatzService));\n}\n```", "```rs\n$ telnet localhost 9999\nConnected to localhost.\nEscape character is '^]'.\n12\n[12, 6, 3, 10, 5, 16, 8, 4, 2, 1]\n30\n[30, 15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]\nfoobar\nCould not parse input as an u64\n```", "```rs\n$ cargo new --bin collatz-client\n```", "```rs\n[package]\nname = \"collatz-client\"\nversion = \"0.1.0\"\nauthors = [\"Abhishek Chanda <abhishek.becs@gmail.com>\"]\n\n[dependencies]\nfutures = \"0.1\"\ntokio-core = \"0.1\"\ntokio-io = \"0.1\"\n```", "```rs\n// ch7/collatz-client/src/main.rs\n\nextern crate futures;\nextern crate tokio_core;\nextern crate tokio_io;\n\nuse std::net::SocketAddr;\nuse std::io::BufReader;\nuse futures::Future;\nuse tokio_core::reactor::Core;\nuse tokio_core::net::TcpStream;\n\nfn main() {\n    let mut core = Core::new().expect(\"Could not create event loop\");\n    let handle = core.handle();\n    let addr: SocketAddr = \"127.0.0.1:9999\".parse().expect(\"Could not parse as SocketAddr\");\n    let socket = TcpStream::connect(&addr, &handle);\n    let request = socket.and_then(|socket| {\n        tokio_io::io::write_all(socket, b\"110\\n\")\n    });\n    let response = request.and_then(|(socket, _request)| {\n        let sock = BufReader::new(socket);\n        tokio_io::io::read_until(sock, b'\\n', Vec::new())\n    });\n    let (_socket, data) = core.run(response).unwrap();\n    println!(\"{}\", String::from_utf8_lossy(&data));\n}\n```", "```rs\n$ cargo run\n   Compiling futures-loop v0.1.0 (file:///src/ch7/collatz-client)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.94 secs\n     Running `target/debug/futures-loop`\n[110, 55, 166, 83, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]\n```", "```rs\n$ cargo new collatz-multiplexed\n```", "```rs\n[package]\nname = \"collatz-multiplexed\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nbytes = \"0.4\"\nfutures = \"0.1\"\ntokio-io = \"0.1\"\ntokio-core = \"0.1\"\ntokio-proto = \"0.1\"\ntokio-service = \"0.1\"\n```", "```rs\n// ch7/collatz-multiplexed/src/lib.rs\n\nextern crate bytes;\nextern crate futures;\nextern crate tokio_core;\nextern crate tokio_io;\nextern crate tokio_proto;\nextern crate tokio_service;\n\nuse futures::{future, Future};\n\nuse tokio_io::{AsyncRead, AsyncWrite};\nuse tokio_io::codec::{Decoder, Encoder, Framed};\nuse tokio_core::net::TcpStream;\nuse tokio_core::reactor::Handle;\nuse tokio_proto::TcpClient;\nuse tokio_proto::multiplex::{ClientProto, ClientService, RequestId, ServerProto};\nuse tokio_service::Service;\n\nuse bytes::{BigEndian, Buf, BufMut, BytesMut};\n\nuse std::{io, str};\nuse std::net::SocketAddr;\n\n// Everything client side\n// Represents a client connecting to our server\npub struct Client {\n    inner: ClientService<TcpStream, CollatzProto>,\n}\n\nimpl Client {\n    pub fn connect(\n        addr: &SocketAddr,\n        handle: &Handle,\n    ) -> Box<Future<Item = Client, Error = io::Error>> {\n        let ret = TcpClient::new(CollatzProto)\n            .connect(addr, handle)\n            .map(|service| Client {\n                inner: service,\n            });\n\n        Box::new(ret)\n    }\n}\n\nimpl Service for Client {\n    type Request = String;\n    type Response = String;\n    type Error = io::Error;\n    type Future = Box<Future<Item = String, Error = io::Error>>;\n\n    fn call(&self, req: String) -> Self::Future {\n        Box::new(self.inner.call(req).and_then(move |resp| Ok(resp)))\n    }\n}\n\n// Everything server side\npub struct CollatzCodec;\npub struct CollatzProto;\n\n// Represents a frame that has a RequestId and the actual data (String)\ntype CollatzFrame = (RequestId, String);\n\nimpl Decoder for CollatzCodec {\n    type Item = CollatzFrame;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> \n    Result<Option<CollatzFrame>, io::Error> {\n        // Do not proceed if we haven't received at least 6 bytes yet\n        // 4 bytes for the RequestId + data + 1 byte for newline\n        if buf.len() < 5 {\n            return Ok(None);\n        }\n        let newline = buf[4..].iter().position(|b| *b == b'\\n');\n        if let Some(n) = newline {\n            let line = buf.split_to(n + 4);\n            buf.split_to(1);\n            let request_id = io::Cursor::new(&line[0..4]).get_u32:\n            :<BigEndian>();\n            return match str::from_utf8(&line.as_ref()[4..]) {\n                Ok(s) => Ok(Some((u64::from(request_id),\n                s.to_string()))),\n                Err(_) => Err(io::Error::new(io::ErrorKind::Other, \n                \"invalid string\")),\n            };\n        }\n        // Frame is not complete if it does not have a newline at the\n        end\n        Ok(None)\n    }\n}\n\nimpl Encoder for CollatzCodec {\n    type Item = CollatzFrame;\n    type Error = io::Error;\n\n    fn encode(&mut self, msg: CollatzFrame, buf: &mut BytesMut) ->\n    io::Result<()> {\n        // Calculate final message length first\n        let len = 4 + msg.1.len() + 1;\n        buf.reserve(len);\n\n        let (request_id, msg) = msg;\n\n        buf.put_u32::<BigEndian>(request_id as u32);\n        buf.put_slice(msg.as_bytes());\n        buf.put_u8(b'\\n');\n\n        Ok(())\n    }\n}\n\nimpl<T: AsyncRead + AsyncWrite + 'static> ClientProto<T> for CollatzProto {\n    type Request = String;\n    type Response = String;\n\n    type Transport = Framed<T, CollatzCodec>;\n    type BindTransport = Result<Self::Transport, io::Error>;\n\n    fn bind_transport(&self, io: T) -> Self::BindTransport {\n        Ok(io.framed(CollatzCodec))\n    }\n}\n\nimpl<T: AsyncRead + AsyncWrite + 'static> ServerProto<T> for CollatzProto {\n    type Request = String;\n    type Response = String;\n\n    type Transport = Framed<T, CollatzCodec>;\n    type BindTransport = Result<Self::Transport, io::Error>;\n\n    fn bind_transport(&self, io: T) -> Self::BindTransport {\n        Ok(io.framed(CollatzCodec))\n    }\n}\n\npub struct CollatzService;\n\nfn get_sequence(mut n: u64) -> Vec<u64> {\n    let mut result = vec![];\n    result.push(n);\n    while n > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        result.push(n);\n    }\n    result\n}\n\nimpl Service for CollatzService {\n    type Request = String;\n    type Response = String;\n    type Error = io::Error;\n    type Future = Box<Future<Item = Self::Response, Error = Self::Error>>;\n\n    fn call(&self, req: Self::Request) -> Self::Future {\n        match req.trim().parse::<u64>() {\n            Ok(num) => {\n                let res = get_sequence(num);\n                Box::new(future::ok(format!(\"{:?}\", res)))\n            }\n            Err(_) => Box::new(future::ok(\"Could not parse input as an\n            u64\".to_owned())),\n        }\n    }\n}\n```", "```rs\n// ch7/collatz-multiplexed/examples/server.rs\n\nextern crate collatz_multiplexed as collatz;\nextern crate tokio_proto;\n\nuse tokio_proto::TcpServer;\nuse collatz::{CollatzService, CollatzProto};\n\nfn main() {\n    let addr = \"0.0.0.0:9999\".parse().unwrap();\n    TcpServer::new(CollatzProto, addr).serve(|| Ok(CollatzService));\n}\n```", "```rs\n// ch7/collatz-multiplexed/examples/client.rs\n\nextern crate collatz_multiplexed as collatz;\n\nextern crate futures;\nextern crate tokio_core;\nextern crate tokio_service;\n\nuse futures::Future;\nuse tokio_core::reactor::Core;\nuse tokio_service::Service;\n\npub fn main() {\n    let addr = \"127.0.0.1:9999\".parse().unwrap();\n    let mut core = Core::new().unwrap();\n    let handle = core.handle();\n\n    core.run(\n        collatz::Client::connect(&addr, &handle)\n            .and_then(|client| {\n                client.call(\"110\".to_string())\n                    .and_then(move |response| {\n                        println!(\"We got back: {:?}\", response);\n                        Ok(())\n                    })\n            })\n    ).unwrap();\n}\n```", "```rs\n$ cargo run --example client\n   Compiling collatz-multiplexed v0.1.0 (file:///src/ch7/collatz-multiplexed)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.93 secs\n     Running `target/debug/examples/client`\nWe got back: \"[110, 55, 166, 83, 250, 125, 376, 188, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]\"\n```", "```rs\n$ cargo new collatz-streaming\n```", "```rs\n[package]\nname = \"collatz-streaming\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nbytes = \"0.4\"\nfutures = \"0.1\"\ntokio-io = \"0.1\"\ntokio-core = \"0.1\"\ntokio-proto = \"0.1\"\ntokio-service = \"0.1\"\n```", "```rs\n// ch7/collatz-streaming/src/lib.rs\n\nextern crate bytes;\nextern crate futures;\nextern crate tokio_core;\nextern crate tokio_io;\nextern crate tokio_proto;\nextern crate tokio_service;\n\nuse futures::{future, Future, Poll, Stream};\nuse futures::sync::mpsc;\nuse tokio_io::{AsyncRead, AsyncWrite};\nuse tokio_io::codec::{Decoder, Encoder, Framed};\nuse tokio_core::reactor::Handle;\nuse tokio_proto::TcpClient;\nuse tokio_proto::streaming::{Body, Message};\nuse tokio_proto::streaming::pipeline::{ClientProto, Frame, ServerProto};\nuse tokio_proto::util::client_proxy::ClientProxy;\nuse tokio_service::Service;\nuse std::str::FromStr;\nuse bytes::{BufMut, BytesMut};\nuse std::{io, str};\nuse std::net::SocketAddr;\n\n// Everything about clients\ntype CollatzMessage = Message<String, Body<String, io::Error>>;\n\n#[derive(Debug)]\npub enum CollatzInput {\n    Once(String),\n    Stream(CollatzStream),\n}\n\npub struct CollatzProto;\n\npub struct Client {\n    inner: ClientProxy<CollatzMessage, CollatzMessage, io::Error>,\n}\n\nimpl Client {\n    pub fn connect(\n        addr: &SocketAddr,\n        handle: &Handle,\n    ) -> Box<Future<Item = Client, Error = io::Error>> {\n        let ret = TcpClient::new(CollatzProto)\n            .connect(addr, handle)\n            .map(|cp| Client { inner: cp });\n\n        Box::new(ret)\n    }\n}\n\nimpl Service for Client {\n    type Request = CollatzInput;\n    type Response = CollatzInput;\n    type Error = io::Error;\n    type Future = Box<Future<Item = Self::Response, Error = \n    io::Error>>;\n\n    fn call(&self, req: CollatzInput) -> Self::Future {\n        Box::new(self.inner.call(req.into()).map(CollatzInput::from))\n    }\n}\n```", "```rs\n//ch7/collatz-streaming/src/lib.rs\n\n// Everything about server\n#[derive(Debug)]\npub struct CollatzStream {\n    inner: Body<String, io::Error>,\n}\n\nimpl CollatzStream {\n    pub fn pair() -> (mpsc::Sender<Result<String, io::Error>>,\n    CollatzStream) {\n        let (tx, rx) = Body::pair();\n        (tx, CollatzStream { inner: rx })\n    }\n}\n\nimpl Stream for CollatzStream {\n    type Item = String;\n    type Error = io::Error;\n\n    fn poll(&mut self) -> Poll<Option<String>, io::Error> {\n        self.inner.poll()\n    }\n}\n\npub struct CollatzCodec {\n    decoding_head: bool,\n}\n\n// Decodes a frame to a byte slice\nimpl Decoder for CollatzCodec {\n    type Item = Frame<String, String, io::Error>;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> Result<Option<Self::Item>, io::Error> {\n        if let Some(n) = buf.as_ref().iter().position(|b| *b == b'\\n') {\n            let line = buf.split_to(n);\n\n            buf.split_to(1);\n            return match str::from_utf8(line.as_ref()) {\n                Ok(s) => {\n                    if s == \"\" {\n                        let decoding_head = self.decoding_head;\n                        self.decoding_head = !decoding_head;\n\n                        if decoding_head {\n                            Ok(Some(Frame::Message {\n                                message: s.to_string(),\n                                body: true,\n                            }))\n                        } else {\n                            Ok(Some(Frame::Body { chunk: None }))\n                        }\n                    } else {\n                        if self.decoding_head {\n                            Ok(Some(Frame::Message {\n                                message: s.to_string(),\n                                body: false,\n                            }))\n                        } else {\n                            Ok(Some(Frame::Body {\n                                chunk: Some(s.to_string()),\n                            }))\n                        }\n                    }\n                }\n                Err(_) => Err(io::Error::new(io::ErrorKind::Other, \n                \"invalid string\")),\n            };\n        }\n\n        Ok(None)\n    }\n}\n\n// Encodes a given byte slice to a frame\nimpl Encoder for CollatzCodec {\n    type Item = Frame<String, String, io::Error>;\n    type Error = io::Error;\n\n    fn encode(&mut self, msg: Self::Item, buf: &mut BytesMut) ->\n    io::Result<()> {\n        match msg {\n            Frame::Message { message, body } => {\n                buf.reserve(message.len());\n                buf.extend(message.as_bytes());\n            }\n            Frame::Body { chunk } => {\n                if let Some(chunk) = chunk {\n                    buf.reserve(chunk.len());\n                    buf.extend(chunk.as_bytes());\n                }\n            }\n            Frame::Error { error } => {\n                return Err(error);\n            }\n        }\n        buf.put_u8(b'\\n');\n        Ok(())\n    }\n}\n\nimpl<T: AsyncRead + AsyncWrite + 'static> ClientProto<T> for CollatzProto {\n    type Request = String;\n    type RequestBody = String;\n    type Response = String;\n    type ResponseBody = String;\n    type Error = io::Error;\n\n    type Transport = Framed<T, CollatzCodec>;\n    type BindTransport = Result<Self::Transport, io::Error>;\n\n    fn bind_transport(&self, io: T) -> Self::BindTransport {\n        let codec = CollatzCodec {\n            decoding_head: true,\n        };\n\n        Ok(io.framed(codec))\n    }\n}\n\nimpl<T: AsyncRead + AsyncWrite + 'static> ServerProto<T> for CollatzProto {\n    type Request = String;\n    type RequestBody = String;\n    type Response = String;\n    type ResponseBody = String;\n    type Error = io::Error;\n\n    type Transport = Framed<T, CollatzCodec>;\n    type BindTransport = Result<Self::Transport, io::Error>;\n\n    fn bind_transport(&self, io: T) -> Self::BindTransport {\n        let codec = CollatzCodec {\n            decoding_head: true,\n        };\n\n        Ok(io.framed(codec))\n    }\n}\n```", "```rs\n//ch7/collatz-streaming/src/lib.rs\n\npub struct CollatzService;\n\n// Given an u64, returns it's collatz sequence\nfn get_sequence(mut n: u64) -> Vec<u64> {\n    let mut result = vec![];\n    result.push(n);\n    while n > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        result.push(n);\n    }\n    result\n}\n\n// Removes leading and trailing whitespaces from a given line\n// and tries to parse it as a u64\nfn clean_line(line: &str) -> Result<u64, <u64 as FromStr>::Err> {\n    line.trim().parse::<u64>()\n}\n\nimpl Service for CollatzService {\n    type Request = CollatzInput;\n    type Response = CollatzInput;\n    type Error = io::Error;\n    type Future = Box<Future<Item = Self::Response, Error = Self::Error>>;\n\n    fn call(&self, req: Self::Request) -> Self::Future {\n        match req {\n            CollatzInput::Once(line) => {\n                println!(\"Server got: {}\", line);\n                let res = get_sequence(clean_line(&line).unwrap());\n                Box::new(future::done(Ok(CollatzInput::Once\n                (format!(\"{:?}\", res)))))\n            }\n            CollatzInput::Stream(body) => {\n                let resp = body.for_each(|line| {\n                    println!(\"{}\", line);\n                    Ok(())\n                }).map(|_| CollatzInput::Once(\"Foo\".to_string()));\n\n                Box::new(resp) as Box<Future<Item = Self::\n                Response, Error = io::Error>>\n            }\n        }\n    }\n}\n```", "```rs\n// ch7/collatz-streaming/src/lib.rs\n\n// Converts a CollatzMessage to a CollatzInput\nimpl From<CollatzMessage> for CollatzInput {\n    fn from(src: CollatzMessage) -> CollatzInput {\n        match src {\n            Message::WithoutBody(line) => CollatzInput::Once(line),\n            Message::WithBody(_, body) => CollatzInput::Stream(CollatzStream { inner: body }),\n        }\n    }\n}\n\n// Converts a CollatzInput to a Message<String, Body>\nimpl From<CollatzInput> for Message<String, Body<String, io::Error>> {\n    fn from(src: CollatzInput) -> Self {\n        match src {\n            CollatzInput::Once(line) => Message::WithoutBody(line),\n            CollatzInput::Stream(body) => {\n                let CollatzStream { inner } = body;\n                Message::WithBody(\"\".to_string(), inner)\n            }\n        }\n    }\n}\n```", "```rs\n// ch7/collatz-streaming/examples/server.rs\n\nextern crate collatz_streaming as collatz;\nextern crate futures;\n\nextern crate tokio_proto;\n\nuse tokio_proto::TcpServer;\nuse collatz::{CollatzProto, CollatzService};\n\nfn main() {\n    let addr = \"0.0.0.0:9999\".parse().unwrap();\n```", "```rs\n    TcpServer::new(CollatzProto, addr).serve(|| Ok(CollatzService));\n}\n```", "```rs\n// ch7/collatz-streaming/examples/client.rs\n\nextern crate collatz_streaming as collatz;\n\nextern crate futures;\nextern crate tokio_core;\nextern crate tokio_service;\n\nuse collatz::{CollatzInput, CollatzStream};\nuse std::thread;\nuse futures::Sink;\nuse futures::Future;\nuse tokio_core::reactor::Core;\nuse tokio_service::Service;\n\npub fn main() {\n    let addr = \"127.0.0.1:9999\".parse().unwrap();\n    let mut core = Core::new().unwrap();\n    let handle = core.handle();\n\n    // Run the client in the event loop\n    core.run(\n        collatz::Client::connect(&addr, &handle)\n            .and_then(|client| {\n                client.call(CollatzInput::Once(\"10\".to_string()))\n                    .and_then(move |response| {\n                        println!(\"Response: {:?}\", response);\n\n                        let (mut tx, rx) = CollatzStream::pair();\n\n                        thread::spawn(move || {\n                            for msg in &[\"Hello\", \"world\", \"!\"] {\n                                tx =\n                                tx.send(Ok(msg.to_string()))\n                                .wait().unwrap();\n                            }\n                        });\n\n                        client.call(CollatzInput::Stream(rx))\n                    })\n                    .and_then(|response| {\n                        println!(\"Response: {:?}\", response);\n                        Ok(())\n                    })\n            })\n    ).unwrap();\n}\n```", "```rs\n$ cargo run --example server\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/examples/server`\nServer got: 10\nHello\nworld\n!\n```", "```rs\n$ cargo run --example client\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/examples/client`\nResponse: Once(\"[10, 5, 16, 8, 4, 2, 1]\")\nResponse: Once(\"Foo\")\n```", "```rs\n$ cargo new --bin tokio-curl\n```", "```rs\n[package]\nname = \"tokio-curl\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\ntokio-curl = \"0.1\"\ntokio-core = \"0.1\"\ncurl = \"0.4.8\"\n```", "```rs\n// ch7/toki-curl/src/main.rs\n\nextern crate curl;\nextern crate tokio_core;\nextern crate tokio_curl;\n\nuse curl::easy::Easy;\nuse tokio_core::reactor::Core;\nuse tokio_curl::Session;\nuse std::io::Write;\nuse std::fs::File;\n\nfn main() {\n    let mut core = Core::new().unwrap();\n    let session = Session::new(core.handle());\n\n    let mut handle = Easy::new();\n    let mut file = File::create(\"foo.zip\").unwrap();\n    handle.get(true).unwrap();\n    handle.url(\"http://ipv4.download.thinkbroadband.com/5MB.zip\").unwrap();\n    handle.header_function(|header| {\n        print!(\"{}\", std::str::from_utf8(header).unwrap());\n        true\n    }).unwrap();\n    handle.write_function(move |data| {\n        file.write_all(data).unwrap();\n        Ok(data.len())\n    }).unwrap();\n\n    let request = session.perform(handle);\n\n    let mut response = core.run(request).unwrap();\n    println!(\"{:?}\", response.response_code());\n}\n```", "```rs\n$ cargo run\n   Compiling tokio-curl v0.1.0 (file:///src/ch7/tokio-curl)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.97 secs\n     Running `target/debug/tokio-curl`\nHTTP/1.1 200 OK\nServer: nginx\nDate: Mon, 25 Dec 2017 20:16:12 GMT\nContent-Type: application/zip\nContent-Length: 5242880\nLast-Modified: Mon, 02 Jun 2008 15:30:42 GMT\nConnection: keep-alive\nETag: \"48441222-500000\"\nAccess-Control-Allow-Origin: *\nAccept-Ranges: bytes\n\nOk(200)\n```"]