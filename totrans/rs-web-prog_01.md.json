["```rs\nfn main() {\n    println!(\"hello world\");\n}\n```", "```rs\nif __name__ == \"__main__\":\n    print(\"Hello, World!\")\n```", "```rs\nfn print(message: str) {\n    println!(\"{}\", message);\n}\nfn main() {\n    let message = \"hello world\";\n    print(message);\n}\n```", "```rs\n10 |     print(message);\n   |           ^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all function arguments must have a statically known size \n```", "```rs\nfn print(message: String) {\n    println!(\"{}\", message);\n}\nfn main() {\n    let message = String::from(\"hello world\");\n    print(message);\n}\n```", "```rs\n    let string_one = \"hello world\".to_owned();\n    let string_two = \"hello world\".to_string();\n    let string_three = string_two.clone();\n```", "```rs\n# slower method \ndata = [\"one\", \"two\", \"three\", \"four\"]\nstring = \"\"\nfor i in data:\n    string += i   \n# faster method\n\"\".join(data)\n```", "```rs\nfn print(message: &str) {\n    println!(\"{}\", message);\n}\nfn main() {\n    print(&\"hello world\");\n}\n```", "```rs\nlet number: u8 = 256;\n```", "```rs\nthe literal `256` does not fit into the type \n`u8` whose range is `0..=255`\n```", "```rs\nlet number: i8 = 255;\n```", "```rs\nthe literal `255` does not fit into the type \n`i8` whose range is `-128..=127`\n```", "```rs\nlet number: i16 = 255;\n```", "```rs\nlet number = 255i16;\nlet number_two = 5i8;\nlet result = number + number_two;\n```", "```rs\n11 |     let result = number + number_two;\n   |                         ^ no implementation for `i16 + i8`\n   |\n   = help: the trait `Add<i8>` is not implemented for `i16`\n```", "```rs\n let result = number + number_two as i16;\n```", "```rs\nlet result = i8::from(number) + number_two;\n```", "```rs\nlet result = i8::from(number) + number_two;\n|                  ^^^^^^^^ the trait `From<i16>` is not \n                            implemented for `i8`\n```", "```rs\nlet float: f32 = 2.6;\n```", "```rs\nfn main() {\n    let int_array: [i32; 3] = [1, 2, 3];\n    for i in int_array {\n        println!(\"{}\", i);\n    }\n    println!(\"{}\", int_array[1]);\n}\n```", "```rs\n1\n2\n3\n2\n```", "```rs\nfn main() {\n    let mut mutable_array: [i32; 3] = [1, 2, 0];\n    mutable_array[2] = 3;\n    println!(\"{:?}\", mutable_array);\n    println!(\"{}\", mutable_array.len());\n}\n```", "```rs\n[1, 2, 3]\n3\n```", "```rs\nfn main() {\n    let slice_array: [i32; 100] = [0; 100];\n    println!(\"length: {}\", slice_array.len());\n    println!(\"slice: {:?}\", &slice_array[5 .. 8]);\n}\n```", "```rs\nlength: 100\nslice: [0, 0, 0]\n```", "```rs\nenum SomeValue {\n    StringValue(String),\n    IntValue(i32)\n}\n```", "```rs\n    let multi_array: [SomeValue; 4] = [\n        SomeValue::StringValue(String::from(\"one\")),\n        SomeValue::IntValue(2),\n        SomeValue::StringValue(String::from(\"three\")),\n        SomeValue::IntValue(4)\n    ];\n```", "```rs\n    for i in multi_array {\n        match i {\n            SomeValue::StringValue(data) => {\n                println!(\"The string is: {}\", data);\n            },\n            SomeValue::IntValue(data) => {\n                println!(\"The int is: {}\", data);\n            }\n        }\n    }\n```", "```rs\nThe string is: one\nThe int is: 2\nThe string is: three\nThe int is: 4\n```", "```rs\n    let mut string_vector: Vec<&str> = vec![\"one\", \"two\", \n        \"three\"];\n    println!(\"{:?}\", string_vector);\n    string_vector.push(\"four\");\n    println!(\"{:?}\", string_vector);\n```", "```rs\n[\"one\", \"two\", \"three\"]\n[\"one\", \"two\", \"three\", \"four\"]\n```", "```rs\n#[derive(Debug)]\nenum CharacterValue {\n    Name(String),\n    Age(i32),\n    Items(Vec<String>)\n}\n```", "```rs\nuse std::collections::HashMap;\nfn main() {\n    let mut profile: HashMap<&str, CharacterValue> = \n                     HashMap::new();\n}\n```", "```rs\nprofile.insert(\"name\", CharacterValue::Name(\"Maxwell\".to_string()));\nprofile.insert(\"age\", CharacterValue::Age(32));\nprofile.insert(\"items\", CharacterValue::Items(vec![\n    \"laptop\".to_string(),\n    \"book\".to_string(),\n    \"coat\".to_string()\n]));\nprintln!(\"{:?}\", profile);\n```", "```rs\n{\"items\": Items([\"laptop\", \"book\", \"coat\"]), \"age\": Age(32), \n\"name\": Name(\"Maxwell\")}\n```", "```rs\n    match profile.get(\"name\") {\n        Some(value_data) => {\n            match value_data {\n                CharacterValue::Name(name) => {\n                    println!(\"the name is: {}\", name);\n                },\n                _ => panic!(\"name should be a string\") \n            }\n        },\n        None => {\n            println!(\"name is not present\");\n        }\n    }\n```", "```rs\n    match profile.get(\"name\").unwrap() {\n        CharacterValue::Name(name) => {\n            println!(\"the name is: {}\", name);\n        }, \n        _ => panic!(\"name should be a string\") \n    }\n```", "```rs\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value'\n```", "```rs\nfn error_check(check: bool) -> Result<i8, &'static str> {\n    if check {\n        Err(\"this is an error\")\n        } \n    else {\n        Ok(1)\n    }\n}\n```", "```rs\nfn main() {\n    println!(\"{:?}\", error_check(false));\n    println!(\"{:?}\", error_check(false).is_err());\n    println!(\"{:?}\", error_check(true));\n    println!(\"{:?}\", error_check(true).is_err());\n}\n```", "```rs\nOk(1)\nfalse\nErr(\"this is an error\")\ntrue\n```", "```rs\nlet result: i8 = error_check(true).expect(\"this has been caught\");\n```", "```rs\nthread 'main' panicked at 'this has been caught: \"this is an error\"'\n```", "```rs\nlet one: i8 = 10;\nlet two: i8 = one + 5;\nprintln!(\"{}\", one);\nprintln!(\"{}\", two);\n```", "```rs\n10\n15\n```", "```rs\nlet one = \"one\".to_string();\nlet two = one;\nprintln!(\"{}\", one);\nprintln!(\"{}\", two);\n```", "```rs\nmove occurs because `one` has type `String`, which does not implement the `Copy` trait\n```", "```rs\nlet one: String = String::from(\"one\");\nlet two: String = one + \" two\";\nprintln!(\"{}\", two);\nprintln!(\"{}\", one);\n```", "```rs\nlet one: String = String::from(\"one\");\n    --- move occurs because `one` has type \n    `String`, which does not implement the \n    `Copy` trait\nlet two: String = one + \" two\";\n                  ------------ `one` moved due to usage in operator\nprintln!(\"{}\", two);\nprintln!(\"{}\", one);\n               ^^^ value borrowed here after move\n```", "```rs\nlet two: String = one.to_owned() + \" two\";\n```", "```rs\nfn print(value: String) {\n    println!(\"{}\", value);\n}\nfn main() {\n    let one = \"one\".to_string();\n    print(one);\n    println!(\"{}\", one);\n}\n```", "```rs\nfn print(value: &String) {\n    println!(\"{}\", value);\n}\nfn main() {\n    let one = \"one\".to_string();\n    print(&one);\n    println!(\"{}\", one);\n}\n```", "```rs\none\none\n```", "```rs\nfn print(value: &String, value_two: String) {\n    println!(\"{}\", value);\n    println!(\"{}\", value_two);\n}\nfn main() {\n    let one = \"one\".to_string();\n    print(&one, one);\n    println!(\"{}\", one);\n}\n```", "```rs\nprint(&one, one);\n----- ----  ^^^ move out of `one` occurs here\n|     |\n|     borrow of `one` occurs here\nborrow later used by call\n```", "```rs\nfn print(value: &String, value_two: &String) {\n    println!(\"{}\", value);\n    println!(\"{}\", value_two);\n}\nfn main() {\n    let one = \"one\".to_string();\n    print(&one, &one);\n    println!(\"{}\", one);\n}\n```", "```rs\nfn print(value: &mut i8) {\n     value += 1;\n    println!(\"In function the value is: {}\", value);\n}\nfn main() {\n    let mut one: i8 = 5;\n    print(&mut one);\n    println!(\"In main the value is: {}\", one);\n}\n```", "```rs\nIn function the value is: 6\nIn main the value is: 6\n```", "```rs\nfn print(value: &mut i8, value_two: &mut i8) {\n     value += 1;\n    println!(\"In function the value is: {}\", value);\n     value_two += 1;\n}\nfn main() {\n    let mut one: i8 = 5;\n    print(&mut one, &mut one);\n    println!(\"In main the value is: {}\", one);\n}\n```", "```rs\nerror[E0499]: cannot borrow `one` as mutable more than once at a time\n```", "```rs\nprintln!(\"{}\", two);\n               ^^^ not found in this scope\n```", "```rs\nfn main() {\n    let one = &\"one\";\n    let two: &str;\n    {\n        println!(\"{}\", one);\n        two = &\"two\";\n    }\n    println!(\"{}\", one);\n    println!(\"{}\", two);\n}\n```", "```rs\none\none\ntwo\n```", "```rs\nfn main() {\n    let one: &i8;\n    {\n        let two: i8 = 2;\n        one = &two;\n    } // -----------------------> two lifetime stops here\n    println!(\"r: {}\", one);\n}\n```", "```rs\none = &two;    }    println!(\"r: {}\", one);}\n      ^^^^     -                      --- borrow later used here\n      |        |\n      |        `two` dropped here while still borrowed\n      borrowed value does not live long enough\n```", "```rs\nfn get_highest<'a>(first_number: &'a i8, second_number: &'a\n    i8) -> &'a i8 {\n    if first_number > second_number {\n        first_number\n        } else {\n        second_number\n    }\n}\nfn main() {\n    let one: i8 = 1;\n    let outcome: &i8;\n    {\n        let two: i8 = 2;\n        let outcome: &i8 = get_highest(&one, &two);\n    }\n    println!(\"{}\", outcome);\n}\n```", "```rs\nprintln!(\"{}\", outcome);}\n               ^^^^^^^ use of possibly-uninitialized `outcome`\n```", "```rs\nfn filter<'a, 'b>(first_number: &'a i8, second_number: &'b\n    i8) -> &'a i8 {\n    if first_number < second_number {\n        &0\n    } else {\n        first_number\n    }\n}\nfn main() {\n    let one: i8 = 1;\n    let outcome: &i8;\n    {\n        let two: i8 = 2;\n        outcome = filter(&one, &two);\n    }\n    println!(\"{}\", outcome);\n}\n```", "```rs\n#[derive(Debug)]\nstruct Human<'a> {\n    name: &'a str,\n    age: i8,\n    current_thought: &'a str\n}\n```", "```rs\nfn main() {\n    let developer = Human{\n        name: \"Maxwell Flitton\",\n        age: 32,\n        current_thought: \"nothing\"\n    };\n    println!(\"{:?}\", developer);\n    println!(\"{}\", developer.name);\n}\n```", "```rs\nHuman { name: \"Maxwell Flitton\", age: 32, current_thought:    \"nothing\" }\nMaxwell Flitton\n```", "```rs\n#[derive(Debug)]\nenum Friend {\n    HUMAN(Human),\n    NIL\n}\n#[derive(Debug)]\nstruct Human {\n    name: String,\n    age: i8,\n    current_thought: String,\n    friend: Friend\n}\n```", "```rs\n    let developer = Human{\n        name: \"Maxwell Flitton\".to_string(),\n        age: 32,\n        current_thought: \"nothing\".to_string(),\n        friend: Friend::NIL\n    };\n```", "```rs\nenum Friend {    HUMAN(Human),    NIL}#[derive(Debug)]\n^^^^^^^^^^^            ----- recursive without indirection\n|\nrecursive type has infinite size\n```", "```rs\n#[derive(Debug)]\nenum Friend {\n    HUMAN(Box<Human>),\n    NIL\n}\n```", "```rs\nfn main() {\n    let another_developer = Human{\n        name: \"Caroline Morton\".to_string(),\n        age:30,\n        current_thought: \"I need to code!!\".to_string(),\n        friend: Friend::NIL\n    };\n    let developer = Human{\n        name: \"Maxwell Flitton\".to_string(),\n        age: 32,\n        current_thought: \"nothing\".to_string(),\n        friend: Friend::HUMAN(Box::new(another_developer))\n    };\n    match &developer.friend {\n        Friend::HUMAN(data) => {\n            println!(\"{}\", data.name);\n        },\n        Friend::NIL => {}\n    }\n}\n```", "```rs\n#[derive(Debug)]\nstruct Human {\n    name: String,\n    age: i8,\n    current_thought: Option<String>,\n    friend: Friend\n}\nimpl Human {    \n    fn new(name: &str, age: i8) -> Human {\n        return Human{\n            name: name.to_string(),\n            age: age,\n            current_thought: None,\n            friend: Friend::NIL\n        }\n    }\n}\n```", "```rs\nlet developer = Human::new(\"Maxwell Flitton\", 32);\n```", "```rs\n    fn with_thought(mut self, thought: &str) -> Human {\n        self.current_thought = Some(thought.to_string());\n        return self\n    }\n    fn with_friend(mut self, friend: Box<Human>) -> Human {\n        self.friend = Friend::HUMAN(friend);\n        return self\n    }\n```", "```rs\nlet developer = Human::new(\"Maxwell Flitton\", 32)\n    .with_thought(\"I love Rust!\");\n```", "```rs\nlet developer_friend = Human::new(\"Caroline Morton\", 30);\nlet developer = Human::new(\"Maxwell Flitton\", 32)\n    .with_thought(\"I love Rust!\")\n    .with_friend(Box::new(developer_friend));\nPrintln!(\"{:?}\", developer);\n```", "```rs\nName: \"Maxwell Flitton\"\nAge: 32\nCurrent Thought: Some(\"I love Rust!\")\nFriend: HUMAN(Human { name: \"Caroline Morton\", age: 30, \n    current_thought: None, friend: NIL })\n```", "```rs\n    struct AdminUser {\n    ```", "```rs\n        username: String,\n    ```", "```rs\n        password: String\n    ```", "```rs\n    }\n    ```", "```rs\n    struct User {\n    ```", "```rs\n        username: String,\n    ```", "```rs\n        password: String\n    ```", "```rs\n    }\n    ```", "```rs\n    trait CanEdit {\n    ```", "```rs\n        fn edit(&self) {\n    ```", "```rs\n            println!(\"admin is editing\");\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    trait CanCreate {\n    ```", "```rs\n        fn create(&self) {\n    ```", "```rs\n            println!(\"admin is creating\");\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    trait CanDelete {\n    ```", "```rs\n        fn delete(&self) {\n    ```", "```rs\n            println!(\"admin is deleting\");\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    impl CanDelete for AdminUser {}\n    ```", "```rs\n    impl CanCreate for AdminUser {}\n    ```", "```rs\n    impl CanEdit for AdminUser {}\n    ```", "```rs\n    impl CanEdit for User {\n    ```", "```rs\n        fn edit(&self) {\n    ```", "```rs\n            println!(\"A standard user {} is editing\", \n    ```", "```rs\n        self.username);\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    fn create<T: CanCreate>(user: &T) -> () {\n    ```", "```rs\n        user.create();\n    ```", "```rs\n    }\n    ```", "```rs\n    fn edit<T: CanEdit>(user: &T) -> () {\n    ```", "```rs\n        user.edit();\n    ```", "```rs\n    }\n    ```", "```rs\n    fn delete<T: CanDelete>(user: &T) -> () {\n    ```", "```rs\n        user.delete();\n    ```", "```rs\n    }\n    ```", "```rs\n    fn main() {\n    ```", "```rs\n        let admin = AdminUser{\n    ```", "```rs\n            username: \"admin\".to_string(), \n    ```", "```rs\n            password: \"password\".to_string()\n    ```", "```rs\n        };\n    ```", "```rs\n        let user = User{\n    ```", "```rs\n            username: \"user\".to_string(), \n    ```", "```rs\n            password: \"password\".to_string()\n    ```", "```rs\n        };\n    ```", "```rs\n        create(&admin);\n    ```", "```rs\n        edit(&admin);\n    ```", "```rs\n        edit(&user);\n    ```", "```rs\n        delete(&admin);\n    ```", "```rs\n    }\n    ```", "```rs\nadmin is creating\nadmin is editing\nA standard user user is editing\nadmin is deleting\n```", "```rs\nstruct Coordinate <T> {\n    x: T,\n    y: T\n}\nfn main() {\n    let one = Coordinate{x: 50, y: 50};\n    let two = Coordinate{x: 500, y: 500};\n    let three = Coordinate{x: 5.6, y: 5.6};\n}\n```", "```rs\nstruct Coordinate <T, X> {\n    x: T,\n    y: X\n}\nfn main() {\n    let one = Coordinate{x: 50, y: 500};\n    let two = Coordinate{x: 5.6, y: 500};\n    let three = Coordinate{x: 5.6, y: 50};\n}\n```", "```rs\nmacro_rules! capitalize {\n    ($a: expr) => {\n        let mut v: Vec<char> = $a.chars().collect();\n        v[0] = v[0].to_uppercase().nth(0).unwrap();\n        $a = v.into_iter().collect();\n    }\n}\nfn main() {\n    let mut x = String::from(\"test\");\n    capitalize!(x);\n    println!(\"{}\", x);\n}\n```", "```rs\n|     capitalize!(32);\n|     ---------------- in this macro invocation\n|\n= help: the trait `std::iter::FromIterator<char>` is not implemented for `{integer}`\n```"]