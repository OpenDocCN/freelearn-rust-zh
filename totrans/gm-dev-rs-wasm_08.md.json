["```rs\nimpl RedHatBoyContext {\n    fn update(mut self, frame_count: u8) -> Self {\n         ...\n         // DELETE THIS LINE! self.position.x += \n           self.velocity.x\n         self.position.y += self.velocity.y;\n         ...\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn walking_speed(&self) -> i16 {\n        self.state_machine.context().velocity.x\n    }\n```", "```rs\nimpl Walk {\n    fn velocity(&self) -> i16 {\n        -self.boy.walking_speed()\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            walk.boy.update();\n            walk.platform.position.x += walk.velocity();\n            walk.stone.move_horizontally(walk.velocity());\n            ...\n```", "```rs\nimpl Image {\n    ...\n    pub fn move_horizontally(&mut self, distance: i16) {\n        self.bounding_box.x += distance as f32;\n        self.position.x += distance;\n    }\n}\n```", "```rs\nfn update(&mut self, keystate: &KeyState) {\n    if let WalkTheDog::Loaded(walk) = self {\n        ...\n        walk.platform.position.x += walk.velocity();\n        walk.stone.move_horizontally(walk.velocity());\n        walk.background.move_horizontally(walk.velocity());\n        ...\n```", "```rs\nstruct Walk {\n    boy: RedHatBoy,\n    backgrounds: [Image; 2],\n    stone: Image,\n    platform: Platform,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let background_width = background.width() \n                 as i16;\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    boy: rhb,\n                    backgrounds: [\n                        Image::new(background.clone(), \n                        Point { x: 0, y: 0 }),\n                        Image::new(\n                            background,\n                            Point {\n                                x: background_width,\n                                y: 0,\n                            },\n                        ),\n                    ],\n                    stone: Image::new(stone, Point { x: \n                     150, y: 546 }),\n                    platform,\n                })))\n                ...\n```", "```rs\nfn update(&mut self, keystate: &KeyState) {\n   if let WalkTheDog::Loaded(walk) = self {\n        ...\n        walk.platform.position.x += walk.velocity();\n        walk.stone.move_horizontally(walk.velocity());\n        let velocity = walk.velocity();\n        walk.backgrounds.iter_mut().for_each(|background| {\n            background.move_horizontally(velocity);\n        });\n```", "```rs\nfn draw(&self, renderer: &Renderer) {\n    ...\n        if let WalkTheDog::Loaded(walk) = self {\n            walk.backgrounds.iter().for_each(|background| {\n                background.draw(renderer);\n            });\n           ...\n```", "```rs\nfn update(&mut self, keystate: &KeyState) {\n   if let WalkTheDog::Loaded(walk) = self {\n       ...\n       walk.platform.position.x += walk.velocity();\n       walk.stone.move_horizontally(walk.velocity());\n       let velocity = walk.velocity();\n       let [first_background, second_background] = &mut \n        walk.backgrounds;\n       first_background.move_horizontally(velocity);\n       second_background.move_horizontally(velocity);\n       if first_background.right() < 0 {\n            first_background.set_x(\n             second_background.right());\n       }\n       if second_background.right() < 0 {\n            second_background.set_x(\n             first_background.right());\n       }\n       ...\n```", "```rs\nimpl Image {\n    ...\n    pub fn move_horizontally(&mut self, distance: i16) {\n        self.set_x(self.position.x + distance);\n    }\n    pub fn set_x(&mut self, x: i16) {\n        self.bounding_box.x = x as f32;\n        self.position.x = x;\n    }\n    pub fn right(&self) -> i16 {\n        (self.bounding_box.x + self.bounding_box.width) as \n         i16\n    }\n}\n```", "```rs\nimpl Rect {\n    pub fn intersects(&self, rect: &Rect) -> bool {\n        self.x < rect.right()\n        && self.right() > rect.x\n        && self.y < rect.bottom()\n        && self.bottom() > rect.y\n    }\n    pub fn right(&self) -> i16 {\n        self.x + self.width\n    }\n    pub fn bottom(&self) -> i16 {\n        self.y + self.height\n    }\n```", "```rs\nimpl Image {\n    ...\n    pub fn right(&self) -> i16 {\n        self.bounding_box.right()\n    }\n}\n```", "```rs\npub struct Rect {\n    pub position: Point,\n    pub width: i16,\n    pub height: i16,\n}\n```", "```rs\nimpl Rect {\n    pub fn new(position: Point, width: i16, height: i16) -> \n     Self {\n        Rect {\n            position,\n            width,\n            height,\n        }\n    }\n    pub fn new_from_x_y(x: i16, y: i16, width: i16, height: \n     i16) -> Self {\n        Rect::new(Point { x, y }, width, height)\n    }\n    ...\n```", "```rs\nimpl Rect {\n    ...\n    pub fn x(&self) -> i16 {\n        self.position.x\n    }\n    pub fn y(&self) -> i16 {\n        self.position.y\n    }\n```", "```rs\nimpl Rect {\n    ...\n    pub fn intersects(&self, rect: &Rect) -> bool {\n        self.x() < self.right()\n        && self.right() > rect.x()\n        && self.y() < rect.bottom()\n        && self.bottom() > rect.y()\n    }\n```", "```rs\nimpl Image {\n     pub fn new(element: HtmlImageElement, position: Point) \n      -> Self {\n        let bounding_box = Rect::new(position, \n         element.width() as i16, element.height() as i16);\n        ...\n```", "```rs\nimpl Rect {\n    ...\n    pub fn set_x(&mut self, x: i16) {\n        self.position.x = x\n    }\n}\n```", "```rs\nimpl Image {\n    ...\n    pub fn set_x(&mut self, x: i16) {\n        self.bounding_box.set_x(x);\n        self.position.x = x;\n    }\n```", "```rs\npub struct Image {\n    element: HtmlImageElement,\n    bounding_box: Rect,\n}\n```", "```rs\nimpl Image {\n    pub fn new(element: HtmlImageElement, position: Point) \n     -> Self {\n        let bounding_box = Rect::new(position, \n         element.width() as i16, element.height() as i16);\n        Self {\n            element,\n            bounding_box,\n        }\n    }\n    pub fn draw(&self, renderer: &Renderer) {\n        renderer.draw_entire_image(&self.element, \n         &self.bounding_box.position)\n    }\n    pub fn bounding_box(&self) ->&Rect {\n        &self.bounding_box\n    }\n    pub fn move_horizontally(&mut self, distance: i16) {\n        self.set_x(self.bounding_box.x() + distance);\n    }\n    pub fn set_x(&mut self, x: i16) {\n        self.bounding_box.set_x(x);\n    }\n    ...\n```", "```rs\npub trait Obstacle {\n    fn check_intersection(&self, boy: &mut RedHatBoy);\n    fn draw(&self, renderer: &Renderer);\n    fn move_horizontally(&mut self, x: i16);\n}\n```", "```rs\nimpl Obstacle for Platform {\n    fn draw(&self, renderer: &Renderer) {\n    ...\n    }\n    fn move_horizontally(&mut self, x: i16) {\n        self.position.x += x;\n    }\n}\n```", "```rs\nfor bounding_box in &walk.platform.bounding_boxes() {\n    if walk.boy.bounding_box().intersects(bounding_box) {\n        if walk.boy.velocity_y() > 0 && walk.boy.pos_y() < \n         walk.platform.position.y {\n            walk.boy.land_on(bounding_box.y);\n        } else {\n            walk.boy.knock_out();\n        }\n    }\n}\n```", "```rs\nimpl Obstacle for Platform {\n    ...\n    fn check_intersection(&self, boy: &mut RedHatBoy) {\n        if let Some(box_to_land_on) = self\n            .bounding_boxes()\n            .iter()\n            .find(|&bounding_box| boy.bounding_box()\n             .intersects(bounding_box))\n        {\n            if boy.velocity_y() > 0 && boy.pos_y() < \n             self.position.y {\n                boy.land_on(box_to_land_on.y());\n            } else {\n                boy.knock_out();\n            }\n        }\n    }\n}\n```", "```rs\nstruct Walk {\n    boy: RedHatBoy,\n    backgrounds: [Image; 2],\n    stone: Image,\n    platform: Box<dyn Obstacle>,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    ...\n                    platform: Box::new(platform),\n                })))\n            }\n            ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            let velocity = walk.velocity();\n            walk.platform.move_horizontally(velocity);\n            walk.stone.move_horizontally(velocity);\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            if second_background.right() < 0 {\n                second_background.set_x(\n                 first_background.right());\n            }\n            walk.platform.check_intersection(&mut \n             walk.boy);\n            if walk\n                .boy\n                .bounding_box()\n                .intersects(walk.stone.bounding_box())\n            {\n                 walk.boy.knock_out()\n            }\n```", "```rs\npub struct Barrier {\n    image: Image,\n}\nimpl Obstacle for Barrier {\n    fn check_intersection(&self, boy: &mut RedHatBoy) {\n        todo!()\n    }\n    fn draw(&self, renderer: &Renderer) {\n        todo!()\n    }\n    fn move_horizontally(&mut self, x: i16) {\n        todo!()\n    }\n}\n```", "```rs\nimpl Barrier {\n    pub fn new(image: Image) -> Self {\n        Barrier { image }\n    }\n}\n```", "```rs\nimpl Obstacle for Barrier {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        self.image.draw(renderer);\n    }\n    fn move_horizontally(&mut self, x: i16) {\n        self.image.move_horizontally(x);\n    }\n}\n```", "```rs\nimpl Obstacle for Barrier {\n    ...\n    fn check_intersection(&self, boy: &mut RedHatBoy) {\n        if boy.bounding_box().intersects(\n         self.image.bounding_box()) {\n              boy.knock_out()\n        }\n    }\n}\n```", "```rs\nstruct Walk {\n    boy: RedHatBoy,\n    backgrounds: [Image; 2],\n    obstacles: Vec<Box<dyn Obstacle>>,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n                ...\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    ...\n                    obstacles: vec![\n                        Box::new(Barrier::new(Image::new(\n                        stone, Point { x: 150, y: 546 }))),\n                        Box::new(platform),\n                    ],\n                })))\n                ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            if second_background.right() < 0 {\n                second_background.set_x(\n                 first_background.right());\n            }\n            walk.obstacles.iter_mut().for_each(|obstacle| {\n                obstacle.move_horizontally(velocity);\n                obstacle.check_intersection(&mut walk.boy);\n            });\n        }\n    }\n    ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        ...\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            walk.obstacles.iter().for_each(|obstacle| {\n                obstacle.draw(renderer);\n            });\n        }\n    }\n}\n```", "```rs\npanicked at 'attempt to add with overflow', src/engine.rs:289:20\nStack:\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            walk.obstacles.retain(|obstacle| \n             obstacle.right() > 0);\n            walk.obstacles.iter_mut().for_each(|obstacle| {\n                obstacle.move_horizontally(velocity);\n                obstacle.check_intersection(&mut walk.boy);\n            });\n            ...\n```", "```rs\ntrait Obstacle {\n    ...\n    fn right(&self) -> i16;\n}\n```", "```rs\nimpl Obstacle for Platform {\n    ...\n    fn right(&self) -> i16 {\n        self.bounding_boxes()\n            .last()\n            .unwrap_or(&Rect::default())\n            .right()\n    }\n}\n```", "```rs\npub struct SpriteSheet {\n    sheet: Sheet,\n    image: HtmlImageElement,\n}\n```", "```rs\nimpl SpriteSheet {\n    pub fn new(sheet: Sheet, image: HtmlImageElement) -> \n     Self {\n        SpriteSheet { sheet, image }\n    }\n    pub fn cell(&self, name: &str) -> Option<&Cell> {\n        self.sheet.frames.get(name)\n    }\n    pub fn draw(&self, renderer: &Renderer, source: &Rect, \n     destination: &Rect) {\n        renderer.draw_image(&self.image, source, destination);\n    }\n}\n```", "```rs\npub struct Platform {\n    sheet: SpriteSheet,\n    position: Point,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> \n    {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let platform = Platform::new(\n                    SpriteSheet::new(\n                        platform_sheet.into_serde::\n                         <Sheet>()?,\n                        engine::load_image(\n                         \"tiles.png\").await?,\n                    ),\n                    Point { x: 200, y: 400 },\n                );\n                ...\n```", "```rs\nstruct Walk {\n    obstacle_sheet: Rc<SpriteSheet>,\n    ...\n}\n```", "```rs\npub struct Platform {\n    sheet: Rc<SpriteSheet>,\n    ...\n}\nimpl Platform {\n    pub fn new(sheet: Rc<SpriteSheet>, position: Point) -> \n     Self {\n        Platform { sheet, position }\n    }\n    ...\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> \n    {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let tiles = browser::fetch_json(\n                 \"tiles.json\").await?;\n                let sprite_sheet = \n                 Rc::new(SpriteSheet::new(\n                    tiles.into_serde::<Sheet>()?,\n                    engine::load_image(\"tiles.png\").await?,\n                ));\n                let platform = Platform::new(\n                    sprite_sheet.clone(),\n                    Point {\n                        x: FIRST_PLATFORM,\n                        y: LOW_PLATFORM,\n                    },\n                );\n                ...\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    ...\n                    obstacles: vec![\n                        Box::new(Barrier::new(Image::new(\n                        stone, Point { x: 150, y: 546 }))),\n                        Box::new(platform),\n                    ],\n                    obstacle_sheet: sprite_sheet,\n                })))\n```", "```rs\npub struct Platform {\n    sheet: Rc<SpriteSheet>,\n    bounding_boxes: Vec<Rect>,\n    sprites: Vec<Cell>,\n    position: Point,\n}\n```", "```rs\nimpl Platform {\n    pub fn new(\n        sheet: Rc<SpriteSheet>,\n        position: Point,\n        sprite_names: &[&str],\n        bounding_boxes: &[Rect],\n    ) -> Self {\n        let sprites = sprite_names\n            .iter()\n            .filter_map(|sprite_name| \n             sheet.cell(sprite_name).cloned())\n            .collect();\n        ...\n```", "```rs\n        ...\n        let bounding_boxes = bounding_boxes\n            .iter()\n            .map(|bounding_box| {\n                Rect::new_from_x_y(\n                    bounding_box.x() + position.x,\n                    bounding_box.y() + position.y,\n                    bounding_box.width,\n                    bounding_box.height,\n                )\n            })\n            .collect();\n        Platform {\n            sheet,\n            position,\n            sprites,\n            bounding_boxes,\n        }\n    }\n```", "```rs\nimpl Platform {\n    ...\n    fn bounding_boxes(&self) -> &Vec<Rect> {\n        &self.bounding_boxes\n    }\n}\n```", "```rs\nimpl Obstacle for Platform {\n    ...\n    fn move_horizontally(&mut self, x: i16) {\n        self.position.x += x;\n        self.bounding_boxes.iter_mut()\n         .for_each(|bounding_box| {\n            bounding_box.set_x(bounding_box.position.x + \n             x);\n        });\n    }\n```", "```rs\nimpl Obstacle for Platform {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        let mut x = 0;\n        self.sprites.iter().for_each(|sprite| {\n            self.sheet.draw(\n                renderer,\n                &Rect::new_from_x_y(\n                    sprite.frame.x,\n                    sprite.frame.y,\n                    sprite.frame.w,\n                    sprite.frame.h,\n                ),\n                // Just use position and the standard \n                   widths in the tileset\n                &Rect::new_from_x_y(\n                    self.position.x + x,\n                    self.position.y,\n                    sprite.frame.w,\n                    sprite.frame.h,\n                ),\n            );\n            x += sprite.frame.w;\n        });\n    }\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> \n    {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let platform = Platform::new(\n                    sprite_sheet.clone(),\n                    Point {\n                        x: FIRST_PLATFORM,\n                        y: LOW_PLATFORM,\n                    },\n                    &[\"13.png\", \"14.png\", \"15.png\"],\n                    &[\n                        Rect::new_from_x_y(0, 0, 60, 54),\n                        Rect::new_from_x_y(60, 0, 384 - (60 \n                         * 2), 93),\n                        Rect::new_from_x_y(384 - 60, 0, 60, \n                         54),\n                    ],\n                );\n                ...\n```", "```rs\npub fn stone_and_platform(\n    stone: HtmlImageElement,\n    sprite_sheet: Rc<SpriteSheet>,\n    offset_x: i16,\n) -> Vec<Box<dyn Obstacle>> {\n    const INITIAL_STONE_OFFSET: i16 = 150;\n    vec![\n        Box::new(Barrier::new(Image::new(\n            stone,\n            Point {\n                x: offset_x + INITIAL_STONE_OFFSET,\n                y: STONE_ON_GROUND,\n            },\n        ))),\n        Box::new(create_floating_platform(\n            sprite_sheet,\n            Point {\n                x: offset_x + FIRST_PLATFORM,\n                y: LOW_PLATFORM,\n            },\n        )),\n    ]\n}\n```", "```rs\nfn create_floating_platform(sprite_sheet: Rc<SpriteSheet>, position: Point) -> Platform {\n    Platform::new(\n        sprite_sheet,\n        position,\n        &FLOATING_PLATFORM_SPRITES,\n        &FLOATING_PLATFORM_BOUNDING_BOXES,\n    )\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> \n    {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    ...\n                    obstacles: stone_and_platform(stone, \n                    sprite_sheet.clone(), 0),\n                    obstacle_sheet: sprite_sheet,\n                })))\n```", "```rs\nfn rightmost(obstacle_list: &Vec<Box<dyn Obstacle>>) -> i16 {\n    obstacle_list\n        .iter()\n        .map(|obstacle| obstacle.right())\n        .max_by(|x, y| x.cmp(&y))\n        .unwrap_or(0)\n}\n```", "```rs\nstruct Walk {\n    ...\n    stone: HtmlImageElement,\n    timeline: i16,\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> \n    {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let starting_obstacles = stone_and_platform\n                 (stone.clone(), sprite_sheet.clone(), 0);\n                let timeline = rightmost(\n                 &starting_obstacles);\n                Ok(Box::new(WalkTheDog::Loaded(Walk {\n                    ...\n                    obstacles: starting_obstacles,\n                    obstacle_sheet: sprite_sheet,\n                    stone,\n                    timeline,\n                })))\n            }\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            walk.obstacles.iter_mut().for_each(|obstacle| {\n                obstacle.move_horizontally(velocity);\n                obstacle.check_intersection(&mut walk.boy);\n            });\n            if walk.timeline < TIMELINE_MINIMUM {\n                let mut next_obstacles = \n                 stone_and_platform(\n                    walk.stone.clone(),\n                    walk.obstacle_sheet.clone(),\n                    walk.timeline + OBSTACLE_BUFFER,\n                );\n                walk.timeline = rightmost(&next_obstacles);\n                walk.obstacles.append(&mut next_obstacles);\n            } else {\n                walk.timeline += velocity;\n            }\n        }\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            if walk.timeline < TIMELINE_MINIMUM {\n                walk.generate_next_segment()\n            } else {\n                walk.timeline += velocity;\n            }\n        }\n        ...\n    }\n}\nimpl Walk {\n    ...\n    fn generate_next_segment(&mut self) {\n        let mut next_obstacles = stone_and_platform(\n            self.stone.clone(),\n            self.obstacle_sheet.clone(),\n            self.timeline + OBSTACLE_BUFFER,\n        );\n        self.timeline = rightmost(&next_obstacles);\n        self.obstacles.append(&mut next_obstacles);\n    }\n}\n```", "```rs\nimpl Walk {\n    ...\n    fn generate_next_segment(&mut self) {\n        let mut rng = thread_rng();\n        let next_segment = rng.gen_range(0..1);\n        let mut next_obstacles = match next_segment {\n            0 => stone_and_platform(\n                self.stone.clone(),\n                self.obstacle_sheet.clone(),\n                self.timeline + OBSTACLE_BUFFER,\n            ),\n            _ =>vec![],\n        };\n        self.timeline = rightmost(&next_obstacles);\n        self.obstacles.append(&mut next_obstacles);\n    }\n}\n```", "```rs\nimpl Walk {\n    ...\n    fn generate_next_segment(&mut self) {\n        let mut rng = thread_rng();\n        let next_segment = rng.gen_range(0..2);\n        let mut next_obstacles = match next_segment {\n            0 => stone_and_platform(\n                self.stone.clone(),\n                self.obstacle_sheet.clone(),\n                self.timeline + OBSTACLE_BUFFER,\n            ),\n            1 => platform_and_stone(\n                self.stone.clone(),\n                self.obstacle_sheet.clone(),\n                self.timeline + OBSTACLE_BUFFER,\n            ),\n            _ =>vec![],\n        };\n        self.timeline = rightmost(&next_obstacles);\n        self.obstacles.append(&mut next_obstacles);\n    }\n}\n```"]