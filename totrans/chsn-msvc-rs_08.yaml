- en: Interaction to Database with Object-Relational Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to interact with databases, but this time
    we will explore **object-relational mapping** (**ORM**) using the `diesel` crate. 
    This crate helps with generating Rust types that represent tables and records
    in SQL databases. ORM allows you to use native data structs in code and maps records
    and database tables to them. It's useful because the compiler takes care of matching
    types of data columns in a database and structs in source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this chapter you will be familiar with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `diesel` crate with `r2d2` pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and applying migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data with ORM types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use the SQLite embedded database. You don't need to
    install and run databases, but you need development packages from the PostgreSQL,
    MySQL, and SQLite databases. Install them on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: The diesel crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about interacting with different databases.
    But the approach we discussed has potential difficulties—you have to check the
    raw requests you add to your application. It's better if the Rust compiler controls
    the structure of the data and generates all the necessary requests for the declared
    structs. This formal and strict approach is possible with the `diesel` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has an awesome feature that creates macros and generates code. It allowed
    the creators of the `diesel` crate to create a domain-specific language to query
    data from a database. To start using this crate, we need to add it to a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the necessary dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new crate and add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the `clap`, `r2d2`, and `serde` crates along with the `serde_derive`
    crate. We also need the `uuid` crate for generating user IDs. We also added the `diesel`
    crate with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlite`: To adapt the crate to use the SQLite database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r2d2`: To use a pool instead of a plain connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next thing you need is the `diesel_cli` tool.
  prefs: []
  type: TYPE_NORMAL
- en: diesel_cli
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`diesel_cli` is needed to create migrations and apply them. To install the
    tool, use `cargo` with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However you need development packages for PostgreSQL, MySQL, and SQLite to
    build this tool. If you don''t have or can''t install them, you can pass special
    parameters to `cargo install`. For example, if you want to use `diesel_cli` with
    the example in this chapter, it''s enough to install the tool with the `sqlite`
    feature only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have installed the `diesel-cli` tool, run it to prepare the application
    using the `setup` command to use the `diesel` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to prepare all the necessary migrations for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command creates a `migrations` folder, where you can store migrations
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a migration called `<name>` and stores it in the  `migrations` folder.
    For example, if you set the name of the created migration to `create_tables`,
    you will see in the following structure in the `migrations` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For every migration, the `generate` command creates a folder and a pair of
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`up.sql`: Statements for applying migrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down.sql`: Statements for reverting migrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All migrations are handwritten. Add all the necessary statements for the migrations
    yourself. For our example, we need the following statements in the `up.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite statement is in the `down.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Applying the `up.sql` script creates the `users` database with the same struct
    we used in the previous chapter. The revert script drops the users table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create the database and apply all the migrations with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We set `DATABASE_URL` to `test.db` to create a SQLite database in the current
    folder. The `run` command runs all the migrations in order. You can have multiple
    migrations and move from one structure level to another, both forward and backward.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful! You can have multiple migrations, but you can't have competing migrations
    from different projects to the same database. The problem of automatic migrations
    is that you can't do it from multiple services, or you can't even start a microservice
    if it will try to migrate the database after another microservice has already
    migrated it.
  prefs: []
  type: TYPE_NORMAL
- en: We have created migrations, and now we have to declare the data structure in
    Rust sources.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our tool will have two modules with a data structure. The first is the `src/schema.rs`
    module, which contains a `table!` macro call that declares the fields of every
    table. In our case, this module contains the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This file was automatically generated by the `diesel setup` command. When you
    run a setup, it creates a `diesel.toml` configuration file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the config has a schema module reference. A `schema.rs` file
    is also generated, and will be updated on every compilation. The `table!` macro
    creates the required declaration of DSL for the tables used.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Schema declaration defines a table structure only. To map tables to Rust types,
    you have to add a module with models that will be used to convert records from
    the `users` table to native Rust types. Let''s create one and call it `models.rs`.
    It will contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We declared two models here: `User` to represent a user in a database and `NewUser` for
    creating a new record of a user. We derive the necessary traits for the `User`
    struct. The `Queryable` trait is implemented to allow you get this type from a
    database using queries.
  prefs: []
  type: TYPE_NORMAL
- en: There is the `Insertable` trait, which is derived from the `NewUser` struct.
    This trait allows a struct to be inserted as a new row in a table. This derivation
    requires an annotation with the name of the table. We can set it to the `users`
    table with the `#[table_name = "users"]` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The database structure has been prepared, and we can start to use the database
    from an application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our tool, we will implement two subcommands—`add` to add a new user, and
    `list` to retrieve all available users from the database. Import all the necessary
    dependencies and add the modules with `schema` and `models`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `r2d2` crate, we also have to import `ConnectionManager` to
    use diesel's abstraction over the traditional database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Modules declared with the `pub` modifier make them available in documentation.
    It's useful for modules that are generated by the `diesel` crate so that you can
    explore the functions provided by a generated DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the examples in the previous chapter, we have a parser for arguments.
    It has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can get `--database` arguments with a path to a database file. The  `add` subcommand
    requires two arguments—`NAME` with the name of a user, and `EMAIL` with their
    email. The `list` subcommand doesn't require extra arguments and will print a
    list of users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a connection, we extract the path to a database. Since we are using
    the SQLite database, in contrast to the previous examples, we don''t expect a
    URL, but instead a path to a database file. That''s why we use the `test.db` filename
    instead of a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`r2d2::Pool` requires a `ConnectionManager` instance to establish connections
    with a database, and we can provide `SqliteConnection` as an associated type to
    use the SQLite database. We provide a path to a database extracted from command-line
    arguments. Now let''s look at how to use a generated DSL to interact with a database.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing subcommands using a DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `diesel` crate generates a DSL for us to construct typed queries in a simple
    way. All instructions are generated as a submodule of schema and are available
    for every generated table mapping with a module path such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement two commands using generated typed relations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a user subcommand implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first subcommand of our users management tool is `add`. This command extracts
    the `NAME` and `EMAIL` of the user from the arguments and generates a new user
    identifier using the `uuid` crate. We will use this type across all our microservices.
    Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After we have extracted all the parameters, we create a `NewUser` instance from
    the `models` module. It requires references to values, and we don't need to pass
    ownership to values and reuse them in multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: The last line uses the `insert_into` function, which generates an `INSERT INTO`
    statement for the provided tables, but instead of textual names of tables, such
    as  `"users"`, we use the `table` type from the users `module` of schema. It helps
    you to see all the mistypes at compile time. We set the value for this request
    with the `values` function call. As a value, we use a reference to the `NewUser`
    instance because this map is already mapped to the ***users*** table in the struct
    declaration. To execute a statement, we call the `execute` function of the `InsertStatement`
    instance which is generated by the `values` method call.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute` method expects a reference to a connection that we have already
    extracted from a pool.
  prefs: []
  type: TYPE_NORMAL
- en: Listing users subcommand implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example of data insertion, we didn't use the generated `users`
    type, and used the `table` nested type only. To list users in the implementation
    of the `list` subcommand, we will use types from the `dsl` submodule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build some documentation and look into the `users::schema::users::dsl`
    module, you will see the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All types are quite complex, and you can see all the features in the documentation.
    Since the `users` table type implements the `AsQuery` trait, we can use the `load`
    method of the `RunQueryDsl` trait for the `users` type. We set the associated
    type to `model::Users` to extract this type from the table. We also don''t need
    any manual extractions like we did in the previous chapter. The `load` method
    expects a `Connection` that we `get` from a `Pool` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can simply iterate over the users collections. That's pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to construct more complex requests, you can use other DSL functions
    that are generated by the `diesel` crate during building. For example, you can
    filter users by domain name and limit the quantity of users in a list with the
    following DSL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have filtered all users by the `example.com` domain using the `filter` method
    with a parameter created by the `like` method call of the `email` column.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our tool. Compile and run it with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add filtering and call the `list` subcommand, you will see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We got a perfect example of mapping pure Rust types to relational database types.
  prefs: []
  type: TYPE_NORMAL
- en: Complex database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered one example with a single table. In this section, we will create
    an example with a complex table structure to cover holistic database interaction.
    We will develop a separate crate for database interaction that covers the functionality
    of a complex chat application—chat with users, channels, and roles. Also, we will
    test the functionality we have implemented and show you how to test the database
    interaction layer of the Rust application.
  prefs: []
  type: TYPE_NORMAL
- en: Business logic of the example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to transform data relations into ORM models.
    We will implement a database interaction crate for a chat application. Imagine,
    we need to express these data relations in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d814f00c-892e-439a-be5c-89a444c2afc9.png)'
  prefs: []
  type: TYPE_IMG
- en: We have four tables. The first table contains users. It's the main table and
    is used by all the other tables. Every user can create a channel and become the
    owner of a channel. The second table contains channels, and every channel has
    the owner represented by a record in the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: In our chat application, every user can join a channel and post messages to
    it. To maintain this relation, we will add a `memberships` table that contains
    records with two references—a user who is a member of a channel and a channel
    record that contains a user as a member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, users can post messages to channels. We will keep all messages in a separate
    `messages` table. Every message has two relations: the channel that contains the
    message and the user who posted the message.'
  prefs: []
  type: TYPE_NORMAL
- en: API methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To maintain the data, we need to provide the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`register_user`: Adds a new user to the `users` table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_channel`: Creates a new channel with the provided user as the owner
    of the channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish_channel`: Makes the channel public'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_member`: Adds a member to a channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_message`: Adds a message from a user to a channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_message`: Deletes a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that we don't have methods to delete a channel, but we
    have a method to delete a message. That's because users can post a message accidentally,
    which they may want to delete. Perhaps the user posts some private information
    that they want removed from the database.
  prefs: []
  type: TYPE_NORMAL
- en: We don't allow the deletion of channels and users, because they are an important
    part of the business logic. If user deletes a channel, then all the messages from
    other users will be deleted as well. It's not a behavior other users want.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a deleting feature, you can add a boolean column to every table
    that means the record was deleted. Don't delete the physical record, but mark
    it as deleted. You can add it yourself to this example. In real cases you also
    have to take into account the laws in the country that the user lives in, because
    they can require the physical deletion of records.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can express these relations in Rust with ORM using the `diesel` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Database structure and migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the database structure. We need four tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users`: Contains users'' accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channels`: Contains channels created by users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memberships`: Users belonging to a channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages`: Messages of users in channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add these tables, we will add four migrations to a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands created these migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, every migration folder contains two files: `up.sql` and
    `down.sql`. Now, we can add SQL statements to execute the necessary migration
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Diesel initial setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first migration is `diesel_initial_setup`. It was created by the `diesel`
    CLI tool automatically and contains a function to set a trigger to update the `updated_at`
    column of a table. We will use this feature for the channel table. Like every
    migration, it consists of two files.
  prefs: []
  type: TYPE_NORMAL
- en: up.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This SQL file contains two statements. The first is the `diesel_manage_updated_at`
    function, whichcreates a trigger for a table to call the `diesel_set_updated_at`
    function for each row update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function only executes the `CREATE TRIGGER` statement for a table you provided
    with the `_tbl` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function is `diesel_set_updated_at`, which updates the `updated_at`
    column with the current timestamp if the processed row has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To make this function work, you have to add the `updated_at` column to your
    table and a field with the same name to your model. We will do this for the `channel`
    table later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: down.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The down script removes both functions, if they exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This was a default migration created by the `diesel` tool. As you can see, it
    contains a functionality you can drop or replace with your own. Now, we can add
    the `users` table to the next migration.
  prefs: []
  type: TYPE_NORMAL
- en: Users table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second migration is `create_users`. It creates a `users` table that is required
    to keep all the users' accounts in a database. To create this table, we create
    a separate migration that contains two scripts—one to create the `users` table
    and one to drop it.
  prefs: []
  type: TYPE_NORMAL
- en: up.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following statement to the `up.sql` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the table has two columns. `id` represents the unique ID of
    the user, and we will use this identifier in other tables later. The `email` column
    contains the unique e-mail of the user. For real applications, the `users` table
    also has to contain a hashed password, and two columns to store when the user
    was created and updated.
  prefs: []
  type: TYPE_NORMAL
- en: down.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The down script drops the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the users' IDs to create channels.
  prefs: []
  type: TYPE_NORMAL
- en: Channels table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third migration is `create_channels`. It creates a `channels` table that
    contains all of the channels that have been created by users. Channels can be
    private or public, and each has a title. Let's look at a script that creates a
    table of channels in a database.
  prefs: []
  type: TYPE_NORMAL
- en: up.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The up script contains a statement that creates the `channels` table. Columns
    includes the channel `id` and `user_id` , which refers to the user in the `users`
    table. The channel also has a `title` column and an `is_public` column that contains
    a flag that represents the visibility of the channel. If `is_public` equals `TRUE`,
    it means the channel is public. Look at the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The table also has two columns—`create_at`, which takes the current timestamp
    when the row is created, and `updated_at`, which contains the timestamp of the
    latest update of the row. By default, the `updated_at` column takes the current
    timestamp as the default value on creation.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, diesel creates a `diesel_manage_updated_at` function
    that sets a trigger to a table, which updates the `updated_at` column of rows
    automatically when the row is updated. Since we have the `updated_at` column in
    the table declaration, we can call this function in the `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: down.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The down script drops the `channels` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `up.sql` script,we created a trigger with a `diesel_manage_updated_at`
    call, but we don't need to drop it manually, because it is automatically removed
    with the table.
  prefs: []
  type: TYPE_NORMAL
- en: Memberships table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth migration is `create_memberships`. It creates a `memberships` table
    that is necessary to manage the participants of the channel who can read messages
    and write new ones. This table depends on both the `users` and `channels` tables.
  prefs: []
  type: TYPE_NORMAL
- en: up.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `up` script is simple and contains a statement that creates the memberships
    table with three fields—the `id` of a membership, the `id` of a channel in the `channel_id`
    column whose member is a user with the `user_id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: down.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The down script drops the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We now need to add a table that stores messages that users have posted to the
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: Messages table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fifth migration is `create_messages`. It creates a `messages` table that
    contains every message that has been written by the users.
  prefs: []
  type: TYPE_NORMAL
- en: up.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the following up script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It creates a table that contains a message that is associated with a channel
    and a user by ID. Also, it contains a timestamp showing when the messages were
    added, as well as the text of each message.
  prefs: []
  type: TYPE_NORMAL
- en: down.sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The down script drops the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have finished all the migrations, and now we can look at the schema that
    was generated by the `diesel` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`diesel` creates a schema file that contains macro calls that generate a DSL
    language to use in the sources of your crate. A schema of tables that have relations
    to each other need extra declarations. Let''s explore a generated schema in the `src/schema.rs`
    file to see how it differs from the simple schema we created earlier in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table is `users`. It has the same columns we declared in the SQL
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `table!` macro will be expanded during compilation to some type and trait
    implementations that you can see with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This command prints all expanded macros to a Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diesel tool has also generated a DSL declaration for the `channels` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `memberships` table, we have this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the `messages` table, we have this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'But you might have noticed that the table declarations don''t contain any information
    about relations. Relations created by the `joinable!` macro expect a table name
    and a parent table with the ID column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'All relations are listed with the `joinable!` macro, but the schema also contains
    a `allow_tables_to_appear_in_same_query!` macro call that represents which tables
    can be used in `JOIN` queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we have a complete schema declaration with all relations, we can declare
    models with the same relations as native Rust structs.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can use the generated schema to create all the necessary models that
    represent database records to native Rust structs. First, we have to import the `NaiveDateTime`
    type, because we have the timestamp column. Also, we have to import all tables:
    `users`, `channels`, `memberships`, and `messages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `i32` type as the identifier of records, but it''s better to
    use an alias to make its intent more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a model to represent a record in the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: User
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To represent a user stored in the `users` table, we will add a `User` struct
    with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `Id` type for the ID column that has the `SERIAL`
    SQL type. For the email field, we use the String type, which maps to the `TEXT`
    column type in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `table_name` attribute to bind this struct with a table. We
    also derive some traits for this model—`Debug` for printing the model's value
    to a terminal, and the `Serialize` and `Deserialize` traits to make this model
    convertible to any serialization format. Theser are basic traits that I recommend
    to implement for database models, especially if you want to use the same types
    in a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The `Queryable` trait represents the result of SQL expressions that can be converted
    in a struct that implements the trait. This lets us convert tuples to the `User`
    struct in our database interaction API later.
  prefs: []
  type: TYPE_NORMAL
- en: The `Identifiable` trait means the struct that implements this trait represents
    a single record in a table. This trait has an associated `Id` type that is set
    to the corresponding type in the SQL table. This trait also contains an `id` method
    that returns the identifier of a record in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next model is `Channel`, which represents a record in the `channels` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This model binds to a table using the `table_name` attribute and contains all
    the fields that map to the corresponding columns of the table. To represent the `TIMESTAMP`
    SQL type, we use `NaiveDateTime` from the `chrono` crate.
  prefs: []
  type: TYPE_NORMAL
- en: The model has a `user_id` field that maps to a record in the `users` table.
    To indicate whether a `User` model belongs to the `users` table, we added the `belongs_to`
    attribute to this model. The model also has to implement the `Associations` trait.
    If the model does that, you can use the `belonging_to` method of a model to get
    records belonging to other records with a parental relation.
  prefs: []
  type: TYPE_NORMAL
- en: Membership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To represent records in the memberships model, we added the `Membership` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This model has set relations with the `Channel` and `User` models. For example,
    if you want to get all the memberships of a user, you can use the `belonging_to`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last model we need is `Message`, which relates to the records in the `messages`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This model also uses derived traits which we discussed in the first example.
    Now, we can implement our database interaction crate using the generated schema
    and the declared models.
  prefs: []
  type: TYPE_NORMAL
- en: Database interaction API crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add an implementation of the database interaction API to the `lib.rs`
    source file. We need to import the `diesel` crate and declare the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we have added two modules: `models` and `schema`. In the implementation,
    we need the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The imports include all models and all tables. We also imported the `Connection`
    trait to the `establish` connection, the `ExpressionMethods` trait to use the `eq`
    method of DSL to set the equality of columns to values, the `OptionalExtension` trait
    to use the `optional` method to try to get a record that cannot be in a table,
    the `QueryDsl` trait that has the `filter` method, and `RunQueryDsl` to use the `get_result`
    method that tries to convert a record to the Rust type. The `insert_into` method
    lets us insert new records into a table. Now, we have everything we need to declare
    the `Api` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Api
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will declare a struct with a connection instance inside and add methods
    over this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Api` struct can be created with the `connect` method, which uses the `DATABASE_URL`
    environment variable to bootstrap a connection to PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We use a direct connection here without an `r2d2` pool, but you can also make
    the `Api` struct compatible with concurrent access. Let's add first the API method
    for registering new users.
  prefs: []
  type: TYPE_NORMAL
- en: Register user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To register a new user with an email address, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `register_user` function expects a string with the email of a user, adds
    a record to a database, and returns a `User` instance, which represents a record
    in the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `insert_into` method with a table type from the users scope, which
    is automatically created by the `table!` macro in the `schema` module. This method
    returns an `IncompleteInsertStatement` instance that provides a `values` method
    to set values with an `INSERT` statement. We set the `email` column equal to the `email`
    variable. The `values` method call returns an `InsertStatement` type instance
    that has the `returning` method to set columns that will be returned with this
    statement. We set the returning values to the `id` and `email` columns of the `users`
    table. The `returning` method takes ownership of a statement and returns a new `InsertStatement`
    instance with the returning values.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we call the `get_result` method of the `InsertStatement` struct
    to execute the statement and convert the result to the `User` model. Because we
    have a different error type of `Result`, we have to convert the `diesel::result::Error`
    type returned by the `get_result`, method call to the `failure::Error` type.
  prefs: []
  type: TYPE_NORMAL
- en: Create channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next method is `create_channel`, which creates a new channel for a user.
    Take a look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The function expects `user_id`, the `title` of a channel, and the `is_public`
    flag, which means the channel is public.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have to add the user who created the channel as the first member of
    a created channel, we will join two statements to a single transaction. To create
    a transaction with `diesel`, you can use the `transaction` method of the `Connection`
    instance. This method expects three type parameters—successful value type, error
    value type, and a type of a closure provided as a single argument with a function
    call. We skip all types, because the compiler can detect them.
  prefs: []
  type: TYPE_NORMAL
- en: In the transaction implementation we create a `Channel` model instance that
    represents a new record in a database. After that, we use the `add_member` method
    of our `Api` struct. As you can see, neither the transaction and connection instances
    need a mutable reference, and we can combine multiple methods to get an immutable
    reference to a `Connection` instance. You will see the implementation of the `add_member`
    method later, but now we will add a method to update a channel's record in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Publish channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add a method that sets the `is_public` flag of a channel record to
    `true`. Look at the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The function expects `channel_id`, and we use the `table` value to create a
    statement. We use the `filter` method of the `QueryDsl` trait to get a single
    record with the provided ID, and the `select` method of the same trait to extract
    values from the table needed for conversion to the `Channel` model instance. Then,
    we call the `first` method that returns the first record found with the executed
    statement. If no record is found, it will return an error, but since `Result`
    types are returned, we can drop the error part of this by converting it in `Option` with
    the `optional` method call. It lets us decide later what to do if a record hasn't
    been found later.
  prefs: []
  type: TYPE_NORMAL
- en: If a record is found, we use the `update` method with a reference to a `Channel`
    model. This call returns an `UpdateStatement` value, which has a `set` method
    that we use to set the `is_public` column to `true`. At the end, we `execute`
    this statement for a connection instance. This call also updates the `updated_at`
    column of the record automatically since we registered a trigger for the `channels`
    table. Now, we can implement the `add_member` function.
  prefs: []
  type: TYPE_NORMAL
- en: Add member
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `add_member` function requires a channel ID and a user ID to add a membership
    record to the `memberships` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is simple and it uses the `insert_into` function call to
    prepare the `INSERT` statement to insert a new `Membership` value in the table.
    We also need a function to add new messages to a channel.
  prefs: []
  type: TYPE_NORMAL
- en: Add message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `add_message` method adds a message related to a channel and a user to
    the `messages` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The implementation also uses the `insert_into` function, but we also created
    the timestamp manually. You can avoid setting this field manually and set a default
    value to the current timestamp in the `timestamp` column.
  prefs: []
  type: TYPE_NORMAL
- en: Delete message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you posted a message and decided to remove it, we need a method to delete
    messages from `messages` table. Look at `delete_message` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the `delete` method, which returns a `DeleteStatement` instance,
    which has a `filter` method as well. We set a filter with the `id` column equal
    to the provided `message_id` and execute the generated `DELETE` SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's all, and now we have a crate that can be used to interact with a database.
    Since it's not binary, we need to guarantee that the code works correctly. It's
    a good practice to cover your code with tests, and we will do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `lib.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We added a `test` module and a `create_users` testing function. This function
    tests all the API methods we implemented. It creates an `Api` instance with a
    connect method call and uses that instance to register two users with the following
    emails—`"user_1@example.com"` and `"user_2@example.com"`. After that, it creates
    a channel for the first user, publishes it, and add the second user as a member.
    At the end, it adds two messages and deletes the first one. Let's run this test,
    but you have to run a PostgreSQL database instance with Docker. You can read how
    to do this in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply all the migrations and run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When the testing is over, you will get a message with from the `psql` client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test added two records and removed the first. In [Chapter
    13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing and Debugging Rust Microservices*,
    we will discuss testing microservices in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use object-relational mapping to store
    and load pure Rust types to databases. First, we created migrations with the `diesel-cli`
    tool that comes with the `diesel` crate. After that, we added models to map columns
    to Rust types and created a minimal connection using the `r2d2` crate with a `diesel`
    crate abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched on DSL constructs. however the `diesel` crate provides a lot
    of features, and if you want to construct more complex queries, you can refer
    to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some frameworks that simplify writing
    microservices and let you implement your ideas faster.
  prefs: []
  type: TYPE_NORMAL
