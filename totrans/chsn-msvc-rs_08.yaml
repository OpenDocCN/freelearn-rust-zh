- en: Interaction to Database with Object-Relational Mapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象关系映射（ORM）与数据库交互
- en: In this chapter, we will continue to interact with databases, but this time
    we will explore **object-relational mapping** (**ORM**) using the `diesel` crate. 
    This crate helps with generating Rust types that represent tables and records
    in SQL databases. ORM allows you to use native data structs in code and maps records
    and database tables to them. It's useful because the compiler takes care of matching
    types of data columns in a database and structs in source code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续与数据库交互，但这次我们将使用 `diesel` crate 探索对象关系映射（ORM）。这个 crate 帮助生成代表 SQL 数据库中表和记录的
    Rust 类型。ORM 允许您在代码中使用原生数据结构，并将记录和数据库表映射到它们。它很有用，因为编译器会负责匹配数据库中的数据列和源代码中的结构体的类型。
- en: 'After reading this chapter you will be familiar with the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将熟悉以下内容：
- en: Using the `diesel` crate with `r2d2` pools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `diesel` crate 与 `r2d2` 池
- en: Generating and applying migrations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和应用迁移
- en: Accessing data with ORM types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ORM 类型访问数据
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will use the SQLite embedded database. You don't need to
    install and run databases, but you need development packages from the PostgreSQL,
    MySQL, and SQLite databases. Install them on your system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 SQLite 嵌入式数据库。您不需要安装和运行数据库，但您需要 PostgreSQL、MySQL 和 SQLite 数据库的开发包。在您的系统上安装它们。
- en: 'You can find examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08.](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter08)
- en: The diesel crate
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: diesel crate
- en: In the previous chapter, we learned about interacting with different databases.
    But the approach we discussed has potential difficulties—you have to check the
    raw requests you add to your application. It's better if the Rust compiler controls
    the structure of the data and generates all the necessary requests for the declared
    structs. This formal and strict approach is possible with the `diesel` crate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何与不同的数据库交互。但我们讨论的方法存在潜在困难——您必须检查添加到应用程序中的原始请求。如果 Rust 编译器控制数据的结构并生成所有必要的请求，那么会更好。这种正式和严格的方法可以通过
    `diesel` crate 实现。
- en: Rust has an awesome feature that creates macros and generates code. It allowed
    the creators of the `diesel` crate to create a domain-specific language to query
    data from a database. To start using this crate, we need to add it to a new project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有一个很棒的功能可以创建宏并生成代码。它允许 `diesel` crate 的创建者创建一个特定领域的语言来查询数据库中的数据。要开始使用这个
    crate，我们需要将其添加到一个新项目中。
- en: Adding the necessary dependencies
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加必要的依赖项
- en: 'Create a new crate and add the following dependencies:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 crate 并添加以下依赖项：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have added the `clap`, `r2d2`, and `serde` crates along with the `serde_derive`
    crate. We also need the `uuid` crate for generating user IDs. We also added the `diesel`
    crate with the following features:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `clap`、`r2d2` 和 `serde` crate，以及 `serde_derive` crate。我们还需要 `uuid` crate
    来生成用户 ID。我们还添加了具有以下功能的 `diesel` crate：
- en: '`sqlite`: To adapt the crate to use the SQLite database'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite`：使 crate 能够使用 SQLite 数据库'
- en: '`r2d2`: To use a pool instead of a plain connection'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r2d2`：使用池而不是普通连接'
- en: The next thing you need is the `diesel_cli` tool.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步您需要的是 `diesel_cli` 工具。
- en: diesel_cli
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: diesel_cli
- en: '`diesel_cli` is needed to create migrations and apply them. To install the
    tool, use `cargo` with the following parameters:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`diesel_cli` 是创建迁移并应用它们所必需的。要安装此工具，请使用以下参数的 `cargo`：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However you need development packages for PostgreSQL, MySQL, and SQLite to
    build this tool. If you don''t have or can''t install them, you can pass special
    parameters to `cargo install`. For example, if you want to use `diesel_cli` with
    the example in this chapter, it''s enough to install the tool with the `sqlite`
    feature only:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您需要 PostgreSQL、MySQL 和 SQLite 的开发包来构建这个工具。如果您没有或无法安装它们，您可以在 `cargo install`
    中传递特殊参数。例如，如果您想在本章的示例中使用 `diesel_cli`，只需安装具有 `sqlite` 功能的工具即可：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you have installed the `diesel-cli` tool, run it to prepare the application
    using the `setup` command to use the `diesel` crate:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装了 `diesel-cli` 工具后，运行它，使用 `setup` 命令准备应用程序以使用 `diesel` crate：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have to prepare all the necessary migrations for our example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为我们的示例准备所有必要的迁移。
- en: Creating migrations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建迁移
- en: 'This command creates a `migrations` folder, where you can store migrations
    using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个 `migrations` 文件夹，你可以使用以下命令存储迁移：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command creates a migration called `<name>` and stores it in the  `migrations` folder.
    For example, if you set the name of the created migration to `create_tables`,
    you will see in the following structure in the `migrations` folder:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个名为 `<name>` 的迁移并将其存储在 `migrations` 文件夹中。例如，如果你将创建的迁移的名称设置为 `create_tables`，你将在
    `migrations` 文件夹中看到以下结构：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For every migration, the `generate` command creates a folder and a pair of
    files:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个迁移，`generate` 命令都会创建一个文件夹和一对文件：
- en: '`up.sql`: Statements for applying migrations'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up.sql`：应用迁移的语句'
- en: '`down.sql`: Statements for reverting migrations'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down.sql`：回滚迁移的语句'
- en: 'All migrations are handwritten. Add all the necessary statements for the migrations
    yourself. For our example, we need the following statements in the `up.sql` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有迁移都是手写的。你需要自己添加所有必要的迁移语句。以我们的例子为例，我们需要在 `up.sql` 文件中添加以下语句：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The opposite statement is in the `down.sql` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的语句在 `down.sql` 文件中：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Applying the `up.sql` script creates the `users` database with the same struct
    we used in the previous chapter. The revert script drops the users table.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 `up.sql` 脚本会创建与我们在上一章中使用的相同结构的 `users` 数据库。回滚脚本会删除用户表。
- en: 'Now, we can create the database and apply all the migrations with this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此命令创建数据库并应用所有迁移：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We set `DATABASE_URL` to `test.db` to create a SQLite database in the current
    folder. The `run` command runs all the migrations in order. You can have multiple
    migrations and move from one structure level to another, both forward and backward.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `DATABASE_URL` 设置为 `test.db` 以在当前文件夹中创建一个 SQLite 数据库。`run` 命令按顺序运行所有迁移。你可以有多个迁移，并且可以从一个结构级别移动到另一个，无论是向前还是向后。
- en: Be careful! You can have multiple migrations, but you can't have competing migrations
    from different projects to the same database. The problem of automatic migrations
    is that you can't do it from multiple services, or you can't even start a microservice
    if it will try to migrate the database after another microservice has already
    migrated it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！你可以有多个迁移，但你不能有来自不同项目到同一数据库的竞争迁移。自动迁移的问题是你不能从多个服务中进行，或者如果你在另一个微服务已经迁移数据库之后尝试迁移数据库，甚至无法启动一个微服务。
- en: We have created migrations, and now we have to declare the data structure in
    Rust sources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了迁移，现在我们必须在 Rust 源代码中声明数据结构。
- en: Declaring the data structure
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明数据结构
- en: 'Our tool will have two modules with a data structure. The first is the `src/schema.rs`
    module, which contains a `table!` macro call that declares the fields of every
    table. In our case, this module contains the following declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将有两个包含数据结构的模块。第一个是 `src/schema.rs` 模块，它包含一个 `table!` 宏调用，用于声明每个表的字段。在我们的例子中，此模块包含以下声明：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This file was automatically generated by the `diesel setup` command. When you
    run a setup, it creates a `diesel.toml` configuration file with the following
    contents:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是由 `diesel setup` 命令自动生成的。当你运行设置时，它创建一个包含以下内容的 `diesel.toml` 配置文件：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the config has a schema module reference. A `schema.rs` file
    is also generated, and will be updated on every compilation. The `table!` macro
    creates the required declaration of DSL for the tables used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，配置有一个 schema 模块引用。还会生成一个 `schema.rs` 文件，并且每次编译时都会更新。`table!` 宏创建了用于表的 DSL
    所需的声明。
- en: Models
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Schema declaration defines a table structure only. To map tables to Rust types,
    you have to add a module with models that will be used to convert records from
    the `users` table to native Rust types. Let''s create one and call it `models.rs`.
    It will contain the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 架构声明仅定义表结构。为了将表映射到 Rust 类型，你必须添加一个包含模型的模块，该模型将用于将 `users` 表中的记录转换为原生 Rust 类型。让我们创建一个并命名为
    `models.rs`。它将包含以下代码：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We declared two models here: `User` to represent a user in a database and `NewUser` for
    creating a new record of a user. We derive the necessary traits for the `User`
    struct. The `Queryable` trait is implemented to allow you get this type from a
    database using queries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明了两个模型：`User` 用于表示数据库中的用户，`NewUser` 用于创建用户的新的记录。我们为 `User` 结构体推导出必要的特质。`Queryable`
    特质被实现以允许你通过查询从数据库获取此类型。
- en: There is the `Insertable` trait, which is derived from the `NewUser` struct.
    This trait allows a struct to be inserted as a new row in a table. This derivation
    requires an annotation with the name of the table. We can set it to the `users`
    table with the `#[table_name = "users"]` annotation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`Insertable`特质，它是从`NewUser`结构体派生出来的。这个特质允许结构体作为新行插入到表中。这种派生需要一个带有表名的注解。我们可以将其设置为`users`表，使用`#[table_name
    = "users"]`注解。
- en: The database structure has been prepared, and we can start to use the database
    from an application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库结构已经准备就绪，我们可以从应用程序开始使用数据库。
- en: Connecting to a database
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'In our tool, we will implement two subcommands—`add` to add a new user, and
    `list` to retrieve all available users from the database. Import all the necessary
    dependencies and add the modules with `schema` and `models`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具中，我们将实现两个子命令——`add`用于添加新用户，`list`用于从数据库检索所有可用用户。导入所有必要的依赖项并添加带有`schema`和`models`的模块：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since we are using the `r2d2` crate, we also have to import `ConnectionManager` to
    use diesel's abstraction over the traditional database connection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是`r2d2` crate，我们还需要导入`ConnectionManager`以使用diesel对传统数据库连接的抽象。
- en: Modules declared with the `pub` modifier make them available in documentation.
    It's useful for modules that are generated by the `diesel` crate so that you can
    explore the functions provided by a generated DSL.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pub`修饰符声明的模块使它们在文档中可用。这对于由`diesel` crate生成的模块很有用，这样你可以探索由生成的DSL提供的函数。
- en: Parsing arguments
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析参数
- en: 'Similar to the examples in the previous chapter, we have a parser for arguments.
    It has the following declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章中的示例类似，我们有一个参数解析器。它的声明如下：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can get `--database` arguments with a path to a database file. The  `add` subcommand
    requires two arguments—`NAME` with the name of a user, and `EMAIL` with their
    email. The `list` subcommand doesn't require extra arguments and will print a
    list of users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有数据库文件路径的`--database`参数。`add`子命令需要两个参数——带有用户名的`NAME`和带有电子邮件的`EMAIL`。`list`子命令不需要额外的参数，并将打印用户列表。
- en: Creating a connection
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建连接
- en: 'To create a connection, we extract the path to a database. Since we are using
    the SQLite database, in contrast to the previous examples, we don''t expect a
    URL, but instead a path to a database file. That''s why we use the `test.db` filename
    instead of a URL:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建连接，我们提取数据库的路径。由于我们使用的是SQLite数据库，与之前的示例不同，我们不需要URL，而是数据库文件的路径。这就是为什么我们使用`test.db`文件名而不是URL的原因：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`r2d2::Pool` requires a `ConnectionManager` instance to establish connections
    with a database, and we can provide `SqliteConnection` as an associated type to
    use the SQLite database. We provide a path to a database extracted from command-line
    arguments. Now let''s look at how to use a generated DSL to interact with a database.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`r2d2::Pool`需要一个`ConnectionManager`实例来与数据库建立连接，我们可以提供从命令行参数中提取的数据库路径作为关联类型来使用SQLite数据库。现在让我们看看如何使用生成的DSL与数据库交互。'
- en: Implementing subcommands using a DSL
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DSL实现子命令
- en: 'The `diesel` crate generates a DSL for us to construct typed queries in a simple
    way. All instructions are generated as a submodule of schema and are available
    for every generated table mapping with a module path such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`diesel` crate为我们生成一个DSL，以简单的方式构造类型化查询。所有指令都作为schema的子模块生成，并对每个生成的表映射可用，模块路径如下：'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's implement two commands using generated typed relations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用生成的类型化关系实现两个命令。
- en: Adding a user subcommand implementation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户子命令实现
- en: 'The first subcommand of our users management tool is `add`. This command extracts
    the `NAME` and `EMAIL` of the user from the arguments and generates a new user
    identifier using the `uuid` crate. We will use this type across all our microservices.
    Look at the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用户管理工具的第一个子命令是`add`。这个命令从参数中提取用户的`NAME`和`EMAIL`，并使用`uuid` crate生成一个新的用户标识符。我们将在这个所有微服务中使用这种类型。看看下面的代码：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After we have extracted all the parameters, we create a `NewUser` instance from
    the `models` module. It requires references to values, and we don't need to pass
    ownership to values and reuse them in multiple requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提取所有参数后，我们从`models`模块创建一个`NewUser`实例。它需要引用值，我们不需要将所有权传递给值并在多个请求中重用它们。
- en: The last line uses the `insert_into` function, which generates an `INSERT INTO`
    statement for the provided tables, but instead of textual names of tables, such
    as  `"users"`, we use the `table` type from the users `module` of schema. It helps
    you to see all the mistypes at compile time. We set the value for this request
    with the `values` function call. As a value, we use a reference to the `NewUser`
    instance because this map is already mapped to the ***users*** table in the struct
    declaration. To execute a statement, we call the `execute` function of the `InsertStatement`
    instance which is generated by the `values` method call.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行使用了`insert_into`函数，它为提供的表生成一个`INSERT INTO`语句，但与表文本名称，如`"users"`不同，我们使用来自模式中用户`module`的`table`类型。这有助于你在编译时看到所有错误。我们使用`values`函数调用来设置这个请求的值。作为值，我们使用对`NewUser`实例的引用，因为这个映射已经在结构声明中映射到`***users***`表。要执行一个语句，我们调用由`values`方法调用生成的`InsertStatement`实例的`execute`函数。
- en: The `execute` method expects a reference to a connection that we have already
    extracted from a pool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法期望一个对我们已经从池中提取的连接的引用。'
- en: Listing users subcommand implementation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出用户子命令实现
- en: In the previous example of data insertion, we didn't use the generated `users`
    type, and used the `table` nested type only. To list users in the implementation
    of the `list` subcommand, we will use types from the `dsl` submodule.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的数据插入示例中，我们没有使用生成的`users`类型，而只使用了嵌套的`table`类型。为了在`list`子命令的实现中列出用户，我们将使用`dsl`子模块中的类型。
- en: 'If you build some documentation and look into the `users::schema::users::dsl`
    module, you will see the following items:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建一些文档并查看`users::schema::users::dsl`模块，你会看到以下项目：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All types are quite complex, and you can see all the features in the documentation.
    Since the `users` table type implements the `AsQuery` trait, we can use the `load`
    method of the `RunQueryDsl` trait for the `users` type. We set the associated
    type to `model::Users` to extract this type from the table. We also don''t need
    any manual extractions like we did in the previous chapter. The `load` method
    expects a `Connection` that we `get` from a `Pool` instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都非常复杂，你可以在文档中看到所有功能。由于`users`表类型实现了`AsQuery`特质，我们可以使用`RunQueryDsl`特质的`load`方法来处理`users`类型。我们将关联类型设置为`model::Users`以从表中提取此类型。我们也不需要像上一章那样进行任何手动提取。`load`方法期望一个`Connection`，我们可以从`Pool`实例中获取它：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can simply iterate over the users collections. That's pretty simple.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地遍历用户集合。这很简单。
- en: 'If you want to construct more complex requests, you can use other DSL functions
    that are generated by the `diesel` crate during building. For example, you can
    filter users by domain name and limit the quantity of users in a list with the
    following DSL expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构造更复杂的请求，可以使用`diesel`crate在构建过程中生成的其他DSL函数。例如，你可以通过域名过滤用户，并使用以下DSL表达式限制列表中用户的数量：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have filtered all users by the `example.com` domain using the `filter` method
    with a parameter created by the `like` method call of the `email` column.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`filter`方法，并通过`email`列的`like`方法调用来创建参数，过滤了所有`example.com`域的用户。
- en: Testing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Let''s test our tool. Compile and run it with the following commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的工具。使用以下命令编译并运行它：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you add filtering and call the `list` subcommand, you will see the following
    output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加过滤并调用`list`子命令，你会看到以下输出：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We got a perfect example of mapping pure Rust types to relational database types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个将纯Rust类型映射到关系数据库类型的完美示例。
- en: Complex database structure
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的数据库结构
- en: We have covered one example with a single table. In this section, we will create
    an example with a complex table structure to cover holistic database interaction.
    We will develop a separate crate for database interaction that covers the functionality
    of a complex chat application—chat with users, channels, and roles. Also, we will
    test the functionality we have implemented and show you how to test the database
    interaction layer of the Rust application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了一个单表的示例。在本节中，我们将创建一个具有复杂表结构的示例，以涵盖整体数据库交互。我们将开发一个用于数据库交互的独立crate，该crate涵盖了复杂聊天应用程序的功能——与用户、频道和角色聊天。此外，我们将测试我们实现的功能，并展示如何测试Rust应用程序的数据库交互层。
- en: Business logic of the example application
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序的业务逻辑
- en: 'In this section, we will learn how to transform data relations into ORM models.
    We will implement a database interaction crate for a chat application. Imagine,
    we need to express these data relations in Rust:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将数据关系转换为ORM模型。我们将实现一个聊天应用的数据库交互包。想象一下，我们需要在Rust中表达这些数据关系：
- en: '![](img/d814f00c-892e-439a-be5c-89a444c2afc9.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d814f00c-892e-439a-be5c-89a444c2afc9.png)'
- en: We have four tables. The first table contains users. It's the main table and
    is used by all the other tables. Every user can create a channel and become the
    owner of a channel. The second table contains channels, and every channel has
    the owner represented by a record in the `users` table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个表。第一个表包含用户。它是主表，并被其他所有表使用。每个用户都可以创建一个频道并成为频道的所有者。第二个表包含频道，每个频道都有一个所有者，由`users`表中的记录表示。
- en: In our chat application, every user can join a channel and post messages to
    it. To maintain this relation, we will add a `memberships` table that contains
    records with two references—a user who is a member of a channel and a channel
    record that contains a user as a member.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的聊天应用中，每个用户都可以加入频道并向其发布消息。为了维护这种关系，我们将添加一个`memberships`表，其中包含两个引用的记录——一个用户是频道的成员，另一个是包含用户的频道记录。
- en: 'Also, users can post messages to channels. We will keep all messages in a separate
    `messages` table. Every message has two relations: the channel that contains the
    message and the user who posted the message.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户可以向频道发布消息。我们将保留所有消息在一个单独的`messages`表中。每条消息有两个关系：包含消息的频道和发布消息的用户。
- en: API methods
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API方法
- en: 'To maintain the data, we need to provide the following methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护数据，我们需要提供以下方法：
- en: '`register_user`: Adds a new user to the `users` table'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_user`：向`users`表添加新用户'
- en: '`create_channel`: Creates a new channel with the provided user as the owner
    of the channel'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_channel`：创建一个新的频道，并使用提供的用户作为频道所有者'
- en: '`publish_channel`: Makes the channel public'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish_channel`：使频道公开'
- en: '`add_member`: Adds a member to a channel'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_member`：向频道添加成员'
- en: '`add_message`: Adds a message from a user to a channel'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_message`：向频道添加用户的消息'
- en: '`delete_message`: Deletes a message'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_message`：删除消息'
- en: You may have noticed that we don't have methods to delete a channel, but we
    have a method to delete a message. That's because users can post a message accidentally,
    which they may want to delete. Perhaps the user posts some private information
    that they want removed from the database.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有删除频道的功能，但我们有一个删除消息的方法。这是因为用户可能会不小心发布一条消息，他们可能想要删除它。也许用户发布了一些他们想要从数据库中删除的私人信息。
- en: We don't allow the deletion of channels and users, because they are an important
    part of the business logic. If user deletes a channel, then all the messages from
    other users will be deleted as well. It's not a behavior other users want.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不允许删除频道和用户，因为它们是业务逻辑的重要组成部分。如果用户删除了一个频道，那么其他用户的全部消息也会被删除。这不是其他用户希望的行为。
- en: If you need a deleting feature, you can add a boolean column to every table
    that means the record was deleted. Don't delete the physical record, but mark
    it as deleted. You can add it yourself to this example. In real cases you also
    have to take into account the laws in the country that the user lives in, because
    they can require the physical deletion of records.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个删除功能，你可以在每个表中添加一个布尔列，表示记录已被删除。不要删除物理记录，但将其标记为已删除。你可以自己添加到这个例子中。在实际情况中，你还需要考虑用户所在国家的法律，因为它们可能要求物理删除记录。
- en: Now, we can express these relations in Rust with ORM using the `diesel` crate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Rust的ORM通过`diesel`包来表示这些关系。
- en: Database structure and migrations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库结构和迁移
- en: 'Let''s start by creating the database structure. We need four tables:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建数据库结构。我们需要四个表：
- en: '`users`: Contains users'' accounts'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：包含用户的账户'
- en: '`channels`: Contains channels created by users'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels`：包含用户创建的频道'
- en: '`memberships`: Users belonging to a channel'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memberships`：属于频道的用户'
- en: '`messages`: Messages of users in channels'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages`：频道中用户的消息'
- en: 'To add these tables, we will add four migrations to a new project:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些表，我们将向新项目添加四个迁移：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding commands created these migrations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令创建了这些迁移：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you may remember, every migration folder contains two files: `up.sql` and
    `down.sql`. Now, we can add SQL statements to execute the necessary migration
    operations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，每个迁移文件夹包含两个文件：`up.sql`和`down.sql`。现在，我们可以添加SQL语句来执行必要的迁移操作。
- en: Diesel initial setup
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Diesel初始设置
- en: The first migration is `diesel_initial_setup`. It was created by the `diesel`
    CLI tool automatically and contains a function to set a trigger to update the `updated_at`
    column of a table. We will use this feature for the channel table. Like every
    migration, it consists of two files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次迁移是`diesel_initial_setup`。它是由`diesel` CLI工具自动创建的，包含一个设置触发器以更新表`updated_at`列的函数。我们将使用这个功能来处理频道表。像每次迁移一样，它由两个文件组成。
- en: up.sql
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: up.sql
- en: 'This SQL file contains two statements. The first is the `diesel_manage_updated_at`
    function, whichcreates a trigger for a table to call the `diesel_set_updated_at`
    function for each row update:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL文件包含两个语句。第一个是`diesel_manage_updated_at`函数，它为表创建一个触发器，以便在每行更新时调用`diesel_set_updated_at`函数：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function only executes the `CREATE TRIGGER` statement for a table you provided
    with the `_tbl` argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅对提供`_tbl`参数的表执行`CREATE TRIGGER`语句。
- en: 'The second function is `diesel_set_updated_at`, which updates the `updated_at`
    column with the current timestamp if the processed row has changed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数是`diesel_set_updated_at`，它更新`updated_at`列，如果处理过的行已更改，则使用当前时间戳：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To make this function work, you have to add the `updated_at` column to your
    table and a field with the same name to your model. We will do this for the `channel`
    table later in this section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能工作，你必须将`updated_at`列添加到你的表中，并在你的模型中添加一个同名字段。我们将在本节稍后对`channel`表做这件事。
- en: down.sql
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: down.sql
- en: 'The down script removes both functions, if they exist:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 降级脚本会删除两个函数（如果存在）：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This was a default migration created by the `diesel` tool. As you can see, it
    contains a functionality you can drop or replace with your own. Now, we can add
    the `users` table to the next migration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由`diesel`工具创建的默认迁移。正如你所见，它包含你可以删除或用你自己的替换的功能。现在，我们可以将`users`表添加到下一个迁移中。
- en: Users table
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户表
- en: The second migration is `create_users`. It creates a `users` table that is required
    to keep all the users' accounts in a database. To create this table, we create
    a separate migration that contains two scripts—one to create the `users` table
    and one to drop it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次迁移是`create_users`。它创建一个`users`表，该表用于在数据库中保存所有用户的账户。为了创建这个表，我们创建了一个单独的迁移，包含两个脚本——一个用于创建`users`表，另一个用于删除它。
- en: up.sql
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: up.sql
- en: 'Add the following statement to the `up.sql` script:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下语句添加到`up.sql`脚本中：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the table has two columns. `id` represents the unique ID of
    the user, and we will use this identifier in other tables later. The `email` column
    contains the unique e-mail of the user. For real applications, the `users` table
    also has to contain a hashed password, and two columns to store when the user
    was created and updated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该表有两个列。`id`代表用户的唯一ID，我们将在稍后的其他表中使用这个标识符。`email`列包含用户的唯一电子邮件。对于实际应用，`users`表还必须包含一个散列密码，以及两个列来存储用户创建和更新的时间。
- en: down.sql
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: down.sql
- en: 'The down script drops the `users` table:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 降级脚本删除`users`表：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we can use the users' IDs to create channels.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用用户的ID来创建频道。
- en: Channels table
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频道表
- en: The third migration is `create_channels`. It creates a `channels` table that
    contains all of the channels that have been created by users. Channels can be
    private or public, and each has a title. Let's look at a script that creates a
    table of channels in a database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次迁移是`create_channels`。它创建一个`channels`表，包含所有由用户创建的频道。频道可以是私有的或公共的，每个频道都有一个标题。让我们看看创建数据库中频道表的脚本。
- en: up.sql
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: up.sql
- en: 'The up script contains a statement that creates the `channels` table. Columns
    includes the channel `id` and `user_id` , which refers to the user in the `users`
    table. The channel also has a `title` column and an `is_public` column that contains
    a flag that represents the visibility of the channel. If `is_public` equals `TRUE`,
    it means the channel is public. Look at the following statement:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 升级脚本包含一个创建`channels`表的语句。列包括频道`id`和`user_id`，它引用`users`表中的用户。频道还有一个`title`列和一个`is_public`列，它包含一个表示频道可见性的标志。如果`is_public`等于`TRUE`，则表示该频道是公开的。看看以下语句：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The table also has two columns—`create_at`, which takes the current timestamp
    when the row is created, and `updated_at`, which contains the timestamp of the
    latest update of the row. By default, the `updated_at` column takes the current
    timestamp as the default value on creation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该表还有两个列——`create_at`，它在行创建时获取当前时间戳，以及`updated_at`，它包含行的最新更新时间戳。默认情况下，`updated_at`列在创建时使用当前时间戳作为默认值。
- en: As we mentioned before, diesel creates a `diesel_manage_updated_at` function
    that sets a trigger to a table, which updates the `updated_at` column of rows
    automatically when the row is updated. Since we have the `updated_at` column in
    the table declaration, we can call this function in the `SELECT` statement.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，diesel 创建了一个 `diesel_manage_updated_at` 函数，该函数将触发器设置到表中，当行被更新时自动更新行的
    `updated_at` 列。由于我们在表声明中已经有了 `updated_at` 列，我们可以在 `SELECT` 语句中调用此函数。
- en: down.sql
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: down.sql
- en: 'The down script drops the `channels` table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: down 脚本删除了 `channels` 表：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `up.sql` script,we created a trigger with a `diesel_manage_updated_at`
    call, but we don't need to drop it manually, because it is automatically removed
    with the table.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `up.sql` 脚本中，我们创建了一个带有 `diesel_manage_updated_at` 调用的触发器，但我们不需要手动删除它，因为它会随着表的删除而自动移除。
- en: Memberships table
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会员表
- en: The fourth migration is `create_memberships`. It creates a `memberships` table
    that is necessary to manage the participants of the channel who can read messages
    and write new ones. This table depends on both the `users` and `channels` tables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第四次迁移是 `create_memberships`。它创建了一个必要的 `memberships` 表，用于管理可以读取消息并写入新消息的渠道参与者。这个表依赖于
    `users` 和 `channels` 表。
- en: up.sql
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: up.sql
- en: 'The `up` script is simple and contains a statement that creates the memberships
    table with three fields—the `id` of a membership, the `id` of a channel in the `channel_id`
    column whose member is a user with the `user_id` column:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`up` 脚本简单，包含一个创建具有三个字段（会员的 `id`、在 `channel_id` 列中的渠道 `id` 以及具有 `user_id` 列的用户的
    `id`）的会员表语句：'
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: down.sql
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: down.sql
- en: 'The down script drops the table:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: down 脚本删除了表：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now need to add a table that stores messages that users have posted to the
    channels.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加一个存储用户发布到渠道的消息的表。
- en: Messages table
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息表
- en: The fifth migration is `create_messages`. It creates a `messages` table that
    contains every message that has been written by the users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第五次迁移是 `create_messages`。它创建了一个包含所有用户已写入消息的 `messages` 表。
- en: up.sql
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: up.sql
- en: 'Look at the following up script:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 up 脚本：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It creates a table that contains a message that is associated with a channel
    and a user by ID. Also, it contains a timestamp showing when the messages were
    added, as well as the text of each message.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个包含与渠道和用户通过 ID 关联的消息的表。此外，它还包含显示消息添加时间的戳以及每条消息的文本。
- en: down.sql
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: down.sql
- en: 'The down script drops the table:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: down 脚本删除了表：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have finished all the migrations, and now we can look at the schema that
    was generated by the `diesel` tool.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有迁移，现在我们可以查看 `diesel` 工具生成的架构。
- en: Schema
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: '`diesel` creates a schema file that contains macro calls that generate a DSL
    language to use in the sources of your crate. A schema of tables that have relations
    to each other need extra declarations. Let''s explore a generated schema in the `src/schema.rs`
    file to see how it differs from the simple schema we created earlier in this chapter.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`diesel` 创建了一个包含生成用于源代码中使用的 DSL 语言的宏调用的 schema 文件。具有相互关系的表架构需要额外的声明。让我们在 `src/schema.rs`
    文件中查看生成的架构，看看它与我们在本章早期创建的简单架构有何不同。'
- en: 'The first table is `users`. It has the same columns we declared in the SQL
    file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张表是 `users`。它具有我们在 SQL 文件中声明的相同列：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `table!` macro will be expanded during compilation to some type and trait
    implementations that you can see with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`table!` 宏在编译期间会被展开为一些类型和特质实现，您可以使用以下命令查看：'
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command prints all expanded macros to a Terminal.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将所有展开的宏打印到终端。
- en: 'The diesel tool has also generated a DSL declaration for the `channels` table:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: diesel 工具还为 `channels` 表生成了一个 DSL 声明：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For the `memberships` table, we have this declaration:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `memberships` 表，我们有以下声明：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And for the `messages` table, we have this declaration:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `messages` 表，我们有以下声明：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But you might have noticed that the table declarations don''t contain any information
    about relations. Relations created by the `joinable!` macro expect a table name
    and a parent table with the ID column name:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能已经注意到，表声明中没有包含任何关于关系的信息。由 `joinable!` 宏创建的关系期望一个表名和一个具有 ID 列名的父表：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All relations are listed with the `joinable!` macro, but the schema also contains
    a `allow_tables_to_appear_in_same_query!` macro call that represents which tables
    can be used in `JOIN` queries:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关系都通过 `joinable!` 宏列出，但架构还包含一个 `allow_tables_to_appear_in_same_query!` 宏调用，表示哪些表可以在
    `JOIN` 查询中使用：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we have a complete schema declaration with all relations, we can declare
    models with the same relations as native Rust structs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有了包含所有关系的完整模式声明，我们可以声明与原生Rust结构体具有相同关系的模型。
- en: Models
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Now, we can use the generated schema to create all the necessary models that
    represent database records to native Rust structs. First, we have to import the `NaiveDateTime`
    type, because we have the timestamp column. Also, we have to import all tables:
    `users`, `channels`, `memberships`, and `messages`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用生成的模式来创建所有必要的模型，这些模型代表数据库记录到原生Rust结构体。首先，我们必须导入`NaiveDateTime`类型，因为我们有时间戳列。此外，我们必须导入所有表：`users`、`channels`、`memberships`和`messages`：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will use the `i32` type as the identifier of records, but it''s better to
    use an alias to make its intent more clear:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`i32`类型作为记录的标识符，但最好使用别名来使其意图更加明确：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's add a model to represent a record in the `users` table.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个模型来表示`users`表中的记录。
- en: User
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户
- en: 'To represent a user stored in the `users` table, we will add a `User` struct
    with the following declaration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示存储在`users`表中的用户，我们将添加一个具有以下声明的`User`结构体：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, we use the `Id` type for the ID column that has the `SERIAL`
    SQL type. For the email field, we use the String type, which maps to the `TEXT`
    column type in PostgreSQL.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用具有`SERIAL` SQL类型的`Id`类型作为ID列。对于电子邮件字段，我们使用String类型，它在PostgreSQL中映射到`TEXT`列类型。
- en: There is also the `table_name` attribute to bind this struct with a table. We
    also derive some traits for this model—`Debug` for printing the model's value
    to a terminal, and the `Serialize` and `Deserialize` traits to make this model
    convertible to any serialization format. Theser are basic traits that I recommend
    to implement for database models, especially if you want to use the same types
    in a REST API.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`table_name`属性来将此结构体与表绑定。我们还为此模型推导了一些特质——`Debug`用于将模型值打印到终端，以及`Serialize`和`Deserialize`特质，使此模型可转换为任何序列化格式。这些是推荐实现的基本特质，尤其是如果你想在一个REST
    API中使用相同的类型。
- en: The `Queryable` trait represents the result of SQL expressions that can be converted
    in a struct that implements the trait. This lets us convert tuples to the `User`
    struct in our database interaction API later.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queryable`特质代表可以转换为实现该特质的结构的SQL表达式的结果。这使得我们可以在数据库交互API中将元组转换为`User`结构体。'
- en: The `Identifiable` trait means the struct that implements this trait represents
    a single record in a table. This trait has an associated `Id` type that is set
    to the corresponding type in the SQL table. This trait also contains an `id` method
    that returns the identifier of a record in a table.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Identifiable`特质意味着实现此特质的结构体代表表中的一个单个记录。此特质有一个关联的`Id`类型，它设置为SQL表中相应的类型。此特质还包含一个`id`方法，它返回表中的记录标识符。'
- en: Channel
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: 'The next model is `Channel`, which represents a record in the `channels` table:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模型是`Channel`，它代表`channels`表中的记录：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This model binds to a table using the `table_name` attribute and contains all
    the fields that map to the corresponding columns of the table. To represent the `TIMESTAMP`
    SQL type, we use `NaiveDateTime` from the `chrono` crate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型使用`table_name`属性绑定到表，并包含映射到表相应列的所有字段。为了表示`TIMESTAMP` SQL类型，我们使用来自`chrono`包的`NaiveDateTime`。
- en: The model has a `user_id` field that maps to a record in the `users` table.
    To indicate whether a `User` model belongs to the `users` table, we added the `belongs_to`
    attribute to this model. The model also has to implement the `Associations` trait.
    If the model does that, you can use the `belonging_to` method of a model to get
    records belonging to other records with a parental relation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型有一个`user_id`字段，它映射到`users`表中的记录。为了指示`User`模型是否属于`users`表，我们向此模型添加了`belongs_to`属性。该模型还必须实现`Associations`特质。如果模型做到了这一点，你就可以使用模型的`belonging_to`方法来获取与父记录相关联的其他记录。
- en: Membership
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会员资格
- en: 'To represent records in the memberships model, we added the `Membership` model:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示会员资格模型中的记录，我们添加了`Membership`模型：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This model has set relations with the `Channel` and `User` models. For example,
    if you want to get all the memberships of a user, you can use the `belonging_to`
    method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型与`Channel`和`User`模型建立了关联关系。例如，如果你想获取一个用户的全部会员资格，你可以使用`belonging_to`方法：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Message
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: 'The last model we need is `Message`, which relates to the records in the `messages`
    table:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个模型是`Message`，它与`messages`表中的记录相关联：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This model also uses derived traits which we discussed in the first example.
    Now, we can implement our database interaction crate using the generated schema
    and the declared models.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型还使用了我们在第一个示例中讨论的派生特性。现在，我们可以使用生成的模式和声明的模型来实现我们的数据库交互包。
- en: Database interaction API crate
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库交互 API 包
- en: 'Let''s add an implementation of the database interaction API to the `lib.rs`
    source file. We need to import the `diesel` crate and declare the module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `lib.rs` 源文件中添加数据库交互 API 的实现。我们需要导入 `diesel` 包并声明模块：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can see that we have added two modules: `models` and `schema`. In the implementation,
    we need the following types:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们添加了两个模块：`models` 和 `schema`。在实现中，我们需要以下类型：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The imports include all models and all tables. We also imported the `Connection`
    trait to the `establish` connection, the `ExpressionMethods` trait to use the `eq`
    method of DSL to set the equality of columns to values, the `OptionalExtension` trait
    to use the `optional` method to try to get a record that cannot be in a table,
    the `QueryDsl` trait that has the `filter` method, and `RunQueryDsl` to use the `get_result`
    method that tries to convert a record to the Rust type. The `insert_into` method
    lets us insert new records into a table. Now, we have everything we need to declare
    the `Api` struct.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包括所有模型和所有表。我们还导入了 `Connection` 特性到 `establish` 连接，`ExpressionMethods` 特性来使用
    DSL 的 `eq` 方法设置列的值相等，`OptionalExtension` 特性来使用 `optional` 方法尝试获取不在表中的记录，具有 `filter`
    方法的 `QueryDsl` 特性，以及 `RunQueryDsl` 来使用尝试将记录转换为 Rust 类型的 `get_result` 方法。`insert_into`
    方法让我们能够向表中插入新记录。现在，我们已经有了声明 `Api` 结构体所需的一切。
- en: Api
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Api
- en: 'We will declare a struct with a connection instance inside and add methods
    over this connection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明一个包含连接实例的结构体，并在这个连接上添加方法：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Api` struct can be created with the `connect` method, which uses the `DATABASE_URL`
    environment variable to bootstrap a connection to PostgreSQL:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Api` 结构体可以通过 `connect` 方法创建，它使用 `DATABASE_URL` 环境变量来启动与 PostgreSQL 的连接：'
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We use a direct connection here without an `r2d2` pool, but you can also make
    the `Api` struct compatible with concurrent access. Let's add first the API method
    for registering new users.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用直接连接而没有 `r2d2` 连接池，但你也可以使 `Api` 结构体兼容并发访问。让我们首先添加用于注册新用户的 API 方法。
- en: Register user
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册用户
- en: 'To register a new user with an email address, add the following method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用电子邮件地址注册新用户，添加以下方法：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `register_user` function expects a string with the email of a user, adds
    a record to a database, and returns a `User` instance, which represents a record
    in the `users` table.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`register_user` 函数期望一个包含用户电子邮件的字符串，向数据库中添加一条记录，并返回一个代表 `users` 表中记录的 `User`
    实例。'
- en: We use the `insert_into` method with a table type from the users scope, which
    is automatically created by the `table!` macro in the `schema` module. This method
    returns an `IncompleteInsertStatement` instance that provides a `values` method
    to set values with an `INSERT` statement. We set the `email` column equal to the `email`
    variable. The `values` method call returns an `InsertStatement` type instance
    that has the `returning` method to set columns that will be returned with this
    statement. We set the returning values to the `id` and `email` columns of the `users`
    table. The `returning` method takes ownership of a statement and returns a new `InsertStatement`
    instance with the returning values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `insert_into` 方法与来自 `users` 范围的表类型，这是由 `schema` 模块中的 `table!` 宏自动创建的。此方法返回一个
    `IncompleteInsertStatement` 实例，它提供了一个 `values` 方法来使用 `INSERT` 语句设置值。我们将 `email`
    列设置为等于 `email` 变量。`values` 方法调用返回一个 `InsertStatement` 类型实例，它具有 `returning` 方法来设置与此语句一起返回的列。我们将返回值设置为
    `users` 表的 `id` 和 `email` 列。`returning` 方法接收一个语句的所有权并返回一个新的 `InsertStatement`
    实例，其中包含返回值。
- en: At the end, we call the `get_result` method of the `InsertStatement` struct
    to execute the statement and convert the result to the `User` model. Because we
    have a different error type of `Result`, we have to convert the `diesel::result::Error`
    type returned by the `get_result`, method call to the `failure::Error` type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `InsertStatement` 结构体的 `get_result` 方法来执行语句并将结果转换为 `User` 模型。因为我们有一个不同的
    `Result` 错误类型，所以我们必须将 `get_result` 方法返回的 `diesel::result::Error` 类型转换为 `failure::Error`
    类型。
- en: Create channel
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建频道
- en: 'The next method is `create_channel`, which creates a new channel for a user.
    Take a look at the implementation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `create_channel`，它为用户创建一个新的频道。看看实现方式：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The function expects `user_id`, the `title` of a channel, and the `is_public`
    flag, which means the channel is public.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望 `user_id`、频道的 `title` 和 `is_public` 标志，这意味着频道是公开的。
- en: Since we have to add the user who created the channel as the first member of
    a created channel, we will join two statements to a single transaction. To create
    a transaction with `diesel`, you can use the `transaction` method of the `Connection`
    instance. This method expects three type parameters—successful value type, error
    value type, and a type of a closure provided as a single argument with a function
    call. We skip all types, because the compiler can detect them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须将创建频道的用户作为创建频道的第一个成员添加，因此我们将两个语句合并为一个事务。要使用 `diesel` 创建事务，你可以使用 `Connection`
    实例的 `transaction` 方法。此方法期望三个类型参数——成功值类型、错误值类型以及作为单个参数提供的闭包类型的函数调用。我们跳过所有类型，因为编译器可以检测它们。
- en: In the transaction implementation we create a `Channel` model instance that
    represents a new record in a database. After that, we use the `add_member` method
    of our `Api` struct. As you can see, neither the transaction and connection instances
    need a mutable reference, and we can combine multiple methods to get an immutable
    reference to a `Connection` instance. You will see the implementation of the `add_member`
    method later, but now we will add a method to update a channel's record in a table.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务实现中，我们创建一个 `Channel` 模型实例，它代表数据库中的一个新记录。之后，我们使用 `Api` 结构的 `add_member` 方法。正如你所看到的，事务和连接实例都不需要一个可变引用，我们可以组合多个方法来获取一个不可变引用到
    `Connection` 实例。你将在稍后看到 `add_member` 方法的实现，但现在我们将添加一个方法来更新表中频道的记录。
- en: Publish channel
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布频道
- en: 'We will add a method that sets the `is_public` flag of a channel record to
    `true`. Look at the following implementation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个方法来将频道记录的 `is_public` 标志设置为 `true`。看看以下实现：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The function expects `channel_id`, and we use the `table` value to create a
    statement. We use the `filter` method of the `QueryDsl` trait to get a single
    record with the provided ID, and the `select` method of the same trait to extract
    values from the table needed for conversion to the `Channel` model instance. Then,
    we call the `first` method that returns the first record found with the executed
    statement. If no record is found, it will return an error, but since `Result`
    types are returned, we can drop the error part of this by converting it in `Option` with
    the `optional` method call. It lets us decide later what to do if a record hasn't
    been found later.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望 `channel_id`，我们使用 `table` 值来创建一个语句。我们使用 `QueryDsl` 特性的 `filter` 方法获取具有提供
    ID 的单个记录，并使用同一特性的 `select` 方法从表中提取转换为 `Channel` 模型实例所需的价值。然后，我们调用返回执行语句找到的第一个记录的
    `first` 方法。如果没有找到记录，它将返回一个错误，但由于返回的是 `Result` 类型，我们可以通过使用 `optional` 方法调用来转换它，从而删除这个错误部分。它让我们可以在稍后决定如果未找到记录时该做什么。
- en: If a record is found, we use the `update` method with a reference to a `Channel`
    model. This call returns an `UpdateStatement` value, which has a `set` method
    that we use to set the `is_public` column to `true`. At the end, we `execute`
    this statement for a connection instance. This call also updates the `updated_at`
    column of the record automatically since we registered a trigger for the `channels`
    table. Now, we can implement the `add_member` function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到记录，我们使用 `update` 方法和一个 `Channel` 模型的引用。此调用返回一个 `UpdateStatement` 值，它有一个
    `set` 方法，我们使用它将 `is_public` 列设置为 `true`。最后，我们对连接实例执行此语句。此调用还自动更新记录的 `updated_at`
    列，因为我们为 `channels` 表注册了一个触发器。现在，我们可以实现 `add_member` 函数。
- en: Add member
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加成员
- en: 'The `add_member` function requires a channel ID and a user ID to add a membership
    record to the `memberships` table:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_member` 函数需要一个频道 ID 和用户 ID 来将会员记录添加到 `memberships` 表：'
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The implementation is simple and it uses the `insert_into` function call to
    prepare the `INSERT` statement to insert a new `Membership` value in the table.
    We also need a function to add new messages to a channel.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单，它使用 `insert_into` 函数调用来准备 `INSERT` 语句，在表中插入一个新的 `Membership` 值。我们还需要一个函数来向频道添加新消息。
- en: Add message
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加消息
- en: 'The `add_message` method adds a message related to a channel and a user to
    the `messages` table:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_message` 方法将一条与频道和用户相关的消息添加到 `messages` 表：'
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The implementation also uses the `insert_into` function, but we also created
    the timestamp manually. You can avoid setting this field manually and set a default
    value to the current timestamp in the `timestamp` column.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实现还使用了`insert_into`函数，但我们还手动创建了时间戳。您可以通过在`timestamp`列中设置当前时间戳的默认值来避免手动设置此字段。
- en: Delete message
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除消息
- en: 'If you posted a message and decided to remove it, we need a method to delete
    messages from `messages` table. Look at `delete_message` method implementation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发布了消息并决定删除它，我们需要一个方法从`messages`表中删除消息。查看`delete_message`方法的实现：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function uses the `delete` method, which returns a `DeleteStatement` instance,
    which has a `filter` method as well. We set a filter with the `id` column equal
    to the provided `message_id` and execute the generated `DELETE` SQL statement.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用`delete`方法，该方法返回一个`DeleteStatement`实例，该实例也有一个`filter`方法。我们使用`id`列等于提供的`message_id`设置一个过滤器，并执行生成的`DELETE`
    SQL语句。
- en: Testing the crate
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试包
- en: That's all, and now we have a crate that can be used to interact with a database.
    Since it's not binary, we need to guarantee that the code works correctly. It's
    a good practice to cover your code with tests, and we will do that now.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，现在我们有一个可以用来与数据库交互的包。由于它不是二进制文件，我们需要保证代码的正确性。一个好的做法是用测试覆盖您的代码，我们现在就来做这件事。
- en: 'Add the following code to the `lib.rs` file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`lib.rs`文件中：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We added a `test` module and a `create_users` testing function. This function
    tests all the API methods we implemented. It creates an `Api` instance with a
    connect method call and uses that instance to register two users with the following
    emails—`"user_1@example.com"` and `"user_2@example.com"`. After that, it creates
    a channel for the first user, publishes it, and add the second user as a member.
    At the end, it adds two messages and deletes the first one. Let's run this test,
    but you have to run a PostgreSQL database instance with Docker. You can read how
    to do this in the previous chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`test`模块和一个`create_users`测试函数。这个函数测试了我们实现的所有API方法。它使用带有连接方法调用的`Api`实例创建一个实例，并使用该实例注册两个用户，电子邮件地址为`"user_1@example.com"`和`"user_2@example.com"`。之后，它为第一个用户创建了一个频道，发布了它，并将第二个用户添加为成员。最后，它添加了两条消息并删除了第一条。让我们运行这个测试，但您必须使用Docker运行一个PostgreSQL数据库实例。您可以在上一章中阅读如何做到这一点。
- en: 'Apply all the migrations and run the test:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用所有迁移并运行测试：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When the testing is over, you will get a message with from the `psql` client:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试完成后，您将收到来自`psql`客户端的消息：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, the test added two records and removed the first. In [Chapter
    13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml), *Testing and Debugging Rust Microservices*,
    we will discuss testing microservices in detail.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试添加了两个记录并删除了第一个。在第13章[测试和调试Rust微服务](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml)中，我们将详细讨论微服务的测试。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use object-relational mapping to store
    and load pure Rust types to databases. First, we created migrations with the `diesel-cli`
    tool that comes with the `diesel` crate. After that, we added models to map columns
    to Rust types and created a minimal connection using the `r2d2` crate with a `diesel`
    crate abstraction.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用对象关系映射将纯Rust类型存储和加载到数据库中。首先，我们使用`diesel`包中包含的`diesel-cli`工具创建了迁移。之后，我们添加了模型以将列映射到Rust类型，并使用`r2d2`包和`diesel`包的抽象创建了一个最小连接。
- en: We also touched on DSL constructs. however the `diesel` crate provides a lot
    of features, and if you want to construct more complex queries, you can refer
    to the documentation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了DSL构造，然而`diesel`包提供了很多功能，如果您想构建更复杂的查询，可以参考文档。
- en: In the next chapter, we will learn about some frameworks that simplify writing
    microservices and let you implement your ideas faster.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些简化编写微服务并让您更快实现想法的框架。
