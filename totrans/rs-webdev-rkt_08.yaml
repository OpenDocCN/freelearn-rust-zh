- en: '*Chapter 6*: Implementing User CRUD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a rough outline for the application. In
    this chapter, we are going to implement the endpoints for managing users. By implementing
    the endpoints in this chapter, you are going to learn about HTTP basic operations
    for an entity, that is, creating, reading, updating, and deleting an entity.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you are going to learn how to construct HTML and an HTML form,
    send the form payload to the server, validate and sanitize the form payload, hash
    the password payload, and handle failure by redirecting to another endpoint with
    a message.
  prefs: []
  type: TYPE_NORMAL
- en: Along with implementing the endpoints, you will also learn how to query single
    and multiple rows from the database, and how to insert, update, and delete a row
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GET user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing GET users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing POST user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PUT and PATCH user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing DELETE user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GET user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the steps to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the basics by implementing the `get_user()` function in `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we implement `get_user()`, we want to prepare the other routines that
    we will use. For example, we want to return HTML, so we need to create a `const`
    of `&'static str` in the same `src/routes/user.rs` file as our HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create two separate instances of `const` so we can insert different
    contents between the HTML prefix and suffix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, we will create two methods for a `User` struct. The first one is
    the find method to find the entry in the database server, and the second one is
    to create an HTML string for a `User` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/models/user.rs` file, add the following lines to the `use` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an `impl` block for `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the block, add the `find()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a similar method before. The first thing we do is parse the UUID
    (Universal Unique Identifier) `&str` into a `Uuid` instance and use the question
    mark operator (`?`) to quickly return `Box<dyn Error>`. After that, we define
    the SQL query string, `query_str`, and finally, we return the `User` instance.
  prefs: []
  type: TYPE_NORMAL
- en: One thing a little different here is that we are passing the mutable reference
    to `PgConnection` itself, instead of a mutable reference to `Connection<DBConnection>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember previously, we used `Connection<DBConnection>` as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We first dereference `db` using an asterisk (`*`) operator. The connection implements
    `std::ops::Deref`, and its implementation exposes the new type, `DBConnection`,
    which is a wrapper for `sqlx::PgPool`, an alias to `sqlx::Pool<sqlx::Postgres>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlx::Executor` trait is implemented for `sqlx::PgConnection`, a struct
    that implements the `sqlx::Connection` trait, representing a single connection
    to the database. The `sqlx::Executor` trait is also implemented for `&sqlx::Pool`,
    an asynchronous pool of SQLx database connections.
  prefs: []
  type: TYPE_NORMAL
- en: Since various `sqlx` methods (such as `fetch_all`, `fetch_one`, `fetch_many`,
    `fetch`, `execute`, and `execute_many`) accept the generic type `E`, which is
    bound by the `sqlx::Executor` trait, we can use either the reference to the pool
    itself or the connection obtained from the pool in those methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's a problem with the `find()` method since `OurDateTime` is a type unknown
    by `sqlx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following directive in `src/models/our_date_time.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `transparent` directive automatically generates implementations referring
    to the implementation of the inner type, which in our case is `DateTime<Utc>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beside the `find()` method, let''s implement another method to convert `User`
    to an HTML `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `OurDateTime` member is private but we access it like `self.created_at.``.to_rfc3339()`,
    it''s going to create an error when we compile it. To resolve it, convert the
    member of `OurDateTime` in `src/models/our_date_time.rs` to public:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to implement the `to_string()` method for `UserStatus` as well. We can
    choose to implement `to_string()`, or we can implement `std::fmt::Display`, which
    automatically provides `to_string()`. As a bonus, with the `Display` trait, we
    can also use it in the `format!("{}", something)` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `src/models/user_status.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s time to implement the `get_user()` function in `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we add the required `use` directives, and then we remove the underscore
    from `_db` and `_uuid` to mark it as a used variable. Then, we acquire a single
    connection from the database pool or return `InternalServerError` if there's something
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we set the connection variable, we can execute the `find()` method we
    defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only expose a simple error, `NotFound`, for this case, but a more complex
    application should handle the error properly, such as logging the error and returning
    the proper error status and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can construct the HTML string and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice we added two links for editing this user and to go to `/users`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to implement the `get_users()` function so
    the application can handle a `/users` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GET users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement `get_users()`. Here is a quick reminder of what the function
    looked like in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we should prepare the routines we''re going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/models/user.rs`, create a method called `find_all`, as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameter for `find_all` is `Connection`, which has the connection pool
    and the optional `Pagination`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the function is successful, we want to return a vector of `User` and `Pagination`.
    We can wrap it as a *tuple* in parentheses `()`, but there''s a possibility that
    there''s no further row in the database, so we wrap the returned `Pagination`
    in `Option`. We then split it into two methods to make it easier to read: `find_all_without_pagination`
    and `find_all_with_pagination`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify `src/models/pagination.rs` a little bit, and add `DEFAULT_LIMIT`
    to limit the number of users we want to fetch at a single time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then create and implement the function for the base case in `src/models/user.rs`,
    `find_all_without_pagination`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like the `find()` method, we define `query_str` and execute the query, and
    bind the `Vec<User>` result to the `users` variable. But, why do we pass the `&mut
    Connection<DBConnection>` database connection pool this time? Let''s continue
    the function first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We then prepare the returned pagination, setting it to `None` first. If the
    fetched users are equal to `DEFAULT_LIMIT`, there's a possibility of a next row,
    so we do the second query to the database. Since we cannot reuse a single connection,
    we have to obtain a new connection again from the database pool. That's why we
    pass `&mut Connection<DBConnection>` to `find_all` and `find_all_without_pagination`
    instead of `&mut PgConnection`. If there's the next row, we can return the pagination
    wrapped in `Some()`. But, what is `BoolWrapper`? We need to set a type to put
    the result of the `"SELECT EXISTS..."` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `pub mod bool_wrapper;` to `src/models/mod.rs` and create a new file, `src/models/bool_wrapper.rs`,
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't forget to add `use super::bool_wrapper::BoolWrapper;` to `src/models/user.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement `find_all_with_pagination`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The private method works like `find_all_without_pagination`, but we add a `WHERE`
    condition to start querying from a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement the `get_users()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we have obtained `users` and `new_pagination`, we can construct the HTML
    for the return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the link to the next page if we have `new_pagination`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice we use `timestamp_nanos()` to convert time to `i64` to make it easier
    to transport in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize the function, append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have to implement `FromFormField` for `OurDateTime` since we are using
    `OurDateTime` in the pagination. In `src/models/our_date_time.rs`, add the required
    `use` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we are cloning `OurDateTime` inside the `User` implementation (`users.last().unwrap().created_at``Clone`
    for `OurDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `from_value` implementation, we are just parsing `i64` from the request
    parameter and converting it to the `OurDateTime` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But, for `from_data`, we have to be more involved because we have to convert
    the request to `bytes`, convert it again into `&str`, and finally, into `i64`.
    First, we get the Rocket limit for the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, get the `bytes` from the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we convert `bytes` to `&str`, parse it as `i64`, and convert it
    to `OurDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, `get_user` and `get_users` are ready, but we do not have any data yet.
    In the next section, we are going to implement the `new_user` and `create_user`
    functions so we can insert user data through an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing POST user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a user, we are going to use the `new_user` and `create_user` functions.
    The `new_user()` function is relatively easy to implement; we just need to serve
    an HTML page with a form for a user to fill in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `new_user()` function in `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the HTML, we set the `form` tag `action` attribute to `"/users"` and the
    `method` attribute to `"POST"`. This corresponds to the `create_user` route in
    our application. On the HTML page, we have fields for `username`, `email`, `password`,
    `password_confirmation`, and `description`. We then insert the button to submit
    and serve the `html_string` to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the application now and open `http://127.0.0.1:8000/users/new`
    in the web browser. Finally, we have something we can render in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 ‒ New user page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 ‒ New user page
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously, before implementing the `create_user()` function, we want to
    create other routines first. Since the HTML form has no one-to-one mapping to
    a `User` struct, we create another struct. Put this struct in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set the derive `FromForm` trait for `NewUser`, so on top of the struct fields,
    we use the `field` directive. This directive can be used to match the request
    payload field name to the struct field name, set the default value, and validate
    the content of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have HTML form field that is different from the struct field name, we
    can rename the field using field directive like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you use uncased macro, then the payload HTML field name containing any case,
    such as `HTML-FIELD-NAME`, will be matched to the struct field name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For setting the default value, the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And, for validation, the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of built-in validation functions in the `rocket::form::validate`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contains`: This function succeeds when the field as a string has this substring,
    or the field as a `Vec` contains this item, or `Option` has `Some(value)`, or
    `rocket::form::Result` has `Ok(value)` – for example, `contains("foo")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eq`: This function succeeds when the field value is equal to the function
    parameters. A type in Rust can be compared if the type implements `std::cmp::PartialEq`.
    You can see the example in the `NewUser` struct, `eq(self.password)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ext`: This function succeeds if the field type is `rocket::fs::TempFile` and
    the content type matches the function parameter – for example, `ext(rocket::http::ContentType::JavaScript)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len`: This function succeeds if the length of the field value is within the
    parameter range. You can see the example in our `NewUser` struct, `len(5..20)`.
    In Rust, we define the range as `from..to`, but we can omit the `to` part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ne`: This function succeeds if the field value is not equal (`!=`) to the
    provided parameter. A type implementing the `std::cmp::PartialEq` trait can also
    use the inequality operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`omits`: This function is the opposite of `contains`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`one_of`: This function succeeds if the value contains one of the items in
    the supplied parameter. The parameter must be an iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`: This function is like `len`, but it matches the value of the field
    instead of the value of the length of the field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with`: We can pass a function or closure with the Boolean return type, and
    the function succeeds when the passed function or closure returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides those functions, there are three more functions we can use. The functions
    work almost the same, but with different messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dbg_contains`: This function also returns the field value in the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dbg_eq`: This function also returns the item value in the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dbg_omits`: This function also returns the item value in the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `NewUser` struct, we can see that we can also set a custom error message
    by combining the validation function with `.or_else("other message"`, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Besides the provided functions, we can create a custom validation function.
    The function should return `form::Result<'_, ()>`. We want to implement custom
    validation for checking the strength of the password and the correctness of the
    email.
  prefs: []
  type: TYPE_NORMAL
- en: The first validation is password validation. We are going to use a crate called
    `zxcvbn`. This crate is a Rust port of the `npm` module of the same name created
    by Dropbox. The inspiration for the `zxcvbn` library is based on an `"CorrectHorseBatteryStaple"`,
    are easier to remember and harder to crack compared to some rule such as *must
    contain a minimum of eight characters, of which one is upper case, one lower case,
    and one is a number*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `zxcvbn = "2"` to the `Cargo.toml` dependencies, then create the following
    function in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can set the scoring strength up to four, but it means we cannot send a weak
    password to the server. Right now, we just set the threshold of the password score
    to two.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can implement the validation for email correctness. First, add
    `regex = "1.5.4"` to `Cargo.toml` and add this function in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the email `NewUser` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we can implement the `create()` method for the `User` struct. For security
    purposes, we will hash the password using the secure password-hashing function.
    In 2021, people considered `md5` as a very insecure hashing function, and `sha1`
    and `sha3` as insecure hashing functions, so we will not use those functions.
    People usually consider using `bcrypt`, `scrypt`, or `argon2` instead. Now, `argon2`
    has a version, `argon2id`, which is resistant to side-channel attacks and GPU
    cracking attacks, so we will use `argon2` as a password-hashing implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is another possible attack on the `create()` method: `"<script>console.log("hack")</script>"`
    as a description. We can rectify this problem by using an HTML sanitization library
    called `ammonia`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add `argon2` and `ammonia` for the `create()` method, add these lines in
    `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a function to sanitize HTML in `src/models/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default cleaner from `ammonia::Builder::default` allows many HTML tags,
    and people can still deface the site. To rectify this problem, we are passing
    an empty `HashSet` to disallow any HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the password hashing and HTML sanitization are ready, it is time to implement
    the `create()` method for the `User` struct. Add the required `use` directives
    in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put these lines in the `impl User` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We generate a new UUID for the new `User` instance. After that, we clean the
    username value and description value. We don't clean the email and password because
    we already validate the content of the email using a regex and we will not show
    any password in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, append the following lines to hash the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we send the `INSERT` statement to our database server and return the
    inserted row. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the `User::create()` method is ready, we can implement the `create_user()`
    function. When the application successfully creates a user, it's better to show
    the result by redirecting to `get_user`. For this purpose, we can use the `rocket::response::Redirect`
    type instead of `RawHtml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, if there's an error, it's better to redirect to `new_user()` and show
    the error so the user can fix the input error. We can do this by getting the error
    of the `NewUser` validations or any other error, and redirecting to the `new_user()`
    function with embedded error information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the errors for the request form value using `rocket::form::Contextual`,
    a proxy for the form type that contains error information. We also going to use
    `rocket::response::Flash` to send a one-time cookie to the web browser and retrieve
    the message on a route using `rocket::request::FlashMessage`. Append these lines
    to `src/routes/user.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the signature of the `create_user()` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are sending `POST` data, the browser will send `Content-Type` as
    `"application/x-www-form-urlencoded"`, so we have to change the format accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, take a look at the request parameter; instead of `Form<NewUser<'r>>`,
    we are inserting the `Contextual` type in the middle of the parameter. We are
    also changing the return value to `Result<Flash<Redirect>, Flash<Redirect>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the function body. Append the following lines to the
    function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `user_context` has `value`, it means that Rocket successfully converted the
    request payload and put it inside the `value` attribute. We are branching and
    returning `Error` with a `Flash` message and `Redirect` directive to `"/users/new"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next implementation is if Rocket successfully parses `NewUser`. Append
    the following lines in the `true` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like the `get_user()` function, we create a routine to get the database
    connection, perform an `INSERT` operation to the database server, and generate
    the successful `Redirect` response. But, when an error occurs, instead of returning
    HTML, we generate the `Redirect` directive with the appropriate path and message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to change the `new_user()` and `get_user()` functions to be able
    to handle incoming `FlashMessage` request guards. First, for the `new_user()`
    function, change the signature to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the flash message may not always exist, we wrap it in `Option`. After
    `let mut html_string = String::from(USER_HTML_PREFIX);`, append the following
    lines in the function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We change the `new_user()` function almost the same. Change the function signature
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, append the following lines after `USER_HTML_PREFIX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to try creating the user data. If everything is correct, you
    should see screens like the following. The error message looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 ‒ Error message when failed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 ‒ Error message when failed
  prefs: []
  type: TYPE_NORMAL
- en: 'The success message looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 ‒ Success message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 ‒ Success message
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we are going to continue with updating the user and deleting
    a user.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing PUT and PATCH user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the user, we need a page such as `new_user()`, but we want the form
    pre-populated with existing data. We also want to add another field for the user
    to confirm the old password. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `edit_user()` function signature to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the existing user, append the following lines inside the function body
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can append the HTML, such as `new_user()`, but this time, we
    also include the existing data from the user. Append the following lines inside
    the `edit_user()` function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, all previous links to `"/users/edit/{}"` that we implemented in
    the previous pages should work.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the code, we see the form's `method` attribute has a `"POST"`
    value. The reason is that the HTML standard says that a form method can only be
    `GET` or `POST`. Most web browsers will just change the invalid method, such as
    `PUT` and `PATCH`, to `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: Some web frameworks work around this limitation by sending an `POST` request
    but include a hidden value in the request payload. We are going to use the second
    way to implement updating the user by adding a new field, `name="_METHOD"`, with
    the `"PUT"` value.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `create_user()`, we want to execute `update_function()` to redirect
    to `edit_user()` again if there's something wrong. We also want to execute `update_function()`
    to redirect to the user page again after successfully updating the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are adding new payloads, `_METHOD` and `old_password`, we need a new
    type that is different from `NewUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new struct called `EditedUser` in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to skip updating the password if there''s no value in `old_password`,
    but if there is a value in `old_password`, we want to make sure the `password`
    strength is adequate and `password_confirmation` has the same content as `password`.
    Create a function in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the validation function in the directive above the password field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need a method for `User` to update the database row based on the `EditedUser`
    content. This method will also verify the hash of `old_password` to make sure
    `EditedUser` is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `use` directive in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new method inside the `impl User` block in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the method, fetch the old user data from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prepare the data for updating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we can change the password or skip changing the password depending
    on whether or not we have `old_password or not`, prepare the query items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we are updating `password`, we need to verify `old_password` with the existing
    password. We also want to hash a new password and add the password to `set_strings`.
    Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then construct the `UPDATE` statement to update the user, execute the
    statement, and return the `User` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it''s time to use `EditedUser` and implement `update_user()`. Append `EditedUser`
    in the `use` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `update_user()` function in `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the function, we need to check whether the form is correct or not. Append
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can tell the application to process depending on `"_METHOD"`. Append the
    following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don't waste the functions we defined before. We are using the `put_user()`
    and `patch_user()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement the `put_user()` function. Change the signature
    of the `put_user()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, implement the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `patch_user()` function, we can just reuse the `put_user()` function.
    Write the code for `patch_user()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, append the new route in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only endpoint left is for deleting the user. Let's continue with that in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DELETE user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do to delete a user is to create a method for the
    `User` struct. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the method to delete a user in the `impl User` block in `src/models/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can implement the `delete_user()` function in `src/routes/user.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that neither the link nor the form in HTML are allowed to use
    the `DELETE` method. We cannot use the link, as any bot seeing it will crawl on
    it and could perform resource deletion accidentally. As with updating the user,
    we can use the form and send a `POST` request to a new endpoint. Add a new function
    in `src/routes/user.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t forget to add the route in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, where can we create a form to delete the user? Let''s do that on the `get_user()`
    page. Append the HTML for the form as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now completed all of the endpoints used to manage users. Try adding
    users and see how pagination works or try improving the HTML. You can also try
    activating users for a challenge!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the basic operations for user entities
    by implementing the creation, reading, updating, and deleting of user routes.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned more about various modules of the Rocket framework such as RawHtml,
    Redirect, Contextual, Flash, Form, and FlashMessage.
  prefs: []
  type: TYPE_NORMAL
- en: Along with implementing the endpoints, we also learned more about database operations
    such as querying, inserting, updating, and deleting objects on a database server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn more about error handling and creating
    our own error types.
  prefs: []
  type: TYPE_NORMAL
