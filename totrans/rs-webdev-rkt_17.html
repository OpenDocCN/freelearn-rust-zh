<html><head></head><body>
		<div><h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor145"/>Chapter 14</em>: Building a Full Stack Application</h1>
			<p>In this chapter, we are going to learn how to build a simple WebAssembly application and use Rocket to serve the WebAssembly application. We are going to make WebAssembly load the user information from one of the endpoints that we created earlier. After learning the information in this chapter, you will be able to write and build a WebAssembly application using Rust. You will learn how to serve WebAssembly using the Rocket web framework.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Introducing WebAssembly</li>
				<li>Setting up a Cargo workspace</li>
				<li>Setting a WebAssembly build target</li>
				<li>Writing a WebAssembly application using Yew</li>
				<li>Serving a WebAssembly application using Rocket </li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>The technical requirements for this chapter are very simple: the Rust compiler, the Cargo command line, and a web browser.</p>
			<p>You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14</a>.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor147"/>Introducing WebAssembly</h1>
			<p>In the past, almost <a id="_idIndexMarker707"/>all applications in the web browser were made using the JavaScript language. There were also attempts to use different languages in the web browser, such as Java Applet, Adobe Flash, and Silverlight. But, all those different attempts were not web standards, and, therefore, the adoption of those attempts was not as universal as JavaScript.</p>
			<p>However, there is a way to use other programming languages in the web browser: by using <strong class="bold">WebAssembly</strong>. WebAssembly is both a binary executable format and its corresponding text format for a stack-based virtual machine. Web browsers that support WebAssembly can execute the binary executable format. Any programming language that can be compiled into WebAssembly can be executed by web browsers.</p>
			<p>In 2015, WebAssembly was announced and was first released in March 2017. All major web browser vendors finished the release of browsers with minimum support for WebAssembly in September 2017, and then World Wide Web Consortium recommended WebAssembly on December 5th, 2019. </p>
			<p>Compiled languages such as C++ or Rust can be compiled into a <code>.wasm</code> file, and a virtual machine in the browser can then run the WebAssembly file. To run interpreted languages, first, the language runtime can be compiled into a <code>.wasm</code> file, and then, the runtime can run the runtime scripts.</p>
			<div><div><img src="img/Figure_14.1_B16825.jpg" alt="Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 ‒ Interpreted languages and compiled languages in WebAssembly</p>
			<p>The Rust programming <a id="_idIndexMarker708"/>language supports WebAssembly, and as we have already learned about Rust and created a backend application using Rust and Rocket, we can take this opportunity to learn a little about frontend application development using Rust. The old web standards and web technologies, such as HTML, CSS, and JavaScript, are technologies that changed the course of human history. Learning about new web standards, such as WebAssembly, is a good opportunity to be a part of future development.</p>
			<p>Let's implement a page in our application where we will render an empty template. The template will load WebAssembly binary from the server. WebAssembly will call the user API endpoint that we created earlier. It will then render users using a custom component.</p>
			<p>For the implementation, we are <a id="_idIndexMarker709"/>going to use Yew (<a href="https://yew.rs">https://yew.rs</a>), which is a frontend Rust framework.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Setting up a Cargo workspace</h1>
			<p>Since we are <a id="_idIndexMarker710"/>going to create a new application, it would be nice if we could make the code for the <code>our_application</code> Rocket application work alongside this new application. Cargo has a feature called <strong class="bold">Cargo workspaces</strong>. A Cargo workspace<a id="_idIndexMarker711"/> is a set of different Cargo packages in a single directory.</p>
			<p>Let's set up a Cargo workspace to have multiple applications in a single directory using the following steps:</p>
			<ol>
				<li>Create a directory, for example, <code>01Wasm</code>.</li>
				<li>Move the <code>our_application</code> directory inside the <code>01Wasm</code> directory and create a new <code>Cargo.toml</code> file inside the <code>01Wasm</code> directory.</li>
				<li>Edit the <code>Cargo.toml</code> file as follows:<pre>[workspace]
members = [
  "our_application",
]</pre></li>
				<li>Create a new Rust application inside <code>01Wasm</code> using this command:<pre><strong class="bold">cargo new our_application_wasm</strong></pre></li>
				<li>After that, add the new application as a member of the workspace in <code>01Wasm/Cargo.toml</code>, as follows:<pre>members = [
  "our_application",
  "our_application_wasm",
]</pre></li>
				<li>Try building both applications using this command:<pre><strong class="bold">cargo build</strong></pre></li>
				<li>To <a id="_idIndexMarker712"/>build or run one of the applications, append <code>--bin</code> with the binary package name, or <code>--lib</code> with the library package name. To run the application, consider the location of the directories required for running the Rocket application. For example, if there's no logs directory, the application might fail to run. Also, if there's no static directory, the application might not be able to find the assets file. </li>
				<li>Try building one of the applications by running this command in the terminal:<pre><strong class="bold">cargo build --bin our_application</strong></pre></li>
			</ol>
			<p>Now that we have set up the Cargo workspace, we can learn how to build the application for a different target specifically for WebAssembly.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Setting a WebAssembly build target</h1>
			<p>The <a id="_idIndexMarker713"/>Rust compiler can be set to compile to a different architecture. The architectures are also called <code>x86_64-unknown-linux_gnu</code> and <code>x86_64-apple-darwin</code>.</p>
			<p>Targets can be categorized into three tiers, tier 1, tier 2, and tier 3: </p>
			<ul>
				<li><strong class="bold">Tier 1</strong> means <a id="_idIndexMarker717"/>that the target is guaranteed to work properly. </li>
				<li><strong class="bold">Tier 2</strong> means <a id="_idIndexMarker718"/>that the target is guaranteed to build but, sometimes, the automated test to build the binary for the targets may not pass. The host tools and full standard library for this tier are also supported. </li>
				<li><strong class="bold">Tier 3</strong> means<a id="_idIndexMarker719"/> that the Rust code base supports some features of the targets. The build for those targets may or may not exist, and the tooling might not be complete.</li>
			</ul>
			<p>Remember that WebAssembly is a binary format for a virtual machine. The Rust compiler has targets for the virtual machine specifications, such as <code>asmjs-unknown-emscripten</code>, <code>wasm32-unknown-emscripten</code>, or <code>wasm32-unknown-unknown</code>. The community mostly supports the tooling around <code>wasm32-unknown-unknown</code>.</p>
			<p>To see the<a id="_idIndexMarker720"/> available <a id="_idIndexMarker721"/>target list for the Rust compiler, run the following command in the terminal:</p>
			<pre>rustup target list</pre>
			<p>To add <a id="_idIndexMarker722"/>WebAssembly target support for the Rust compiler, run the following command in the terminal:</p>
			<pre>rustup target add wasm32-unknown-unknown</pre>
			<p>After adding the target, try building <code>our_application_wasm</code> by running this command:</p>
			<pre>cargo build --target wasm32-unknown-unknown --bin our_application_wasm</pre>
			<p>We will use <code>wasm32-unknown-unknown</code> to build the WebAssembly application in the next section.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Writing a WebAssembly application using Yew</h1>
			<p>In the <a id="_idIndexMarker723"/>application, we are going to use Yew (https://yew.rs). On<a id="_idIndexMarker724"/> the website, it says that Yew is a modern Rust framework for creating multithreaded frontend web apps. </p>
			<p>Cargo can<a id="_idIndexMarker725"/> compile the WebAssembly binary, but the WebAssembly binary itself is not usable without other steps. We have to load the WebAssembly binary in the web browser's virtual machine engine. There are proposals such as using a <code>&lt;script type="module"&gt;&lt;/script&gt;</code> tag, but unfortunately, those proposals are not standard yet. We have to tell JavaScript to load the module using the WebAssembly Web API. To make the development easier, we can use <code>wasm-pack</code> from the<a id="_idIndexMarker726"/> Rust WebAssembly working group at https://rustwasm.github.io/. Yew uses an application <a id="_idIndexMarker727"/>named <code>trunk</code> (https://trunkrs.dev) that wraps <code>wasm-pack</code> and provides other conveniences. Install <code>trunk</code> by using this command:</p>
			<pre>cargo install --locked trunk</pre>
			<p>Now that the preparation for compiling WebAssembly has been completed, we can write the code <a id="_idIndexMarker728"/>for the WebAssembly application. Follow<a id="_idIndexMarker729"/> these steps to create the application:</p>
			<ol>
				<li value="1">Create an HTML file named <code>index.html</code> inside the <code>our_application_wasm</code> directory. We will use this HTML file to mimic the template on <code>our_application</code>, with small differences. We want to add an ID for an HTML tag to be the main tag for the WebAssembly application. Let's name this ID <code>main_container</code>. Append the following lines to <code>our_application_wasm/index.html</code>:<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;header&gt;
    &lt;a href="/" class="button"&gt;Home&lt;/a&gt;
  &lt;/header&gt;
  &lt;div class="container" id="main_container"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>Add <code>yew</code> as a dependency to <code>our_application_wasm</code>. We also want to access the browser DOM, so we need another <a id="_idIndexMarker730"/>dependency. Gloo (<a href="https://gloo-rs.web.app/">https://gloo-rs.web.app/</a>) provides bindings to the Web API, and we want to use <code>gloo_utils</code> as a dependency for our WebAssembly application to access the DOM. Add the following dependencies to <code>our_application_wasm/Cargo.toml</code>:<pre>gloo-utils = "0.1.3"
yew = "0.19"
getrandom = { version = "0.2", features = ["js"] }</pre></li>
				<li>Add the required <code>use</code> declarations in <code>our_application_wasm/src/main.rs</code>:<pre>use gloo_utils::document;
use yew::prelude::*;</pre></li>
				<li>Create<a id="_idIndexMarker731"/> a minimal component that <a id="_idIndexMarker732"/>creates an empty HTML inside <code>our_application_wasm/src/main.rs</code>:<pre>#[function_component(App)]
fn app() -&gt; Html {
    html! {
        &lt;&gt;{"Hello WebAssembly!"}&lt;/&gt;
    }
}</pre></li>
				<li>Use <code>gloo_utils</code> in the <code>main()</code> function in <code>our_application_wasm/src/main.rs</code> to select the <code>div</code> tag with the <code>main_container</code> ID. Append the following lines in the <code>main()</code> function:<pre>let document = document();
let main_container = document.query_selector("#main_container").unwrap().unwrap();</pre></li>
				<li>Initialize a Yew application by appending this line to the <code>main()</code> function:<pre>yew::start_app_in_element::&lt;App&gt;(main_container);</pre></li>
				<li>We can use <code>trunk</code> to create a small web server and build everything needed to build the WebAssembly and related JavaScript to load the WebAssembly and serve the HTML. Run <a id="_idIndexMarker733"/>this command<a id="_idIndexMarker734"/> in the terminal inside the <code>our_application_wasm</code> directory: <pre><strong class="bold">trunk serve</strong></pre></li>
			</ol>
			<p>There should be an output like the following in the terminal:</p>
			<pre>Apr 27 20:35:44.122  INFO fetching cargo artifacts
Apr 27 20:35:44.747  INFO processing WASM
Apr 27 20:35:44.782  INFO using system installed binary app="wasm-bindgen" version="0.2.80"
Apr 27 20:35:44.782  INFO calling wasm-bindgen
Apr 27 20:35:45.065  INFO copying generated wasm-bindgen artifacts
Apr 27 20:35:45.072  INFO applying new distribution
Apr 27 20:35:45.074  INFO ✅ success
Apr 27 20:35:45.074  INFO 📡 serving static assets at -&gt; /
Apr 27 20:35:45.075  INFO 📡 server listening at 0.0.0.0:8080
Apr 27 20:53:10.796  INFO 📦 starting build
Apr 27 20:53:10.797  INFO spawning asset pipelines
Apr 27 20:53:11.430  INFO building our_application_wasm</pre>
			<ol>
				<li value="8">Try opening a web browser to <code>http://127.0.0.1:8080</code>; you'll see that it loads and runs the Yew WebAssembly application:</li>
			</ol>
			<div><div><img src="img/Figure_14.2_B16825.jpg" alt="Figure 14.2 ‒ Hello WebAssembly!&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 ‒ Hello WebAssembly!</p>
			<ol>
				<li value="9">We are <a id="_idIndexMarker735"/>going to get users' information <a id="_idIndexMarker736"/>using an API endpoint that returns the JSON that we created earlier in <code>our_application</code> from <code>http://127.0.0.1:8000/api/users</code>. To convert the JSON into Rust types, let's define similar types to those in <code>our_application</code>. The types should derive SerDes' <code>deserialize</code>. In <code>our_application_wasm/Cargo.toml</code>, add the dependencies for the WebAssembly code:<pre>chrono = {version = "0.4", features = ["serde"]}
serde = {version = "1.0.130", features = ["derive"]}
uuid = {version = "0.8.2", features = ["v4", "serde"]}</pre></li>
				<li>Then, in <code>our_application_wasm/src/main.rs</code>, add the required <code>use</code> declarations:<pre>use chrono::{offset::Utc, DateTime};
use serde::Deserialize;
use std::fmt::{self, Display, Formatter};
use uuid::Uuid;</pre></li>
				<li>Finally, add the types to deserialize the JSON:<pre>#[derive(Deserialize, Clone, PartialEq)]
enum UserStatus {
    Inactive = 0,
    Active = 1,
}
impl fmt::Display for UserStatus {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; 
    fmt::Result {
        match *self {
            UserStatus::Inactive =&gt; write!(f, 
            "Inactive"),
            UserStatus::Active =&gt; write!(f, "Active"),
        }
    }
}
#[derive(Copy, Clone, Deserialize, PartialEq)]
struct OurDateTime(DateTime&lt;Utc&gt;);
impl fmt::Display for OurDateTime {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; 
    fmt::Result {
        write!(f, "{}", self.0)
    }
}
#[derive(Deserialize, Clone, PartialEq)]
struct User {
    uuid: Uuid,
    username: String,
    email: String,
    description: Option&lt;String&gt;,
    status: UserStatus,
    created_at: OurDateTime,
    updated_at: OurDateTime,
}
#[derive(Clone, Copy, Deserialize, PartialEq)]
struct Pagination {
    next: OurDateTime,
    limit: usize,
}
#[derive(Deserialize, Default, Properties, PartialEq)]
struct UsersWrapper {
    users: Vec&lt;User&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pagination: Option&lt;Pagination&gt;,
}</pre><p class="callout-heading">Note</p><p class="callout">One thing that we can do to improve redefining the types is to create a library that defines types that can be used by both applications.</p></li>
				<li>If we look at the <code>User</code> struct, we can see that the description field is an <code>Option</code>. Create a convenience <a id="_idIndexMarker737"/>function to return an empty <code>String</code> if the value is <code>None</code>, and return the <code>String</code> content of <code>Some</code> if the value is <code>Some</code>. Add the following function to <code>our_application_wasm/src/main.rs</code>: <pre>struct DisplayOption&lt;T&gt;(pub Option&lt;T&gt;);
impl&lt;T: Display&gt; Display for DisplayOption&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self.0 {
            Some(ref v) =&gt; write!(f, "{}", v),
            None =&gt; write!(f, ""),
        }
    }
}</pre></li>
				<li>It's now<a id="_idIndexMarker738"/> time to implement a component that will render <code>User</code>. We will name the component <code>UsersList</code>. Add the following function to <code>our_application_wasm/src/main.rs</code>:<pre>#[function_component(UsersList)]
fn users_list(UsersWrapper { users, .. }: &amp;UsersWrapper) -&gt; Html {
    users.iter()
        .enumerate().map(|user| html! {
        &lt;div class="container"&gt;
            &lt;div&gt;&lt;mark class="tag"&gt;{ format!("{}", 
            user.0) }&lt;/mark&gt;&lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "UUID:" 
                }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                user.1.uuid) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ 
                "Username:" }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt;{ format!("{}", 
                user.1.username) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Email:" 
                }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                user.1.email) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ 
                "Description:" }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                DisplayOption(user.1.description.
                as_ref())) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ 
                "Status:" }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                user.1.status) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Created 
                At:" }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                user.1.created_at) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Updated 
                At:" }&lt;/mark&gt;&lt;/div&gt;
                &lt;div class="col-sm-9"&gt; { format!("{}", 
                user.1.updated_at) }&lt;/div&gt;
            &lt;/div&gt;
            &lt;a href={format!("/users/{}", 
            user.1.uuid)} class="button"&gt;{ "See user" 
            }&lt;/a&gt;
        &lt;/div&gt;
    }).collect()
}</pre></li>
			</ol>
			<p>Notice that the <code>html!</code> macro content looks like the content of <code>our_application/src/views/users/_user.html.tera</code>.</p>
			<ol>
				<li value="14">We <a id="_idIndexMarker739"/>want to load the <code>User</code> data from<a id="_idIndexMarker740"/> the API endpoint. We can do this by using two libraries, <code>reqwasm</code> (which provides HTTP request functionality), and <code>wasm-bindgen-futures</code> (which converts Rust <code>futures</code> into JavaScript <code>promise</code> and vice versa). Add the following dependencies to <code>our_application_wasm/Cargo.toml</code>:<pre>reqwasm = "0.2"
wasm-bindgen-futures = "0.4"</pre></li>
				<li>In <code>our_application_wasm/src/main.rs</code>, add a <code>const</code> for our API endpoint. Add the following line:<pre>const USERS_URL: &amp;str = "http://127.0.0.1:8000/api/users";</pre></li>
				<li>Implement the routine to fetch the <code>User</code> data. Add the required <code>use</code> declaration:<pre>use reqwasm::http::Request;</pre></li>
			</ol>
			<p>Then, append the following lines inside the <code>app()</code> function in <code>our_application_wasm/src/main.rs</code>:</p>
			<pre>fn app() -&gt; Html {
<strong class="bold">    let users_wrapper = use_state(|| UsersWrapper::</strong>
<strong class="bold">    default());</strong>
<strong class="bold">    {</strong>
<strong class="bold">        let users_wrapper = users_wrapper.clone();</strong>
<strong class="bold">        use_effect_with_deps(</strong>
<strong class="bold">            move |_| {</strong>
<strong class="bold">                let users_wrapper = </strong>
<strong class="bold">                users_wrapper.clone();</strong>
<strong class="bold">                wasm_bindgen_futures::spawn_</strong>
<strong class="bold">                local(async move {</strong>
<strong class="bold">                    let fetched_users_wrapper: </strong>
<strong class="bold">                    UsersWrapper = Request::get(</strong>
<strong class="bold">                    USERS_URL)</strong>
<strong class="bold">                        .send()</strong>
<strong class="bold">                        .await</strong>
<strong class="bold">                        .unwrap()</strong>
<strong class="bold">                        .json()</strong>
<strong class="bold">                        .await</strong>
<strong class="bold">                        .unwrap();</strong>
<strong class="bold">                    users_wrapper.set(fetched_</strong>
<strong class="bold">                    users_wrapper);</strong>
<strong class="bold">                });</strong>
<strong class="bold">                || ()</strong>
<strong class="bold">            },</strong>
<strong class="bold">            (),</strong>
<strong class="bold">        );</strong>
<strong class="bold">    }</strong>
}</pre>
			<ol>
				<li value="17">Below the <code>{}</code> block under the <code>users_wrapper</code> fetching, set the value for <code>next</code> and <code>limit</code>. Append<a id="_idIndexMarker741"/> the following lines:<pre>let users_wrapper = use_state(|| UsersWrapper::default());
{
    ...
}
<strong class="bold">let (next, limit): (Option&lt;OurDateTime&gt;, Option&lt;usize&gt;) = if users_wrapper.pagination.is_some()</strong>
<strong class="bold">{</strong>
<strong class="bold">    let pagination = users_wrapper.</strong>
<strong class="bold">    pagination.as_ref().unwrap();</strong>
<strong class="bold">    (Some(pagination.next), Some(pagination.limit))</strong>
<strong class="bold">} else {</strong>
<strong class="bold">    (None, None)</strong>
<strong class="bold">};</strong></pre></li>
				<li>Change the<a id="_idIndexMarker742"/> HTML from <code>Hello WebAssembly!</code> to show the proper <code>User</code> information. We want to use the <code>UsersList</code> component that we created earlier. Change the <code>html!</code> macro content into the following:<pre>html! {
    &lt;&gt;
        &lt;UsersList users = {users_wrapper.
        users.clone()}/&gt;
        if next.is_some() {
            &lt;a href={ format!("/users?
            pagination.next={}&amp;pagination.limit={}", 
            DisplayOption(next), DisplayOption(limit)) 
            } class="button"&gt;
                { "Next" }
            &lt;/a&gt;
        }
    &lt;/&gt;
}</pre></li>
				<li>Build<a id="_idIndexMarker743"/> the <code>our_application_wasm</code> WebAssembly and JavaScript by running this command in the terminal:<pre><strong class="bold">trunk build</strong></pre></li>
			</ol>
			<p>The command should generate three files in the <code>dist</code> directory: <code>index.html</code>, a WebAssembly file with random name, and a JavaScript file with random name. The example of random WebAssembly and JavaScript file are <code>index-9eb0724334955a2a_bg.wasm</code> and <code>index-9eb0724334955a2a.js</code> in the <code>dist</code> directory.</p>
			<p>At this point, we<a id="_idIndexMarker744"/> have successfully written and built a WebAssembly application. In the next section, we are going to learn how to serve a WebAssembly application using Rocket.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Serving a WebAssembly application using Rocket </h1>
			<p>In this section, we <a id="_idIndexMarker745"/>are going to serve <a id="_idIndexMarker746"/>the WebAssembly web application using the following steps:</p>
			<ol>
				<li value="1">To run the WebAssembly file in <code>our_application</code>, we have to modify <code>our_application</code> a little bit. First, copy the WebAssembly and the JavaScript from <code>our_application_wasm/dist</code> to the <code>our_application/static</code> directory.</li>
				<li>Edit the template to be able to selectively use WebAssembly in <code>our_application/src/views/template.html.tera</code> as follows:<pre>&lt;head&gt;
  ...
  <strong class="bold">{% block wasm %}{% endblock wasm %}</strong>
  &lt;meta...&gt; 
&lt;/head&gt;
&lt;body&gt;
  ...
  <strong class="bold">{% block wasmscript %}{% endblock wasmscript %}</strong>
&lt;/body&gt;</pre></li>
				<li>Add a <a id="_idIndexMarker747"/>new template file named <code>our_application/src/views/users/wasm.html.tera</code>. Edit the file<a id="_idIndexMarker748"/> in order to make sure the HTML file loads the necessary WebAssembly and JavaScript file, and run the WebAssembly on the right DOM. Add the following lines:<pre>{% extends "template" %}
{% block wasm %}
&lt;link rel="preload" href="/assets/index-9eb0724334955a2a_bg.wasm" as="fetch" type="application/wasm" crossorigin=""&gt;
&lt;link rel="modulepreload" href="/assets/index-9eb0724334955a2a.js"&gt;
{% endblock wasm %}
{% block body %}
&lt;div id="main_container"&gt;&lt;/div&gt;
{% endblock body %}
{% block wasmscript %}
&lt;script type="module"&gt;import init from '/assets/index-9eb0724334955a2a.js';init('/assets/index-9eb0724334955a2a_bg.wasm');&lt;/script&gt;
{% endblock wasmscript %}</pre></li>
				<li>Add a<a id="_idIndexMarker749"/> new route handling function<a id="_idIndexMarker750"/> to load just the generated HTML. Add the following function in <code>our_application/src/routes/user.rs</code>:<pre>#[get("/users/wasm", format = "text/html")]
pub async fn wasm() -&gt; HtmlResponse {
    let context = context! {};
    Ok(Template::render("users/wasm", context))
}</pre></li>
				<li>Finally, don't forget to load the route. Add the new route in <code>our_application/src/lib.rs</code>:<pre>user::delete_user_entry_point,
<strong class="bold">user::wasm,</strong>
post::get_post,</pre></li>
				<li>Run the <code>our_application</code> web server by running <code>cargo run</code> in the <code>our_application</code> directory, and then open <code>http://127.0.0.1:8000/users/wasm</code> in the web browser. If we inspect the web browser developer tools, we can see that the web browser runs the JavaScript and WebAssembly, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_14.3_B16825.jpg" alt="Figure 14.3 ‒ Web browser loading and running our_application_wasm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 ‒ Web browser loading and running our_application_wasm</p>
			<p><a id="_idIndexMarker751"/>WebAssembly <a id="_idIndexMarker752"/>should run properly by modifying the tag with the <code>main_container</code> tag, then loading the JSON from <code>http://127.0.0.1:8000/api/users</code> and rendering the HTML in the web browser properly.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Summary</h1>
			<p>Web technology has evolved to allow web browsers to run a universal binary format for a virtual machine. Web browsers can now run a binary generated by the Rust compiler.</p>
			<p>In this chapter, we have looked at an overview of WebAssembly, and how to prepare the Rust compiler to compile to WebAssembly. We also learned how to set up a Cargo workspace to have more than one application in a single directory. </p>
			<p>We then learned how to write a simple frontend application that loads the <code>User</code> data from the <code>our_application</code> API endpoint that we created earlier using Yew and other Rust libraries.</p>
			<p>Finally, we finished with how to serve the generated WebAssembly and JavaScript in the <code>our_application</code> web server.</p>
			<p>The next chapter is the final chapter, and we're going to see how we can expand the Rocket application and find alternatives to it.</p>
		</div>
	</body></html>