<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor145"/>Chapter 14</em>: Building a Full Stack Application</h1>
			<p>In this chapter, we are going to learn how to build a simple WebAssembly application and use Rocket to serve the WebAssembly application. We are going to make WebAssembly load the user information from one of the endpoints that we created earlier. After learning the information in this chapter, you will be able to write and build a WebAssembly application using Rust. You will learn how to serve WebAssembly using the Rocket web framework.</p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Introducing WebAssembly</li>
				<li>Setting up a Cargo workspace</li>
				<li>Setting a WebAssembly build target</li>
				<li>Writing a WebAssembly application using Yew</li>
				<li>Serving a WebAssembly application using Rocket </li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>The technical requirements for this chapter are very simple: the Rust compiler, the Cargo command line, and a web browser.</p>
			<p>You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter14</a>.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor147"/>Introducing WebAssembly</h1>
			<p>In the past, almost <a id="_idIndexMarker707"/>all applications in the web browser were made using the JavaScript language. There were also attempts to use different languages in the web browser, such as Java Applet, Adobe Flash, and Silverlight. But, all those different attempts were not web standards, and, therefore, the adoption of those attempts was not as universal as JavaScript.</p>
			<p>However, there is a way to use other programming languages in the web browser: by using <strong class="bold">WebAssembly</strong>. WebAssembly is both a binary executable format and its corresponding text format for a stack-based virtual machine. Web browsers that support WebAssembly can execute the binary executable format. Any programming language that can be compiled into WebAssembly can be executed by web browsers.</p>
			<p>In 2015, WebAssembly was announced and was first released in March 2017. All major web browser vendors finished the release of browsers with minimum support for WebAssembly in September 2017, and then World Wide Web Consortium recommended WebAssembly on December 5th, 2019. </p>
			<p>Compiled languages such as C++ or Rust can be compiled into a <strong class="source-inline">.wasm</strong> file, and a virtual machine in the browser can then run the WebAssembly file. To run interpreted languages, first, the language runtime can be compiled into a <strong class="source-inline">.wasm</strong> file, and then, the runtime can run the runtime scripts.</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_14.1_B16825.jpg" alt="Figure 14.1 â€’ Interpreted languages and compiled languages in WebAssembly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 â€’ Interpreted languages and compiled languages in WebAssembly</p>
			<p>The Rust programming <a id="_idIndexMarker708"/>language supports WebAssembly, and as we have already learned about Rust and created a backend application using Rust and Rocket, we can take this opportunity to learn a little about frontend application development using Rust. The old web standards and web technologies, such as HTML, CSS, and JavaScript, are technologies that changed the course of human history. Learning about new web standards, such as WebAssembly, is a good opportunity to be a part of future development.</p>
			<p>Let's implement a page in our application where we will render an empty template. The template will load WebAssembly binary from the server. WebAssembly will call the user API endpoint that we created earlier. It will then render users using a custom component.</p>
			<p>For the implementation, we are <a id="_idIndexMarker709"/>going to use Yew (<a href="https://yew.rs">https://yew.rs</a>), which is a frontend Rust framework.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Setting up a Cargo workspace</h1>
			<p>Since we are <a id="_idIndexMarker710"/>going to create a new application, it would be nice if we could make the code for the <strong class="source-inline">our_application</strong> Rocket application work alongside this new application. Cargo has a feature called <strong class="bold">Cargo workspaces</strong>. A Cargo workspace<a id="_idIndexMarker711"/> is a set of different Cargo packages in a single directory.</p>
			<p>Let's set up a Cargo workspace to have multiple applications in a single directory using the following steps:</p>
			<ol>
				<li>Create a directory, for example, <strong class="source-inline">01Wasm</strong>.</li>
				<li>Move the <strong class="source-inline">our_application</strong> directory inside the <strong class="source-inline">01Wasm</strong> directory and create a new <strong class="source-inline">Cargo.toml</strong> file inside the <strong class="source-inline">01Wasm</strong> directory.</li>
				<li>Edit the <strong class="source-inline">Cargo.toml</strong> file as follows:<p class="source-code">[workspace]</p><p class="source-code">members = [</p><p class="source-code">Â Â "our_application",</p><p class="source-code">]</p></li>
				<li>Create a new Rust application inside <strong class="source-inline">01Wasm</strong> using this command:<p class="source-code"><strong class="bold">cargo new our_application_wasm</strong></p></li>
				<li>After that, add the new application as a member of the workspace in <strong class="source-inline">01Wasm/Cargo.toml</strong>, as follows:<p class="source-code">members = [</p><p class="source-code">Â Â "our_application",</p><p class="source-code">Â Â "our_application_wasm",</p><p class="source-code">]</p></li>
				<li>Try building both applications using this command:<p class="source-code"><strong class="bold">cargo build</strong></p></li>
				<li>To <a id="_idIndexMarker712"/>build or run one of the applications, append <strong class="source-inline">--bin</strong> with the binary package name, or <strong class="source-inline">--lib</strong> with the library package name. To run the application, consider the location of the directories required for running the Rocket application. For example, if there's no logs directory, the application might fail to run. Also, if there's no static directory, the application might not be able to find the assets file. </li>
				<li>Try building one of the applications by running this command in the terminal:<p class="source-code"><strong class="bold">cargo build --bin our_application</strong></p></li>
			</ol>
			<p>Now that we have set up the Cargo workspace, we can learn how to build the application for a different target specifically for WebAssembly.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Setting a WebAssembly build target</h1>
			<p>The <a id="_idIndexMarker713"/>Rust compiler can be set to compile to a different architecture. The architectures are also called <strong class="bold">targets</strong>. Targets<a id="_idIndexMarker714"/> can be identified by <a id="_idIndexMarker715"/>using <strong class="bold">target triple</strong>, a string that consists of three identifiers to be sent to the compiler. Examples <a id="_idIndexMarker716"/>of targets are <strong class="source-inline">x86_64-unknown-linux_gnu</strong> and <strong class="source-inline">x86_64-apple-darwin</strong>.</p>
			<p>Targets can be categorized into three tiers, tier 1, tier 2, and tier 3: </p>
			<ul>
				<li><strong class="bold">Tier 1</strong> means <a id="_idIndexMarker717"/>that the target is guaranteed to work properly. </li>
				<li><strong class="bold">Tier 2</strong> means <a id="_idIndexMarker718"/>that the target is guaranteed to build but, sometimes, the automated test to build the binary for the targets may not pass. The host tools and full standard library for this tier are also supported. </li>
				<li><strong class="bold">Tier 3</strong> means<a id="_idIndexMarker719"/> that the Rust code base supports some features of the targets. The build for those targets may or may not exist, and the tooling might not be complete.</li>
			</ul>
			<p>Remember that WebAssembly is a binary format for a virtual machine. The Rust compiler has targets for the virtual machine specifications, such as <strong class="source-inline">asmjs-unknown-emscripten</strong>, <strong class="source-inline">wasm32-unknown-emscripten</strong>, or <strong class="source-inline">wasm32-unknown-unknown</strong>. The community mostly supports the tooling around <strong class="source-inline">wasm32-unknown-unknown</strong>.</p>
			<p>To see the<a id="_idIndexMarker720"/> available <a id="_idIndexMarker721"/>target list for the Rust compiler, run the following command in the terminal:</p>
			<p class="source-code">rustup target list</p>
			<p>To add <a id="_idIndexMarker722"/>WebAssembly target support for the Rust compiler, run the following command in the terminal:</p>
			<p class="source-code">rustup target add wasm32-unknown-unknown</p>
			<p>After adding the target, try building <strong class="source-inline">our_application_wasm</strong> by running this command:</p>
			<p class="source-code">cargo build --target wasm32-unknown-unknown --bin our_application_wasm</p>
			<p>We will use <strong class="source-inline">wasm32-unknown-unknown</strong> to build the WebAssembly application in the next section.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Writing a WebAssembly application using Yew</h1>
			<p>In the <a id="_idIndexMarker723"/>application, we are going to use Yew (https://yew.rs). On<a id="_idIndexMarker724"/> the website, it says that Yew is a modern Rust framework for creating multithreaded frontend web apps. </p>
			<p>Cargo can<a id="_idIndexMarker725"/> compile the WebAssembly binary, but the WebAssembly binary itself is not usable without other steps. We have to load the WebAssembly binary in the web browser's virtual machine engine. There are proposals such as using a <strong class="source-inline">&lt;script type="module"&gt;&lt;/script&gt;</strong> tag, but unfortunately, those proposals are not standard yet. We have to tell JavaScript to load the module using the WebAssembly Web API. To make the development easier, we can use <strong class="source-inline">wasm-pack</strong> from the<a id="_idIndexMarker726"/> Rust WebAssembly working group at https://rustwasm.github.io/. Yew uses an application <a id="_idIndexMarker727"/>named <strong class="source-inline">trunk</strong> (https://trunkrs.dev) that wraps <strong class="source-inline">wasm-pack</strong> and provides other conveniences. Install <strong class="source-inline">trunk</strong> by using this command:</p>
			<p class="source-code">cargo install --locked trunk</p>
			<p>Now that the preparation for compiling WebAssembly has been completed, we can write the code <a id="_idIndexMarker728"/>for the WebAssembly application. Follow<a id="_idIndexMarker729"/> these steps to create the application:</p>
			<ol>
				<li value="1">Create an HTML file named <strong class="source-inline">index.html</strong> inside the <strong class="source-inline">our_application_wasm</strong> directory. We will use this HTML file to mimic the template on <strong class="source-inline">our_application</strong>, with small differences. We want to add an ID for an HTML tag to be the main tag for the WebAssembly application. Let's name this ID <strong class="source-inline">main_container</strong>. Append the following lines to <strong class="source-inline">our_application_wasm/index.html</strong>:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">Â Â &lt;header&gt;</p><p class="source-code">Â Â Â Â &lt;a href="/" class="button"&gt;Home&lt;/a&gt;</p><p class="source-code">Â Â &lt;/header&gt;</p><p class="source-code">Â Â &lt;div class="container" id="main_container"&gt;&lt;/div&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Add <strong class="source-inline">yew</strong> as a dependency to <strong class="source-inline">our_application_wasm</strong>. We also want to access the browser DOM, so we need another <a id="_idIndexMarker730"/>dependency. Gloo (<a href="https://gloo-rs.web.app/">https://gloo-rs.web.app/</a>) provides bindings to the Web API, and we want to use <strong class="source-inline">gloo_utils</strong> as a dependency for our WebAssembly application to access the DOM. Add the following dependencies to <strong class="source-inline">our_application_wasm/Cargo.toml</strong>:<p class="source-code">gloo-utils = "0.1.3"</p><p class="source-code">yew = "0.19"</p><p class="source-code">getrandom = { version = "0.2", features = ["js"] }</p></li>
				<li>Add the required <strong class="source-inline">use</strong> declarations in <strong class="source-inline">our_application_wasm/src/main.rs</strong>:<p class="source-code">use gloo_utils::document;</p><p class="source-code">use yew::prelude::*;</p></li>
				<li>Create<a id="_idIndexMarker731"/> a minimal component that <a id="_idIndexMarker732"/>creates an empty HTML inside <strong class="source-inline">our_application_wasm/src/main.rs</strong>:<p class="source-code">#[function_component(App)]</p><p class="source-code">fn app() -&gt; Html {</p><p class="source-code">Â Â Â Â html! {</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;&gt;{"Hello WebAssembly!"}&lt;/&gt;</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>Use <strong class="source-inline">gloo_utils</strong> in the <strong class="source-inline">main()</strong> function in <strong class="source-inline">our_application_wasm/src/main.rs</strong> to select the <strong class="source-inline">div</strong> tag with the <strong class="source-inline">main_container</strong> ID. Append the following lines in the <strong class="source-inline">main()</strong> function:<p class="source-code">let document = document();</p><p class="source-code">let main_container = document.query_selector("#main_container").unwrap().unwrap();</p></li>
				<li>Initialize a Yew application by appending this line to the <strong class="source-inline">main()</strong> function:<p class="source-code">yew::start_app_in_element::&lt;App&gt;(main_container);</p></li>
				<li>We can use <strong class="source-inline">trunk</strong> to create a small web server and build everything needed to build the WebAssembly and related JavaScript to load the WebAssembly and serve the HTML. Run <a id="_idIndexMarker733"/>this command<a id="_idIndexMarker734"/> in the terminal inside the <strong class="source-inline">our_application_wasm</strong> directory: <p class="source-code"><strong class="bold">trunk serve</strong></p></li>
			</ol>
			<p>There should be an output like the following in the terminal:</p>
			<p class="source-code">Apr 27 20:35:44.122Â Â INFO fetching cargo artifacts</p>
			<p class="source-code">Apr 27 20:35:44.747Â Â INFO processing WASM</p>
			<p class="source-code">Apr 27 20:35:44.782Â Â INFO using system installed binary app="wasm-bindgen" version="0.2.80"</p>
			<p class="source-code">Apr 27 20:35:44.782Â Â INFO calling wasm-bindgen</p>
			<p class="source-code">Apr 27 20:35:45.065Â Â INFO copying generated wasm-bindgen artifacts</p>
			<p class="source-code">Apr 27 20:35:45.072Â Â INFO applying new distribution</p>
			<p class="source-code">Apr 27 20:35:45.074Â Â INFO âœ… success</p>
			<p class="source-code">Apr 27 20:35:45.074Â Â INFO ðŸ“¡ serving static assets at -&gt; /</p>
			<p class="source-code">Apr 27 20:35:45.075Â Â INFO ðŸ“¡ server listening at 0.0.0.0:8080</p>
			<p class="source-code">Apr 27 20:53:10.796Â Â INFO ðŸ“¦ starting build</p>
			<p class="source-code">Apr 27 20:53:10.797Â Â INFO spawning asset pipelines</p>
			<p class="source-code">Apr 27 20:53:11.430Â Â INFO building our_application_wasm</p>
			<ol>
				<li value="8">Try opening a web browser to <strong class="source-inline">http://127.0.0.1:8080</strong>; you'll see that it loads and runs the Yew WebAssembly application:</li>
			</ol>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_14.2_B16825.jpg" alt="Figure 14.2 â€’ Hello WebAssembly!&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 â€’ Hello WebAssembly!</p>
			<ol>
				<li value="9">We are <a id="_idIndexMarker735"/>going to get users' information <a id="_idIndexMarker736"/>using an API endpoint that returns the JSON that we created earlier in <strong class="source-inline">our_application</strong> from <strong class="source-inline">http://127.0.0.1:8000/api/users</strong>. To convert the JSON into Rust types, let's define similar types to those in <strong class="source-inline">our_application</strong>. The types should derive SerDes' <strong class="source-inline">deserialize</strong>. In <strong class="source-inline">our_application_wasm/Cargo.toml</strong>, add the dependencies for the WebAssembly code:<p class="source-code">chrono = {version = "0.4", features = ["serde"]}</p><p class="source-code">serde = {version = "1.0.130", features = ["derive"]}</p><p class="source-code">uuid = {version = "0.8.2", features = ["v4", "serde"]}</p></li>
				<li>Then, in <strong class="source-inline">our_application_wasm/src/main.rs</strong>, add the required <strong class="source-inline">use</strong> declarations:<p class="source-code">use chrono::{offset::Utc, DateTime};</p><p class="source-code">use serde::Deserialize;</p><p class="source-code">use std::fmt::{self, Display, Formatter};</p><p class="source-code">use uuid::Uuid;</p></li>
				<li>Finally, add the types to deserialize the JSON:<p class="source-code">#[derive(Deserialize, Clone, PartialEq)]</p><p class="source-code">enum UserStatus {</p><p class="source-code">Â Â Â Â Inactive = 0,</p><p class="source-code">Â Â Â Â Active = 1,</p><p class="source-code">}</p><p class="source-code">impl fmt::Display for UserStatus {</p><p class="source-code">Â Â Â Â fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; </p><p class="source-code">Â Â Â Â fmt::Result {</p><p class="source-code">Â Â Â Â Â Â Â Â match *self {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â UserStatus::Inactive =&gt; write!(f, </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â "Inactive"),</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â UserStatus::Active =&gt; write!(f, "Active"),</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p><p class="source-code">#[derive(Copy, Clone, Deserialize, PartialEq)]</p><p class="source-code">struct OurDateTime(DateTime&lt;Utc&gt;);</p><p class="source-code">impl fmt::Display for OurDateTime {</p><p class="source-code">Â Â Â Â fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; </p><p class="source-code">Â Â Â Â fmt::Result {</p><p class="source-code">Â Â Â Â Â Â Â Â write!(f, "{}", self.0)</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p><p class="source-code">#[derive(Deserialize, Clone, PartialEq)]</p><p class="source-code">struct User {</p><p class="source-code">Â Â Â Â uuid: Uuid,</p><p class="source-code">Â Â Â Â username: String,</p><p class="source-code">Â Â Â Â email: String,</p><p class="source-code">Â Â Â Â description: Option&lt;String&gt;,</p><p class="source-code">Â Â Â Â status: UserStatus,</p><p class="source-code">Â Â Â Â created_at: OurDateTime,</p><p class="source-code">Â Â Â Â updated_at: OurDateTime,</p><p class="source-code">}</p><p class="source-code">#[derive(Clone, Copy, Deserialize, PartialEq)]</p><p class="source-code">struct Pagination {</p><p class="source-code">Â Â Â Â next: OurDateTime,</p><p class="source-code">Â Â Â Â limit: usize,</p><p class="source-code">}</p><p class="source-code">#[derive(Deserialize, Default, Properties, PartialEq)]</p><p class="source-code">struct UsersWrapper {</p><p class="source-code">Â Â Â Â users: Vec&lt;User&gt;,</p><p class="source-code">Â Â Â Â #[serde(skip_serializing_if = "Option::is_none")]</p><p class="source-code">Â Â Â Â #[serde(default)]</p><p class="source-code">Â Â Â Â pagination: Option&lt;Pagination&gt;,</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">One thing that we can do to improve redefining the types is to create a library that defines types that can be used by both applications.</p></li>
				<li>If we look at the <strong class="source-inline">User</strong> struct, we can see that the description field is an <strong class="source-inline">Option</strong>. Create a convenience <a id="_idIndexMarker737"/>function to return an empty <strong class="source-inline">String</strong> if the value is <strong class="source-inline">None</strong>, and return the <strong class="source-inline">String</strong> content of <strong class="source-inline">Some</strong> if the value is <strong class="source-inline">Some</strong>. Add the following function to <strong class="source-inline">our_application_wasm/src/main.rs</strong>: <p class="source-code">struct DisplayOption&lt;T&gt;(pub Option&lt;T&gt;);</p><p class="source-code">impl&lt;T: Display&gt; Display for DisplayOption&lt;T&gt; {</p><p class="source-code">Â Â Â Â fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {</p><p class="source-code">Â Â Â Â Â Â Â Â match self.0 {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Some(ref v) =&gt; write!(f, "{}", v),</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â None =&gt; write!(f, ""),</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â }</p><p class="source-code">}</p></li>
				<li>It's now<a id="_idIndexMarker738"/> time to implement a component that will render <strong class="source-inline">User</strong>. We will name the component <strong class="source-inline">UsersList</strong>. Add the following function to <strong class="source-inline">our_application_wasm/src/main.rs</strong>:<p class="source-code">#[function_component(UsersList)]</p><p class="source-code">fn users_list(UsersWrapper { users, .. }: &amp;UsersWrapper) -&gt; Html {</p><p class="source-code">Â Â Â Â users.iter()</p><p class="source-code">Â Â Â Â Â Â Â Â .enumerate().map(|user| html! {</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;div class="container"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div&gt;&lt;mark class="tag"&gt;{ format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â user.0) }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "UUID:" </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.uuid) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Username:" }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt;{ format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.username) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Email:" </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.email) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Description:" }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â DisplayOption(user.1.description.</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â as_ref())) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Status:" }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.status) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Created </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â At:" }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.created_at) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="row"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-3"&gt;&lt;mark&gt;{ "Updated </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â At:" }&lt;/mark&gt;&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &lt;div class="col-sm-9"&gt; { format!("{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â user.1.updated_at) }&lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;a href={format!("/users/{}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â user.1.uuid)} class="button"&gt;{ "See user" </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â }&lt;/a&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;/div&gt;</p><p class="source-code">Â Â Â Â }).collect()</p><p class="source-code">}</p></li>
			</ol>
			<p>Notice that the <strong class="source-inline">html!</strong> macro content looks like the content of <strong class="source-inline">our_application/src/views/users/_user.html.tera</strong>.</p>
			<ol>
				<li value="14">We <a id="_idIndexMarker739"/>want to load the <strong class="source-inline">User</strong> data from<a id="_idIndexMarker740"/> the API endpoint. We can do this by using two libraries, <strong class="source-inline">reqwasm</strong> (which provides HTTP request functionality), and <strong class="source-inline">wasm-bindgen-futures</strong> (which converts Rust <strong class="source-inline">futures</strong> into JavaScript <strong class="source-inline">promise</strong> and vice versa). Add the following dependencies to <strong class="source-inline">our_application_wasm/Cargo.toml</strong>:<p class="source-code">reqwasm = "0.2"</p><p class="source-code">wasm-bindgen-futures = "0.4"</p></li>
				<li>In <strong class="source-inline">our_application_wasm/src/main.rs</strong>, add a <strong class="source-inline">const</strong> for our API endpoint. Add the following line:<p class="source-code">const USERS_URL: &amp;str = "http://127.0.0.1:8000/api/users";</p></li>
				<li>Implement the routine to fetch the <strong class="source-inline">User</strong> data. Add the required <strong class="source-inline">use</strong> declaration:<p class="source-code">use reqwasm::http::Request;</p></li>
			</ol>
			<p>Then, append the following lines inside the <strong class="source-inline">app()</strong> function in <strong class="source-inline">our_application_wasm/src/main.rs</strong>:</p>
			<p class="source-code">fn app() -&gt; Html {</p>
			<p class="source-code"><strong class="bold">Â Â Â Â let users_wrapper = use_state(|| UsersWrapper::</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â default());</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â {</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â let users_wrapper = users_wrapper.clone();</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â use_effect_with_deps(</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â move |_| {</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let users_wrapper = </strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â users_wrapper.clone();</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â wasm_bindgen_futures::spawn_</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â local(async move {</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let fetched_users_wrapper: </strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â UsersWrapper = Request::get(</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â USERS_URL)</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .send()</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .await</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .unwrap()</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .json()</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .await</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .unwrap();</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â users_wrapper.set(fetched_</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â users_wrapper);</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â || ()</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â },</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â (),</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â Â Â Â Â );</strong></p>
			<p class="source-code"><strong class="bold">Â Â Â Â }</strong></p>
			<p class="source-code">}</p>
			<ol>
				<li value="17">Below the <strong class="source-inline">{}</strong> block under the <strong class="source-inline">users_wrapper</strong> fetching, set the value for <strong class="source-inline">next</strong> and <strong class="source-inline">limit</strong>. Append<a id="_idIndexMarker741"/> the following lines:<p class="source-code">let users_wrapper = use_state(|| UsersWrapper::default());</p><p class="source-code">{</p><p class="source-code">Â Â Â Â ...</p><p class="source-code">}</p><p class="source-code"><strong class="bold">let (next, limit): (Option&lt;OurDateTime&gt;, Option&lt;usize&gt;) = if users_wrapper.pagination.is_some()</strong></p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">Â Â Â Â let pagination = users_wrapper.</strong></p><p class="source-code"><strong class="bold">Â Â Â Â pagination.as_ref().unwrap();</strong></p><p class="source-code"><strong class="bold">Â Â Â Â (Some(pagination.next), Some(pagination.limit))</strong></p><p class="source-code"><strong class="bold">} else {</strong></p><p class="source-code"><strong class="bold">Â Â Â Â (None, None)</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
				<li>Change the<a id="_idIndexMarker742"/> HTML from <strong class="source-inline">Hello WebAssembly!</strong> to show the proper <strong class="source-inline">User</strong> information. We want to use the <strong class="source-inline">UsersList</strong> component that we created earlier. Change the <strong class="source-inline">html!</strong> macro content into the following:<p class="source-code">html! {</p><p class="source-code">Â Â Â Â &lt;&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â &lt;UsersList users = {users_wrapper.</p><p class="source-code">Â Â Â Â Â Â Â Â users.clone()}/&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â if next.is_some() {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;a href={ format!("/users?</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â pagination.next={}&amp;pagination.limit={}", </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â DisplayOption(next), DisplayOption(limit)) </p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â } class="button"&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â { "Next" }</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â &lt;/a&gt;</p><p class="source-code">Â Â Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â &lt;/&gt;</p><p class="source-code">}</p></li>
				<li>Build<a id="_idIndexMarker743"/> the <strong class="source-inline">our_application_wasm</strong> WebAssembly and JavaScript by running this command in the terminal:<p class="source-code"><strong class="bold">trunk build</strong></p></li>
			</ol>
			<p>The command should generate three files in the <strong class="source-inline">dist</strong> directory: <strong class="source-inline">index.html</strong>, a WebAssembly file with random name, and a JavaScript file with random name. The example of random WebAssembly and JavaScript file are <strong class="source-inline">index-9eb0724334955a2a_bg.wasm</strong> and <strong class="source-inline">index-9eb0724334955a2a.js</strong> in the <strong class="source-inline">dist</strong> directory.</p>
			<p>At this point, we<a id="_idIndexMarker744"/> have successfully written and built a WebAssembly application. In the next section, we are going to learn how to serve a WebAssembly application using Rocket.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Serving a WebAssembly application using Rocket </h1>
			<p>In this section, we <a id="_idIndexMarker745"/>are going to serve <a id="_idIndexMarker746"/>the WebAssembly web application using the following steps:</p>
			<ol>
				<li value="1">To run the WebAssembly file in <strong class="source-inline">our_application</strong>, we have to modify <strong class="source-inline">our_application</strong> a little bit. First, copy the WebAssembly and the JavaScript from <strong class="source-inline">our_application_wasm/dist</strong> to the <strong class="source-inline">our_application/static</strong> directory.</li>
				<li>Edit the template to be able to selectively use WebAssembly in <strong class="source-inline">our_application/src/views/template.html.tera</strong> as follows:<p class="source-code">&lt;head&gt;</p><p class="source-code">Â Â ...</p><p class="source-code">Â Â <strong class="bold">{% block wasm %}{% endblock wasm %}</strong></p><p class="source-code">Â Â &lt;meta...&gt; </p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">Â Â ...</p><p class="source-code">Â Â <strong class="bold">{% block wasmscript %}{% endblock wasmscript %}</strong></p><p class="source-code">&lt;/body&gt;</p></li>
				<li>Add a <a id="_idIndexMarker747"/>new template file named <strong class="source-inline">our_application/src/views/users/wasm.html.tera</strong>. Edit the file<a id="_idIndexMarker748"/> in order to make sure the HTML file loads the necessary WebAssembly and JavaScript file, and run the WebAssembly on the right DOM. Add the following lines:<p class="source-code">{% extends "template" %}</p><p class="source-code">{% block wasm %}</p><p class="source-code">&lt;link rel="preload" href="/assets/index-9eb0724334955a2a_bg.wasm" as="fetch" type="application/wasm" crossorigin=""&gt;</p><p class="source-code">&lt;link rel="modulepreload" href="/assets/index-9eb0724334955a2a.js"&gt;</p><p class="source-code">{% endblock wasm %}</p><p class="source-code">{% block body %}</p><p class="source-code">&lt;div id="main_container"&gt;&lt;/div&gt;</p><p class="source-code">{% endblock body %}</p><p class="source-code">{% block wasmscript %}</p><p class="source-code">&lt;script type="module"&gt;import init from '/assets/index-9eb0724334955a2a.js';init('/assets/index-9eb0724334955a2a_bg.wasm');&lt;/script&gt;</p><p class="source-code">{% endblock wasmscript %}</p></li>
				<li>Add a<a id="_idIndexMarker749"/> new route handling function<a id="_idIndexMarker750"/> to load just the generated HTML. Add the following function in <strong class="source-inline">our_application/src/routes/user.rs</strong>:<p class="source-code">#[get("/users/wasm", format = "text/html")]</p><p class="source-code">pub async fn wasm() -&gt; HtmlResponse {</p><p class="source-code">Â Â Â Â let context = context! {};</p><p class="source-code">Â Â Â Â Ok(Template::render("users/wasm", context))</p><p class="source-code">}</p></li>
				<li>Finally, don't forget to load the route. Add the new route in <strong class="source-inline">our_application/src/lib.rs</strong>:<p class="source-code">user::delete_user_entry_point,</p><p class="source-code"><strong class="bold">user::wasm,</strong></p><p class="source-code">post::get_post,</p></li>
				<li>Run the <strong class="source-inline">our_application</strong> web server by running <strong class="source-inline">cargo run</strong> in the <strong class="source-inline">our_application</strong> directory, and then open <strong class="source-inline">http://127.0.0.1:8000/users/wasm</strong> in the web browser. If we inspect the web browser developer tools, we can see that the web browser runs the JavaScript and WebAssembly, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_14.3_B16825.jpg" alt="Figure 14.3 â€’ Web browser loading and running our_application_wasm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 â€’ Web browser loading and running our_application_wasm</p>
			<p><a id="_idIndexMarker751"/>WebAssembly <a id="_idIndexMarker752"/>should run properly by modifying the tag with the <strong class="source-inline">main_container</strong> tag, then loading the JSON from <strong class="source-inline">http://127.0.0.1:8000/api/users</strong> and rendering the HTML in the web browser properly.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Summary</h1>
			<p>Web technology has evolved to allow web browsers to run a universal binary format for a virtual machine. Web browsers can now run a binary generated by the Rust compiler.</p>
			<p>In this chapter, we have looked at an overview of WebAssembly, and how to prepare the Rust compiler to compile to WebAssembly. We also learned how to set up a Cargo workspace to have more than one application in a single directory. </p>
			<p>We then learned how to write a simple frontend application that loads the <strong class="source-inline">User</strong> data from the <strong class="source-inline">our_application</strong> API endpoint that we created earlier using Yew and other Rust libraries.</p>
			<p>Finally, we finished with how to serve the generated WebAssembly and JavaScript in the <strong class="source-inline">our_application</strong> web server.</p>
			<p>The next chapter is the final chapter, and we're going to see how we can expand the Rocket application and find alternatives to it.</p>
		</div>
	</body></html>