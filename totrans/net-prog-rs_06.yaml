- en: Talking HTTP in the Internet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在互联网上谈论HTTP
- en: The single most important application-layer protocol that has changed our lives
    heavily has to be the HTTP. It forms the backbone of the World Wide Web (WWW).
    In this chapter, we will look at how Rust makes writing fast HTTP servers easier.
    We will also look at writing clients to communicate with these servers over a
    network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的应用层协议之一，它极大地改变了我们的生活，必须是HTTP。它是万维网（WWW）的骨干。在本章中，我们将探讨Rust如何使编写快速HTTP服务器变得更加容易。我们还将探讨编写客户端通过网络与这些服务器通信。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A short introduction to Hyper, one of the most widely used crates for writing
    HTTP servers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyper的简要介绍，它是编写HTTP服务器中最广泛使用的crate之一
- en: We will study Rocket, a new crate that has become widely popular owing to its
    simpler interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将研究Rocket，一个由于接口更简单而变得非常流行的crate
- en: We will move on to reqwest, an HTTP client library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将继续介绍reqwest，一个HTTP客户端库
- en: Introducing Hyper
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Hyper
- en: Hyper is arguably the most stable and well-known of Rust-based HTTP frameworks.
    It has two distinct components, one for writing HTTP servers and one for writing
    clients. Recently, the server component was moved to a new async programming model
    based on tokio and futures. As a result, it is well-suited for high-traffic workloads.
    However, like a lot of other libraries in the ecosystem, Hyper has not hit Version
    1.0 yet, so one should expect breaking API changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper可以说是基于Rust的HTTP框架中最稳定和最知名的。它有两个不同的组件，一个用于编写HTTP服务器，另一个用于编写客户端。最近，服务器组件被移动到一个基于tokio和futures的新异步编程模型。因此，它非常适合高流量工作负载。然而，像生态系统中的许多其他库一样，Hyper尚未达到版本1.0，因此应该预期API会有破坏性的变化。
- en: We will start with writing a small HTTP server in Hyper. Like always, we will
    need to set up our project using Cargo.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在Hyper中编写一个小型HTTP服务器开始。像往常一样，我们需要使用Cargo设置我们的项目。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us now add dependencies that will include `hyper` and `futures`. The `Cargo.toml`
    file will look as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加依赖项，包括`hyper`和`futures`。`Cargo.toml`文件将如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our main file is pretty simple. In the real world, HTTP servers often talk to
    a backend, and all that can take a while to complete. Thus, it is common for replies
    to be a bit delayed. We will simulate that using a function that sleeps for 200
    ms each time it is called, and then returns a fixed string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要文件相当简单。在现实世界中，HTTP服务器通常与后端进行通信，所有这些操作可能需要一段时间才能完成。因此，回复稍微延迟是很常见的。我们将使用一个每次调用时暂停200毫秒的函数来模拟这种情况，然后返回一个固定的字符串。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As Hyper heavily relies on `tokio` to do asynchronous handling of requests,
    an HTTP server in Hyper needs to implement a built-in trait called `Service` from
    `tokio`. This is essentially a function that maps a `Request` to a `Response`
    via an implementation of the `call` method. This method returns the result as
    a `Future`, indicating eventual completion of the given task. In that implementation,
    we match the method and path of the incoming request. If the method is `GET` and
    the path is `/data`, we call `heavy_work` and get the result. We then compose
    a response by setting the `Content-Length` header to the size of the string we
    are returning and the body of the response. In our `main` function, we construct
    our server by binding it to a known port. At the end, we call `run` on it to start
    the server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Hyper严重依赖`tokio`来处理异步请求，Hyper中的HTTP服务器需要实现来自`tokio`的内置特质`Service`。这本质上是一个将`Request`映射到`Response`的函数，通过实现`call`方法。此方法返回一个`Future`，表示给定任务的最终完成。在该实现中，我们匹配传入请求的方法和路径。如果方法是`GET`且路径是`/data`，我们调用`heavy_work`并获取结果。然后，我们通过设置返回字符串的大小作为`Content-Length`头和响应体来组合响应。在我们的`main`函数中，我们通过绑定到一个已知端口来构建我们的服务器。最后，我们调用`run`来启动服务器。
- en: 'Interacting with the server is easy with `curl`; a session should look like
    this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`与服务器交互很简单；会话应该如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us benchmark our server. For this, we will install ApacheBench ([https://httpd.apache.org/docs/trunk/programs/ab.html](https://httpd.apache.org/docs/trunk/programs/ab.html)).
    We will run 1,000 total requests from 100 clients in parallel by passing some
    command-line parameters to ApacheBench. This will take a while to complete, and
    we are waiting 200 ms before returning each response. So, for 1,000 requests,
    we will wait for at least 200 seconds. On one run, the output looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基准测试我们的服务器。为此，我们将安装ApacheBench ([https://httpd.apache.org/docs/trunk/programs/ab.html](https://httpd.apache.org/docs/trunk/programs/ab.html))。我们将通过向ApacheBench传递一些命令行参数，并行运行来自100个客户端的1,000个总请求。这需要一段时间才能完成，我们在返回每个响应之前等待200毫秒。因此，对于1,000个请求，我们将至少等待200秒。一次运行的结果如下：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that, across all requests, the server takes around 103.4 ms to reply
    back. This matches our expectation of 100 ms with the extra time being spent on
    other things. Also, our server is processing 4.92 requests per second, which is
    way too low for a reasonable server. This is all because our server is single-threaded,
    and only one thread serves all clients. This server also ignores the fact that
    multiple CPU cores are available on the host.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在整个请求过程中，服务器大约需要103.4毫秒来回复。这与我们预期的100毫秒相符，额外的耗时花在其他事情上。此外，我们的服务器每秒处理4.92个请求，这对于一个合理的服务器来说太低了。这全部是因为我们的服务器是单线程的，只有一个线程为所有客户端服务。这个服务器也忽略了主机上可用的多个CPU核心的事实。
- en: 'Let us go ahead and write a server that largely does the same thing, the difference
    being that this one uses multi-threading heavily and uses all CPU cores. Cargo
    setup should be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写一个服务器，它基本上做同样的事情，区别在于这个服务器大量使用多线程并使用所有CPU核心。Cargo设置应该是这样的：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will need to add some more crates as dependencies, and our `Cargo.toml`
    should be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一些额外的crate作为依赖项，我们的`Cargo.toml`应该是这样的：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have a number of extra things here. `tokio-core` will be used to run an
    event loop (as we did in mio, in [Chapter 3](part0046.html#1BRPS0-e803f047c8b7448c90887daa96419287), *TCP
    and UDP Using Rust*), `net2` will be used for some advanced socket configuration,
    and `num_cpus` will be used to figure out the number of CPU cores on the machine.
    Having set those up, our main file is pretty simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一些额外的事情。`tokio-core`将被用来运行一个事件循环（就像我们在`mio`中在[第3章](part0046.html#1BRPS0-e803f047c8b7448c90887daa96419287)，*使用Rust的TCP和UDP*），`net2`将被用来进行一些高级套接字配置，而`num_cpus`将被用来确定机器上的CPU核心数。设置好这些后，我们的主文件相当简单：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Functionally, this server is exactly the same as the last one. Architecturally,
    they are very different. Our implementation of `Service` is the same. What changed
    majorly is that we split starting the server into two functions; the serve function
    creates a new event loop (and a handle to it). We create our listener using `net2`
    so that we can set a bunch of options on it using the `TcpBuilder` pattern. Specifically,
    we set `SO_REUSEPORT` on the socket so that under high loads the OS can distribute
    connections to all threads fairly. We also set a backlog of 128 for the listening
    socket. We then loop over incoming connections on the listener and, for each,
    we run our service implementation. Our `start_server` method takes in an integer
    that corresponds to the number of cores on the host and an address as a string.
    We then start a loop and run the serve method in new threads. In this case, our
    `Http` instance will be passed to multiple threads. Thus, we need to wrap it in
    an **Automatically Reference Counting** (**ARC**) pointer because that guarantees
    thread safety of the underlying type. Finally, we call `start_server` in our `main`
    function, using `num_cpus::get` to get the number of cores on the machine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 功能上，这个服务器与上一个完全相同。在架构上，它们非常不同。我们的`Service`实现是相同的。主要变化是我们将启动服务器分成两个函数；`serve`函数创建一个新的事件循环（及其句柄）。我们使用`net2`创建监听器，这样我们就可以使用`TcpBuilder`模式设置一系列选项。具体来说，我们在套接字上设置了`SO_REUSEPORT`，这样在高负载下，操作系统可以公平地将连接分配给所有线程。我们还为监听套接字设置了128个回压。然后我们在监听器上循环处理传入的连接，并对每个连接运行我们的服务实现。我们的`start_server`方法接受一个整数，对应于主机上的核心数，以及一个字符串形式的地址。然后我们启动一个循环，在新线程中运行`serve`方法。在这种情况下，我们的`Http`实例将被传递到多个线程。因此，我们需要将其包装在一个**自动引用计数**（**ARC**）指针中，因为这保证了底层类型的线程安全性。最后，我们在`main`函数中调用`start_server`，使用`num_cpus::get`获取机器上的核心数。
- en: 'Benchmarking this in the same way as last time shows these results:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以与上次相同的方式基准测试，结果显示如下：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This server's throughput is around double the last one, primarily because it
    uses threading better. Requests still take just over 100 ms to process, as expected.
    Note that the actual time taken by this will depend on the hardware and conditions
    of the machine running this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器的吞吐量大约是上一个的两倍，主要是因为它更好地使用了线程。请求的处理时间仍然略超过 100 毫秒，正如预期的那样。请注意，实际所需时间将取决于运行此机器的硬件和条件。
- en: Introducing Rocket
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Rocket
- en: Perhaps the most widely known web framework for Rust is Rocket. It started as
    a one-man project and gradually evolved into a simple, elegant, and fast framework
    over the last year or so. Rocket focuses a lot on simplicity, something that a
    lot of Flask users will appreciate. Like Flask uses python decorators to declare
    routes, Rocket uses custom attributes to the same effect. Unfortunately, this
    means that Rocket has to make heavy use of nightly-only features. Thus, as of
    now, Rocket applications can only be built using nightly Rust. However, as more
    and more things are stabilized (moved to stable Rust), this restriction will eventually
    go away.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最广为人知的 Rust 网络框架是 Rocket。它最初是一个人的项目，并在过去一年左右的时间里逐渐发展成为一个简单、优雅且快速的框架。Rocket
    非常注重简洁性，这是许多 Flask 用户会欣赏的。像 Flask 使用 Python 装饰器来声明路由一样，Rocket 使用自定义属性来达到同样的效果。不幸的是，这意味着
    Rocket 必须大量使用仅限夜间构建的功能。因此，截至目前，Rocket 应用程序只能使用夜间 Rust 来构建。然而，随着越来越多的功能得到稳定（转移到稳定
    Rust），这种限制最终将消失。
- en: 'Let us start with a basic example of Rocket, beginning with setting up the
    project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Rocket 的一个基本示例开始，首先是设置项目：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our Cargo setup needs to add Rocket components as dependencies, and should
    look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Cargo 设置需要将 Rocket 组件作为依赖项添加，并且应该看起来像这样：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us look at the main file. As we will see, Rocket needs a bit of boilerplate
    setup:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看主文件。正如我们将看到的，Rocket 需要一些样板设置：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function called `blast_off` defines a route, a mapping between an incoming
    request and an output. In this case, a **GET** request to the `/` route should
    return a static string. In our main function, we initialize Rocket, add our routes,
    and call `launch`. Run it using Cargo:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `blast_off` 的函数定义了一个路由，即一个传入请求与输出之间的映射。在这种情况下，对 `/` 路由的 **GET** 请求应返回一个静态字符串。在我们的主函数中，我们初始化
    Rocket，添加我们的路由，并调用 `launch`。使用 Cargo 运行它：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In another terminal, if we use curl to hit that endpoint, this is what we should
    see:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，如果我们使用 curl 来访问该端点，我们应该看到以下内容：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Experienced Python users will find Rocket similar to the framework called Flask.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的 Python 用户会发现 Rocket 与名为 Flask 的框架类似。
- en: 'Let us now look at a more complex example: writing an API server using Rocket.
    Our application is a blog server that has the following endpoints:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更复杂的例子：使用 Rocket 编写 API 服务器。我们的应用程序是一个博客服务器，具有以下端点：
- en: '| **Endpoint** | **Method** | **Purpose** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **方法** | **目的** |'
- en: '| `/posts` | `GET` | Get all posts |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `/posts` | `GET` | 获取所有帖子 |'
- en: '| `/posts/<id>` | `GET` | Get the post with the given ID |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `/posts/<id>` | `GET` | 获取给定 ID 的帖子 |'
- en: '| `/posts` | `POST` | Add a new post |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `/posts` | `POST` | 添加新帖子 |'
- en: '| `/posts/<id>` | `PATCH` | Edit a post |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `/posts/<id>` | `PATCH` | 编辑帖子 |'
- en: '| `/posts/<id>` | `DELETE` | Delete the post with the given ID |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `/posts/<id>` | `DELETE` | 删除给定 ID 的帖子 |'
- en: For this example, we will use SQLite Version 3 as our database. A real application
    should use a more scalable database, such as PostgresSQL or MySQL. We will use
    the diesel crate as our **Object-Relational Mapping** (**ORM**) tool, and r2d2
    for connection-pooling to the database. The first step for this is to install
    the diesel CLI to work with database schema migrations. This can be installed
    using Cargo.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用 SQLite 版本 3 作为我们的数据库。一个真正的应用程序应该使用更可扩展的数据库，例如 PostgreSQL 或 MySQL。我们将使用
    diesel crate 作为我们的 **对象关系映射**（**ORM**）工具，并使用 r2d2 进行数据库连接池。为此，第一步是安装 diesel CLI
    以处理数据库模式迁移。这可以通过 Cargo 来安装。
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'SQLite Version 3 must be installed on the host''s system for this to work.
    For more information, visit the following link:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能正常工作，必须在主机系统上安装 SQLite 版本 3。有关更多信息，请访问以下链接：
- en: '[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)'
- en: Now we can set up our database using diesel CLI. It will read our migration
    scripts and create the whole schema. As SQLite is a file-based database, it will
    also create an empty `db` file, if one does not exist already.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 diesel CLI 来设置我们的数据库。它将读取我们的迁移脚本并创建整个模式。由于 SQLite 是基于文件的数据库，如果不存在，它还将创建一个空的
    `db` 文件。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember that the last command must be run from the directory that has the
    migrations directory, otherwise it will fail to find the migrations. We will use
    Cargo to set up the project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，最后一个命令必须从包含迁移目录的目录中运行，否则它将无法找到迁移。我们将使用 Cargo 来设置项目：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will then add a number of dependencies here; `Cargo.toml` should look like
    the following code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里添加一些依赖项；`Cargo.toml` 应该看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This app is a bit more complex than our previous example. This is composed
    of multiple modules, each doing a specific thing. Here is how the `src` directory
    looks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序比我们之前的例子要复杂一些。它由多个模块组成，每个模块执行特定的功能。以下是 `src` 目录的看起来：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first step in running this is to set up connection to the database. We
    will use r2d2 for database pooling; all the `db` setup-related operations will
    be in `db.rs`. This will look like the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序的第一步是设置与数据库的连接。我们将使用 r2d2 进行数据库连接池；所有与 `db` 设置相关的操作都将放在 `db.rs` 中。这看起来像以下代码片段：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our `DB` struct has an instance of the database pool and returns that on calling
    the function called `conn`. `FromRequest`. This is a request guard trait from
    Rocket that makes sure that particular requests can be fulfilled by the handler
    that matched. In our case, we use it to make sure a new connection is available
    in the pool, and we return an HTTP 500 error if that is not the case. Now this
    trait will be used for all incoming requests throughout the life of the program.
    Thus, for this to work correctly, the reference to the database pool must live
    throughout the program and not the local scope. We use the `lazy_static!` crate
    to make sure the constant `DB_POOL` is initialized only once and lives throughout
    the life of the program. In the macro, we set up `dotenv`, which will be used
    later to parse the database location and also the connection pool with a size
    of 32 connections. We also implement the `Deref` trait for our database wrapper
    so that `&*DB` is transparently translated to a `&SqliteConnection`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DB` 结构体有一个数据库连接池的实例，并在调用名为 `conn` 的函数时返回它。`FromRequest` 是来自 Rocket 的一个请求保护特质，它确保特定的请求可以被匹配的处理程序满足。在我们的情况下，我们使用它来确保连接池中有一个新的连接可用，如果没有，则返回
    HTTP 500 错误。现在这个特质将用于整个程序生命周期中的所有传入请求。因此，为了正确工作，数据库连接池的引用必须在整个程序生命周期中存在，而不是局部作用域。我们使用
    `lazy_static!` crate 来确保常量 `DB_POOL` 只初始化一次，并贯穿整个程序的生命周期。在宏中，我们设置了 `dotenv`，它将被用于稍后解析数据库位置以及大小为
    32 个连接的连接池。我们还为我们的数据库包装器实现了 `Deref` 特质，这样 `&*DB` 就可以透明地转换为 `&SqliteConnection`。
- en: 'The next step is to set up the database schema in code. Luckily, `diesel` makes
    that very easy, as it can read the database schema and generate Rust code to represent
    that accordingly. The generated Rust code is put in a module corresponding to
    the name of the file it is in (in this case, the module will be called `schema`).
    We use the `dotenv` crate to pass this information to a `diesel` macro. This is
    done in the file `schema.rs`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在代码中设置数据库模式。幸运的是，`diesel` 使得这一过程非常简单，因为它可以读取数据库模式并生成相应的 Rust 代码来表示。生成的 Rust
    代码被放置在一个与文件名对应的模块中（在这个例子中，模块将被命名为 `schema`）。我们使用 `dotenv` crate 将这些信息传递给 `diesel`
    宏。这是在文件 `schema.rs` 中完成的：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that once the new macro system is functional, this call will use the `dotenv!`
    macro. We can then use the generated schema to build our models. This is done
    in `models.rs`. This file will look like the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦新的宏系统可用，这个调用将使用 `dotenv!` 宏。然后我们可以使用生成的模式来构建我们的模型。这是在 `models.rs` 中完成的。这个文件看起来像以下代码片段：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have two major structures here: the `Post` structure represents a blog post
    in the database, and the `PostData` structure represents a blog post as seen in
    an incoming create request. As a `PostData` has not been saved in the database
    yet, it does not have an ID. Diesel necessitates that all types that can be queried
    should implement the `Queryable` trait, which is done automatically using `#[derive(Queryable)]`.
    We also enable serialization and deserialization using serde, as this will be
    passed as JSON to the API. In contrast, the `PostData` struct does not derive
    `Queryable`; it derives some other traits. The `Insertable` trait indicates that
    this struct can be used to insert a row of data in a table (with the specified
    table name). Because we will only need to deserialize this struct from an incoming
    request, we only implement `Deserialize` on it. Lastly, the `AsChangeSet` trait
    enables this struct to be used to update records in the database.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两大结构：`Post` 结构代表数据库中的博客文章，而 `PostData` 结构代表在传入的创建请求中看到的博客文章。由于 `PostData`
    尚未保存到数据库中，它没有 ID。Diesel 要求所有可以查询的类型都应该实现 `Queryable` 特性，这可以通过 `#[derive(Queryable)]`
    自动完成。我们还启用了使用 serde 的序列化和反序列化，因为这将作为 JSON 传递到 API。相比之下，`PostData` 结构不继承 `Queryable`；它继承了一些其他特性。`Insertable`
    特性表示这个结构可以用作在表中插入一行数据（指定表名）。因为我们只需要从传入的请求中反序列化这个结构，所以我们只实现了 `Deserialize`。最后，`AsChangeSet`
    特性使得这个结构可以用作更新数据库中的记录。
- en: The `FromData` trait is from Rocket, which is used to validate incoming data,
    making sure it parses into JSON correctly. This is in relation to a feature called
    data guards. When Rocket finds a suitable handler for an incoming request, it
    calls the data guard of the data type specified in the request handler on the
    incoming data. The route is actually invoked only if the data guard succeeds.
    These guards are implemented using the `FromData` trait. In our case, the implementation
    tries to parse the input as a JSON (using SerDe). In the success case, we return
    the JSON for further processing, or we return a `Status::BadRequest`, which sends
    back an HTTP 400 error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromData` 特性来自 Rocket，用于验证传入的数据，确保其正确解析为 JSON。这与一个名为数据守卫的功能相关。当 Rocket 找到适合传入请求的处理程序时，它会调用请求处理程序中指定数据类型的数据守卫对传入数据进行处理。只有当数据守卫成功时，路由才会实际调用。这些守卫是通过
    `FromData` 特性实现的。在我们的案例中，实现尝试将输入解析为 JSON（使用 SerDe）。在成功的情况下，我们返回 JSON 以供进一步处理，或者返回
    `Status::BadRequest`，这会发送 HTTP 400 错误。'
- en: 'The only database-related thing required now is the model. This will define
    a number of convenience methods that can be used to manipulate records using diesel.
    The file `post.rs` hosts these, and it looks like the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所需的唯一数据库相关事物是模型。这将定义一系列方便的方法，可以用来使用 diesel 操作记录。文件 `post.rs` 包含了这些方法，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function names are very self-explanatory. We make abundant use of a number
    of diesel APIs that help us to interact with the database without writing SQL
    directly. All of these functions take in a reference to the database connection.
    The `get_post` function takes in an additional post ID that it uses on the posts
    table to look up posts using the `find` method, and then returns the first result
    as an instance of `Post`. The `get_posts` function is similar, except it returns
    all records in the posts table as a vector of `Post` instances. `create_post`
    takes in a reference to `PostData` and inserts that record into the database.
    This function returns a `bool` indicating success or failure. `delete_post` takes
    in a post ID and tries to delete it in the database. `update_post` again takes
    in a reference to `PostData` and a post ID. It then tries to replace the post
    with the given ID with the new `PostData`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称非常直观。我们大量使用了 diesel API，这些 API 帮助我们与数据库交互，而无需直接编写 SQL。所有这些函数都接受数据库连接的引用。`get_post`
    函数接受一个额外的帖子 ID，它使用 `find` 方法在帖子表中查找帖子，然后返回第一个结果作为 `Post` 实例。`get_posts` 函数类似，但它返回帖子表中的所有记录作为
    `Post` 实例的向量。`create_post` 函数接受 `PostData` 的引用，并将该记录插入到数据库中。此函数返回一个 `bool` 值，指示成功或失败。`delete_post`
    函数接受帖子 ID 并尝试在数据库中删除它。`update_post` 再次接受 `PostData` 的引用和一个帖子 ID。然后它尝试用新的 `PostData`
    替换具有给定 ID 的帖子。
- en: Let us move on to defining errors for our API. This will be located in the file
    called `error.rs`. As will see here, the errors will need to implement a number
    of traits to be used seamlessly in Rocket and Diesel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义我们API的错误。这将位于名为`error.rs`的文件中。正如我们将看到的，错误需要实现多个特性，以便在Rocket和Diesel中无缝使用。
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our error is an `enum` called `ApiError`; for simplicity's sake, we will only
    return an object-not-found error and a catch-all internal server error. As we
    have seen in previous chapters, to declare an error in Rust, we will need to implement
    `fmt::Display` and `std::error::Error` on that type. We also implement `From<DieselError>`
    for our type so that a failure in the database lookup can be reported appropriately.
    The final trait we need to implement is `Responder` from Rocket, which enables
    us to use this as the return type of a request handler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误是一个名为`ApiError`的`enum`；为了简单起见，我们只返回一个对象未找到错误和一个通用的内部服务器错误。正如我们在前面的章节中看到的，为了在Rust中声明错误，我们需要在那种类型上实现`fmt::Display`和`std::error::Error`。我们还为我们类型实现了`From<DieselError>`，以便在数据库查找失败时能够适当地报告。我们需要实现的最后一个特性是Rocket的`Responder`，这使我们能够将其用作请求处理器的返回类型。
- en: 'Having done all the groundwork, the last part of the system is our main file
    that will run when invoked with Cargo. It should look like the following code
    snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有准备工作后，系统的最后一部分是我们主要的文件，当使用Cargo调用时将运行。它应该看起来像以下代码片段：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The most important things here are the route handlers. These are just regular
    functions with special attributes that determine the path, the format, and the
    arguments. Also, notice the use of instances of `DB` as request guards in the
    handlers. We have a helper function called `rocket` that sets up everything, and
    the `main` function just calls the `ignite` method to start the server. When `rocket`
    sees an incoming request, this is how a response is generated:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的东西是路由处理器。这些只是具有特殊属性的标准函数，用于确定路径、格式和参数。此外，请注意在处理器中使用`DB`实例作为请求保护。我们有一个名为`rocket`的辅助函数，用于设置一切，而`main`函数只是调用`ignite`方法来启动服务器。当`rocket`看到传入的请求时，这就是生成响应的方式：
- en: It goes over the list of all handlers and finds one that matches the HTTP method,
    type, and format. If one is found, it ensures that the handler's parameters can
    be derived from the data in the request using `FormData`. This process continues
    till a handler works or all handlers have been exhausted. In the latter case,
    a 404 error is returned.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会遍历所有处理器的列表，并找到一个与HTTP方法、类型和格式匹配的处理器。如果找到了一个，它会确保处理器的参数可以使用`FormData`从请求中的数据中推导出来。这个过程会一直持续到找到一个有效的处理器或者所有处理器都尝试过。在后一种情况下，会返回一个404错误。
- en: The handler function then receives a copy of the data parsed into the given
    data type. After it has done processing, it must use the `Responder` implementation
    to convert the output to a valid return type.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理函数随后会接收到解析到给定数据类型中的数据的副本。在它完成处理之后，它必须使用`Responder`实现将输出转换为有效的返回类型。
- en: Finally, `Rocket` sends back the response to the client.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`Rocket`将响应发送回客户端。
- en: 'Having set up everything, running the server is very easy:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好一切后，运行服务器非常简单：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For comparison, here is how a load testing session looks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，以下是负载测试会话的示例：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, to be fair to our earlier servers, we had a delay of 100 ms there. In this
    case, each request takes around 21 ms on average. So, hypothetically, if each
    request took 100 ms, we would have one fifth of the throughput. That comes up
    to be around 950 requests per second—way faster than our earlier servers!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了公平起见，我们之前的服务器那里有一个100毫秒的延迟。在这种情况下，每个请求平均需要21毫秒。所以，假设每个请求需要100毫秒，我们将有五分之一的吞吐量。这将达到大约每秒950个请求——比我们之前的服务器快得多！
- en: 'Now, obviously, an HTTP server cannot be all about REST endpoints. It must
    be able to serve static and dynamic content as well. For that, Rocket has a bunch
    of features to be able to generate HTML. Let us look at an example, which is a
    simple web page that takes in a name as a URL parameter and outputs that. The
    page also counts the total number of visits and displays that as well. The Cargo
    setup for this project is simple: we just run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显，一个HTTP服务器不能只关注REST端点。它还必须能够提供静态和动态内容。为此，Rocket提供了一系列功能，能够生成HTML。让我们看看一个例子，这是一个简单的网页，它接受一个作为URL参数的名称，并输出该名称。该页面还计算总访问次数，并将其显示出来。这个项目的Cargo设置很简单：我们只需运行以下命令：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, we will just need Rocket in our `Cargo.toml` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只需要在`Cargo.toml`文件中包含Rocket：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our web page will be generated from a template. We will use a templating engine
    called Tera, which is inspired by Jinja2 and is written in Rust. Rocket supports
    templates in a different crate called `rocket_contrib`, which we will pull in
    with required features. Our template is pretty simple and should look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网页将从一个模板生成。我们将使用一个名为 Tera 的模板引擎，它受到 Jinja2 的启发，并使用 Rust 编写。Rocket 支持一个名为
    `rocket_contrib` 的不同 crate 中的模板，我们将通过所需功能将其拉入。我们的模板非常简单，应该看起来像这样：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that the template has to be in a directory called `templates` in the project
    root, otherwise `Rocket` will not be able to find it. In this case, the template
    is pretty simple. It needs to be a complete HTML page, as we intend to display
    it in a browser. We use two temporary variables, `name` and `visitor_number`,
    that will be replaced during execution. Our main file will look like the following
    code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模板必须位于项目根目录下的 `templates` 目录中，否则 `Rocket` 将无法找到它。在这种情况下，模板非常简单。它需要是一个完整的
    HTML 页面，因为我们打算在浏览器中显示它。我们使用两个临时变量，`name` 和 `visitor_number`，它们将在执行期间被替换。我们的主文件将如下代码片段所示：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our setup is pretty much the same as last time; the only difference being, we
    have used the template fairing, which is like a middleware in Rocket. To use this,
    we needed to call `attach(Template::fairing())` on the rocket instance. Another
    difference is the use of managed state, which we use to manage our counter automatically.
    This is achieved by calling `manage` on the instance and passing an initial state
    for the managed object. Our counter is a struct, having only one element that
    holds the current count. Now our counter will be shared between multiple threads,
    all running rocket instances. To make the counter thread safe, we have used the
    primitive `AtomicUsize`, which guarantees thread safety. In our route, we match
    on the `GET` verb and we take in a name as a URL parameter. To render our template,
    we will need to build a context and populate it. Whenever an incoming request
    matches this route, we can insert the name in our context. We then call `fetch_add`
    on the underlying counter. This method increments the counter and returns the
    previous value, which we store in the context against a key called `visitor_number`.
    Once done, we can render our template, which is returned to the client. Note the
    use of `Ordering::SeqCst` in `fetch_add`, which guarantees a sequentially consistent
    view of the counter across all competing threads. Also note that the names of
    the keys in the context have to match the temporary variables used in the template,
    otherwise rendering will fail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次的设置与上次基本相同；唯一的区别是，我们使用了模板 fairing，它在 Rocket 中类似于中间件。要使用它，我们需要在 rocket 实例上调用
    `attach(Template::fairing())`。另一个区别是使用了托管状态，我们用它来自动管理我们的计数器。这是通过在实例上调用 `manage`
    并传递托管对象的初始状态来实现的。我们的计数器是一个结构体，它只有一个元素，用于保存当前计数。现在我们的计数器将在多个线程之间共享，所有这些线程都在运行 rocket
    实例。为了使计数器线程安全，我们使用了原始的 `AtomicUsize`，它保证了线程安全。在我们的路由中，我们匹配 `GET` 动词，并接受一个作为 URL
    参数的名称。为了渲染我们的模板，我们需要构建一个上下文并填充它。每当传入的请求匹配此路由时，我们可以在我们的上下文中插入名称。然后我们调用底层数计器的 `fetch_add`。此方法增加计数器并返回之前的值，我们将它存储在上下文中，键名为
    `visitor_number`。完成后，我们可以渲染我们的模板，并将其返回给客户端。注意 `fetch_add` 中使用 `Ordering::SeqCst`，这保证了所有竞争线程对计数器的顺序一致性视图。还要注意，上下文中键的名称必须与模板中使用的临时变量匹配，否则渲染将失败。
- en: 'Running this is easy; we just need to use `cargo run`. This is what we see
    on the CLI:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序很简单；我们只需要使用 `cargo run`。这是我们在命令行界面看到的内容：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then use a web browser to access the page to see something like the
    following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用网络浏览器访问页面，看到以下类似截图的内容：
- en: '![](img/00015.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'Notice that the counter resets when the `Rocket` instance is restarted. A real-world
    application may decide to persist such a metric in a database so that it is not
    lost between restarts. This also works with `curl`, which just dumps the raw HTML
    in the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `Rocket` 实例重启时，计数器会重置。在实际应用中，可能会决定将此类指标持久化到数据库中，以便在重启之间不会丢失。这也适用于 `curl`，它只是将原始
    HTML 输出到控制台：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last experiment with this piece of code is performance analysis. As always,
    we will fire up apache bench and point it to the endpoint. This is what one run
    shows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码的最后实验是性能分析。和往常一样，我们将启动 apache bench 并指向端点。这是单次运行的结果：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Performance in this case is comparable to last time, as measured in requests
    per second. This one is slightly slower, as it has to increment the counter and
    render the template each time. This is also reflected in mean time per request,
    which increased by 2 ms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，性能与上次相当，以每秒请求数来衡量。这个稍微慢一些，因为它每次都必须增加计数器并渲染模板。这也反映在平均请求时间上，增加了 2 毫秒。
- en: Rocket has a ton of other features, from cookies to streaming data. It also
    supports SSL out of the box by reading a special config file that can be placed
    in the root directory of the application. However, those advanced features are
    outside the scope of this book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Rocket 有许多其他功能，从 cookies 到流式数据。它还支持通过读取放置在应用程序根目录中的特殊配置文件来开箱即用 SSL。然而，这些高级功能超出了本书的范围。
- en: Introducing reqwest
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 reqwest
- en: 'So far, we have only talked about writing servers and used `curl` to access
    those. Sometimes, programmatically accessing a server becomes a necessity. In
    this section, we will discuss the `reqwest` crate and look at how to use it; this
    borrows heavily from the requests library in Python. Thus, it is very easy to
    set up and use, starting first with the project setup:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了编写服务器并使用 `curl` 访问它们。有时，以编程方式访问服务器变得是必需的。在本节中，我们将讨论 `reqwest` crate
    并查看如何使用它；这大量借鉴了 Python 中的 requests 库。因此，它非常容易设置和使用，首先从项目设置开始：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next step for our demo is to include our dependencies. Our Cargo config
    should look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示的下一步是包含我们的依赖项。我们的 Cargo 配置应该看起来像这样：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we will use Serde to serialize and deserialize our data to JSON. Very
    conveniently, we will use the `Rocket` server we wrote in the last section. Our
    main file will look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 Serde 来将我们的数据序列化和反序列化为 JSON。非常方便的是，我们将使用上一节中编写的 `Rocket` 服务器。我们的主文件将看起来像这样：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start with a struct to represent our blog post, which is exactly the same
    as the one in the last section. In our `main` function, we create an instance
    of our client and, using the builder pattern, pass on our post as a JSON to it.
    Finally, we call `send` on it and print out the return status. Make sure to change
    the `url` to point to the location where `Rocket` is running. We then issue a
    `GET` request on the same endpoint. We deserialize the response to a list of `Post`
    objects and print those out in a loop. Internally, reqwest uses SerDe to serialize
    and deserialize to/from JSON, making the API very user-friendly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个表示我们的博客文章的 struct 开始，这与上一节中的完全相同。在我们的 `main` 函数中，我们创建了一个客户端实例，并使用构建器模式将我们的文章作为
    JSON 传递给它。最后，我们在它上面调用 `send` 并打印出返回状态。确保将 `url` 改变为目标 `Rocket` 运行的位置。然后，我们在同一端点上发出一个
    `GET` 请求。我们将响应反序列化为 `Post` 对象的列表，并在循环中打印这些对象。内部，reqwest 使用 SerDe 将数据序列化和反序列化为
    JSON，使 API 非常用户友好。
- en: 'Here is an example session running the preceding code. In our server, we already
    had two existing entries and, in our code, we added one more. Then, we got back
    all three, which are printed here. Take a look at the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个运行前面代码的示例会话。在我们的服务器中，我们已经有了两个现有的条目，在我们的代码中，我们添加了一个。然后，我们得到了所有三个，它们在这里打印出来。请看以下代码片段：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Recently, `reqwest` added asynchronous programming support using tokio. All
    those APIs are located in `reqwest::unstable` and, as the name suggests, those
    are not stable yet. Let''s look at using the asynchronous client for the same
    purpose. In this case, we will use the futures and tokio crates, thus we will
    need to include those in our cargo manifest, which will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，`reqwest` 添加了对异步编程的支持，使用 tokio。所有这些 API 都位于 `reqwest::unstable` 中，正如其名所示，这些还不是稳定的。让我们看看如何使用异步客户端达到相同的目的。在这种情况下，我们将使用
    futures 和 tokio crate，因此我们需要在我们的 cargo manifest 中包含它们，它将看起来像这样：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will need to activate the feature called unstable in reqwest. Our main file
    will look like the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要激活 reqwest 中的名为 unstable 的功能。我们的主文件将看起来像以下代码片段：
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Admittedly, this is way more convoluted than the previous version! Some scaffolding
    for the `Post` struct is the same, and we pull in all the extra libraries we need.
    In our `main` function, we create a tokio core and then an asynchronous client
    based on that core. We chain the `json` and `send` methods like last time. Things
    diverge from there; for the asynchronous client, the `send` call returns a future.
    Once that future has resolved, the `and_then` call executes another future based
    on the first one. In here, we print out the status that we got back and resolve
    the future by returning an `Ok(())`. Finally, we run our future on the core.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这比上一个版本要复杂得多！`Post`结构的某些支架是相同的，我们引入了所有需要的额外库。在我们的`main`函数中，我们创建了一个tokio核心，然后基于该核心创建了一个异步客户端。我们像上次一样链式调用`json`和`send`方法。从这里开始，事情开始有所不同；对于异步客户端，`send`调用返回一个future。一旦该future解析完成，`and_then`调用就会基于第一个future执行另一个future。在这里，我们打印出我们得到的状态，并通过返回`Ok(())`来解析future。最后，我们在核心上运行我们的future。
- en: Getting data back from the endpoint is a bit more involved, because we have
    to deal with returned data as well. Here, we chain calls to `get` and `send`.
    We then chain another future that collects the response body. The second future
    is then chained to another one that consumes that body and copies it over to a
    `Vec<u8>` named `writer`. We then convert the vector to a `str` using `std::str::from_utf8`.
    The `str` is then passed to `serde_json::from_str`, which tries to deserialize
    it into a vector of `Post` objects that we can then print out by iterating over
    those. At the end, we resolve the chain of futures by returning an `Ok(())`. On
    running, this behaves exactly like the last one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从端点获取数据稍微复杂一些，因为我们还需要处理返回的数据。在这里，我们链式调用`get`和`send`。然后我们链式调用另一个future来收集响应体。第二个future随后被链式调用到另一个future上，该future消费该body并将其复制到名为`writer`的`Vec<u8>`中。然后我们使用`std::str::from_utf8`将向量转换为`str`。然后，我们将`str`传递给`serde_json::from_str`，它尝试将其反序列化为`Post`对象的向量，然后我们可以通过迭代这些对象来打印出来。最后，通过返回`Ok(())`来解析future链。运行时，这的行为与上一个例子完全相同。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a number of crates that help with dealing with HTTP-based
    REST endpoints in Rust, using Hyper and Rocket. We also looked at programmatically
    accessing these endpoints, using request, which is largely based on Hyper. These
    crates are at various stages of development. As we saw, Rocket can only run on
    nightly, because it uses a bunch of features that are not stable yet. We also
    glossed over tokio, which powers both Hyper and Rocket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些帮助我们在Rust中使用Hyper和Rocket处理基于HTTP的REST端点的crate。我们还探讨了如何使用请求程序化地访问这些端点，请求主要基于Hyper。这些crate处于不同的开发阶段。正如我们所见，Rocket只能运行在nightly版本上，因为它使用了一些尚未稳定的特性。我们还简要介绍了tokio，它是Hyper和Rocket的动力。
- en: Now, tokio, being the defacto asynchronous programming library in Rust, deserves
    all the attention it can get. So, we will discuss the tokio stack in detail in
    the next chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为Rust中事实上的异步编程库，tokio值得所有它能得到的关注。因此，我们将在下一章详细讨论tokio堆栈。
