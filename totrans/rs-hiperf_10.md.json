["```rs\nuse std::cell::Cell;\n\nfn main() {\n    let my_cell = Cell::new(0);\n    println!(\"Initial cell value: {}\", my_cell.get());\n\n    my_cell.set(my_cell.get() + 1);\n    println!(\"Final cell value: {}\", my_cell.get());\n}\n```", "```rs\nuse std::cell::RefCell;\nuse std::collections::HashMap;\n\nfn main() {\n    let hm = HashMap::new();\n    let my_cell = RefCell::new(hm);\n    println!(\"Initial cell value: {:?}\", my_cell.borrow());\n\n    my_cell.borrow_mut().insert(\"test_key\", \"test_value\");\n    println!(\"Final cell value: {:?}\", my_cell.borrow());\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n    println!(\"Before the thread!\");\n\n    let handle = thread::spawn(|| {\n        println!(\"Inside the thread!\");\n    });\n    println!(\"After thread spawn!\");\n\n    handle.join().expect(\"the thread panicked\");\n    println!(\"After everything!\");\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n    println!(\"Before the thread!\");\n\n    let handle = thread::Builder::new()\n        .name(\"bad thread\".to_owned())\n        .spawn(|| {\n            panic!(\"Panicking inside the thread!\");\n        })\n        .expect(\"could not create the thread\");\n    println!(\"After thread spawn!\");\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n    println!(\"After everything!\");\n}\n```", "```rs\nuse std::thread;\n\nstruct MyStruct {\n    name: String,\n}\n\nimpl Drop for MyStruct {\n    fn drop(&mut self) {\n        if thread::panicking() {\n            println!(\"The thread is panicking with the {} struct!\", self.name);\n        } else {\n            println!(\"The {} struct is out of scope :(\", self.name);\n        }\n    }\n}\n\nfn main() {\n    let my_struct = MyStruct {\n        name: \"whole program\".to_owned(),\n    };\n\n    {\n        let scoped_struct = MyStruct {\n            name: \"scoped\".to_owned(),\n        };\n    }\n\n    let handle = thread::Builder::new()\n        .name(\"bad thread\".to_owned())\n        .spawn(|| {\n            let thread_struct = MyStruct {\n                name: \"thread\".to_owned(),\n            };\n            panic!(\"Panicking inside the thread!\");\n        })\n        .expect(\"could not create the thread\");\n    println!(\"After thread spawn!\");\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n    println!(\"After everything!\");\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n    let my_vec = vec![10, 33, 54];\n\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(|| {\n            println!(\"This is my vector: {:?}\", my_vec);\n        })\n        .expect(\"could not create the thread\");\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n}\n```", "```rs\nuse std::thread;\n\nfn main() {\n    let my_vec = vec![10, 33, 54];\n\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            println!(\"This is my vector: {:?}\", my_vec);\n        })\n        .expect(\"could not create the thread\");\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n}\n```", "```rs\nuse std::thread;\nuse std::sync::Arc;\n\nfn main() {\n    let my_vec = vec![10, 33, 54];\n    let pointer = Arc::new(my_vec);\n\n    let t_pointer = pointer.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            println!(\"Vector in second thread: {:?}\", t_pointer);\n        })\n        .expect(\"could not create the thread\");\n\n    println!(\"Vector in main thread: {:?}\", pointer);\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n}\n```", "```rs\nuse std::thread;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nfn main() {\n    let my_val = AtomicUsize::new(0);\n    let pointer = Arc::new(my_val);\n\n    let t_pointer = pointer.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            for _ in 0..250_000 {\n                let cur_value = t_pointer.load(Ordering::Relaxed);\n                let sum = cur_value + 1;\n                t_pointer.store(sum, Ordering::Relaxed);\n            }\n        })\n        .expect(\"could not create the thread\");\n\n    for _ in 0..250_000 {\n        let cur_value = pointer.load(Ordering::Relaxed);\n        let sum = cur_value + 1;\n        pointer.store(sum, Ordering::Relaxed);\n    }\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n\n    let a_int = Arc::try_unwrap(pointer).unwrap();\n    println!(\"Final number: {}\", a_int.into_inner());\n}\n```", "```rs\nuse std::thread;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nfn main() {\n    let my_val = AtomicUsize::new(0);\n    let pointer = Arc::new(my_val);\n\n    let t_pointer = pointer.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            for _ in 0..250_000 {\n                t_pointer.fetch_add(1, Ordering::Relaxed);\n            }\n        })\n        .expect(\"could not create the thread\");\n\n    for _ in 0..250_000 {\n        pointer.fetch_add(1, Ordering::Relaxed);\n    }\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n\n    let a_int = Arc::try_unwrap(pointer).unwrap();\n    println!(\"Final number: {}\", a_int.into_inner());\n}\n```", "```rs\nuse std::thread;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n\nfn main() {\n    let my_val = AtomicUsize::new(0);\n    let pointer = Arc::new(my_val);\n    let lock = Arc::new(AtomicBool::new(false));\n\n    let t_pointer = pointer.clone();\n    let t_lock = lock.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            for _ in 0..250_000 {\n                while t_lock.compare_and_swap(\n                        false, true, Ordering::Relaxed) {}\n                let cur_value = t_pointer.load(Ordering::Relaxed);\n                let sum = cur_value + 1;\n                t_pointer.store(sum, Ordering::Relaxed);\n                t_lock.store(false, Ordering::Relaxed);\n            }\n        })\n        .expect(\"could not create the thread\");\n\n    for _ in 0..250_000 {\n        while lock.compare_and_swap(\n            false, true, Ordering::Relaxed) {}\n        let cur_value = pointer.load(Ordering::Relaxed);\n        let sum = cur_value + 1;\n        pointer.store(sum, Ordering::Relaxed);\n        lock.store(false, Ordering::Relaxed);\n    }\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n\n    let a_int = Arc::try_unwrap(pointer).unwrap();\n    println!(\"Final number: {}\", a_int.into_inner());\n}\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc, Mutex};\n\nfn main() {\n    let my_vec = Arc::new(Mutex::new(Vec::new()));\n\n    let t_vec = my_vec.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            for i in 0..50 {\n                t_vec.lock().unwrap().push(i);\n            }\n        })\n        .expect(\"could not create the thread\");\n\n    for i in 0..50 {\n        my_vec.lock().unwrap().push(i);\n    }\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n\n    let vec_mutex = Arc::try_unwrap(my_vec).unwrap();\n    let f_vec = vec_mutex.into_inner().unwrap();\n    println!(\"Final vector: {:?}\", f_vec);\n}\n```", "```rs\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nuse std::time::Duration;\n\nfn main() {\n    let my_vec = Arc::new(Mutex::new(Vec::new()));\n\n    let t_vec = my_vec.clone();\n    let handle = thread::Builder::new()\n        .name(\"my thread\".to_owned())\n        .spawn(move || {\n            for i in 0..10 {\n                let mut vec = t_vec.lock().unwrap();\n                vec.push(i);\n                panic!(\"Panicking the secondary thread\");\n            }\n        })\n        .expect(\"could not create the thread\");\n\n    thread::sleep(Duration::from_secs(1));\n\n    for i in 0..10 {\n        let mut vec = match my_vec.lock() {\n            Ok(g) => g,\n            Err(e) => {\n                println!(\"The secondary thread panicked, recovering…\");\n                e.into_inner()\n            }\n        };\n        vec.push(i);\n    }\n\n    if handle.join().is_err() {\n        println!(\"Something bad happened :(\");\n    }\n\n    let vec_mutex = Arc::try_unwrap(my_vec).unwrap();\n    let f_vec = match vec_mutex.into_inner() {\n        Ok(g) => g,\n        Err(e) => {\n            println!(\"The secondary thread panicked, recovering…\");\n            e.into_inner()\n        }\n    };\n    println!(\"Final vector: {:?}\", f_vec);\n}\n```", "```rs\nuse std::thread;\nuse std::sync::mpsc::*;\nuse std::time::Duration;\n\nfn main() {\n    let (sender, receiver) = channel();\n\n    let handles: Vec<_> = (1..6)\n        .map(|i| {\n            let t_sender = sender.clone();\n            thread::Builder::new()\n                .name(format!(\"sender-{}\", i))\n                .spawn(move || {\n                    t_sender.send(\n                        format!(\"Hello from sender {}!\", i)\n                    ).unwrap();\n                })\n                .expect(\"could not create the thread\")\n        })\n        .collect();\n\n    while let Ok(message) = receiver.recv_timeout(Duration::from_secs(1)) {\n        println!(\"{}\", message);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Finished\");\n}\n```", "```rs\nextern crate crossbeam;\n\nuse std::thread;\nuse std::sync::Arc;\n\nuse crossbeam::sync::MsQueue;\n\nfn main() {\n    let queue = Arc::new(MsQueue::new());\n\n    let handles: Vec<_> = (1..6)\n        .map(|_| {\n            let t_queue = queue.clone();\n            thread::spawn(move || {\n                for _ in 0..1_000_000 {\n                    t_queue.push(10);\n                }\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    let final_queue = Arc::try_unwrap(queue).unwrap();\n    let mut sum = 0;\n    while let Some(i) = final_queue.try_pop() {\n        sum += i;\n    }\n\n    println!(\"Final sum: {}\", sum);\n}\n```", "```rs\nextern crate crossbeam;\n\nuse std::thread;\nuse std::sync::Arc;\nuse std::time::Duration;\n\nuse crossbeam::sync::{MsQueue, TreiberStack};\n\nfn main() {\n    let queue = Arc::new(MsQueue::new());\n    let stack = Arc::new(TreiberStack::new());\n\n    let in_queue = queue.clone();\n    let in_stack = stack.clone();\n    let in_handle = thread::spawn(move || {\n        for i in 0..5 {\n            in_queue.push(i);\n            in_stack.push(i);\n            println!(\"Pushed :D\");\n            thread::sleep(Duration::from_millis(50));\n        }\n    });\n\n    let mut final_queue = Vec::new();\n    let mut final_stack = Vec::new();\n\n    let mut last_q_failed = 0;\n    let mut last_s_failed = 0;\n\n    loop {\n        // Get the queue\n        match queue.try_pop() {\n            Some(i) => {\n                final_queue.push(i);\n                last_q_failed = 0;\n                println!(\"Something in the queue! :)\");\n            }\n            None => {\n                println!(\"Nothing in the queue :(\");\n                last_q_failed += 1;\n            }\n        }\n\n        // Get the stack\n        match stack.try_pop() {\n            Some(i) => {\n                final_stack.push(i);\n                last_s_failed = 0;\n                println!(\"Something in the stack! :)\");\n            }\n            None => {\n                println!(\"Nothing in the stack :(\");\n                last_s_failed += 1;\n            }\n        }\n\n        // Check if we finished\n        if last_q_failed > 1 && last_s_failed > 1 {\n            break;\n        } else if last_q_failed > 0 || last_s_failed > 0 {\n            thread::sleep(Duration::from_millis(100));\n        }\n    }\n\n    in_handle.join().unwrap();\n\n    println!(\"Queue: {:?}\", final_queue);\n    println!(\"Stack: {:?}\", final_stack);\n}\n```", "```rs\nextern crate crossbeam;\n\nfn main() {\n    let all_nums: Vec<_> = (0..1_000_u64).into_iter().collect();\n    let mut results = Vec::new();\n\n    crossbeam::scope(|scope| {\n        for num in &all_nums {\n            results.push(scope.spawn(move || num * num + num * 5 + 250));\n        }\n    });\n\n    let final_result: u64 = results.into_iter().map(|res| res.join()).sum();\n    println!(\"Final result: {}\", final_result);\n}\n```", "```rs\nextern crate crossbeam;\n\nfn main() {\n    let all_nums: Vec<_> = (0..10).into_iter().collect();\n\n    crossbeam::scope(|scope| {\n        for num in all_nums {\n            scope.spawn(move || {\n                println!(\"Next number is {}\", num);\n            });\n        }\n    });\n\n    println!(\"Main thread continues :)\");\n}\n\n```", "```rs\nextern crate num_cpus;\nextern crate threadpool;\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\n\nuse threadpool::ThreadPool;\n\nfn main() {\n    let pool = ThreadPool::with_name(\"my worker\".to_owned(), num_cpus::get());\n    println!(\"Pool threads: {}\", pool.max_count());\n\n    let result = Arc::new(AtomicUsize::new(0));\n\n    for i in 0..1_0000_000 {\n        let t_result = result.clone();\n        pool.execute(move || {\n            t_result.fetch_add(i, Ordering::Relaxed);\n        });\n    }\n\n    pool.join();\n\n    let final_res = Arc::try_unwrap(result).unwrap().into_inner();\n    println!(\"Final result: {}\", final_res);\n}\n```", "```rs\nextern crate rayon;\n\nuse rayon::prelude::*;\n\nfn main() {\n    let result = (0..1_000_000_u64)\n        .into_par_iter()\n        .map(|e| e * 2)\n        .sum::<u64>();\n\n    println!(\"Result: {}\", result);\n}\n```"]