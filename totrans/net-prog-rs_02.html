<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to Rust and its Ecosystem</h1>
                
            
            <article>
                
<p class="calibre2">The Rust programming language is sponsored by Mozilla and supported by a community of developers from across the globe. Rust is promoted as a systems programming language that supports automatic memory management without the overhead of a runtime or a garbage collector, concurrency without data races enforced by the compiler, and zero cost abstractions and generics. In subsequent sections, we will discuss these features in more detail. Rust is statically typed and borrows a number of functional programming ideas. A fascinating aspect of Rust is the use of the type system to guarantee memory safety without using a runtime. This makes Rust uniquely suitable for low-resource embedded devices and real-time systems, which require strong guarantees around code correctness. On the flip side, this often means that the compiler has to do a lot more work to ensure syntactical correctness and then translate source code, resulting in higher build times. While the community is working on methods to reduce compile time as much as possible, this is still an important issue encountered by a lot of developers.</p>
<p class="calibre2">The <strong class="calibre1">Low Level Virtual Machine</strong> (<strong class="calibre1">LLVM</strong>) project started as a university research project aimed at developing a set of tools for building compilers that can generate machine code for a range of CPU architectures. This was achieved using the <strong class="calibre1">LLVM intermediate representation</strong> (<strong class="calibre1">LLVM IR</strong>). The toolchain can compile any higher-level language to LLVM IR, which can then be targeted for a given CPU. The Rust compiler depends heavily on the LLVM project for interoperability, using it as a backend. It actually translates Rust code into LLVM's intermediate representation and optimizes it as necessary. LLVM then translates that into machine code for the specific platform, which gets run on the CPU.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre7">
<li class="calibre8"><span>An introduction to the ecosystem and how Rust works</span></li>
<li class="calibre8"><span>Installing Rust and setting up the toolchain</span></li>
<li class="calibre8"><span>An introduction to its major features, starting from the borrow checker and how ownership works</span></li>
<li class="calibre8"><span>Generics and how the trait system works with the ownership model</span></li>
<li class="calibre8"><span>Error handling and the macro system</span></li>
<li class="calibre8"><span>Concurrency primitives</span></li>
<li class="calibre8">Testing primitives</li>
</ul>
<p class="calibre2"><span>Note that this chapter is a very high-level overview of the language and some of its most distinctive features, not a deep dive.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Rust ecosystem</h1>
                
            
            <article>
                
<p class="calibre2">The success or failure of an open source project is often determined by the strength of the community around it. Having a coherent ecosystem helps in building a strong community. Since Rust is primarily driven by Mozilla, they have been able to build a strong ecosystem around it, the primary components being:</p>
<ul class="calibre7">
<li class="calibre8">Source code: Rust hosts all the source code in GitHub. Developers are encouraged to report bugs and submit pull requests in there. At the time of writing, the Rust repository on GitHub has 1,868 unique contributors, over 2,700 open bug reports, and 90 open pull requests. The core Rust team is composed of Mozilla employees and contributors from other organizations (like Google, Baidu, and so on). The team uses GitHub for all collaborations; even major changes to any component have to be first proposed by writing a <strong class="calibre1">Request For Comments</strong> (<strong class="calibre1">RFC</strong>). This way, everyone has a chance to take a look at it and collaborate on improving it. Once it is approved, the actual change can be implemented.</li>
<li class="calibre8">Compiler: The Rust compiler is named <em class="calibre16">rustc.</em> Since Rust follows semantic versioning for compiler releases, there cannot be any backward incompatible breaking changes between minor releases. At the time of writing this book, the compiler has already reached version 1.0, thus it can be assumed that there will not be any breaking changes till version 2.0. Note that breaking changes do slip once in a while. But in all those cases, they are treated as bugs and fixed as soon as possible.</li>
</ul>
<p class="calibre2"><br class="title-page-name"/>
To facilitate adding new compiler features without breaking existing dependent libraries, Rust releases new compiler versions in stages. At any point, three different versions of the compiler (and the standard library) are maintained.</p>
<ul class="calibre7">
<li class="calibre8">The first one is called <strong class="calibre1">nightly</strong>. As the name implies, it is built each night from the tip of the source tree. Since this is only tested by unit and integration tests, this release often has more bugs in the real world.</li>
<li class="calibre8">The second stage is <strong class="calibre1">beta</strong>, which is a planned release. By the time a nightly has reached this stage, it has gone through multiple rounds of unit, integration, and regression testing. Additionally, the community has had the time to use it in real projects and share feedback with the Rust team.</li>
<li class="calibre8">Once everyone is confident about the release, it is tagged as a <strong class="calibre1">stable</strong> release and pushed out. Since the compiler supports a variety of platforms (from Windows to Redox) and architectures (amd64), each release has pre-built binaries for all combinations of platforms and architectures.</li>
</ul>
<ul class="calibre7">
<li class="calibre8">Installation mechanism: The community supported installation mechanism is via a tool called <em class="calibre16">rustup. </em>This tool can install a given version of Rust along with everything needed to use it (including the compiler, standard library, package manager, and so on).</li>
<li class="calibre8">Package manager: Rust's package manager is called <em class="calibre16">Cargo, </em>while individual packages are called <em class="calibre16">crates</em>. All external libraries and applications can be packaged in a crate and published using the Cargo CLI tool. A user can then use it to search for and install packages. All crates can be searched using the following website: <a href="https://crates.io/" class="calibre10">https://crates.io/</a>. For all packages hosted on <em class="calibre16">crates.io</em>, the corresponding documentation is available at: <a href="https://docs.rs/" class="calibre10">https://docs.rs/</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with Rust</h1>
                
            
            <article>
                
<p class="calibre2">The Rust toolchain installer is available at: <a href="https://www.rustup.rs/" class="calibre10">https://www.rustup.rs/</a>. The following commands will install all three versions of the toolchain on a system. For the examples in this book, we will use a Linux machine running Ubuntu 16.04. While most of Rust should not depend on the OS, there can be minor differences.</p>
<p class="calibre2">We will point out any strict dependencies on the OS:</p>
<pre class="calibre17"><strong class="calibre1"># curl https://sh.rustup.rs -sSf | sh</strong><br class="title-page-name"/><strong class="calibre1"># source $HOME/.cargo/env</strong><br class="title-page-name"/><strong class="calibre1"># rustup install nightly beta</strong></pre>
<p class="calibre2">We will need to put Cargo's bin directory to our <strong class="calibre1">PATH</strong> by editing <strong class="calibre1">.bashrc</strong>. Run the following to do that:</p>
<pre class="calibre17"><strong class="calibre1">$ echo "export PATH=$HOME/.cargo/bin:$PATH" &gt;&gt; ~/.bashrc</strong></pre>
<p class="calibre2">A Rust installation comes with a lot of documentation built in; they can be accessed by running the following command. This should open up the documentation in a browser window:</p>
<pre class="calibre17"><strong class="calibre1"># rustup doc</strong></pre>
<p class="calibre2">The next step is to set up a Rust project and run it, all using Cargo:</p>
<pre class="calibre17"><strong class="calibre1"># cargo new --bin hello-rust</strong></pre>
<p class="calibre2">This tells Cargo to set up a new project called <kbd class="calibre11">hello-rust</kbd> in the current directory. Cargo will create a directory of that name and set up the basic structure. Since the type of this project is set to be a binary, Cargo will generate a file called <kbd class="calibre11">main.rs</kbd> which will have an empty <kbd class="calibre11">main</kbd> function, the entry point for the application. The other (default) option here is that of a library, in this case, a file named <kbd class="calibre11">lib.rs</kbd> will be generated. <span>The file named <kbd class="calibre11">Cargo.</kbd></span><kbd class="calibre11">toml</kbd><span> has a bunch of metadata for the current project and is used by Cargo. All source code is located in the <kbd class="calibre11">src</kbd> directory:</span></p>
<pre class="calibre17"><strong class="calibre1"># tree hello-rust/</strong><br class="title-page-name"/>hello-rust/<br class="title-page-name"/>├── Cargo.toml<br class="title-page-name"/>└── src<br class="title-page-name"/>    └── main.rs<br class="title-page-name"/><br class="title-page-name"/>1 directory, 2 files</pre>
<p class="calibre2">The project can then be built and run using the following command. Note that this command should be run from the <kbd class="calibre11">hello-rust</kbd> directory that Cargo created previously:</p>
<pre class="calibre17"><strong class="calibre1"># cargo run</strong></pre>
<p class="calibre2">Interestingly, this command modifies the directory quite a bit. The <kbd class="calibre11">target</kbd> directory contains compilation artifacts. The structure of this is heavily platform dependent, but always includes everything necessary to run the application in the given build mode. The default build mode is <kbd class="calibre11">debug</kbd>, which includes debugging information and symbols to be used with a debugger:</p>
<pre class="calibre17"><strong class="calibre1"># tree hello-rust/</strong><br class="title-page-name"/>hello-rust/<br class="title-page-name"/>├── Cargo.lock<br class="title-page-name"/>├── Cargo.toml<br class="title-page-name"/>├── src<br class="title-page-name"/>│   └── main.rs<br class="title-page-name"/>└── target<br class="title-page-name"/>    └── debug<br class="title-page-name"/>        ├── build<br class="title-page-name"/>        ├── deps<br class="title-page-name"/>        │   └── hello_rust-392ba379262c5523<br class="title-page-name"/>        ├── examples<br class="title-page-name"/>        ├── hello-rust<br class="title-page-name"/>        ├── hello-rust.d<br class="title-page-name"/>        ├── incremental<br class="title-page-name"/>        └── native<br class="title-page-name"/><br class="title-page-name"/>8 directories, 6 files</pre>
<p class="calibre2">A packaged Rust application is called a crate. Rust crates are published to <em class="calibre16">crates.io</em>. Once published, anyone can use the web interface or the cargo CLI to search for crates, as shown in the following code snippet. This operation needs a working internet connection so that cargo can communicate with <em class="calibre16">crates.io</em>:</p>
<pre class="calibre17"><strong class="calibre1"># cargo search term</strong><br class="title-page-name"/>    Updating registry `https://github.com/rust-lang/crates.io-index`<br class="title-page-name"/>term = "0.4.6" # A terminal formatting library<br class="title-page-name"/>ansi_term = "0.9.0" # Library for ANSI terminal colours and styles (bold, underline)<br class="title-page-name"/>term-painter = "0.2.4" # Coloring and formatting terminal output<br class="title-page-name"/>term_size = "0.3.0" # functions for determining terminal sizes and dimensions<br class="title-page-name"/>rust_erl_ext = "0.2.1" # Erlang external term format codec.<br class="title-page-name"/>slog-term = "2.2.0" # Unix terminal drain and formatter for slog-rs<br class="title-page-name"/>colored = "1.5.2" # The most simple way to add colors in your terminal<br class="title-page-name"/>term_grid = "0.1.6" # Library for formatting strings into a grid layout<br class="title-page-name"/>rust-tfidf = "1.0.4" # Library to calculate TF-IDF (Term Frequency - Inverse Document Frequency) for generic documents<br class="title-page-name"/>aterm = "0.20.0" # Implementation of the Annotated Terms data structure<br class="title-page-name"/>... and 1147 crates more (use --limit N to see more)</pre>
<p class="calibre2">Now, say we want to use the <kbd class="calibre11">term</kbd> crate in our application; we will need to edit the <kbd class="calibre11">Cargo.toml</kbd> file and include it in the <kbd class="calibre11">[dependencies]</kbd> section, as shown in the following code snippet. This particular crate helps in formatting terminal colors. Using this crate, we would like to print the words <kbd class="calibre11">hello</kbd> and <kbd class="calibre11">world</kbd> in green and red, respectively:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "hello-rust"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo Bar &lt;foo.bar@foobar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>term = "0.4.6"</pre>
<p class="calibre2">To actually use the crate in our application, we need to modify the <kbd class="calibre11">main.rs</kbd> file, as shown in the following code snippet. We will discuss the language in detail in subsequent sections, but here is a small overview. The following sample is a simple program that prints the string <kbd class="calibre11">hello world!</kbd> on the screen. Further, it prints <kbd class="calibre11">hello</kbd> in green and <kbd class="calibre11">world!</kbd> in red:</p>
<pre class="calibre17">// chapter2/hello-rust/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate term;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut t = term::stdout().unwrap();<br class="title-page-name"/>    t.fg(term::color::GREEN).unwrap();<br class="title-page-name"/>    write!(t, "hello, ").unwrap();<br class="title-page-name"/><br class="title-page-name"/>    t.fg(term::color::RED).unwrap();<br class="title-page-name"/>    writeln!(t, "world!").unwrap();<br class="title-page-name"/><br class="title-page-name"/>    t.reset().unwrap();<br class="title-page-name"/>}</pre>
<p class="calibre2">In Rust, each application must have a single entry point called <kbd class="calibre11">main</kbd>, which should be defined as a function that does not take in parameters. Functions are defined using the <kbd class="calibre11">fn</kbd> keyword. The phrase <kbd class="calibre11">extern crate term</kbd> tells the toolchain that we want to use an external crate as a dependency of our current application.</p>
<p class="calibre2">Now, we can run it using Cargo. It automatically downloads and builds the library we need and all of its dependencies. Finally, it calls the Rust compiler so that our application is linked with the library and runs the executable. Cargo also generates a file called <kbd class="calibre11">Cargo.lock</kbd> that has a snapshot of everything needed to run the application in a consistent manner. This file should never be edited manually. Since cargo caches all dependencies locally, subsequent invocations do not need internet access:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Updating registry `https://github.com/rust-lang/crates.io-index`<br class="title-page-name"/>   Compiling term v0.4.6<br class="title-page-name"/>   Compiling hello-rust v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter2/hello-rust)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 3.20 secs<br class="title-page-name"/>     Running `target/debug/hello-rust`<br class="title-page-name"/>hello, world!</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to the borrow checker</h1>
                
            
            <article>
                
<p class="calibre2">The most important aspect of Rust is the ownership and borrowing model. Based on the strict enforcing of borrowing rules, the compiler can guarantee memory safety without an external garbage collector. This is done by the borrow checker, a subsystem of the compiler. By definition, every resource created has a lifetime and an owner associated with it, which operates under the following rules:</p>
<ul class="calibre7">
<li class="calibre8">Each resource has exactly one owner at any point in time. By default, the owner is the variable that created that resource, and its lifetime is the lifetime of the enclosing scope. Others can borrow or copy the resource if they need to. Note that a resource can be anything from a variable or a function. A function takes ownership of a resource from its caller; returning from the function transfers back ownership.</li>
<li class="calibre8">When the owner's scope has finished executing, all resources owned by it will be dropped. This is statically computed by the compiler, which then produces machine code accordingly.</li>
</ul>
<p class="calibre2">Some examples of these rules are shown in the following code snippet:</p>
<pre class="calibre17">// chapter2/ownership-heap.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let s = String::from("Test");<br class="title-page-name"/>    heap_example(s);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn heap_example(input: String) {<br class="title-page-name"/>    let mystr = input;<br class="title-page-name"/>    let _otherstr = mystr;<br class="title-page-name"/>    println!("{}", mystr);<br class="title-page-name"/>}</pre>
<p class="calibre2">In Rust, variables are declared using the <kbd class="calibre11">let</kbd> keyword. All variables are immutable by default and can be made mutable by using the <kbd class="calibre11">mut</kbd> keyword. The <kbd class="calibre11">::</kbd> syntax refers to an object in the given namespace, in this case, the <kbd class="calibre11">from</kbd> function. <kbd class="calibre11">println!</kbd> is a built-in macro that the compiler provides; it is used to write to the standard output with a trailing newline. Functions are defined using the <kbd class="calibre11">fn</kbd> keyword. When we try to build it, we get the following error:</p>
<pre class="calibre17"><strong class="calibre1"># rustc ownership-heap.rs</strong><br class="title-page-name"/>error[E0382]: use of moved value: `mystr`<br class="title-page-name"/> --&gt; ownership-heap.rs:9:20<br class="title-page-name"/>  |<br class="title-page-name"/>8 | let _otherstr = mystr;<br class="title-page-name"/>  | --------- value moved here<br class="title-page-name"/>9 | println!("{}", mystr);<br class="title-page-name"/>  | ^^^^^ value used here after move<br class="title-page-name"/>  |<br class="title-page-name"/>  = note: move occurs because `mystr` has type `std::string::String`, which does not implement the `Copy` trait<br class="title-page-name"/><br class="title-page-name"/>error: aborting due to previous error</pre>
<p class="calibre2">In this example, a string resource is created which is owned by the variable <kbd class="calibre11">mystr</kbd>, in the function <kbd class="calibre11">heap_example</kbd>. Thus, its lifetime is the same as its scope. Under the hood, since the compiler does not know the length of the string at compile time, it must place it on the heap. The owner variable is created on the stack and points to the resource on the heap. When we assign that resource to a new variable, the resource is now owned by the new variable. Rust will mark <kbd class="calibre11">mystr</kbd> as invalid at this point to prevent situations where the memory associated with the resource might be freed multiple times. Thus, compilation fails here to guarantee memory safety. We can force the compiler to copy the resource and have the second owner point to the newly created resource. For that, we will need to <kbd class="calibre11">.clone()</kbd> the resource named <kbd class="calibre11">mystr</kbd>. Here is how it looks:</p>
<pre class="calibre17">// chapter2/ownership-heap-fixed.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let s = String::from("Test");<br class="title-page-name"/>    heap_example(s);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn heap_example(input: String) {<br class="title-page-name"/>    let mystr = input;<br class="title-page-name"/>    let _otherstr = mystr.clone();<br class="title-page-name"/>    println!("{}", mystr);<br class="title-page-name"/>}</pre>
<p class="calibre2">As expected, this does not throw any errors on compilation and prints the given string <kbd class="calibre11">"Test"</kbd> on running. Notice that till now, we have been using Cargo for running our code. Since in this case, we just have a simple file and no external dependency, we will use the Rust compiler directly to compile our code, and we will run it manually:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc ownership-heap-fixed.rs &amp;&amp; ./ownership-heap-fixed</strong><br class="title-page-name"/>Test</pre>
<p class="calibre2">Consider the code sample below which shows the case when resources are stored on the stack:</p>
<pre class="calibre17">// chapter2/ownership-stack.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let i = 42;<br class="title-page-name"/>    stack_example(i);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn stack_example(input: i32) {<br class="title-page-name"/>    let x = input;<br class="title-page-name"/>    let _y = x;<br class="title-page-name"/>    println!("{}", x);<br class="title-page-name"/>}</pre>
<p class="calibre2">Interestingly, though it looks exactly the same as the code block before, this does not throw a compilation error. We build and run this using the Rust compiler directly from the command line:</p>
<pre class="calibre17"><strong class="calibre1"># rustc ownership-stack.rs &amp;&amp; ./ownership-stack</strong><br class="title-page-name"/>42</pre>
<p class="calibre2">The difference is in the types of the variables. Here, the original owner and the resource are both created on the stack. When the resource is reassigned, it is copied over to the new owner. This is possible only because the compiler knows that the size of an integer is always fixed (and hence can be placed on the stack). Rust provides a special way to say that a type can be placed on the stack via the <kbd class="calibre11">Copy</kbd> trait. Our example works only because built-in integers (and some other types) are marked with this trait. We will explain the trait system in more detail in subsequent sections.</p>
<p class="calibre2">One might have noticed that copying a resource of unknown length to a function might lead to memory bloats. In a lot of languages, the caller will pass a pointer to a memory location, and then to the function. Rust does this by using references. These allow you to refer to a resource without actually owning it. When a function receives a reference to a resource, we say that it borrowed that resource. In the following example, the function <kbd class="calibre11">heap_example</kbd> borrows the resource owned by the variable <kbd class="calibre11">s</kbd>. Since borrowing is not absolute ownership, the scope of the borrowing variable does not affect how memory associated with the resource is freed. That also means there is no chance of freeing the borrowed resource multiple times in the function, since nobody in the function's scope actually owns that resource. Thus, the earlier code that failed works in this case:</p>
<pre class="calibre17">// chapter2/ownership-borrow.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let s = String::from("Test");<br class="title-page-name"/>    heap_example(&amp;s);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn heap_example(input: &amp;String) {<br class="title-page-name"/>    let mystr = input;<br class="title-page-name"/>    let _otherstr = mystr;<br class="title-page-name"/>    println!("{}", mystr);<br class="title-page-name"/>}</pre>
<p class="calibre2">The borrowing rules also imply that the borrow is immutable. However, there can be cases where one needs to mutate the borrow. To handle those cases, Rust allows mutable references (or borrowing). As one would expect, this takes us back to the problem we had in the first example, and compilation fails with the following code:</p>
<pre class="calibre17">// chapter2/ownership-mut-borrow.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut s = String::from("Test");<br class="title-page-name"/>    heap_example(&amp;mut s);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn heap_example(input: &amp;mut String) {<br class="title-page-name"/>    let mystr = input;<br class="title-page-name"/>    let _otherstr = mystr;<br class="title-page-name"/>    println!("{}", mystr);<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that a resource can be mutably borrowed only once in a scope. The compiler will refuse to compile code that tries to do otherwise. While this might look like an annoying error, you need to remember that in a working application, these functions will often be called from competing threads. If there is a synchronization error due to a programming fault, we will end up with a data race where multiple unsynchronized threads race to modify the same resource. This feature helps prevent such situations.</p>
<p class="calibre2">Another language feature that is closely related to references is that of a lifetime. A reference lives as long as it is in scope, thus its lifetime is that of the enclosing scope. All variables declared in Rust can have a lifetime explicit elision that puts a name to its lifetime. This is useful for the borrow checker to reason about the relative lifetimes of variables. In general, one does not need to put an explicit lifetime name to each and every variable since the compiler manages that. In certain scenarios, this is needed, especially when automatic lifetime determination cannot work. Let's look at an example where this happens:</p>
<pre class="calibre17">// chapter2/lifetime.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let v1 = vec![1, 2, 3, 4, 5];<br class="title-page-name"/>    let v2 = vec![1, 2];<br class="title-page-name"/><br class="title-page-name"/>    println!("{:?}", longer_vector(&amp;v1, &amp;v2));<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn longer_vector(x: &amp;[i32], y: &amp;[i32]) -&gt; &amp;[i32] {<br class="title-page-name"/>    if x.len() &gt; y.len() { x } else { y }<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre11">vec!</kbd> macro constructs a vector from the given list of objects. Note that unlike previous examples, our function here needs to return a value back to the caller. We need to specify the return type using the arrow syntax. Here, we are given two vectors, and we want to print the longest of the two. Our <kbd class="calibre11">longer_vector</kbd> function does just that. It takes in references to two vectors, computes their length, and returns a reference to the one with the larger length. This fails to compile with the following error:</p>
<pre class="calibre17"><strong class="calibre1"># rustc lifetime.rs</strong><br class="title-page-name"/>error[E0106]: missing lifetime specifier<br class="title-page-name"/> --&gt; lifetime.rs:8:43<br class="title-page-name"/>  |<br class="title-page-name"/>8 | fn longer_vector(x: &amp;[i32], y: &amp;[i32]) -&gt; &amp;[i32] {<br class="title-page-name"/>  | ^ expected lifetime parameter<br class="title-page-name"/>  |<br class="title-page-name"/>  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`<br class="title-page-name"/><br class="title-page-name"/>error: aborting due to previous error</pre>
<p class="calibre2">This tells us that the compiler could not determine if the returned reference should refer to the first parameter or the second, so it could not determine how long it should live. There is no way this can be determined at compile time since we have no control of the inputs. A key insight here is that we do not need to know the lifetimes of all the references at compile time. We need to make sure the following things hold true:</p>
<ul class="calibre7">
<li class="calibre8">The two inputs should have the same lifetimes since we want to compare their lengths in the function</li>
<li class="calibre8">The return value should have the same lifetime as that of the input, which is the longer of the two</li>
</ul>
<p class="calibre2">Given these two axioms, it follows that the two inputs and the return should have the same lifetime. We can annotate this, as shown in the following code snippet:</p>
<pre class="calibre17">fn longer_vector&lt;'a&gt;(x: &amp;'a[i32], y: &amp;'a[i32]) -&gt; &amp;'a[i32] {<br class="title-page-name"/>    if x.len() &gt; y.len() { x } else { y }<br class="title-page-name"/>}</pre>
<p class="calibre2">This works as expected since the compiler can happily guarantee code correctness. Lifetime parameters can also be attached to structs and method definitions. There is a special lifetime called <kbd class="calibre11">'static</kbd> that refers to the entire duration of the program.</p>
<div class="packt_infobox">Rust recently accepted a proposal to add a new designated lifetime called <kbd class="calibre31">'fn</kbd> that will be equal to the scope of the innermost function or closure.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generics and the trait system</h1>
                
            
            <article>
                
<p class="calibre2">Rust supports writing generic code that is later bound with more concrete types, either during compile time or during runtime. People who are familiar with templates in C++ might notice that generics in Rust are pretty similar to templates, as far as syntax goes. The following example illustrates how to use generic programming. We also introduce some new constructs which we haven't discussed before, which we will explain as we proceed.</p>
<p class="calibre2"><span>Much like C and C++, a Rust </span><kbd class="calibre11">struct</kbd><span> defines a user-defined type that aggregates multiple logically connected resources in one unit. Our struct here defines a tuple of two variables. We define a generic struct and we use a generic </span><em class="calibre16">type parameter</em><span>, written here as </span><kbd class="calibre11">&lt;T&gt;</kbd><span>. Each member of the struct is defined to be of that type. We later define a generic function that sums the two elements of the tuple. Let's look at a naive implementation of this:</span></p>
<pre class="calibre17">// chapter2/generic-function.rs<br class="title-page-name"/><br class="title-page-name"/>struct Tuple&lt;T&gt; {<br class="title-page-name"/>    first: T,<br class="title-page-name"/>    second: T,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let tuple_u32: Tuple&lt;u32&gt; = Tuple {first: 4u32, second: 2u32 };<br class="title-page-name"/>    let tuple_u64: Tuple&lt;u64&gt; = Tuple {first: 5u64, second: 6u64 };<br class="title-page-name"/>    println!("{}", sum(tuple_u32));<br class="title-page-name"/>    println!("{}", sum(tuple_u64));<br class="title-page-name"/><br class="title-page-name"/>    let tuple: Tuple&lt;String&gt; = Tuple {first: "One".to_owned(), second: "Two".to_owned() };<br class="title-page-name"/>    println!("{}", sum(tuple));<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn sum&lt;T&gt;(tuple: Tuple&lt;T&gt;) -&gt; T<br class="title-page-name"/>{<br class="title-page-name"/>    tuple.first + tuple.second<br class="title-page-name"/>}</pre>
<p class="calibre2">This fails to compile, and the compiler throws the following error:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc generic-function.rs</strong><br class="title-page-name"/>error[E0369]: binary operation `+` cannot be applied to type `T`<br class="title-page-name"/>  --&gt; generic-function-error.rs:18:5<br class="title-page-name"/>   |<br class="title-page-name"/>18 | tuple.first + tuple.second<br class="title-page-name"/>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^<br class="title-page-name"/>   |<br class="title-page-name"/>   = note: `T` might need a bound for `std::ops::Add`<br class="title-page-name"/><br class="title-page-name"/>error: aborting due to previous error</pre>
<p class="calibre2">This error is important. The compiler is telling us that it does not know how to add two operands of type <kbd class="calibre11">T</kbd>. It also (correctly) guessed that the <kbd class="calibre11">T</kbd> type needs to be bound by the <kbd class="calibre11">Add</kbd> trait. This means that the list of possible concrete types for <kbd class="calibre11">T</kbd> should only have types that implement the <kbd class="calibre11">Add</kbd> trait, which are types whose concrete references can be added. Let's go ahead and put the trait bound in the <kbd class="calibre11">sum</kbd> function. Our code should look like this now:</p>
<pre class="calibre17">// chapter2/generic-function-fixed.rs<br class="title-page-name"/><br class="title-page-name"/>use std::ops::Add;<br class="title-page-name"/><br class="title-page-name"/>struct Tuple&lt;T&gt; {<br class="title-page-name"/>    first: T,<br class="title-page-name"/>    second: T,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let tuple_u32: Tuple&lt;u32&gt; = Tuple {first: 4u32, second: 2u32 };<br class="title-page-name"/>    let tuple_u64: Tuple&lt;u64&gt; = Tuple {first: 5u64, second: 6u64 };<br class="title-page-name"/>    println!("{}", sum(tuple_u32));<br class="title-page-name"/>    println!("{}", sum(tuple_u64));<br class="title-page-name"/><br class="title-page-name"/>    // These lines fail to compile<br class="title-page-name"/>    let tuple: Tuple&lt;String&gt; = Tuple {first: "One".to_owned(), second: "Two".to_owned() };<br class="title-page-name"/>    println!("{}", sum(tuple));<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// We constrain the possible types of T to those which implement the Add trait<br class="title-page-name"/>fn sum&lt;T: Add&lt;Output = T&gt;&gt;(tuple: Tuple&lt;T&gt;) -&gt; T<br class="title-page-name"/>{<br class="title-page-name"/>    tuple.first + tuple.second<br class="title-page-name"/>}</pre>
<p class="calibre2">For this to work, the elements must be summable; there should be a logical meaning of summing them. So, we have constrained the possible types the <kbd class="calibre11">T</kbd> parameter can have to those which have the <kbd class="calibre11">Add</kbd> trait implemented. We also need to let the compiler know that the output for this function should be of the type <kbd class="calibre11">T</kbd>. Given this information, we can construct our tuples and call the sum function on them, and they will behave as expected. Also, note that a tuple of strings will fail to compile with the error, since the <kbd class="calibre11">Add</kbd> trait is not implemented for strings.</p>
<p class="calibre2">From the last example, one might notice that traits are essential to properly implement generics. They help the compiler reason about properties of generic types. In essence, a trait defines properties of a type. The library defines a bunch of commonly used traits and their implementations for built-in types. For any user-defined types, it's up to the user to define what properties those types should have by defining and implementing traits.</p>
<pre class="calibre17">// chapter2/traits.rs<br class="title-page-name"/><br class="title-page-name"/>trait Max&lt;T&gt; {<br class="title-page-name"/>    fn max(&amp;self) -&gt; T;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>struct ThreeTuple&lt;T&gt; {<br class="title-page-name"/>    first: T,<br class="title-page-name"/>    second: T,<br class="title-page-name"/>    third: T,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// PartialOrd enables comparing<br class="title-page-name"/>impl&lt;T: PartialOrd + Copy&gt; Max&lt;T&gt; for ThreeTuple&lt;T&gt; {<br class="title-page-name"/>    fn max(&amp;self) -&gt; T {<br class="title-page-name"/>        if self.first &gt;= self.second &amp;&amp; self.first &gt;= self.third {<br class="title-page-name"/>            self.first<br class="title-page-name"/>        }<br class="title-page-name"/>        else if self.second &gt;= self.first &amp;&amp; self.second &gt;= self.third {<br class="title-page-name"/>            self.second<br class="title-page-name"/>        }<br class="title-page-name"/>        else {<br class="title-page-name"/>            self.third<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>struct TwoTuple&lt;T&gt; {<br class="title-page-name"/>    first: T,<br class="title-page-name"/>    second: T,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T: PartialOrd + Copy&gt; Max&lt;T&gt; for TwoTuple&lt;T&gt; {<br class="title-page-name"/>    fn max(&amp;self) -&gt; T {<br class="title-page-name"/>        if self.first &gt;= self.second {<br class="title-page-name"/>            self.first<br class="title-page-name"/>        } else { self.second }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let two_tuple: TwoTuple&lt;u32&gt; = TwoTuple {first: 4u32, second: 2u32 };<br class="title-page-name"/>    let three_tuple: ThreeTuple&lt;u64&gt; = ThreeTuple {first: 6u64,<br class="title-page-name"/>                                       second: 5u64, third: 10u64 };<br class="title-page-name"/><br class="title-page-name"/>    println!("{}", two_tuple.max());<br class="title-page-name"/>    println!("{}", three_tuple.max());<br class="title-page-name"/>}</pre>
<p class="calibre2">We start by defining a generic trait of type <kbd class="calibre11">T</kbd>. Our trait has a single function that will return the maximum of the given type that implements it. What counts as the maximum is an implementation detail and is not important at this stage. We then define a tuple of three elements, each of the same generic type. Later, we implement our trait for that type we defined. In Rust, a function returns the last expression if there is no explicit return statement. Using this style is considered idiomatic in the community. Our <kbd class="calibre11">max</kbd> function uses this feature in the <kbd class="calibre11">if...else</kbd> block. For the implementation to work, the generic types must have an ordering relation defined between them so that we can compare them. In Rust, this is achieved by constraining the possible types to those which implement the <kbd class="calibre11">PartialOrd</kbd> trait. We also need to put a constraint on the <kbd class="calibre11">Copy</kbd> trait so that the compiler can make copies of the self parameter before returning from the function. We move on to defining another tuple, which has two elements. We implement the same trait here in a similar fashion. When we actually use these in our <kbd class="calibre11">main</kbd> function, they work as expected.</p>
<p class="calibre2">Traits can also be used to extend built-in types and add new functionalities. Let's look at the following example:</p>
<pre class="calibre17">// chapter2/extending-types.rs<br class="title-page-name"/><br class="title-page-name"/>// Trait for our behavior<br class="title-page-name"/>trait Sawtooth {<br class="title-page-name"/>    fn sawtooth(&amp;self) -&gt; Self;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Extending the builtin f64 type<br class="title-page-name"/>impl Sawtooth for f64 {<br class="title-page-name"/>    fn sawtooth(&amp;self) -&gt; f64 {<br class="title-page-name"/>        self - self.floor()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    println!("{}", 2.34f64.sawtooth());<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we want to implement the sawtooth (<a href="https://en.wikipedia.org/wiki/Sawtooth_wave" class="calibre10">https://en.wikipedia.org/wiki/Sawtooth_wave</a>) function on the built-in <kbd class="calibre11">f64</kbd> type. This function is not available in the standard library, so we would need to write some code to get it working by extending the standard library. To have this seamlessly integrated into the type system, we will need to define a trait and implement it for the <kbd class="calibre11">f64</kbd> type. This enables us to use the new function using the dot notation like any other built-in function on the <kbd class="calibre11">f64</kbd> type.</p>
<p class="calibre2">The standard library provides a number of built-in traits; the most common of these are <kbd class="calibre11">Display</kbd> and <kbd class="calibre11">Debug</kbd>. These two are used to format types while printing. <kbd class="calibre11">Display</kbd> corresponds to the empty formatter <kbd class="calibre11">{}</kbd> and <kbd class="calibre11">Debug</kbd> corresponds to format debugging output. All of the mathematical operations are defined as traits, such as <kbd class="calibre11">Add</kbd>, <kbd class="calibre11">Div</kbd>, and so on. The compiler attempts to provide default implementations for user-defined types if they are marked with the <kbd class="calibre11">#[derive]</kbd> attribute. However, an implementation might choose to override any of these if necessary. An example of this is shown in the following code snippet:</p>
<pre class="calibre17">// chapter2/derive.rs<br class="title-page-name"/><br class="title-page-name"/>use std::fmt;<br class="title-page-name"/>use std::fmt::Display;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug, Hash)]<br class="title-page-name"/>struct Point&lt;T&gt; {<br class="title-page-name"/>    x: T,<br class="title-page-name"/>    y: T,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>impl&lt;T&gt; fmt::Display for Point&lt;T&gt; where T: Display {<br class="title-page-name"/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br class="title-page-name"/>        write!(f, "({}, {})", self.x, self.y)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let p: Point&lt;u32&gt; = Point { x: 4u32, y: 2u32 };<br class="title-page-name"/><br class="title-page-name"/>    // uses Display<br class="title-page-name"/>    println!("{}", p);<br class="title-page-name"/><br class="title-page-name"/>    // uses Debug<br class="title-page-name"/>    println!("{:?}", p);<br class="title-page-name"/>}</pre>
<p class="calibre2">We define a generic point structure with two fields. We let the compiler generate implementations of some common traits. We must, however, implement the <kbd class="calibre11">Display</kbd> trait by hand, since the compiler cannot determine the best way to display user-defined types. We have to constrain the generic type to types that implement <kbd class="calibre11">Display</kbd> using the <kbd class="calibre11">where</kbd> clause. This example also demonstrates the alternate way to constrain types based on traits. Having set all of this up, we can display our point using the default formatter. This produces the following output:</p>
<pre class="calibre17"><strong class="calibre1"># rustc derive.rs &amp;&amp; ./derive</strong><br class="title-page-name"/>(4, 2)<br class="title-page-name"/>Point { x: 4, y: 2 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Error handling</h1>
                
            
            <article>
                
<p class="calibre2">One of Rust's major goals is enabling the developer to write robust software. An essential component of this is advanced error handling. In this section, we will take a deeper look at how Rust does error handling. But before that, let's take a detour and look at some type theory. Specifically, we are interested in <strong class="calibre1">algebraic data types</strong> (<strong class="calibre1">ADT</strong>), types formed by combining other types. The two most common ADTs are sum and product types. A <kbd class="calibre11">struct</kbd> in Rust is an example of a product type. This name derives from the fact that given a struct, the range of its type is essentially the Cartesian product of the ranges of each of its components, since an instance of the type has values for all of its constituent types. In contrast, a sum type is when the ADT can assume the type of only one of its constituents. An example of this is an <kbd class="calibre11">enum</kbd> in Rust. While similar to enums in C and other languages, Rust enums provide a number of enhancements: they allow variants to carry data.</p>
<p class="calibre2">Now, back to error handling. Rust mandates that operations which can result in an error must return a special <kbd class="calibre11">enum</kbd> that carries the result. Conveniently, this <kbd class="calibre11">enum</kbd> looks like this:</p>
<pre class="calibre17"><span><span>enum</span> <span>Result</span></span><span>&lt;T, E&gt; {<br class="title-page-name"/></span><span>    Ok</span><span>(T),     <br class="title-page-name"/></span><span>    Err</span><span>(E), <br class="title-page-name"/>}</span></pre>
<p class="calibre2">The two possible options are called variants. In this case, they represent the non-error case and the error case, respectively. Note that this is generically defined so that an implementation is free to define the types in both cases. This is useful in applications that want to expand on the standard error type and implement custom errors. Let's look at an example of this in action:</p>
<pre class="calibre17">// chapter2/custom-errors.rs<br class="title-page-name"/><br class="title-page-name"/>use std::fmt;<br class="title-page-name"/>use std::error::Error;<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>enum OperationsError {<br class="title-page-name"/>    DivideByZeroError,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Useful for displaying the error nicely<br class="title-page-name"/>impl fmt::Display for OperationsError {<br class="title-page-name"/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br class="title-page-name"/>        match *self {<br class="title-page-name"/>        OperationsError::DivideByZeroError =&gt; f.write_str("Cannot divide by zero"),<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Registers the custom error as an error<br class="title-page-name"/>impl Error for OperationsError {<br class="title-page-name"/>    fn description(&amp;self) -&gt; &amp;str {<br class="title-page-name"/>        match *self {<br class="title-page-name"/>            OperationsError::DivideByZeroError =&gt; "Cannot divide by zero",<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Divides the dividend by the divisor and returns the result. Returns<br class="title-page-name"/>// an error if the divisor is zero<br class="title-page-name"/>fn divide(dividend: u32, divisor: u32) -&gt; Result&lt;u32, OperationsError&gt; {<br class="title-page-name"/>    if divisor == 0u32 {<br class="title-page-name"/>        Err(OperationsError::DivideByZeroError)<br class="title-page-name"/>    } else {<br class="title-page-name"/>        Ok(dividend / divisor)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let result1 = divide(100, 0);<br class="title-page-name"/>    println!("{:?}", result1);<br class="title-page-name"/><br class="title-page-name"/>    let result2 = divide(100, 2);<br class="title-page-name"/>    println!("{:?}", result2.unwrap());<br class="title-page-name"/>}</pre>
<p class="calibre2">For this example, we define a function that simply returns the quotient when the first operand is divided by the second. This function must handle the error case when the divisor is zero. We also want it to signal an error to its caller if that is the case. Also, let's assume that this is a part of a library that will expand to include more such operations. To make the code manageable, we create an error class for our library, with one element that represents the divide by zero error. For the Rust compiler to know that the enum is an error type, our enum has to implement the <kbd class="calibre11">Error</kbd> trait from the standard library. It also needs to implement the <kbd class="calibre11">Display</kbd> trait manually. Having set up this boilerplate, we can define our division method. We will take advantage of the generic <kbd class="calibre11">Result</kbd> trait to annotate that on success, it should return a <kbd class="calibre11">u32</kbd>, the same type as the operands. On failure, it should return an error of type <kbd class="calibre11">OperationsError</kbd>. In the function, we raise the error if our divisor is zero. Otherwise, we carry out the division, wrap the result in a <kbd class="calibre11">Ok</kbd> so that it becomes a variant of the <kbd class="calibre11">Result</kbd> enum, and return it. In our <kbd class="calibre11">main</kbd> function, we call this with a zero divisor. The result will be an error, as shown by the first print macro. In the second invocation, we know that the divisor is not zero. Thus, we can safely unwrap the result to convert it from <kbd class="calibre11">Ok(50)</kbd> to <kbd class="calibre11">50</kbd>. The standard library has a number of utility functions to handle <kbd class="calibre11">Result</kbd> types, safely reporting the error to the caller.</p>
<p class="calibre2">Here is a sample run of the last example:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc custom-errors.rs &amp;&amp; ./custom-errors</strong><br class="title-page-name"/>Err(DivideByZeroError)<br class="title-page-name"/>50</pre>
<p class="calibre2">A related idiom in the standard library is the <kbd class="calibre11">Option</kbd> type, as shown in the following code snippet. This is used to indicate the nullability of an operation, indicated by the <kbd class="calibre11">None</kbd> variant. The <kbd class="calibre11">Some</kbd> variant handles the case where it holds the actual value of the type <kbd class="calibre11">T</kbd>:</p>
<pre class="calibre17">pub enum Option&lt;T&gt; {
    None,
    Some(T),
}</pre>
<p class="calibre2">Given this type, we could have written our divide function like this:</p>
<pre class="calibre17">// chapter2/options.rs<br class="title-page-name"/><br class="title-page-name"/>fn divide(dividend: u32, divisor: u32) -&gt; Option&lt;u32&gt; {<br class="title-page-name"/>    if divisor == 0u32 {<br class="title-page-name"/>        None<br class="title-page-name"/>    } else {<br class="title-page-name"/>        Some(dividend / divisor)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let result1 = divide(100, 0);<br class="title-page-name"/><br class="title-page-name"/>    match result1 {<br class="title-page-name"/>        None =&gt; println!("Error occurred"),<br class="title-page-name"/>        Some(result) =&gt; println!("The result is {}", result),<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    let result2 = divide(100, 2);<br class="title-page-name"/>    println!("{:?}", result2.unwrap());<br class="title-page-name"/>}</pre>
<p class="calibre2">We modify our function to return an <kbd class="calibre11">Option</kbd> of type <kbd class="calibre11">u32</kbd>. In our <kbd class="calibre11">main</kbd> function, we call our function. In this case, we can match on the return type. If it happens to be <kbd class="calibre11">None</kbd>, we know that the function did not succeed. In that case, we can print an error. In case it returned <kbd class="calibre11">Some</kbd>, we extract the underlying value and print it. The second invocation works fine since we know it did not get a zero divisor. Using <kbd class="calibre11">Option</kbd> for error handling can be a bit easier to manage since it involves less boilerplate. However, this can be a bit difficult to manage in a library with custom error types since errors are not handled by the type system.</p>
<div class="packt_tip">Note that <kbd class="calibre31">Option</kbd> can be represented as a <kbd class="calibre31">Result</kbd> of a given type and the unit type<br class="calibre22"/>
<kbd class="calibre31">type Option&lt;T&gt; = Result&lt;T, ()&gt;;</kbd>.</div>
<p class="calibre2">What we have described so far for error handling has been done with recoverable errors. In some cases, though, it might be wise to abort execution if an error occurs. The standard library provides the <kbd class="calibre11">panic!</kbd> macro to handle such cases. Calling this stops the execution of the current thread, prints a message on the screen, and unwinds the call stack. However, one needs to use this cautiously since in a lot of cases, a better option is to handle the error properly and bubble the error up to the caller.</p>
<p class="calibre2">A number of built-in methods and functions call this macro in case of an error. Let's look at the following example:</p>
<pre class="calibre17">// chapter2/panic.rs<br class="title-page-name"/><br class="title-page-name"/>fn parse_int(s: String) -&gt; u64 {<br class="title-page-name"/>    return s.parse::&lt;u64&gt;().expect("Could not parse as integer")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // works fine<br class="title-page-name"/>    let _ = parse_int("1".to_owned());<br class="title-page-name"/><br class="title-page-name"/>    // panics<br class="title-page-name"/>    let _ = parse_int("abcd".to_owned());<br class="title-page-name"/>}</pre>
<p class="calibre2">This fails with the following error:</p>
<pre class="calibre17"><strong class="calibre1"># ./panic</strong><br class="title-page-name"/>thread 'main' panicked at 'Could not parse as integer: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:906:4<br class="title-page-name"/>note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<div class="packt_infobox">Some methods that call panic are <kbd class="calibre31">expect()</kbd> and <kbd class="calibre31">unwrap()</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The macro system</h1>
                
            
            <article>
                
<p class="calibre2">Rust supports a macro system that has evolved quite a lot over the years. A distinctive feature of Rust macros are that they are guaranteed to not refer to identifiers outside their scope by accident, and so the macro implementation in Rust is <em class="calibre16">hygienic</em>. As one would expect, Rust macros are expanded to source code ahead of the compilation in place, and are compiled with the translation unit. The compiler enforces scoping rules on expanded macros to make them hygienic. Rust macros differ from other constructs in that they always end in an exclamation mark <kbd class="calibre11">!</kbd>.</p>
<p class="calibre2">Modern Rust has two ways of working with macros; the older, syntactic macro way, and the newer, procedural macro way. Let's look at each of these:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Syntactic macros</h1>
                
            
            <article>
                
<p class="calibre2">This system of macros has existed as part of Rust since pre- 1.0 releases. These macros are defined using a macro called <kbd class="calibre11">macro_rules!</kbd>. Let's look at an example:</p>
<pre class="calibre17">// chapter2/syntactic-macro.rs<br class="title-page-name"/><br class="title-page-name"/>macro_rules! factorial {<br class="title-page-name"/>    ($x:expr) =&gt; {<br class="title-page-name"/>        {<br class="title-page-name"/>            let mut result = 1;<br class="title-page-name"/>            for i in 1..($x+1) {<br class="title-page-name"/>                result = result * i;<br class="title-page-name"/>            }<br class="title-page-name"/>            result<br class="title-page-name"/>        }<br class="title-page-name"/>    };<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let arg = std::env::args().nth(1).expect("Please provide only one argument");<br class="title-page-name"/>    println!("{:?}", factorial!(arg.parse::&lt;u64&gt;().expect("Could not parse to an integer")));<br class="title-page-name"/>}</pre>
<p class="calibre2">We start with defining the factorial macro. Since we do not want the compiler to refuse to compile our code as it might overflow the macro stack, we will use a non-recursive implementation. A syntactic macro in Rust is a collection of rules where the left-hand side dictates how the rule should be matched to an input, and the right-hand side dictates what it should expand to. A rule maps to an expression on the right-hand side via the <kbd class="calibre11">=&gt;</kbd> operator. Variables local to a rule are declared using the <kbd class="calibre11">$</kbd> sign. Match rules are expressed using a special macro language which has its own set of reserved keywords. Our declaration says that we want to take in any valid Rust expression; in this specific case, it should evaluate to an integer. We will leave it to the caller to make sure that is true. We then loop over from 1 to the last integer in the range while accumulating the result. Once done, we return back the result using the implicit return syntax.</p>
<p class="calibre2">Our caller is the main function, in that we take input from the user using the <kbd class="calibre11">std::env</kbd> module. We fetch the first in the list of inputs and throw an error if there are no inputs. We then print the result from our macro, and we try to parse the input as a <kbd class="calibre11">u64</kbd> before passing to it. We also handle the case where parsing might fail. This works as expected:</p>
<pre class="calibre17"><strong class="calibre1"># rustc syntactic-macro.rs &amp;&amp; ./syntactic-macro 5</strong><br class="title-page-name"/>120</pre>
<p class="calibre2">Rust also provides a few tools to debug macros. One might be interested to see what the expanded macro looks like. The <kbd class="calibre11">trace_macros!</kbd> macro does exactly that. To make it work, we will need to enable a feature gate, as shown in the following code snippet (since it is not stable in Rust yet, this code will only work in Rust nightly):</p>
<pre class="calibre17">#![feature(trace_macros)]<br class="title-page-name"/>trace_macros!(true);</pre>
<p class="calibre2">Note that the expansion also includes <kbd class="calibre11">println!</kbd> since it is a macro defined in the standard library.</p>
<div class="packt_tip">The same expansion can also be examined using the following command to invoke the compiler:<br class="calibre22"/>
<kbd class="calibre31">rustc -Z unstable-options --pretty expanded syntactic-macro.rs</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Procedural macros</h1>
                
            
            <article>
                
<p class="calibre2">While regular syntactic macros are useful in a number of scenarios, some applications need advanced code generation features that are better done using the AST that the compiler operates on. Thus, there was a need to extend the macro system to include this. It was later decided that the old macro system and this new system called <em class="calibre16">procedural macros</em> would co-exist. Over time, this is intended to replace the syntactic macro system. The compiler supports loading plugins from external crates; these can receive the AST once the compiler has generated it. There are APIs available to modify the AST in-place to add new code as required. A detailed discussion of this system is beyond the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functional features in Rust</h1>
                
            
            <article>
                
<p class="calibre2">Rust has been inspired by functional languages such as Haskell and OCaml. Unsurprisingly, Rust has rich support for functional programming both in the language and in the standard library. In this section, we will look at some of these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Higher-order functions</h1>
                
            
            <article>
                
<p class="calibre2">We have seen previously how Rust functions define an isolated scope in which all local variables live. Thus, variables outside the scope can never leak into it unless they are explicitly passed as arguments. There can be cases where this is not the desired behavior; closures provide an anonymous function like mechanism, which has access to all the resources defined in the scope in which it is defined. This enables the compiler to enforce the same borrow checking rules while making it easier to reuse code. In Rust terminology, a typical closure borrows all bindings of its surrounding scope. A closure can be forced to own those by marking it with the move keyword. Let's look at some examples:</p>
<pre class="calibre17">// chapter2/closure-borrow.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    // closure with two parameters<br class="title-page-name"/>    let add = |a, b| a + b;<br class="title-page-name"/>    assert_eq!(add(2, 3), 5);<br class="title-page-name"/><br class="title-page-name"/>    // common use cases are on iterators<br class="title-page-name"/>    println!("{:?}", (1..10).filter(|x| x % 2 == 0).collect::&lt;Vec&lt;u32&gt;&gt;());<br class="title-page-name"/><br class="title-page-name"/>    // using a variable from enclosing scope<br class="title-page-name"/>    let times = 2;<br class="title-page-name"/>    println!("{:?}", (1..10).map(|x| x * times).collect::&lt;Vec&lt;i32&gt;&gt;());<br class="title-page-name"/>}</pre>
<p class="calibre2">The first example is a simple closure that adds two numbers given to it. The second example is more involved; it shows a real example of closures for functional programming. We are interested in filtering a list of integers to collect only the even ones out of it. So, we start with a range from 1 to 10, which returns an instance of the built-in type<span> </span><kbd class="calibre11">Range</kbd>. Since that type implements the<span> </span><kbd class="calibre11">IntoIterator</kbd><span> </span>trait, that type behaves as an iterator. Thus, we can filter it by passing a closure that returns true only if the input can be divided by two. Finally, we collect the resultant iterator into a vector of<span> </span><kbd class="calibre11">u32</kbd><span> </span>and print it out. The last example is similar in construction. It borrows the variable times from the closure's enclosing scope and uses it to map to items of the range.</p>
<p class="calibre2">Let's look at an example of using the <kbd class="calibre11">move</kbd> keyword<span> </span>in closures:</p>
<pre class="calibre17">// chapter2/closure-move.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let mut times = 2;<br class="title-page-name"/>    {<br class="title-page-name"/>        // This is in a new scope<br class="title-page-name"/>        let mut borrow = |x| times += x;<br class="title-page-name"/>        borrow(5);<br class="title-page-name"/>    }<br class="title-page-name"/>    assert_eq!(times, 7);<br class="title-page-name"/><br class="title-page-name"/>    let mut own = move |x| times += x;<br class="title-page-name"/>    own(5);<br class="title-page-name"/>    assert_eq!(times, 7);<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">The difference between the first closure (<kbd class="calibre11">borrow</kbd>) and the ones we have discussed so far is that this mutates the variable it inherits from the enclosing scope. We must declare the variable and the closure as<span> </span><kbd class="calibre11">mut</kbd>. We also need to put the closure in a different scope so that the compiler does not complain about double borrowing when we try to assert its value. As asserted, the closure called<span> </span><kbd class="calibre11">borrow</kbd><span> </span>borrows the variables from its parent scope, and that's why its original value changes to <kbd class="calibre11">7</kbd>. The second closure called<span> </span><kbd class="calibre11">own</kbd><span> </span>is a<span> </span>move<span> </span>closure, thus it gets a copy of the variable<span> </span><kbd class="calibre11">times</kbd>. For this to work, the variable has to implement the<span> </span><kbd class="calibre11">Copy</kbd><span> </span>trait so that the compiler can copy it to the closure, which all built-in types do. Since the variable that the closure gets and the original variable are not the same, the compiler does not complain about borrowing it twice. Also, the original value of the variable does not change. These types of closures are immensely important in implementing threads, as we will see in a later section. The standard library also supports accepting and returning closures in user-defined functions or methods using a number of built-in traits, as shown in the following table:</p>
<table class="calibre33">
<tbody class="calibre34">
<tr class="calibre35">
<td class="calibre36"><strong class="calibre1">Trait name</strong></td>
<td class="calibre36"><strong class="calibre1">Function</strong></td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">std::ops::Fn</kbd></td>
<td class="calibre36">Implemented by closures that do not receive <span>mutable</span> captured variables.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">std::ops::FnMut</kbd></td>
<td class="calibre36">Implemented by closures that need to mutate the captured variables.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">std::ops::FnOnce</kbd></td>
<td class="calibre36">Implemented by all closures. Indicates that the closure can be called exactly once.</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Iterators</h1>
                
            
            <article>
                
<p class="calibre2">Another important functional aspect is that of lazy iteration. Given a collection of types, one should be able to loop over those or a subset in any given order. In Rust, a common iterator is a range which has a start and an end. Let's look at how these work:</p>
<pre class="calibre17">// chapter2/range.rs<br class="title-page-name"/><br class="title-page-name"/>#![feature(inclusive_range_syntax)]<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let numbers = 1..5;<br class="title-page-name"/>    for number in numbers {<br class="title-page-name"/>        println!("{}", number);<br class="title-page-name"/>    }<br class="title-page-name"/>    println!("------------------");<br class="title-page-name"/>    let inclusive = 1..=5;<br class="title-page-name"/>    for number in inclusive {<br class="title-page-name"/>        println!("{}", number);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The first range is an exclusive range that spans from the first element to the last but one. The second range is an inclusive one which spans till the last element. Note that inclusive range is an experimental feature that might change in the future.</p>
<p class="calibre2">As one would expect, Rust does provide interfaces with which a user-defined type can be iterated on. The type just needs to implement the trait <kbd class="calibre11">std::iterator::Iterator</kbd>. <span>Let's look at an example. We are interested in generating the </span>Collatz sequence (<a href="https://en.wikipedia.org/wiki/Collatz_conjecture" class="calibre10">https://en.wikipedia.org/wiki/Collatz_conjecture</a>),<span> given an integer. This is given by the recurrence relation below, given an integer:</span></p>
<ul class="calibre7">
<li class="calibre8">If it is even, divide it by two</li>
<li class="calibre8">If it is odd, multiply it by 3 and add one</li>
</ul>
<p class="calibre2">According to the conjecture, this sequence will always terminate at 1. We will assume that is true and define our code respecting that:</p>
<pre class="calibre17">// chapter2/collatz.rs<br class="title-page-name"/><br class="title-page-name"/>// This struct holds state while iterating<br class="title-page-name"/>struct Collatz {<br class="title-page-name"/>    current: u64,<br class="title-page-name"/>    end: u64,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Iterator implementation<br class="title-page-name"/>impl Iterator for Collatz {<br class="title-page-name"/>    type Item = u64;<br class="title-page-name"/><br class="title-page-name"/>    fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {<br class="title-page-name"/>        if self.current % 2 == 0 {<br class="title-page-name"/>            self.current = self.current / 2;<br class="title-page-name"/>        } else {<br class="title-page-name"/>            self.current = 3 * self.current + 1;<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if self.current == self.end {<br class="title-page-name"/>            None<br class="title-page-name"/>        } else {<br class="title-page-name"/>            Some(self.current)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Utility function to start iteration<br class="title-page-name"/>fn collatz(start: u64) -&gt; Collatz {<br class="title-page-name"/>    Collatz { current: start, end: 1u64 }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let input = 10;<br class="title-page-name"/><br class="title-page-name"/>    // First 2 items<br class="title-page-name"/>    for n in collatz(input).take(2) {<br class="title-page-name"/>        println!("{}", n);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    // Dropping first 2 items<br class="title-page-name"/>    for n in collatz(input).skip(2) {<br class="title-page-name"/>        println!("{}", n);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In our code, the state of the current iteration is represented by the struct called <kbd class="calibre11">Collatz</kbd>. We implement the <kbd class="calibre11">Iterator</kbd> protocol on it. For that, we need to implement the <kbd class="calibre11">next</kbd> function, which takes in the current state and produces the next state. When it reaches the end state, it must return a <kbd class="calibre11">None</kbd> so that the caller knows that the iterator has been exhausted. This is represented by the nullable return value of the function. Given the recurrence, the implementation is straightforward. In our main function, we instantiate the initial state and we can iterate using regular <kbd class="calibre11">for</kbd> loops. The <kbd class="calibre11">Iterator</kbd> trait automatically implements a number of useful functions; the <kbd class="calibre11">take</kbd> function takes the given number of elements from the iterator, while the <kbd class="calibre11">skip</kbd> function skips the given number of elements. All these are very important for working with iterable collections.</p>
<p class="calibre2">The following is the output of a run of our example:</p>
<pre class="calibre17"><strong class="calibre1">$ rustc collatz.rs &amp;&amp; ./collatz</strong><br class="title-page-name"/>5<br class="title-page-name"/>16<br class="title-page-name"/>8<br class="title-page-name"/>4<br class="title-page-name"/>2</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Concurrency primitives</h1>
                
            
            <article>
                
<p class="calibre2">One of the promises of Rust is to enable <em class="calibre16">fearless concurrency</em>. Quite naturally, Rust has support for writing concurrent code through a number of mechanisms. In this chapter, we will discuss a few of these. We have seen how the Rust compiler uses borrow checking to ensure correctness of programs at compile time. It turns out that those primitives are also useful in<span> </span>verifying<span> </span>correctness of concurrent code. Now, there are multiple ways of implementing threading in a language. The simplest possible way is to create a new OS thread for each thread created in the platform. This is often called 1:1 threading. On the other hand, a number of application threads can be mapped to one OS thread. This is called N:1 threading. While this approach is resource-light since we end up with fewer actual threads, there is a higher overhead of context switches. A middle ground is called M:N threading, where multiple application threads are mapped to multiple OS level threads. This approach requires the maximum amount of safeguarding and is implemented using a runtime, something that Rust avoids. Thus, Rust uses the 1:1 model. A thread in Rust corresponds to one OS thread in contrast to languages like Go. Let's start with a look at how Rust enables writing multithreaded applications:</p>
<pre class="calibre17">// chapter2/threads.rs<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    for i in 1..10 {<br class="title-page-name"/>        let handle = thread::spawn(move || {<br class="title-page-name"/>            println!("Hello from thread number {}", i);<br class="title-page-name"/>        });<br class="title-page-name"/>        let _ = handle.join();<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We start by importing the threading library. In our main function, we create an empty vector that we will use to store references to the threads we create so that we can wait for them to exit. The threads are actually created using<span> </span><kbd class="calibre11">thread::spawn</kbd>, to which we must pass a closure that will be executed in each of those threads. Since we must borrow a variable from the enclosing scope (the loop index<span> </span><kbd class="calibre11">i</kbd>) in our closure, the closure itself must be a<span> </span>move<span> </span>closure. Right before exiting the closure, we call join on the current thread handle so that all threads wait for one another. This produces the following output:</p>
<pre class="calibre17"><strong class="calibre1"># rustc threads.rs &amp;&amp; ./threads</strong><br class="title-page-name"/>Hello from thread number 1<br class="title-page-name"/>Hello from thread number 2<br class="title-page-name"/>Hello from thread number 3<br class="title-page-name"/>Hello from thread number 4<br class="title-page-name"/>Hello from thread number 5<br class="title-page-name"/>Hello from thread number 6<br class="title-page-name"/>Hello from thread number 7<br class="title-page-name"/>Hello from thread number 8<br class="title-page-name"/>Hello from thread number 9</pre>
<p class="calibre2">The real power of multithreaded applications is when threads can cooperate to do meaningful work. For that, two important things are necessary. Threads need to be able to pass data from one another and there should be ways to coordinate how the threads are scheduled so that they don't step over one another. For the first problem, Rust provides a message, passing mechanisms via channels.<span> </span>Let's<span> </span>look at the following example:</p>
<pre class="calibre17">// chapter2/channels.rs<br class="title-page-name"/><br class="title-page-name"/>use std::thread;<br class="title-page-name"/>use std::sync::mpsc;<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let rhs = vec![10, 20, 30, 40, 50, 60, 70];<br class="title-page-name"/>    let lhs = vec![1, 2, 3, 4, 5, 6, 7];<br class="title-page-name"/>    let (tx, rx) = mpsc::channel();<br class="title-page-name"/><br class="title-page-name"/>    assert_eq!(rhs.len(), lhs.len());<br class="title-page-name"/>    for i in 1..rhs.len() {<br class="title-page-name"/>        let rhs = rhs.clone();<br class="title-page-name"/>        let lhs = lhs.clone();<br class="title-page-name"/>        let tx = tx.clone();<br class="title-page-name"/>        let handle = thread::spawn(move || {<br class="title-page-name"/>            let s = format!("Thread {} added {} and {}, result {}", i,<br class="title-page-name"/>            rhs[i], lhs[i], rhs[i] + lhs[i]);<br class="title-page-name"/>            tx.clone().send(s).unwrap();<br class="title-page-name"/>        });<br class="title-page-name"/>        let _ = handle.join().unwrap();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    drop(tx);<br class="title-page-name"/>    for result in rx {<br class="title-page-name"/>        println!("{}", result);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This example is much like the previous one. We import the necessary modules to be able to work with channels. We define two vectors, and we will create a thread for each pair of elements in the two vectors so that we can add those and return the result. We create the channel, which returns<span> </span>handles<span> </span>to the sending and the receiving ends. As a safety check, we make sure that the two vectors are indeed of equal length. Then, we move on to creating our threads. Since we would need to access outside variables here, the threads need to take in a<span> </span>move<span> </span>closure like the last example. Further, the compiler will try to use the<span> </span><kbd class="calibre11">Copy</kbd><span> </span>trait to copy those variables to the threads. In this case, that will fail since the vector type does not implement<span> </span><kbd class="calibre11">Copy</kbd>. We need to explicitly<span> </span><kbd class="calibre11">clone</kbd><span> </span>the resources so that they do not need to be copied. We run the computation and send the result on the sending end of the pipe. Later, we join all the threads. Before we loop over the receiving end and print the results, we need to explicitly drop the reference to the original handle to the sending end so that all senders are destroyed before we start receiving (the cloned senders will be automatically destroyed when the threads exit). This prints the following, as expected:</p>
<pre class="calibre17"><strong class="calibre1"># rustc channels.rs &amp;&amp; ./channels</strong><br class="title-page-name"/>Thread 1 added 20 and 2, result 22<br class="title-page-name"/>Thread 2 added 30 and 3, result 33<br class="title-page-name"/>Thread 3 added 40 and 4, result 44<br class="title-page-name"/>Thread 4 added 50 and 5, result 55<br class="title-page-name"/>Thread 5 added 60 and 6, result 66<br class="title-page-name"/>Thread 6 added 70 and 7, result 77</pre>
<div class="packt_infobox">Also note that mpsc<span class="calibre18"> </span>stands for multiple producer single consumer.</div>
<p class="calibre2">While working with multiple threads, another common idiom is that of sharing a common state between all of those. That, however, can be a can of worms in a lot of cases. The caller needs to carefully set up exclusion mechanisms so that the state is shared in a race-free manner. Luckily, the borrow checker can help in ensuring this is easier. Rust has a number of smart pointers for dealing with the shared state. The library also provides a generic mutex type that can be used as a lock while working with multiple threads. But perhaps the most important are the <kbd class="calibre11">Send</kbd> and the <kbd class="calibre11">Sync</kbd> traits. Any type that implements the <kbd class="calibre11">Send</kbd> trait can be shared safely between multiple threads. The <kbd class="calibre11">Sync</kbd> trait indicates that access from multiple threads is safe for the given data. There are a few rules around these traits:</p>
<ul class="calibre7">
<li class="calibre8">All built-in types implement both <kbd class="calibre11">Send</kbd> and <kbd class="calibre11">Sync</kbd> with the exception of anything <kbd class="calibre11">unsafe</kbd>, a few smart pointer types like <kbd class="calibre11">Rc&lt;T&gt;</kbd> and <kbd class="calibre11"><span>UnsafeCell&lt;T&gt;</span></kbd></li>
<li class="calibre8">A composite type will automatically implement both, as long as it does not have any type that does not implement <kbd class="calibre11">Send</kbd> and <kbd class="calibre11">Sync</kbd></li>
</ul>
<p class="calibre2">The <kbd class="calibre11">std::sync</kbd> package has a lot of types and helpers for working with parallel code.</p>
<p class="calibre2">In the previous paragraph, we mentioned unsafe Rust. Let's take a detour and look at that in a bit more detail. The Rust compiler provides some strong guarantees around safe programming by using a robust type system. However, there can be cases where these become more of an overhead. To handle such cases, the language provides a way to opt out of those guarantees. A block of code marked with the <kbd class="calibre11">unsafe</kbd> keyword can do everything Rust can do, and the following:</p>
<ul class="calibre7">
<li class="calibre8">Dereference raw pointer types (*mut T or <kbd class="calibre11">*const T</kbd>)</li>
<li class="calibre8">Call unsafe functions or methods</li>
<li class="calibre8">Implement a trait marked as <kbd class="calibre11">unsafe</kbd></li>
<li class="calibre8">Mutate a static variable</li>
</ul>
<p class="calibre2">Let's look at an example which uses the <kbd class="calibre11">unsafe</kbd> block of code to dereference a pointer:</p>
<pre class="calibre17">// chapter2/unsafe.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let num: u32 = 42;<br class="title-page-name"/>    let p: *const u32 = &amp;num;<br class="title-page-name"/><br class="title-page-name"/>    unsafe {<br class="title-page-name"/>        assert_eq!(*p, num);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we create a variable and a pointer to it; if we try to dereference the pointer without using the <kbd class="calibre11">unsafe</kbd> block, the compiler will refuse to compile. Inside the <kbd class="calibre11">unsafe</kbd> block, we get back the original value on dereferencing. While unsafe code can be dangerous to work with, it's very useful in lower level programming like Kernel (RedoxOS) and embedded systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing</h1>
                
            
            <article>
                
<p class="calibre2">Rust treats testing as a first-class construct; all tools in the ecosystem supports testing. The compiler provides a built-in configuration attribute that designates a module for testing. There is also a test attribute that designates functions as tests. When Cargo generates a project from scratch, it sets up this boilerplate. Let's look at an example project; we will call it factorial. It will export a macro that computes the factorial given an integer. Since we have conveniently written such a macro before, we will just re-use that code here. Note that since this crate will be used as a library, this does not have a main function:</p>
<pre class="calibre17"><strong class="calibre1"># cargo new factorial --lib</strong><br class="title-page-name"/><strong class="calibre1"># cargo test</strong><br class="title-page-name"/>   Compiling factorial v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch2/factorial)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.6 secs<br class="title-page-name"/>     Running target/debug/deps/factorial-364286f171614349<br class="title-page-name"/><br class="title-page-name"/>running 1 test<br class="title-page-name"/>test tests::it_works ... ok<br class="title-page-name"/><br class="title-page-name"/>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br class="title-page-name"/><br class="title-page-name"/>   Doc-tests factorial<br class="title-page-name"/><br class="title-page-name"/>running 0 tests<br class="title-page-name"/><br class="title-page-name"/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p class="calibre2">Running <kbd class="calibre11">cargo test</kbd> runs the stub tests that Cargo generates for us. We will copy the code for the factorial macro to the <kbd class="calibre11">lib.rs</kbd>, which will look like this:</p>
<pre class="calibre17">// chapter2/factorial/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>#[allow(unused_macros)]<br class="title-page-name"/>#[macro_export]<br class="title-page-name"/>macro_rules! factorial {<br class="title-page-name"/>    ($x:expr) =&gt; {<br class="title-page-name"/>        {<br class="title-page-name"/>            let mut result = 1;<br class="title-page-name"/>            for i in 1..($x+1) {<br class="title-page-name"/>                result = result * i;<br class="title-page-name"/>            }<br class="title-page-name"/>            result<br class="title-page-name"/>        }<br class="title-page-name"/>    };<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[cfg(test)]<br class="title-page-name"/>mod tests {<br class="title-page-name"/>    #[test]<br class="title-page-name"/>    fn test_factorial() {<br class="title-page-name"/>        assert_eq!(factorial!(5), 120);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We also added a test to make sure factorial actually works as one would expect. The <kbd class="calibre11">#[macro_export]</kbd> attribute tells the compiler that this macro is to be used outside the crate. The compiler built-in <kbd class="calibre11">assert_eq!</kbd> macro checks that the two arguments are indeed equal. We also need to put the <kbd class="calibre11">#[allow(unused_macros)]</kbd> attribute since, without it, the compiler will complain that the macro is not being used in non-test code. If we add one more test that looks like this:</p>
<pre class="calibre17">    #[test]<br class="title-page-name"/>    fn test_factorial_fail() {<br class="title-page-name"/>        assert_eq!(factorial!(5), 121);<br class="title-page-name"/>    }</pre>
<p class="calibre2">This is obviously wrong, and as expected, fails and gives us a descriptive error. The compiler also supports an attribute called <kbd class="calibre11">#[should_panic]</kbd> that marks tests that should panic. In this case, the tests pass only if there is a panic. Another way of writing tests is in the documentation which is also run on a Cargo invocation.</p>
<p class="calibre2">This is a very important tool in documenting code with working examples, which are guaranteed to work as the codebase evolves. Let's go ahead and add some doctest for our factorial macro:</p>
<pre class="calibre17">// chapter2/factorial/src/lib.rs<br class="title-page-name"/><br class="title-page-name"/>/// The factorial crate provides a macro to compute factorial of a given<br class="title-page-name"/>/// integer<br class="title-page-name"/>/// # Examples<br class="title-page-name"/>///<br class="title-page-name"/>/// ```<br class="title-page-name"/>/// # #[macro_use] extern crate factorial;<br class="title-page-name"/>/// # fn main() {<br class="title-page-name"/>/// assert_eq!(factorial!(0), 1);<br class="title-page-name"/>/// assert_eq!(factorial!(6), 720);<br class="title-page-name"/>/// # }<br class="title-page-name"/>/// ```<br class="title-page-name"/>///<br class="title-page-name"/><br class="title-page-name"/>#[macro_export]<br class="title-page-name"/>macro_rules! factorial {<br class="title-page-name"/>    ($x:expr) =&gt; {<br class="title-page-name"/>        {<br class="title-page-name"/>            let mut result = 1;<br class="title-page-name"/>            for i in 1..($x+1) {<br class="title-page-name"/>                result = result * i;<br class="title-page-name"/>            }<br class="title-page-name"/>            result<br class="title-page-name"/>        }<br class="title-page-name"/>    };<br class="title-page-name"/>}</pre>
<p class="calibre2">Doctests for macros differ a bit from doctests for everything else in the following way:</p>
<ul class="calibre7">
<li class="calibre8">They must use the <kbd class="calibre11">#[macro_use]</kbd> attribute to mark that the macro is being used here. Note that an external crate that depends on the crate that exports a macro must use that attribute too.</li>
<li class="calibre8">They must define the main function and include an <kbd class="calibre11">extern crate</kbd> directive in the doctests. For everything else, the compiler generates the main function as needed. The extra <kbd class="calibre11">#</kbd> marks hide those from the generated documentation.</li>
</ul>
<p class="calibre2">In general, the tests module, doctests, and the <kbd class="calibre11">#[test]</kbd> attributes should be used only for unit tests. Integration tests should be placed in a top-level tests directory.</p>
<div class="packt_infobox">The Rust team is working on adding support for running benchmarks in the test system. This is only available on nightly for now.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter was a very short introduction to the Rust language and the ecosystem. Given this background in Rust, let's look at a frequently asked question: should a company adopt Rust? Like a lot of things in engineering, the correct answer is that it depends on a lot of factors. One of the primary reasons for adopting Rust would be the ability to write robust code with less of a footprint as possible. Thus, Rust is suitable for projects targeting embedded devices. This area has traditionally used assembly, C, and C++. Rust can provide the same performance guarantees while ensuring code correctness. Rust also works well for offloading performance intensive computation from Python or Ruby. The primary pain point with Rust is that the learning curve can be steep. Thus, a team trying to adopt Rust might spend a lot of time fighting with the compiler, trying to run code. This, however, eases out with time. Luckily, the compiler error messages are generally very helpful. In 2017, the Rust team decided to make ergonomics a priority. This push has made onboarding new developers a lot easier. For large Rust projects, compile time can be larger than C, C++, or Go. This can become a problem for some teams. There are a few ways to work around this problem, one of them being incremental compilation. Thus, it is difficult to arrive at a one size fits all solution. Hopefully, this short introduction will help in deciding whether to choose Rust in a new project.</p>
<p class="calibre2">In the next chapter, we will build on what we studied here by looking at how Rust handles TCP and UDP connections between two hosts in a network.</p>


            </article>

            
        </section>
    </body></html>