<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Efficient Error Handling</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Efficient Error Handling</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Implementing panic</li>
<li>Implementing Option</li>
<li><span>Creating</span> map combinator</li>
<li>Creating and_then combinator</li>
<li>Creating map for the Result type</li>
<li>Implementing aliases</li>
<li>Handling multiple errors</li>
<li>Implementing early returns</li>
<li>Implementing the try! macro</li>
<li>Defining your own error types</li>
<li>Implementing the boxing of errors</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Error handling is a fundamental part of all programming languages. It is the way in which a developer prepares for the worst conditions by noticing and managing errors due to which the application could fail. These error conditions can occur due to various reasons, such as wrong input provided at runtime and more. In this chapter, we will cover various methods using which we can efficiently handle errors in Rust. We'll also check out the standard library that helps avoid problematic situations and thus avoid a complete failure of the Rust application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing panic</h1>
                </header>
            
            <article>
                
<p>Panic is the simplest error handling mechanism provided by Rust. It prints the error messages given to it, starts to unwind the task, and usually exits the program execution. In this recipe, we will explicitly call out a <kbd>panic</kbd> statement in the face of an undesired case.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the ensuing steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_panic.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing panic <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>compare_stmt</kbd> function; it accepts a string input:</li>
</ol>
<pre>        // function which checks if the strings are same or not<br/>        fn compare_stmt(stmt: &amp;str) {<br/>          // Check if the statements are same or not <br/>          if stmt == "Another book" { <br/>            panic!("Rust Cookbook is not selected!!!!"); <br/>          }<br/><br/>          println!("Statements is {}!!!!!", stmt);<br/>        }
</pre>
<ol start="4">
<li>Define the <kbd>main</kbd> function; it calls the <kbd>compare_stmt</kbd> function with different input:</li>
</ol>
<pre>        // Execution starts here<br/>        fn main() {<br/>         compare_stmt("Rust Cookbook");<br/>         compare_stmt("Another book");<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="67" width="526" src="images/e399cede-55ef-43bc-aba5-1e7800e6fa64.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We have a function named <kbd>compare_stmt</kbd> that accepts an <kbd>str</kbd> variable as an argument and assigns it to a variable named <kbd>input</kbd> in its scope. It later checks whether the string value is <kbd>Another Book</kbd>. If it is, it calls the <kbd>panic!</kbd> function; otherwise, it prints the value that was passed. We passed two values from the main function: <kbd>Rust CookBook</kbd> and <span><kbd>`Another Book`</kbd>.</span></p>
<p>When we run the preceding program, the first input will fail the <kbd>if</kbd> condition and will not invoke panic, so we get the print statement working. However, for the second input, which satisfies the <kbd>if</kbd> condition, panic is invoked and it returns <kbd>thread 'main' panicked at 'Rust Cookbook is not selected!!!!', sample_panic.rs:12</kbd> and exits the program.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Option</h1>
                </header>
            
            <article>
                
<p><span>Panic handles cases where there are identified instances of undesired input, but it does not handle zero input. For that, we have the <kbd>Option&lt;T&gt;</kbd> type, an <kbd>enum</kbd> from the standard library that you can use to handle cases where you have no input. In this recipe, you will learn the different ways in which you can use</span> Options <span>to handle zero case input.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow the ensuing steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_option.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<p>&#160;</p>
<pre>        //-- #########################<br/>        //-- Task: Implementing Option<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>compare_stmt_match</kbd> function; it accepts the <kbd>input</kbd> string of the <kbd>Option&lt;&amp;str&gt;</kbd> type:</li>
</ol>
<p>&#160;</p>
<pre>        // All arguments are handled explicitly using `match`.<br/>        fn compare_stmt_match(input: Option&lt;&amp;str&gt;) {<br/>          // Specify a course of action for each case.<br/>          match input {<br/>            Some("Rust CookBook") =&gt; println!("Rust CookBook <br/>            was selected"),<br/>            Some(inner) =&gt; println!("Rust CookBook not<br/>            selected"),<br/>            None =&gt; println!("No input provided"),<br/>          }<br/>        }
</pre>
<ol start="4">
<li>Similarly, create the <kbd>compare_stmt_unwrap</kbd> function; it <span>also accepts the</span> <kbd>input</kbd> <span>string of the</span> <kbd>Option&lt;&amp;str&gt;</kbd> <span>type:</span></li>
</ol>
<p>&#160;</p>
<pre>        // All arguments are handled implicitly using `unwrap`.<br/>        fn compare_stmt_unwrap(input: Option&lt;&amp;str&gt;) {<br/>          // `unwrap` returns a `panic` when it receives a<br/>          `None`     value<br/>          let inside_val = input.unwrap();<br/>          if inside_val == "Another Book" { panic!("Rust<br/>          CookBook is not selected"); }<br/><br/>          println!("I love {}s!!!!!", inside_val);<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>main</kbd> function; it calls the two functions with different input:</li>
</ol>
<pre>        // main execution starts here<br/>        fn main() {<br/>          let Desired_Book = Some("Rust CookBook");<br/>          let Another_Book = Some("Another Book");<br/>          let Empty_value = None;<br/><br/>          compare_stmt_match(Desired_Book);<br/>          compare_stmt_match(Another_Book);<br/>          compare_stmt_match(Empty_value);<br/><br/>          println!("*********************");<br/><br/>          let Rand_Book = Some("Random Book");<br/>          let No_val = None;<br/><br/>          compare_stmt_unwrap(Rand_Book);<br/>          compare_stmt_unwrap(No_val);<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="689" src="images/da4d8747-d2ab-4086-bcf9-28b28b645e7f.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the preceding recipe, we knew we had to exit the program using <kbd>panic!</kbd> in the case of an undesired input, but the main problem we are trying to solve in this recipe is the way by which we can handle <kbd>None</kbd> input. We use the Rust standard library to address this problem. More specifically, we use an <kbd>enum</kbd> called <kbd>Option&lt;T&gt;</kbd> from the <kbd>std</kbd> library, which is used when there is no input:</p>
<pre><span class="kw">        enum</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {<br/>          <span class="prelude-val">None</span>,<br/>          <span class="prelude-val">Some</span>(<span class="ident">T</span>),<br/>        }
</pre>
<p>It has two options, namely:</p>
<ul>
<li><kbd>Some(T)</kbd>: This is an element of the type <kbd>T</kbd> that was sent</li>
<li><kbd>None</kbd>: This refers to the case where there was no input</li>
</ul>
<p>We handle these cases in two ways: the explicit way of handling in which we use <kbd>match</kbd> and the implicit way in which we use <kbd>unwrap</kbd>. The implicit way of handling returns the inner element of either <kbd>enum</kbd> or <kbd>panic!</kbd>.</p>
<p>In the explicit way of handling, we declared three variables, namely <kbd>Desired_Book</kbd>, <kbd>Another_Book</kbd>, and <kbd>Empty_value</kbd> in the <kbd>main</kbd> function. We assigned them with book names, which were <kbd>Rust Cookbook</kbd>, <kbd>Another Book</kbd>, and <kbd>`None`</kbd>, respectively. Post this, we called the functions in the following manner:</p>
<ul>
<li><kbd>compare_stmt_match(Desired_Book)</kbd>: This satisfies the match statement condition <kbd>Some("Rust CookBook")</kbd> to print <kbd>Rust CookBook was selected</kbd></li>
<li><kbd>compare_stmt_match(Another_Book)</kbd>: <span>This satisfies the <kbd>match</kbd> statement condition</span> <kbd>Some(inner)</kbd> <span>to print</span> <kbd>"Rust CookBook not selected"</kbd></li>
<li><kbd>compare_stmt_match(Empty_val)</kbd>: This satisfies the <kbd>match</kbd> statement condition <kbd>None</kbd> to print <kbd>No input provided</kbd></li>
</ul>
<p>In implicit handling, we created <kbd>Rand_Book</kbd> and <kbd>No_val</kbd> with the values <kbd>Some("Random Book")</kbd> and <kbd>None</kbd>, respectively. We call another function that uses unwrap to handle <kbd>Some(T)</kbd> and <kbd>None</kbd> values. The <kbd>compare_stmt_unwrap(Rand_Book)</kbd> used <kbd>unwrap</kbd> to get <kbd>inside_val</kbd>, which successfully called the print statement; on the second function call <kbd>compare_stmt_unwrap(No_val)</kbd>, we got <kbd>thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', ../src/libcore/option.rs:323</kbd>. This was because <kbd>unwrap</kbd> returns a panic when we have <kbd>None</kbd> as the inner value.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating map combinator</h1>
                </header>
            
            <article>
                
<p>We will learn about the map combinator in this recipe, which again is a combinator for handling <kbd>Option</kbd> types. The <kbd>Option</kbd> has an inbuilt map method for simple mapping of <kbd>Some(T)</kbd> to another valid type; it can also handle the mapping of none values. The <kbd>map</kbd> is a great way to explicitly handle <kbd>None</kbd> case input. It also simplifies the code as it can be used multiple times. Combinators, in general, are high-order functions that apply only the functions and the combinators defined earlier to provide a result from their arguments. They are generally used to control the flow in a modular fashion in an application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_map.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing map <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create a user-defined data type to use the program:</li>
</ol>
<pre>        #![allow(dead_code)]<br/><br/>        #[derive(Debug)] enum Food { Apple, Carrot, Potato }<br/><br/>        #[derive(Debug)] struct Peeled(Food);<br/>        #[derive(Debug)] struct Chopped(Food);<br/>        #[derive(Debug)] struct Cooked(Food);
</pre>
<ol start="4">
<li>Define the <kbd>peel</kbd> function; it accepts the <kbd>Option&lt;Food&gt;</kbd> type input and returns <kbd>Option&lt;Peeled&gt;</kbd>:</li>
</ol>
<pre>        fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {<br/>          match food {<br/>            Some(food) =&gt; Some(Peeled(food)),<br/>            None =&gt; None,<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Define the <kbd>chop</kbd> function; it accepts the <kbd>Option&lt;Peeled&gt;</kbd> type input and returns <kbd>Option&lt;Chopped&gt;</kbd>:</li>
</ol>
<pre>        fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {<br/>          match peeled {<br/>            Some(Peeled(food)) =&gt; Some(Chopped(food)),<br/>            None =&gt; None,<br/>          }<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>cook</kbd> function; it accepts the <kbd>Option&lt;Chopped&gt;</kbd> type input and returns <kbd>Option&lt;Cooked&gt;</kbd>:</li>
</ol>
<pre>        fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {<br/>          chopped.map(|Chopped(food)| Cooked(food))<br/>        }
</pre>
<ol start="7">
<li>Define the <kbd>process</kbd> function; it accepts the <kbd>Option&lt;Food&gt;</kbd> type input and returns <kbd>Option&lt;Cooked&gt;</kbd>:</li>
</ol>
<pre>        fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {<br/>          food.map(|f| Peeled(f))<br/>          .map(|Peeled(f)| Chopped(f))<br/>          .map(|Chopped(f)| Cooked(f))<br/>        }
</pre>
<ol start="8">
<li>Define the <kbd>eat</kbd> function; it accepts the <kbd>Option&lt;Cooked&gt;</kbd> type input:</li>
</ol>
<pre>        fn eat(food: Option&lt;Cooked&gt;) {<br/>          match food {<br/>            Some(food) =&gt; println!("Mmm. I love {:?}", food),<br/>            None =&gt; println!("Oh no! It wasn't edible."),<br/>          }<br/>        }
</pre>
<ol start="9">
<li>Define <span>the <kbd>main</kbd></span> <span>function where we can create the different types of input to understand the working of the map combinator:</span></li>
</ol>
<pre>        fn main() {<br/>          let apple = Some(Food::Apple);<br/>          let carrot = Some(Food::Carrot);<br/>          let potato = None;<br/><br/>          let cooked_apple = cook(chop(peel(apple)));<br/>          let cooked_carrot = cook(chop(peel(carrot)));<br/>          let cooked_potato = process(potato);<br/><br/>          eat(cooked_apple);<br/>          eat(cooked_carrot);<br/>          eat(cooked_potato);<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="70" width="529" src="images/21819b41-85ef-4299-b15b-01dc5bfc7f9e.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We first created an <kbd>enum</kbd> type named <kbd>Food</kbd> that had data elements, namely <kbd>Apple</kbd>, <kbd>Carrot</kbd>, and <kbd>Potato</kbd>. Then we created three <kbd>struct</kbd> with user-defined data types, namely <kbd>Peeled</kbd>, <kbd>Chopped</kbd>, and <kbd>Cooked</kbd> with <kbd>Food</kbd> as a data field. In the <kbd>main</kbd> function, we created three variables and assigned them to the values of the <kbd>Option</kbd> data, where <kbd>apple</kbd> was valued <kbd>Food::Apple</kbd>, <kbd>carrot</kbd> as <kbd>Food::Carrot</kbd>, and <kbd>potato</kbd> as <kbd>None</kbd>.</p>
<p>Now let's check out how our function units react to different input:</p>
<ul>
<li><kbd>peel</kbd>: This function takes in an <kbd>Option</kbd> type that has a field <kbd>enum</kbd> type <kbd>Food</kbd> along with the data and returns an <kbd>Option</kbd> of the <kbd>struct</kbd> data type <kbd>Peeled</kbd>. Here we use the <kbd>match</kbd> function to change the type.</li>
<li><kbd>chop</kbd>: This f<span>unction takes in the <kbd>Option</kbd> type that has a field <kbd>enum</kbd> type <kbd>Peeled</kbd></span> <span>along with the data and returns an <kbd>Option</kbd> of the <kbd>struct</kbd> data type <kbd>Chopped</kbd></span><span>. Here we use the</span> <kbd>match</kbd> <span><span>function to change the type.</span></span></li>
<li><kbd>cook</kbd>: This function takes in the <kbd>Option</kbd> type that has a field <kbd>enum</kbd> type <kbd><span><span>Chopped</span></span></kbd> along with the data and returns an <kbd>Option</kbd> of the <kbd>struct</kbd> data type <kbd>Cooked</kbd>. Here we use the <span><span><kbd>map</kbd></span></span> function to change the type, where we place the input type between two pipe symbols that convert them into the desired form.</li>
<li><kbd>process</kbd>: Instead of having three functions to change types, we use map multiple times to convert <kbd>Option&lt;Food&gt;</kbd> into <kbd>Option&lt;Cooked&gt;</kbd> directly, where each map function successively converts the type to the desired form by this process we can peel, chop, and cook <kbd>food</kbd> type in a sequence by using multiple <kbd>map()</kbd>, thus it simplifies the code.</li>
<li><kbd>eat</kbd>: This function takes in the <kbd>Option&lt;Cooked&gt;</kbd> type as an input argument and checks it using a <kbd>match</kbd> statement. The first case <kbd>some(food)</kbd> would be true if a valid type exists for the <kbd>food</kbd> argument which is passed to the <kbd>match</kbd> statement, then it would print the value of the argument <kbd>food</kbd> in the place holder of the print statement else in the <kbd>None</kbd> case, it prints a default statement.</li>
</ul>
<p>In the <kbd>main</kbd> function, we declared <kbd>cooked_apple</kbd> and assigned the return value of the <kbd>chop(peel(apple))</kbd> call. Since we didn't pass a <kbd>None</kbd> input, this was supposed to return the <kbd>Cooked(apple)</kbd> type of the data feed. Similarly, <span><kbd>cooked_carrot</kbd> had the value <kbd>Cooked(carrot)</kbd></span>; <span>however, <kbd>cooked_potato</kbd></span>, <span>for which we called the <kbd>process</kbd> function, returned <kbd>None</kbd>. Later, when we called the <kbd>eat</kbd> function, only the variable that had <kbd>Cooked</kbd> <kbd>struct</kbd> values got printed as</span> <kbd>MM. I Love statement</kbd> <span>and the variable that had <kbd>None</kbd> had</span> <kbd>Oh No! statement</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and_then combinator</h1>
                </header>
            
            <article>
                
<p>The problem with <kbd>map</kbd> is that it can get confusing when we have too many functions returning maps. This is because the result will be nested in the <kbd>Option&lt;Option&lt;T&gt;&gt;</kbd> format, and this gets complicated and confusing on multiple calls of the map combinator.</p>
<p>Rust provides another combinator, namely <kbd>and_then()</kbd>, which solves the preceding problem by only returning the result instead. It does it by flattening the chained results to a single type. In this recipe, you will learn how to use this combinator in detail.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_and_then.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing and_then <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Create the <kbd>enum</kbd> types <kbd>Food</kbd> and <kbd>Day</kbd>:</li>
</ol>
<pre>        #![allow(dead_code)]<br/><br/>        #[derive(Debug)] enum Food { CordonBleu, Steak, Sushi}<br/>        #[derive(Debug)] enum Day { Monday, Tuesday, Wednesday}
</pre>
<ol start="4">
<li>Define a function named <kbd>have_ingredients</kbd> that will accept the <kbd>Food</kbd> type as an input argument and return <kbd>Option&lt;Food&gt;</kbd>:</li>
</ol>
<pre>        fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {<br/>          match food {<br/>            Food::Sushi =&gt; None,<br/>            _ =&gt; Some(food),<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Define a function named <kbd>have_recipe</kbd> that will accept the <kbd>Food</kbd> type as an input argument and return <kbd>Option&lt;Food&gt;</kbd>:</li>
</ol>
<pre>        fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {<br/>          match food {<br/>            Food::CordonBleu =&gt; None,<br/>            _ =&gt; Some(food),<br/>          }<br/>        }
</pre>
<ol start="6">
<li>Define a function named <kbd>cookable</kbd> that will accept the <kbd>Food</kbd> type as an input argument and return <kbd><span>Option&lt;Food&gt;</span></kbd>:</li>
</ol>
<pre>        fn cookable(food: Food) -&gt; Option&lt;Food&gt; {<br/>          have_ingredients(food).and_then(have_recipe)<br/>        }
</pre>
<ol start="7">
<li>Define a function named <kbd><span><span>eat</span></span></kbd> that will accept the <kbd>Food</kbd> type as an input argument and return <kbd>Day</kbd>:</li>
</ol>
<pre>        fn eat(food: Food, day: Day) {<br/>          match cookable(food) {<br/>            Some(food) =&gt; println!("Yay! On {:?} we get to eat<br/>            {:?}.", day, food),<br/>            None =&gt; println!("Oh no. We don't get to eat on <br/>            {:?}?", day),<br/>          }<br/>        }
</pre>
<ol start="8">
<li>Define the <kbd>main</kbd> function; it will initialize and call all the functions:</li>
</ol>
<pre>        fn main() {<br/>          let (cordon_bleu, steak, sushi) = (Food::CordonBleu,<br/>          Food::Steak, Food::Sushi);<br/><br/>          eat(cordon_bleu, Day::Monday);<br/>          eat(steak, Day::Tuesday);<br/>          eat(sushi, Day::Wednesday);<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="67" width="537" src="images/6fe0fca8-1379-4550-8249-0cac73518195.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We declared two <kbd>enum</kbd> types, namely <kbd>Food</kbd> and <kbd>Day</kbd>, where we had these elements: <kbd>CordonBleu</kbd>, <kbd>Steak</kbd>, and <kbd>Sushi</kbd> and <kbd>Monday</kbd>, <kbd>Tuesday</kbd>, and <kbd>Wednesday</kbd>.</p>
<p><span>Now let's see how our function units react to different input:</span></p>
<ul>
<li><kbd>have_ingredients</kbd>: This function takes in the <kbd>enum</kbd> input <kbd>Food</kbd> and returns <kbd>Option&lt;Food&gt;</kbd>. It has a case in its <kbd>match</kbd> statement indicating whether <kbd>Food</kbd> has the value <kbd>Sushi</kbd> in that it returns <kbd>None</kbd> and for all other values, it returns the same <kbd>Food</kbd> value.</li>
<li><kbd>have_recipe</kbd>: This function takes in the <kbd>enum</kbd> input <kbd>Food</kbd> and returns <kbd>Option&lt;Food&gt;</kbd>. It has a case in its <kbd>match</kbd> statement indicating whether <kbd>Food</kbd> has the value <kbd>CordonBleu</kbd> in that it returns <kbd>None</kbd>; for all other values, it returns the same <kbd>Food</kbd> value.</li>
<li><kbd><span><span>cookable</span></span></kbd>: This function takes in the <kbd>enum</kbd> input <kbd>Food</kbd> and returns <kbd>Option&lt;Food&gt;</kbd>. Here, we use the <kbd>and_then</kbd> combinator to check the <kbd>have_ingredients</kbd> and <kbd>have_recipe</kbd> functions in order to confirm that the <kbd>Food</kbd> type will pass these cases.</li>
<li><kbd>eat</kbd>: This function takes the <kbd>enum</kbd> input <kbd>Food</kbd> and <kbd>Day</kbd> and sends the <kbd>Food</kbd> value to the <kbd>cookable</kbd> function. Here we have a <kbd>match</kbd> statement that prints the day and <kbd>Food</kbd> type in the case of <kbd>Some(Food)</kbd> from the <kbd>cookable</kbd> function.</li>
</ul>
<p>We observe that for <kbd>cookable</kbd> to return a value, we need both the functions <span><kbd>have_ingredients</kbd> and <kbd>have_</kbd></span> <span>recipe to return <kbd>Some(Food)</kbd>, which happens only in the case of <kbd>Steak</kbd>.</span> In the <kbd>main</kbd> function, we called the <kbd>eat</kbd> function with all the values of <kbd>Food</kbd> and <kbd>Day</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating map for the Result type</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>Result</kbd> type is similar to the <kbd>Option</kbd> type, but it offers more, as it also describes the possible error. This means we will have two outcomes: one where the desired element is found and the other where we may have found an error with an element. In this recipe, we will use the <kbd>map</kbd> method of <kbd>Result</kbd> to return a specific error.<br/></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_map_result.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing map for Result <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard library:</li>
</ol>
<pre><strong>      use</strong> <strong>std::num::ParseIntError;</strong>
</pre>
<ol start="4">
<li>Create a function named <kbd>double_number</kbd> that will accept the <kbd>str</kbd> input and return a <kbd>Result&lt;T&gt;</kbd> type:</li>
</ol>
<pre>        fn double_number(number_str: &amp;str) -&gt; Result&lt;i32,<br/>        ParseIntError&gt; {<br/>          match number_str.parse::&lt;i32&gt;() {<br/>            Ok(n) =&gt; Ok(2 * n),<br/>            Err(e) =&gt; Err(e),<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Create a function named <kbd>double_number_map</kbd> that will accept the <kbd>str</kbd> input and return a <kbd>Result&lt;T&gt;</kbd> type:</li>
</ol>
<pre>        fn double_number_map(number_str: &amp;str) -&gt; Result&lt;i32,<br/>        ParseIntError&gt; {<br/>          number_str.parse::&lt;i32&gt;().map(|n| 2 * n)<br/>        }
</pre>
<ol start="6">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;T&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32, ParseIntError&gt;) {<br/>          match result {<br/>          Ok(n) =&gt; println!("n is {}", n),<br/>          Err(e) =&gt; println!("Error: {}", e),<br/>          }<br/>        }
</pre>
<ol start="7">
<li>Define the <kbd>main</kbd> function and declare different input for different functions:</li>
</ol>
<pre>        fn main() {<br/>          // This still presents a reasonable answer.<br/>          let twenty = double_number("10");<br/>          print(twenty);<br/><br/>          // The following now provides a much more helpful<br/>          error message.<br/>          let tt = double_number_map("t");<br/>          print(tt);<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="47" width="497" src="images/8614b77b-4a21-406c-9ca7-2506ddc273cf.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Panicking gives us only an error message, which is not of great use for being more specific regarding the return type and the error. We have the <kbd>Result</kbd> type, which is similar to Options, but it can also be used to mention the error type. In this recipe, we used the map method of Rust to get the specific error type.</p>
<p>First, we called the standard library error type <kbd>ParseIntError</kbd>, which we used for returning error types as per the <kbd>Result</kbd> type.</p>
<p>Let's check out the different functional units in the code:</p>
<ul>
<li><kbd>print</kbd>: This function takes in an input type of <kbd>Result&lt;i32, ParseIntError&gt;</kbd>, and based on its value, whether it is <kbd>Ok</kbd> or <kbd>Err</kbd>, prints the corresponding statements.</li>
<li><kbd>double_number_map</kbd>: This function takes in the <kbd>str</kbd> input and returns <span><kbd>Result&lt;i32, ParseIntError&gt;</kbd></span>. <span>It parses the string to a value, and if it is a valid integer, we use the <kbd>map</kbd> function to multiply the input value by 2; else, we have the <kbd>Err</kbd> case.</span></li>
<li><kbd>double_number</kbd>: This f<span>unction takes in the</span> <kbd>str</kbd> <span>input and returns</span> <span><kbd>Result&lt;i32, ParseIntError&gt;</kbd></span>, <span><span>where it has a <kbd>match</kbd> statement where it parses the string to a value. If it is a valid integer, it satisfies the <kbd>Ok</kbd> case and the value is multiplied by two if an <kbd>Err</kbd> case occurs.</span></span></li>
<li><kbd>print</kbd>: This function takes in <span><kbd>Result&lt;i32, ParseIntError&gt;</kbd>; using the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p>In the <kbd>main</kbd> function, we had two variables, namely <kbd>twenty</kbd> and <kbd>tt</kbd>, assigned to <kbd><span>double_number("</span>10")</kbd> and <kbd>double_number_map("t")</kbd>, respectively. When we called <kbd>double_number function</kbd> for <kbd>twenty</kbd>, it returned an integer value, but <span><kbd>double_number_map</kbd> returned an error for <kbd>t</kbd>. The print statement printed the final value of these <kbd>Result</kbd> type variables.</span> In the case of passing a string to the<kbd>double_number</kbd> method that can't be parsed to integer will result in the <kbd>ParseIntError</kbd> and a valid integer argument of string type will result in double its value for <kbd>double_number_map</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing aliases</h1>
                </header>
            
            <article>
                
<p>We use aliases in order to reuse a specific type multiple times. Rust allows us to create aliases of the <kbd>Result</kbd> type and more types in order to reuse them across the program. At the module level, this is really helpful as we can identify similar kinds of bugs and errors from the units/items of the module.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_aliases_result.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing aliases <br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard library:</li>
</ol>
<pre><strong>        use</strong> <strong>std::num::ParseIntError;</strong>
</pre>
<ol start="4">
<li>Define a generic alias named <kbd>AliasedResult&lt;T&gt;</kbd> for the <kbd>Result</kbd> type:</li>
</ol>
<pre>        type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;
</pre>
<ol start="5">
<li>Create a function named <kbd>double_number</kbd> that will accept the <kbd>str</kbd> input and return an <kbd>AliasedResult&lt;i32&gt;</kbd> type:</li>
</ol>
<pre>        fn double_number(number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {<br/>         number_str.parse::&lt;i32&gt;().map(|n| 2 * n)<br/>        }
</pre>
<ol start="6">
<li>Create a function named <kbd>print</kbd> that will accept an <kbd>AliasedResult&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: AliasedResult&lt;i32&gt;) {<br/>         match result {<br/>         Ok(n) =&gt; println!("n is {}", n),<br/>         Err(e) =&gt; println!("Error: {}", e),<br/>         }<br/>        }
</pre>
<ol start="7">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>         print(double_number("10"));<br/>         print(double_number("t"));<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="60" width="685" src="images/130a1552-7c90-42b0-af61-7d5ba2759561.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Aliases work in a fairly simple manner. Its main role is to ease the usage of a particular type and maintain different types across different modules.</p>
<p>In this recipe, we used the <kbd>type</kbd> keyword to create an alias for <kbd>Result&lt;T, ParseIntError&gt;</kbd> as <kbd>AliasedResult&lt;T&gt;</kbd>; we used this as the type of all the units of the code.</p>
<p>Let's go through the different functional units of the code:</p>
<ul>
<li><kbd>double_number</kbd>: This <span>function takes in the</span> <kbd>str</kbd> <span>input and returns <kbd>AliasedResult&lt;T&gt;</kbd></span>. I<span>t parses the string to a value, and if it is a valid integer, we use the <kbd>map</kbd> function to multiply the input value by 2; else, we have the <kbd>Err</kbd> case.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>AliasedResult&lt;T&gt;</span></kbd>, <span>and using the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p>In the <kbd>main</kbd> function, we called <kbd>print(double_number("10"))</kbd>, which printed the <kbd>Ok</kbd> case statements due to valid input, but <kbd>print(double_number("t"))</kbd> pushed back an error due to invalid input.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling multiple errors</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we saw and developed error-handling units, where Results interacted with other Results and Options interacted with other Options. However, we have cases where we need interaction between the <kbd>Option</kbd> type and <kbd>Result</kbd> or between <kbd>Result&lt;T, Error_1&gt;</kbd> type, and <kbd>Result&lt;T, Error_2&gt;</kbd>. In this recipe, you will learn how to build units to manage different error types and have them interact with each other; we will use our knowledge of combinators to achieve this.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_multiple_err.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Handling multiple errors<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Define a generic alias named <kbd>Result&lt;T&gt;</kbd> for the <kbd>std::result::Result&lt;T, String&gt;</kbd> type:</li>
</ol>
<pre>        type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;
</pre>
<ol start="4">
<li>Create a function named <kbd>double_first</kbd> that will accept the <kbd>Vec</kbd> input and return a <kbd>Result&lt;i32&gt;</kbd> type:</li>
</ol>
<pre>        fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {<br/>          vec.first()<br/>          .ok_or("Please use a vector with at least one<br/>          element.".to_owned())<br/>          .and_then(|s| s.parse::&lt;i32&gt;()<br/>          .map_err(|e| e.to_string())<br/>          .map(|i| 2 * i))<br/>        }
</pre>
<ol start="5">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32&gt;) {<br/>          match result {<br/>            Ok(n) =&gt; println!("The first doubled is {}", n),<br/>            Err(e) =&gt; println!("Error: {}", e),<br/>          }<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>          let empty = vec![];<br/>          let strings = vec!["tofu", "93", "18"];<br/><br/>          print(double_first(empty));<br/>          print(double_first(strings));<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="60" width="627" src="images/186e200c-d8f9-4575-b7d1-27948c0198a4.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we handled cases where we had similar types, such as Results and Options interacting with other Results and Options. In this recipe, we handled cross types, for example, the interaction of Options with Results. We used our previous experience in relation to combinators to implement this.</p>
<p>First, we created an alias for <kbd>std::result::Result&lt;T&gt;, String&gt;</kbd> using the <kbd>type</kbd> keyword as <kbd>Result&lt;T&gt;</kbd>, which we will use across the functional units of the code.</p>
<p>Let's check out the working of all the functional units:</p>
<ul>
<li><kbd>double_first</kbd>: This f<span>unction takes in the <kbd>vec</kbd></span> <span>input and returns <kbd>Result&lt;T&gt;</kbd></span><span>. In our case, it took the first value of the vector sent to it using the <kbd>vec.first</kbd> method. If no values are provided, then it would enter <kbd>ok_or</kbd>, where it would print the statement asking the user to input at least one value to the vector. Next, it checks whether we are able to parse the string value to a valid integer value. If this is successful, it allows us to use the map function to double it by multiplying the parsed integer by 2; else, it takes the error value and maps it to the string equivalent.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>Result&lt;T&gt;</span></kbd>, <span>and using the <kbd>match</kbd> statement, it checks whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p>In the <kbd>main</kbd> function, we had vectors. Out of these, one was <kbd>empty</kbd>--there were no values in the vector--and the other was <kbd>string</kbd>, where we only had string values. When we call the <kbd>double_first</kbd> function with these input values, we get the corresponding errors.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing early returns</h1>
                </header>
            
            <article>
                
<p><span>Another way of dealing with different errors is using the combination of both <kbd>match</kbd> and early <kbd>return</kbd> statements. This is where we explicitly handle errors by returning them, and we do so without stopping the execution, as in the case of panic and so on.<br/></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_early_ret.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing early returns<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Define a generic alias named <kbd>Result&lt;T&gt;</kbd> for the <kbd>std::result::Result&lt;T, String&gt;</kbd> type:</li>
</ol>
<pre>        type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;
</pre>
<ol start="4">
<li>Create a function named <kbd>double_first</kbd> that will accept the <kbd>Vec</kbd> input and return a <kbd>Result&lt;i32&gt;</kbd> type:</li>
</ol>
<pre>        fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {<br/>          let first = match vec.first() {<br/>            Some(first) =&gt; first,<br/>            None =&gt; return Err("Please use a vector with at<br/>            least<br/>            one element.".to_owned())<br/>          };<br/><br/>          match first.parse::&lt;i32&gt;() {<br/>            Ok(i) =&gt; Ok(2 * i),<br/>            Err(e) =&gt; Err(e.to_string()),<br/>          }<br/>        }
</pre>
<ol start="5">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32&gt;) {<br/>          match result {<br/>            Ok(n) =&gt; println!("The first doubled is {}", n),<br/>            Err(e) =&gt; println!("Error: {}", e),<br/>          }<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>          let empty = vec![];<br/>          let strings = vec!["tofu", "93", "18"];<br/><br/>          print(double_first(empty));<br/>          print(double_first(strings));<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="63" width="636" src="images/f90ef85f-3ba8-4695-b218-9e8c41e99f99.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we explicitly handled errors using combinators. Rust also provides us with another way to deal with these cases, where we use a combination of <kbd>match</kbd> statements and early returns. The early returns is a way by which we can catch errors at an early stage of the function process and return back to the user of the application or library.</p>
<p><span>First, we created an alias for</span> <kbd>std::result::Result&lt;T, String&gt;</kbd> <span>using the <kbd>type</kbd> keyword as</span> <kbd>Result&lt;T&gt;</kbd>, <span>which we will use across the functional units of the code.</span></p>
<p><span>Let's check out the working of all the functional units:</span></p>
<ul>
<li><kbd>double_first</kbd>: This f<span>unction takes in the <kbd>vec</kbd></span> <span>input and returns <kbd>Result&lt;T&gt;</kbd></span><span>. In our case, we used the early</span> <kbd>return Err</kbd> <span>to handle errors. We declared a variable named <kbd>first</kbd>, which held onto the first value of the vector that was passed. On this <kbd>first</kbd> variable, we performed <kbd>match</kbd> statements. If the value you get is <kbd>None</kbd>, use <kbd>return Err</kbd> to implement an early return to pass the error. In case you have string values in the vector element, use the <kbd>Err</kbd> value of the aliased type to raise the error.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>Result&lt;T&gt;</span></kbd>, <span>and using the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p><span>In the <kbd>main</kbd> function, we had vectors in which one was</span> <kbd>empty</kbd><span>, where there were no values in the vector. The other was</span> <kbd>string</kbd><span>, where we had only string values when we called the</span> <kbd>double_first</kbd> <span>function. With this input, we get the corresponding errors.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the try! macro</h1>
                </header>
            
            <article>
                
<p><span>We have reached a state where we can now avoid panicking, but explicitly handling all our errors is still a very difficult task. In this recipe, we'll use <kbd>try!</kbd> for cases where we simply need to unwrap without having to panic.<br/></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_try.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing try!<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Define a generic alias <kbd>Result&lt;T&gt;</kbd> for the <kbd>std::result::Result&lt;T, String&gt;</kbd> type:</li>
</ol>
<pre>        type Result&lt;T&gt; = std::result::Result&lt;T, String&gt;;
</pre>
<ol start="4">
<li>Create a function named <kbd>double_first</kbd> that will accept the <kbd>Vec</kbd> input and return a <kbd>Result&lt;i32&gt;</kbd> type:</li>
</ol>
<pre>        fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {<br/>          let first = try!(vec.first()<br/>          .ok_or("Please use a vector with at least one               <br/>          element.".to_owned()));<br/><br/>          let value = try!(first.parse::&lt;i32&gt;()<br/>          .map_err(|e| e.to_string()));<br/><br/>          Ok(2 * value)<br/>        }
</pre>
<ol start="5">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32&gt;) {<br/>         match result {<br/>         Ok(n) =&gt; println!("The first doubled is {}", n),<br/>         Err(e) =&gt; println!("Error: {}", e),<br/>         }<br/>        }
</pre>
<ol start="6">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>         let empty = vec![];<br/>         let strings = vec!["tofu", "93", "18"];<br/><br/>         print(double_first(empty));<br/>         print(double_first(strings));<br/>        }
</pre>
<p class="mce-root">You will get the following output upon successful execution of the code:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="57" width="556" src="images/8b22d6d0-93f4-4cae-b6c7-3ad2082b2ddf.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>try!</kbd> macro enables us to simply unwrap without using panic. In the previous recipes, we used the unwrap and nested functionality many times to get the desired value. And <kbd>try!</kbd> is equivalent to an <kbd>unwrap</kbd> function that is returned instead of panic <span>in the case of an error</span>. In this recipe, you will learn how to use <kbd>try!</kbd> along with combinators.</p>
<p><span>First, we created an alias for</span> <kbd>std::result::Result&lt;T, String&gt;</kbd> <span>using the <kbd>type</kbd> keyword as</span> <kbd>Result&lt;T&gt;</kbd>, <span>which we will use across the functional units of the code.</span></p>
<p><span>Let's check out the working of all the functional units:</span></p>
<ul>
<li><kbd>double_first</kbd>: This f<span>unction takes in the <kbd>vec</kbd></span> <span>type input and returns a<kbd>Result&lt;T&gt;</kbd></span> type. <span>We declare a variable named <kbd>first</kbd> and assign it to <kbd>try!</kbd> macro statements for different cases. First, we check whether the first element of the vector is empty using <kbd>vec.first()</kbd>, which fetches the first value of the vector, if it's empty, we print a statement using the <kbd>ok_or</kbd> method and in the other <kbd>try!</kbd> we parse the <kbd>first</kbd> variable to an interger type. In case there is an error, we convert the error into a string using the <kbd>map_err</kbd> method.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>Result&lt;T&gt;</span></kbd>. U<span>sing the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p><span>In the main function, we had vectors in which one was</span> <kbd>empty</kbd>, <span>where there were no values in the vector. The other was</span> <kbd>string</kbd>, <span>where we only had string values. When we call the</span> <kbd>double_first</kbd> <span><span>function with these input values, we get the corresponding errors.</span></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining your own error types</h1>
                </header>
            
            <article>
                
<p><span><span>Rust allows us to define our own error types using custom Rust datatypes like <kbd>enum</kbd> and <kbd>struct</kbd>. We will create customized error-handling cases where we will able to define our own error types and have a definition for implementing or doing something to handle those error cases.<br/></span></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_error.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Defining your own error type<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard crates and create a generic alias type <kbd>Result&lt;T&gt;</kbd> for the <kbd>std::result::Result&lt;T, CustomError&gt;</kbd> type:</li>
</ol>
<pre>        use std::num::ParseIntError;<br/>        use std::fmt;<br/><br/>        type Result&lt;T&gt; = std::result::Result&lt;T, CustomError&gt;;
</pre>
<ol start="4">
<li>Create an <kbd>enum</kbd> type <kbd>CustomError</kbd>, which is our user-defined error type:</li>
</ol>
<pre>        #[derive(Debug)]<br/>        enum CustomError {<br/>         EmptyVec,<br/>         Parse(ParseIntError),<br/>        }
</pre>
<ol start="5">
<li>Implement a customized way to display the error of the <kbd>CustomError</kbd> type:</li>
</ol>
<pre>        impl fmt::Display for CustomError {<br/>         fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>         match *self {<br/>         CustomError::EmptyVec =&gt;<br/>         write!(f, "please use a vector with at least one<br/>         element"),<br/>         // This is a wrapper, so defer to the underlying<br/>         types' implementation of `fmt`.<br/>         CustomError::Parse(ref e) =&gt; e.fmt(f),<br/>         }<br/>         }<br/>        }
</pre>
<ol start="6">
<li>Crea<span>te a function named</span> <kbd>double_first</kbd> <span>that will accept the</span> <kbd>Vec</kbd> <span>input and return a</span> <kbd>Result&lt;i32&gt;</kbd> <span>type:</span></li>
</ol>
<pre>        fn double_val(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {<br/>          vec.first()<br/>          // Change the error to our new type.<br/>         .ok_or(CustomError::EmptyVec)<br/>         .and_then(|s| s.parse::&lt;i32&gt;()<br/>         // Update to the new error type here also.<br/>         .map_err(CustomError::Parse)<br/>         .map(|i| 2 * i))<br/>       }
</pre>
<ol start="7">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32&gt;) {<br/>         match result {<br/>         Ok(n) =&gt; println!("The first doubled is {}", n),<br/>         Err(e) =&gt; println!("Error: {}", e),<br/>         }<br/>        }
</pre>
<ol start="8">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>         let numbers = vec!["93", "18"];<br/>         let empty = vec![];<br/>         let strings = vec!["tofu", "93", "18"];<br/><br/>         print(double_val(numbers));<br/>         print(double_val(empty));<br/>         print(double_val(strings));<br/>        }
</pre>
<p>You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="78" width="616" src="images/d5cb2219-4113-44cb-8056-a85c6f633d35.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In general, we would define a good error type as something that would do the following things for the developer so that it's easy for them to understand where exactly the code is breaking at runtime:</p>
<ul>
<li>Represent the different errors in the code with the same type</li>
<li>Display proper error functions to the user so it is easy for the developer to classify between different errors</li>
<li>Hold proper information about the error</li>
</ul>
<p>In this recipe, we created our own customized <kbd>enum</kbd> error type named <kbd>CustomError</kbd>. It had two types of data: <kbd>EmptyVec</kbd> and <kbd>Parse(ParseIntError)</kbd>. For each of these errors, we had customized implementation of error handling, where we produced customized error display messages for different errors so that our error type <kbd>CustomError</kbd> could follow all the preceding properties of a good error type. In the case of <kbd>EmptyVec</kbd>, we did not pass or need extra information about the error, but in the case of <kbd>Parse(ParseIntError)</kbd>, we had to supply the information required to parse the error implementation for its error.</p>
<p>Let's see how to implement custom display functions for different errors. In this case, we used the <kbd>impl</kbd> keyword to create a customized <kbd>fmt::Display</kbd> for our error type <kbd>CustomError</kbd>, where <kbd>fmt</kbd> represented the standard library. For the <kbd>fmt</kbd> method that takes in <kbd>&amp;self, f: &amp;mut fmt::Formatter</kbd> and returns the standard <kbd>fmt::Result</kbd>, we used the <kbd>match</kbd> statement to identify the type of error and display the corresponding error messages. In the case of <kbd>CustomError::EmptyVec</kbd>, we printed this error message: <kbd>please use a vector with at least one element.</kbd> In the case of <kbd>CustomError::Parse</kbd>, we formatted and printed the extra information of the type.</p>
<p><span>Let's check out the working of all the functional units:</span></p>
<ul>
<li><kbd>double_first</kbd>: This f<span>unction takes in the <kbd>vec</kbd></span> <span>input and returns <kbd>Result&lt;i32&gt;</kbd></span><span>. It takes the first value of the vector sent to it using the <kbd>vec.first</kbd> method. If no values are provided, then it enters <kbd>ok_or</kbd></span>, <span>where it changes the error type to <kbd>CustomError::EmptyVec</kbd></span>. <span>Next, it checks whether we are able to parse the string value to a valid integer value. If this is successful, we use the <kbd>map</kbd> function to double it by multiplying the parsed integer by <kbd>2</kbd>; else, it takes the error value and maps it to the other <kbd>CustomError::Parse</kbd> type.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>Result&lt;i32&gt;</span></kbd>. U<span>sing the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case for printing the corresponding statement.</span></li>
</ul>
<p><span>In the <kbd>main</kbd> function, we had vectors. One of them was a number, where we had the correct input type for producing the output without any errors. The next one was</span> <kbd>empty</kbd>, <span>where there were no values in the vector. Then, there was</span> <kbd>strings</kbd><span>, where we had the first value as a string of character values that couldn't be parsed to an integer. When we call the</span> <kbd>double_first</kbd> <span>function with these input values, we get the corresponding errors.<br/></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the boxing of errors</h1>
                </header>
            
            <article>
                
<p><span>Rust allows us to b</span>ox <span>our error types, which is the process of creating wrapper error types around standard library error types. Boxing of errors is a common practice where developers bring together all the error types of the different libraries and use them to build the project.<br/></span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will require the Rust compiler and any text editor for developing the Rust code snippet.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to get through this recipe:</p>
<ol>
<li>Create a file named <kbd>sample_box.rs</kbd> and open it in your text editor.</li>
<li>Write the code header with the relevant information:</li>
</ol>
<pre>        //-- #########################<br/>        //-- Task: Implementing Boxing<br/>        //-- Author: Vigneshwer.D<br/>        //-- Version: 1.0.0<br/>        //-- Date: 26 March 17<br/>        //-- #########################
</pre>
<ol start="3">
<li>Call the standard crates and create a generic alias type, namely <kbd>Result&lt;T&gt;</kbd>, for the <kbd>std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;</kbd> type:</li>
</ol>
<pre>        use std::error;<br/>        use std::fmt;<br/>        use std::num::ParseIntError;<br/><br/>        type Result&lt;T&gt; = std::result::Result&lt;T,         Box&lt;error::Error&gt;&gt;;
</pre>
<ol start="4">
<li>Create an <kbd>enum</kbd> type <kbd>CustomError</kbd>, which would be our user-defined error type:</li>
</ol>
<pre>        #[derive(Debug)]<br/>        enum CustomError {<br/>         EmptyVec,<br/>         Parse(ParseIntError),<br/>        }
</pre>
<ol start="5">
<li>Convert the standard library error type into a custom type:</li>
</ol>
<pre>        impl From&lt;ParseIntError&gt; for CustomError {<br/>         fn from(err: ParseIntError) -&gt; CustomError {<br/>         CustomError::Parse(err)<br/>         }<br/>        }
</pre>
<ol start="6">
<li>Implement a customized way to display an error for the <kbd>CustomError</kbd> type:</li>
</ol>
<pre>        impl fmt::Display for CustomError {<br/>         fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>         match *self {<br/>         CustomError::EmptyVec =&gt;<br/>         write!(f, "please use a vector with at least one element"),<br/>         CustomError::Parse(ref e) =&gt; e.fmt(f),<br/>         }<br/>         }<br/>        }
</pre>
<ol start="7">
<li>Implement the <kbd>error</kbd> trait for the <span><kbd>CustomError</kbd> type</span>:</li>
</ol>
<pre>        impl error::Error for CustomError {<br/>         fn description(&amp;self) -&gt; &amp;str {<br/>         match *self {<br/>         CustomError::EmptyVec =&gt; "empty vectors not allowed",<br/>         CustomError::Parse(ref e) =&gt; e.description(),<br/>         }<br/>         }<br/><br/>         fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {<br/>         match *self {<br/>         CustomError::EmptyVec =&gt; None,<br/>         CustomError::Parse(ref e) =&gt; Some(e),<br/>         }<br/>         }<br/>        }
</pre>
<ol start="8">
<li>Create a <span>function named</span> <kbd>double_first</kbd> <span>that will accept the</span> <kbd>Vec</kbd> <span>input and return a</span> <kbd>Result&lt;i32&gt;</kbd> <span>type:</span></li>
</ol>
<pre>        fn double_val(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {<br/>          let first = try!(vec.first().ok_or(CustomError::EmptyVec));<br/>          let parsed = try!(first.parse::&lt;i32&gt;());<br/>          <br/>          Ok(2 * parsed)<br/>        }
</pre>
<ol start="9">
<li>Create a function named <kbd>print</kbd> that will accept a <kbd>Result&lt;i32&gt;</kbd> type as input:</li>
</ol>
<pre>        fn print(result: Result&lt;i32&gt;) {<br/>         match result {<br/>         Ok(n) =&gt; println!("The first doubled is {}", n),<br/>         Err(e) =&gt; println!("Error: {}", e),<br/>         }<br/>        }
</pre>
<ol start="10">
<li>Define the <kbd>main</kbd> function and call the different functions:</li>
</ol>
<pre>        fn main() {<br/>         let numbers = vec!["93", "18"];<br/>         let empty = vec![];<br/>         let strings = vec!["tofu", "93", "18"];<br/><br/>         print(double_val(numbers));<br/>         print(double_val(empty));<br/>         print(double_val(strings));<br/>        }
</pre>
<p class="CDPAlignLeft CDPAlign">You will get the following output upon successful execution of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="64" width="524" src="images/15eb889d-c9a2-4605-9052-6a94b7751c28.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>std</kbd> library automatically converts any type that implements the <kbd>Error</kbd> trait into the trait object <kbd>Box&lt;Error&gt;</kbd> via the <kbd>From</kbd> trait object. However, a user may use many external libraries, and different libraries provide their own error types. In order to define a valid <kbd>Result&lt;T, E&gt;</kbd> type, perform the following tasks:</p>
<ul>
<li><span>Define a new wrapper error type around the library's standard error types</span></li>
<li><span>Convert the error types into String or any other type that is convenient to handle</span></li>
<li><span>Box the error types into the <kbd>Box&lt;Error&gt;</kbd> type</span></li>
</ul>
<p><span>In this recipe, we started off by calling the standard libraries <kbd>std::error</kbd>,</span> <span><kbd>std::fmt</kbd>, and <kbd>std::num::ParseIntError</kbd>. We then created an alias <kbd>Result&lt;T&gt;</kbd> for <kbd>std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;</kbd>. Next, we created our own customized <kbd>enum</kbd> error type named <kbd>CustomError</kbd>, which had two types of data: <kbd>EmptyVec</kbd> and <kbd>Parse(ParseIntError)</kbd>.</span></p>
<div class="packt_infobox">The compiler is capable of providing basic implementations for some traits via the <kbd>#[derive]</kbd> attribute, where an attribute is a metadata applied to some module, crate, or item. We use the <kbd>#[derive(Debug)]</kbd> for getting an output format that is programmer-facing and has more debugging context.</div>
<p>We converted the standard library's <kbd>ParseIntError</kbd> error into the custom error type <kbd>CustomError</kbd> by implementing the <kbd>From</kbd> trait. We did this because the <kbd>from</kbd> method takes in the standard error type <kbd>ParseIntError</kbd> as <kbd>err</kbd> and returns the <kbd>CustomError</kbd> type by setting <kbd>CustomError::Parse(err)</kbd>.</p>
<p>Now let's see how we implemented custom display functions for the different errors. We used the <kbd>impl</kbd> keyword to create a customized <kbd>fmt::Display</kbd> for our <kbd>CustomError</kbd> error type<span>, where <kbd>fmt</kbd> represented the standard library. The <kbd>fmt</kbd> method takes in <kbd>&amp;self, f: &amp;mut fmt::Formatter</kbd> and returns the standard <kbd>fmt::Result</kbd>. We used the <kbd>match</kbd> statement to identify what type of error it was and display the corresponding error messages. In the case of <kbd>CustomError::EmptyVec</kbd>, we printed this error message: <kbd>please use a vector with at least one element.</kbd> In the case of <kbd>CustomError::Parse</kbd></span>, <span>we formatted and printed the extra information of the type.</span></p>
<p><span>To implement <kbd>Box&lt;Error&gt;</kbd>, we had to implement the Error trait where we had two methods: <kbd>description</kbd> and <kbd>cause</kbd></span>. <span>These methods take the value of the trait and return them. In the <kbd>description</kbd> method, using the <kbd>match</kbd> statement, we assigned a description about the error types; here we matched <kbd>CustomError::EmptyVec</kbd> to <kbd>empty vectors not allowed</kbd> and</span> <span><kbd>CustomError::Parse(ref e)</kbd> to <kbd>e.description()</kbd>. Similarly, in the case of <kbd>cause</kbd></span>, <span>we had sample values that led to the error, and we matched <kbd>CustomError::EmptyVec</kbd> to <kbd>None</kbd> and <kbd>CustomError::Parse(ref e)</kbd> to <kbd>Some(e)</kbd>.</span></p>
<p><span>Let's check out the working of all the functional units:</span></p>
<ul>
<li><kbd>double_first</kbd>: This f<span>unction takes in the <kbd>vec</kbd></span> <span>input and returns <kbd>Result&lt;i32&gt;</kbd></span><span>. In our case, it took the first value of the vector sent to it using the <kbd>vec.first</kbd> method with the</span> <kbd>try!</kbd> <span>macro and assigned it to the <kbd>first</kbd> variable. If no values are provided, then it would enter <kbd>ok_or</kbd></span>, <span>where it changes the error type to <kbd>CustomError::EmptyVec</kbd></span>. <span>Next, we checked whether we were able to parse the string value to a valid integer value by <kbd>first.parse::&lt;i32&gt;()</kbd></span>, <span>using the</span> <span><kbd>try!</kbd> macro and assigning it to the <kbd>parsed</kbd> variable. If this is successful, we double it by multiplying the parsed integer by <kbd>2</kbd>. In the</span> <span><kbd>Ok</kbd> data type, it returns the <kbd>enum</kbd> type <kbd>Result&lt;i32&gt;</kbd>; else, it takes the</span> error value parsed by the error type<span>.</span></li>
<li><kbd>print</kbd>: This function takes in <kbd><span>Result&lt;i32&gt;</span></kbd>. U<span>sing the <kbd>match</kbd> statement, we check whether we have an <kbd>Ok</kbd> or <kbd>Err</kbd> case to print the corresponding statement.</span></li>
</ul>
<p>In the <kbd>main</kbd> function, we had vectors. Among these, one was a number, where we had the correct input type for producing the output without any errors. The next one was <kbd>empty</kbd>, <span>meaning there were no values in the vector. The other one was</span> <kbd>strings</kbd>, <span>where we had the first value of a string of character values that couldn't be parsed into an integer. When we call the</span> <kbd>double_first</kbd> <span>function with these input values, we get the corresponding errors.</span></p>


            </article>

            
        </section>
    </div>
</body>
</html>