<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Data Structures</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Creating lazy static objects</li>
<li>Working with bit fields</li>
<li>Providing custom derives</li>
<li>Converting types into each other</li>
<li>Boxing data</li>
<li>Sharing ownership with smart pointers</li>
<li>Working with interior mutability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p class="mce-root">So far, we have primarily looked at techniques that were all useful in their own right. Of course, we are continuing that trend, but the recipes shown in this chapter truly shine when combined with other code. You can imagine them as the <em>glue</em> holding a nice Rust program together, as they are primarily oriented toward new enabling ways in which different components of your crate can work together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating lazy static objects</h1>
                
            
            
                
<p>Big objects, especially constant ones, should be reused instead of rebuilt. The <kbd>lazy_static!</kbd> macro helps you with this by extending Rust's normal <kbd>static</kbd> functionality, which normally requires your objects to be constructable at compile-time, with the ability to create lazy objects that are initialized during runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a Rust project to work on during this chapter with <kbd>cargo new chapter_five</kbd>.</li>
<li>Navigate into the newly created <kbd>chapter_five</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory.</li>
<li>Inside the <kbd>src</kbd> folder, create a new folder called <kbd>bin</kbd>.</li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library.</li>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following lines:</li>
</ol>
<pre style="padding-left: 60px">lazy_static = "1.0"<br/>regex = "0.2"</pre>
<p style="padding-left: 60px">If you want, you can go to the crates.io web pages for <kbd>lazy_static</kbd> (<a href="https://crates.io/crates/lazy_static">https://crates.io/crates/lazy_static</a>) and regex (<a href="https://crates.io/crates/regex">https://crates.io/crates/regex</a>) to check for the newest version and use that one instead.</p>
<ol start="7">
<li>In the <kbd>src/bin</kbd> folder, create a file called <kbd>lazy_static.rs</kbd></li>
<li>Add the following code and run it with <kbd>cargo run --bin lazy_static</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1    #[macro_use] <br/>2    extern crate lazy_static;<br/>3    extern crate regex;<br/>4 <br/>5    use regex::Regex;<br/>6    use std::collections::HashMap;<br/>7    use std::sync::RwLock;<br/>8 <br/>9    // Global immutable static<br/>10   lazy_static! {<br/>11     static ref CURRENCIES: HashMap&lt;&amp;'static str, &amp;'static str&gt; = <br/>       {<br/>12       let mut m = HashMap::new();<br/>13       m.insert("EUR", "Euro");<br/>14       m.insert("USD", "U.S. Dollar");<br/>15       m.insert("CHF", "Swiss Francs");<br/>16       m<br/>17     };<br/>18   }<br/>19 <br/>20   // Global mutable static<br/>21   lazy_static! {<br/>22     static ref CLIENTS: RwLock&lt;Vec&lt;String&gt;&gt; = <br/>       RwLock::new(Vec::new());<br/>23   }<br/>24 <br/>25   // Local static<br/>26   fn extract_day(date: &amp;str) -&gt; Option&lt;&amp;str&gt; {<br/>27     // lazy static objects are perfect for<br/>28     // compiling regexes only once<br/>29     lazy_static! {<br/>30       static ref RE: Regex =<br/>31       Regex::new(r"(\d{2}).(\d{2}).(\d{4})")<br/>32         .expect("Failed to create regex");<br/>33     }<br/>34     RE.captures(date)<br/>35       .and_then(|cap| cap.get(1).map(|day| day.as_str()))<br/>36   }<br/>37 <br/>38   fn main() {<br/>39     // The first access to CURRENCIES initializes it<br/>40     let usd = CURRENCIES.get("USD");<br/>41     if let Some(usd) = usd {<br/>42       println!("USD stands for {}", usd);<br/>43     }<br/>44 <br/>45     // All accesses will now refer to the same,<br/>46     // already constructed object<br/>47     if let Some(chf) = CURRENCIES.get("CHF") {<br/>48       println!("CHF stands for {}", chf);<br/>49     }<br/>50 <br/>51     // Mutable the global static<br/>52     CLIENTS<br/>53       .write()<br/>54       .expect("Failed to unlock clients for writing")<br/>55       .push("192.168.0.1".to_string());<br/>56 <br/>57     // Get an immutable reference to the global static<br/>58     let clients = CLIENTS<br/>59       .read()<br/>60       .expect("Failed to unlock clients for reading");<br/>61     let first_client = clients.get(0).expect("CLIENTS is<br/>       empty");<br/>62     println!("The first client is: {}", first_client);<br/>63 <br/>64     let date = "12.01.2018";<br/>65     // The static object is nicely hidden inside<br/>66     // the definition of extract_day()<br/>67     if let Some(day) = extract_day(date) {<br/>68       println!("The date \"{}\" contains the day \"{}\"", date, <br/>         day);<br/>69     }<br/>70   }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">By invoking the <kbd>lazy_static!</kbd> macro [10, 21 and 29], we define a lazily initialized object in the current scope. <em>Lazy</em> here means <em>created only the first time it is used</em>.</p>
<p class="mce-root">Contrary to a <kbd>let</kbd> binding, its scope can also be the global scope [10]. A realistic example for this is creating a collection with a known content that is used by many functions, as the alternative would be to create it once and pass it around endlessly.</p>
<p>If your <kbd>lazy_static</kbd> consists of a <kbd>Vec</kbd> with content that is known at compile time, you can instead use a <kbd>const</kbd> array, as its construction is constant. In terms of code, this means you don't need to use this:<br/>
<pre>lazy_static!{<br/>    static ref FOO: Vec&lt;&amp;'static str&gt; = vec!["a", "b", "c"];<br/>}</pre>
Instead, you can use the following:
<pre>const FOO: [&amp;str; 3] = ["a", "b", "c"];</pre></p>
<p>Remember when, in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; <em>Querying with Regexes</em>, we talked about how compiling Regexes is expensive and should be avoided? <kbd>lazy_static!</kbd> is ideal for this. In fact, the pattern of creating a local <kbd>static</kbd> regex in a function is so widespread that we included it in this example [29]:</p>
<pre style="padding-left: 30px">fn extract_day(date: &amp;str) -&gt; Option&lt;&amp;str&gt; {<br/>    lazy_static! {<br/>        static ref RE: Regex =<br/>            Regex::new(r"(\d{2}).(\d{2}).(\d{4})")<br/>            .expect("Failed to create regex");<br/>    }<br/>    RE.captures(date)<br/>        .and_then(|cap| cap.get(1).map(|day| day.as_str()))<br/>}</pre>
<p>Lastly, you can also create a global mutable state with <kbd>lazy_static</kbd> objects [21]. As mentioned in earlier chapters, the excessive state is the root of many evils in software development and should be treated with care. There are very few cases where having such an object is justifiable, as it is almost always better to pass the object around. There are exceptions, however. Sometimes a program revolves around the manipulation of one specific dataset in memory and all involved actors want to access it. In these cases, it can be very cumbersome to pass an object to literally every function in your code. One possible, but still very rare, an example where this might happen, is when dealing exclusively with a list of active connections [21]:</p>
<pre style="padding-left: 30px">lazy_static! {<br/>    static ref CLIENTS: RwLock&lt;Vec&lt;String&gt;&gt; = RwLock::new(Vec::new());<br/>}</pre>
<p>Note that, as the borrow checker is disabled for objects with <kbd>'static</kbd> lifetimes (see the following <em>There's more...</em> section), we need to wrap our <kbd>static</kbd> in a parallel lock, such as <kbd>RwLock</kbd> or <kbd>Mutex</kbd>, to guarantee thread safety. You can read more about that in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em>; <em>Access resources in parallel with RwLocks</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p class="mce-root">People coming from other languages might wonder what <kbd>lazy_static</kbd> offers that can't already be done by a normal <kbd>static</kbd> object. The difference between them is as follows.</p>
<p>In Rust, a <kbd>static</kbd> variable is a variable that lives for the entire duration of the program, which is why they get their own, special lifetime, <kbd>'static</kbd>. The catch is that the variable has to be built in a constant way, that is, a way that is known at compile time. In our example, we cannot replace <kbd>CURRENCIES</kbd> [11] with a normal <kbd>static</kbd> because <kbd>HashMap::new()</kbd> returns a newly constructed <kbd>HashMap</kbd> sitting somewhere in the memory during runtime. As this requires it to live in memory, it's impossible to build a <kbd>HashMap</kbd> during compile time, so its constructor is not <kbd>constant</kbd>.</p>
<p>Another catch with <kbd>static</kbd> variables is that, because they have a global lifetime, the borrow checker cannot make sure that their access is thread-safe. As a consequence, any access on a <kbd>static mut</kbd> variable will always be <kbd>unsafe</kbd>.</p>
<p>The convention for <kbd>static</kbd> variables is to write them in <kbd>ALL_CAPS</kbd>, just like <kbd>const</kbd> variables. This is because they are very closely linked. In fact, a <kbd>const</kbd> is nothing but an inlined <kbd>static</kbd> that can never be <kbd>mut</kbd>.</p>
<p><kbd>lazy_static</kbd> gets around these restrictions by wrapping your object in a newly created <kbd>struct</kbd> that can be implicitly dereferenced into your object. This means that you never actually access your object directly. <kbd>lazy_static</kbd> stresses this by demanding that you write <kbd>ref</kbd> during the declaration of the <kbd>static</kbd>, as this makes you mentally treat the variable as a reference rather than an actual object:</p>
<pre style="padding-left: 30px">lazy_static! {<br/>    static ref foo: Foo = Foo::new();<br/>}</pre>
<p>While dereferencing, the wrapper <kbd>struct</kbd> works with a <kbd>static mut</kbd> pointer in your dynamically created object. All it does then is wrap the <kbd>unsafe</kbd> calls in a safe way.</p>
<p>If you come from a modern C++ background, you can view a normal <kbd>static</kbd> Rust as a <kbd>static constexpr</kbd> C++ and a <kbd>lazy_static</kbd> Rust as a <kbd>static</kbd> C++ local.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Querying with Regexes</em> recipe in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><em>Access resources in parallel with RwLocks</em> recipe in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with bit fields</h1>
                
            
            
                
<p>Programs written in C don't have the possibility to use the Builder Pattern (<a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml" target="_blank">Chapter 1</a>, <em>Learning the Basics</em>; <em>Using the builder pattern</em>) to provide users with combinable options. Instead, they have to rely on bit fields. As C has historically become the <em>lingua franca</em> of system languages, you will have to interact with a lot of C code if you plan on wrapping existing programs in a Rust interface or vice versa. Because of this, you will sooner or later come in contact with bit fields. As Rust's <kbd>enum</kbd> is way more complex than a C <kbd>enum</kbd>, you have to instead rely on the <kbd>bitflags</kbd> crate to provide you with all of the necessary functionality to comfortably handle bit fields.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>This chapter assumes that you know what a bit field is. Explaining it here doesn't make sense, as it would also incorporate an explanation of binary arithmetic and is not that relevant in your day-to-day Rust experience. For a good introduction to bit fields, check out this forum post and tutorial: <a href="http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/">http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/</a> and <a href="https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm">https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm</a>, respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>Under <kbd>[dependencies]</kbd>, add the following lines:</li>
</ol>
<pre style="padding-left: 60px">bitflags = "1.0"</pre>
<ol start="3">
<li>If you want, you can go to bitflags' crates.io page (<a href="https://crates.io/crates/bitflags">https://crates.io/crates/bitflags</a>) to check for the newest version and use that one instead.</li>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>bit_fields.rs</kbd>.</p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin bit_fields</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    #[macro_use]<br/>2    extern crate bitflags;<br/>3 <br/>4    bitflags! {<br/>5      struct Spices: u32 {<br/>6        const SALT    = 0b0000_0001;<br/>7        const PEPPER  = 0b0000_0010;<br/>8        const CHILI   = 0b0000_0100;<br/>9        const SAFFRON = 0b0000_1000;<br/>10       const ALL     = Self::SALT.bits<br/>11                     | Self::PEPPER.bits<br/>12                     | Self::CHILI.bits<br/>13                     | Self::SAFFRON.bits;<br/>14     }<br/>15   }<br/>16 <br/>17   impl Spices {<br/>18     // Implementing a "clear" method can be useful<br/>19     pub fn clear(&amp;mut self) -&gt; &amp;mut Self {<br/>20       self.bits = 0;<br/>21       self<br/>22     }<br/>23   }<br/>24 <br/>25   fn main() {<br/>26     let classic = Spices::SALT | Spices::PEPPER;<br/>27     let spicy = Spices::PEPPER | Spices::CHILI;<br/>28     // Bit fields can nicely be printed<br/>29     println!("Classic: {:?}", classic);<br/>30     println!("Bits: {:08b}", classic.bits());<br/>31     println!("Spicy: {:?}", spicy);<br/>32     println!("Bits: {:08b}", spicy.bits());<br/>33 <br/>34     println!();<br/>35 <br/>36     // Use set operations<br/>37     println!("Union: {:?}", classic | spicy);<br/>38     println!("Intersection: {:?}", classic &amp; spicy);<br/>39     println!("Difference: {:?}", classic - spicy);<br/>40     println!("Complement: {:?}", !classic);<br/>41 <br/>42     // Interact with flags in a bit field<br/>43     let mut custom = classic | spicy;<br/>44     println!("Custom spice mix: {:?}", custom);<br/>45     custom.insert(Spices::SAFFRON);<br/>46     // Note that ALL is now also contained in the bit field<br/>47     println!("Custom spice after adding saffron: {:?}", custom);<br/>48     custom.toggle(Spices::CHILI);<br/>49     println!("Custom spice after toggling chili: {:?}", custom);<br/>50     custom.remove(Spices::SALT);<br/>51     println!("Custom spice after removing salt: {:?}", custom);<br/>52 <br/>53     // This could be user input<br/>54     let wants_salt = true;<br/>55     custom.set(Spices::SALT, wants_salt);<br/>56     if custom.contains(Spices::SALT) {<br/>57       println!("I hope I didn't put too much salt in it");<br/>58     }<br/>59 <br/>60     // Read flags from raw bits<br/>61     let bits = 0b0000_1101;<br/>62     if let Some(from_bits) = Spices::from_bits(bits) {<br/>63       println!("The bits {:08b} represent the flags {:?}", bits,<br/>         from_bits);<br/>64     }<br/>65 <br/>66     custom.clear();<br/>67     println!("Custom spice mix after clearing: {:?}", custom);<br/>68   }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>bitflags!</kbd> macro lets you define all of your flags and their underlying type (in our case, this is <kbd>u32</kbd>)[4 to 15]. They are written in <kbd>ALL_CAPS</kbd> because they are constants. We can also define collections of flags this way, as we did with <kbd>ALL</kbd>[10]. We could have added additional combinations, for example:</p>
<pre style="padding-left: 30px">const SPICY = Self::PEPPER.bits | Self::CHILI.bits;</pre>
<p>The macro then creates a struct with the specified members for you and implements a bunch of traits for it in order to enable the familiar <kbd>|</kbd>, <kbd>&amp;</kbd>, <kbd>-</kbd>, and <kbd>!</kbd> notations [37 to 40] and pretty printing. You can still access the raw <kbd>bits</kbd> used in the background directly over the member of the same name.</p>
<p>Note that, when printing, flag combinations will be listed separately. For instance, look at the output in line [47]. After setting all possible flags in the field to active, it will pretty print itself as the following:</p>
<pre style="padding-left: 30px">Custom spice after adding saffron: SALT | PEPPER | CHILI | SAFFRON | ALL</pre>
<p>A useful method to additionally define on a bit field is <kbd>clear()</kbd>[19]. This hides the underlying <kbd>bits</kbd> from the user and is nicely readable.</p>
<p>With the aforementioned binary operators, you can perform <em>set operations</em> on your bit field [37 to 40]. These are the same operations as the ones you can perform on a <kbd>HashSet</kbd> and are explained with a nice diagram in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections;</em> <em>Using a HashSet</em>.</p>
<p>Working with single flags in the bit field is also very easy. <kbd>insert()</kbd> sets a flag in the field to active [45], <kbd>remove()</kbd> sets it to inactive [50], and <kbd>toggle</kbd> flips it from active to inactive and vice versa [48]. If you don't yet know whether you're going to <kbd>insert</kbd> or <kbd>remove</kbd> a flag, as is the case with unpredictable user input, you can use <kbd>set()</kbd> to explicitly set the activation of a flag to either <kbd>true</kbd> or <kbd>false</kbd> [55].</p>
<p>You can check whether a certain flag is active by calling <kbd>contains()</kbd> [56]. This also works for another bit field or a flag combination. This means that the following is also valid:</p>
<pre>if custom.contains(Spices::SALT | Spices::PEPPER) {<br/>    println!("The custom spice contains both salt and pepper");<br/>}</pre>
<p>Additionally, you can use <kbd>intersects()</kbd> to check whether <em>any</em> flags in two-bit fields match.</p>
<p>Last but not least, you can deserialize raw bytes into your generated bit field struct by calling <kbd>from_bits()</kbd> on it [62]. This will check whether every bit actually corresponds to a flag and return <kbd>None</kbd> otherwise. You can skip the error checking and simply ignore invalid bits with <kbd>from_bits_truncate()</kbd> if you're absolutely 100% sure that the data has to be valid.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Using a HashSet</em> recipe in <a href="977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml" target="_blank">Chapter 2</a>, <em>Working with Collections</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Providing custom derives</h1>
                
            
            
                
<p>You might have looked at <kbd>#[derive(Debug)]</kbd> and assumed it's some weird compiler magic. It is not. It is a so-called <em>procedural macro</em>, that is, a macro that doesn't simply expand at compile time but instead <em>runs</em> at compile time. This way, you can inject code into the actual compilation process. The most useful application for this is creating custom derives, with which you can generate new code based on the analysis of existing code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started</h1>
                
            
            
                
<p>This recipe will operate with an <em>Abstract Syntax Tree</em>, or AST. It is a tree-like representation of a language's elements in relation to each other. In this recipe, we (that is, a cool crate called <kbd>syn</kbd>) will parse our entire program into a single deep <kbd>struct</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>Create a new sub-crate for the custom derive with <kbd>cargo new chapter-five-derive</kbd>.</p>
</li>
<li>Open the newly generated <kbd>chapter-five-derive/Cargo.toml</kbd>.</li>
<li class="mce-root">Add this directly above the <kbd>[dependencies]</kbd> section of the file in order to mark the crate as a procedural macro crate:</li>
</ol>
<pre style="padding-left: 60px">[lib]<br/>proc-macro = true</pre>
<ol start="4">
<li>Under <kbd>[dependencies]</kbd>, add the following lines:</li>
</ol>
<pre style="padding-left: 60px">syn = "0.11.11"<br/>quote = "0.3.15"<br/></pre>
<p style="padding-left: 60px">If you want, you can go to the crates.io web pages for <kbd>syn</kbd> (<a href="https://crates.io/crates/syn">https://crates.io/crates/syn</a>) and <kbd>quote</kbd> (<a href="https://crates.io/crates/quote">https://crates.io/crates/quote</a>) to check for the newest version and use that one instead.</p>
<ol start="5">
<li> In the <kbd>chapter-five-derive/src/lib.rs</kbd> file, delete the generated code and add the following:</li>
</ol>
<pre style="padding-left: 60px">1    extern crate proc_macro; <br/>2    #[macro_use]<br/>3    extern crate quote;<br/>4    extern crate syn;<br/>5 <br/>6    use proc_macro::TokenStream;<br/>7 <br/>8    // HelloWorld is the name for the derive<br/>9    // hello_world_name is the name of our optional attribute<br/>10   #[proc_macro_derive(HelloWorld, attributes(hello_world_name))]<br/>11   pub fn hello_world(input: TokenStream) -&gt; TokenStream {<br/>12     // Construct a string representation of the type definition<br/>13     let s = input.to_string();<br/>14     // Parse the string representation into an abstract syntax <br/>          tree<br/>15     let ast = syn::parse_derive_input(&amp;s).expect("Failed to <br/>       parse the source into an AST");<br/>16 <br/>17     // Build the implementation<br/>18     let gen = impl_hello_world(&amp;ast);<br/>19 <br/>20     // Return the generated implementation<br/>21     gen.parse()<br/>22       .expect("Failed to parse the AST generated from deriving <br/>          from HelloWorld")<br/>23   }<br/>24 <br/>25   fn impl_hello_world(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {<br/>26     let identifier = &amp;ast.ident;<br/>27     // Use the name provided by the attribute<br/>28     // If there is no attribute, use the identifier<br/>29     let hello_world_name = <br/>       get_name_attribute(ast).unwrap_or_else(||    <br/>       identifier.as_ref());<br/>30     quote! {<br/>31       // Insert an implementation for our trait<br/>32       impl HelloWorld for #identifier {<br/>33         fn hello_world() {<br/>34           println!(<br/>35             "The struct or enum {} says: \"Hello world from    <br/>                {}!\"",<br/>36              stringify!(#identifier),<br/>37              #hello_world_name<br/>38           );<br/>39         } //end of fn hello_world()<br/>40       } //end of impl HelloWorld<br/>41     } //end of quote<br/>42   } //end of fn impl_hello_world<br/>43 <br/>44   fn get_name_attribute(ast: &amp;syn::DeriveInput) -&gt; Option&lt;&amp;str&gt; {<br/>45     const ATTR_NAME: &amp;str = "hello_world_name";<br/>46 <br/>47     // Go through all attributes and find one with our name<br/>48     if let Some(attr) = ast.attrs.iter().find(|a| a.name() == <br/>       ATTR_NAME) {<br/>49       // Check if it's in the form of a name-value pair<br/>50       if let syn::MetaItem::NameValue(_, ref value) = attr.value <br/>         {<br/>51         // Check if the value is a string<br/>52         if let syn::Lit::Str(ref value_as_str, _) = *value {<br/>53           Some(value_as_str)<br/>54         } else {<br/>55             panic!(<br/>56               "Expected a string as the value of {}, found {:?} <br/>                  instead",<br/>57                ATTR_NAME, value<br/>58             );<br/>59           }<br/>60         } else {<br/>61             panic!(<br/>62               "Expected an attribute in the form #[{} = \"Some <br/>                  value\"]",<br/>63                ATTR_NAME<br/>64             );<br/>65           }<br/>66         } else {<br/>67             None<br/>68         }<br/>69   }</pre>
<ol start="6">
<li>In the original <kbd>Cargo.toml</kbd> file of this chapter, add the following to the <kbd>[dependencies]</kbd>:</li>
</ol>
<pre style="padding-left: 60px">custom-derive = { path = "custom-derive" }</pre>
<p>               7. In the <kbd>bin</kbd> folder, create a file called <kbd>custom_derive.rs</kbd>.</p>
<p>               8. Add the following code and run it with <kbd>cargo run --bin custom_derive</kbd>:</p>
<pre style="padding-left: 60px">1    #[macro_use]<br/>2    extern crate chapter_five_derive;<br/>3 <br/>4    // trait definitions have to be in "consumer" crate<br/>5    trait HelloWorld {<br/>6      // This method will send a friendly greeting<br/>7      fn hello_world();<br/>8    }<br/>9 <br/>10   // thanks to the code in the custom_derive crate<br/>11   // we can derive from HelloWorld in order to provide<br/>12   // an automatic implementation for the HelloWorld trait<br/>13   #[derive(HelloWorld)]<br/>14   struct Switzerland;<br/>15 <br/>16   #[derive(HelloWorld)]<br/>17   struct Britain;<br/>18 <br/>19   #[derive(HelloWorld)]<br/>20   // We can use an optional attribute to change the message<br/>21   #[hello_world_name = "the Land Down Under"]<br/>22   struct Australia;<br/>23 <br/>24   fn main() {<br/>25     Switzerland::hello_world();<br/>26     Britain::hello_world();<br/>27     Australia::hello_world();<br/>28   }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The instructions for this recipe are a bit more complex than the others, as we need to manage two separate crates. If your code doesn't compile, compare your version with the one used in the book at <a href="https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five">https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five.</a> We need to separate the code into two crates because providing a custom <kbd>derive</kbd> requires creating a procedural macro, as indicated by all of the instances of <kbd>proc_macro</kbd> in the code. A procedural macro is Rust code that runs alongside the compiler and interacts directly with it. Because of the special nature and unique restrictions of such code, it needs to be in a separate crate that is annotated with the following:</p>
<div><pre style="padding-left: 30px">[lib]<br/>proc-macro = true</pre></div>
<p>This crate is typically named after the main crate with the <kbd>_derive</kbd> suffix added. In our example, the main crate is called <kbd>chapter_five</kbd>, so the crate providing the procedural macro is called <kbd>chapter_five_derive</kbd>.</p>
<p>In our example, we are going to create a derived version of good, old Hello World: a <kbd>struct</kbd> or <kbd>enum</kbd> deriving from <kbd>HelloWorld</kbd> will implement the <kbd>HelloWorld</kbd> trait, providing a <kbd>hello_world()</kbd> function with a friendly greeting containing its own name. Additionally, you can specify a <kbd>HelloWorldName</kbd> attribute to alter the message.</p>
<p>The code in <kbd>custom.rs</kbd> should be self-explanatory. We begin by importing our derivation crate [2] where we need to include the <kbd>#[macro_use]</kbd> attribute in order to actually import the procedural macros. We then define our <kbd>HelloWorld</kbd> trait [5] and proceed to derive it on a bunch of structures [13, 16 and 19], just like we would with built-in derives such as <kbd>Debug</kbd> or <kbd>Clone</kbd>. <kbd>Australia</kbd> gets a custom message via the <kbd>HelloWorldName</kbd> attribute. Lastly, in the <kbd>main</kbd> function, we call the generated <kbd>hello_world()</kbd> function.</p>
<p>Let's take a look at <kbd>chapter-five-derive/src/lib.rs</kbd> now. Procedural macro crates typically begin by importing the <kbd>proc_macro</kbd>, <kbd>quote</kbd>, and <kbd>syn</kbd> crates. Attentive readers will have noticed that we didn't add the <kbd>proc_macro</kbd> to our <kbd>[dependencies]</kbd> section in the crate's <kbd>Cargo.toml</kbd>. We didn't need to because this special support crate is provided by the standard Rust distribution.</p>
<p>The <kbd>quote</kbd> crate provides the <kbd>quote!</kbd> macro, which lets us translate Rust code into tokens that the compiler can use. The really useful feature of this macro is that it supports code interpolation of a variable by writing a <kbd>#</kbd> in front of it. This means that when we write the following, the value inside the <kbd>struct_name</kbd> variable is interpreted as Rust code:</p>
<div><pre style="padding-left: 30px">impl HelloWorld for #struct_name { ... }</pre>
<p>If <kbd>struct_name</kbd> has the <kbd>Switzerland</kbd> value, the following code will be generated:</p>
<pre style="padding-left: 30px">impl HelloWorld for Switzerland { ... }</pre></div>
<p>The <kbd>syn</kbd> crate is a Rust parser built upon the <kbd>nom</kbd> parser combinator framework (<a href="https://github.com/Geal/nom">https://github.com/Geal/nom</a>), which you should check out as well if you're thinking about writing a parser. In fact, some of the crates used in <a href="c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml" target="_blank">Chapter 4</a>, <em>Serialization</em>, are written with <kbd>nom</kbd>, too. Back on track, <kbd>syn</kbd> parses the code annotated by your custom attributes or derives and lets you work with the generated abstract syntax tree.</p>
<p>The convention for a custom derive is to create a function with the name of the derive in <kbd>snake_case</kbd> (<kbd>pub fn hello_world</kbd>, in our case) that parses the annotated code and then calls a function that generates the new code. The second function typically has the name of the first one, prefixed with <kbd>impl</kbd>. In our code, this is <kbd>fn impl_hello_world</kbd>.</p>
<p>In a <kbd>proc_macro</kbd> crate, only functions tagged with <kbd>proc_macro_derive</kbd> are allowed to be published. The consequence of this is, by the way, that we are not able to move our <kbd>HelloWorld</kbd> trait into this crate; it wouldn't be allowed to be <kbd>pub</kbd>.</p>
<p>The <kbd>proc_macro_derive</kbd> annotation requires you to specify which name will be used for the derive (<kbd>HelloWorld</kbd> for us) and which attributes it allows. If we didn't want to accept the <kbd>HelloWorldName</kbd> attribute, we could simply omit the entire attributes section and annotate our function like this:</p>
<pre style="padding-left: 30px">#[proc_macro_derive(HelloWorld)]</pre>
<p>Because <kbd>hello_world</kbd> hooks itself directly into the compiler, it both accepts and returns a <kbd>TokenStream</kbd>, which is the compiler-internal representation of Rust code. We start by turning the <kbd>TokenStream</kbd> back into a <kbd>String</kbd> in order to be parsed again by <kbd>syn</kbd>. This is not an expensive action, as the <kbd>TokenStream</kbd> we receive from the compiler is not the entire program, but only the part annotated by our custom derive. For example, the <kbd>String</kbd> behind the <kbd>TokenStream</kbd> of the first <kbd>struct</kbd> annotated by <kbd>HelloWorld</kbd> is simply the following:</p>
<pre style="padding-left: 30px">struct Switzerland;</pre>
<p class="mce-root">We then parse the said string with <kbd>syn::parse_derive_input(&amp;s)</kbd>, which basically tells <kbd>syn</kbd> that the code we want to parse is a <kbd>struct</kbd> or <kbd>enum</kbd> that is deriving something.</p>
<p>We then generate the code with the following:</p>
<div><pre style="padding-left: 30px">let gen = impl_hello_world(&amp;ast);</pre></div>
<p>Then we convert it back into a <kbd>TokenStream</kbd> with this:</p>
<pre style="padding-left: 30px">gen.parse()</pre>
<p>The <kbd>TokenStream</kbd> is then injected back into the code by the compiler. As you can see, a procedural macro cannot change existing code, but only analyze it and generate additional code.</p>
<p>Here is the process described in <kbd>hello_world</kbd>: </p>
<ol>
<li>Convert the <kbd>TokenStream</kbd> into a <kbd>String</kbd></li>
<li>Parse the <kbd>String</kbd> with <kbd>syn</kbd></li>
<li>Generate an implementation of another method</li>
<li>Parse the implementation back into a <kbd>TokenStream</kbd></li>
</ol>
<p>It is very typical for a custom derive. You can reuse the code presented in nearly all basic procedural macros.</p>
<p>Let's move on to <kbd>impl_hello_world</kbd> now. With the help of the <kbd>ast</kbd> passed, we can analyze the annotated structure. The <kbd>ident</kbd> member, which stands for <em>identifier</em>, tells us the name of the <kbd>struct</kbd> or <kbd>enum</kbd>. For instance, in the first struct that derives from <kbd>HelloWorld</kbd>, this is the <kbd>"Switzerland"</kbd> string.</p>
<p>We then decide which name to use in the greeting with the help of the <kbd>get_name_attribute</kbd> little helper function, which we will look at in a moment. It returns the value of the <kbd>HelloWorldName</kbd> attribute if it has been set. If not, we default to the <kbd>identifier</kbd>, converted to a string via <kbd>as_ref</kbd>[29]. How this is done is explained in the next recipe.</p>
<p>Finally, we create some <kbd>quote::Tokens</kbd> by writing the implementation and surrounding it with <kbd>quote!</kbd>. Notice again how we interpolate variables into the code by writing <kbd>#</kbd> in front of it. Additionally, while printing, we surround <kbd>#identifier</kbd> with <kbd>stringify!</kbd>, which turns an identifier into a string. We don't need to do this with <kbd>#hello_world_identifier</kbd> because it already holds a string. To understand why this is needed, let's look at the code that would be generated for the <kbd>Switzerland</kbd> struct if we <em>didn't</em> include <kbd>stringify!</kbd>:</p>
<pre style="padding-left: 30px">impl HelloWorld for Switzerland {<br/>    fn hello_world() {<br/>        println!(<br/>            "The struct or enum {} says: \"Hello world from {}!\"",<br/>            Switzerland,<br/>            "Switzerland"<br/>        );<br/>    }<br/>}</pre>
<p>Try it out for yourself, and you will be greeted with an error message stating that something along the lines of <kbd>"`Switzerland` cannot be formatted with the default formatter"</kbd>. This is because we are not printing the <kbd>"Switzerland"</kbd> string, but instead trying to print the concept of the <kbd>Switzerland</kbd> struct itself, which is clearly nonsense. To fix this, we just need to make sure that the interpolated variable is surrounded by quotes (<kbd>"</kbd>), which is exactly what <kbd>stringify!</kbd> does.</p>
<p class="mce-root">Let's look at the final piece of the puzzle now: <kbd>get_name_attribute</kbd>. This function might look a little intimidating at first. Let's go through it step by step:</p>
<pre style="padding-left: 30px">if let Some(attr) = ast.attrs.iter().find(|a| a.name() == ATTR_NAME) { ... }</pre>
<p>Here we'll go through all available attributes and search for one named <kbd>"HelloWorldName"</kbd>. If we don't find any, the function call already ends by returning <kbd>None</kbd>. Otherwise, we continue with the following line:</p>
<div><pre style="padding-left: 30px">if let syn::MetaItem::NameValue(_, ref value) = attr.value { ... }</pre></div>
<p><kbd>syn::MetaItem</kbd> is simply how <kbd>syn</kbd> calls attributes. This line is necessary because there are many ways to write attributes in Rust. For example, a <kbd>syn::MetaItem::Word</kbd> can be written like <kbd>#[foo]</kbd>. An example for <kbd>syn::MetaItem::List</kbd> is <kbd>#[foo(Bar, Baz, Quux)]</kbd>. <kbd>#[derive(...)]</kbd> itself also a <kbd>syn::MetaItem::List</kbd>. We, however, are only interested in <kbd>syn::MetaItem::NameValue</kbd>, which is an attribute in the form of <kbd>#[foo = Bar]</kbd>. If the <kbd>HelloWorldName</kbd> attribute is not in this form, we <kbd>panic!</kbd> with a message explaining what the problem is. A <kbd>panic</kbd> in procedural macro results in a compiler error. You can verify this by replacing <kbd>#[HelloWorldName = "the Land Down Under"</kbd> in <kbd>custom.rs</kbd> with <kbd>#[HelloWorldName]</kbd>.</p>
<p>Contrary to normal programs, because of procedural macros <kbd>panic!</kbd> at compile time, it's okay for them to <kbd>panic!</kbd> often. When doing so, remember that errors originating from other crates are very nasty to debug, doubly so in any kind of macros, so it's incredibly important to write the error messages as explicitly as possible.</p>
<p>The last check we need to do is on the value of <kbd>HelloWorldName</kbd>. As we are going to print it, we want to accept only strings:</p>
<pre style="padding-left: 30px">if let syn::Lit::Str(ref value_as_str, _) = *value { ... }</pre>
<p>On success, we return the string. Otherwise, we again <kbd>panic!</kbd> with an error message detailing the problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you ran into trouble while running this recipe, you can use David Tolney's <kbd>cargo-expand</kbd> (<a href="https://github.com/dtolnay/cargo-expand">https://github.com/dtolnay/cargo-expand</a>) to show you how the compiler expanded your <kbd>proc_macros</kbd>. It's a really useful tool to debug your macros, so be sure to check it out.</p>
<p>The reason behind the two-crate restriction is historical and only temporary. In the beginning, there was only one way to define macros, <kbd>macro_rules!</kbd>. People with exotic needs, who were ready to put in the effort, were (and still are) able to extend their programs by directly hooking into the Rust compiler itself. Crates written this way are called <em>compiler plugins</em>. Of course, this is incredibly unstable because every minor Rust release can break your plugin, but people kept on doing it because it gave them one big advantage, custom derives. The core team reacted to the increased demand for language extensibility by deciding to launch <kbd>macros2.0</kbd> at some point in the future, bringing an overhaul to the entire macro system and many additional features, such as namespacing macros.</p>
<p>As they saw that most of the plugins were used only for custom derives, they also decided to bridge the time until <kbd>macros2.0</kbd> with <kbd>macros1.1</kbd>, which are also called <em>procedural macros</em>. Stabilizing the small subset of the compiler that is needed to create custom derives. The only problem was that crates now had parts that ran normally and parts that ran at compile time instead. Mixing them proved difficult to implement and a bit chaotic, so the two-crate system of moving all procedural macro code into a <kbd>-derive</kbd> crate was created. This is the system used in this recipe, as at the time of writing, <kbd>macros2.0</kbd> has not been stabilized yet. I encourage you to take a look at the current progress: <a href="https://github.com/rust-lang/rust/issues/39412">https://github.com/rust-lang/rust/issues/39412</a>.</p>
<p>If by the time you read this book, <kbd>macros2.0</kbd> has been released, you should update your knowledge about how to write modern custom derives.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting types into each other</h1>
                
            
            
                
<p>Having dedicated types is great, but true flexibility can only come when these types can easily be converted from and into each other. Luckily, Rust provides this functionality quite literally through the <kbd>From</kbd> and <kbd>Into</kbd> traits, along with some friends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>conversion.rs</kbd>.</p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin conversion</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    use std::ops::MulAssign; <br/>2    use std::fmt::Display;<br/>3 <br/>4    // This structure doubles all elements it stores<br/>5    #[derive(Debug)]<br/>6    struct DoubleVec&lt;T&gt;(Vec&lt;T&gt;);<br/>7 <br/>8 <br/>9    // Allowing conversion from a Vec&lt;T&gt;,<br/>10   // where T is multipliable with an integer<br/>11   impl&lt;T&gt; From&lt;Vec&lt;T&gt;&gt; for DoubleVec&lt;T&gt;<br/>12   where<br/>13   T: MulAssign&lt;i32&gt;,<br/>14   {<br/>15     fn from(mut vec: Vec&lt;T&gt;) -&gt; Self {<br/>16       for elem in &amp;mut vec {<br/>17         *elem *= 2;<br/>18       }<br/>19       DoubleVec(vec)<br/>20     }<br/>21   }<br/>22 <br/>23   // Allowing conversion from a slice of Ts<br/>24   // where T is again multipliable with an integer<br/>25   impl&lt;'a, T&gt; From&lt;&amp;'a [T]&gt; for DoubleVec&lt;T&gt;<br/>26   where<br/>27   T: MulAssign&lt;i32&gt; + Clone,<br/>28   {<br/>29     fn from(slice: &amp;[T]) -&gt; Self {<br/>30       // Vec&lt;T: MulAssign&lt;i32&gt;&gt; automatically<br/>31       // implements Into&lt;DoubleVec&lt;T&gt;&gt;<br/>32       slice.to_vec().into()<br/>33     }<br/>34   }<br/>35 <br/>36   // Allowing conversion from a &amp;DoubleVec&lt;T&gt; to a &amp;Vec&lt;T&gt;<br/>37   impl&lt;T&gt; AsRef&lt;Vec&lt;T&gt;&gt; for DoubleVec&lt;T&gt; {<br/>38     fn as_ref(&amp;self) -&gt; &amp;Vec&lt;T&gt; {<br/>39       &amp;self.0<br/>40     }<br/>41   }<br/>42 <br/>43 <br/>44   fn main() {<br/>45     // The following three are equivalent<br/>46     let hello_world = "Hello World".to_string();<br/>47     let hello_world: String = "Hello World!".into();<br/>48     let hello_world = String::from("Hello World!");<br/>49 <br/>50     // Vec&lt;u8&gt; implements From&lt;&amp;str&gt;<br/>51     // so hello_world_bytes has the value b"Hello World!"<br/>52     let hello_world_bytes: Vec&lt;u8&gt; = "Hello World!".into();<br/>53     let hello_world_bytes = Vec::&lt;u8&gt;::from("Hello World!");<br/>54 <br/>55     // We can convert a Vec&lt;T: MulAssign&lt;i32&gt;&gt; into a DoubleVec<br/>56     let vec = vec![1, 2, 3];<br/>57     let double_vec = DoubleVec::from(vec);<br/>58     println!("Creating a DoubleVec from a Vec: {:?}", <br/>       double_vec);<br/>59 <br/>60     // Vec&lt;T: MulAssign&lt;i32&gt;&gt; automatically implements <br/>          Into&lt;DoubleVec&lt;T&gt;&gt;<br/>61     let vec = vec![1, 2, 3];<br/>62     let double_vec: DoubleVec&lt;_&gt; = vec.into();<br/>63     println!("Converting a Vec into a DoubleVec: {:?}", <br/>       double_vec);<br/>64 <br/>65     // A reference to DoubleVec can be converted to a reference <br/>          to Vec<br/>66     // Which in turn dereferences to a slice<br/>67     print_elements(double_vec.as_ref());<br/>68 <br/>69     // The standard library provides From&lt;T&gt; for Option&lt;T&gt;<br/>70     // You can design your API in an ergonomic way thanks to this<br/>71     easy_public_func(Some(1337), Some(123), None);<br/>72     ergonomic_public_func(1337, 123, None);<br/>73   }<br/>74 <br/>75 <br/>76   fn print_elements&lt;T&gt;(slice: &amp;[T])<br/>77   where<br/>78   T: Display,<br/>79   {<br/>80     for elem in slice {<br/>81       print!("{} ", elem);<br/>82     }<br/>83     println!();<br/>84   }<br/>85 <br/>86 <br/>87   // Easily written but cumbersome to use<br/>88   fn easy_public_func(foo: Option&lt;i32&gt;, bar: Option&lt;i32&gt;, baz: <br/>     Option&lt;i32&gt;) {<br/>89     println!(<br/>90       "easy_public_func = foo: {:?}, bar: {:?}, baz: {:?}",<br/>91        foo,<br/>92        bar,<br/>93        baz<br/>94     );<br/>95   }<br/>96 <br/>97 <br/>98   // This is quite some extra typing, so it's only worth to do <br/>        for<br/>99   // public functions with many optional parameters<br/>100  fn ergonomic_public_func&lt;Foo, Bar, Baz&gt;(foo: Foo, bar: Bar, <br/>     baz: Baz)<br/>101  where<br/>102  Foo: Into&lt;Option&lt;i32&gt;&gt;,<br/>103  Bar: Into&lt;Option&lt;i32&gt;&gt;,<br/>104  Baz: Into&lt;Option&lt;i32&gt;&gt;,<br/>105  {<br/>106    let foo: Option&lt;i32&gt; = foo.into();<br/>107    let bar: Option&lt;i32&gt; = bar.into();<br/>108    let baz: Option&lt;i32&gt; = baz.into();<br/>109 <br/>110    println!(<br/>111     "ergonomic_public_func = foo: {:?}, bar: {:?}, baz: {:?}",<br/>112      foo,<br/>113      bar,<br/>114      baz<br/>115    );<br/>116  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The most important trait for conversion is <kbd>From</kbd>. Implementing it means defining how to obtain a type <em>from</em> another.</p>
<p>We present this on the example of <kbd>DoubleVec</kbd>[6]. Its concept is simple, when you construct it out of a <kbd>Vec</kbd>, it doubles all its elements. For this purpose, we implement <kbd>From&lt;Vec&lt;T&gt;&gt;</kbd> [11] with a <kbd>where</kbd> clause specifying <kbd>T: MulAssign&lt;i32&gt;</kbd>[13], which means that the trait will be implemented for all types that can be assigned to the result of a multiplication with an integer. Or, in terms of code, all types that allow the following, assuming the <kbd>t</kbd> variable is of the <kbd>T</kbd> type:</p>
<pre style="padding-left: 30px">t *= 2;</pre>
<p class="mce-root">The actual implementation should be self-explanatory, we simply multiply every element in the vector by two and wrap it in our <kbd>DoubleVec</kbd>[19]. Afterwards, we implement <kbd>From</kbd> as well for slices of the same type [25].</p>
<p>It is considered good practice to extend all of your trait definitions that work with vectors ( <kbd>Vec&lt;T&gt;</kbd> ) to also work with slices (<kbd>&amp;[T]</kbd>). This way, you gain generality and performance, as you can operate on direct references to arrays (such as <kbd>&amp;[1, 2, 3]</kbd>) and ranges of other vectors (<kbd>vec[1..3]</kbd>) without converting them first. This best practice carries over to functions as well, where you should always accept a slice of your type (as shown with <kbd>print_elements()</kbd>), if possible, for the same reasons.</p>
<p>In this implementation, however, we see something interesting:</p>
<pre>fn from(slice: &amp;[T]) -&gt; Self {<br/>    slice.to_vec().into()<br/>}</pre>
<p><kbd>slice.to_vec()</kbd> simply converts the slice into a vector. But what's up with <kbd>.into()</kbd>? Well, it comes from the <kbd>Into</kbd> trait, which is the opposite of the <kbd>From</kbd> trait, it converts a type <em>into</em> another. But how does a <kbd>Vec</kbd> know how to turn into a <kbd>DoubleVec</kbd>?</p>
<p>Let's take a look at the standard library's implementation of <kbd>Into</kbd> at <a href="https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs">https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs</a>, where we find the following lines:</p>
<pre class="rust" style="padding-left: 30px">// From implies Into<br/>impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt;
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}</pre>
<p>Aha! According to this, every <kbd>T</kbd> type that implements <kbd>From</kbd> for <kbd>U</kbd> automatically lets <kbd>U</kbd> implement <kbd>Into</kbd> for <kbd>T</kbd>. And sure enough because we implemented <kbd>From&lt;Vec&lt;T&gt; for DoubleVec&lt;T&gt;</kbd>, we automatically also implemented <kbd>Into&lt;DoubleVec&lt;T&gt;&gt; for Vec&lt;T&gt;</kbd>. Let's look at our code from before again:</p>
<pre style="padding-left: 30px">fn from(slice: &amp;[T]) -&gt; Self {<br/>    slice.to_vec().into()<br/>}</pre>
<p>The slice gets turned into a <kbd>Vec</kbd>, which implements <kbd>Into</kbd> for <kbd>DoubleVec</kbd>, among many others. Because our function signature says that we return <kbd>Self</kbd>, Rust knows which <kbd>Into</kbd> implementation to use, as only one of them returns <kbd>DoubleVec</kbd> as well.</p>
<p>Another useful trait for type conversion is <kbd>AsRef</kbd>. Its only function, <kbd>as_ref</kbd>, is nearly identical to <kbd>into</kbd>, but instead of moving itself into another type, it takes a reference to itself and returns a reference to another type. In a way, it <em>translates</em> references. You can expect this operation to be cheap in most cases, as it typically just returns a reference to an internal object. In fact, you have already used this method in the last recipe:</p>
<pre>let hello_world_name = get_name_attribute(ast).unwrap_or_else(|| identifier.as_ref());</pre>
<p><kbd>identifier</kbd> internally holds a <kbd>String</kbd> of its name. The compiler knows that <kbd>hello_world_name</kbd> has to be a <kbd>&amp;str</kbd>, as the return type of <kbd>get_name_attribute(ast)</kbd> is <kbd>Option&lt;&amp;str&gt;</kbd> and we are trying to unwrap it with a default value. Based on this information, <kbd>as_ref()</kbd> tries to return a <kbd>&amp;str</kbd>, which it can, as the only implementation of <kbd>AsRef</kbd> for <kbd>identifier</kbd> that returns a <kbd>&amp;str</kbd> is the one that returns a reference to the aforementioned <kbd>String</kbd> that holds its name.</p>
<p>We are only implementing <kbd>AsRef</kbd> for <kbd>Vec</kbd>, and not for a slice, because of a reference to a vector (<kbd>&amp;Vec&lt;T&gt;</kbd>) with automatically deref-coerce into a slice  (<kbd>&amp;[T]</kbd>), which means we automatically implement it. You can read more about the concept of deref coercion at <a href="https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods</a>.<a href="https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"/></p>
<p><kbd>AsRef</kbd> also has a brother called <kbd>AsMut</kbd>, which is identical but operates on mutable references. We intentionally didn't implement it in this example, as we don't want users messing with the internal state of <kbd>DoubleVec</kbd>. In general, you should be very conservative with this trait as well, as excessive access to the internals of anything can quickly become very chaotic.</p>
<p>The <kbd>main</kbd> function contains some examples of converting types. A popular example is the conversion from <kbd>&amp;str</kbd> to <kbd>String</kbd> in lines [46 to 48]. Interestingly, <kbd>&amp;str</kbd> can also be converted into a vector of its underlying bytes [52 and 53]. Let's look at how our <kbd>DoubleVec</kbd> can be converted in the same way.</p>
<p>The next line showcases how the <kbd>&amp;Vec&lt;i32&gt;</kbd> returned by <kbd>double_vec.as_ref()</kbd> seamlessly behaves like an <kbd>&amp;[i32]</kbd>, as <kbd>print_elements()</kbd> only accepts slices [67]:</p>
<pre style="padding-left: 30px">print_elements(double_vec.as_ref());</pre>
<p>The last part of the recipe is about API design. There is a little implementation of <kbd>From</kbd> in the standard library that reads:</p>
<pre style="padding-left: 30px">impl&lt;T&gt; From&lt;T&gt; for Option&lt;T&gt; {<br/>    fn from(val: T) -&gt; Option&lt;T&gt; {<br/>        Some(val)<br/>    }<br/>}</pre>
<p>This means that every type can be converted into an <kbd>Option</kbd>. You can use this trick, as showcased in the implementation of <kbd>ergonomic_public_func</kbd> [100], to make functions with multiple parameters of the <kbd>Option</kbd> type easier to use and look at, as you can see by comparing the following two function calls [71 and 72]:</p>
<pre>easy_public_func(Some(1337), Some(123), None);<br/>ergonomic_public_func(1337, 123, None);</pre>
<p>However, because some extra typing is required to achieve this, it's okay if you only do this on functions that are part of your API, that is, available to users of your crate. If you want to read some more tips about clean API design in Rust, check out Rust core developer Pascal Hertleif's excellent blog entry:  <a href="https://deterministic.space/elegant-apis-in-rust.html">https://deterministic.space/elegant-apis-in-rust.html.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Boxing data</h1>
                
            
            
                
<p>The first smart pointer we are going to look at is the <kbd>Box</kbd>. This very special type is the analogue to C++'s <kbd>unique_ptr</kbd>, a pointer to data stored on the heap that deletes said data automatically when it's out of scope. Because of the shift from stack to heap, <kbd>Box</kbd> can allow you some flexibility by intentionally losing type information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>boxing.rs</kbd>.</p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin boxing</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    use std::fs::File;<br/>2    use std::io::BufReader;<br/>3    use std::result::Result;<br/>4    use std::error::Error;<br/>5    use std::io::Read;<br/>6    use std::fmt::Debug;<br/>7 <br/>8    #[derive(Debug)]<br/>9    struct Node&lt;T&gt; {<br/>10     data: T,<br/>11     child_nodes: Option&lt;(BoxedNode&lt;T&gt;, BoxedNode&lt;T&gt;)&gt;,<br/>12   }<br/>13   type BoxedNode&lt;T&gt; = Box&lt;Node&lt;T&gt;&gt;;<br/>14 <br/>15   impl&lt;T&gt; Node&lt;T&gt; {<br/>16     fn new(data: T) -&gt; Self {<br/>17       Node {<br/>18         data,<br/>19         child_nodes: None,<br/>20       }<br/>21     }<br/>22 <br/>23     fn is_leaf(&amp;self) -&gt; bool {<br/>24       self.child_nodes.is_none()<br/>25     }<br/>26 <br/>27     fn add_child_nodes(&amp;mut self, a: Node&lt;T&gt;, b: Node&lt;T&gt;) {<br/>28       assert!(<br/>29         self.is_leaf(),<br/>30         "Tried to add child_nodes to a node that is not a leaf"<br/>31       );<br/>32       self.child_nodes = Some((Box::new(a), Box::new(b)));<br/>33     }<br/>34   }<br/>35 <br/>36   // Boxes enable you to use traditional OOP polymorph<br/>37   trait Animal: Debug {<br/>38     fn sound(&amp;self) -&gt; &amp;'static str;<br/>39   }<br/>40 <br/>41   #[derive(Debug)]<br/>42   struct Dog;<br/>43   impl Animal for Dog {<br/>44     fn sound(&amp;self) -&gt; &amp;'static str {<br/>45       "Woof!"<br/>46     }<br/>47   }<br/>48 <br/>49   #[derive(Debug)]<br/>50   struct Cat;<br/>51   impl Animal for Cat {<br/>52     fn sound(&amp;self) -&gt; &amp;'static str {<br/>53       "Meow!"<br/>54     }<br/>55   }<br/>56 <br/>57   fn main() {<br/>58     let mut root = Node::new(12);<br/>59     root.add_child_nodes(Node::new(3), Node::new(-24));<br/>60     root.child_nodes<br/>61       .as_mut()<br/>62       .unwrap()<br/>63       0<br/>64       .add_child_nodes(Node::new(0), Node::new(1803));<br/>65     println!("Our binary tree looks like this: {:?}", root);<br/>66 <br/>67     // Polymorphism<br/>68     let mut zoo: Vec&lt;Box&lt;Animal&gt;&gt; = Vec::new();<br/>69     zoo.push(Box::new(Dog {}));<br/>70     zoo.push(Box::new(Cat {}));<br/>71     for animal in zoo {<br/>72       println!("{:?} says {}", animal, animal.sound());<br/>73     }<br/>74 <br/>75     for word in caps_words_iter("do you feel lucky, punk‽") {<br/>76       println!("{}", word);<br/>77     }<br/>78 <br/>79     // Assuming a file called number.txt exists<br/>80     let num = read_file_as_number("number.txt").expect("Failed <br/>       read the file as a number");<br/>81     println!("number.txt contains the number {}", num);<br/>82 <br/>83     // Dynamically composing functions<br/>84     let multiplier = create_multiplier(23);<br/>85     let result = multiplier(3);<br/>86     println!("23 * 3 = {}", result);<br/>87   }<br/>88 <br/>89   // Via trait objects we can return any iterator<br/>90   fn caps_words_iter&lt;'a&gt;(text: &amp;'a str) -&gt; Box&lt;Iterator&lt;Item = <br/>     String&gt; + 'a&gt; {<br/>91     // Return an iterator over every word converted into <br/>       ALL_CAPS<br/>92     Box::new(text.trim().split(' ').map(|word| <br/>       word.to_uppercase()))<br/>93   }<br/>94 <br/>95   // Same goes for errors<br/>96   fn read_file_as_number(filename: &amp;str) -&gt; Result&lt;i32, <br/>     Box&lt;Error&gt;&gt; {<br/>97     let file = File::open(filename)?;<br/>98     let mut buf_reader = BufReader::new(file);<br/>99     let mut content = String::new();<br/>100    buf_reader.read_to_string(&amp;mut content)?;<br/>101    let number: i32 = content.parse()?;<br/>102    Ok(number)<br/>103  }<br/>104 <br/>105  fn create_multiplier(a: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {<br/>106    Box::new(move |b| a * b)<br/>107  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first thing that we are going to explore are recursive types, that is, a type that contains itself. This cannot be done directly, as the compiler needs to know in advance how much space a type requires. Consider the following <kbd>struct</kbd>:</p>
<pre style="padding-left: 30px">struct Foo {<br/>    bar: i32<br/>}</pre>
<p>The compiler will ask itself, <kbd>How much space does it take to create a Foo?</kbd> and see that it needs just enough space to hold an <kbd>i32</kbd>. And how much does an <kbd>i32</kbd> need? Exactly 32 bits. Now, consider the following:</p>
<pre>struct Foo {<br/>    bar: i32,<br/>    baz: Foo,<br/>}</pre>
<p>How much space does <kbd>Foo</kbd> need? Enough to hold an <kbd>i32</kbd> and a <kbd>Foo</kbd>. How much is an <kbd>i32</kbd>? 32 bits. And <kbd>Foo</kbd>? Enough to hold an <kbd>i32</kbd> and a <kbd>Foo</kbd>. And how much does that <kbd>Foo</kbd> take? Enough for a <kbd>Foo</kbd>, and so on, until the heat death of the universe. Clearly, we don't want to spend that long on compiling. Let's take a look at the solution to our problem:</p>
<pre style="padding-left: 30px">struct Foo {<br/>    bar: i32,<br/>    baz: Box&lt;Foo&gt;,<br/>}</pre>
<p>One last time, how big is <kbd>Foo</kbd>? Enough to hold an <kbd>i32</kbd> and a <kbd>Foo</kbd>. How big is an <kbd>i32</kbd>? 32 bits. How big is a <kbd>Box&lt;Foo&gt;</kbd>? Just as big as a box of any other type, namely 64 bit. Every <kbd>Box</kbd> will always have the same size, as they are all the same thing, a pointer to some type in the heap. This way, we resolved our problem, as the compiler now knows the exact size of the type at compile time and is happy. And because it is happy, we are happy.</p>
<p>In our code example, we illustrate one possible use case for a recursive type, a naive binary tree implementation [9]. In case you didn't know, a binary tree consists of a clump of data, which is called a <em>node</em>, that can be connected to either zero or two other <em>child nodes</em>. A node that is connected to zero nodes is a <em>leaf</em>. In our example, we build such a tree that will look like this:</p>
<div><img src="img/b80fc206-db6d-4c14-8575-7a18fc1ce149.png" style="width:13.25em;height:17.50em;"/></div>
<p>We implement it as a <kbd>struct Node</kbd> that contains any data and optionally a pair of <kbd>BoxedNode</kbd>, which is just an alias for <kbd>Box&lt;Node&gt;</kbd>.</p>
<p>A real binary tree implementation that is optimized for speed will be a little bit more complex than our example. While the concept of recursion fits very nicely into a binary tree, it is rather inefficient to store every node separately somewhere in the heap. Real implementations will instead just appear to be recursive for the user but internally store the nodes in a <kbd>Vec&lt;Node&gt;</kbd>. This way, the nodes profit from speed gains by simply being allocated in a continuous memory block, as this will optimize caching. Rust's <kbd>BTreeMap</kbd> and <kbd>BTreeSet</kbd> follow this concept as well.<br/>
<br/>
A binary tree is an excellent kind of data structure for data traversal. You can read about some of its biggest use cases at the following StackOverflow answer by Danny Pflughoeft: <a href="https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588">https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588</a>.</p>
<p>The next thing that a <kbd>Box</kbd> enables us to do is classic polymorphism how you will recognize it from other languages. For this, we prepare a trait called <kbd>Animal</kbd> [37] that has a method to produce a <kbd>sound()</kbd>. Its implementor, <kbd>Dog</kbd> [42], will produce <kbd>"Woof!"</kbd>[45] and the <kbd>Cat</kbd> [50] implementor will produce <kbd>"Meow!"</kbd> [53]. Our goal is to store both a <kbd>Dog</kbd> and a <kbd>Cat</kbd> in a <kbd>Vec</kbd> of <kbd>Animal</kbd>. We can do this by creating a so-called <em>trait object</em>. It is created by a <kbd>Box</kbd> of a trait, like in our example in the following line:</p>
<pre style="padding-left: 30px">let mut zoo: Vec&lt;Box&lt;Animal&gt;&gt; = Vec::new();</pre>
<p>This way, we intentionally erase type information from the actual type in the <kbd>Box</kbd>. The compiler no longer knows which type is in the <kbd>Box</kbd>, only that it implements <kbd>Animal</kbd>, which is all that it needs to know. As you can see by running the code, the Rust runtime will still execute the correct functions and give the <kbd>Dog</kbd> and the <kbd>Cat</kbd> different sounds.</p>
<p>With the same mechanism, we can return a trait object of <kbd>Iterator</kbd>[90]:</p>
<pre style="padding-left: 30px">fn caps_words_iter&lt;'a&gt;(text: &amp;'a str) -&gt; Box&lt;Iterator&lt;Item = String&gt; + 'a&gt; { ... }</pre>
<p>This way, we can mix and match iterators inside <kbd>caps_words_iter()</kbd> without caring for the exact return type, so long as it implements <kbd>Iterator</kbd>, which they all do. Remember that we can't just return <kbd>Iterator</kbd> directly without any <kbd>Box</kbd> around it, as we cannot return a trait. A trait object, however, is completely fine.</p>
<p>On we go to <kbd>read_file_as_number()</kbd>[96]. This method reads a file and returns the content parsed as an <kbd>i32</kbd>. This file will not be generated for you, so you will have to either download it from our GitHub repo or manually create a file called <kbd>number.txt</kbd> that contains a number, say <kbd>777</kbd>. From the signature, you can gather that this time we are boxing the <kbd>Error</kbd>. This lets us mix the error type returned. Indeed, this method does return two different kinds of errors: <kbd>std::io::Error</kbd> and <kbd>std::num::ParseIntError</kbd>.</p>
<p>The last thing that we are going to look at is how to return closures with <kbd>create_multiplier()</kbd>[105]. As all closures implement either <kbd>Fn</kbd>, <kbd>FnOnce</kbd>, and/or <kbd>FnMut</kbd>, we can return a trait object for them. This way, we can create, compose, and change functions at runtime, just like with functional languages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You might have noticed that returning a <kbd>Box&lt;Iterator&gt;</kbd> or a <kbd>Box&lt;Error&gt;</kbd> comes at a small cost in terms of efficiency, as it requires moving an object onto the heap without it having any reason to go there. There are currently two ways around this.</p>
<p>For <kbd>Box&lt;Error&gt;</kbd>, you should instead create an own <kbd>Error</kbd> type, combining all the possible errors that can be returned from your function. This is detailed in <a href="d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml" target="_blank">Chapter 6</a>, <em>Handling Errors</em>; <em>Providing user-defined Error types</em>.</p>
<p>For <kbd>Box&lt;Iterator&gt;</kbd>, you can analyze the compiler's output in order to find out the exact true type that you're returning. This works for small iterators, but any complex iterator will take a long time to crack. Because this situation is not really desirable, the Rust team has approved the introduction of <em>abstract types</em>, which will be introduced in <a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml" target="_blank">Chapter 10</a>, <em>Using Experimental Nightly Features</em>; <em>Returning abstract types</em> because it has not yet hit stable Rust.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Providing user-defined error types</em> recipe in <a href="d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml" target="_blank">Chapter 6</a>, <em>Handling Errors</em></li>
<li><em>Returning abstract types</em> recipe in <a href="f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml" target="_blank">Chapter 10</a>, <em>Using Experimental Nightly Features</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharing ownership with smart pointers</h1>
                
            
            
                
<p>Some ownership relationships are not as straightforward as <em>type A owns B</em>. Sometimes, an entire group of types owns another type. To handle this, we need another smart pointer that behaves mostly like <kbd>Box</kbd> but only deletes the underlying resource if no one needs it anymore, it is <kbd>Rc</kbd>, which stands for Reference Counted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>shared.rs</kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin shared</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    use std::rc::Rc;<br/>2 <br/>3    // The ball will survive until all kids are done playing with <br/>        it<br/>4    struct Kid {<br/>5      ball: Rc&lt;Ball&gt;,<br/>6    }<br/>7    struct Ball;<br/>8 <br/>9    fn main() {<br/>10     {<br/>11       // rc is created and count is at 1<br/>12       let foo = Rc::new("foo");<br/>13       // foo goes out of scope; count decreases<br/>14       // count is zero; the object gets destroyed<br/>15     }<br/>16 <br/>17     {<br/>18       // rc is created and count is at 1<br/>19       let bar = Rc::new("bar");<br/>20       // rc is cloned; count increases to 2<br/>21       let second_bar = Rc::clone(&amp;bar);<br/>22       // bar goes out of scode; count decreases to 1<br/>23       // bar goes out of scode; count decreases to 0<br/>24     }<br/>25 <br/>26     {<br/>27       // rc is created and count is at 1<br/>28       let baz = Rc::new("baz");<br/>29       {<br/>30         // rc is cloned; count increases to 2<br/>31         let second_baz = Rc::clone(&amp;baz);<br/>32         // second_baz goes out of scode; count decreases to 1<br/>33       }<br/>34       // baz goes out of scode; count decreases to 0<br/>35     }<br/>36     let kid_one = spawn_kid_with_new_ball();<br/>37     let kid_two = Kid {<br/>38       ball: Rc::clone(&amp;kid_one.ball),<br/>39     };<br/>40     let kid_three = Kid {<br/>41       ball: Rc::clone(&amp;kid_one.ball),<br/>42     };<br/>43     // ball lives until here<br/>44   }<br/>45 <br/>46   fn spawn_kid_with_new_ball() -&gt; Kid {<br/>47     let ball = Rc::new(Ball);<br/>48     Kid {<br/>49       ball: Rc::clone(&amp;ball),<br/>50     }<br/>51     // Although the ball goes out of scope here, the object <br/>          behind it<br/>52<br/>53     // will survive as part of the kid<br/>54   }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The heart and soul of an <kbd>Rc</kbd> is its internal counter of how many objects own it at the moment. Every time the <kbd>Rc</kbd> is cloned, it increases by one, and every time one of its clones go out of scope, it decreases by one. The moment this counter reaches zero, the objects behind the <kbd>Rc</kbd> are destroyed. The <kbd>main</kbd> method contains some annotated examples of values the counter reaches during its lifetime to help you understand how the mechanism works.</p>
<p>The effect of the simple rules presented is that a resource behind an <kbd>Rc</kbd> will only be deleted once it's no longer used, at the slim cost of a very small runtime performance loss because of the ongoing counting. This <em>delayed deletion</em> effect is ideal for resources that are shared between objects. Simply wrap them in an <kbd>Rc</kbd> and they will make sure that everything survives long enough. This is the equivalent of <kbd>shared_ptr</kbd> in C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In one edge case, reference counts can cause a <em>memory leak</em>, that is, accidentally preventing resources from ever being deleted. This happens when two objects exist that both contain an <kbd>Rc</kbd> pointing to each other. Because of this circular dependence, none of them will stop using the other and so the two objects will continue existing and pointing at each other long after your code has stopped using them. The solution here is to pick the weaker link in the hierarchy and replace its <kbd>Rc</kbd> for a <kbd>Weak</kbd>, which contains a <em>non-owning reference</em> instead. Because this situation is fairly rare, however, we are not going to look at it in detail. Instead, simply remember the possibility of a memory leak and come back to read this again when it arises.</p>
<p><kbd>Rc</kbd> is inherently singlethreaded. If you need its functionality in a multithreaded environment (such as the one we are going to explore in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em>; <em>Sharing resources in multithreaded closures</em>), you can use <kbd>Arc</kbd> instead. It stands for Atomically Reference Counted and behaves the same way as <kbd>Rc</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Sharing resources in multithreaded closures</em> recipe in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with interior mutability</h1>
                
            
            
                
<p>Although Rust's borrow checker is one of its biggest selling points, alongside its clever error-handling concept and impressive tooling, it cannot read minds yet. Sometimes you might have to take things into your own hands and borrow objects manually. This is done with the concept of <em>interior mutability</em>, which states that certain types can wrap objects while being non-mutable and still operate on them mutably.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>
<p>In the <kbd>bin</kbd> folder, create a file called <kbd>interior_mutability.rs</kbd>.<kbd><br/></kbd></p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo test --bin interior_mutability</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1    trait EmailSender { <br/>2      fn send_mail(&amp;self, msg: &amp;Email) -&gt; Option&lt;String&gt;;<br/>3    }<br/>4 <br/>5    #[derive(Debug, Clone)]<br/>6    struct Email {<br/>7      from: String,<br/>8      to: String,<br/>9      msg: String,<br/>10   }<br/>11 <br/>12   #[derive(Debug)]<br/>13   struct Customer {<br/>14     address: String,<br/>15     wants_news: bool,<br/>16   }<br/>17 <br/>18   // Send news to every customer that wants to receive them<br/>19   fn publish_news(msg: &amp;str, sender: &amp;EmailSender, customers: &amp;<br/>     [Customer]) -&gt; Option&lt;i32&gt; {<br/>20     let mut count = 0;<br/>21     let mut mail = Email {<br/>22     from: "Rust Newsletter".to_string(),<br/>23     to: "".to_string(),<br/>24     msg: msg.to_string(),<br/>25   };<br/>26   for customer in customers {<br/>27     if !customer.wants_news {<br/>28       continue;<br/>29     }<br/>30     mail.to = customer.address.to_string();<br/>31     if sender.send_mail(&amp;mail).is_none() {<br/>32       return None;<br/>33     }<br/>34     count += 1;<br/>35   }<br/>36   Some(count)<br/>37 }<br/>38 <br/>39   fn main() {<br/>40   // No code running as we are concentrating on the tests instead<br/>41   }<br/>42 <br/>43 <br/>44   #[cfg(test)]<br/>45   mod tests {<br/>46     use super::*;<br/>47     use std::cell::RefCell;<br/>48 <br/>49     struct MockEmailSender {<br/>50       // sent_mails can be modified even if MockEmailSender is <br/>            immutable<br/>51       sent_mails: RefCell&lt;Vec&lt;Email&gt;&gt;,<br/>52     }<br/>53     impl MockEmailSender {<br/>54       fn new() -&gt; Self {<br/>55         MockEmailSender {<br/>56           sent_mails: RefCell::new(Vec::new()),<br/>57         }<br/>58       }<br/>59     }<br/>60 <br/>61     impl EmailSender for MockEmailSender {<br/>62     fn send_mail(&amp;self, msg: &amp;Email) -&gt; Option&lt;String&gt; {<br/>63       // Borrow sent_mails mutably<br/>64       self.sent_mails.borrow_mut().push(msg.clone());<br/>65       Some("200 OK".to_string())<br/>66     }<br/>67   }<br/>68 <br/>69   #[test]<br/>70   fn sends_zero_to_zero_customers() {<br/>71     let sent = publish_news("hello world!", <br/>       &amp;MockEmailSender::new(), &amp;[]);<br/>72     assert_eq!(Some(0), sent);<br/>73   }<br/>74 <br/>75   #[test]<br/>76   fn sends_one_to_one_willing() {<br/>77     let customer = Customer {<br/>78       address: "herbert@herbert.com".to_string(),<br/>79       wants_news: true,<br/>80     };<br/>81     let sent = publish_news("hello world!", <br/>       &amp;MockEmailSender::new(), &amp;[customer]);<br/>82     assert_eq!(Some(1), sent);<br/>83   }<br/>84 <br/>85 #[test]<br/>86   fn sends_none_to_unwilling() {<br/>87     let customer_one = Customer {<br/>88       address: "herbert@herbert.com".to_string(),<br/>89       wants_news: false,<br/>90     };<br/>91     let customer_two = Customer {<br/>92       address: "michael@jackson.com".to_string(),<br/>93       wants_news: false,<br/>94     };<br/>95     let sent = publish_news(<br/>96       "hello world!",<br/>97        &amp;MockEmailSender::new(),<br/>98        &amp;[customer_one, customer_two],<br/>99     );<br/>100     assert_eq!(Some(0), sent);<br/>101   }<br/>102 <br/>103   #[test]<br/>104   fn sends_correct_mail() {<br/>105     let customer = Customer {<br/>106       address: "herbert@herbert.com".to_string(),<br/>107       wants_news: true,<br/>108     };<br/>109     let sender = MockEmailSender::new();<br/>110     publish_news("hello world!", &amp;sender, &amp;<br/>        [customer]).expect("Failed to send mail");<br/>111 <br/>112     // Borrow sent_mails immutable<br/>113     let mails = sender.sent_mails.borrow();<br/>114     assert_eq!(1, mails.len());<br/>115     assert_eq!("Rust Newsletter", mails[0].from);<br/>116     assert_eq!("herbert@herbert.com", mails[0].to);<br/>117     assert_eq!("hello world!", mails[0].msg);<br/>118   }<br/>119 }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The protagonist of this recipe is <kbd>RefCell</kbd>, a wrapper around any type that moves the borrow checker's rule enforcement from compile time to runtime. The basics are pretty easy, you borrow the underlying value immutably by calling <kbd>.borrow()</kbd> and borrow it mutably by calling <kbd>.borrow_mut()</kbd>. If you don't follow the golden rule of only having multiple readers or one single writer at the same time, the program goes into <kbd>panic!</kbd>. One application for this is making members of your structs mutable even though your struct itself is immutable. The best use case to show where this is useful is mocking, the art of faking infrastructure for testing purposes.</p>
<p>The idea of our example is as follows, we want to send a newsletter to every customer that is interested. For that, we have the <kbd>EmailSender</kbd> trait[1], which just specifies a method to send an <kbd>Email</kbd> and return a response[2]. It's good practice to try to define functionality through traits in order to mock them.</p>
<p>Our <kbd>publish_news</kbd> function [19] takes a message, an <kbd>EmailSender</kbd> and a slice of <kbd>Customer</kbd> (please don't imagine that literally), and sends the message to all customers who want to receive news. If it encounters an error, it returns <kbd>None</kbd>[32], otherwise, it returns the number of newsletters it sent [36].</p>
<p>You probably don't want to send an email to your customers every time you test your code, which is why we create <kbd>MockEmailSender</kbd>[49] inside the test configuration, which doesn't actually send anything but instead stores all mail in a <kbd>Vec</kbd> [64]. In order to do this, it needs to modify its member despite being immutable. That's exactly what <kbd>RefCell</kbd> is for! Thanks to this, we can efficiently test <kbd>publish_news()</kbd>, as we can access all messages it would have sent and compare them with what we expect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are many types that use interior mutability. Among them are <kbd>Cell</kbd>, which, instead of handing out references, simply copies the value it stores. This is nice when storing primitive types such as <kbd>i32</kbd> or <kbd>bool</kbd>, as they all implement copy anyway.</p>
<p>Others are <kbd>RwLock</kbd> and <kbd>Mutex</kbd>, which are important for parallelism, as we shall see in their recipes in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml">Chapter 7</a>, <em>Parallelism and Rayon</em>; <em>Access resources in parallel with RwLocks</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Access resources in parallel with RwLocks</em> recipe in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>
<p class="mce-root"/>


            

            
        
    </body></html>