["```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::List(path) => self = await!(self.list(path))?,\n        // …\n    }\n}\n```", "```rs\nuse std::fs::read_dir;\n\n#[async]\nfn list(mut self, path: Option<PathBuf>) -> Result<Self> {\n    if self.data_writer.is_some() {\n        let path = self.cwd.join(path.unwrap_or_default());\n        let directory = PathBuf::from(&path);\n        let (new_self, res) = self.complete_path(directory);\n        self = new_self;\n        if let Ok(path) = res {\n            self = await!\n            (self.send(Answer::new(ResultCode::DataConnectionAlreadyOpen,\n                                                \"Starting to list directory...\")))?;\n```", "```rs\n            let mut out = vec![];\n            if path.is_dir() {\n                if let Ok(dir) = read_dir(path) {\n                    for entry in dir {\n                        if let Ok(entry) = entry {\n                            add_file_info(entry.path(), &mut out);\n                        }\n                    }\n                } else {\n                    self = await!\n                    (self.send(Answer::new(ResultCode::InvalidParameterOrArgument,\n                                                        \"No such file or \n                                                         directory\")))?;\n                    return Ok(self);\n                }\n            } else {\n                add_file_info(path, &mut out);\n            }\n```", "```rs\n            self = await!(self.send_data(out))?;\n            println!(\"-> and done!\");\n        } else {\n            self = await!\n         (self.send(Answer::new(ResultCode::InvalidParameterOrArgument,\n                                                \"No such file or directory\")))?;\n        }\n    } else {\n        self = await!(self.send(Answer::new(ResultCode::ConnectionClosed, \"No opened \n         data connection\")))?;\n    }\n    if self.data_writer.is_some() {\n        self.close_data_connection();\n        self = await!(self.send(Answer::new(ResultCode::ClosingDataConnection, \n                      \"Transfer done\")))?;\n    }\n    Ok(self)\n}\n```", "```rs\n#[async]\nfn send_data(mut self, data: Vec<u8>) -> Result<Self> {\n    if let Some(writer) = self.data_writer {\n        self.data_writer = Some(await!(writer.send(data))?);\n    }\n    Ok(self)\n}\n```", "```rs\nfn close_data_connection(&mut self) {\n    self.data_reader = None;\n    self.data_writer = None;\n}\n```", "```rs\nconst MONTHS: [&'static str; 12] = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nfn add_file_info(path: PathBuf, out: &mut Vec<u8>) {\n    let extra = if path.is_dir() { \"/\" } else { \"\" };\n    let is_dir = if path.is_dir() { \"d\" } else { \"-\" };\n\n    let meta = match ::std::fs::metadata(&path) {\n        Ok(meta) => meta,\n        _ => return,\n    };\n    let (time, file_size) = get_file_info(&meta);\n    let path = match path.to_str() {\n        Some(path) => match path.split(\"/\").last() {\n            Some(path) => path,\n            _ => return,\n        },\n        _ => return,\n    };\n    let rights = if meta.permissions().readonly() {\n        \"r--r--r--\"\n    } else {\n        \"rw-rw-rw-\"\n    };\n```", "```rs\n    let file_str = format!(\"{is_dir}{rights} {links} {owner} {group} {size} {month}  \n    {day} {hour}:{min} {path}{extra}\\r\\n\",\n                           is_dir=is_dir,\n                           rights=rights,\n                           links=1, // number of links\n                           owner=\"anonymous\", // owner name\n                           group=\"anonymous\", // group name\n                           size=file_size,\n                           month=MONTHS[time.tm_mon as usize],\n                           day=time.tm_mday,\n                           hour=time.tm_hour,\n                           min=time.tm_min,\n                           path=path,\n                           extra=extra);\n    out.extend(file_str.as_bytes());\n    println!(\"==> {:?}\", &file_str);\n}\n```", "```rs\nextern crate time;\n\nuse std::fs::Metadata;\n\n#[cfg(windows)]\nfn get_file_info(meta: &Metadata) -> (time::Tm, u64) {\n    use std::os::windows::prelude::*;\n    (time::at(time::Timespec::new(meta.last_write_time())), meta.file_size())\n}\n\n#[cfg(not(windows))]\nfn get_file_info(meta: &Metadata) -> (time::Tm, u64) {\n    use std::os::unix::prelude::*;\n    (time::at(time::Timespec::new(meta.mtime(), 0)), meta.size())\n}\n```", "```rs\ntime = \"0.1.38\"\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Retr(file) => self = await!(self.retr(file))?,\n        // …\n    }\n}\n```", "```rs\nuse std::fs::File;\nuse std::io::Read;\n\nuse error::Error;\n\n#[async]\nfn retr(mut self, path: PathBuf) -> Result<Self> {\n    if self.data_writer.is_some() {\n        let path = self.cwd.join(path);\n        let (new_self, res) = self.complete_path(path.clone());\n        self = new_self;\n        if let Ok(path) = res {\n            if path.is_file() {\n                self = await!(self.send(Answer::new(ResultCode::DataConnectionAlreadyOpen, \"Starting to send file...\")))?;\n                let mut file = File::open(path)?;\n                let mut out = vec![];\n                file.read_to_end(&mut out)?;\n                self = await!(self.send_data(out))?;\n                println!(\"-> file transfer done!\");\n```", "```rs\n            } else {\n                self = await!(self.send(Answer::new(ResultCode::LocalErrorInProcessing,\n                              &format!(\"\\\"{}\\\" doesn't exist\",\n                              path.to_str().ok_or_else(|| Error::Msg(\"No \n                              path\".to_string()))?))))?;\n            }\n        } else {\n            self = await!(self.send(Answer::new(ResultCode::LocalErrorInProcessing,\n                          &format!(\"\\\"{}\\\" doesn't exist\",\n                          path.to_str().ok_or_else(|| Error::Msg(\"No  \n                          path\".to_string()))?))))?;\n        }\n    } else {\n        self = await!\n```", "```rs\n(self.send(Answer::new(ResultCode::ConnectionClosed, \"No opened  \n         data connection\")))?;\n    }\n```", "```rs\n.ok_or_else(|| Error::Msg(\"No path\".to_string()))?\n```", "```rs\n    if self.data_writer.is_some() {\n        self.close_data_connection();\n        self = await!(self.send(Answer::new(ResultCode::ClosingDataConnection, \n         \"Transfer done\")))?;\n    }\n    Ok(self)\n}\n```", "```rs\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    match cmd {\n        Command::Stor(file) => self = await!(self.stor(file))?,\n        // …\n    }\n}\n```", "```rs\nuse std::io::Write;\n\n#[async]\nfn stor(mut self, path: PathBuf) -> Result<Self> {\n    if self.data_reader.is_some() {\n        if invalid_path(&path) {\n            let error: io::Error = io::ErrorKind::PermissionDenied.into();\n            return Err(error.into());\n        }\n        let path = self.cwd.join(path);\n        self = await!(self.send(Answer::new(ResultCode::DataConnectionAlreadyOpen, \n         \"Starting to send file...\")))?;\n```", "```rs\n        let (data, new_self) = await!(self.receive_data())?;\n        self = new_self;\n        let mut file = File::create(path)?;\n        file.write_all(&data)?;\n        println!(\"-> file transfer done!\");\n        self.close_data_connection();\n        self = await!(self.send(Answer::new(ResultCode::ClosingDataConnection, \n        \"Transfer done\")))?;\n    } else {\n        self = await!(self.send(Answer::new(ResultCode::ConnectionClosed, \n         \"No opened data connection\")))?;\n    }\n    Ok(self)\n}\n```", "```rs\n#[async]\nfn receive_data(mut self) -> Result<(Vec<u8>, Self)> {\n    let mut file_data = vec![];\n    if self.data_reader.is_none() {\n        return Ok((vec![], self));\n    }\n    let reader = self.data_reader.take().ok_or_else(|| Error::Msg(\"No data \n     reader\".to_string()))?;\n    #[async]\n    for data in reader {\n        file_data.extend(&data);\n    }\n    Ok((file_data, self))\n}\n```", "```rs\nuse std::path::Component;\n\nfn invalid_path(path: &Path) -> bool {\n    for component in path.components() {\n        if let Component::ParentDir = component {\n            return true;\n        }\n    }\n    false\n}\n```", "```rs\ntoml = \"0.4\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\n```", "```rs\npub struct Config {\n    // fields...\n}\n```", "```rs\npub struct Config {\n    pub server_port: Option<u16>,\n    pub server_addr: Option<String>,\n}\n```", "```rs\npub struct User {\n    pub name: String,\n    pub password: String,\n}\n```", "```rs\npub struct Config {\n    pub server_port: Option<u16>,\n    pub server_addr: Option<String>,\n    pub users: Vec<User>,\n    pub admin: Option<User>,\n}\n```", "```rs\n#[derive(Deserialize, Serialize)]\n```", "```rs\n#[derive(Clone, Deserialize, Serialize)]\npub struct Config {\n    pub server_port: Option<u16>,\n    pub server_addr: Option<String>,\n    pub admin: Option<User>,\n    pub users: Vec<User>,\n}\n\n#[derive(Clone, Deserialize, Serialize)]\npub struct User {\n    pub name: String,\n    pub password: String,\n}\n```", "```rs\nuse std::fs::File;\nuse std::path::Path;\nuse std::io::{Read, Write};\n\nuse toml;\n\nfn get_content<P: AsRef<Path>>(file_path: &P) -> Option<String> {\n    let mut file = File::open(file_path).ok()?;\n    let mut content = String::new();\n    file.read_to_string(&mut content).ok()?;\n    Some(content)\n}\n\nimpl Config {\n    pub fn new<P: AsRef<Path>>(file_path: P) -> Option<Config> {\n        if let Some(content) = get_content(&file_path) {\n            toml::from_str(&content).ok()\n        } else {\n            println!(\"No config file found so creating a new one in \n                     {}\",file_path.as_ref().display());\n            // In case we didn't find the config file, \n                we just build a new one.\n            let config = Config {\n                server_port: Some(DEFAULT_PORT),\n                server_addr: Some(\"127.0.0.1\".to_owned()),\n                admin: None,\n                users: vec![User {\n                    name: \"anonymous\".to_owned(),\n                    password: \"\".to_owned(),\n                }],\n            };\n            let content = toml::to_string(&config).expect(\"serialization failed\");\n            let mut file = File::create(file_path.as_ref()).expect(\"couldn't create \n             file...\");\n            writeln!(file, \"{}\", content).expect(\"couldn't fulfill config file...\");\n            Some(config)\n        }\n    }\n}\n```", "```rs\nif let Some(content) = get_content(&file_path) {\n    toml::from_str(&content).ok()\n}\n```", "```rs\npub const DEFAULT_PORT: u16 = 1234;\n```", "```rs\nelse {\n    println!(\"No config file found so creating a new one in {}\",\n             file_path.as_ref().display());\n    // In case we didn't find the config file, we just build a new one.\n    let config = Config {\n        server_port: Some(DEFAULT_PORT),\n        server_addr: Some(\"127.0.0.1\".to_owned()),\n        admin: None,\n        users: vec![User {\n            name: \"anonymous\".to_owned(),\n            password: \"\".to_owned(),\n        }],\n    };\n    let content = toml::to_string(&config).expect(\"serialization failed\");\n    let mut file = File::create(file_path.as_ref()).expect(\"couldn't create \n    file...\");\n    writeln!(file, \"{}\", content).expect(\"couldn't fulfill config file...\");\n    Some(config)\n}\n```", "```rs\nconst CONFIG_FILE: &'static str = \"config.toml\";\n```", "```rs\nlet config = Config::new(CONFIG_FILE).expect(\"Error while loading config...\");\n```", "```rs\nif let Err(error) = core.run(server(handle, server_root, config)) {\n```", "```rs\n#[async]\nfn server(handle: Handle, server_root: PathBuf, config: Config) -> io::Result<()> {\n    let port = config.server_port.unwrap_or(DEFAULT_PORT);\n    let addr = SocketAddr::new(IpAddr::V4(config.server_addr.as_ref()\n                                                .unwrap_or(&\"127.0.0.1\".to_owned())\n                                                .parse()\n                                                .expect(\"Invalid IpV4 address...\")),\n                                                 port);\n    let listener = TcpListener::bind(&addr, &handle)?;\n\n    println!(\"Waiting clients on port {}...\", port);\n    #[async]\n    for (stream, addr) in listener.incoming() {\n        let address = format!(\"[address : {}]\", addr);\n        println!(\"New client: {}\", address);\n        handle.spawn(handle_client(stream, handle.clone(), server_root.clone()));\n        handle.spawn(handle_client(stream, handle.clone(), server_root.clone(),  \n        config.clone()));\n        println!(\"Waiting another client...\");\n    }\n    Ok(())\n}\n```", "```rs\n#[async]\nfn handle_client(stream: TcpStream, handle: Handle, server_root: PathBuf,\n                 config: Config) -> result::Result<(), ()> {\n    await!(client(stream, handle, server_root, config))\n        .map_err(|error| println!(\"Error handling client: {}\", error))\n}\n```", "```rs\n#[async]\nfn client(stream: TcpStream, handle: Handle, server_root: PathBuf, config: Config) -> Result<()> {\n    let (writer, reader) = stream.framed(FtpCodec).split();\n    let writer = await!(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser,\n                                    \"Welcome to this FTP server!\")))?;\n    let mut client = Client::new(handle, writer, server_root, config);\n    #[async]\n    for cmd in reader {\n        client = await!(client.handle_cmd(cmd))?;\n    }\n    println!(\"Client closed\");\n    Ok(())\n}\n```", "```rs\nstruct Client {\n    cwd: PathBuf,\n    data_port: Option<u16>,\n    data_reader: Option<DataReader>,\n    data_writer: Option<DataWriter>,\n    handle: Handle,\n    name: Option<String>,\n    server_root: PathBuf,\n    transfer_type: TransferType,\n    writer: Writer,\n    is_admin: bool,\n    config: Config,\n    waiting_password: bool,\n}\n```", "```rs\nfn is_logged(&self) -> bool {\n    self.name.is_some() && !self.waiting_password\n}\n```", "```rs\nfn new(handle: Handle, writer: Writer, server_root: PathBuf, config: Config) -> Client {\n    Client {\n        cwd: PathBuf::from(\"/\"),\n        data_port: None,\n        data_reader: None,\n        data_writer: None,\n        handle,\n        name: None,\n        server_root,\n        transfer_type: TransferType::Ascii,\n        writer,\n        is_admin: false,\n        config,\n        waiting_password: false,\n    }\n}\n```", "```rs\npub enum Command {\n    // variants...\n    Pass(String),\n    // variants...\n}\n```", "```rs\nb\"PASS\" => Command::Pass(data.and_then(|bytes| String::from_utf8(bytes.to_vec()).map_err(Into::into))?),\n```", "```rs\nuse config::{DEFAULT_PORT, Config};\nuse std::path::Path;\n\nfn prefix_slash(path: &mut PathBuf) {\n    if !path.is_absolute() {\n        *path = Path::new(\"/\").join(&path);\n    }\n}\n\n#[async]\nfn handle_cmd(mut self, cmd: Command) -> Result<Self> {\n    println!(\"Received command: {:?}\", cmd);\n    if self.is_logged() {\n        match cmd {\n            Command::Cwd(directory) => return Ok(await!(self.cwd(directory))?),\n            Command::List(path) => return Ok(await!(self.list(path))?),\n            Command::Pasv => return Ok(await!(self.pasv())?),\n            Command::Port(port) => {\n                self.data_port = Some(port);\n                return Ok(await!(self.send(Answer::new(ResultCode::Ok,\n                          &format!(\"Data port is now {}\", \n                           port))))?);\n            }\n            Command::Pwd => {\n                let msg = format!(\"{}\", self.cwd.to_str().unwrap_or(\"\")); // small   \n                 trick\n                if !msg.is_empty() {\n                    let message = format!(\"\\\"{}\\\" \", msg);\n\n                    return Ok(await!\n                    (self.send(Answer::new(ResultCode::PATHNAMECreated,\n                      &message)))?);\n                } else {\n                    return Ok(await!(self.send(Answer::new(ResultCode::FileNotFound,\n                              \"No such file or directory\")))?);\n                }\n            }\n            Command::Retr(file) => return Ok(await!(self.retr(file))?),\n            Command::Stor(file) => return Ok(await!(self.stor(file))?),\n            Command::CdUp => {\n                if let Some(path) = self.cwd.parent().map(Path::to_path_buf) {\n                    self.cwd = path;\n                    prefix_slash(&mut self.cwd);\n                }\n                return Ok(await!(self.send(Answer::new(ResultCode::Ok, \"Done\")))?);\n            }\n            Command::Mkd(path) => return Ok(await!(self.mkd(path))?),\n            Command::Rmd(path) => return Ok(await!(self.rmd(path))?),\n            _ => (),\n        }\n    } else if self.name.is_some() && self.waiting_password {\n        if let Command::Pass(content) = cmd {\n            let mut ok = false;\n            if self.is_admin {\n                ok = content == self.config.admin.as_ref().unwrap().password;\n            } else {\n                for user in &self.config.users {\n                    if Some(&user.name) == self.name.as_ref() {\n                        if user.password == content {\n                            ok = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if ok {\n                self.waiting_password = false;\n                let name = self.name.clone().unwrap_or(String::new());\n                self = await!(\n                    self.send(Answer::new(ResultCode::UserLoggedIn,\n                                          &format!(\"Welcome {}\", name))))?;\n            } else {\n                self = await!(self.send(Answer::new(ResultCode::NotLoggedIn,\n                               \"Invalid password\")))?;\n            }\n            return Ok(self);\n        }\n    }\n    match cmd {\n        Command::Auth =>\n            self = await!(self.send(Answer::new(ResultCode::CommandNotImplemented,\n                          \"Not implemented\")))?,\n        Command::Quit => self = await!(self.quit())?,\n        Command::Syst => {\n            self = await!(self.send(Answer::new(ResultCode::Ok, \"I won't tell!\")))?;\n        }\n        Command::Type(typ) => {\n            self.transfer_type = typ;\n            self = await!(self.send(Answer::new(ResultCode::Ok,\n                           \"Transfer type changed successfully\")))?;\n        }\n        Command::User(content) => {\n            if content.is_empty() {\n                self = await!\n               (self.send(Answer::new(ResultCode::InvalidParameterOrArgument,\n                                       \"Invalid username\")))?;\n            } else {\n                let mut name = None;\n                let mut pass_required = true;\n\n                self.is_admin = false;\n                if let Some(ref admin) = self.config.admin {\n                    if admin.name == content {\n                        name = Some(content.clone());\n                        pass_required = admin.password.is_empty() == false;\n                        self.is_admin = true;\n                    }\n                }\n                // In case the user isn't the admin.\n                if name.is_none() {\n                    for user in &self.config.users {\n                        if user.name == content {\n                            name = Some(content.clone());\n                            pass_required = user.password.is_empty() == false;\n                            break;\n                        }\n                    }\n                }\n                // In case this is an unknown user.\n                if name.is_none() {\n                    self = await!(self.send(Answer::new(ResultCode::NotLoggedIn,\n                                     \"Unknown user...\")))?;\n                } else {\n                    self.name = name.clone();\n                    if pass_required {\n                        self.waiting_password = true;\n                        self = await!(\n\n                       self.send(Answer::new(ResultCode::UserNameOkayNeedPassword,\n                                      &format!(\"Login OK, password needed for {}\",\n                                               name.unwrap()))))?;\n                    } else {\n                        self.waiting_password = false;\n                        self = await! \n                         (self.send(Answer::new(ResultCode::UserLoggedIn,\n                              &format!(\"Welcome {}!\", content))))?;\n                    }\n                }\n            }\n        }\n        Command::NoOp => self = await!(self.send(Answer::new(ResultCode::Ok,\n                                                             \"Doing nothing\")))?,\n        Command::Unknown(s) =>\n            self = await!(self.send(Answer::new(ResultCode::UnknownCommand,\n                           &format!(\"\\\"{}\\\": Not implemented\", s))))?,\n        _ => {\n            // It means that the user tried to send a command while they weren't  \n             logged yet.\n            self = await!(self.send(Answer::new(ResultCode::NotLoggedIn,\n                           \"Please log first\")))?;\n        }\n    }\n    Ok(self)\n}\n```", "```rs\nif self.is_admin || entry.path() != self.server_root.join(CONFIG_FILE) {\n```", "```rs\nif self.is_admin || path != self.server_root.join(CONFIG_FILE)\n```", "```rs\nif path.is_file() {\n```", "```rs\nif path.is_file() && (self.is_admin || path != self.server_root.join(CONFIG_FILE)) {\n```", "```rs\nif invalid_path(&path) {\n```", "```rs\nif invalid_path(&path) || (!self.is_admin && path == self.server_root.join(CONFIG_FILE)) {\n```", "```rs\n#[cfg(test)]\nmod tests {\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use std::path::PathBuf;\n\n    use ftp::ResultCode;\n    use super::{Answer, BytesMut, Command, Decoder, Encoder, FtpCodec};\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    // …\n\n    #[test]\n    fn test_encoder() {\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    // …\n\n    #[test]\n    fn test_encoder() {\n        let mut codec = FtpCodec;\n        let message = \"bad sequence of commands\";\n        let answer = Answer::new(ResultCode::BadSequenceOfCommands, message);\n        let mut buf = BytesMut::new();\n        let result = codec.encode(answer, &mut buf);\n        assert!(result.is_ok());\n        assert_eq!(buf, format!(\"503 {}\\r\\n\", message));\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    // …\n\n    #[test]\n    fn test_encoder() {\n        // …\n        let answer = Answer::new(ResultCode::CantOpenDataConnection, \"\");\n        let mut buf = BytesMut::new();\n        let result = codec.encode(answer, &mut buf);\n        assert!(result.is_ok(), \"Result is ok\");\n        assert_eq!(buf, format!(\"425\\r\\n\"), \"Buffer contains 425\");\n    }\n}\n```", "```rs\n Compiling ftp-server v0.0.1 (file:///path/to/FTP-server-rs)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.29 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 1 test\ntest codec::tests::test_encoder ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n    #[test]\n    fn test_dummy() {\n        assert!(false, \"Always fail\");\n    }\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 1.30 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 2 tests\ntest codec::tests::test_encoder ... ok\ntest codec::tests::test_dummy ... FAILED\n\nfailures:\n\n---- codec::tests::test_dummy stdout ----\n    thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\nfailures:\n    codec::tests::test_dummy\n```", "```rs\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nerror: test failed, to rerun pass '--bin ftp-server'\n```", "```rs\nexport RUST_BACKTRACE=1\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 2 tests\ntest codec::tests::test_encoder ... ok\ntest codec::tests::test_dummy ... FAILED\n\nfailures:\n\n---- codec::tests::test_dummy stdout ----\n    thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\nstack backtrace:\n   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace\n             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49\n   1: std::sys_common::backtrace::_print\n             at /checkout/src/libstd/sys_common/backtrace.rs:68\n   2: std::panicking::default_hook::{{closure}}\n             at /checkout/src/libstd/sys_common/backtrace.rs:57\n             at /checkout/src/libstd/panicking.rs:381\n   3: std::panicking::default_hook\n             at /checkout/src/libstd/panicking.rs:391\n   4: std::panicking::rust_panic_with_hook\n             at /checkout/src/libstd/panicking.rs:577\n   5: std::panicking::begin_panic\n             at /checkout/src/libstd/panicking.rs:538\n   6: ftp_server::codec::tests::test_dummy\n             at src/codec.rs:102\n   7: <F as test::FnBox<T>>::call_box\n             at /checkout/src/libtest/lib.rs:1491\n             at /checkout/src/libcore/ops/function.rs:223\n             at /checkout/src/libtest/lib.rs:142\n   8: __rust_maybe_catch_panic\n             at /checkout/src/libpanic_unwind/lib.rs:99\n\nfailures:\n    codec::tests::test_dummy  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n\nerror: test failed, to rerun pass '--bin ftp-server'\n```", "```rs\n6: ftp_server::codec::tests::test_dummy\n             at src/codec.rs:102\n```", "```rs\n    #[should_panic]\n    #[test]\n    fn test_dummy() {\n        assert!(false, \"Always fail\");\n    }\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 1.30 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 2 tests\ntest codec::tests::test_dummy ... ok\ntest codec::tests::test_encoder ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n    #[ignore]\n    #[test]\n    fn test_dummy() {\n        assert!(false, \"Always fail\");\n    }\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 2 tests\ntest codec::tests::test_dummy ... ignored\ntest codec::tests::test_encoder ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n```", "```rs\ncargo test -- --ignored\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 1 test\ntest codec::tests::test_dummy ... FAILED\n\nfailures:\n\n---- codec::tests::test_dummy stdout ----\n    thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\nfailures:\n    codec::tests::test_dummy\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 1 filtered out\n\nerror: test failed, to rerun pass '--bin ftp-server'\n```", "```rs\n#[cfg(test)]\nmod tests {\n    // …\n\n    #[test]\n    fn test_decoder() {\n        let mut codec = FtpCodec;\n        let mut buf = BytesMut::new();\n        buf.extend(b\"PWD\");\n        let result = codec.decode(&mut buf);\n        assert!(result.is_ok());\n        let command = result.unwrap();\n        assert!(command.is_none());\n```", "```rs\n        buf.extend(b\"\\r\\n\");\n        let result = codec.decode(&mut buf);\n        assert!(result.is_ok());\n        let command = result.unwrap();\n        assert_eq!(command, Some(Command::Pwd));\n```", "```rs\n        let mut buf = BytesMut::new();\n        buf.extend(b\"LIST /tmp\\r\\n\");\n        let result = codec.decode(&mut buf);\n        assert!(result.is_ok());\n        let command = result.unwrap();\n        assert_eq!(command, Some(Command::List(Some(PathBuf::from(\"/tmp\")))));\n    }\n}\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 1.70 secs\n     Running target/debug/deps/ftp_server-452667ddc2d724e8\n\nrunning 2 tests\ntest codec::tests::test_encoder ... ok\ntest codec::tests::test_decoder ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nmkdir tests\n```", "```rs\nextern crate ftp;\n\nuse std::process::Command;\nuse std::thread;\nuse std::time::Duration;\n\nuse ftp::FtpStream;\n```", "```rs\n[dev-dependencies]\nftp = \"^2.2.1\"\n```", "```rs\n#[test]\nfn test_pwd() {\n    let child =\n        Command::new(\"./target/debug/ftp-server\")\n            .spawn().unwrap();\n    let mut controller = ProcessController::new(child);\n\n    thread::sleep(Duration::from_millis(100));\n    assert!(controller.is_running(), \"Server was aborted\");\n\n    let mut ftp = FtpStream::connect(\"127.0.0.1:1234\").unwrap();\n\n    ftp.quit().unwrap();\n}\n```", "```rs\nstruct ProcessController {\n    child: Child,\n}\n```", "```rs\nimpl ProcessController {\n    fn new(child: Child) -> Self {\n        ProcessController {\n            child,\n        }\n    }\n\n    fn is_running(&mut self) -> bool {\n        let status = self.child.try_wait().unwrap();\n        status.is_none()\n    }\n}\n```", "```rs\nimpl Drop for ProcessController {\n    fn drop(&mut self) {\n        let _ = self.child.kill();\n    }\n}\n```", "```rs\n#[test]\nfn test_pwd() {\n    // …\n\n    let mut ftp = FtpStream::connect(\"127.0.0.1:1234\").unwrap();\n\n    let pwd = ftp.pwd().unwrap();\n    assert_eq!(\"/\", pwd);\n\n    ftp.login(\"ferris\", \"\").unwrap();\n\n    ftp.cwd(\"src\").unwrap();\n    let pwd = ftp.pwd().unwrap();\n    assert_eq!(\"/src\", pwd);\n\n    let _ = ftp.cdup();\n    let pwd = ftp.pwd().unwrap();\n    assert_eq!(\"/\", pwd);\n\n    ftp.quit().unwrap();\n}\n```", "```rs\n Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/ftp_server-47386d9089111729\n\nrunning 2 tests\ntest codec::tests::test_decoder ... ok\ntest codec::tests::test_encoder ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/debug/deps/server-1b5cda64792f5f82\n\nrunning 1 test\nWaiting clients on port 1234...\nNew client: [address : 127.0.0.1:43280]\nWaiting another client...\nReceived command: Pwd\nReceived command: User(\"ferris\")\nReceived command: Cwd(\"src\")\nReceived command: Pwd\nReceived command: CdUp\nReceived command: Pwd\nReceived command: Quit\ntest test_pwd ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#[test]\nfn test_pwd() {\n    println!(\"Running FTP server\");\n\n    // …\n}\n```", "```rs\ncargo run -- --nocapture\n```", "```rs\n…\n\n     Running target/debug/deps/server-1b5cda64792f5f82\n\nrunning 1 test\nRunning FTP server\nWaiting clients on port 1234...\nNew client: [address : 127.0.0.1:43304]\nWaiting another client...\nReceived command: Pwd\nReceived command: User(\"ferris\")\nReceived command: Cwd(\"src\")\nReceived command: Pwd\nReceived command: CdUp\nReceived command: Pwd\nReceived command: Quit\ntest test_pwd ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n//! An FTP server, written using tokio and futures-await.\n```", "```rs\n//! FTP codecs to encode and decode FTP commands and raw bytes.\n```", "```rs\n/// Some introduction text.\n///\n/// # Big Title\n///\n/// ## Less big title\n///\n/// ### Even less big title.\n///\n/// #### Small title\n///\n/// ...\n```", "```rs` ```", "```rs`. Usually, the code blocks are written under an `Examples` header. Let's see an example using all of these syntactic elements for a function that convert bytes to uppercase:\n\n```", "```rs\n/// let mut data = b\"test\";\n/// to_uppercase(&mut data);\n/// ```", "```rs\n\nHere, we start with a short description of the function. Then, we show a code example.\n\nIt's recommended to add comments in the code if needed, to help users understand it more easily, so don't hesitate to add some!\n\n# Documenting an enumeration (or any type with public fields)\n\nWhen we want to document an enumeration, we want not only to document the type, but also each variant. To do so, we can simply add a doc-comment before each variant. The same applies for a structure, for its fields.\n\nLet's see an example for the `Command` type:\n\n```", "```rs\n\nWe see that the `enum` itself has a doc-comment and most of the variants also have documentation.\n\n# Generating the documentation\n\nWe can easily generate the documentation by running the following command:\n\n```", "```rs\n\nThis will generate the documentation in the directory `target/doc/ftp_server`. Here is how it looks:\n\n![](img/00050.jpeg)*Figure 10.5*\n\n# Warning about public items without documentation\n\nWhen writing a library, it is very easy to forget to write the documentation about every item. But, we can use the help of the tools at our disposal. By adding the `#[warn(missing_docs)]` attribute in our crate's root, the compiler will warn us when public items do not have a doc-comment. In such a case, it will print something like this:\n\n```", "```rs\n\n# Hiding items from the documentation\n\nSometimes, we intentionally do not want to have a public item show up in the documentation. In this case, we can use the `#[doc(hidden)]` attribute:\n\n```", "```rs\n\nFor instance, this can be useful for something that is used by a macro of the crate but is not intended to be used directly by the user.\n\n# Documentation tests\n\nWriting documentation is a great thing. Showing code in your documentation is even better. However, how can you be sure that the code you're showing is still up to date? That it won't break when users copy/paste it to test it out? Here comes another wonderful feature from Rust: `doc tests`.\n\n# Tags\n\nFirst, any code blocks in documentation comments will be tested by default if they don't have `ignore` or any non-recognized tag. So, for example:\n\n```", "```rsignore\n/// let x = 12;\n/// x += 1;\n/// ```", "```rs\n\nThis block code won't be tested (luckily, because it wouldn't compile!). A few other examples:\n\n```", "```rstext\n/// this is just some text\n/// but it's rendered inside a code block\n/// nice, right?\n/// ```", "```rsc-language\n/// int strlen(const char *s) {\n///     char *c = s;\n///\n///     for (; *c; ++c);\n///     return c - s;\n/// }\n/// ```", "```rswhatever\n/// 010010000110100100100001\n/// ```", "```rs\n\nA few other instructions might come in handy for you. Let's start with `ignore`!\n\n# ignore\n\nJust like this flag name states, `ignore` makes the block code ignored. As simple as that. It'll still get the Rust syntax color once rendered in the documentation. For example:\n\n```", "```rsignore\n/// let x = 0;\n/// ```", "```rs\n\nHowever, once rendered, it'll have a graphical notification about the fact that this block code isn't tested:\n\n![](img/00051.jpeg)*Figure 10.6*\n\nAnd when you hover over the ![](img/00052.jpeg) sign:\n\n![](img/00053.jpeg)*Figure 10.7*\n\nNow let's continue with `compile_fail`!\n\n# compile_fail\n\nThe `compile_fail` flag ensures that the given code blocks don't compile. As simple as that. It's mostly used when you're showing bad code and demonstrating why it is bad. For example:\n\n```", "```rscompile_fail\n/// let x = 0;\n/// x += 2; // Damn! `x` isn't mutable so you cannot update it...\n/// ```", "```rs\n\nThen you just write a small explanation about what went wrong and show a working example. It's very common in tutorials, to help users understand why it's wrong and how to fix it.\n\nIn addition to this, please note that there will be a graphical indication that this block is supposed to fail at compilation:\n\n![](img/00054.jpeg)*Figure 10.8*\n\nAnd when you hover over the ![](img/00055.jpeg) sign:\n\n![](img/00056.jpeg)*Figure 10.9*\n\nLet's continue with `no_run`!\n\n# no_run\n\nThe `no_run` flag tells `rustdoc` to only check if the code block compiles (and therefore, not to run it). It's mostly used in cases involving external resources (such as files). For example:\n\n```", "```rsno_run\n/// use std::fs::File;\n///\n/// let mut f = File::open(\"some-file.txt\").expect(\"file not found...\");\n/// ```", "```rs\n\nIf you run this test, it's very likely (but not certain, since there is a possibility that some funny user decided to suddenly add a `some-file.txt` file) to fail at execution. However, the code is perfectly fine so it'd be a shame to just `ignore` it, right?\n\nNow, let's see what to do if you *want* the test to fail:\n\n# should_panic\n\nThe `should_panic` flag ensures that your block code panics at execution. If it doesn't, then the test fails. Let's take the previous code block:\n\n```", "```rsshould_panic\n/// use std::fs::File;\n///\n/// let mut f = File::open(\"some-file.txt\").expect(\"file not found...\");\n/// ```", "```rs\n\nOnce again, the test should succeed (unless, again, you have a funny user who added the file). Quite useful if you want to show some *bad* behavior.\n\n# Combining flags?\n\nIt's actually possible to combine flags, although it's not really useful. For example:\n\n```", "```rsrust,ignore\n/// let x = 0;\n/// ```", "```rs\n\nYou could just have written this as follows:\n\n```", "```rsignore\n/// let x = 0;\n/// ```", "```rs\n\nFor now, it's not really useful, but who knows what will happen in the future? At least now you know!\n\n# About the doc blocks themselves\n\nI suppose you noticed that we never added a function or anything. So how does it actually work?\n\nWell first, it checks if the `main` function is defined. If not, it'll wrap the code into one. Observe the following code:\n\n```", "```rs\n/// let x = 0;\n/// ```", "```rs\n\nWhen you write the preceding code, it gets transformed into this:\n\n```", "```rs\n/// fn main() {\n///     let x = 0;\n/// }\n/// ```", "```rs\n\nAlso, you can use all the public items defined in your crate in your code blocks. No need to import the crate with an `extern crate` (however, you still have to import the item!).\n\nOne last (very) important point remains to be talked about: hiding code blocks lines.\n\n# Hiding code blocks lines\n\nIf you want to use `?`, you'll have to do it inside a function returning an `Option` or a `Result`. But still, inside a function. However, you don't necessarily want to show those lines to the user in order to focus on what you're trying to explain.\n\nTo put it simply, you just need to add a `#` at the beginning of the line. As simple as that. As always, let's show it with a small example:\n\n```", "```rs\n/// # fn foo() -> std::io::Result<()> {\n/// let mut file = File::open(\"some-file.txt\")?;\n/// write!(file, \"Hello world!\")?;\n/// # Ok(())\n/// # }\n/// ```", "```rs\n\nThe user will only see the following:\n\n```", "```rs\n\nHowever, if they click on the Run button, they'll see the following:\n\n```", "```rs\n\n(Don't forget that the `main` function is added as well!).\n\nThat's it for the doc tests. With all this knowledge, you should be able to write a nice API documentation which will always be up to date and tested (hopefully)!\n\n# Fuzzing tests\n\nThere is another type of test that is very useful but is not integrated into the Rust standard library: fuzzing tests.\n\nA fuzzing test will test a function's automatically generated input with the sole purpose of crashing this function or making it behave incorrectly. Fuzzing tests can be used to complement tests that are written manually because they can generate way more input than we can possibly write by hand. We will use `cargo-fuzz` to test our command parser.\n\nFirst, we need to install it:\n\n```", "```rs\n\nNext, we will use the new `cargo fuzz` command to create a new fuzz test crate in our FTP server crate:\n\n```", "```rs\n\nThis generated a few files. The most important of them and the one we will modify, is `fuzz/fuzz_targets/fuzz_target_1.rs`. Let's replace its content with the following:\n\n```", "```rs\n\nSince our crate is a binary instead of a library, we cannot directly import functions from it. So, we use this little trick to get access to the functions we want:\n\n```", "```rs\n\nThe `mod error` is needed because our `cmd` module depends on it. With that sorted, we include the `cmd` module with a macro. This macro will expand to the content of the file, similarly to the `#include` preprocessor directive in `C`. Finally, we have our `test` function:\n\n```", "```rs\n\nHere, we just create a new command from the random input we receive. We ignore the result since there's no way we can possibly check if it is right, except by listing all possibilities (which would make a great unit test). So, if there's a bug in our command parser that causes a panic, the fuzzer could find it.\n\nTo run the fuzzer, issue the following command:\n\n```", "```rs\n\nHere's the output:\n\n```", "```rs\n\nThere's actually a bug in our parser! We can see where, thanks to this line:\n\n```", "```rs\n\nThe corresponding line in the source code is:\n\n```", "```rs\n\nAnd indeed, if the data is empty, this will panic. Let's fix that:\n\n```", "```rs\n\nThe fix is simple: we check if the data is empty, in which case we return an error.\n\nLet's try the fuzzer to see if it can find another bug. Here's the output:\n\n```"]