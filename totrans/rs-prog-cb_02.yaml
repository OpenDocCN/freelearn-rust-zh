- en: Going Further with Advanced Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no doubts as to the difficulties that the Rust language poses to
    the avid learner. However, if you are reading this, you have gone further than
    most and invested the time needed to improve. The language and the way it forces
    you to think about memory is going to introduce new concepts into your programming
    habits. Rust does not necessarily provide new tools to accomplish things, but
    the borrowing and ownership rules help us to concern ourselves more with scopes,
    lifetimes, and freeing memory appropriately, regardless of the language. Hence,
    let''s go deeper into more advanced concepts in Rust in order to complete our
    understanding of the language – when, why, and how to apply concepts such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating meaningful numbers with enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex conditions with pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and transforming sequences efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading memory the unsafe way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared mutable ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References with explicit lifetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing behavior with trait bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with generic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating meaningful numbers with enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums, short for enumerations, are well-known programming constructs that many
    languages feature. These special cases of types allow a number to be mapped to
    a name. This can be used to tie constants together under a single name and lets
    us declare values as variants. For example, we could have pi, as well as Euler's
    number, as variants of an enum, `MathConstants`. Rust is no different, but it
    can go a lot further. Instead of simply relying on *naming numbers*, Rust allows
    enums the same flexibility as other Rust types have. Let's see what this means
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to explore enums:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with `cargo new enums --lib` and open this folder in Visual
    Studio Code, or any IDE of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/lib.rs` and declare an enum containing some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the declaration, we also implement a simple function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we also need to do something with the enum, so let''s implement a dummy
    function called `do_work`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is true until it''s tested! Now, add a number of tests that show the
    powerful matching of enums, starting with the `do_work()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `get_kind()` function, we also require a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In a call to `cargo test` in the root directory of the project, we can observe
    the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how enums work under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enums in Rust encapsulate choices—just as in any language. However, they behave
    similarly to regular structures in a lot of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They can have `impl` blocks for traits and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unnamed and named properties can carry different values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These aspects make them really great candidates for choices of all kinds, be
    it configuration values, flags, constants, or wrapping errors, as we did in *Step
    2*. Typical enums in other languages map a name to a numerical value of your choice,
    but Rust goes one step further. Instead of just numerical values, Rust''s enum
    can have any value and even named properties. Take a look at the definition in
    *Step 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ApplicationError::Code` features two properties, one called `full` and one
    called `short`—assignable just like any other `struct` instance. The second and
    third variations, `Message` and `IOWrapper`, encapsulate another type instance
    entirely, one a `String`, and the other an `std::io::Error`, similar to tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: The additional ability to work in match clauses makes these constructs very
    useful, especially for large code bases where readability is important—an example
    of which can be found in *Step 3*, where we implement a function at the enum's
    type. This function maps explicit enum instances to strings for easier printing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* implements a helper function that provides us with different kinds
    of errors and values to work with, something that we require in *Step 5*, where
    we create two extensive tests of these functions. There, we use the `match` clause
    (which will also be discussed in a later recipe in this chapter) to extract values
    from the errors and match on multiple enum variants in a single arm. Additionally,
    we created a test to show that the `print_kind()` function works by using a `Vec`
    as a stream (thanks to it implementing the `Write` trait).'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to create meaningful numbers with enums. Now,
    let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There is no null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional languages typically don't have a concept of **null** for the simple
    reason that it's always a special case. If you strictly follow functional principles,
    each input must have a workable output—but what is null? Is it an error? Or within
    normal operating parameters, but a negative result?
  prefs: []
  type: TYPE_NORMAL
- en: As a legacy feature, null has been around since C/C++, when a pointer could
    actually point to the (invalid) address, `0`. However, many new languages try
    to move away from that. Rust does not have null, and no return value as a normal
    case with the `Option` type. The case of error is covered by the `Result` type,
    to which we dedicated an entire chapter, [Chapter 5](898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml),
    *Handling Errors and Other Results*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are exploring a built-in library feature, we''ll create several tests
    that cover everything:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using `cargo new not-null --lib` and open the project folder
    using Visual Studio code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start off, let''s see what `unwrap()` does and replace the default test
    in `src/lib.rs` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Option` also wraps values well, and it''s sometimes complicated (or simply
    verbose) to get them out. Here are a number of ways of getting the value out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to their functional origins, where it''s often not important whether one
    works on a single value or a collection, `Option` also behaves like a collection
    in some ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, using the `match` clause on `Option` is very popular and often necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To see it all working, we should also run `cargo test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Options` are, to our initial surprise, an enum. While this almost guarantees
    great `match` compatibility, enums behave a lot like structs in the remaining
    aspects. In *Step 2*, we see that it''s not just a regular enum, but also a typed
    enum—which forces us to add a type declaration to `None` as well. *Step 2* also
    shows ways how to get values out of the `Option` type, with and without panicking.
    `unwrap()` is a popular choice, but it comes with some variations that don''t
    halt the thread if `None` is encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unwrap()` is always a dangerous thing, and should only be used in non-production
    code. It panics, which can bring the entire program to a sudden, unexpected halt,
    and doesn''t even leave you with a proper error message. If stopping the program
    is the desired outcome, `expect()` is a better choice since it lets you add a
    simple message. This is why we added the `#[should_panic]` attribute to the unit
    test, so that we can prove to you that it actually panics (or otherwise the test
    fails).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* shows some non-intrusive ways to *unwrap* the value of `Option`. Especially
    since `unwrap()` returns the owned value while destroying `Option` itself, other
    ways can be more useful if `Option` remains part of a data structure and only
    temporarily holds a value. `take()` was designed for these situations that replace
    the value with `None`, similar to `replace()`, which does the same for the replacement
    value. Furthermore, there is `map()`, which lets you work directly with the value
    (if present) and ignore the usual `if`-then or `match` constructs, which add a
    lot of code verbosity (refer to *step 5*).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* features an interesting tidbit in the middle: `Options` can be used
    like Booleans to perform logic operations, similar to Python, where AND/OR operations
    return a particular operand ([https://docs.python.org/3/reference/expressions.html#boolean-operations](https://docs.python.org/3/reference/expressions.html#boolean-operations))
    in either case. Last but not least, `Options` can also be treated like collections
    using an iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: Rust's options are very versatile and, by looking at the documents ([https://doc.rust-lang.org/std/option/index.html](https://doc.rust-lang.org/std/option/index.html)),
    you can find out many different ways to transform values on the fly without tedious
    guard clauses with `if`, `let`, and `match`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully learned that there is no null in Rust, let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditions with pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the previous recipe, pattern matching is very useful with enums.
    However, there is more! Pattern matching is a construct that originates in functional
    languages and curtails much of the choice between conditional branches and the
    assignment of properties in `struct` that commonly follows. These steps are taken
    at once, reducing the amount of code on the screen and creating something akin
    to a higher-order `switch-case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just a few steps need to be followed in order to learn more about pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new binary project using `cargo new pattern-matching`. This time, we'll
    run an actual executable! Again, open the project using Visual Studio Code or
    another editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s check out literal matching. Just like a `switch-case` statement in other
    languages, each matching arm can match to literals as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, pattern matching is way more powerful than that. For example, tuple
    elements can be extracted and selectively matched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Destructuring** (moving properties out of a `struct` into their own variables)
    is a powerful feature in conjunction with structs and enums. First, this facilitates
    the assigning of multiple variables in a single matching arm to values that are
    assigned to properties at the incoming struct instance. Now, let''s define a few
    structs and enums:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the individual properties can be matched in a destructuring match. Enums
    work just as well—however, be sure to cover all possible variations; the compiler
    will notice (or use the special `_` to match all). Matching is also done from
    top to bottom, so whichever rule applies first will be executed. The following
    snippet matches variations of the structs we just defined. It matches and assigns
    variables if a particular user type and theme is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of the powerful regular matching, a guard can also enforce certain conditions.
    Similar to destructuring, we can add more constraints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, borrowing and ownership has not been a significant concern. However,
    the `match` clauses so far have all taken ownership and transferred it to the
    scope of the matching arm (anything after `=>`), which, unless you return it,
    means that the outside scope cannot do any other work with it. To remedy that,
    references can be matched as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to go full circle, we have not yet matched a particular type of literal:
    the string literal. Due to their heap allocation, they are fundamentally different
    from types such as `i32` or `usize`. Syntactically, however, they don''t look
    different from any other form of matching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s tie it all together and build a `main` function that calls the
    various functions with the right parameters. Let''s begin by printing a few simpler
    matches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can also print the destructured matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, let''s see about guards and literal string matches on UTF symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step again involves running the program. Since this is not a library
    project, the results will be printed on the command line. Feel free to change
    any of the variables in the `main` function to see how it affects the output.
    Here''s what the output *should* be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a peek behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since we came across pattern matching in the Scala programming language,
    we fell in love with its simplicity. As a major pillar of functional programming,
    the technique provides a quick way to transform values in various ways without
    sacrificing Rust's type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal matches in *Steps 2* and *7 *are a great way to save on `if-else`
    chains. However, the most common matching is probably done to unpack `Result`
    or `Option` types for extracting the encapsulated values. While multiple matches
    are only possible using the `|` symbol , there are special operators to match
    to particular variations: `...` denotes a range, while `..` means to skip the
    remaining members of a struct. `_` is almost always a wildcard for ignoring a
    particular thing and, as a `match` clause, it is a catch-all and should be placed
    last. In *Step 3*, we did a lot of unpacking of tuples; we skipped some of the
    matches using an `_` in place of a variable name.'
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, *Step 4* sets up and uses Rust's mechanism to match properties
    inside types when using the `match` clause (also called destructuring). This feature
    supports nesting and lets us pick values and sub-structs out of a complex struct
    instance. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: However, it is often not done with matching on the type and then working with
    the unpacked values only in the match arm. Instead, having the match conditions
    lined up is a much better way to deal with allowed values within types. Rust's
    `match` clause supports guards for exactly that reason. *Step 5* shows what they
    are capable of.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 8* and *9* both then show the use of the previously implemented `match`
    functions. We highly recommend going through some experiments yourself and seeing
    what changes. The typed matching allows for complex architectures without verbose
    safeguards or workarounds, which is exactly what we want!'
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned about complex conditions with pattern matching. Now,
    let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The true power of a great language is the way in which it lets the programmer
    integrate with types in the standard library and around the general ecosystem.
    One way to do this is the iterator pattern: defined by the Gang of Four in their
    book *Design Patterns* (Addison-Wesley Professional, 1994), an iterator is an
    encapsulation of a pointer moving through a collection. Rust provides a range
    of implementations on top of the `Iterator` trait. Let''s see how we can leverage
    that power with only a few lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build an iterator for the linked list we built in an earlier recipe.
    We recommend either using the `Chapter01/testing` project or walking with us through
    construction of the iterator. In case you are too busy for that, the full solution
    can be found in `Chapter02/custom-iterators`. These paths refer to the GitHub
    repository for this book at [https://github.com/PacktPublishing/Rust-Programming-Cookbook](https://github.com/PacktPublishing/Rust-Programming-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterators are typically their own structs and, since there can be different
    types (for example, for returning references instead of owned values), they are
    a good choice architecturally as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the struct for the iterator of `List<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this is only a regular `struct` that lacks everything an iterator should
    have. Their defining nature is a `next()` function that advances the internal
    pointer and returns the value that it just moved off of. In typical Rust fashion,
    the returned value is wrapped in an `Option` that becomes `None` once the collection
    runs out of items. Let''s implement the `Iterator` trait to get all of these features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, we could instantiate `ConsumingListIterator` and pass our own `List`
    instance to it and it would work well. However, that is far from a seamless integration!
    The Rust standard library offers an additional trait to implement `IntoIterator`.
    By implementing this trait''s functions, even a `for` loop knows what to do, and
    it looks just like any other collection and is easily interchangeable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to write a test to prove that everything is working. Let''s
    add this to the existing test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests will show how well this integration works. The `cargo test` command''s
    output demonstrates this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The next section is going to dive deeper into what's happening behind the scenes!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators are a great way of providing advanced capabilities to custom data
    structures. With their simple, unified interface, collection types can be switched
    out easily as well and programmers don't have to get used to new APIs for every
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the `Iterator` trait in *Steps 1* and *2*, it becomes easy to
    provide exactly the desired access level to a collection's elements. In the case
    of this recipe (and similar to `Vec<T>`), it will consume the list entirely and
    remove the items one by one, starting at the front.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 3*, we implement `IntoIterator`, a trait that makes this construct
    available to the `for` loop and other users who call `into_iter()`. Not every
    collection implements this trait to provide multiple different iterators; for
    example, the second iterator of `Vec<T>` is reference-based, and only accessible
    via an `iter()` function on the type. By the way, a reference is a data type,
    just like the actual instance, so it''s all about the type definition in this
    case. These definitions are made inside the trait implementation with the `type
    Item` declaration (so-called **associated types**: [https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html](https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html)).
    These types are called associated types, and can be referenced using `Self::Item`—just
    like generics, but without the added syntax verbosity.'
  prefs: []
  type: TYPE_NORMAL
- en: With these interfaces, you can get access to a large library of functions that
    only assume a working iterator to be present! Check out *Steps 4* and *5* to see
    the implementation and outcome of using the iterator on a newly created list type.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to implement custom iterators. Now, let's move
    on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and transforming sequences efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in the previous recipe we discussed implementing a custom iterator, it's
    now time to make use of the functions they provide. Iterators can transform, filter,
    reduce, or simply convert the underlying elements in a single go, thereby making
    it a very efficient endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create a new project using `cargo new iteration --lib` and add the following
    to the newly created `Cargo.toml` file in the project''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This adds a dependency to the `rand` ([https://github.com/rust-random/rand](https://github.com/rust-random/rand))
    crate to the project, which will be installed upon running `cargo test` the first
    time. Open the entire project (or the `src/lib.rs` file) in Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In four easy steps, we''ll be able to filter and transform collections in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use an iterator, you have to retrieve it first! Let''s do that
    and implement a test that quickly shows how an iterator works on a regular Rust
    `Vec<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With one test added, let''s explore the notion of iterator functions further.
    They are compose able and let you perform multiple steps in a single iteration
    (think of adding more things to a single `for` loop). Additionally, the outcome''s
    type can be completely different from what you started with! Here is another test
    to add to the project that performs some data transformations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final step, let''s also look at some filtering and splitting. These
    have proven to be the most useful in our personal experience—it removes a lot
    of code verbosity. Here is some code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we want to see the examples working! Run `cargo test` to do just
    that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Do you want to know more? Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s iterators are heavily inspired by functional programming languages,
    which makes them very handy to use. As an iterator, every operation is applied
    sequentially one element at a time, but only as far as the iterator is moved forward.
    There are several types of operations shown in this recipe. The most important
    ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map()` operations execute a value or type transformation, and they are very
    common and easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()`, in the same way as many similar operations, executes a predicate
    (a function with a Boolean return value) in order to determine whether an element
    is to be included in the output. Examples are `find()`, `take_while()`, `skip_while()`,
    and `any()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation functions such as `fold()`, `sum()`, `min()`, and `max()` are used
    to reduce the entire iterator's contents into a single object. That could be a
    number (`sum()`) or a hash map (for example, by using `fold()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain()`, `zip()`, `fuse()`, and many more combine iterators so that they
    can be iterated over in a single loop. Typically, we use these if multiple run-throughs
    are otherwise required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This more functional style of programming not only reduces the amount of code
    that has to be written, but also acts as a universal vocabulary: instead of reading
    through the entire `for` loop that pushes items into a previously defined list
    if a condition applies, a function call to `filter()` tells the reader what to
    expect. *Steps 2* and *3* show different function invocations to transform (*Step
    2*) or filter (*Step 3*) collections based on various use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, iterators can be chained together, so a call to `iterator.filter().map().fold()` is
    not unusual and typically quicker to reason about than a loop that does the same
    thing. As the last step, most iterators are collected into their target collection
    or variable type. `collect()` evaluates the entire chain, which means that its
    execution is costly. Since the entire topic is very specific to the tasks at hand,
    check out the code we wrote and the outcomes/invocations to get the most out of
    it. *Step 4* only shows running the tests, but the real story is inside the code.
  prefs: []
  type: TYPE_NORMAL
- en: Done! We've successfully learned how to filter and transform sequences efficiently.
    Move on to the next recipe to learn more!
  prefs: []
  type: TYPE_NORMAL
- en: Reading memory the unsafe way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`unsafe` is a concept in Rust where some compiler safety mechanisms are turned
    off. These **superpowers** bring Rust closer to C''s abilities to manipulate (almost)
    arbitrary parts of the memory. `unsafe` itself qualifies a scope (or function)
    to be able to use these four superpowers (from [https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: Dereference a raw pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call an `unsafe` function or method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access or modify a mutable static variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an unsafe trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most projects, `unsafe` is only required for using the **FFI** (short for
    **Foreign Function Interface**) because it's outside of the borrow checker's reach.
    Regardless, in this recipe, we are going to explore some unsafe ways to read memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In just a few steps, we are `unsafe`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new library project using `cargo new unsafe-ways --lib`. Open the project
    using Visual Studio Code or another editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `src/libr.rs` to add the following function before the test module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With that ready, we now have to add some tests inside `mod tests {}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Recalling the `unsafe` superpowers, we could try and change the way we are
    reading memory. Let''s add this test to see how it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to see the positive test results after running `cargo test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Safety is an important concept in Rust, so let's find out what we trade off
    by using `unsafe`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `unsafe` is one way to enable easier solutions to sometimes tricky situations,
    this book ([https://rust-unofficial.github.io/too-many-lists/index.html](https://rust-unofficial.github.io/too-many-lists/index.html))
    describes the limitations of safe programming perfectly with something as simple
    as a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a safe programming language, which means that the compiler makes sure
    that all the memory is accounted for. Thus, it is impossible for programs to obtain
    multiple mutable references to the same memory address, use memory after it has
    been freed, or incorrect type safety, among other things. This lets Rust avoid
    undefined behavior. For some limited use cases, however, these constraints prohibit
    valid use cases, which is why `unsafe` loosens some of these guarantees to accommodate
    some of the things only C would allow.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the project in *Step 1*, we are adding the first function in
    *Step 2*. Its purpose is similar to `chunks()` ([https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut](https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut)),
    but instead of an iterator, we are returning the entire collection right away,
    which is OK as an example, but should be thought about when implementing it for
    production use. Our function splits a provided (mutable) slice into a `parts`
    number of chunks of equal size and returns mutable references to them. Since the
    input is also a mutable reference to the entire part of the memory, we will have
    `parts + 1` number of mutable references to the same memory area; clearly, a violation
    of safe Rust! On top of that, this function allows going beyond the allocated
    memory with the `ptr.offset()` call (which does pointer arithmetic).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test created in *Step 3*, we show that it compiles and executes without
    any major problems. *Step 4* provides another example for unsafe code: changing
    the data type without casting. The `transmute` ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html))
    function can easily change the data type of a variable with all the consequences
    that come with that. Had we changed the type to something else, such as `u64`,
    we would end up with a totally different result and read memory that does not
    belong to the program. In *Step 5*, we run the whole test suite.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafe` Rust can be interesting to get that last bit of performance out of
    a data structure, do some magic bin-packing, or to implement `Send` and `Sync` ([https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html)).
    Whatever you intend to do with `unsafe`, check out the nomicon ([https://doc.rust-lang.org/nightly/nomicon/](https://doc.rust-lang.org/nightly/nomicon/))
    to delve deeper into the depths.'
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with that knowledge, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Shared ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ownership and borrowing are fundamental concepts in Rust; they are the reason
    no runtime garbage collection is required. As a quick primer: how do they work?
    In short: scopes. Rust (and many other languages) use (nested) scopes to determine
    the validity of a variable, so it cannot be used outside of the scope (like a
    function). In Rust, these scopes *own* their variables, so they will be gone after
    the scope finishes. In order for the program to *move* around values, it can transfer
    ownership to a nested scope or return it to the parent scope.'
  prefs: []
  type: TYPE_NORMAL
- en: For temporary transfers (and multiple viewers), Rust has **borrowing**, which
    creates a reference back to the owned value. However, these references are less
    powerful, and sometimes more complex to maintain (for example, can the reference
    outlive the original value?), and they are probably the reason why the compiler
    complains.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are getting around this problem by sharing ownership using
    a reference counter that only drops the variable after the counter reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `new sharing-ownership --lib`, create a new library project and open the
    directory in your favorite editor. We will also use the `nightly` compiler for
    benchmarks, so running `rustup default nightly` is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: To enable benchmarks, add `#![feature(test)]` to the top of the `lib.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding shared ownership only requires eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fairly young ecosystem that is Rust, APIs and function signatures are
    not always the most efficient, especially when they require somewhat advanced
    knowledge of memory layout. So, consider a simple `length` function (add it to
    the `mod tests` scope):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: While unnecessary, the function requires that you pass your owned variable to
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the `clone()` function is ready for you if you still need ownership
    after the function call. This is similar to a loop, by the way, where ownership
    is moved in the first iteration, which means it is **gone** by the second iteration—leading
    to a compiler error. Let''s add a simple test to illustrate these moves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but creates a lot of clones of a string, only then to drop it shortly
    after. This leads to wasting resources and, with large enough strings, slows down
    the program. To establish a baseline, let''s check this by adding a benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Some APIs require ownership of the input variables without a semantic meaning.
    For example, the `length` function from *Step 1* pretends to require variable
    ownership, but unless mutability is also necessary, Rust''s `std::rc::Rc` (short
    for **Reference Counted**) type is a great choice for avoiding heavyweight cloning
    or taking away ownership from the calling scope. Let''s try it out by creating
    a better `length` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now continue to use the `owned` type after passing it into the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created a baseline benchmark, we certainly want to know how well
    the `Rc` version fares:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we should check whether the implementations are correct by running `cargo
    test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can check which variation is faster, and what the differences are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After we have explored shared ownership with `Rc`, let's go behind the scenes
    to understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The impressive benchmark results are no accident: `Rc` objects are smart pointers
    to locations on the heap, and while we still call clone to do a *deep copy*, `Rc`
    only duplicates a pointer and increments the number of references to it. While
    the actual example function is kept simple so that we don''t have to worry about
    it, it does have all the properties of complex functions we often encounter. We
    define the first version, which only works with owned memory (the input parameter
    is not a reference), in *Step 1*. *Steps 2* and *3* show the consequences of the
    API chosen in *Step 1*: we need to call the clone function if we want to keep
    (a copy of) the data we pass in.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 4* to *6,* we do the equivalent with a Rust construct called `Rc`.
    Having ownership of one of those means that you own the pointer location, but
    not the actual value, which makes the entire construct very lightweight. In fact,
    allocating the memory for the original value once and pointing to it from multiple
    locations is a common way to improve performance in applications that require
    a lot of moving around of a string. This is a result that can be observed in *Steps
    7* and *8*, where we execute tests and benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat remains. `Rc` constructs do not allow for mutable ownership, something
    that we'll solve in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Shared mutable ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing ownership is great for read-only data. However, mutability is sometimes
    required, and Rust provides a great way to achieve this. If you recall the rules
    of ownership and borrowing, if there is a mutable reference, it has to be the
    only reference to avoid anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is typically where the borrow checker comes in: at compile time, it makes
    sure that the condition holds true. This is where Rust introduces the pattern
    of interior mutability. By wrapping the data into a `RefCell` or `Cell`-type object,
    immutable and mutable access can be handed out dynamically. Let''s see how this
    works in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new library project using `cargo new --lib mut-shared-ownership` and
    open `src/lib.rs` in your favorite editor. To enable benchmarks, please switch
    to `nightly` Rust using `rustup default nightly`, and add `#![feature(test)]` (which
    facilitates the use of the types required for benchmark-type tests) at the top
    of the `lib.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a test to establish the best way to share mutable ownership in
    just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a couple of new functions inside the testing module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions dynamically (based on incoming data) mutate a list of integers
    to fit a particular condition (such as the sum needs to be at least *X*) and rely
    on three ways of sharing mutable ownership. Let''s explore how these behave on
    the outside! `Cell` objects (and `RefCell` objects) are simply wrappers that either
    return a reference or ownership of a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this seems very familiar to other programming languages, where references
    can be passed around freely, we should also know the caveats. One important aspect
    is that these `Cell` threads panic if the borrow check fails, which brings the
    current thread at least to a sudden halt. In a few lines of code, this is what
    this looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitively, these cells should add runtime overhead and thereby be slower
    than a regular – precompiled – borrow check. In order to confirm this, let''s
    add a benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we did not address the dangers of unforeseen panics in `Cell`, which
    might be prohibitive in complex applications. This is where `Cow` comes in. `Cow`
    is a **Copy-on-Write** type that replaces the value it wraps by lazily cloning
    if mutable access is requested. By using this `struct`, we can be certain to avoid
    panics with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s verify that the tests and benchmarks are successful by running
    `cargo test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the benchmark timings in the output of `cargo bench`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Sharing memory in various ways is complex, so let's dive deeper into how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is set up like a large benchmark or testing scheme: in *Step 1*,
    we define the functions to be tested, each with different input parameters, but
    the same behavior; it fills `Vec` up to a minimum sum. These parameters reflect
    different ways of sharing ownership, including `RefCell`, `Cell`, and `Cow`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 2* and *3* create tests that work exclusively on the different ways
    adopted by `RefCell` and `Cell` of handling and failing these values. *Step 5*
    does something similar to the `Cow` type; all are great opportunities to test
    out your own theories as well!'
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 4* and *6*, we are creating and running benchmarks and tests on the
    functions we created in this recipe. The results are surprising. In fact, we tried
    different computers and versions and arrived at the same conclusion: `RefCell`
    is almost as fast as the regular way of retrieving a mutable reference (the runtime
    behavior results in a higher variance). The `Cell` parameter's slowdown is also
    expected; they move the entire data in and out at every iteration—and this is
    what we can also expect from `Cow`, so feel free to try it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Both `Cell` objects and `RefCell` objects move the data onto the heap memory
    and use references (pointers) to get to these values, often requiring an extra
    jump. However, they offer a similar way of moving object references around with
    the comfort of C#, Java, or other such languages.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have successfully learned about shared mutable ownership. Now, let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing with explicit lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifetimes are common in many languages and typically decide whether a variable
    is available outside the scope. In Rust, the situation is a bit more complicated
    thanks to the borrowing and ownership model that extensively uses lifetimes and
    scopes to automatically manage memory. Instead of reserving memory and cloning
    stuff into it, we developers want to avoid the inefficiencies and potential slowdowns
    this causes with references. However, this leads down a tricky path because, as
    the original value goes out of scope, what happens to the reference?
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler cannot infer this information from code, you have to help
    it and annotate the code so it can go and check for proper usage. Let's see what
    this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lifetimes can be explored in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using `cargo new lifetimes --lib` and open it in your favorite
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple function that takes in a reference that might not
    outlive the function! Let''s make sure that the function and the input parameter
    are on the same lifetime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the lifetime declaration is required is in structs. Therefore, we define
    the base `struct` first. It comes with a lifetime annotation for the type it contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows is the implementation, which continues the lifetime specifications.
    First, we implement the constructor (`new()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to implement the variance calculation along with the standard
    deviation and the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final operation, we add the median calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it! Some tests are required so that we can be certain everything
    works as expected. Let''s start with a few helper functions and a test for calculating
    the mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we perform some testing on the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s test the actual statistics. In a single function, we are starting
    with some special input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to check more sophisticated input data (for example, skewed distributions
    or edge cases), let''s expand the test further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `cargo test` to run the tests and verify that they are successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Working with lifetimes is complex, so let's go behind the scenes to understand
    the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a simple statistics toolbox that allows normal distribution
    samples to be analyzed quickly and accurately. However, this example was only
    chosen to illustrate the ways of how lifetimes are useful and comparatively simple.
    In *Step 2*, we are creating a function to calculate the mean of a given collection.
    Since lifetimes can be inferred from using the functions/variables, explicit specification
    of the lifetime is optional. Nevertheless, the function explicitly ties the input
    parameter's lifetime to the function's lifetime, requiring any reference that
    is passed in to outlive `mean()`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 3* and *4* show how to deal with lifetimes in structs and their implementations.
    Since type instances can easily outlive the references they store (and each could
    even require a different lifetime), the explicit specification of the lifetimes
    becomes necessary. The lifetimes have to be stated every step of the way; in the
    struct declaration, in the `impl` block, and in the functions they are used with.
    The lifetime''s name binds them together. In a way, it creates a virtual scope
    bound to the type instance''s life.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime annotations are useful but verbose, which makes working with references
    sometimes cumbersome. However, once the annotations are in place, the program
    can be much more efficient and the interfaces can be a lot more convenient, removing
    `clone()` method and other things.
  prefs: []
  type: TYPE_NORMAL
- en: The choice for the lifetime name (`'a`) is common, but arbitrary. Other than
    the predefined `'static`, every word works just as fine and a readable choice
    is definitely better.
  prefs: []
  type: TYPE_NORMAL
- en: Working with explicit lifetimes was not too hard, right? We recommend that you
    keep on experimenting until you are ready to move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing behavior with trait bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a complex architecture, prerequisite behavior is very common.
    In Rust, this means that we cannot build either generic or other types without
    requiring them to conform to some prior behavior, or, in other words, we need
    to be able to specify which traits are required. Trait bounds are one way of doing
    that – and you have seen multiple instances of this already, even if you have
    skipped many recipes so far.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn more about traits:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using `cargo new trait-bounds` and open it in your favorite
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `src/main.rs` to add the following code, where we can easily print a variable''s
    debug format since an implementation of that format is required on compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to call this using a custom type such as `struct AnotherType(usize)`,
    the compiler would quickly complain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fix this, we can either implement or derive the `Debug` trait,
    as it says in the error message. Deriving the implementation is very common for
    compositions of standard types. In traits, the trait bounds get a bit more interesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create and implement a suitable type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s tie the code together in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `cargo run` and establish whether the output matches your expectations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: After creating an example program, let's explore the background for trait bounds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trait bounds specify the requirements of the implementation to implementers.
    In this way, we can call functions on generic types without having a more in-depth
    knowledge of their structures.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we require any parameter type to implement the `std::fmt::Debug`
    trait in order to be able to use the debug formatter for printing. However, that
    does not generalize well, and we have to require that implementation for any *other*
    function as well. That's why, in *Step 4*, we require that any type that implements
    the `Loggable` trait also implements `Debug`.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we can expect to use all the required traits in the trait's functions,
    which makes expansion easier and provides the ability for all types to implement
    the trait to be compatible. In *Step 5* , we are implementing the `Loggable` trait
    for the type we created and using it in the remainder of the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Decisions regarding the required traits are important for public APIs as well
    as for writing well-designed and maintainable code. Being mindful of what types
    are really required and how to provide them will lead to better interfaces and
    types. Notice also the `+` between two type bounds; it requires both (and more
    if more `+` symbols are added) traits to be present when implementing `Loggable`.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to enforce behavior with trait bounds. Now, let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Working with generic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's function overloading is a bit more exotic than in other languages. Instead
    of redefining the same function with a different type signature, you can achieve
    the same result by specifying the actual types for a generic implementation. Generics
    are a great way to provide more general interfaces and are not too complex to
    implement thanks to helpful compiler messages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement a dynamic array (such as `Vec<T>`)
    in a generic way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learn how to use generics in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start off by creating a new library project with `cargo new generics --lib` and
    open the project folder in Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dynamic array is a data structure many of you will use every day. In Rust,
    the implementation is called `Vec<T>`, while other languages know it as `ArrayList`
    or `List`. First, let''s establish the basic structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `struct` definition shows, the main element is a box of type `T`, a
    generic type. Let''s see what the implementation looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, very straightforward. Instead of a type name, we''ll simply use `T`.
    What happens if we wanted to implement a specific type for a generic definition?
    Let''s implement the `Index` operation (a trait in Rust) for the `usize` type. Additionally,
    a `clone` operation will become very helpful in the future, so let''s add that
    too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be certain that all of this works and we did not make any mistakes,
    let''s start with a few tests for each implemented function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some more tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the tests are implemented, we can run the tests successfully with `cargo
    test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at using generics from behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics work very well in Rust and, other than the verbose notation, they are
    very handy. In fact, you will find them all over the place and, as you progress
    in Rust, the need for better, more generic interfaces will increase.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we are creating a modified dynamic array (taken from the book *Hand**s-On
    Data Structures and Algorithms with Rust:* [https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-*rust*](https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust))
    that uses a generic type. Using a generic type in code works like any other type,
    writing `T` instead of `i32`. However, as discussed in a previous recipe, the
    compiler expects certain behaviors from the `T` type, such as implementing `Clone`, which
    is specified in the `where` clause of the struct and implementation. In more complex
    use cases, there could be multiple blocks for when `T` implements `Clone` and
    when it doesn't, but that would go beyond the scope of the recipe. *Step 3* shows
    the generic implementation of the dynamic array type and how the `Clone` and `Sized`
    traits come into play.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the `Index` trait in *Step 4*, something becomes more obvious.
    First, we specify the `usize` type for the trait implementation header. Therefore,
    this trait is only implemented if someone uses a `usize` variable (or constant/literal)
    for indexing, thereby ruling out any negative values. The second aspect is the
    associated type, which, in itself, has a generic type.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of generics is the term `Sized`. Variables in Rust
    are `Sized` when the size is known at compile time, so the compiler knows how
    much memory to allocate. Unsized types have an unknown size at compile time; that
    is, they are dynamically allocated and may grow at runtime. Examples include `str`,
    or slices of type `[T]`. Their actual size can change, which is why they are always
    behind a fixed-size reference, a pointer. If `Sized` is required, only the reference
    to an unsized type can be used (`&str`, `&[T]`), but there is also `?Sized` to
    make this behavior optional.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steps 5* and *6* then create some tests and run them. The tests demonstrate
    that the main functions of the dynamic array continue to work, and we encourage
    you to try out any questions you have about the code in there as well.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want more details on the dynamic array and why/how it grows (it doubles
    in size, like Java's `ArrayList`), check out *Hands-On Data Structures and Algorithms
    with Rust*, where this dynamic array and other data structures are explained in
    more detail.
  prefs: []
  type: TYPE_NORMAL
