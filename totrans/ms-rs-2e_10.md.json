["```rs\n// both_true_false.c\n\nint main(void) {\n    bool var;\n    if (var) {\n        fputs(\"var is true!\\n\");\n    }\n    if (!var) {\n        fputs(\"var is false!\\n\");\n    }\n    return 0;\n}\n```", "```rs\nvar is true\nvar is false\n```", "```rs\n// unsafe_function.rs\n\nfn get_value(i: *const i32) -> i32 { \n    *i\n}\n\nfn main() {\n    let foo = &1024 as *const i32;\n    let _bar = get_value(foo);\n}\n```", "```rs\nunsafe fn get_value(i: *const i32) -> i32 { \n    *i\n}\n```", "```rs\nfn main() {\n    let foo = &1024 as *const i32;\n    let bar = unsafe { get_value(foo) };\n}\n```", "```rs\nfn get_value(i: *const i32) -> i32 { \n    unsafe { \n        *i \n    }\n}\n```", "```rs\n// https://doc.rust-lang.org/src/alloc/string.rs.html#1277-1285\n\npub fn insert(&mut self, idx: usize, ch: char) {\n    assert!(self.is_char_boundary(idx));\n    let mut bits = [0; 4];\n    let bits = ch.encode_utf8(&mut bits).as_bytes();\n    unsafe {\n        self.insert_bytes(idx, bits);\n    }\n}\n```", "```rs\nunsafe_function(4 as *const i32); \n```", "```rs\n// unsafe_trait_and_impl.rs\n\nstruct MyType;\n\nunsafe trait UnsafeTrait { \n    unsafe fn unsafe_func(&self);\n    fn safe_func(&self) {\n        println!(\"Things are fine here!\");\n    }\n}\n\ntrait SafeTrait {\n    unsafe fn look_before_you_call(&self);\n}\n\nunsafe impl UnsafeTrait for MyType {\n    unsafe fn unsafe_func(&self) {\n        println!(\"Highly unsafe\");\n    }\n}\n\nimpl SafeTrait for MyType {\n    unsafe fn look_before_you_call(&self) {\n        println!(\"Something unsafe!\");\n    }\n}\n\nfn main() {\n    let my_type = MyType;\n    my_type.safe_func();\n    unsafe {\n        my_type.look_before_you_call();\n    }\n}\n```", "```rs\n// c_from_rust/mystrlen.c\n\nunsigned int mystrlen(char *str) { \n    unsigned int c; \n    for (c = 0; *str != '\\0'; c++, *str++); \n    return c; \n} \n```", "```rs\n# c_from_rust/Cargo.toml\n\n[build-dependencies]\ncc = \"1.0\"\n```", "```rs\n// c_from_rust/build.rs\n\nfn main() {\n    cc::Build::new().file(\"mystrlen.c\")\n                    .static_flag(true)\n                    .compile(\"mystrlen\");\n}\n```", "```rs\n// c_from_rust/src/main.rs\n\nuse std::os::raw::{c_char, c_uint};\nuse std::ffi::CString; \n\nextern \"C\" { \n    fn mystrlen(str: *const c_char) -> c_uint; \n}\n\nfn main() { \n    let c_string = CString::new(\"C From Rust\").expect(\"failed\"); \n    let count = unsafe { \n        mystrlen(c_string.as_ptr()) \n    }; \n    println!(\"c_string's length is {}\", count);\n}\n```", "```rs\nfn safe_mystrlen(str: &str) -> Option<u32> { \n    let c_string = match CString::new(str) { \n        Ok(c) => c, \n        Err(_) => return None \n    };\n\n    unsafe { \n        Some(mystrlen(c_string.as_ptr())) \n    } \n} \n```", "```rs\n# rust_from_c/Cargo.toml\n\n[package]\nname = \"rust_from_c\"\nversion = \"0.1.0\"\nauthors = [\"Rahul Sharma <creativcoders@gmail.com>\"]\nedition = \"2018\"\n\n[lib]\nname = \"stringutils\"\ncrate-type = [\"cdylib\"]\n```", "```rs\n// rust_from_c/src/lib.rs\n\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\n\n#[repr(C)]\npub enum Order {\n    Gt,\n    Lt,\n    Eq\n}\n\n#[no_mangle]\npub extern \"C\" fn compare_str(a: *const c_char, b: *const c_char) -> Order {\n    let a = unsafe { CStr::from_ptr(a).to_bytes() };\n    let b = unsafe { CStr::from_ptr(b).to_bytes() };\n    if a > b {\n        Order::Gt\n    } else if a < b {\n        Order::Lt\n    } else {\n        Order::Eq\n    }\n}\n```", "```rs\n// rust_from_c/main.c\n\n#include <stdint.h>\n#include <stdio.h>\n\nint32_t compare_str(const char* value, const char* substr);\n\nint main() {\n    printf(\"%d\\n\", compare_str(\"amanda\", \"brian\"));\n    return 0;\n}\n```", "```rs\n# rust_from_c/Makefile\n\nmain:\n    cargo build\n    gcc main.c -L ./target/debug -lstringutils -o main\n```", "```rs\n$ export LD_LIBRARY_PATH=./target/debug\n$ ./main\n```", "```rs\n$ apt-get install llvm-3.9-dev libclang-3.9-dev clang-3.9\n```", "```rs\n# edit_distance/Cargo.toml\n\n[build-dependencies]\nbindgen = \"0.43.0\"\ncc = \"1.0\"\n```", "```rs\n// edit_distance/build.rs\n\nuse std::path::PathBuf;\n\nfn main() {\n    println!(\"cargo:rustc-rerun-if-changed=.\");\n    println!(\"cargo:rustc-link-search=.\");\n    println!(\"cargo:rustc-link-lib=levenshtein\");\n\n    cc::Build::new()\n        .file(\"lib/levenshtein.c\")\n        .out_dir(\".\")\n        .compile(\"levenshtein.so\");\n\n    let bindings = bindgen::Builder::default()\n        .header(\"lib/levenshtein.h\")\n        .generate()\n        .expect(\"Unable to generate bindings\");\n\n    let out_path = PathBuf::from(\"./src/\");\n    bindings.write_to_file(out_path.join(\"bindings.rs\")).expect(\"Couldn't write bindings!\");\n}\n```", "```rs\nprintln!(\"cargo:rustc-rerun-if-changed=.\");\nprintln!(\"cargo:rustc-link-search=.\");\nprintln!(\"cargo:rustc-link-lib=levenshtein\");\n```", "```rs\ncc::Build::new().file(\"lib/levenshtein.c\")\n                .out_dir(\".\")\n                .compile(\"levenshtein\");\n```", "```rs\nlet bindings = bindgen::Builder::default().header(\"lib/levenshtein.h\")\n                                          .generate()\n                                          .expect(\"Unable to generate bindings\");\n```", "```rs\n// edit_distance/src/lib.rs\n\nmod bindings;\n\nuse crate::bindings::levenshtein;\nuse std::ffi::CString;\n\npub fn levenshtein_safe(a: &str, b: &str) -> u32 {\n    let a = CString::new(a).unwrap();\n    let b = CString::new(b).unwrap();\n    let distance = unsafe { levenshtein(a.as_ptr(), b.as_ptr()) };\n    distance\n}\n```", "```rs\n// edit_distance/examples/basic.rs\n\nuse edit_distance::levenshtein_safe;\n\nfn main() {\n    let a = \"foo\";\n    let b = \"fooo\";\n    assert_eq!(1, levenshtein_safe(a, b));\n}\n```", "```rs\n# word_suffix/Cargo.toml\n\n[package]\nname = \"word_suffix\"\nversion = \"0.1.0\"\nauthors = [\"Rahul Sharma <creativcoders@gmail.com>\"]\n\n[dependencies]\npyo3 = \"0.4\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n```", "```rs\n// word_suffix/src/lib.rs\n\n//! A demo python module in Rust that can extract words\n//! from a comma seperated string of words that ends with the given suffix\n\n#[macro_use]\nextern crate pyo3;\nuse pyo3::prelude::*;\n\n/// This module is a python module implemented in Rust.\n#[pymodinit]\nfn word_suffix(_py: Python, module: &PyModule) -> PyResult<()> {\n    module.add_function(wrap_function!(find_words))?;\n    Ok(())\n}\n\n#[pyfunction]\nfn find_words(src: &str, suffix: &str) -> PyResult<Vec<String>> {\n    let mut v = vec![];\n    let filtered = src.split(\",\").filter_map(|s| {\n        let trimmed = s.trim();\n        if trimmed.ends_with(&suffix) {\n            Some(trimmed.to_owned())\n        } else {\n            None\n        }\n    });\n\n    for s in filtered {\n        v.push(s);\n    }\n    Ok(v)\n}\n```", "```rs\nvirtualenv -p /usr/bin/python3.5 test_word_suffix \n```", "```rs\nsource test_word_suffix/bin/activate\n```", "```rs\nsudo apt-get install python3-pip\nsudo pip3 install virtualenv\n```", "```rs\n# word_suffix/main.py\n\nimport word_suffix\n\nprint(word_suffix.find_words(\"Baz,Jazz,Mash,Splash,Squash\", \"sh\"))\n```", "```rs\nnpm install --global neon-cli \n```", "```rs\n native_counter tree\n.\n├── lib\n│   └── index.js\n├── native\n│   ├── build.rs\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── package.json\n└── README.md\n```", "```rs\n# native_counter/native/Cargo.toml\n\n[package]\nname = \"native_counter\"\nversion = \"0.1.0\"\nauthors = [\"Rahul Sharma <creativcoders@gmail.com>\"]\nlicense = \"MIT\"\nbuild = \"build.rs\"\nexclude = [\"artifacts.json\", \"index.node\"]\n\n[lib]\nname = \"native_counter\"\ncrate-type = [\"dylib\"]\n\n[build-dependencies]\nneon-build = \"0.2.0\"\n\n[dependencies]\nneon = \"0.2.0\"\n```", "```rs\n// native_counter/native/src/lib.rs\n\n#[macro_use]\nextern crate neon;\n\nuse neon::prelude::*;\n\nfn count_words(mut cx: FunctionContext) -> JsResult<JsNumber> {\n    let text = cx.argument::<JsString>(0)?.value();\n    let word = cx.argument::<JsString>(1)?.value();\n    Ok(cx.number(text.split(\" \").filter(|s| s == &word).count() as f64))\n}\n\nregister_module!(mut m, { \n    m.export_function(\"count_words\", count_words)?;\n    Ok(())\n});\n```", "```rs\ntext.split(\" \").filter(|s| s == &word).count()\n```", "```rs\n// native_counter/lib/index.js\n\nvar word_counter = require('../native');\nmodule.exports = word_counter.count_words;\n```", "```rs\nneon build\n```", "```rs\n// native_counter/main.js\n\nvar count_words_func = require('.');\nvar wc = count_words_func(\"A test text to test native module\", \"test\");\nconsole.log(wc);\n```", "```rs\nnode main.js\n```"]