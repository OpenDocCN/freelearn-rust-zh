- en: Cargo and Crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust is a rather young language that has been designed from scratch to be a
    practical and useful tool for programmers. This is a great situation to be in:
    there are no legacy applications to care about, and many lessons learned from
    other languages have been incorporated in Rust—especially around tooling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrating and managing third-party packages has been an issue in the past
    for a lot of languages, and there are a few different approaches out there:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NPM**: The package manager for Node, which has been very popular with the
    JavaScript community'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: Enterprise-grade Java package management, based on the XML format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NuGet**: .NET''s package management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyPI**: The Python package index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these has different styles of configuration, naming guidelines, publishing
    infrastructure, features, plugins, and so on. The Rust team learned from all of
    these approaches and built their own version: `cargo`. This chapter will be all
    about the power of `cargo` of how and where to integrate with the wealth of packages
    (called crates) out there. Whether you are working on your own small library or
    you are building a large enterprise-grade system, `cargo` will be a central piece
    of the project. By reading this chapter, you can look forward to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about `cargo`, its configuration, and plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing more about the different types of crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking and test integration done in `cargo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic Rust tooling is composed of three programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo`: The Rust package manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rustc`: The Rust compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rustup`: The Rust toolchain manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most users will never touch (or even see) `rustc` directly, but will usually
    use `rustup` to install it and then let `cargo` orchestrate the compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `cargo` without any arguments reveals the subcommands it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are a few clues here as to what the package manager can do. Other than
    resolving different types of dependencies for projects, it acts as a test runner
    for benchmarks and unit/integration tests, and provides access to registries such
    as `crates.io` ([https://crates.io/](https://crates.io/)). Many of these properties
    can be configured in a `.cargo/config` file in the TOML ([https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))
    syntax, either in your home directory, the project directory, or the hierarchy
    in between.
  prefs: []
  type: TYPE_NORMAL
- en: The individual properties that can be configured can easily evolve over time,
    so we'll focus on some core parts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Local repositories** can be customized with a `paths` property (an array
    of paths) in the root section of the file, whereas any command-line arguments
    for the `cargo new` command can be found in the `[cargo-new]` section of the file.
    If these custom repositories are remote, this can be configured in `[registry]`
    and `[http]` for the `proxy` address and port, custom certificate authority (`cainfo`),
    or high latencies (`timeout`) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are handy configurations for enterprise systems with private repositories,
    or CI builds with shared drives acting as caches. However, there are options to
    **customize the toolchain**, by letting the user provide some configuration in
    a `[target.$triple]` section (for example, `[target.wasm32-unknown-unknown]` to
    customize a Wasm target). Each of those sections contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A `linker` specific to the selected triple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another archiver by customizing `ar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `runner` for running the program and associated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flags for the compiler in `rustflags`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the **build configuration** is set within the `[build]` section, where
    the number of `jobs`, binaries, such as `rustc` or `rustdoc`, the `target` triple,
    `rustflags`, or `incremental` compilation can be set. To learn more about configuring
    `cargo` and to obtain a sample of this configuration, go to [https://doc.rust-lang.org/cargo/reference/config.html](https://doc.rust-lang.org/cargo/reference/config.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections, we are going to explore the core of `cargo`: the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Project configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to recognize a Rust project, `cargo` requires its manifest to be present,
    where most of the other aspects (metadata, source code location, and so on) can
    be configured. Once this has been done, building the project will create another
    file: `Cargo.lock`. This file contains the dependency tree of a project with library
    versions and locations in order to speed up future builds. Both of these files
    are essential to a Rust project.'
  prefs: []
  type: TYPE_NORMAL
- en: The manifest – Cargo.toml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Cargo.toml` file follows—as the name suggests—the TOML structure. It''s
    handwritten and contains metadata about the project as well as dependencies, links
    to other resources, build profiles, examples, and much more. Most of them are
    optional and have reasonable defaults. In fact, the `cargo new` command generates
    the minimal version of a manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are many more sections and properties, and we will present a few important
    ones here.
  prefs: []
  type: TYPE_NORMAL
- en: Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This manifest section is all about metadata for the package, such as name, version,
    and authors, but also a link to the documentation that defaults to the corresponding
    page ([https://docs.rs/](https://docs.rs/)). While many of these fields are there
    to support `crates.io` and display various indicators (categories, badges, repository,
    homepage, and so on), some fields should be filled regardless of whether they
    are published there, such as license (especially with open source projects).
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting section is the metadata table in `package.metadata`, because
    it's ignored by `cargo`. This means that projects can store their own data in
    the manifest for project- or publishing-related properties—for example, for publishing
    on Android's Google Play Store, or information to generate Linux packages.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run `cargo build`, `cargo build --release`, or `cargo test`, `cargo`
    uses profiles to determine individual settings for each stage. While these have
    reasonable defaults, you might want to customize some settings. The manifest provides
    these switches with the `[profile.dev]`, `[profile.release]`, `[profile.test]`,
    and `[profile.bench]` sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These values are the defaults (as of writing this book) and are already useful
    for most users.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably the most important section for most developers. The dependencies
    section contains a list of values that represent crate names on `crates.io` (or
    your configured private registry) as keys along with the version as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the version string, it''s equally possible to provide an inline
    table as a value that specifies optionality or other fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, since this is an object, TOML allows us to use it like a section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since, in the 2018 edition, the `extern` crate declarations inside the `.rs`
    files are optional, renaming a dependency can be done inside the `Cargo.toml`
    specification by using the `package` property. Then, the specified key can become
    an alias for this `package`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Features are crate-specific strings that include or exclude certain features.
    In the case of rand (and some others), `stdweb` is a feature that allows us to
    use the crate in Wasm scenarios by leaving out things that would not compile otherwise.
    Note that these features might be automatically applied when they depend on toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something that needs to be specified via those objects is the dependence on
    a remote Git repository or local path. This is useful for testing a patched version
    of a library locally without publishing it to `crates.io` ([https://crates.io/](https://crates.io/))
    and having it built by `cargo` during the parent''s build phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying versions with `cargo` follows a pattern too. Since any crate is
    encouraged to follow a semantic versioning scheme (`<major>.<minor>.<patch>`),
    there are operators that include or exclude certain versions (and thereby APIs).
    For `cargo`, those operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tilde** (`~`): Only patch increases are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caret** (`^`): No major update will be done (2.0.1 to 2.1.0 is OK, to 3.0.1
    is not!) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wildcard** (`*`): Allows any version, but it can be used to replace a position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operators avoid future dependency headaches and introduce a stable API
    without missing the required updates and fixes.
  prefs: []
  type: TYPE_NORMAL
- en: It isn't possible to publish a crate with wildcard dependencies. After all,
    which version is the target computer supposed to use? This is why `cargo` enforces
    explicit version numbers when running `cargo publish`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to work with purpose-specific dependencies. They can
    either be declared by platform (`[target.wasm32-unknown-unknown]`) or by their
    intention: there is a dependency type, `[dev-dependencies]`, for compiling tests,
    examples, and benchmarks, but there is also a build-only dependency specification,
    `[build-dependencies]`, that will be separated from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the dependencies are specified, they are resolved and looked up to generate
    a dependency tree within the project. This is where the `Cargo.lock` file comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies – Cargo.lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a great quote from the `cargo` FAQ ([https://doc.rust-lang.org/cargo/faq.html](https://doc.rust-lang.org/cargo/faq.html))
    about what the purpose of this file is and what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a Cargo.lock is to describe the state of the world at the time
    of a successful build. It is then used to provide deterministic builds across
    whatever machine is building the project by ensuring that the exact same dependencies
    are being compiled.
  prefs: []
  type: TYPE_NORMAL
- en: This serialized state can easily be transferred across teams or computers. Therefore,
    should a dependency introduce a bug with a patch update, your build should be
    largely unaffected unless you run `cargo update`. In fact, it's recommended for
    libraries to commit the `Cargo.lock` file to version control to retain a stable,
    working build. For debugging purposes, it's also quite handy to streamline the
    dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` supports a wealth of commands that can be extended easily. It deeply
    integrates with the project and allows for additional build scripts, benchmarking,
    testing, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The compile and run commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the main build tool, `cargo` does compile and run by way of creating and
    then executing the output binary (usually found in `target/<profile>/<target-triple>/`).
  prefs: []
  type: TYPE_NORMAL
- en: What if a library written in a different language is required to precede the
    Rust build? This is where build scripts come in. As mentioned in the *Project
    configuration* section, the manifest provides a field called `build` which takes
    a path or name to a `build` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script itself can be a regular Rust binary that generates output in a designated
    folder, and can even have dependencies specified in `Cargo.toml` (`[build-dependencies]`,
    but nothing else). Any required information (target architecture, output, and
    so on) is passed into the program using environment variables, and any output
    for `cargo` is required to have the `cargo:key=value` format. Those are picked
    up by `cargo` to configure further steps. While the most popular is building native
    dependencies, it''s entirely possible to generate code (such as bindings, data
    access classes, and so on) as well. Read more in the `cargo` reference: [https://doc.rust-lang.org/cargo/reference/build-scripts.html](https://doc.rust-lang.org/cargo/reference/build-scripts.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Larger projects will require a more complex structure than a simple `src/`
    folder to contain all the source code, which is why `cargo` provides the option
    to split projects into subprojects, called a workspace. This comes in handy for
    architectural patterns such as microservices (each service could be a project),
    or loosely coupling components (clean architecture). To set this up, place each
    subproject in a subdirectory and create a `Cargo.toml` in the workspace that declares
    its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This applies any commands run at the top level to every crate in the workspace.
    Invoking `cargo test` will run all types of tests and that can take a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As far as commands go, `cargo` supports test and bench to run a crate''s tests.
    These tests are specified in the code by creating a "module" inside a module and
    annotating it with `#[cfg(test)]`. Furthermore, each test also has to be annotated
    with either `#[test]` or `#[bench]`, whereas the latter takes an argument to the
    `Bencher`, a benchmark runner class that allows us to collect stats on each run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `cargo test`, the output is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the tests are importing and calling a function from its parent
    module, called `my_add`. One of the tests even expects a `panic!` (caused by an
    overflow) to be thrown, which is why the `#[should_panic]` annotation has been
    added.
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, `cargo` supports doctests, which is a special form of testing.
    One of the most tedious things when refactoring is updating the examples in the
    documentation which is why they are frequently not working. Coming from Python,
    the doctest is a solution to this dilemma. By running the actual code in a denoted
    example, doctests makes sure that everything that's printed in the documentation
    can be executed—creating a black box test at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Every function in Rust can be annotated using a special docstring—which is used
    to generate the documentation at DOCS.RS ([https://docs.rs/](https://docs.rs/)).
  prefs: []
  type: TYPE_NORMAL
- en: doctests are only available for crates of the library type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This documentation has sections (indicated by a markdown header: `#`), and
    if a particular section is called `Examples`, any contained code will be compiled
    and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add another test to the preceding sample by creating a few lines
    of documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]rust'
  prefs: []
  type: TYPE_NORMAL
- en: /// assert_eq!(ch2::my_add(1, 1), 2);
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE12]
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cargo test` command will now run the code in examples as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For larger tests or black-box tests, it's also possible (and recommended) to
    put the tests into a subfolder of the project, called `tests`. `cargo` will pick
    this up automatically and run the tests accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: On top of tests, other commands are often required (code metrics, linting, and
    so on) and recommended. For that, `cargo` provides a third-party command interface.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party subcommands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` allows the extension of its command-line interface with subcommands.
    These subcommands are binaries that are called when invoking `cargo <command>`
    (for example, `cargo clippy` for the popular linter).'
  prefs: []
  type: TYPE_NORMAL
- en: In order to install a new command (for a particular toolchain), run `cargo +nightly
    install clippy`, which will download, compile, and install a crate called `cargo-clippy`
    and then put it into the `.cargo` directory in your home folder. In fact, this
    will work with any binary that is called `cargo-<something>` and is executable
    from any command line. The `cargo` project keeps an updated list of some useful
    subcommands in the repository at [https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands).
  prefs: []
  type: TYPE_NORMAL
- en: Crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's modules (crates) can easily be packaged and distributed once all the
    compilation and testing is done, regardless of whether they are libraries or executables.
    First, let's take a look at Rust binaries in general.
  prefs: []
  type: TYPE_NORMAL
- en: Rust libraries and binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are executable binaries and libraries in Rust. When these Rust programs
    use dependencies, they rely on the linker to integrate those so it will work on—at
    least—the current platform. There are two major types of linking: static and dynamic—both
    of which are somewhat dependent on the operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, Rust dependencies have two types of linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: Via the `rlib` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: Via shared libraries (`.so` or `.dll`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preference—if a corresponding `rlib` can be found—is to link statically
    and therefore include all dependencies into the output binary, making the file
    a lot larger (to the dismay of embedded programmers). Therefore, if multiple Rust
    programs use the same dependency, each comes with its own built-in version. It's
    all about the context though, since, as Go's success has shown, static linking
    can simplify complex deployments since only a single file has to be rolled out.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are drawbacks to the static linking approach beyond size: for static
    libraries, all dependencies have to be of the `rlib` type, which is Rust''s native
    package format, and cannot contain a dynamic library since the formats (for example,
    `.so` (dynamic) and `.a` (static) on ELF systems) aren''t convertible.'
  prefs: []
  type: TYPE_NORMAL
- en: For Rust, dynamic linking is commonly used for native dependencies, since they
    are usually available in the operating system and don't need to be included in
    the package. The Rust compiler can favor this with a `-C prefer-dynamic` flag,
    which will get the compiler to look for the corresponding dynamic libraries first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therein lies the current strategy of the compiler: depending on the output
    format (`--crate-format= rlib`, `dylib`, `staticlib`, `library`, or `bin`), it
    decides on the best linking type with your influence via flags. However, there
    is a rule that the output cannot statically link the same library twice, so it
    won''t link two libraries with the same static dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the topic, we recommend checking out [https://doc.rust-lang.org/reference/linkage.html](https://doc.rust-lang.org/reference/linkage.html).
    That said, the compiler is usually trustworthy and, unless there is an interoperability
    goal, `rustc` will decide optimally.
  prefs: []
  type: TYPE_NORMAL
- en: Linking and interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust compiles to native code like many other languages, which is great because
    it expands the available libraries and lets you choose the best technology to
    solve a problem. "Playing nice with others" has always been a major design goal
    of Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interoperability on that level is as simple as declaring the function that
    you want to import and dynamically linking a library that exports this function.
    This process is largely automated: the only thing required is to create and declare
    a build script that compiles the dependency and then tells the linker where the
    output is located. Depending on what type of library you built, the linker does
    what is necessary to include it into the Rust program: static or dynamic linking
    (the default).'
  prefs: []
  type: TYPE_NORMAL
- en: If there is only one native library that is to be linked dynamically, the manifest
    file offers a `links` property to specify that. Programmatically, it's very easy
    to interact with these included libraries by using the Foreign Function Interface.
  prefs: []
  type: TYPE_NORMAL
- en: FFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Foreign Function Interface** (**FFI**) is Rust''s way of calling into
    other native libraries (and vice versa) using a simple keyword: `extern`. By declaring
    an `extern` function, the compiler knows that, either an outside interface needs
    to be bound via the linker (import) or, that the declared function is to be exported
    so other languages can make use of it (export).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the keyword, the compiler and linker have to get a hint of what
    type of binary layout is expected. That''s why the usual `extern` declaration
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows a `C` library function to be called from within Rust. However,
    there''s one caveat: the calling part has to be wrapped in an `unsafe` section.
    The Rust compiler cannot guarantee the safety of an external library so it makes
    sense to be pessimistic about its memory management. The exported function is
    safe, and by adding the `#[no_mangle]` attribute, there is no name mangling, so
    it can be found using its name.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use libraries for specialized algorithms available in a C/C++ library,
    there is a tool that generates suitable structures, `extern "C"` declarations,
    and data types, called `rust-bindgen`. Find out more at [https://github.com/rust-lang-nursery/rust-bindgen](https://github.com/rust-lang-nursery/rust-bindgen).
    These interoperability capabilities make Rust code available to legacy software
    or for use in a vastly different context, such as web frontends.
  prefs: []
  type: TYPE_NORMAL
- en: Wasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wasm**, which **WebAssembly** is now commonly called, is a binary format
    meant to complement JavaScript that Rust can be compiled to. The format is designed
    to run as a stack machine inside several sandboxed execution environments (such
    as web browsers, or the Node.js runtime) for performance-critical applications
    ([https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)).
    While this is—as of this writing—in its early stages, Rust and the Wasm target
    have been used in real-time frontend settings (such as browser games), and in
    2018 there was a dedicated working group seeking to improve this integration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other targets, such as ARM, the Wasm target is an LLVM (the compiler
    technology Rust is built on) backend so it has to be installed using `rustup target
    add wasm32-unknown-unknown`. Furthermore, it isn''t necessary to declare the binary
    layout (the `"C"` in `extern "C"`) and a different bindgen tool does the rest:
    `wasm-bindgen`, available at [https://github.com/rustwasm/wasm-bindgen](https://github.com/rustwasm/wasm-bindgen).
    We highly recommend reading the documentation for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: The main repository – crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `crates.io` website ([https://crates.io/](https://crates.io/)) provides
    a huge repository of crates to be used with Rust. Along with discoverability functions,
    such as `tags` and `search`, it allows Rust programmers to offer their work to
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository itself provides APIs to interact with and a wealth of documentation
    pointers for `cargo`, crates in general, and so on. The source code is available
    on GitHub—we recommend checking out the repository for more information: [https://github.com/rust-lang/crates.io](https://github.com/rust-lang/crates.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For developers to get their crate into this repository, `cargo` harbors a command:
    `cargo publish`. The command is actually doing more things behind the scenes:
    first it runs the `cargo` package to create a `*.crate` file that contains everything
    that is uploaded. Then it verifies the contents of the package by essentially
    running `cargo test` and checks whether there are any uncommitted files in the
    local repository. Only if these checks pass does `cargo` upload the contents of
    the `*.crate` file to the repository. This requires a valid account on `crates.io`
    (available with your GitHub login) to acquire your personal secret API token,
    and the crate has to follow certain rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previously-mentioned Wasm target, it''s even possible to publish Rust
    packages to the famous JavaScript package repository: `npm` Keep in mind that
    Wasm support is still very new, but once a crate compiles to Wasm it can be packed
    into an `npm` package using Wasm-pack: [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack).'
  prefs: []
  type: TYPE_NORMAL
- en: '`crates.io` aspires to be a permanent storage for Rust crates, so there is
    no "unpublish" button. Versions can be yanked with `cargo yank`, but this won''t
    delete any code; it will just prohibit updates to this particular version. Additionally
    there can be team structures, colorful READMEs, badges, and so on, on your repository''s
    site and we highly recommend you check out the docs on that as well: [https://doc.rust-lang.org/cargo/reference/publishing.html](https://doc.rust-lang.org/cargo/reference/publishing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cargo` is Rust''s package manager and build tool that is configurable with
    a manifest called `Cargo.toml`. The file is used by `cargo` to build the desired
    binary with the specified dependencies, profiles, workspaces, and package metadata.
    During this process, the package state is saved in a file called `Cargo.lock`.
    Thanks to its LLVM frontend, Rust compiles to native code on various platforms
    including the web (using Wasm)—thus keeping a high degree of interoperabilty.
    Successfully-built packages can be published on a repository called `crates.io`,
    a website that is a central hub for available Rust libraries and binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into data structures (starting with lists), the next chapter
    will introduce the ways Rust stores variables and data in memory, whether to copy
    or to clone, and what sized and unsized types are.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does `cargo` do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does `cargo` provide linting support?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In which cases is the `Cargo.lock` file important to publish?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the requirements to publish to `crates.io`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Wasm and why should you care?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are tests organized in a Rust project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://crates.io](https://crates.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/rustwasm/team](https://github.com/rustwasm/team)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webassembly.org](https://webassembly.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
