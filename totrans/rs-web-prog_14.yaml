- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Exploring the Tokio Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Tokio框架
- en: So far in this book, we have been building web apps using frameworks and packaging
    them in Docker to be deployed on a server. Building standard servers is useful
    and will enable us to solve a range of problems. However, there will come a point
    in your web development career where a standard REST API server will not be the
    best solution. It is useful to reach for another tool to implement more custom
    solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直在使用框架构建Web应用，并将它们打包在Docker中以部署到服务器上。构建标准服务器是有用的，这将使我们能够解决一系列问题。然而，在你的Web开发生涯中，某个时刻，标准的REST
    API服务器可能不再是最佳解决方案。寻找另一个工具来实现更定制的解决方案是有用的。
- en: In this chapter, we will explore the **Tokio** framework to enable async programming.
    We will then use the Tokio runtime to build safe custom async systems, by sending
    messages to async code blocks using channels. These messages can even be sent
    over different threads. We will then facilitate async solutions to complex problems
    by implementing the actor model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索**Tokio**框架以实现异步编程。然后，我们将使用Tokio运行时通过使用channels向异步代码块发送消息来构建安全的自定义异步系统。这些消息甚至可以发送到不同的线程。然后，我们将通过实现actor模型来促进对复杂问题的异步解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the Tokio framework for async programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异步编程的Tokio框架
- en: Working with workers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用workers进行工作
- en: Exploring the actor model for async programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异步编程的actor模型
- en: Working with channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用channels进行工作
- en: Working with actors in Tokio
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Tokio中使用actors
- en: By the end of this chapter, you will be able to create async programs that solve
    complex problems using the actor model. Your async program will not need any external
    infrastructure such as a database, and the implementation of our async program
    will be safe and isolated because you will be able to pass data around your system
    and threads using channels. You will be able to understand and implement the building
    blocks of highly concurrent async programs and network applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建使用actor模型解决复杂问题的异步程序。你的异步程序不需要任何外部基础设施，例如数据库，并且我们的异步程序实现将是安全和隔离的，因为你将能够通过channels在你的系统和线程之间传递数据。你将能够理解和实现高度并发异步程序和网络应用的构建块。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, no previous code is needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，不需要任何之前的代码。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter14)找到。
- en: Exploring the Tokio framework for async programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索异步编程的Tokio框架
- en: 'Before we explore what Tokio is and how it works, we should try to execute
    some async code in normal Rust. Throughout this chapter, we will be building a
    basic simulation using Tokio. Therefore, the Tokio code that we will be writing
    is in the `simulation` directory as its own Cargo project. Seeing as we are running
    `async` functions in our Rust server code to process views, we can see if we can
    execute a basic `async` function in our `main` function in the `main.rs` file
    with the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Tokio是什么以及它是如何工作之前，我们应该尝试在正常的Rust中执行一些异步代码。在本章中，我们将构建一个基本的模拟使用Tokio。因此，我们将要编写的Tokio代码位于`simulation`目录中，作为一个独立的Cargo项目。鉴于我们在Rust服务器代码中运行`async`函数来处理视图，我们可以尝试在`main.rs`文件中的`main`函数中执行一个基本的`async`函数，以下代码如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This looks simple enough; however, if we try to run our `main` function, we
    get the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单；然而，如果我们尝试运行我们的`main`函数，我们会得到以下输出：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we are reminded that our `async` function is a `Hello, world!` message
    because we did not wait for the `hello` function to execute. However, if we implement
    `await` on our `hello` function, we will get the following error:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们被提醒我们的`async`函数是一个`Hello, world!`消息，因为我们没有等待`hello`函数执行。然而，如果我们对`hello`函数实现`await`，我们会得到以下错误：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `main` function is not `async`. If we try to turn our `main` function into
    an `async` function, we get a very clear error message that the `main` function
    is not allowed to be `async`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数不是`async`的。如果我们尝试将我们的`main`函数转换为`async`函数，我们会得到一个非常清晰的错误消息，指出`main`函数不允许是`async`的。'
- en: 'We could implement our own structs that implement a `Future` trait and then
    create our own poll method. However, creating our own futures from scratch would
    be excessive for the context of this book, as this book is not dedicated to async
    Rust. Luckily, the Tokio framework comes to the rescue by turning our `main` runtime
    function into an `async` runtime function. To run our `hello` function, we first
    need to add Tokio to our `Cargo.toml` file with the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自己实现实现`Future`特质的struct，然后创建我们自己的poll方法。然而，从头开始创建自己的future对于本书的上下文来说过于繁琐，因为本书不是专门关于异步Rust的。幸运的是，Tokio框架通过将我们的`main`运行时函数转换为异步运行时函数来提供帮助。要运行我们的`hello`函数，我们首先需要将Tokio添加到我们的`Cargo.toml`文件中，以下代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then import the following Tokio macro and `Error` struct in our `main.rs`
    file to enable an async runtime:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`main.rs`文件中导入以下Tokio宏和`Error`结构体，以启用异步运行时：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then apply our Tokio macro to make our `main` function async and execute
    our `hello` function with the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以应用我们的Tokio宏来使`main`函数异步执行，并使用以下代码执行`hello`函数：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can see that we are either returning a `Result` with an empty tuple,
    which is the same as `None` or `Void` in other languages, or an error. If we return
    an error, we return a struct that implements the `Error` trait that is on heap
    memory due to the `Box` notation. When we run our program now, we will get the
    `hello world` message. From this, we can deduce that our program is blocked until
    the `hello` function has executed. However, the preceding code requires us to
    return something, and there is a bit of boilerplate code in the definition. If
    we drop all imports, we can have the following simpler `main` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们要么返回一个包含空元组的`Result`，这在其他语言中与`None`或`Void`相同，要么返回一个错误。如果我们返回一个错误，我们返回一个实现`Error`特质的struct，它由于`Box`表示法而位于堆内存中。现在我们运行我们的程序，我们将得到`hello
    world`消息。从这个结果中，我们可以推断出我们的程序在`hello`函数执行完毕之前是被阻塞的。然而，前面的代码要求我们返回某些内容，并且在定义中有一点点样板代码。如果我们删除所有导入，我们可以得到以下更简单的`main`函数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we can see that we are not having to bother with `return` definitions,
    and we can do whatever we want in the last statement of the `main` function. We
    still block the thread on `await`, as we can see with the following printout:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们不需要烦恼于`return`定义，我们可以在`main`函数的最后一个语句中做任何我们想做的事情。我们仍然在`await`上阻塞线程，正如以下打印输出所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have got basic `async` functions running in Tokio, we can do an
    experiment. We can run multiple `async` functions and wait for them with the following
    code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Tokio中运行了基本的异步函数，我们可以进行一个实验。我们可以运行多个异步函数，并使用以下代码等待它们：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this code will give the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see that the operations are executed in the order `main` is executed.
    This means that when we use `await` to wait on a future to complete, the runtime
    is blocked until the future has completed. Even though the `two` future was defined
    before the `three` future, the `three` future executes before the `two` future
    because the `three` future was awaited before the `two` future.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到操作是按照`main`函数执行的顺序进行的。这意味着当我们使用`await`等待一个future完成时，运行时会阻塞，直到future完成。即使`two`
    future在`three` future之前定义，`three` future也会在`two` future之前执行，因为`three` future在`two`
    future之前被await。
- en: 'So what? What’s the big deal? If our `async` functions are blocking the runtime,
    then why don’t we just define normal functions? We can do one last experiment
    to get to know Tokio: the standard sleep test. First, we need to import the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是什么？这有什么大不了的？如果我们的异步函数阻塞了运行时，那么我们为什么不去定义普通的函数呢？我们可以进行最后一个实验来了解Tokio：标准的睡眠测试。首先，我们需要导入以下内容：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then redefine our `hello` function to sleep for 5 seconds before printing
    out to the terminal with the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重新定义我们的`hello`函数，使其在打印到终端之前暂停5秒钟，以下代码：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then spawn Tokio tasks when waiting for our futures to execute in our hello
    function. We spawn a Tokio task using `tokio::spawn`. A Tokio task is a light
    weight, non-blocking unit of execution. While Tokio tasks are like OS threads,
    they are not managed by the OS scheduler but by the Tokio runtime instead. The
    Tokio task spawned is run on a thread pool. The spawned task could correspond
    to a thread, but it could also not. It is up to the Tokio runtime. We spawn our
    tasks with the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在hello函数中等待未来执行时，会生成Tokio任务。我们使用`tokio::spawn`生成一个Tokio任务。Tokio任务是一个轻量级、非阻塞的执行单元。虽然Tokio任务类似于操作系统线程，但它们不是由操作系统调度器管理，而是由Tokio运行时管理。生成的Tokio任务在线程池上运行。生成的任务可能对应于一个线程，也可能不对应。这取决于Tokio运行时。我们使用以下代码生成任务：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If our futures block the entire runtime, then the time elapsed will be 15 seconds.
    However, running our program will give us the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的未来阻塞了整个运行时间，那么经过的时间将是15秒。然而，运行我们的程序将给出以下输出：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see that there is some asynchronous order in which the futures
    can be executed. However, the total time is 5 seconds because they are running
    concurrently. Again, at face value, this does not seem too impressive. However,
    this is where it gets exciting. The super smart people building Tokio keep track
    of threading using polling. This is where the Tokio runtime keeps checking to
    see if a future has executed by polling a bit of memory. Because of polling, checking
    up on threads does not take a lot of resources. Because checking up on threads
    does not take a lot of resources, Tokio can literally keep millions of tasks open.
    If there is an `await` instance in the thread and it is blocking the runtime of
    that thread, Tokio will merely switch over to another thread and start executing
    the new thread. A future running in the background would occasionally poll the
    task executor end query if there is a result or not. As a result, Tokio is powerful,
    and therefore we used Tokio as a runtime for our Actix Web server when exploring
    Actix in [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP Requests*.
    Getting to know Tokio will enable us to build our own networking applications
    at a lower level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到未来执行存在某种异步顺序。然而，总时间是5秒，因为它们是并发运行的。再次强调，从表面上看，这似乎并不太令人印象深刻。然而，这正是令人兴奋的地方。构建Tokio的超级聪明的人们通过轮询来跟踪线程。这就是Tokio运行时不断检查未来是否通过轮询一小部分内存来执行的地方。由于轮询，检查线程并不需要很多资源。因为检查线程不需要很多资源，Tokio实际上可以保持数百万个任务开启。如果线程中有一个`await`实例并且它阻塞了该线程的运行时，Tokio将简单地切换到另一个线程并开始执行新线程。在后台运行的未来会偶尔轮询任务执行器以查询是否有结果。因此，Tokio非常强大，这就是为什么我们在探索Actix时使用Tokio作为我们的Actix
    Web服务器的运行时，如[*第3章*](B18722_03.xhtml#_idTextAnchor059)中所述，*处理HTTP请求*。了解Tokio将使我们能够以较低级别构建自己的网络应用程序。
- en: While spinning off multiple threads using Tokio is exciting, we must explore
    the trade-offs of working with multiple workers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Tokio生成多个线程很令人兴奋，但我们必须探索与多个工作者协同工作的权衡。
- en: Working with workers
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与工作者协同工作
- en: 'When it comes to defining workers, we can augment the Tokio runtime macro with
    the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义工作者时，我们可以使用以下代码增强Tokio运行时宏：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we can see that we state that the runtime is multithreaded, and we have
    four worker threads. Workers are essentially processes that run in constant loops.
    Each worker consumes tasks through a channel, putting them in a queue. The worker
    then works through the tasks, executing them in the order received. If a worker
    has finished all the tasks, it will search other queues belonging to other workers,
    stealing tasks if they are available, as seen here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们声明运行时是多线程的，并且我们有四个工作者线程。工作者本质上是在循环中运行的进程。每个工作者通过一个通道消耗任务，将它们放入队列中。然后工作者通过任务工作，按照接收的顺序执行它们。如果一个工作者完成了所有任务，它将搜索其他工作者的队列，如果可用，就会窃取任务，就像这里看到的那样：
- en: '![Figure 14.1 – Worker event loops (Work stealing runtime. By Carl Lerche –
    License MIT: https://tokio.rs/blog/2019-10-scheduler#the-next-generation-tokio-scheduler)](img/Figure_14.1_B18722.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 工作者事件循环（工作窃取运行时。由卡尔·勒奇创作 – 许可证MIT：https://tokio.rs/blog/2019-10-scheduler#the-next-generation-tokio-scheduler）](img/Figure_14.1_B18722.jpg)'
- en: 'Figure 14.1 – Worker event loops (Work stealing runtime. By Carl Lerche – License
    MIT: https://tokio.rs/blog/2019-10-scheduler#the-next-generation-tokio-scheduler)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 工作者事件循环（工作窃取运行时。由卡尔·勒奇创作 – 许可证MIT：https://tokio.rs/blog/2019-10-scheduler#the-next-generation-tokio-scheduler）
- en: 'Now that we know we can alter the number of workers, we can test how the number
    of worker threads affects how our runtime. First, we must change our `hello` function
    to sleep for only 1 second at a time. We then loop through a range of numbers
    where we spawn a task for each iteration of that range, pushing the handle of
    the spawned task to a vector. We then await all the futures in the vector with
    the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以改变工作线程的数量，我们可以测试工作线程的数量如何影响我们的运行时间。首先，我们必须将我们的`hello`函数改为每次只休眠1秒钟。然后，我们遍历一系列数字，为该范围的每次迭代生成一个任务，将生成任务的句柄推送到一个向量中。然后，我们使用以下代码等待向量中的所有future：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could keep running the program with a different number of worker threads
    to see how the number of threads affects the time taken. To save you time, this
    has been done, providing the graph shown in *Figure 14**.2*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行程序，使用不同数量的工作线程来查看线程数量如何影响所需时间。为了节省您的时间，这已经完成，提供了*图14.2*所示的图表：
- en: '![Figure 14.2 – Time versus the number of workers](img/Figure_14.2_B18722.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 时间与工作线程数量的关系](img/Figure_14.2_B18722.jpg)'
- en: Figure 14.2 – Time versus the number of workers
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 时间与工作线程数量的关系
- en: We can see that the first four workers have a big effect on the overall time
    of the program. However, the returns sharply diminish as we increase the number
    of workers to more than four. This might be different for you. I got this graph
    because my computer that is running our program has four cores. It is advised
    that we have one worker thread per core.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，前四个工作线程对程序的整体时间有重大影响。然而，当我们增加工作线程数量超过四个时，回报急剧减少。这可能因人而异。我得到这张图表是因为运行我们程序的计算机有四个核心。建议我们有一个工作线程对应一个核心。
- en: We have now managed to speed up our program using Tokio worker threads. We have
    also gotten a deeper appreciation for the trade-off of worker threads and how
    they process tasks. However, what advantage is there to understanding this? We
    could just use a higher-level framework like Actix Web or Rocket to concurrently
    handle API endpoints. Yes, higher-level frameworks are useful and do solve a problem,
    but these are just one solution to the problems. In the next section, we will
    cover the actor model as this is an asynchronous solution that can run in a program
    or a web server depending on your needs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地使用Tokio工作线程加快了我们的程序。我们也更深入地理解了工作线程的权衡以及它们如何处理任务。然而，理解这一点有什么优势呢？我们完全可以使用像Actix
    Web或Rocket这样的高级框架来并发处理API端点。是的，高级框架很有用，确实解决了问题，但这些只是问题的一个解决方案。在下一节中，我们将介绍演员模型，因为这是一个异步解决方案，可以根据您的需求在程序或Web服务器中运行。
- en: Exploring the actor model for async programming
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索异步编程的演员模型
- en: If you have coded complex solutions to complex problems before in an object-oriented
    fashion, you will be familiar with objects, attributes, and class inheritance.
    If you are not familiar, do not worry—we are not going to implement them in this
    chapter. However, it is advised that you read up on the concepts of object-oriented
    programming to gain a full appreciation for the actor model.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前以面向对象的方式编写过解决复杂问题的复杂代码，您将熟悉对象、属性和类继承。如果您不熟悉，请不要担心——我们不会在本章中实现它们。然而，建议您阅读面向对象编程的概念，以全面理解演员模型。
- en: 'For objects, we have a range of processes and an encapsulated state around
    those processes, which can be attributes of the object. Objects are useful for
    compartmentalizing logic and state around a concept or process. Some people merely
    see objects as a tool to reduce repeated code; however, objects can be used as
    interfaces between modules or can be used to orchestrate processes. Objects are
    the cornerstone of many complex systems. However, when it comes to asynchronous
    programming, objects can get messy—for instance, when we have two objects referencing
    data from another object or in general when we have shared common resources between
    objects, modifying them simultaneously, as seen in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象，我们有一系列进程和围绕这些进程的封装状态，这些状态可以是对象的属性。对象对于将逻辑和状态封装在概念或进程周围非常有用。有些人仅仅把对象看作是减少重复代码的工具；然而，对象可以用作模块之间的接口，或者可以用作编排进程。对象是许多复杂系统的基石。然而，当涉及到异步编程时，对象可能会变得复杂——例如，当我们有两个对象引用另一个对象的数据时，或者在一般情况下，当我们有对象之间的共享资源时，同时修改它们，如以下图表所示：
- en: '![Figure 14.3 – Objects and async](img/Figure_14.3_B18722.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 对象和异步](img/Figure_14.3_B18722.jpg)'
- en: Figure 14.3 – Objects and async
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 对象和异步
- en: In this diagram, we can imagine a system where *Object C* is keeping track of
    investments. We have a rule coded into *Object C* that we do not spend over £50\.
    However, *Object A* and *Object B* are both performing processes that invest in
    different stocks. For a range of reasons, from network latency to maybe different
    price calculation strategies, the processes for deciding to invest in a stock
    can vary. Even though both *Object A* and *Object B* get approved by getting the
    total amount already invested from *Object C*, *Object B* places the order first
    due to *Object B*’s process finishing first. So, when *Object A* finishes its
    process and places an order, it could tip our total investment over £50\. This
    is a data race problem. We can potentially spend over our investment budget because
    two competing investment executions are operating too close to each other. When
    we consider that we could be keeping track of potentially hundreds of positions,
    it will become certain that data races will end up breaking the rules of our strategy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以想象一个系统，其中*对象C*正在跟踪投资。我们在*对象C*中编码了一个规则，即我们不花费超过50英镑。然而，*对象A*和*对象B*都在执行不同的股票投资过程。由于各种原因，从网络延迟到可能的不同价格计算策略，决定投资股票的过程可能会有所不同。尽管*对象A*和*对象B*都通过从*对象C*获取已投资总额获得批准，但由于*对象B*的过程先完成，所以*对象B*首先下单。因此，当*对象A*完成其过程并下单时，它可能会使我们的总投资超过50英镑。这是一个数据竞争问题。我们可能会因为两个竞争的投资执行过于接近而超出投资预算。当我们考虑到我们可能需要跟踪数百个头寸时，数据竞争最终会破坏我们策略的规则。
- en: 'To solve the data race problem, we could implement a database, or try to keep
    an eye on all the threads running to implement locks in the form of Mutexes, RwLocks,
    and so on. However, the database solution requires more memory, infrastructure,
    and code to handle the data. The data is also persisted when the program has been
    shut down, which adds to the complexity of the management. The locking system
    and keeping track of common shared resources also introduce potential bugs and
    excessive complexity for the simple problem that we have defined. This is where
    actors come in. Actors are essentially units of computation with their own state.
    However, it must be noted that actors are not free; they require heavier RAM usage.
    Also, actors can die, which will also kill their state, so database backups can
    be helpful to persist the state if and when actors die. Actors only communicate
    through channels using messages. These messages are queued and then processed
    in the order the messages were sent. This gives us the following system dynamic:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决数据竞争问题，我们可以实现一个数据库，或者尝试监控所有运行的线程以实现互斥锁、读写锁等形式。然而，数据库解决方案需要更多的内存、基础设施和代码来处理数据。当程序关闭时，数据也会被持久化，这增加了管理的复杂性。锁定系统和跟踪共享资源也可能引入潜在的错误和过度复杂性，这对于我们定义的简单问题来说是不必要的。这就是演员发挥作用的地方。演员本质上是有自己状态的计算单元。然而，必须注意的是，演员不是免费的；它们需要更多的RAM使用。此外，演员可能会死亡，这也会导致它们的状态消失，因此数据库备份可以在演员死亡时帮助持久化状态。演员只通过通道使用消息进行通信。这些消息被排队，然后按照消息发送的顺序进行处理。这给我们带来了以下系统动态：
- en: '![Figure 14.4 – Actors and async](img/Figure_14.4_B18722.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 演员和异步](img/Figure_14.4_B18722.jpg)'
- en: Figure 14.4 – Actors and async
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 演员和异步
- en: Here, we can see that *Actor C* accepts messages and places an order if we have
    not exceeded our investment budget. We can have hundreds of actors sending buy-and-sell
    messages to *Actor C* and still be confident that the budget would not be exceeded.
    Our system does not get increasingly complicated as we add more actors. There
    is nothing stopping us from getting our *Actor C* to send messages to other actors
    to stop or increase the number of buy-or-sell positions, depending on the current
    state of our investment budget.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，如果我们没有超过我们的投资预算，*演员C*会接受消息并下单。我们可以让数百个演员向*演员C*发送买卖消息，同时仍然有信心不会超过预算。随着我们添加更多的演员，我们的系统并不会变得越来越复杂。没有任何东西阻止我们让*演员C*向其他演员发送消息，以根据我们投资预算的当前状态停止或增加买卖头寸的数量。
- en: 'To build more complex systems, you must be familiar with the following terms:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的系统，你必须熟悉以下术语：
- en: '**Actor**: A unit of work that can contain state and modifies that state by
    processing messages it receives. You never have reference to an actor state or
    actor directly.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员**：一个可以包含状态并通过处理接收到的消息来修改该状态的作业单元。你永远不会直接引用演员状态或演员。'
- en: '**Actor reference**: A handle to an actor. This allows you to send the actor
    messages without knowing its implementation type or location on the network. All
    I need to know is that if we send a message to an actor, we get *X* back. We do
    not need to know if the actor is local somewhere else.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**actor引用**：对actor的引用。这允许你发送消息给actor，而无需知道其实现类型或网络上的位置。我所需要知道的是，如果我们向actor发送消息，我们会得到*X*。我们不需要知道actor是否在某个地方是本地的。'
- en: '**Actor system**: A collection of actors that exist inside a single process
    and communicate via in-memory message passing.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**actor系统**：存在于单个进程内的actor集合，通过内存消息传递进行通信。'
- en: '**Cluster**: A collection of networked actor systems whose actors communicate
    via TCP message passing.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群**：网络化actor系统的集合，其actor通过TCP消息传递进行通信。'
- en: What makes this exciting is that we can achieve asynchronism without having
    to rely on a database or on keeping track of threads. We can run it all in our
    Tokio runtime in one static binary! This is very powerful. However, there is nothing
    stopping us from using the actor model on a microservices-cluster scale in the
    form of nanoservices. At the time of writing this book, nano services are lightly
    written about and used by some companies such as Netflix. However, with what we
    have explored with Rust and distroless containers, we can deploy Rust servers
    into a cluster at 50 MB a server. With what we have covered so far in this book,
    there is nothing stopping you from pushing the boundaries and building nano services,
    and implementing the actor model using nano services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 令人兴奋的是，我们可以实现异步操作，而无需依赖于数据库或跟踪线程。我们可以在Tokio运行时中运行所有操作，只需一个静态二进制文件！这非常强大。然而，没有任何阻止我们在微服务集群规模上以纳米服务的形式使用actor模型。在撰写本书时，纳米服务被轻描淡写地提及，并被一些公司如Netflix所使用。然而，通过我们在Rust和distroless容器中探索的内容，我们可以将Rust服务器部署到集群中，每个服务器只需50
    MB。根据本书到目前为止所涵盖的内容，没有任何阻止您推动边界并构建纳米服务，以及使用纳米服务实现actor模型。
- en: 'The actor model is being used in a lot of IoT devices and real-time event systems.
    Some applications that make use of the actor model are listed as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: actor模型正在许多物联网设备和实时事件系统中使用。以下是一些使用actor模型的应用程序列表：
- en: Event-driven applications (chat, workflow, CRM)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动应用程序（聊天、工作流、CRM）
- en: Finance (pricing, fraud detection, algorithmic trading)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金融（定价、欺诈检测、算法交易）
- en: Gaming (multi-player)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏（多人游戏）
- en: Analytics and monitoring
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和监控
- en: Marketing automation
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营销自动化
- en: Systems integration
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统集成
- en: IoT (healthcare, transportation, security)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网（医疗保健、交通、安全）
- en: 'OK—we may never truly understand Hollywood actors, but at least we are familiar
    with computational actors. With the high-level concepts out of the way, we can
    move on to constructing the building blocks of an actor system: actors. Before
    we work with actors, we need to get actors to communicate with each other. This
    is achieved using channels in Tokio.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——我们可能永远无法真正理解好莱坞演员，但至少我们对计算actor很熟悉。在高级概念之后，我们可以继续构建actor系统的构建块：actor。在我们与actor一起工作之前，我们需要让actor相互通信。这可以通过Tokio中的通道来实现。
- en: Working with channels
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与通道一起工作
- en: 'We can experiment with channels by rewriting our `main.rs` file. First, we
    need to import channels and implement the `main` trait for the `main` function
    with the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重写`main.rs`文件来实验通道。首先，我们需要导入通道并实现`main`特质为`main`函数，以下代码：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we can see that we import the `mpsc` module. `mpsc`. We can now create
    our channel and spawn a thread that sends multiple messages to a receiver down
    the channel we created in our `main` function with the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们导入了`mpsc`模块。`mpsc`。我们现在可以创建我们的通道并启动一个线程，该线程将多个消息发送到我们在`main`函数中创建的通道的接收器。以下代码：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we can see that the creation of a channel returns a tuple, which we unpack
    to transmit (`tx`) and receive (`rx`). We then loop through a range of integers
    from 0 to 10, sending them down the channel we created. If there is an error,
    we print it out and return an empty tuple, breaking the loop. In the following
    loop, we print out what we sent down the channel. We can then receive the messages
    with the code shown next:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到通道的创建返回一个元组，我们解包以传输（`tx`）和接收（`rx`）。然后我们遍历从0到10的整数范围，将它们发送到我们创建的通道。如果有错误，我们将其打印出来并返回一个空元组，中断循环。在下一个循环中，我们打印出我们发送到通道的内容。然后我们可以使用以下代码接收消息：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It must be noted that split halves of channels implement the `Iterator` trait,
    enabling us to read messages from these channels in a `while` loop. If we run
    our code now, we get the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，通道的分割 halves 实现了 `Iterator` 特性，使我们能够通过 `while` 循环从这些通道中读取消息。如果我们现在运行我们的代码，我们会得到以下输出：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The printout continues to `9`, but we get the idea of what is going on. We are
    not sending all our messages and then processing them. Both code blocks are executing
    side by side, sending and receiving messages. If we make one of the code blocks
    sleep between iterations, we will still get the same printout.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出继续到 `9`，但我们已经了解了正在发生的事情。我们不是发送所有消息然后处理它们。两个代码块是并行执行的，发送和接收消息。如果我们让其中一个代码块在迭代之间休眠，我们仍然会得到相同的打印输出。
- en: 'While getting the basis of async message sending and receiving is a nice step
    in the right direction, it is not useful. Right now, we are just sending a number.
    If we want to be able to implement actors that communicate with each other, we
    need to be able to send more comprehensive messages over the channel. To work
    out how to do this, we can inspect the `channel` source code, which reveals the
    following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然获取异步消息发送和接收的基础是一个正确的方向上的好步骤，但它并不实用。目前，我们只是在发送一个数字。如果我们想要能够实现相互通信的演员，我们需要能够在通道上发送更全面的消息。为了找出如何做到这一点，我们可以检查
    `channel` 的源代码，它揭示了以下内容：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see that the `channel` function is implementing generics. The sender
    and receiver can send anything if it is consistent, as denoted in the `(Sender<T>,
    Receiver<T>)` return type. Now that we know the `channel` function can load any
    type, we can create a message struct outside of the `channel` function with the
    following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`channel` 函数正在实现泛型。发送者和接收者可以发送任何东西，只要它是一致的，正如在 `(Sender<T>, Receiver<T>)`
    返回类型中所表示的。既然我们知道 `channel` 函数可以加载任何类型，我们就可以在 `channel` 函数外部创建一个消息结构体，以下代码所示：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we have a struct that has an order, which can either be `BUY` or `SELL`.
    Our `Message` struct also has a ticker to denote the name of the stock being processed
    and the amount of stock being processed. Inside our `main` function, we then pass
    our `Message` struct into the `channel` function and define the stocks that we
    are going to buy with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个具有订单的结构体，该订单可以是 `BUY` 或 `SELL`。我们的 `Message` 结构体还有一个股票的标记，用来表示正在处理的股票名称和处理股票的数量。在我们的
    `main` 函数中，我们随后将我们的 `Message` 结构体传递给 `channel` 函数，并定义我们将要购买的股票，以下代码所示：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that our orders are defined, we loop through the orders, sending and receiving
    them with the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了订单，我们通过以下代码遍历订单，发送和接收它们：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running our program now gives us the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的程序会给我们以下输出：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see here that we are sending and receiving messages across the channel.
    However, it must be noted before we move on that if we increase the size of the
    buffer passed into the `channel` function from 1 to 300, we get the following
    printout:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们正在通过通道发送和接收消息。然而，在我们继续之前，必须注意，如果我们将传递给 `channel` 函数的缓冲区大小从 1 增加到 300，我们会得到以下打印输出：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is because the buffer is so large that multiple messages can be sent without
    having to wait for the channel to be read (drained) until there is a new buffer
    that is more available.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为缓冲区太大，可以在不需要等待通道被读取（排空）直到有更多可用的新缓冲区的情况下发送多个消息。
- en: Working with actors in Tokio
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Tokio 中与演员一起工作
- en: 'This will be the last time we rewrite our `main.rs` file. However, once we
    have finished this section, we will have built a basic actor model system. In
    our system, we will create an actor that keeps track of the orders so that we
    do not exceed our budget threshold. We then need to build an actor that sends
    the order, resulting in the following process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是最后一次我们重写我们的 `main.rs` 文件。然而，一旦我们完成这一部分，我们将构建一个基本的演员模型系统。在我们的系统中，我们将创建一个演员来跟踪订单，这样我们就不超过我们的预算阈值。然后我们需要构建一个发送订单的演员，从而产生以下过程：
- en: '![Figure 14.5 – Our stock order interaction for actors](img/Figure_14.5_B18722.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 我们为演员的股票订单交互](img/Figure_14.5_B18722.jpg)'
- en: Figure 14.5 – Our stock order interaction for actors
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 我们为演员的股票订单交互
- en: 'We can see that this time round, we need to send the address of the actor that
    is making the order with the order message. This is a design choice because, in
    our system, *order* actors spin up and die quickly after the order has been made.
    We cannot keep track of the addresses for all the *order* actors in our program
    in our *order book* actor. Instead, the *order book* actor can get the address
    from the message to send the response to the *order* actor. First, we must import
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这次我们需要在订单消息中发送发出订单的演员的地址。这是一个设计选择，因为在我们系统中，*订单*演员在订单制作后迅速启动并死亡。我们无法在我们的*订单簿*演员中跟踪所有*订单*演员的地址。相反，*订单簿*演员可以从消息中获取地址以将响应发送给*订单*演员。首先，我们必须导入以下内容：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we import the `mpsc` channel to send the message to the *order book*.
    We then import the `oneshot` channel to facilitate the outcome being sent back
    to the *order*. A `oneshot` channel is a channel that stays open until a message
    is sent. This is because a `oneshot` channel has a capacity/buffer size of one,
    so it is bounded to only one message being sent before the channel is closed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`mpsc`通道以向*订单簿*发送消息。然后我们导入`oneshot`通道以促进结果被发送回*订单*。`oneshot`通道是一个在发送消息之前保持打开状态的通道。这是因为`oneshot`通道的容量/缓冲区大小为1，因此它绑定在只发送一条消息之前关闭通道。
- en: 'Now that we have imported all that we need, we can move on to defining the
    message with the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有需要的内容，我们可以继续定义以下代码的消息：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we can see that we have attached the `Sender` struct, which enables the
    receiver to send values to the sender through a channel. With this message, we
    can build out our *order book* actor with the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经附加了`Sender`结构体，这使得接收者可以通过通道向发送者发送值。通过这条消息，我们可以使用以下代码构建我们的*订单簿*演员：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The state of the *order book* actor will live on throughout the lifetime of
    the program. The `receiver` field will be used to accept incoming messages from
    all *order* actors, and a decision on how to process the order will be made on
    the total invested and the investment cap that we define when we are creating
    the actor. We now must implement functions that create the *order book* actor,
    handle incoming messages, and run the actor with the following outline:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*订单簿*演员的状态将在整个程序的生命周期中持续存在。`receiver`字段将用于接收来自所有*订单*演员的传入消息，并且将根据我们创建演员时定义的总投资和投资上限来做出处理订单的决定。我们现在必须实现创建*订单簿*演员、处理传入消息和按照以下大纲运行演员的函数：'
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can start with the constructor (the `new` function), which takes the following
    form:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从构造函数（`new`函数）开始，它具有以下形式：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The implementation of the constructor is not surprising. We merely pass in
    a receiver and the investment cap, and automatically set the total invested to
    `0`. Now that the *order* actor can be constructed, we can handle the messages
    the *order* actor received with the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的实现并不令人惊讶。我们只是传递一个接收者和投资上限，并自动将总投资设置为`0`。现在*订单*演员可以被构建，我们可以使用以下代码处理*订单*演员接收到的消息：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we have kept the implementation basic. If the new order brings our invested
    capital over our threshold, we print out that we have rejected the order and return
    a `0`. If our new order does not breach the threshold, we then print out that
    we are processing the order and send a `1`. For our example, the *order* actor
    is not going to act on the response from the *order book* actor; however, if you
    were to build in a system where another order is placed (such as a sell order),
    it is advised that you create another *order* actor based on the outcome.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持了实现的基本性。如果新的订单使我们的投资资本超过我们的阈值，我们打印出我们已拒绝订单并返回`0`。如果我们的新订单没有违反阈值，我们然后打印出我们正在处理订单并发送一个`1`。在我们的例子中，*订单*演员不会对*订单簿*演员的响应采取行动；然而，如果您要构建一个系统，其中可以放置另一个订单（例如，卖出订单），建议您根据结果创建另一个基于*订单*的演员。
- en: 'The only function left for our *order book* actor is the `run` function, which
    is defined with the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*订单簿*演员剩下的唯一函数是`run`函数，它使用以下代码定义：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we merely wait for messages until all the senders in our channel have
    been killed. If a message is sent to our actor, we process it with our `handle_message`
    function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是等待消息，直到我们通道中的所有发送者都被杀死。如果向我们的演员发送消息，我们使用我们的`handle_message`函数处理它。
- en: 'Our *order book* actor can now be constructed, run, and receive messages returning
    a response through a channel with three separate functions. We need to build an
    *order* actor struct so that we can send messages to our *order book* actor. First,
    we define our order fields with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*订单簿*演员现在可以通过三个单独的函数来构建、运行和接收通过通道返回的响应消息。我们需要构建一个*订单*演员结构体，以便我们可以向我们的*订单簿*演员发送消息。首先，我们使用以下代码定义我们的订单字段：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we need to define the ticker symbol that we are buying, the amount that
    we are buying, and the type of order. We then have the `Sender` struct so that
    we can send messages to the *order book*. For the *order* actor, we only need
    two functions: the `constructor` function and the `send` function. This is because
    our *order* actor is the one sending the initial message, so the *order* actor
    does not need a separate function to wait for messages. Our two functions for
    our *order* actor have the following outline:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要定义我们正在购买的股票的股票代码、购买的数量和订单类型。然后我们有`Sender`结构体，以便我们可以向*订单簿*发送消息。对于*订单*演员，我们只需要两个函数：构造函数和`send`函数。这是因为我们的*订单*演员是发送初始消息的那个，所以*订单*演员不需要一个单独的函数来等待消息。我们为我们的*订单*演员的两个函数有以下大纲：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point in time, you should be able to code the constructor for the *order*
    actor yourself. If you stop to have an attempt at this, your code should look
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时间点，你应该能够自己编写*订单*演员的构造函数。如果你停下来尝试编写这个函数，你的代码应该看起来像这样：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we merely pass the parameters into the creation of the struct, with the
    `order` field being automatically set to `BUY`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将参数传递给结构的创建，其中`order`字段自动设置为`BUY`。
- en: 'With the constructor built, the only function left to define is the `send`
    function, which takes the following form:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数构建完成后，唯一需要定义的函数是`send`函数，其形式如下：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we set up a one-shot channel that will close once the response from the
    *order book* actor has been received. We then package our message with the fields
    of our *order* actor struct and include the address of the *order* actor in the
    `respond_to` field of the message. The *order* actor then sends the message and
    awaits a response, which we merely print out as it is an example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个一次性通道，一旦从*订单簿*演员那里收到响应就会关闭。然后我们将我们的消息与*订单*演员结构体的字段打包，并在消息的`respond_to`字段中包含*订单*演员的地址。然后*订单*演员发送消息并等待响应，我们只是简单地打印出来，因为这只是一个示例。
- en: 'Our system components are now built. We can now orchestrate our actors to work
    with each other in our `main` function with the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统组件现在已经构建完成。现在我们可以在`main`函数中使用以下代码来编排我们的演员协同工作：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we define the channel and clone the sender to the channel once so that
    we have two senders for the same channel. This is because we have two Tokio threads
    sending order messages. We then create our *order book* actor and run it. If we
    cloned another sender but did not use it, our program would hang forever until
    we shut it down because the *order book* actor would be waiting for all senders
    for the channel to be killed before stopping.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了通道并将发送者克隆到通道中一次，这样我们就有两个相同的通道的发送者。这是因为我们有两个Tokio线程发送订单消息。然后我们创建我们的*订单簿*演员并运行它。如果我们克隆了另一个发送者但没有使用它，我们的程序将永远挂起，直到我们关闭它，因为*订单簿*演员会等待所有发送者被杀死后才会停止。
- en: 'Inside our threads, we will simply be sending a lot of stocks using loops with
    the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的线程中，我们将简单地使用以下代码使用循环发送大量股票：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It must be noted that we drop the `tx_one` and `tx` transmitters after we have
    sent all of our messages to signal early the task has completed, instead of having
    to wait for the end of the runtime to close the channel. We have two threads running
    because we want to properly check if our *order book* is safe to handle concurrent
    messages. If we run our program, we get the following printout:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在我们发送完所有消息后，我们会丢弃`tx_one`和`tx`传输器，以提前发出任务完成的信号，而不是等待运行时结束来关闭通道。我们有两个线程在运行，因为我们想正确检查我们的*订单簿*是否可以安全地处理并发消息。如果我们运行我们的程序，我们会得到以下输出：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can see messages are being sent and processed to our *order book* actor
    in an async manner. However, no matter how many times you run the program, you
    will never exceed your threshold of investment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到消息正在以异步方式发送和处理到我们的*订单簿*演员。然而，无论你运行程序多少次，你都不会超过你的投资阈值。
- en: And here we have it. Tokio enables us to run async code in the `main` function,
    and the actor model enables us to build safe async code that is easy to understand
    without having to rely on locks, handling of threads, passing state over threads,
    or external infrastructure such as a database. This does not mean that we should
    run around applying the actor model to everything. However, if you want to write
    safe async code that has a simple, testable implementation without external infrastructure
    and fast access to local memory, then the actor model combined with Tokio is very
    powerful.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于得到了这个。Tokio 允许我们在 `main` 函数中运行异步代码，而演员模型允许我们构建无需依赖锁、线程处理、线程间状态传递或外部基础设施（如数据库）即可轻松理解的同步代码。这并不意味着我们应该将演员模型应用到所有事物上。然而，如果你想要编写安全、简单、可测试的异步代码，且无需外部基础设施并快速访问本地内存，那么结合
    Tokio 的演员模型是非常强大的。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we managed to revisit async programming. Initially, we explored
    the Tokio framework by looking into what the Tokio framework enabled us to do
    and then implementing basic async code, which was then implemented by the Tokio
    framework. We then increased the number of worker threads to demonstrate the point
    that we get diminishing returns when we simply increase the number of worker threads.
    We then worked with channels to facilitate sending messages through these channels.
    This enabled us to send data between different areas of the code even if the code
    is running in a different thread.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地回顾了异步编程。最初，我们通过研究 Tokio 框架能够做什么以及实现基本的异步代码来探索 Tokio 框架，然后这些代码由 Tokio
    框架实现。然后我们增加了工作线程的数量，以证明当我们仅仅增加工作线程的数量时，我们会得到递减的回报。然后我们使用通道来促进通过这些通道发送消息。这使得我们能够在代码的不同区域之间发送数据，即使代码在不同的线程中运行。
- en: However, while async programming with the Tokio framework is interesting and
    fun, the basic combination of Tokio and async programming with channels does not
    directly lead to practical applications by itself. To gain some practical skills
    with Tokio and async programming, we explored the actor framework. This is where
    we define structs with their own state, and then communicate between the structs
    that we now call actors using channels. We then used actors to build a basic system
    that places orders where the amount of money invested does not exceed a defined
    threshold, even though we are placing these orders in an async manner. Implementing
    the actor model in Tokio has enabled us to build safe async systems without having
    any external infrastructure such as a database. In the next chapter, we take the
    ability to build custom async systems to the next level by building TCP listeners
    for our Tokio async application, meaning that we can listen for commands sent
    to our application from other applications and clients across a network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管使用 Tokio 框架进行异步编程很有趣且令人愉快，但仅通过 Tokio 和通道的异步编程组合本身并不能直接导致实际应用。为了获得一些与 Tokio
    和异步编程相关的实用技能，我们探索了演员框架。在这里，我们定义具有自己状态的 struct，然后通过通道在现在称为演员的 struct 之间进行通信。然后我们使用演员构建了一个基本系统，该系统在异步方式下放置订单，即使投资金额不超过定义的阈值。在
    Tokio 中实现演员模型使我们能够构建无需任何外部基础设施（如数据库）的安全异步系统。在下一章中，我们将构建自定义异步系统的能力提升到新的水平，通过为我们的
    Tokio 异步应用程序构建 TCP 监听器，这意味着我们可以监听来自其他应用程序和通过网络连接到我们的应用程序的客户端发送的命令。
- en: Further reading
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Tokio documentation: [https://tokio.rs/tokio/tutorial](https://tokio.rs/tokio/tutorial'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tokio 文档：[https://tokio.rs/tokio/tutorial](https://tokio.rs/tokio/tutorial)
- en: )
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Questions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does an actor model prevent data race issues?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演员模型是如何防止数据竞争问题的？
- en: How can we engineer a two-way communication where an actor can send a message
    to another actor and get a response back?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何设计一种双向通信，使得一个演员可以向另一个演员发送消息并得到回应？
- en: What happens to our program if we have two actors sending one message each to
    a third actor but we have cloned three instances of the sender for the MPSC channel
    facilitating the communication between the actors?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有两个演员各自向第三个演员发送一条消息，但我们为促进演员间通信的 MPSC 通道克隆了三个发送者的实例，那么我们的程序会发生什么？
- en: What are the advantages of using channels and messages to communicate data between
    code blocks?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通道和消息在代码块之间通信数据有什么优势？
- en: Answers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The actor model is where actors send messages to each other. Each actor has
    a queue for processing the incoming messages for the actor. Because of this, the
    incoming messages are processed in the order they are received.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演员模型是演员之间发送消息的地方。每个演员都有一个队列来处理发送给该演员的传入消息。正因为如此，传入的消息按照接收的顺序进行处理。
- en: The actor receiving the initial message has the receiver of the MPSC channel.
    The actor sending the initial message has the sender for the MPSC channel and
    creates a one-shot channel. The actor sending the initial message then sends the
    sender from the one-shot channel in the initial message. The actor sending the
    initial message then waits for the actor receiving the initial message to process
    the data and then uses the sender in the initial sender to send back a response.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收初始消息的演员拥有MPSC通道的接收者。发送初始消息的演员是MPSC通道的发送者，并创建了一个单次使用的通道。发送初始消息的演员随后在初始消息中发送单次通道的发送者。发送初始消息的演员然后等待接收初始消息的演员处理数据，然后使用初始发送者中的发送者发送回响应。
- en: Our program will run as we expect; however, only two of the senders for the
    MSPC channel will be killed as we only have two actors that are sending messages.
    This means that one sender will be left over. As one sender is not used up, the
    channel is not closed, so the receiving actor will continue to keep the program
    running indefinitely.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目将按照预期运行；然而，由于我们只有两个发送消息的演员，因此只有两个用于MSPC通道的发送者会被终止。这意味着将有一个发送者剩余。由于有一个发送者未被使用完，通道不会被关闭，所以接收演员将继续无限期地保持程序运行。
- en: Channels and messages give us a lot of flexibility. We can send messages across
    threads. We also do not have to pass data across multiple different areas of code.
    If a block has a connection to a channel, the code block can receive/send data.
    We also must note that we can implement different patterns. For instance, we can
    have a message emitted into a channel and received by multiple subscribers. We
    can also enforce the direction of traffic or rules such as one-shot. This means
    we have a lot of control over the flow of the data.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通道和消息为我们提供了很多灵活性。我们可以在线程之间发送消息。我们也不必在代码的多个不同区域传递数据。如果一个代码块与一个通道有连接，该代码块可以接收/发送数据。我们还必须注意，我们可以实现不同的模式。例如，我们可以将消息发射到通道中并由多个订阅者接收。我们还可以强制交通方向或规则，如单次使用。这意味着我们对数据的流动有大量的控制。
