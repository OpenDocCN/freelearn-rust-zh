<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Events and Basic Game Mechanisms</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the last chapter, we saw how to add dependencies into a project thanks to <kbd class="calibre14">Cargo</kbd> and the basics of the <kbd class="calibre14">SDL2</kbd> library.</p>
<p class="calibre3">We now have all the Rust basics in order to write the Tetris game. Time to look at how we will actually write Tetris.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Tetrimino</li>
<li class="calibre11">Creating tetriminos</li>
<li class="calibre11">Generating a tetrimino</li>
<li class="calibre11">Tetris struct</li>
<li class="calibre11">Interacting with the game map</li>
<li class="calibre11">SDL events</li>
<li class="calibre11">Score, level, lines sent</li>
</ul>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Writing Tetris</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First, let's review the Tetris rules (just in case):</p>
<ul class="calibre10">
<li class="calibre11">There is a grid with a height of 16 blocks and a width of 10 blocks.</li>
<li class="calibre11">You have seven different <span><kbd class="calibre14">tetrimino</kbd></span> (a tetris piece) that are all composed of four blocks.</li>
<li class="calibre11">A new <kbd class="calibre14">tetrimino</kbd> appears at the top of the game's grid every time the previous one cannot descend any more (because the block below is already occupied or because you've reached the game's floor).</li>
<li class="calibre11">The game is over when a new <kbd class="calibre14">tetrimino</kbd> cannot appear anymore (because there is already a tetrimino at the top of the grid).</li>
<li class="calibre11">Every time a line is <em class="calibre21">full</em> (all blocks are occupied by a <kbd class="calibre14">tetrimino</kbd> part), it disappears and all lines above descend by one line.</li>
</ul>
<p class="calibre3">Now that we all agree on the game rules, let's see how to actually write those mechanisms.</p>
<p class="calibre3">First, we need to actually create those <span><kbd class="calibre14">tetrimino</kbd></span>s.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Tetrimino</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">As said previously, every <kbd class="calibre14">tetrimino</kbd> has four blocks. Another thing to note is that they can rotate. So for example you have this <kbd class="calibre14">tetrimino</kbd>:</p>
<div class="mce-root"><img src="../images/00012.jpeg" class="calibre42"/></div>
<div class="mce-root1"><em class="calibre21">Figure 3.1</em></div>
<p class="calibre3">It can also rotate in the three following positions:</p>
<div class="mce-root">  <img src="../images/00013.jpeg" class="calibre43"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.2</em></div>
</div>
<p class="calibre3">Theoretically, every <kbd class="calibre14">tetrimino</kbd> should have four states, but in reality, not all of them do. For example, this one has no transformation so to speak:</p>
<div class="mce-root"><img src="../images/00014.jpeg" class="calibre44"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.3</em></div>
</div>
<p class="calibre3">And these three only have two states:</p>
<div class="mce-root"><img src="../images/00015.jpeg" class="calibre45"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.4</em></div>
</div>
<p class="calibre3">We have two ways of handling these rotations: using matrix rotation or storing the different states. To have a code that's easy to read and update, I picked the second option, but don't hesitate to try using matrix on your own, it could help you learn a lot of new things!</p>
<p class="calibre3">So first, let's write down a <span><kbd class="calibre14">struct</kbd></span> for <span><kbd class="calibre14">tetrimino</kbd></span>s:</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> Tetrimino <span>{</span>
    states: <span>Vec</span>&lt;<span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;&gt;,
    x: <span>isize</span>,
    y: <span>usize</span>,
    current_state: <span>u8</span>,
<span>}</span></pre></div>
<p class="calibre3">Everything seems fine except this line:</p>
<div class="title-page-name">
<pre class="calibre22">states: <span>Vec</span>&lt;<span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;&gt;,</pre></div>
<p class="calibre3">Pretty ugly, right? Let's make it look a bit better by using type aliasing!</p>
<p class="calibre3">So what is our <span><kbd class="calibre14">states</kbd></span> field representing? Simply a list of states. Each state represents a piece's transformation. I suppose it's a bit hard to understand all of this. Let's write an example:</p>
<div class="title-page-name">
<pre class="calibre22"><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>1</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
     <span>vec!</span><span>[</span><span>1</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
     <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
     <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span></pre></div>
<p class="calibre3">In here, <span><kbd class="calibre14">0</kbd></span> means the block is empty, otherwise, it's a <span><kbd class="calibre14">tetrimino</kbd></span> block. So from reading this code, I suppose you could guess that we were representing the square:</p>
<div class="mce-root"><img src="../images/00014.jpeg" class="calibre44"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.5</em></div>
</div>
<p class="calibre3">In case you wondered, we have four lines with four blocks because the <em class="calibre21">biggest </em><span><kbd class="calibre14">tetrimino</kbd></span> has a height (or a width, depending the transformation) of four:</p>
<div class="mce-root"><img src="../images/00016.jpeg" class="calibre46"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.6</em></div>
</div>
<p class="calibre3">This isn't mandatory (we could make it fit the form of each <span><kbd class="calibre14">tetrimino</kbd></span>), but it makes our lives easier, so why not?</p>
<p class="calibre3">Coming back to our type aliasing: a piece is basically a vector or vector of numbers. It's long to write it down every time, so let's alias it as follows:</p>
<div class="title-page-name">
<pre class="calibre22"><span>type</span> Piece = <span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;;</pre></div>
<p class="calibre3">Now we can rewrite the <span><kbd class="calibre14">states</kbd></span> field declaration as follows:</p>
<div class="title-page-name">
<pre class="calibre22">states: <span>Vec</span>&lt;Piece&gt;,</pre></div>
<p class="calibre3">Way better and more explicit, right? But since we'll be using those states as well, why not alias them too?</p>
<div class="title-page-name">
<pre class="calibre22"><span>type</span> States = <span>Vec</span>&lt;Piece&gt;;</pre></div>
<p class="calibre3">And now our <span><kbd class="calibre14">states</kbd></span> field declaration becomes:</p>
<div class="title-page-name">
<pre class="calibre22">states: States,</pre></div>
<p class="calibre3">Let's explain the other fields (just in case):</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> Tetrimino <span>{</span>
    states: States,
    x: <span>isize</span>,
    y: <span>usize</span>,
    current_state: <span>u8</span>,
<span>}<br class="calibre6"/></span></pre></div>
<p class="calibre3">A little explanation of this struct:</p>
<ul class="calibre10">
<li class="calibre11"><span><kbd class="calibre14">states</kbd></span> (if you didn't already understand it) is the list of possible states of the <span><kbd class="calibre14">tetrimino</kbd></span></li>
<li class="calibre11"><span><kbd class="calibre14">x</kbd></span> is the <em class="calibre21">x</em> position of the <span><kbd class="calibre14">tetrimino</kbd></span></li>
<li class="calibre11"><span><kbd class="calibre14">y</kbd></span> is the <em class="calibre21">y</em> position of the <span><kbd class="calibre14">tetrimino</kbd></span></li>
<li class="calibre11"><span><kbd class="calibre14">current_state</kbd></span> is the state in which the <span><kbd class="calibre14">tetrimino</kbd></span> is currently</li>
</ul>
<p class="calibre3">Ok, so far so good. Now how should we handle the creation of this type generically? We don't want to rewrite this for every <span><kbd class="calibre14">tetrimino</kbd></span>. This is where <span><kbd class="calibre14">traits</kbd></span> kick in!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating tetriminos</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We wrote the type that will be used in our game, but we didn't write its initialization/creation yet. This is where Rust <span><kbd class="calibre14">trait</kbd></span>s will be useful.</p>
<p class="calibre3">Let's start by writing a generator trait that will be implemented on all <span><kbd class="calibre14">tetrimino</kbd></span>s:</p>
<div class="title-page-name">
<pre class="calibre22"><span>trait</span> TetriminoGenerator <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino;
<span>}</span></pre></div>
<p class="calibre3">And that's it. This <span><kbd class="calibre14">trait</kbd></span> just provides a function that creates a new <span><kbd class="calibre14">Tetrimino</kbd></span> instance. It maybe doesn't like this very much, but thanks to this <span><kbd class="calibre14">trait</kbd></span>, we'll be able to easily create all our <span><kbd class="calibre14">tetrimino</kbd></span>s.</p>
<p class="calibre3">Time to write our first <span><kbd class="calibre14">tetrimino</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoI;</pre></div>
<p class="calibre3">No need to look for more code, this is what a <span><kbd class="calibre14">tetrimino</kbd></span> really looks like. It's an empty structure. The interesting part comes just after:</p>
<div class="title-page-name">
<pre class="calibre22"><span>impl</span> TetriminoGenerator <span>for</span> TetriminoI <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>1</span>, <span>1</span>, <span>1</span>, <span>1</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Which is:</p>
<div class="mce-root"><img src="../images/00017.jpeg" class="calibre47"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.7</em></div>
</div>
<p class="calibre3">In here, a number represents a color and <kbd class="calibre14">0</kbd> means no color (because there is no block).</p>
<p class="calibre3">And that's it. Now you can create this <span><kbd class="calibre14">tetrimino</kbd></span> just by calling:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> tetrimino = TetriminoI::new();</pre></div>
<p class="calibre3">It'll return an instance of the <span><kbd class="calibre14">Tetrimino</kbd></span> structure and that's the one you'll be using in the game. The other <span><kbd class="calibre14">tetrimino</kbd></span> structures (such as <span><kbd class="calibre14">TetriminoI</kbd></span> in here) are just used to generically create the <span><kbd class="calibre14">Tetrimino</kbd></span> structure with the related information.</p>
<p class="calibre3">We now need to create all the other <span><kbd class="calibre14">tetrimino</kbd></span> as well, so let's do it:</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoJ;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoJ <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">In case you're wondering why the blocks have <span><kbd class="calibre14">2</kbd></span> as values, it's simply so that we can differentiate them when displaying them (having all <span><kbd class="calibre14">tetrimino</kbd></span> with the same color wouldn't be very pretty...). It has no other meaning.</p>
<p class="calibre3">This <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00018.jpeg" class="calibre48"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.8</em></div>
</div>
<div class="title-page-name">Let's go for the next one:</div>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoL;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoL <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">This <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00019.jpeg" class="calibre49"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.9</em></div>
</div>
<div class="title-page-name">Another <kbd class="calibre31">tetrimino</kbd>:</div>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoO;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoO <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>4</span>, <span>4</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>4</span>, <span>4</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>5</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">This <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00020.jpeg" class="calibre50"/>
<div class="mce-root1"><em class="calibre21">Figure 3.10</em></div>
</div>
<p class="calibre3">Another <kbd class="calibre14">tetrimino</kbd> (will it ever end?!):</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoS;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoS <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>5</span>, <span>5</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">This <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00021.jpeg" class="calibre51"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.11</em></div>
</div>
<p class="calibre3">Guess what? Another <kbd class="calibre14">tetrimino</kbd>:</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoZ;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoZ <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>6</span>, <span>6</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">This <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00022.jpeg" class="calibre52"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.12</em></div>
</div>
<p class="calibre3">And the last one (finally!):</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> TetriminoT;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoT <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">And finally, this <span><kbd class="calibre14">tetrimino</kbd></span> looks like this:</p>
<div class="mce-root"><img src="../images/00023.jpeg" class="calibre53"/></div>
<div class="title-page-name">
<div class="mce-root1"><em class="calibre21">Figure 3.13</em></div>
</div>
<p class="calibre3">Phew... That was quite a lot of code! Easy code, but still a lot!</p>
<p class="calibre3">It's now time to see how we can generate a new <span><kbd class="calibre14">tetrimino</kbd></span> randomly.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Generating a tetrimino</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In order to do so, we'll need to import another <span><kbd class="calibre14">crate</kbd></span>—<span><kbd class="calibre14">rand</kbd></span>. This <kbd class="calibre14">crate</kbd> is used to generate random numbers and that is exactly what we need here.</p>
<p class="calibre3">First, add the following line to your <span><kbd class="calibre14">Cargo.toml</kbd></span> file (in the <span><kbd class="calibre14">[dependencies]</kbd></span> section):</p>
<pre class="calibre22">rand = "0.3"</pre>
<p class="calibre3">Next, add the following line to your <span><kbd class="calibre14">main.rs</kbd></span> file:</p>
<div class="title-page-name">
<pre class="calibre22"><span>extern</span> <span>crate</span> rand;</pre></div>
<p class="calibre3">And we're done! Now we can write the generation function of the <span><kbd class="calibre14">tetrimino</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> create_new_tetrimino() -&gt; Tetrimino <span>{</span>
    <span>let</span> rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
    <span>match</span> rand_nb <span>{</span>
        <span>0</span> =&gt; TetriminoI::new(),
        <span>1</span> =&gt; TetriminoJ::new(),
        <span>2</span> =&gt; TetriminoL::new(),
        <span>3</span> =&gt; TetriminoO::new(),
        <span>4</span> =&gt; TetriminoS::new(),
        <span>5</span> =&gt; TetriminoZ::new(),
        <span>6</span> =&gt; TetriminoT::new(),
        _ =&gt; <span>unreachable!</span>(),
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Pretty easy, right? Though, please note that this is a bit too random. It'd be problematic if we had the same <span><kbd class="calibre14">tetrimino</kbd></span> generated more than twice in a row (which is already a lot!), so let's improve this function a bit by adding a <span><kbd class="calibre14">static</kbd></span> variable:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> create_new_tetrimino() -&gt; Tetrimino <span>{</span>
    <span>static</span> <span>mut</span> PREV: <span>u8</span> = <span>7</span>;
    <span>let</span> <span>mut</span> rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
    <span>if</span> <span>unsafe</span> <span>{</span> PREV <span>}</span> == rand_nb <span>{</span>
        rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
    <span>}</span>
    <span>unsafe</span> <span>{</span> PREV = rand_nb; }
    <span>match</span> rand_nb <span>{</span>
        <span>0</span> =&gt; TetriminoI::new(),
        <span>1</span> =&gt; TetriminoJ::new(),
        <span>2</span> =&gt; TetriminoL::new(),
        <span>3</span> =&gt; TetriminoO::new(),
        <span>4</span> =&gt; TetriminoS::new(),
        <span>5</span> =&gt; TetriminoZ::new(),
        <span>6</span> =&gt; TetriminoT::new(),
        _ =&gt; <span>unreachable!</span>(),
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">A bit of explanation might be helpful here. First, what is a <span><kbd class="calibre14">static</kbd></span> variable? It's a variable that will keep its value and won't be destroyed when the scope it has been created inside has been left. An example:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> foo() -&gt; <span>u32</span> <span>{</span>
    <span>static</span> <span>mut</span> VALUE: <span>u32</span> = <span>12</span>;
    <span>unsafe</span> <span>{</span>
        VALUE += <span>1</span>;
        VALUE
    <span>}</span>
<span>}</span>

<span>for</span> _ <span>in</span> <span>0.</span>.<span>5</span> <span>{</span>
    <span>println!</span>(<span>"{}"</span>, foo());
<span>}</span></pre></div>
<p class="calibre3">If you execute this code, it'll print out:</p>
<pre class="calibre23"><strong class="calibre5">13
14
15
16
17</strong></pre>
<p class="calibre3">Here are the other properties of the <span><kbd class="calibre14">static</kbd></span> variable:</p>
<ul class="calibre10">
<li class="calibre11">It cannot have a destructor (it's possible to avoid this limitation by using the <span><kbd class="calibre14">lazy_static</kbd></span> crate though, but we won't talk about it here) so only <em class="calibre21">simple</em> types that don't implement the <span><kbd class="calibre14">Drop</kbd></span> trait can be used as <span><kbd class="calibre14">static</kbd></span></li>
<li class="calibre11">Changing the value of a <span><kbd class="calibre14">static</kbd></span> variable is unsafe (that's why there are <span><kbd class="calibre14">unsafe</kbd></span> blocks) for the simple reason that the <span><kbd class="calibre14">static</kbd></span> is shared between all threads in the program and can be modified and read at the same time</li>
<li class="calibre11">Reading the value of a mutable <span><kbd class="calibre14">static</kbd></span> is unsafe (for the reason mentioned previously)</li>
</ul>
<p class="calibre3">We now have a function that can generate a <span><kbd class="calibre14">tetrimino</kbd></span>. We now need to add the following functionalities:</p>
<ul class="calibre10">
<li class="calibre11">Rotating</li>
<li class="calibre11">Changing position</li>
</ul>
<p class="calibre3">Let's start with the rotation part!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Rotating a tetrimino</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Thanks to how we created the <span><kbd class="calibre14">Tetrimino</kbd></span> type, it's quite easy to do:</p>
<div class="title-page-name">
<pre class="calibre22"><span>impl</span> Tetrimino <span>{</span>
    <span>fn</span> rotate(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>self</span>.current_state += <span>1</span>;
        <span>if</span> <span>self</span>.current_state <span>as</span> <span>usize</span> &gt;= <span>self</span>.states.len() <span>{</span>
            <span>self</span>.current_state = <span>0</span>;
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">And we're done. However, we don't check anything: what happens if there is a block already used by another <span><kbd class="calibre14">tetrimino</kbd></span>? We'll just overwrite it. Such a thing cannot be accepted!</p>
<p class="calibre3">In order to perform this check, we'll need the game <em class="calibre21">map</em> as well. It's simply a vector line and a line is a vector of <span><kbd class="calibre14">u8</kbd></span>. Or, more simply:</p>
<div class="title-page-name">
<pre class="calibre22"><span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8&gt;&gt;</span></pre></div>
<p class="calibre3">Considering that it isn't too hard to read, we'll just keep it this way. Now let's write the method:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> test_position(&amp;<span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>,
                 tmp_state: <span>usize</span>, x: <span>isize</span>, y: <span>usize</span>) -&gt; <span>bool</span> <span>{</span>
    <span>for</span> decal_y <span>in</span> <span>0.</span>.<span>4</span> <span>{</span>
      <span>for</span> decal_x <span>in</span> <span>0.</span>.<span>4</span> <span>{</span>
        <span>let</span> x = x + decal_x;
        <span>if</span> <span>self</span>.states<span>[</span>tmp_state<span>][</span>decal_y<span>][</span>decal_x <span>as</span> <span>usize</span><span>]</span> != <span>0</span> <br class="calibre6"/>            &amp;&amp;
                (y + decal_y &gt;= game_map.len() ||
                 x &lt; <span>0</span> ||
                 x <span>as</span> <span>usize</span> &gt;= game_map<span>[</span>y + decal_y<span>]</span>.len() ||
                 game_map<span>[</span>y + decal_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> != <span>0</span>) <span>{</span>
                <span>return</span> <span>false</span>;
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span>;
<span>}</span></pre></div>
<p class="calibre3">Before explaining this function, it seems important to explain why the game map became a <span><kbd class="calibre14">&amp;[Vec&lt;u8&gt;]</kbd></span>. When you send a non-mutable reference over a vector (<span><kbd class="calibre14">Vec&lt;T&gt;</kbd></span>), it is then dereferenced into a <span><kbd class="calibre14">&amp;[T]</kbd></span> slice, which is a constant <em class="calibre21">view</em> over the vector's content.</p>
<p class="calibre3">And we're done (for this method)! Now time for explanations: we loop over every block of our <span><kbd class="calibre14">tetrimino</kbd></span> and check whether the block is free in the game map (by checking whether it is equal to <span><kbd class="calibre14">0</kbd></span>) and if it isn't going out of the game map.</p>
<p class="calibre3">Now that we have our <span><kbd class="calibre14">test_position</kbd></span> method, we can update the <span><kbd class="calibre14">rotate</kbd></span> method:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> rotate(&amp;<span>mut</span> <span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>) <span>{</span>
    <span>let</span> <span>mut</span> tmp_state = <span>self</span>.current_state + <span>1</span>;
    <span>if</span> tmp_state <span>as</span> <span>usize</span> &gt;= <span>self</span>.states.len() <span>{</span>
        tmp_state = <span>0</span>;
    <span>}</span>
    <span>let</span> x_pos = <span>[</span><span>0</span>, -<span>1</span>, <span>1</span>, -<span>2</span>, <span>2</span>, -<span>3</span><span>]</span>;
    <span>for</span> x <span>in</span> x_pos.iter() <span>{</span>
        <span>if</span> <span>self</span>.test_position(game_map, tmp_state <span>as</span> <span>usize</span>,
                              <span>self</span>.x + x, <span>self</span>.y) == <span>true</span> <span>{</span>
            <span>self</span>.current_state = tmp_state;
            <span>self</span>.x += *x;
            <span>break</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">A bit longer, indeed. Since we can't be sure that the piece will be put where we want it to go, we need to make temporary variables and then check the possibilities. Let's go through the code:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> tmp_state = <span>self</span>.current_state + <span>1</span>;
<span>if</span> tmp_state <span>as</span> <span>usize</span> &gt;= <span>self</span>.states.len() <span>{</span>
    tmp_state = <span>0</span>;
<span>}</span></pre></div>
<p class="calibre3">This is <em class="calibre21">exactly</em> what our <span><kbd class="calibre14">rotate</kbd></span> method did before, except that now, we use temporary variables before going further:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> x_pos = <span>[</span><span>0</span>, -<span>1</span>, <span>1</span>, -<span>2</span>, <span>2</span>, -<span>3</span><span>]</span>;</pre></div>
<p class="calibre3">This line on its own doesn't make much sense but it'll be very useful next: in case the piece cannot be placed where we want, we try to move it on the <span><kbd class="calibre14">x</kbd></span> axis to see if it'd work in some other place. It allows you to have a Tetris that is much more flexible and comfortable to play:</p>
<div class="title-page-name">
<pre class="calibre22"><span>for</span> x <span>in</span> x_pos.iter() <span>{</span>
    <span>if</span> <span>self</span>.test_position(game_map, tmp_state <span>as</span> <span>usize</span>,
                          <span>self</span>.x + x, <span>self</span>.y) == <span>true</span> <span>{</span>
        <span>self</span>.current_state = tmp_state;
        <span>self</span>.x += *x;
        <span>break</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">With the explanations given previously, this loop should be really easy to understand. For each <span><kbd class="calibre14">x</kbd></span> shift, we check whether the piece can be placed there. If it works, we change the values of our <span><kbd class="calibre14">tetrimino</kbd></span>, otherwise we just continue.</p>
<p class="calibre3">If no <span><kbd class="calibre14">x</kbd></span> shift worked, we just leave the function without doing anything.</p>
<p class="calibre3">Now that we can rotate and test the position of a <span><kbd class="calibre14">tetrimino</kbd></span>, it'd be nice to actually move it as well (when the timer goes to 0 and the <span><kbd class="calibre14">tetrimino</kbd></span> needs to go down, for example). The main difference with the <span><kbd class="calibre14">rotate</kbd></span> method will be that, if the <span><kbd class="calibre14">tetrimino</kbd></span> cannot move, we'll return a Boolean value to allow the caller to be aware of it.</p>
<p class="calibre3">So the method looks like this:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> change_position(&amp;<span>mut</span> <span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>, new_x: <span>isize</span>, new_y: <span>usize</span>) -&gt; <span>bool</span> <span>{</span>
    <span>if</span> <span>self</span>.test_position(game_map, <span>self</span>.current_state <span>as</span> <span>usize</span>,  <br class="calibre6"/>    new_x, new_y) == <span>true</span> <span>{</span>
        <span>self</span>.x = new_x <span>as</span> <span>isize</span>;
        <span>self</span>.y = new_y;
        <span>true</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>false</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Another difference that you have certainly already spotted is that we don't check multiple possible positions, just the one received. The reason is simple; contrary to a rotation, we can't move the <span><kbd class="calibre14">tetrimino</kbd></span> around when it receives a move instruction. Imagine asking the <span><kbd class="calibre14">tetrimino</kbd></span> to move to the right and it doesn't move, or worse, it moves to the left! We can't allow it and so we're not doing it.</p>
<p class="calibre3">Now about the method's code: it's very simple. If we can put the <span><kbd class="calibre14">tetrimino</kbd></span> in a place, we update the position of the <span><kbd class="calibre14">tetrimino</kbd></span> and return true, otherwise, we do nothing other than return false.</p>
<p class="calibre3">Most of the work is performed in the <span><kbd class="calibre14">test_position</kbd></span> method, allowing our method to be really small.</p>
<p class="calibre3">With these three methods, we have almost everything we need. But for even more simplicity in the future, let's add one more:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> test_current_position(&amp;<span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>) -&gt; <span>bool</span> <span>{</span>
    <span>self</span>.test_position(game_map, <span>self</span>.current_state <span>as</span> <span>usize</span>,  <br class="calibre6"/><span>    self</span>.x, <span>self</span>.y)
<span>}</span></pre></div>
<p class="calibre3">We'll use it when we generate a new <span><kbd class="calibre14">tetrimino</kbd></span>: if it cannot be placed where it appeared because another <span><kbd class="calibre14">tetrimino</kbd></span> is already there, it means the game is over.</p>
<p class="calibre3">We can now say that our <span><kbd class="calibre14">Tetrimino</kbd></span> type is fully implemented. Congratulations! Time to start the game type!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Tetris struct</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This type will be the one holding all the game's information:</p>
<ul class="calibre10">
<li class="calibre11">Game map</li>
<li class="calibre11">Current level</li>
<li class="calibre11">Score</li>
<li class="calibre11">Number of lines</li>
<li class="calibre11">The current <span><kbd class="calibre14">tetrimino</kbd></span></li>
<li class="calibre11">Some potential other information (such as a ghost, or the preview of the next <span><kbd class="calibre14">tetrimino</kbd></span>!)</li>
</ul>
<p class="calibre3">Let's write down this type:</p>
<div class="title-page-name">
<pre class="calibre22"><span>struct</span> Tetris <span>{</span>
    game_map: <span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;,
    current_level: <span>u32</span>,
    score: <span>u32</span>,
    nb_lines: <span>u32</span>,
    current_piece: <span>Option</span>&lt;Tetrimino&gt;,
<span>}</span></pre></div>
<p class="calibre3">Once again, pretty simple. I don't think any additional information is required so let's continue!</p>
<p class="calibre3">Let's start by writing the <span><kbd class="calibre14">new</kbd></span> method for this new type:</p>
<div class="title-page-name">
<pre class="calibre22"><span>impl</span> Tetris <span>{</span>
    <span>fn</span> new() -&gt; Tetris <span>{</span>
        <span>let</span> <span>mut</span> game_map = <span>Vec</span>::new();
        <span>for</span> _ <span>in</span> <span>0.</span>.<span>16</span> <span>{</span>
            game_map.push(<span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
        <span>}</span>
        Tetris <span>{</span>
            game_map: game_map,
            current_level: <span>1</span>,
            score: <span>0</span>,
            nb_lines: <span>0</span>,
            current_piece: <span>None</span>,
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Nothing really complicated except maybe the loop. Let's look at how it works:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> game_map = <span>Vec</span>::new();
<span>for</span> _ <span>in</span> <span>0.</span>.<span>16</span> <span>{</span>
    game_map.push(<span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
<span>}</span></pre></div>
<p class="calibre3">We know that a <span><kbd class="calibre14">tetris</kbd></span> map has a width of 10 blocks and a height of 16 blocks. This loop creates our game map by looping over the number of lines and generating an empty vector of 10 blocks, which will be a line.</p>
<p class="calibre3">Apart from this, everything else is very straightforward:</p>
<ul class="calibre10">
<li class="calibre11">You start at level 1</li>
<li class="calibre11">With your score at 0</li>
<li class="calibre11">With 0 lines sent</li>
<li class="calibre11">No current <span><kbd class="calibre14">tetrimino</kbd></span></li>
</ul>
<p class="calibre3">Let's start by generating a new <span><kbd class="calibre14">tetrimino</kbd></span> randomly. For this, you'll require the <span><kbd class="calibre14">rand</kbd></span> crate. Add the following to your <span><kbd class="calibre14">Cargo.toml</kbd></span> file:</p>
<pre class="calibre22">rand = "0.3"</pre>
<p class="calibre3">Then add this at the top of your <kbd class="calibre14">main</kbd> file:</p>
<div class="title-page-name">
<pre class="calibre22"><span>extern</span> <span>crate</span> rand;</pre></div>
<p class="calibre3">Then we can write the method:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> create_new_tetrimino(&amp;<span>self</span>) -&gt; Tetrimino <span>{</span>
    <span>static</span> <span>mut</span> PREV: <span>u8</span> = <span>7</span>;
    <span>let</span> <span>mut</span> rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
    <span>if</span> <span>unsafe</span> <span>{</span> PREV <span>}</span> == rand_nb <span>{</span>
        rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
    <span>}</span>
    <span>unsafe</span> <span>{</span> PREV = rand_nb; <span>}</span>
    <span>match</span> rand_nb <span>{</span>
        <span>0</span> =&gt; TetriminoI::new(),
        <span>1</span> =&gt; TetriminoJ::new(),
        <span>2</span> =&gt; TetriminoL::new(),
        <span>3</span> =&gt; TetriminoO::new(),
        <span>4</span> =&gt; TetriminoS::new(),
        <span>5</span> =&gt; TetriminoZ::new(),
        <span>6</span> =&gt; TetriminoT::new(),
        _ =&gt; <span>unreachable!</span>(),
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Explanations:</p>
<div class="title-page-name">
<pre class="calibre22"><span>static</span> <span>mut</span> PREV: <span>u8</span> = <span>7</span>;</pre></div>
<p class="calibre3">The <span><kbd class="calibre14">static</kbd></span> keyword is the same in <span><kbd class="calibre14">Rust</kbd></span> as it is in <span><kbd class="calibre14">C</kbd></span> and <span><kbd class="calibre14">C++</kbd></span> for variables: the value set to the variable will be kept between the function calls. So for example, if you write the following function:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> incr() -&gt; <span>u32</span> <span>{</span>
    <span>static</span> <span>mut</span> NB: <span>u32</span> = <span>0</span>;
    <span>unsafe</span> <span>{</span>
        NB += <span>1</span>;
        NB
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">And you then call it, as follows:</p>
<div class="title-page-name">
<pre class="calibre22"><span>for</span> _ <span>in</span> <span>0.</span>.<span>5</span> <span>{</span>
    <span>println!</span>(<span>"{}"</span>, incr());
<span>}</span></pre></div>
<p class="calibre3">You'll get the following output:</p>
<pre class="calibre23"><strong class="calibre5">1
2
3
4
5</strong></pre>
<p class="calibre3">So now, why do we have these <span><kbd class="calibre14">unsafe</kbd></span> blocks? The reason is quite simple: in case the static variable is accessed and modified from different threads, you can't be <em class="calibre21">sure</em> that you won't have data race, concurrency errors, or even memory errors.</p>
<div class="packt_tip">In this case, since we don't have threads, it's fine. However, keep in mind that you should ALWAYS try to avoid unsafe at all costs and use it ONLY when nothing else can be done.</div>
<p class="calibre3">However, if our static variable wasn't mutable, then we could access its value without needing the <span><kbd class="calibre14">unsafe</kbd></span> blocks. The reason once again is simple: even if multiple threads try to access its value at the same time, since this value cannot change, you can't have data race and therefore it is safe.</p>
<p class="calibre3">Let's continue with our function's code explanations:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;</pre></div>
<p class="calibre3">This line generates a random <span><kbd class="calibre14">u8</kbd></span> and then limits its value between 0 (included) and 6 (included) because we have seven different <span><kbd class="calibre14">tetrimino</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>unsafe</span> <span>{</span> PREV <span>}</span> == rand_nb <span>{</span>
    rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
<span>}</span></pre></div>
<p class="calibre3">If the generated <span><kbd class="calibre14">tetrimino</kbd></span> is the same as the previous one, we generate another one. It enables you to prevent having the same <span><kbd class="calibre14">tetrimino</kbd></span> too many times at once. It isn't the best way to do it, having a specific balancing for each <span><kbd class="calibre14">tetrimino</kbd></span> would be better, but this solution is acceptable enough (and a lot easier to write!):</p>
<div class="title-page-name">
<pre class="calibre22"><span>unsafe</span> <span>{</span> PREV = rand_nb; <span>}</span></pre></div>
<p class="calibre3">We now set the generated <span><kbd class="calibre14">tetrimino</kbd></span> <em class="calibre21">ID</em> to our <span><kbd class="calibre14">static</kbd></span> variable:</p>
<div class="title-page-name">
<pre class="calibre22"><span>match</span> rand_nb <span>{</span>
    <span>0</span> =&gt; TetriminoI::new(),
    <span>1</span> =&gt; TetriminoJ::new(),
    <span>2</span> =&gt; TetriminoL::new(),
    <span>3</span> =&gt; TetriminoO::new(),
    <span>4</span> =&gt; TetriminoS::new(),
    <span>5</span> =&gt; TetriminoZ::new(),
    <span>6</span> =&gt; TetriminoT::new(),
    _ =&gt; <span>unreachable!</span>(),
<span>}</span></pre></div>
<p class="calibre3">Nothing much to say about this pattern matching. Every <em class="calibre21">ID</em> matches a <span><kbd class="calibre14">tetrimino</kbd></span> and then we call the corresponding constructor. The only really interesting thing about this construction is the following line:</p>
<div class="title-page-name">
<pre class="calibre22">_ =&gt; <span>unreachable!(),</span></pre></div>
<p class="calibre3">This macro is really useful. It allows us to add a security over the matched value. If the code ever enters this pattern matching, it'll panic right away (because, as the macro's name suggests, it's not supposed to happen).</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Interacting with the game map</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Ok, we can now move all the <span><kbd class="calibre14">tetrimino</kbd></span> and generate them. Two mechanisms are still missing: checking lines to see whether one can be sent (that is, removed since complete) and making a <span><kbd class="calibre14">tetrimino</kbd></span> <em class="calibre21">permanent </em>(that is, not movable anymore).</p>
<p class="calibre3">Let's start with the line check:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> check_lines(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>let</span> <span>mut</span> y = <span>0</span>;

    <span>while</span> y &lt; <span>self</span>.game_map.len() <span>{</span>
        <span>let</span> <span>mut</span> complete = <span>true</span>;

        <span>for</span> x <span>in</span> &amp;<span>self</span>.game_map<span>[</span>y<span>]</span> <span>{</span>
            <span>if</span> *x == <span>0</span> <span>{</span>
                complete = <span>false</span>;
                <span>break</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> complete == <span>true</span> <span>{</span>
            <span>self</span>.game_map.remove(y);
            y -= <span>1</span>;
            <span>// increase the number of self.lines</span>
        <span>}</span>
        y += <span>1</span>;
    <span>}</span>
    <span>while</span> <span>self</span>.game_map.len() &lt; <span>16</span> <span>{</span>
        <span>self</span>.game_map.insert(<span>0</span>, <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">For now, I didn't add the score, lines sent counting, nor level handling but this is here that'll do it later.</p>
<p class="calibre3">Now time to explain this method a bit. Its purpose is to remove lines when they're full (meaning when every block is occupied by a <span><kbd class="calibre14">tetrimino</kbd></span> block). So we just go through the game map line by line and run the check on each.</p>
<p class="calibre3">The code itself doesn't use much of the <span>Rust-</span>specific syntax, but you might wonder why we did it like this. I'm talking about this loop:</p>
<div class="title-page-name">
<pre class="calibre22"><span>while</span> y &lt; <span>self</span>.game_map.len() <span>{</span></pre></div>
<p class="calibre3">When we could have just used:</p>
<div class="title-page-name">
<pre class="calibre22"><span>for</span> line <span>in</span> <span>self</span>.game_map <span>{</span></pre></div>
<p class="calibre3">This is actually a good question and the answer is simple, but maybe hard to understand, if you're used to how Rust ownership works.</p>
<p class="calibre3">All the problems actually come from this line:</p>
<div class="title-page-name">
<pre class="calibre22"><span>self</span>.game_map.remove(y);</pre></div>
<p class="calibre3">In here, we mutably borrow <span><kbd class="calibre14">self.game_map</kbd></span> in order to remove a line. However, <span><kbd class="calibre14">self.game_map</kbd></span> would already be non-mutably borrowed by the <span><kbd class="calibre14">for</kbd></span> loop! A quick reminder on how the borrowing rules work:</p>
<ul class="calibre10">
<li class="calibre11">You can non-mutably borrow a variable as many times as you want</li>
<li class="calibre11">You can mutably borrow a variable only if there are no other borrows (either mutable or non-mutable)</li>
</ul>
<p class="calibre3">So in our case, the <span><kbd class="calibre14">for</kbd></span> loop would break the second rule since we'd have a non-mutable borrow when trying to get mutable access to <span><kbd class="calibre14">self.game_map</kbd></span>.</p>
<p class="calibre3">In this case, we have two solutions:</p>
<ul class="calibre10">
<li class="calibre11">Iterate over the game map "by hand" (with an index variable)</li>
<li class="calibre11">Store lines to remove into a second vector and then remove them after we get out of the loop</li>
</ul>
<p class="calibre3">Both solutions are more or less equivalent in this case so I just picked the first one.</p>
<p class="calibre3">Once the first loop is finished, we have filled the game map with empty lines to replace the one(s) we deleted:</p>
<div class="title-page-name">
<pre class="calibre22"><span>while</span> <span>self</span>.game_map.len() &lt; <span>16</span> <span>{</span>
    <span>self</span>.game_map.insert(<span>0</span>, <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
<span>}</span></pre></div>
<p class="calibre3">And we're done with this method! Let's write the other one.</p>
<p class="calibre3">So now it's time to write the <span><kbd class="calibre14">make_permanent</kbd></span> method. Just like the previous one, it won't be a complete version, but in the future, this is where we'll update the score (we update it when a <span><kbd class="calibre14">tetrimino</kbd></span> is made permanent).</p>
<p class="calibre3">So let's write it:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> make_permanent(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = <span>self</span>.current_piece <span>{</span>
        <span>let</span> <span>mut</span> shift_y = <span>0</span>;

        <span>while</span> shift_y &lt; piece.states<span>[</span>piece.current_state <span>as</span>  <br class="calibre6"/><span>         usize</span><span>]</span>.len() &amp;&amp;
              piece.y + shift_y &lt; <span>self</span>.game_map.len() <span>{</span>
            <span>let</span> <span>mut</span> shift_x = <span>0</span>;

            <span>while</span> shift_x &lt; piece.states<span>[</span>piece.current_state <span>as</span>  <br class="calibre6"/><span>             usize</span><span>][</span>shift_y<span>]</span>.len() &amp;&amp;
                  (piece.x + shift_x <span>as</span> <span>isize</span>) &lt; <br class="calibre6"/><span>                   self</span>.game_map<span>[</span>piece.y +  <br class="calibre6"/>                   shift_y<span>]</span>.len() <span>as</span> <span>isize</span> <span>{</span>
                <span>if</span> piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>] <br class="calibre6"/>                [</span>shift_y<span>][</span>shift_x<span>]</span> != <span>0</span> <span>{</span>
                    <span>let</span> x = piece.x + shift_x <span>as</span> <span>isize</span>;
                    <span>self</span>.game_map<span>[</span>piece.y + shift_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> =
                        piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>] <br class="calibre6"/>                         [</span>shift_y<span>][</span>shift_x<span>]</span>;
                <span>}</span>
                shift_x += <span>1</span>;
            <span>}</span>
            shift_y += <span>1</span>;
        <span>}</span>
    <span>}</span>
    <span>self</span>.check_lines();
    <span>self</span>.current_piece = <span>None</span>;
<span>}</span></pre></div>
<p class="calibre3">This code doesn't seem very encouraging... Brace yourselves, explanations are coming:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = <span>self</span>.current_piece <span>{</span></pre></div>
<p class="calibre3">It's simple pattern matching. If <span><kbd class="calibre14">self.current_piece</kbd></span> is <span><kbd class="calibre14">Some</kbd></span>, then we enter the condition and the value contained by <span><kbd class="calibre14">Some</kbd></span> that is bound into the <span><kbd class="calibre14">piece</kbd></span> variable:</p>
<div class="title-page-name">
<pre class="calibre22"><span>while</span> shift_y &lt; piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>]</span>.len() &amp;&amp;
      piece.y + shift_y &lt; <span>self</span>.game_map.len() <span>{</span></pre></div>
<p class="calibre3">This loop and its condition allow us to avoid a buffer overflow error by checking whether we're not outside of the game map limit for the current rotation (that is, <span><kbd class="calibre14">self.current_state</kbd></span>).</p>
<p class="calibre3">The same goes for the inner loop (which iterates over the blocks of a line):</p>
<div class="title-page-name">
<pre class="calibre22"><span>while</span> shift_x &lt; piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>]</span>.len() &amp;&amp;
      (piece.x + shift_x <span>as</span> <span>isize</span>) &lt; <span>self</span>.game_map<span>[</span>piece.y + shift_y<span>]</span>.len() <span>as</span> <span>isize</span> <span>{</span></pre></div>
<p class="calibre3">It is in this loop that we write the blocks of the current <span><kbd class="calibre14">tetrimino</kbd></span> into the game map:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>][</span>shift_x<span>]</span> != <span>0</span> <span>{</span>
    <span>let</span> x = piece.x + shift_x <span>as</span> <span>isize</span>;
    <span>self</span>.game_map<span>[</span>piece.y + shift_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> =
        piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>][</span>shift_x<span>]</span>;
<span>}</span></pre></div>
<p class="calibre3">If the current block of the current <span><kbd class="calibre14">tetrimino</kbd></span> isn't empty, then we put it into the game map (it's as simple as that).</p>
<p class="calibre3">Once done, this is where we call the <span><kbd class="calibre14">check_lines</kbd></span> method. But now you'll certainly wonder why we don't call it directly inside the <span><kbd class="calibre14">if let</kbd></span> condition. Well, it's for the exact same reason that we didn't use the <span><kbd class="calibre14">for</kbd></span> loop inside the <span><kbd class="calibre14">check_lines</kbd></span> method, <span><kbd class="calibre14">self</kbd></span> is already mutably borrowed by the following line:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = <span>self</span>.current_piece <span>{</span></pre></div>
<p class="calibre3">That's right: if an element of a type is borrowed, then its parent is mutably borrowed as well!</p>
<p class="calibre3">With these two methods, our <span><kbd class="calibre14">Tetris</kbd></span> type is now fully implemented (minus the small required modifications that will come later). Time to add the <span><kbd class="calibre14">SDL</kbd></span> events handling!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">SDL events</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">There aren't many different events to handle:</p>
<ul class="calibre10">
<li class="calibre11"><em class="calibre21">Left</em> and <em class="calibre21">right arrow</em> keys to move the <span><kbd class="calibre14">tetrimino</kbd></span> to the right or the left</li>
<li class="calibre11"><em class="calibre21">Up arrow</em> key to make the <span><kbd class="calibre14">tetrimino</kbd></span> rotate</li>
<li class="calibre11"><em class="calibre21">Down arrow</em> key to make the <span><kbd class="calibre14">tetrimino</kbd></span> descend one block</li>
<li class="calibre11"><em class="calibre21">Spacebar</em> to make the <span><kbd class="calibre14">tetrimino</kbd></span> descend to the bottom instantly</li>
<li class="calibre11"><em class="calibre21">Escape</em> to quit the game</li>
</ul>
<p class="calibre3">It's still possible to add some later on (such as pausing the game with the <em class="calibre21">return</em> key, for example) but for now, let's focus on these ones. For this, go back inside the main loop of the game (inside the <span><kbd class="calibre14">main</kbd></span> function) and replace the current event handling with the following function:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> handle_events(tetris: &amp;<span>mut</span> Tetris, quit: &amp;<span>mut</span> <span>bool</span>, timer: &amp;<span>mut</span> SystemTime,
                 event_pump: &amp;<span>mut</span> sdl2::EventPump) -&gt; <span>bool</span> <span>{</span>
    <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>let</span> <span>mut</span> tmp_x = piece.x;
        <span>let</span> <span>mut</span> tmp_y = piece.y;

        <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
          <span>match</span> event <span>{</span>
          Event::Quit <span>{</span> .. <span>}</span> |
          Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <br class="calibre6"/><span>                {</span>
                    *quit = <span>true</span>;
                    <span>break</span>
                <span>}</span>
           Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Down), .. <span>}</span> =&gt;<br class="calibre6"/>                <span>{</span>
                    *timer = SystemTime::now();
                    tmp_y += <span>1</span>;
                <span>}</span>
           Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Right), .. <span>}</span> =&gt; <br class="calibre6"/><span>                {</span>
                    tmp_x += <span>1</span>;
                <span>}</span>
            Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Left), .. <span>}</span> =&gt; <br class="calibre6"/><span>                {</span>
                    tmp_x -= <span>1</span>;
                <span>}</span>
            Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Up), .. <span>}</span> =&gt; <br class="calibre6"/><span>                {</span>
                    piece.rotate(&amp;tetris.game_map);
                <span>}</span>
           Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Space), .. <span>}</span> =&gt; <br class="calibre6"/><span>               {</span>
                  <span>let</span> x = piece.x;
                  <span>let</span> <span>mut</span> y = piece.y;
           <span>while</span> piece.change_position(&amp;tetris.game_map, x, y + <span>1</span>) <br class="calibre6"/>           == <span>true</span> <span>{</span>
                        y += <span>1</span>;
                   }
                    make_permanent = <span>true</span>;
                <span>}</span>
                _ =&gt; <span>{}</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> !make_permanent <span>{</span>
         <span>if</span> piece.change_position(&amp;tetris.game_map, tmp_x, tmp_y)<br class="calibre6"/>           == <br class="calibre6"/>            false &amp;&amp;
               tmp_y != piece.y <span>{</span>
                make_permanent = <span>true</span>;
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> make_permanent <span>{</span>
        tetris.make_permanent();
        *timer = SystemTime::now();
    <span>}</span>
    make_permanent
<span>}</span></pre></div>
<p class="calibre3">Quite a big one:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> make_permanent = <span>false</span>;</pre></div>
<p class="calibre3">This variable will tell us whether the current <span><kbd class="calibre14">tetrimino</kbd></span> is still falling. If not, then it becomes <span><kbd class="calibre14">true</kbd></span>, the <span><kbd class="calibre14">tetrimino</kbd></span> is then put into the game map and we generate a new one. Luckily for us, we already wrote all the needed functions to perform these operations:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span></pre></div>
<p class="calibre3">This is simple pattern binding. If our game doesn't have a current piece (for some reason), then we don't do anything and just leave:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> tmp_x = piece.x;
<span>let</span> <span>mut</span> tmp_y = piece.y;</pre></div>
<p class="calibre3">If there is a move on the <span><kbd class="calibre14">x</kbd></span> or on the <span><kbd class="calibre14">y</kbd></span> axis, we'll write it into these variables and then we'll test whether the <span><kbd class="calibre14">tetrimino</kbd></span> can actually go there:</p>
<div class="title-page-name">
<pre class="calibre22"><span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span></pre></div>
<p class="calibre3">As there can be multiple events that happened since the last time we came into this function, we need to loop over all of them.</p>
<p class="calibre3">Now we're arriving at the interesting part:</p>
<div class="title-page-name">
<pre class="calibre22"><span>match</span> event <span>{</span>
    Event::Quit <span>{</span> .. <span>}</span> |
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
        *quit = <span>true</span>;
        <span>break</span>
    <span>}</span>
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Down), .. <span>}</span> =&gt; <span>{</span>
        *timer = SystemTime::now();
        tmp_y += <span>1</span>;
    <span>}</span>
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Right), .. <span>}</span> =&gt; <span>{</span>
        tmp_x += <span>1</span>;
    <span>}</span>
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Left), .. <span>}</span> =&gt; <span>{</span>
        tmp_x -= <span>1</span>;
    <span>}</span>
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Up), .. <span>}</span> =&gt; <span>{</span>
        piece.rotate(&amp;tetris.game_map);
    <span>}</span>
    Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Space), .. <span>}</span> =&gt; <span>{</span>
      <span>let</span> x = piece.x;
      <span>let</span> <span>mut</span> y = piece.y;
      <span>while</span> piece.change_position(&amp;tetris.game_map, x, y + <span>1</span>) ==  <br class="calibre6"/><span>      true</span> <span>{</span>
            y += <span>1</span>;
        <span>}</span>
        make_permanent = <span>true</span>;
    <span>}</span>
    _ =&gt; <span>{}</span>
<span>}</span></pre></div>
<p class="calibre3">We can almost consider this small code as the core of our application, without it, no interaction with the program is possible. If you want more interactions, this is where you'll add them:</p>
<div class="title-page-name">
<pre class="calibre22">Event::Quit <span>{</span> .. <span>}</span> |
Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
    *quit = <span>true</span>;
    <span>break</span>
<span>}</span></pre></div>
<p class="calibre3">If we receive a <em class="calibre21">quit</em> event from <span><kbd class="calibre14">sdl</kbd></span> or if we receive an <span><kbd class="calibre14">Escape</kbd></span>, <kbd class="calibre14">KeyDown</kbd> event, we set the <span><kbd class="calibre14">quit</kbd></span> variable to <span><kbd class="calibre14">true</kbd></span>. It'll be used outside of this function to then leave the main loop--and therefore leave the program itself. Then we <em class="calibre21">break;</em> no need to go further since we know that we're leaving the game:</p>
<div class="title-page-name">
<pre class="calibre22">Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Down), .. <span>}</span> =&gt; <span>{</span>
    *timer = SystemTime::now();
    tmp_y += <span>1</span>;
<span>}</span></pre></div>
<p class="calibre3">If the <em class="calibre21">down arrow</em> is pressed, we need to make our <span><kbd class="calibre14">tetrimino</kbd></span> descend by one block and also put the <span><kbd class="calibre14">timer</kbd></span> value to now. <span><kbd class="calibre14">timer</kbd></span> is used to know at what speed the <span><kbd class="calibre14">tetrimino</kbd></span> blocks are falling. The shorter the time, the faster they'll descend.</p>
<p class="calibre3">For now, it isn't used in this function, so we'll see how to handle it outside of it:</p>
<div class="title-page-name">
<pre class="calibre22">Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Right), .. <span>}</span> =&gt; <span>{</span>
    tmp_x += <span>1</span>;
<span>}</span>
Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Left), .. <span>}</span> =&gt; <span>{</span>
    tmp_x -= <span>1</span>;
<span>}</span></pre></div>
<p class="calibre3">In here, we handle the <em class="calibre21">right</em> and <em class="calibre21">left arrow</em> keys. It's just like the <em class="calibre21">down arrow</em> key, except we don't need to change the <span><kbd class="calibre14">timer</kbd></span> variable:</p>
<div class="title-page-name">
<pre class="calibre22">Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Up), .. <span>}</span> =&gt; <span>{</span>
    piece.rotate(&amp;tetris.game_map);
<span>}</span></pre></div>
<p class="calibre3">If we receive an <em class="calibre21">up arrow</em> key pressed event, we rotate the <span><kbd class="calibre14">tetrimino</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre22">Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Space), .. <span>}</span> =&gt; <span>{</span>
   <span>let</span> x = piece.x;
   <span>let</span> <span>mut</span> y = piece.y;
  <span>while</span> piece.change_position(&amp;tetris.game_map, x, y + <span>1</span>) == <span>true </span><span>{</span>
        y += <span>1</span>;
    <span>}</span>
    make_permanent = <span>true</span>;
<span>}</span></pre></div>
<p class="calibre3">And finally the last of our events: the <em class="calibre21">spacebar</em> key pressed event. Here, we move the <span><kbd class="calibre14">tetrimino</kbd></span> down as much as we can and then set the <span><kbd class="calibre14">make_permanent</kbd></span> variable to <span><kbd class="calibre14">true</kbd></span>.</p>
<p class="calibre3">With this, that's it for our events. However, like we said before if you want to add more events, this is where you should put them.</p>
<p class="calibre3">Time to put all this into our main loop:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> print_game_information(tetris: &amp;Tetris) <span>{</span>
    <span>println!</span>(<span>"Game over..."</span>);
    <span>println!</span>(<span>"Score:           {}"</span>, tetris.score);
    <span>// println!("Number of lines: {}", tetris.nb_lines);</span>
    <span>println!</span>(<span>"Current level:   {}"</span>, tetris.current_level);
    <span>// Check highscores here and update if needed</span>
<span>}</span>

<span>let</span> <span>mut</span> tetris = Tetris::new();
<span>let</span> <span>mut</span> timer = SystemTime::now();

<span>loop</span> <span>{</span>
    <span>if</span> <span>match</span> timer.elapsed() <span>{</span>
        <span>Ok</span>(elapsed) =&gt; elapsed.as_secs() &gt;= <span>1</span>,
        <span>Err</span>(_) =&gt; <span>false</span>,
    <span>}</span> <span>{</span>
        <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
        <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
            <span>let</span> x = piece.x;
            <span>let</span> y = piece.y + <span>1</span>;
            make_permanent =  <br class="calibre6"/>             !piece.change_position(&amp;tetris.game_map,  <br class="calibre6"/>             x, y);
        <span>}</span>
        <span>if</span> make_permanent <span>{</span>
            tetris.make_permanent();
        <span>}</span>
        timer = SystemTime::now();
    <span>}</span>

    <span>// We need to draw the tetris "grid" in here.</span>

    <span>if</span> tetris.current_piece.is_none() <span>{</span>
        <span>let</span> current_piece = tetris.create_new_tetrimino();
        <span>if</span> !current_piece.test_current_position(&amp;tetris.game_map) <span>{</span>
            print_game_information(&amp;tetris);
            <span>break</span>
        <span>}</span>
        tetris.current_piece = <span>Some</span>(current_piece);
    <span>}</span>
    <span>let</span> <span>mut</span> quit = <span>false</span>;
    <span>if</span> !handle_events(&amp;<span>mut</span> tetris, &amp;<span>mut</span> quit, &amp;<span>mut</span> timer, &amp;<span>mut</span> <br class="calibre6"/>     event_pump) <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
            <span>// We need to draw our current tetrimino in here.</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> quit <span>{</span>
        print_game_information(&amp;tetris);
        <span>break</span>
    <span>}</span>

    <span>// We need to draw the game map in here.</span>

    sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
<span>}</span></pre></div>
<p class="calibre3">Doesn't seem that long, right? Just a few comments where we're supposed to draw our <kbd class="calibre14">Tetris</kbd>, but otherwise everything is in there, which means that our <kbd class="calibre14">Tetris</kbd> is now fully functional (even though it isn't displayed).</p>
<p class="calibre3">Let's explain what's happening in there:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> tetris = Tetris::new();
<span>let</span> <span>mut</span> timer = SystemTime::now();</pre></div>
<p class="calibre3">In here, we initialize both our <kbd class="calibre14">Tetris</kbd> object and the <kbd class="calibre14">timer</kbd>. The timer will be used to let us know when the <span><kbd class="calibre14">tetrimino</kbd></span> is supposed to descend by one block:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>match</span> timer.elapsed() <span>{</span>
    <span>Ok</span>(elapsed) =&gt; elapsed.as_secs() &gt;= <span>1</span>,
    <span>Err</span>(_) =&gt; <span>false</span>,
<span>}</span> <span>{</span>
    <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>let</span> x = piece.x;
        <span>let</span> y = piece.y + <span>1</span>;
        make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>         x, y);
    <span>}</span>
    <span>if</span> make_permanent <span>{</span>
        tetris.make_permanent();
    <span>}</span>
    timer = SystemTime::now();
<span>}</span></pre></div>
<p class="calibre3">This code checks whether it's been one second or more since the last time the <span><kbd class="calibre14">tetrimino</kbd></span> descended by one block. If we want to handle levels, we'll need to replace the following line:</p>
<div class="title-page-name">
<pre class="calibre22"><span>Ok</span>(elapsed) =&gt; elapsed.as_secs() &gt;= <span>1</span>,</pre></div>
<p class="calibre3">Its replacement will need to be something more generic and we'll add an array to store the different levels' speed of descent.</p>
<p class="calibre3">So coming back to the code, if it's been one second or more then we try to make the <span><kbd class="calibre14">tetrimino</kbd></span> descend by one block. If it cannot, then we put it into the game map and re-initialize the <span><kbd class="calibre14">timer</kbd></span> variable.</p>
<p class="calibre3">Once again, you might wonder why we had to create the <span><kbd class="calibre14">make_permanent</kbd></span> variable instead of directly checking the output of:</p>
<div class="title-page-name">
<pre class="calibre22">!piece.change_position(&amp;tetris.game_map, x, y)</pre></div>
<p class="calibre3">It has an <span><kbd class="calibre14">if</kbd></span> condition, right? Well, just like the previous times, it's because of the borrow checker. We borrow <span><kbd class="calibre14">tetris</kbd></span> here:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span></pre></div>
<p class="calibre3">So as long as we're in this condition, we can't use <span><kbd class="calibre14">tetris</kbd></span> mutably, which is why we store the result of the condition in <span><kbd class="calibre14">make_permanent</kbd></span> so we can use the <span><kbd class="calibre14">make_permanent</kbd></span> method after:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> tetris.current_piece.is_none() <span>{</span>
    <span>let</span> current_piece = tetris.create_new_tetrimino();
    <span>if</span> !current_piece.test_current_position(&amp;tetris.game_map) <span>{</span>
        print_game_information(&amp;tetris);
        <span>return</span>
    <span>}</span>
    tetris.current_piece = <span>Some</span>(current_piece);
<span>}</span></pre></div>
<p class="calibre3">If there is no current <span><kbd class="calibre14">tetrimino</kbd></span>, we need to generate a new one, which we do by calling the <span><kbd class="calibre14">create_new_tetrimino</kbd></span> method. Then we check whether it can be put into the game on the top line by calling the <span><kbd class="calibre14">test_current_position</kbd></span> method. If not, then it means the game is over and we quit. Otherwise, we store the newly-generated <span><kbd class="calibre14">tetrimino</kbd></span> in <span><kbd class="calibre14">tetris.current_piece</kbd></span> and we move on.</p>
<p class="calibre3">Two things are missing here:</p>
<ul class="calibre10">
<li class="calibre11">Since we don't handle the increase of lines sent, nor the score, nor the level, there's no need to print them</li>
<li class="calibre11">We didn't add yet the highscores loading/overwrite</li>
</ul>
<p class="calibre3">Of course, we'll add all this later on:</p>
<div class="title-page-name">
<pre class="calibre22"><span>let</span> <span>mut</span> quit = <span>false</span>;
<span>if</span> !handle_events(&amp;<span>mut</span> tetris, &amp;<span>mut</span> quit, &amp;<span>mut</span> timer, &amp;<span>mut</span> event_pump) <span>{</span>
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>// We need to draw our current tetrimino in here.</span>
    <span>}</span>
<span>}</span>
<span>if</span> quit <span>{</span>
    print_game_information(&amp;tetris);
    <span>break</span>
<span>}</span></pre></div>
<p class="calibre3">This code calls the <span><kbd class="calibre14">handle_events</kbd></span> function and acts according to its output. It returns whether the current <span><kbd class="calibre14">tetrimino</kbd></span> has been put into the game map or not. If it is the case, then there is no need to draw it.</p>
<p class="calibre3">We now need to do the following remaining things:</p>
<ul class="calibre10">
<li class="calibre11">Add the score, levels, and number of lines sent</li>
<li class="calibre11">Load/overwrite the highscores if needed</li>
<li class="calibre11">Actually draw the <kbd class="calibre14">Tetris</kbd></li>
</ul>
<p class="calibre3">Seems like we're getting very close to the end! Let's start by adding the score, number of lines sent, and levels!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Score, level, lines sent</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The biggest required change will be the level handling. You need to create an array with different times to increase the <span><kbd class="calibre14">tetrimino</kbd></span>'s speed of descent and to check whether the level needs to be changed or not (based on the number of lines).</p>
<p class="calibre3">The score will be updated in the following cases:</p>
<ul class="calibre10">
<li class="calibre11">When the <span><kbd class="calibre14">tetrimino</kbd></span> is made permanent</li>
<li class="calibre11">When a line is sent</li>
<li class="calibre11">When the player makes a <kbd class="calibre14">Tetris</kbd> (no more blocks in the game map)</li>
</ul>
<p class="calibre3">Let's start with the easiest change—the score.</p>
<p class="calibre3">First, let's add the following method into our <span><kbd class="calibre14">Tetris</kbd></span> type:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> update_score(&amp;<span>mut</span> <span>self</span>, to_add: <span>u32</span>) <span>{</span>
    <span>self</span>.score += to_add;
<span>}</span></pre></div>
<p class="calibre3">We can suppose that no additional explanations are required here.</p>
<p class="calibre3">Next, let's update a few methods:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> check_lines(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>let</span> <span>mut</span> y = <span>0</span>;
    <span>let</span> <span>mut</span> score_add = <span>0</span>;

    <span>while</span> y &lt; <span>self</span>.game_map.len() <span>{</span>
        <span>let</span> <span>mut</span> complete = <span>true</span>;

        <span>for</span> x <span>in</span> &amp;<span>self</span>.game_map<span>[</span>y<span>]</span> <span>{</span>
            <span>if</span> *x == <span>0</span> <span>{</span>
                complete = <span>false</span>;
                <span>break</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> complete == <span>true</span> <span>{</span>
            score_add += <span>self</span>.current_level;
            <span>self</span>.game_map.remove(y);
            y -= <span>1</span>;
        <span>}</span>
        y += <span>1</span>;
    <span>}</span>
    <span>if</span> <span>self</span>.game_map.len() == <span>0</span> <span>{</span>
        <span>// A "tetris"!</span>
        score_add += <span>1000</span>;
    <span>}</span>
    <span>self</span>.update_score(score_add);
    <span>while</span> <span>self</span>.game_map.len() &lt; <span>16</span> <span>{</span>
        <span>// we'll add this method just after!</span>
        <span>self</span>.increase_line();
        <span>self</span>.game_map.insert(<span>0</span>, <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>,<br class="calibre6"/>         <span>0</span><span>]</span>);
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">As usual, we create a temporary variable (here, <span><kbd class="calibre14">score_add</kbd></span>) and once the borrow of <span><kbd class="calibre14">self</kbd></span> is over, we call the <span><kbd class="calibre14">update_score</kbd></span> method. There is also the usage of the <span><kbd class="calibre14">increase_line</kbd></span> method. We haven't defined it yet; it'll come just after.</p>
<p class="calibre3">The second method is <span><kbd class="calibre14">make_permanent</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre23"><span>fn</span> make_permanent(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>let</span> <span>mut</span> to_add = <span>0</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = <span>self</span>.current_piece <span>{</span>
        <span>let</span> <span>mut</span> shift_y = <span>0</span>;

        <span>while</span> shift_y &lt; piece.states<span>[</span>piece.current_state <span>as</span> <br class="calibre6"/><span>         usize</span><span>]</span>.len() &amp;&amp;
              piece.y + shift_y &lt; <span>self</span>.game_map.len() <span>{</span>
            <span>let</span> <span>mut</span> shift_x = <span>0</span>;

            <span>while</span> shift_x &lt; piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>] <br class="calibre6"/>             [</span>shift_y<span>]</span>.len() &amp;&amp;
                  (piece.x + shift_x <span>as</span> <span>isize</span>) &lt; <span>self</span>.game_map<span>[</span>piece.y  <br class="calibre6"/>                   + shift_y<span>]</span>.len() <span>as</span> <span>isize</span> <span>{</span>
                <span>if</span> piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>] <br class="calibre6"/>                 [</span>shift_x<span>]</span> != <span>0</span> <span>{</span>
                    <span>let</span> x = piece.x + shift_x <span>as</span> <span>isize</span>;
                    <span>self</span>.game_map<span>[</span>piece.y + shift_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> =
                        piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>]    <br class="calibre6"/>                         [</span>shift_y<span>][</span>shift_x<span>]</span>;
                <span>}</span>
                shift_x += <span>1</span>;
            <span>}</span>
            shift_y += <span>1</span>;
        <span>}</span>
        to_add += <span>self</span>.current_level;
    <span>}</span>
    <span>self</span>.update_score(to_add);
    <span>self</span>.check_lines();
    <span>self</span>.current_piece = <span>None</span>;
<span>}</span></pre></div>
<p class="calibre3">Include this just above the <span><kbd class="calibre14">self.check_lines</kbd></span> call.</p>
<p class="calibre3">With these two methods updated, we now have the score handling fully implemented.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Levels and lines sent</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The next two being strongly bound (the level depends directly on the number of lines sent), we'll implement them at the same time.</p>
<p class="calibre3">Before doing anything else, let's define the two following <kbd class="calibre14">const</kbd>:</p>
<div class="title-page-name">
<pre class="calibre22"><span>const</span> LEVEL_TIMES: <span>[</span><span>u32</span>; <span>10</span><span>]</span> = <span>[</span><span>1000</span>, <span>850</span>, <span>700</span>, <span>600</span>, <span>500</span>, <span>400</span>, <span>300</span>, <span>250</span>, <span>221</span>, <span>190</span><span>]</span>;
<span>const</span> LEVEL_LINES: <span>[</span><span>u32</span>; <span>10</span><span>]</span> = <span>[</span><span>20</span>,   <span>40</span>,  <span>60</span>,  <span>80</span>,  <span>100</span>, <span>120</span>, <span>140</span>, <span>160</span>, <span>180</span>, <span>200</span><span>]</span>;</pre></div>
<p class="calibre3">The first one corresponds to the times before the current <span><kbd class="calibre14">tetrimino</kbd></span> descends by one block. Each case being a different level.</p>
<p class="calibre3">The second one corresponds to how many lines the player needs before getting to the next level.</p>
<p class="calibre3">Next, let's add the following method in our <span><kbd class="calibre14">Tetris</kbd></span> type:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> increase_line(&amp;<span>mut</span> <span>self</span>) <span>{</span>
    <span>self</span>.nb_lines += <span>1</span>;
    <span>if</span> <span>self</span>.nb_lines &gt; LEVEL_LINES<span>[</span><span>self</span>.current_level <span>as</span> <span>usize</span> - <span>1</span><span>]</span> <span>{</span>
        <span>self</span>.current_level += <span>1</span>;
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">Nothing complicated. Just be careful when reading the <span><kbd class="calibre14">LEVEL_LINES</kbd></span> const because our <span><kbd class="calibre14">current_level</kbd></span> variable starts at <kbd class="calibre14">1</kbd> and not 0.</p>
<p class="calibre3">Next, we'll need to update how we determine whether the time is up or not. To do so, let's write another function:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> is_time_over() <span>{</span>
    <span>match</span> timer.elapsed() <span>{</span>
        <span>Ok</span>(elapsed) =&gt; <span>{</span>
            <span>let</span> millis = elapsed.as_secs() <span>as</span> <span>u32</span> * <span>1000</span> + <br class="calibre6"/>             elapsed.subsec_nanos() / <span>1_000_000</span>;
            millis &gt; LEVEL_TIMES<span>[</span>tetris.current_level <span>as</span> <span>usize</span> - <span>1</span><span>]</span>
        <span>}</span>
        <span>Err</span>(_) =&gt; <span>false</span>,
    <span>}</span>
<span>}</span></pre></div>
<p class="calibre3">A small but tricky one. The problem is that the type returned by <span><kbd class="calibre14">timer.elapsed</kbd></span> (which is <span><kbd class="calibre14">Duration</kbd></span>) doesn't provide a method to get the number of milliseconds, so we need to get it ourselves.</p>
<p class="calibre3">First, we get the number of seconds elapsed and then multiply it by 1,000 (because 1 second = 1,000 milliseconds). Finally, we get the number of nanoseconds (in the current second) and divide it by 1,000,000 (because 1 millisecond = 1 million nanoseconds).</p>
<p class="calibre3">We can now compare the results to see whether the <span><kbd class="calibre14">tetrimino</kbd></span> should descend or not and return the result:</p>
<div class="title-page-name">
<pre class="calibre22"><span>if</span> is_time_over(&amp;tetris, &amp;timer) <span>{</span>
    <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>let</span> x = piece.x;
        <span>let</span> y = piece.y + <span>1</span>;
        make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>         x, y);
    <span>}</span>
    <span>if</span> make_permanent <span>{</span>
        tetris.make_permanent();
    <span>}</span>
    timer = SystemTime::now();
<span>}</span></pre></div>
<p class="calibre3">And with this, we've finished this part. Let's make the last one now: the highscore loading/overwriting!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Highscores loading/overwriting</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We already saw how to perform the I/O operations in the previous chapter, so it'll be very quick to do:</p>
<div class="title-page-name">
<pre class="calibre22"><span>const</span> NB_HIGHSCORES: <span>usize</span> = <span>5</span>;

<span>fn</span> update_vec(v: &amp;<span>mut</span> <span>Vec</span>&lt;<span>u32</span>&gt;, value: <span>u32</span>) -&gt; <span>bool</span> <span>{</span>
    <span>if</span> v.len() &lt; NB_HIGHSCORES <span>{</span>
        v.push(value);<br class="calibre6"/>        v.sort();
        <span>true</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>for</span> entry <span>in</span> v.iter_mut() <span>{</span>
            <span>if</span> value &gt; *entry <span>{</span>
                *entry = value;
                <span>return</span> <span>true</span>;
            <span>}</span>
        <span>}</span>
        <span>false</span>
    <span>}</span>
<span>}</span>

<span>fn</span> print_game_information(tetris: &amp;Tetris) <span>{</span>
    <span>let</span> <span>mut</span> new_highest_highscore = <span>true</span>;
    <span>let</span> <span>mut</span> new_highest_lines_sent = <span>true</span>;
    <span>if</span> <span>let</span> <span>Some</span>((<span>mut</span> highscores, <span>mut</span> lines_sent)) = <br class="calibre6"/>     load_highscores_and_lines() <span>{</span>
        new_highest_highscore = update_vec(&amp;<span>mut</span> highscores,  <br class="calibre6"/>         tetris.score);
        new_highest_lines_sent = update_vec(&amp;<span>mut</span> lines_sent,  <br class="calibre6"/>         tetris.nb_lines);
        <span>if</span> new_highest_highscore || new_highest_lines_sent <span>{</span>
            save_highscores_and_lines(&amp;highscores, &amp;lines_sent);
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        save_highscores_and_lines(&amp;<span>[</span>tetris.score<span>]</span>, &amp;<br class="calibre6"/><span>         [</span>tetris.nb_lines<span>]</span>);
    <span>}</span>
    <span>println!</span>(<span>"Game over..."</span>);
    <span>println!</span>(<span>"Score:           {}{}"</span>,
             tetris.score,
             <span>if</span> new_highest_highscore <span>{</span> <span>" [NEW HIGHSCORE]"</span><span>}</span> <span>else</span> <span>{</span>   <br class="calibre6"/><span>              ""</span> <span>}</span>);
    <span>println!</span>(<span>"Number of lines: {}{}"</span>,
             tetris.nb_lines,
             <span>if</span> new_highest_lines_sent <span>{</span> <span>" [NEW HIGHSCORE]"</span><span>}</span> <span>else</span> <span>{</span>  <br class="calibre6"/><span>              ""</span> <span>}</span>);
    <span>println!</span>(<span>"Current level:   {}"</span>, tetris.current_level);
<span>}</span></pre></div>
<p class="calibre3">Not much to explain with this code. For the moment, we limited the number of each highscore to <kbd class="calibre14">5</kbd>. Just update it as you want.</p>
<p class="calibre3">And with this code, all the mechanisms are implemented. All that's left is to actually draw the game!</p>
<p class="calibre3">Here is the full code for this chapter:</p>
<div class="title-page-name">
<pre class="calibre22"><span>extern</span> <span>crate</span> rand;
<span>extern</span> <span>crate</span> sdl2;

<span>use</span> sdl2::event::Event;
<span>use</span> sdl2::keyboard::Keycode;
<span>use</span> sdl2::pixels::Color;
<span>use</span> sdl2::rect::Rect;
<span>use</span> sdl2::render::<span>{</span>Canvas, Texture, TextureCreator<span>}</span>;
<span>use</span> sdl2::video::<span>{</span>Window, WindowContext<span>}</span>;

<span>use</span> std::fs::File;
<span>use</span> std::io::<span>{</span><span>self</span>, Read, Write<span>}</span>;
<span>use</span> std::thread::sleep;
<span>use</span> std::time::<span>{</span>Duration, SystemTime<span>}</span>;

<span>const</span> TETRIS_HEIGHT: <span>usize</span> = <span>40</span>;
<span>const</span> HIGHSCORE_FILE: &amp;<span>'static</span> <span>str</span> = <span>"scores.txt"</span>;
<span>const</span> LEVEL_TIMES: <span>[</span><span>u32</span>; <span>10</span><span>]</span> = <span>[</span><span>1000</span>, <span>850</span>, <span>700</span>, <span>600</span>, <span>500</span>, <span>400</span>, <span>300</span>, <span>250</span>, <span>221</span>, <span>190</span><span>]</span>;
<span>const</span> LEVEL_LINES: <span>[</span><span>u32</span>; <span>10</span><span>]</span> = <span>[</span><span>20</span>,   <span>40</span>,  <span>60</span>,  <span>80</span>,  <span>100</span>, <span>120</span>, <span>140</span>, <span>160</span>, <span>180</span>, <span>200</span><span>]</span>;
<span>const</span> NB_HIGHSCORES: <span>usize</span> = <span>5</span>;

<span>type</span> Piece = <span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;;
<span>type</span> States = <span>Vec</span>&lt;Piece&gt;;

<span>trait</span> TetriminoGenerator <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino;
<span>}</span>

<span>struct</span> TetriminoI;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoI <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>1</span>, <span>1</span>, <span>1</span>, <span>1</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>1</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoJ;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoJ <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>2</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>2</span>, <span>2</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoL;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoL <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>3</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>3</span>, <span>3</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>3</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoO;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoO <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>4</span>, <span>4</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>4</span>, <span>4</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>5</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoS;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoS <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>5</span>, <span>5</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>5</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>5</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoZ;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoZ <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>6</span>, <span>6</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>6</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>6</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> TetriminoT;

<span>impl</span> TetriminoGenerator <span>for</span> TetriminoT <span>{</span>
    <span>fn</span> new() -&gt; Tetrimino <span>{</span>
        Tetrimino <span>{</span>
            states: <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>7</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]</span>,
                         <span>vec!</span><span>[</span><span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>7</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>7</span>, <span>0</span>, <span>0</span><span>]</span>,
                              <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]]]</span>,
            x: <span>4</span>,
            y: <span>0</span>,
            current_state: <span>0</span>,
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> Tetrimino <span>{</span>
    states: States,
    x: <span>isize</span>,
    y: <span>usize</span>,
    current_state: <span>u8</span>,
<span>}</span>

<span>impl</span> Tetrimino <span>{</span>
    <span>fn</span> rotate(&amp;<span>mut</span> <span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>) <span>{</span>
        <span>let</span> <span>mut</span> tmp_state = <span>self</span>.current_state + <span>1</span>;
        <span>if</span> tmp_state <span>as</span> <span>usize</span> &gt;= <span>self</span>.states.len() <span>{</span>
            tmp_state = <span>0</span>;
        <span>}</span>
        <span>let</span> x_pos = <span>[</span><span>0</span>, -<span>1</span>, <span>1</span>, -<span>2</span>, <span>2</span>, -<span>3</span><span>]</span>;
        <span>for</span> x <span>in</span> x_pos.iter() <span>{</span>
            <span>if</span> <span>self</span>.test_position(game_map, tmp_state <span>as</span> <span>usize</span>,
                                  <span>self</span>.x + x, <span>self</span>.y) == <span>true</span> <span>{</span>
                <span>self</span>.current_state = tmp_state;
                <span>self</span>.x += *x;
                <span>break</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>fn</span> test_position(&amp;<span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>,
                     tmp_state: <span>usize</span>, x: <span>isize</span>, y: <span>usize</span>) -&gt; <span>bool</span> <span>{</span>
        <span>for</span> shift_y <span>in</span> <span>0.</span>.<span>4</span> <span>{</span>
            <span>for</span> shift_x <span>in</span> <span>0.</span>.<span>4</span> <span>{</span>
                <span>let</span> x = x + shift_x;
                <span>if</span> <span>self</span>.states<span>[</span>tmp_state<span>][</span>shift_y<span>][</span>shift_x <span>as</span> <span>usize</span><span>]</span> != <span>0</span> &amp;&amp;
                    (y + shift_y &gt;= game_map.len() ||
                     x &lt; <span>0</span> ||
                     x <span>as</span> <span>usize</span> &gt;= game_map<span>[</span>y + shift_y<span>]</span>.len() ||
                     game_map<span>[</span>y + shift_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> != <span>0</span>) <span>{</span>
                    <span>return</span> <span>false</span>;
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span>;
    <span>}</span>

    <span>fn</span> test_current_position(&amp;<span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>) -&gt; <span>bool</span> <span>{</span>
        <span>self</span>.test_position(game_map, <span>self</span>.current_state <span>as</span> <span>usize</span>, <span>self</span>.x, <span>self</span>.y)
    <span>}</span>

    <span>fn</span> change_position(&amp;<span>mut</span> <span>self</span>, game_map: &amp;<span>[</span><span>Vec</span>&lt;<span>u8</span>&gt;<span>]</span>, new_x: <span>isize</span>, new_y: <span>usize</span>) -&gt; <span>bool</span> <span>{</span>
        <span>if</span> <span>self</span>.test_position(game_map, <span>self</span>.current_state <span>as</span> <span>usize</span>, new_x, new_y) == <span>true</span> <span>{</span>
            <span>self</span>.x = new_x <span>as</span> <span>isize</span>;
            <span>self</span>.y = new_y;
            <span>true</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>false</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>struct</span> Tetris <span>{</span>
    game_map: <span>Vec</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;,
    current_level: <span>u32</span>,
    score: <span>u32</span>,
    nb_lines: <span>u32</span>,
    current_piece: <span>Option</span>&lt;Tetrimino&gt;,
<span>}</span>

<span>impl</span> Tetris <span>{</span>
    <span>fn</span> new() -&gt; Tetris <span>{</span>
        <span>let</span> <span>mut</span> game_map = <span>Vec</span>::new();
        <span>for</span> _ <span>in</span> <span>0.</span>.<span>16</span> <span>{</span>
            game_map.push(<span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
        <span>}</span>
        Tetris <span>{</span>
            game_map: game_map,
            current_level: <span>1</span>,
            score: <span>0</span>,
            nb_lines: <span>0</span>,
            current_piece: <span>None</span>,
        <span>}</span>
    <span>}</span>

    <span>fn</span> update_score(&amp;<span>mut</span> <span>self</span>, to_add: <span>u32</span>) <span>{</span>
        <span>self</span>.score += to_add;
    <span>}</span>

    <span>fn</span> increase_level(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>self</span>.current_level += <span>1</span>;
    <span>}</span>

    <span>fn</span> increase_line(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>self</span>.nb_lines += <span>1</span>;
        <span>if</span> <span>self</span>.nb_lines &gt; LEVEL_LINES<span>[</span><span>self</span>.current_level <span>as</span> <span>usize</span> - <span>1</span><span>]</span> <span>{</span>
            <span>self</span>.increase_level();
        <span>}</span>
    <span>}</span>

    <span>fn</span> check_lines(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>let</span> <span>mut</span> y = <span>0</span>;
        <span>let</span> <span>mut</span> score_add = <span>0</span>;

        <span>while</span> y &lt; <span>self</span>.game_map.len() <span>{</span>
            <span>let</span> <span>mut</span> complete = <span>true</span>;

            <span>for</span> x <span>in</span> &amp;<span>self</span>.game_map<span>[</span>y<span>]</span> <span>{</span>
                <span>if</span> *x == <span>0</span> <span>{</span>
                    complete = <span>false</span>;
                    <span>break</span>
                <span>}</span>
            <span>}</span>
            <span>if</span> complete == <span>true</span> <span>{</span>
                score_add += <span>self</span>.current_level;
                <span>self</span>.game_map.remove(y);
                y -= <span>1</span>;
            <span>}</span>
            y += <span>1</span>;
        <span>}</span>
        <span>if</span> <span>self</span>.game_map.len() == <span>0</span> <span>{</span>
            <span>// A "tetris"!</span>
            score_add += <span>1000</span>;
        <span>}</span>
        <span>self</span>.update_score(score_add);
        <span>while</span> <span>self</span>.game_map.len() &lt; <span>16</span> <span>{</span>
            <span>self</span>.increase_line();
            <span>self</span>.game_map.insert(<span>0</span>, <span>vec!</span><span>[</span><span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span><span>]</span>);
        <span>}</span>
    <span>}</span>

    <span>fn</span> create_new_tetrimino(&amp;<span>self</span>) -&gt; Tetrimino <span>{</span>
        <span>static</span> <span>mut</span> PREV: <span>u8</span> = <span>7</span>;
        <span>let</span> <span>mut</span> rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
        <span>if</span> <span>unsafe</span> <span>{</span> PREV <span>}</span> == rand_nb <span>{</span>
            rand_nb = rand::random::&lt;<span>u8</span>&gt;() % <span>7</span>;
        <span>}</span>
        <span>unsafe</span> <span>{</span> PREV = rand_nb; <span>}</span>
        <span>match</span> rand_nb <span>{</span>
            <span>0</span> =&gt; TetriminoI::new(),
            <span>1</span> =&gt; TetriminoJ::new(),
            <span>2</span> =&gt; TetriminoL::new(),
            <span>3</span> =&gt; TetriminoO::new(),
            <span>4</span> =&gt; TetriminoS::new(),
            <span>5</span> =&gt; TetriminoZ::new(),
            <span>6</span> =&gt; TetriminoT::new(),
            _ =&gt; <span>unreachable!</span>(),
        <span>}</span>
    <span>}</span>

    <span>fn</span> make_permanent(&amp;<span>mut</span> <span>self</span>) <span>{</span>
        <span>let</span> <span>mut</span> to_add = <span>0</span>;
        <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = <span>self</span>.current_piece <span>{</span>
            <span>let</span> <span>mut</span> shift_y = <span>0</span>;

            <span>while</span> shift_y &lt; piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>]</span>.len() &amp;&amp;
                  piece.y + shift_y &lt; <span>self</span>.game_map.len() <span>{</span>
                <span>let</span> <span>mut</span> shift_x = <span>0</span>;

                <span>while</span> shift_x &lt; piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>] <br class="calibre6"/>                  [</span>shift_y<span>]</span>.len() &amp;&amp;
                      (piece.x + shift_x <span>as</span> <span>isize</span>) &lt; <span>self</span>.game_map<span>[</span>piece.y + <br class="calibre6"/>                       shift_y<span>]</span>.len() <span>as</span> <span>isize</span> <span>{</span>
                    <span>if</span> piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>][</span>shift_x<span>]</span>  <br class="calibre6"/>                    != <span>0</span> <span>{</span>
                        <span>let</span> x = piece.x + shift_x <span>as</span> <span>isize</span>;
                        <span>self</span>.game_map<span>[</span>piece.y + shift_y<span>][</span>x <span>as</span> <span>usize</span><span>]</span> =
                            piece.states<span>[</span>piece.current_state <span>as</span> <span>usize</span><span>][</span>shift_y<span>]<br class="calibre6"/>                            [</span>shift_x<span>]</span>;
                    <span>}</span>
                    shift_x += <span>1</span>;
                <span>}</span>
                shift_y += <span>1</span>;
            <span>}</span>
            to_add += <span>self</span>.current_level;
        <span>}</span>
        <span>self</span>.update_score(to_add);
        <span>self</span>.check_lines();
        <span>self</span>.current_piece = <span>None</span>;
    <span>}</span>
<span>}</span>

<span>fn</span> handle_events(tetris: &amp;<span>mut</span> Tetris, quit: &amp;<span>mut</span> <span>bool</span>, timer: &amp;<span>mut</span> SystemTime,
                 event_pump: &amp;<span>mut</span> sdl2::EventPump) -&gt; <span>bool</span> <span>{</span>
    <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
    <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
        <span>let</span> <span>mut</span> tmp_x = piece.x;
        <span>let</span> <span>mut</span> tmp_y = piece.y;

        <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
            <span>match</span> event <span>{</span>
                Event::Quit <span>{</span> .. <span>}</span> |
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
                    *quit = <span>true</span>;
                    <span>break</span>
                <span>}</span>
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Down), .. <span>}</span> =&gt; <span>{</span>
                    *timer = SystemTime::now();
                    tmp_y += <span>1</span>;
                <span>}</span>
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Right), .. <span>}</span> =&gt; <span>{</span>
                    tmp_x += <span>1</span>;
                <span>}</span>
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Left), .. <span>}</span> =&gt; <span>{</span>
                    tmp_x -= <span>1</span>;
                <span>}</span>
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Up), .. <span>}</span> =&gt; <span>{</span>
                    piece.rotate(&amp;tetris.game_map);
                <span>}</span>
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Space), .. <span>}</span> =&gt; <span>{</span>
                    <span>let</span> x = piece.x;
                    <span>let</span> <span>mut</span> y = piece.y;
                    <span>while</span> piece.change_position(&amp;tetris.game_map, x, y + <span>1</span>) == <span>true</span> <br class="calibre6"/><span>                    {</span>
                        y += <span>1</span>;
                    <span>}</span>
                    make_permanent = <span>true</span>;
                <span>}</span>
                _ =&gt; <span>{}</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> !make_permanent <span>{</span>
            <span>if</span> piece.change_position(&amp;tetris.game_map, tmp_x, tmp_y) == <span>false</span> &amp;&amp;
               tmp_y != piece.y <span>{</span>
                make_permanent = <span>true</span>;
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> make_permanent <span>{</span>
        tetris.make_permanent();
        *timer = SystemTime::now();
    <span>}</span>
    make_permanent
<span>}</span>

<span>fn</span> write_into_file(content: &amp;<span>str</span>, file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
    <span>let</span> <span>mut</span> f = File::create(file_name)?;
    f.write_all(content.as_bytes())
<span>}</span>

<span>fn</span> read_from_file(file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;<span>String</span>&gt; <span>{</span>
    <span>let</span> <span>mut</span> f = File::open(file_name)?;
    <span>let</span> <span>mut</span> content = <span>String</span>::new();
    f.read_to_string(&amp;<span>mut</span> content)?;
    <span>Ok</span>(content)
<span>}</span>

<span>fn</span> slice_to_string(slice: &amp;<span>[</span><span>u32</span><span>]</span>) -&gt; <span>String</span> <span>{</span>
    slice.iter().map(|highscore| highscore.to_string()).collect::&lt;<span>Vec</span>&lt;<span>String</span>&gt;&gt;().join(<span>" "</span>)
<span>}</span>

<span>fn</span> save_highscores_and_lines(highscores: &amp;<span>[</span><span>u32</span><span>]</span>, number_of_lines: &amp;<span>[</span><span>u32</span><span>]</span>) -&gt; <span>bool</span> <span>{</span>
    <span>let</span> s_highscores = slice_to_string(highscores);
    <span>let</span> s_number_of_lines = slice_to_string(number_of_lines);
    write_into_file(&amp;<span>format!</span>(<span>"{}</span><span>\n</span><span>{}</span><span>\n</span><span>"</span>, s_highscores, s_number_of_lines), HIGHSCORE_FILE).is_ok()
<span>}</span>

<span>fn</span> line_to_slice(line: &amp;<span>str</span>) -&gt; <span>Vec</span>&lt;<span>u32</span>&gt; <span>{</span>
    line.split(<span>" "</span>).filter_map(|nb| nb.parse::&lt;<span>u32</span>&gt;().ok()).collect()
<span>}</span>

<span>fn</span> load_highscores_and_lines() -&gt; <span>Option</span>&lt;(<span>Vec</span>&lt;<span>u32</span>&gt;, <span>Vec</span>&lt;<span>u32</span>&gt;)&gt; <span>{</span>
    <span>if</span> <span>let</span> <span>Ok</span>(content) = read_from_file(HIGHSCORE_FILE) <span>{</span>
        <span>let</span> <span>mut</span> lines = content.splitn(<span>2</span>, <span>"</span><span>\n</span><span>"</span>).map(|line| line_to_slice(line)).collect::&lt;<span>Vec</span>&lt;_&gt;&gt;();
        <span>if</span> lines.len() == <span>2</span> <span>{</span>
            <span>let</span> (lines_sent, highscores) = (lines.pop().unwrap(), lines.pop().unwrap());
            <span>Some</span>((highscores, lines_sent))
        <span>}</span> <span>else</span> <span>{</span>
            <span>None</span>
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>None</span>
    <span>}</span>
<span>}</span>

<span>fn</span> update_vec(v: &amp;<span>mut</span> <span>Vec</span>&lt;<span>u32</span>&gt;, value: <span>u32</span>) -&gt; <span>bool</span> <span>{</span>
    <span>if</span> v.len() &lt; NB_HIGHSCORES <span>{</span>
        v.push(value);
        <span>true</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>for</span> entry <span>in</span> v.iter_mut() <span>{</span>
            <span>if</span> value &gt; *entry <span>{</span>
                *entry = value;
                <span>return</span> <span>true</span>;
            <span>}</span>
        <span>}</span>
        <span>false</span>
    <span>}</span>
<span>}</span>

<span>fn</span> print_game_information(tetris: &amp;Tetris) <span>{</span>
    <span>let</span> <span>mut</span> new_highest_highscore = <span>true</span>;
    <span>let</span> <span>mut</span> new_highest_lines_sent = <span>true</span>;
    <span>if</span> <span>let</span> <span>Some</span>((<span>mut</span> highscores, <span>mut</span> lines_sent)) = load_highscores_and_lines() <span>{</span>
        new_highest_highscore = update_vec(&amp;<span>mut</span> highscores, tetris.score);
        new_highest_lines_sent = update_vec(&amp;<span>mut</span> lines_sent, tetris.nb_lines);
        <span>if</span> new_highest_highscore || new_highest_lines_sent <span>{</span>
            save_highscores_and_lines(&amp;highscores, &amp;lines_sent);
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        save_highscores_and_lines(&amp;<span>[</span>tetris.score<span>]</span>, &amp;<span>[</span>tetris.nb_lines<span>]</span>);
    <span>}</span>
    <span>println!</span>(<span>"Game over..."</span>);
    <span>println!</span>(<span>"Score:           {}{}"</span>,
             tetris.score,
             <span>if</span> new_highest_highscore <span>{</span> <span>" [NEW HIGHSCORE]"</span><span>}</span> <span>else</span> <span>{</span> <span>""</span> <span>}</span>);
    <span>println!</span>(<span>"Number of lines: {}{}"</span>,
             tetris.nb_lines,
             <span>if</span> new_highest_lines_sent <span>{</span> <span>" [NEW HIGHSCORE]"</span><span>}</span> <span>else</span> <span>{</span> <span>""</span> <span>}</span>);
    <span>println!</span>(<span>"Current level:   {}"</span>, tetris.current_level);
<span>}</span>

<span>fn</span> is_time_over(tetris: &amp;Tetris, timer: &amp;SystemTime) -&gt; <span>bool</span> <span>{</span>
    <span>match</span> timer.elapsed() <span>{</span>
        <span>Ok</span>(elapsed) =&gt; <span>{</span>
            <span>let</span> millis = elapsed.as_secs() <span>as</span> <span>u32</span> * <span>1000</span> + elapsed.subsec_nanos() /  <br class="calibre6"/><span>             1_000_000</span>;
            millis &gt; LEVEL_TIMES<span>[</span>tetris.current_level <span>as</span> <span>usize</span> - <span>1</span><span>]</span>
        <span>}</span>
        <span>Err</span>(_) =&gt; <span>false</span>,
    <span>}</span>
<span>}</span>

<span>fn</span> main() <span>{<br class="calibre6"/>    let sdl_context = sdl2::init().expect("SDL initialization failed");</span>
    <span>let</span> <span>mut</span> tetris = Tetris::new();
    <span>let</span> <span>mut</span> timer = SystemTime::now();

    <span>let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to get SDL event <br class="calibre6"/>     pump"</span>);

    <span>let</span> grid_x = (width - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>10</span>) <span>as</span> <span>i32</span> / <span>2</span>;
    <span>let</span> grid_y = (height - TETRIS_HEIGHT <span>as</span> <span>u32</span> * <span>16</span>) <span>as</span> <span>i32</span> / <span>2</span>;

    <span>loop</span> <span>{</span>
        <span>if</span> is_time_over(&amp;tetris, &amp;timer) <span>{</span>
            <span>let</span> <span>mut</span> make_permanent = <span>false</span>;
            <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
                <span>let</span> x = piece.x;
                <span>let</span> y = piece.y + <span>1</span>;
                make_permanent = !piece.change_position(&amp;tetris.game_map, x, y);
            <span>}</span>
            <span>if</span> make_permanent <span>{</span>
                tetris.make_permanent();
            <span>}</span>
            timer = SystemTime::now();
        <span>}</span>

        <span>// We need to draw the tetris "grid" in here.</span>

        <span>if</span> tetris.current_piece.is_none() <span>{</span>
            <span>let</span> current_piece = tetris.create_new_tetrimino();
            <span>if</span> !current_piece.test_current_position(&amp;tetris.game_map) <span>{</span>
                print_game_information(&amp;tetris);
                <span>break</span>
            <span>}</span>
            tetris.current_piece = <span>Some</span>(current_piece);
        <span>}</span>
        <span>let</span> <span>mut</span> quit = <span>false</span>;
        <span>if</span> !handle_events(&amp;<span>mut</span> tetris, &amp;<span>mut</span> quit, &amp;<span>mut</span> timer, &amp;<span>mut</span> event_pump) <span>{</span>
            <span>if</span> <span>let</span> <span>Some</span>(<span>ref</span> <span>mut</span> piece) = tetris.current_piece <span>{</span>
                <span>// We need to draw our current tetrimino in here.</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> quit <span>{</span>
            print_game_information(&amp;tetris);
            <span>break</span>
        <span>}</span>

        <span>// We need to draw the game map in here.</span>

        sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
    <span>}</span>
<span>}<br class="calibre6"/></span></pre></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Phew! That was quite the chapter! But now, all the game's mechanisms are here so adding the last remaining parts (such as the drawing) will be a piece of cake.</p>
<p class="calibre3">Once again, be sure to understand this chapter before starting to read the next one.</p>


            </article>

            
        </section>
    </body></html>