<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Events and Basic Game Mechanisms</h1>
                
            
            
                
<p class="calibre3">In the last chapter, we saw how to add dependencies into a project thanks to <kbd class="calibre14">Cargo</kbd> and the basics of the <kbd class="calibre14">SDL2</kbd> library.</p>
<p class="calibre3">We now have all the Rust basics in order to write the Tetris game. Time to look at how we will actually write Tetris.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Tetrimino</li>
<li class="calibre11">Creating tetriminos</li>
<li class="calibre11">Generating a tetrimino</li>
<li class="calibre11">Tetris struct</li>
<li class="calibre11">Interacting with the game map</li>
<li class="calibre11">SDL events</li>
<li class="calibre11">Score, level, lines sent</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Writing Tetris</h1>
                
            
            
                
<p class="calibre3">First, let's review the Tetris rules (just in case):</p>
<ul class="calibre10">
<li class="calibre11">There is a grid with a height of 16 blocks and a width of 10 blocks.</li>
<li class="calibre11">You have seven different <kbd class="calibre14">tetrimino</kbd> (a tetris piece) that are all composed of four blocks.</li>
<li class="calibre11">A new <kbd class="calibre14">tetrimino</kbd> appears at the top of the game's grid every time the previous one cannot descend any more (because the block below is already occupied or because you've reached the game's floor).</li>
<li class="calibre11">The game is over when a new <kbd class="calibre14">tetrimino</kbd> cannot appear anymore (because there is already a tetrimino at the top of the grid).</li>
<li class="calibre11">Every time a line is <em class="calibre21">full</em> (all blocks are occupied by a <kbd class="calibre14">tetrimino</kbd> part), it disappears and all lines above descend by one line.</li>
</ul>
<p class="calibre3">Now that we all agree on the game rules, let's see how to actually write those mechanisms.</p>
<p class="calibre3">First, we need to actually create those <kbd class="calibre14">tetrimino</kbd>s.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tetrimino</h1>
                
            
            
                
<p class="calibre3">As said previously, every <kbd class="calibre14">tetrimino</kbd> has four blocks. Another thing to note is that they can rotate. So for example you have this <kbd class="calibre14">tetrimino</kbd>:</p>
<div><img src="img/00012.jpeg" class="calibre42"/></div>
<div><em class="calibre21">Figure 3.1</em></div>
<p class="calibre3">It can also rotate in the three following positions:</p>
<div><img src="img/00013.jpeg" class="calibre43"/></div>
<div><div><em class="calibre21">Figure 3.2</em></div>
</div>
<p class="calibre3">Theoretically, every <kbd class="calibre14">tetrimino</kbd> should have four states, but in reality, not all of them do. For example, this one has no transformation so to speak:</p>
<div><img src="img/00014.jpeg" class="calibre44"/></div>
<div><div><em class="calibre21">Figure 3.3</em></div>
</div>
<p class="calibre3">And these three only have two states:</p>
<div><img src="img/00015.jpeg" class="calibre45"/></div>
<div><div><em class="calibre21">Figure 3.4</em></div>
</div>
<p class="calibre3">We have two ways of handling these rotations: using matrix rotation or storing the different states. To have a code that's easy to read and update, I picked the second option, but don't hesitate to try using matrix on your own, it could help you learn a lot of new things!</p>
<p class="calibre3">So first, let's write down a <kbd class="calibre14">struct</kbd> for <kbd class="calibre14">tetrimino</kbd>s:</p>
<div><pre class="calibre22">struct Tetrimino {
    states: Vec&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;,
    x: isize,
    y: usize,
    current_state: u8,
}</pre></div>
<p class="calibre3">Everything seems fine except this line:</p>
<div><pre class="calibre22">states: Vec&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;,</pre></div>
<p class="calibre3">Pretty ugly, right? Let's make it look a bit better by using type aliasing!</p>
<p class="calibre3">So what is our <kbd class="calibre14">states</kbd> field representing? Simply a list of states. Each state represents a piece's transformation. I suppose it's a bit hard to understand all of this. Let's write an example:</p>
<div><pre class="calibre22">vec![vec![1, 1, 0, 0],
     vec![1, 1, 0, 0],
     vec![0, 0, 0, 0],
     vec![0, 0, 0, 0]]</pre></div>
<p class="calibre3">In here, <kbd class="calibre14">0</kbd> means the block is empty, otherwise, it's a <kbd class="calibre14">tetrimino</kbd> block. So from reading this code, I suppose you could guess that we were representing the square:</p>
<div><img src="img/00014.jpeg" class="calibre44"/></div>
<div><div><em class="calibre21">Figure 3.5</em></div>
</div>
<p class="calibre3">In case you wondered, we have four lines with four blocks because the <em class="calibre21">biggest </em><kbd class="calibre14">tetrimino</kbd> has a height (or a width, depending the transformation) of four:</p>
<div><img src="img/00016.jpeg" class="calibre46"/></div>
<div><div><em class="calibre21">Figure 3.6</em></div>
</div>
<p class="calibre3">This isn't mandatory (we could make it fit the form of each <kbd class="calibre14">tetrimino</kbd>), but it makes our lives easier, so why not?</p>
<p class="calibre3">Coming back to our type aliasing: a piece is basically a vector or vector of numbers. It's long to write it down every time, so let's alias it as follows:</p>
<div><pre class="calibre22">type Piece = Vec&lt;Vec&lt;u8&gt;&gt;;</pre></div>
<p class="calibre3">Now we can rewrite the <kbd class="calibre14">states</kbd> field declaration as follows:</p>
<div><pre class="calibre22">states: Vec&lt;Piece&gt;,</pre></div>
<p class="calibre3">Way better and more explicit, right? But since we'll be using those states as well, why not alias them too?</p>
<div><pre class="calibre22">type States = Vec&lt;Piece&gt;;</pre></div>
<p class="calibre3">And now our <kbd class="calibre14">states</kbd> field declaration becomes:</p>
<div><pre class="calibre22">states: States,</pre></div>
<p class="calibre3">Let's explain the other fields (just in case):</p>
<div><pre class="calibre22">struct Tetrimino {
    states: States,
    x: isize,
    y: usize,
    current_state: u8,
}<br class="calibre6"/></pre></div>
<p class="calibre3">A little explanation of this struct:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">states</kbd> (if you didn't already understand it) is the list of possible states of the <kbd class="calibre14">tetrimino</kbd></li>
<li class="calibre11"><kbd class="calibre14">x</kbd> is the <em class="calibre21">x</em> position of the <kbd class="calibre14">tetrimino</kbd></li>
<li class="calibre11"><kbd class="calibre14">y</kbd> is the <em class="calibre21">y</em> position of the <kbd class="calibre14">tetrimino</kbd></li>
<li class="calibre11"><kbd class="calibre14">current_state</kbd> is the state in which the <kbd class="calibre14">tetrimino</kbd> is currently</li>
</ul>
<p class="calibre3">Ok, so far so good. Now how should we handle the creation of this type generically? We don't want to rewrite this for every <kbd class="calibre14">tetrimino</kbd>. This is where <kbd class="calibre14">traits</kbd> kick in!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating tetriminos</h1>
                
            
            
                
<p class="calibre3">We wrote the type that will be used in our game, but we didn't write its initialization/creation yet. This is where Rust <kbd class="calibre14">trait</kbd>s will be useful.</p>
<p class="calibre3">Let's start by writing a generator trait that will be implemented on all <kbd class="calibre14">tetrimino</kbd>s:</p>
<div><pre class="calibre22">trait TetriminoGenerator {
    fn new() -&gt; Tetrimino;
}</pre></div>
<p class="calibre3">And that's it. This <kbd class="calibre14">trait</kbd> just provides a function that creates a new <kbd class="calibre14">Tetrimino</kbd> instance. It maybe doesn't like this very much, but thanks to this <kbd class="calibre14">trait</kbd>, we'll be able to easily create all our <kbd class="calibre14">tetrimino</kbd>s.</p>
<p class="calibre3">Time to write our first <kbd class="calibre14">tetrimino</kbd>:</p>
<div><pre class="calibre22">struct TetriminoI;</pre></div>
<p class="calibre3">No need to look for more code, this is what a <kbd class="calibre14">tetrimino</kbd> really looks like. It's an empty structure. The interesting part comes just after:</p>
<div><pre class="calibre22">impl TetriminoGenerator for TetriminoI {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![1, 1, 1, 1],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">Which is:</p>
<div><img src="img/00017.jpeg" class="calibre47"/></div>
<div><div><em class="calibre21">Figure 3.7</em></div>
</div>
<p class="calibre3">In here, a number represents a color and <kbd class="calibre14">0</kbd> means no color (because there is no block).</p>
<p class="calibre3">And that's it. Now you can create this <kbd class="calibre14">tetrimino</kbd> just by calling:</p>
<div><pre class="calibre22">let tetrimino = TetriminoI::new();</pre></div>
<p class="calibre3">It'll return an instance of the <kbd class="calibre14">Tetrimino</kbd> structure and that's the one you'll be using in the game. The other <kbd class="calibre14">tetrimino</kbd> structures (such as <kbd class="calibre14">TetriminoI</kbd> in here) are just used to generically create the <kbd class="calibre14">Tetrimino</kbd> structure with the related information.</p>
<p class="calibre3">We now need to create all the other <kbd class="calibre14">tetrimino</kbd> as well, so let's do it:</p>
<div><pre class="calibre22">struct TetriminoJ;

impl TetriminoGenerator for TetriminoJ {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![2, 2, 2, 0],
                              vec![2, 0, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![2, 2, 0, 0],
                              vec![0, 2, 0, 0],
                              vec![0, 2, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 0, 2, 0],
                              vec![2, 2, 2, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![2, 0, 0, 0],
                              vec![2, 0, 0, 0],
                              vec![2, 2, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">In case you're wondering why the blocks have <kbd class="calibre14">2</kbd> as values, it's simply so that we can differentiate them when displaying them (having all <kbd class="calibre14">tetrimino</kbd> with the same color wouldn't be very pretty...). It has no other meaning.</p>
<p class="calibre3">This <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00018.jpeg" class="calibre48"/></div>
<div><div><em class="calibre21">Figure 3.8</em></div>
</div>
<p>Let's go for the next one:</p>
<div><pre class="calibre22">struct TetriminoL;

impl TetriminoGenerator for TetriminoL {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![3, 3, 3, 0],
                              vec![0, 0, 3, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 3, 0, 0],
                              vec![0, 3, 0, 0],
                              vec![3, 3, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![3, 0, 0, 0],
                              vec![3, 3, 3, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![3, 3, 0, 0],
                              vec![3, 0, 0, 0],
                              vec![3, 0, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">This <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00019.jpeg" class="calibre49"/></div>
<div><div><em class="calibre21">Figure 3.9</em></div>
</div>
<p>Another <kbd class="calibre31">tetrimino</kbd>:</p>
<div><pre class="calibre22">struct TetriminoO;

impl TetriminoGenerator for TetriminoO {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![4, 4, 0, 0],
                              vec![4, 4, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 5,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">This <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00020.jpeg" class="calibre50"/>
<div><em class="calibre21">Figure 3.10</em></div>
</div>
<p class="calibre3">Another <kbd class="calibre14">tetrimino</kbd> (will it ever end?!):</p>
<div><pre class="calibre22">struct TetriminoS;

impl TetriminoGenerator for TetriminoS {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![0, 5, 5, 0],
                              vec![5, 5, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 5, 0, 0],
                              vec![0, 5, 5, 0],
                              vec![0, 0, 5, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">This <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00021.jpeg" class="calibre51"/></div>
<div><div><em class="calibre21">Figure 3.11</em></div>
</div>
<p class="calibre3">Guess what? Another <kbd class="calibre14">tetrimino</kbd>:</p>
<div><pre class="calibre22">struct TetriminoZ;

impl TetriminoGenerator for TetriminoZ {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![6, 6, 0, 0],
                              vec![0, 6, 6, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 0, 6, 0],
                              vec![0, 6, 6, 0],
                              vec![0, 6, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">This <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00022.jpeg" class="calibre52"/></div>
<div><div><em class="calibre21">Figure 3.12</em></div>
</div>
<p class="calibre3">And the last one (finally!):</p>
<div><pre class="calibre22">struct TetriminoT;

impl TetriminoGenerator for TetriminoT {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![7, 7, 7, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![7, 7, 0, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![7, 7, 7, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![0, 7, 7, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}</pre></div>
<p class="calibre3">And finally, this <kbd class="calibre14">tetrimino</kbd> looks like this:</p>
<div><img src="img/00023.jpeg" class="calibre53"/></div>
<div><div><em class="calibre21">Figure 3.13</em></div>
</div>
<p class="calibre3">Phew... That was quite a lot of code! Easy code, but still a lot!</p>
<p class="calibre3">It's now time to see how we can generate a new <kbd class="calibre14">tetrimino</kbd> randomly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generating a tetrimino</h1>
                
            
            
                
<p class="calibre3">In order to do so, we'll need to import another <kbd class="calibre14">crate</kbd>—<kbd class="calibre14">rand</kbd>. This <kbd class="calibre14">crate</kbd> is used to generate random numbers and that is exactly what we need here.</p>
<p class="calibre3">First, add the following line to your <kbd class="calibre14">Cargo.toml</kbd> file (in the <kbd class="calibre14">[dependencies]</kbd> section):</p>
<pre class="calibre22">rand = "0.3"</pre>
<p class="calibre3">Next, add the following line to your <kbd class="calibre14">main.rs</kbd> file:</p>
<div><pre class="calibre22">extern crate rand;</pre></div>
<p class="calibre3">And we're done! Now we can write the generation function of the <kbd class="calibre14">tetrimino</kbd>:</p>
<div><pre class="calibre22">fn create_new_tetrimino() -&gt; Tetrimino {
    let rand_nb = rand::random::&lt;u8&gt;() % 7;
    match rand_nb {
        0 =&gt; TetriminoI::new(),
        1 =&gt; TetriminoJ::new(),
        2 =&gt; TetriminoL::new(),
        3 =&gt; TetriminoO::new(),
        4 =&gt; TetriminoS::new(),
        5 =&gt; TetriminoZ::new(),
        6 =&gt; TetriminoT::new(),
        _ =&gt; unreachable!(),
    }
}</pre></div>
<p class="calibre3">Pretty easy, right? Though, please note that this is a bit too random. It'd be problematic if we had the same <kbd class="calibre14">tetrimino</kbd> generated more than twice in a row (which is already a lot!), so let's improve this function a bit by adding a <kbd class="calibre14">static</kbd> variable:</p>
<div><pre class="calibre22">fn create_new_tetrimino() -&gt; Tetrimino {
    static mut PREV: u8 = 7;
    let mut rand_nb = rand::random::&lt;u8&gt;() % 7;
    if unsafe { PREV } == rand_nb {
        rand_nb = rand::random::&lt;u8&gt;() % 7;
    }
    unsafe { PREV = rand_nb; }
    match rand_nb {
        0 =&gt; TetriminoI::new(),
        1 =&gt; TetriminoJ::new(),
        2 =&gt; TetriminoL::new(),
        3 =&gt; TetriminoO::new(),
        4 =&gt; TetriminoS::new(),
        5 =&gt; TetriminoZ::new(),
        6 =&gt; TetriminoT::new(),
        _ =&gt; unreachable!(),
    }
}</pre></div>
<p class="calibre3">A bit of explanation might be helpful here. First, what is a <kbd class="calibre14">static</kbd> variable? It's a variable that will keep its value and won't be destroyed when the scope it has been created inside has been left. An example:</p>
<div><pre class="calibre22">fn foo() -&gt; u32 {
    static mut VALUE: u32 = 12;
    unsafe {
        VALUE += 1;
        VALUE
    }
}

for _ in 0..5 {
    println!("{}", foo());
}</pre></div>
<p class="calibre3">If you execute this code, it'll print out:</p>
<pre class="calibre23"><strong class="calibre5">13
14
15
16
17</strong></pre>
<p class="calibre3">Here are the other properties of the <kbd class="calibre14">static</kbd> variable:</p>
<ul class="calibre10">
<li class="calibre11">It cannot have a destructor (it's possible to avoid this limitation by using the <kbd class="calibre14">lazy_static</kbd> crate though, but we won't talk about it here) so only <em class="calibre21">simple</em> types that don't implement the <kbd class="calibre14">Drop</kbd> trait can be used as <kbd class="calibre14">static</kbd></li>
<li class="calibre11">Changing the value of a <kbd class="calibre14">static</kbd> variable is unsafe (that's why there are <kbd class="calibre14">unsafe</kbd> blocks) for the simple reason that the <kbd class="calibre14">static</kbd> is shared between all threads in the program and can be modified and read at the same time</li>
<li class="calibre11">Reading the value of a mutable <kbd class="calibre14">static</kbd> is unsafe (for the reason mentioned previously)</li>
</ul>
<p class="calibre3">We now have a function that can generate a <kbd class="calibre14">tetrimino</kbd>. We now need to add the following functionalities:</p>
<ul class="calibre10">
<li class="calibre11">Rotating</li>
<li class="calibre11">Changing position</li>
</ul>
<p class="calibre3">Let's start with the rotation part!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rotating a tetrimino</h1>
                
            
            
                
<p class="calibre3">Thanks to how we created the <kbd class="calibre14">Tetrimino</kbd> type, it's quite easy to do:</p>
<div><pre class="calibre22">impl Tetrimino {
    fn rotate(&amp;mut self) {
        self.current_state += 1;
        if self.current_state as usize &gt;= self.states.len() {
            self.current_state = 0;
        }
    }
}</pre></div>
<p class="calibre3">And we're done. However, we don't check anything: what happens if there is a block already used by another <kbd class="calibre14">tetrimino</kbd>? We'll just overwrite it. Such a thing cannot be accepted!</p>
<p class="calibre3">In order to perform this check, we'll need the game <em class="calibre21">map</em> as well. It's simply a vector line and a line is a vector of <kbd class="calibre14">u8</kbd>. Or, more simply:</p>
<div><pre class="calibre22">Vec&lt;Vec&lt;u8&gt;&gt;</pre></div>
<p class="calibre3">Considering that it isn't too hard to read, we'll just keep it this way. Now let's write the method:</p>
<div><pre class="calibre22">fn test_position(&amp;self, game_map: &amp;[Vec&lt;u8&gt;],
                 tmp_state: usize, x: isize, y: usize) -&gt; bool {
    for decal_y in 0..4 {
      for decal_x in 0..4 {
        let x = x + decal_x;
        if self.states[tmp_state][decal_y][decal_x as usize] != 0 <br class="calibre6"/>            &amp;&amp;
                (y + decal_y &gt;= game_map.len() ||
                 x &lt; 0 ||
                 x as usize &gt;= game_map[y + decal_y].len() ||
                 game_map[y + decal_y][x as usize] != 0) {
                return false;
            }
        }
    }
    return true;
}</pre></div>
<p class="calibre3">Before explaining this function, it seems important to explain why the game map became a <kbd class="calibre14">&amp;[Vec&lt;u8&gt;]</kbd>. When you send a non-mutable reference over a vector (<kbd class="calibre14">Vec&lt;T&gt;</kbd>), it is then dereferenced into a <kbd class="calibre14">&amp;[T]</kbd> slice, which is a constant <em class="calibre21">view</em> over the vector's content.</p>
<p class="calibre3">And we're done (for this method)! Now time for explanations: we loop over every block of our <kbd class="calibre14">tetrimino</kbd> and check whether the block is free in the game map (by checking whether it is equal to <kbd class="calibre14">0</kbd>) and if it isn't going out of the game map.</p>
<p class="calibre3">Now that we have our <kbd class="calibre14">test_position</kbd> method, we can update the <kbd class="calibre14">rotate</kbd> method:</p>
<div><pre class="calibre22">fn rotate(&amp;mut self, game_map: &amp;[Vec&lt;u8&gt;]) {
    let mut tmp_state = self.current_state + 1;
    if tmp_state as usize &gt;= self.states.len() {
        tmp_state = 0;
    }
    let x_pos = [0, -1, 1, -2, 2, -3];
    for x in x_pos.iter() {
        if self.test_position(game_map, tmp_state as usize,
                              self.x + x, self.y) == true {
            self.current_state = tmp_state;
            self.x += *x;
            break
        }
    }
}</pre></div>
<p class="calibre3">A bit longer, indeed. Since we can't be sure that the piece will be put where we want it to go, we need to make temporary variables and then check the possibilities. Let's go through the code:</p>
<div><pre class="calibre22">let mut tmp_state = self.current_state + 1;
if tmp_state as usize &gt;= self.states.len() {
    tmp_state = 0;
}</pre></div>
<p class="calibre3">This is <em class="calibre21">exactly</em> what our <kbd class="calibre14">rotate</kbd> method did before, except that now, we use temporary variables before going further:</p>
<div><pre class="calibre22">let x_pos = [0, -1, 1, -2, 2, -3];</pre></div>
<p class="calibre3">This line on its own doesn't make much sense but it'll be very useful next: in case the piece cannot be placed where we want, we try to move it on the <kbd class="calibre14">x</kbd> axis to see if it'd work in some other place. It allows you to have a Tetris that is much more flexible and comfortable to play:</p>
<div><pre class="calibre22">for x in x_pos.iter() {
    if self.test_position(game_map, tmp_state as usize,
                          self.x + x, self.y) == true {
        self.current_state = tmp_state;
        self.x += *x;
        break
    }
}</pre></div>
<p class="calibre3">With the explanations given previously, this loop should be really easy to understand. For each <kbd class="calibre14">x</kbd> shift, we check whether the piece can be placed there. If it works, we change the values of our <kbd class="calibre14">tetrimino</kbd>, otherwise we just continue.</p>
<p class="calibre3">If no <kbd class="calibre14">x</kbd> shift worked, we just leave the function without doing anything.</p>
<p class="calibre3">Now that we can rotate and test the position of a <kbd class="calibre14">tetrimino</kbd>, it'd be nice to actually move it as well (when the timer goes to 0 and the <kbd class="calibre14">tetrimino</kbd> needs to go down, for example). The main difference with the <kbd class="calibre14">rotate</kbd> method will be that, if the <kbd class="calibre14">tetrimino</kbd> cannot move, we'll return a Boolean value to allow the caller to be aware of it.</p>
<p class="calibre3">So the method looks like this:</p>
<div><pre class="calibre22">fn change_position(&amp;mut self, game_map: &amp;[Vec&lt;u8&gt;], new_x: isize, new_y: usize) -&gt; bool {
    if self.test_position(game_map, self.current_state as usize,  <br class="calibre6"/>    new_x, new_y) == true {
        self.x = new_x as isize;
        self.y = new_y;
        true
    } else {
        false
    }
}</pre></div>
<p class="calibre3">Another difference that you have certainly already spotted is that we don't check multiple possible positions, just the one received. The reason is simple; contrary to a rotation, we can't move the <kbd class="calibre14">tetrimino</kbd> around when it receives a move instruction. Imagine asking the <kbd class="calibre14">tetrimino</kbd> to move to the right and it doesn't move, or worse, it moves to the left! We can't allow it and so we're not doing it.</p>
<p class="calibre3">Now about the method's code: it's very simple. If we can put the <kbd class="calibre14">tetrimino</kbd> in a place, we update the position of the <kbd class="calibre14">tetrimino</kbd> and return true, otherwise, we do nothing other than return false.</p>
<p class="calibre3">Most of the work is performed in the <kbd class="calibre14">test_position</kbd> method, allowing our method to be really small.</p>
<p class="calibre3">With these three methods, we have almost everything we need. But for even more simplicity in the future, let's add one more:</p>
<div><pre class="calibre22">fn test_current_position(&amp;self, game_map: &amp;[Vec&lt;u8&gt;]) -&gt; bool {
    self.test_position(game_map, self.current_state as usize,  <br class="calibre6"/>    self.x, self.y)
}</pre></div>
<p class="calibre3">We'll use it when we generate a new <kbd class="calibre14">tetrimino</kbd>: if it cannot be placed where it appeared because another <kbd class="calibre14">tetrimino</kbd> is already there, it means the game is over.</p>
<p class="calibre3">We can now say that our <kbd class="calibre14">Tetrimino</kbd> type is fully implemented. Congratulations! Time to start the game type!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tetris struct</h1>
                
            
            
                
<p class="calibre3">This type will be the one holding all the game's information:</p>
<ul class="calibre10">
<li class="calibre11">Game map</li>
<li class="calibre11">Current level</li>
<li class="calibre11">Score</li>
<li class="calibre11">Number of lines</li>
<li class="calibre11">The current <kbd class="calibre14">tetrimino</kbd></li>
<li class="calibre11">Some potential other information (such as a ghost, or the preview of the next <kbd class="calibre14">tetrimino</kbd>!)</li>
</ul>
<p class="calibre3">Let's write down this type:</p>
<div><pre class="calibre22">struct Tetris {
    game_map: Vec&lt;Vec&lt;u8&gt;&gt;,
    current_level: u32,
    score: u32,
    nb_lines: u32,
    current_piece: Option&lt;Tetrimino&gt;,
}</pre></div>
<p class="calibre3">Once again, pretty simple. I don't think any additional information is required so let's continue!</p>
<p class="calibre3">Let's start by writing the <kbd class="calibre14">new</kbd> method for this new type:</p>
<div><pre class="calibre22">impl Tetris {
    fn new() -&gt; Tetris {
        let mut game_map = Vec::new();
        for _ in 0..16 {
            game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        Tetris {
            game_map: game_map,
            current_level: 1,
            score: 0,
            nb_lines: 0,
            current_piece: None,
        }
    }
}</pre></div>
<p class="calibre3">Nothing really complicated except maybe the loop. Let's look at how it works:</p>
<div><pre class="calibre22">let mut game_map = Vec::new();
for _ in 0..16 {
    game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
}</pre></div>
<p class="calibre3">We know that a <kbd class="calibre14">tetris</kbd> map has a width of 10 blocks and a height of 16 blocks. This loop creates our game map by looping over the number of lines and generating an empty vector of 10 blocks, which will be a line.</p>
<p class="calibre3">Apart from this, everything else is very straightforward:</p>
<ul class="calibre10">
<li class="calibre11">You start at level 1</li>
<li class="calibre11">With your score at 0</li>
<li class="calibre11">With 0 lines sent</li>
<li class="calibre11">No current <kbd class="calibre14">tetrimino</kbd></li>
</ul>
<p class="calibre3">Let's start by generating a new <kbd class="calibre14">tetrimino</kbd> randomly. For this, you'll require the <kbd class="calibre14">rand</kbd> crate. Add the following to your <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">rand = "0.3"</pre>
<p class="calibre3">Then add this at the top of your <kbd class="calibre14">main</kbd> file:</p>
<div><pre class="calibre22">extern crate rand;</pre></div>
<p class="calibre3">Then we can write the method:</p>
<div><pre class="calibre22">fn create_new_tetrimino(&amp;self) -&gt; Tetrimino {
    static mut PREV: u8 = 7;
    let mut rand_nb = rand::random::&lt;u8&gt;() % 7;
    if unsafe { PREV } == rand_nb {
        rand_nb = rand::random::&lt;u8&gt;() % 7;
    }
    unsafe { PREV = rand_nb; }
    match rand_nb {
        0 =&gt; TetriminoI::new(),
        1 =&gt; TetriminoJ::new(),
        2 =&gt; TetriminoL::new(),
        3 =&gt; TetriminoO::new(),
        4 =&gt; TetriminoS::new(),
        5 =&gt; TetriminoZ::new(),
        6 =&gt; TetriminoT::new(),
        _ =&gt; unreachable!(),
    }
}</pre></div>
<p class="calibre3">Explanations:</p>
<div><pre class="calibre22">static mut PREV: u8 = 7;</pre></div>
<p class="calibre3">The <kbd class="calibre14">static</kbd> keyword is the same in <kbd class="calibre14">Rust</kbd> as it is in <kbd class="calibre14">C</kbd> and <kbd class="calibre14">C++</kbd> for variables: the value set to the variable will be kept between the function calls. So for example, if you write the following function:</p>
<div><pre class="calibre22">fn incr() -&gt; u32 {
    static mut NB: u32 = 0;
    unsafe {
        NB += 1;
        NB
    }
}</pre></div>
<p class="calibre3">And you then call it, as follows:</p>
<div><pre class="calibre22">for _ in 0..5 {
    println!("{}", incr());
}</pre></div>
<p class="calibre3">You'll get the following output:</p>
<pre class="calibre23"><strong class="calibre5">1
2
3
4
5</strong></pre>
<p class="calibre3">So now, why do we have these <kbd class="calibre14">unsafe</kbd> blocks? The reason is quite simple: in case the static variable is accessed and modified from different threads, you can't be <em class="calibre21">sure</em> that you won't have data race, concurrency errors, or even memory errors.</p>
<p>In this case, since we don't have threads, it's fine. However, keep in mind that you should ALWAYS try to avoid unsafe at all costs and use it ONLY when nothing else can be done.</p>
<p class="calibre3">However, if our static variable wasn't mutable, then we could access its value without needing the <kbd class="calibre14">unsafe</kbd> blocks. The reason once again is simple: even if multiple threads try to access its value at the same time, since this value cannot change, you can't have data race and therefore it is safe.</p>
<p class="calibre3">Let's continue with our function's code explanations:</p>
<div><pre class="calibre22">let mut rand_nb = rand::random::&lt;u8&gt;() % 7;</pre></div>
<p class="calibre3">This line generates a random <kbd class="calibre14">u8</kbd> and then limits its value between 0 (included) and 6 (included) because we have seven different <kbd class="calibre14">tetrimino</kbd>:</p>
<div><pre class="calibre22">if unsafe { PREV } == rand_nb {
    rand_nb = rand::random::&lt;u8&gt;() % 7;
}</pre></div>
<p class="calibre3">If the generated <kbd class="calibre14">tetrimino</kbd> is the same as the previous one, we generate another one. It enables you to prevent having the same <kbd class="calibre14">tetrimino</kbd> too many times at once. It isn't the best way to do it, having a specific balancing for each <kbd class="calibre14">tetrimino</kbd> would be better, but this solution is acceptable enough (and a lot easier to write!):</p>
<div><pre class="calibre22">unsafe { PREV = rand_nb; }</pre></div>
<p class="calibre3">We now set the generated <kbd class="calibre14">tetrimino</kbd> <em class="calibre21">ID</em> to our <kbd class="calibre14">static</kbd> variable:</p>
<div><pre class="calibre22">match rand_nb {
    0 =&gt; TetriminoI::new(),
    1 =&gt; TetriminoJ::new(),
    2 =&gt; TetriminoL::new(),
    3 =&gt; TetriminoO::new(),
    4 =&gt; TetriminoS::new(),
    5 =&gt; TetriminoZ::new(),
    6 =&gt; TetriminoT::new(),
    _ =&gt; unreachable!(),
}</pre></div>
<p class="calibre3">Nothing much to say about this pattern matching. Every <em class="calibre21">ID</em> matches a <kbd class="calibre14">tetrimino</kbd> and then we call the corresponding constructor. The only really interesting thing about this construction is the following line:</p>
<div><pre class="calibre22">_ =&gt; unreachable!(),</pre></div>
<p class="calibre3">This macro is really useful. It allows us to add a security over the matched value. If the code ever enters this pattern matching, it'll panic right away (because, as the macro's name suggests, it's not supposed to happen).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Interacting with the game map</h1>
                
            
            
                
<p class="calibre3">Ok, we can now move all the <kbd class="calibre14">tetrimino</kbd> and generate them. Two mechanisms are still missing: checking lines to see whether one can be sent (that is, removed since complete) and making a <kbd class="calibre14">tetrimino</kbd> <em class="calibre21">permanent </em>(that is, not movable anymore).</p>
<p class="calibre3">Let's start with the line check:</p>
<div><pre class="calibre22">fn check_lines(&amp;mut self) {
    let mut y = 0;

    while y &lt; self.game_map.len() {
        let mut complete = true;

        for x in &amp;self.game_map[y] {
            if *x == 0 {
                complete = false;
                break
            }
        }
        if complete == true {
            self.game_map.remove(y);
            y -= 1;
            // increase the number of self.lines
        }
        y += 1;
    }
    while self.game_map.len() &lt; 16 {
        self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
}</pre></div>
<p class="calibre3">For now, I didn't add the score, lines sent counting, nor level handling but this is here that'll do it later.</p>
<p class="calibre3">Now time to explain this method a bit. Its purpose is to remove lines when they're full (meaning when every block is occupied by a <kbd class="calibre14">tetrimino</kbd> block). So we just go through the game map line by line and run the check on each.</p>
<p class="calibre3">The code itself doesn't use much of the Rust-specific syntax, but you might wonder why we did it like this. I'm talking about this loop:</p>
<div><pre class="calibre22">while y &lt; self.game_map.len() {</pre></div>
<p class="calibre3">When we could have just used:</p>
<div><pre class="calibre22">for line in self.game_map {</pre></div>
<p class="calibre3">This is actually a good question and the answer is simple, but maybe hard to understand, if you're used to how Rust ownership works.</p>
<p class="calibre3">All the problems actually come from this line:</p>
<div><pre class="calibre22">self.game_map.remove(y);</pre></div>
<p class="calibre3">In here, we mutably borrow <kbd class="calibre14">self.game_map</kbd> in order to remove a line. However, <kbd class="calibre14">self.game_map</kbd> would already be non-mutably borrowed by the <kbd class="calibre14">for</kbd> loop! A quick reminder on how the borrowing rules work:</p>
<ul class="calibre10">
<li class="calibre11">You can non-mutably borrow a variable as many times as you want</li>
<li class="calibre11">You can mutably borrow a variable only if there are no other borrows (either mutable or non-mutable)</li>
</ul>
<p class="calibre3">So in our case, the <kbd class="calibre14">for</kbd> loop would break the second rule since we'd have a non-mutable borrow when trying to get mutable access to <kbd class="calibre14">self.game_map</kbd>.</p>
<p class="calibre3">In this case, we have two solutions:</p>
<ul class="calibre10">
<li class="calibre11">Iterate over the game map "by hand" (with an index variable)</li>
<li class="calibre11">Store lines to remove into a second vector and then remove them after we get out of the loop</li>
</ul>
<p class="calibre3">Both solutions are more or less equivalent in this case so I just picked the first one.</p>
<p class="calibre3">Once the first loop is finished, we have filled the game map with empty lines to replace the one(s) we deleted:</p>
<div><pre class="calibre22">while self.game_map.len() &lt; 16 {
    self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
}</pre></div>
<p class="calibre3">And we're done with this method! Let's write the other one.</p>
<p class="calibre3">So now it's time to write the <kbd class="calibre14">make_permanent</kbd> method. Just like the previous one, it won't be a complete version, but in the future, this is where we'll update the score (we update it when a <kbd class="calibre14">tetrimino</kbd> is made permanent).</p>
<p class="calibre3">So let's write it:</p>
<div><pre class="calibre22">fn make_permanent(&amp;mut self) {
    if let Some(ref mut piece) = self.current_piece {
        let mut shift_y = 0;

        while shift_y &lt; piece.states[piece.current_state as  <br class="calibre6"/>         usize].len() &amp;&amp;
              piece.y + shift_y &lt; self.game_map.len() {
            let mut shift_x = 0;

            while shift_x &lt; piece.states[piece.current_state as  <br class="calibre6"/>             usize][shift_y].len() &amp;&amp;
                  (piece.x + shift_x as isize) &lt; <br class="calibre6"/>                   self.game_map[piece.y +  <br class="calibre6"/>                   shift_y].len() as isize {
                if piece.states[piece.current_state as usize] <br class="calibre6"/>                [shift_y][shift_x] != 0 {
                    let x = piece.x + shift_x as isize;
                    self.game_map[piece.y + shift_y][x as usize] =
                        piece.states[piece.current_state as usize] <br class="calibre6"/>                         [shift_y][shift_x];
                }
                shift_x += 1;
            }
            shift_y += 1;
        }
    }
    self.check_lines();
    self.current_piece = None;
}</pre></div>
<p class="calibre3">This code doesn't seem very encouraging... Brace yourselves, explanations are coming:</p>
<div><pre class="calibre22">if let Some(ref mut piece) = self.current_piece {</pre></div>
<p class="calibre3">It's simple pattern matching. If <kbd class="calibre14">self.current_piece</kbd> is <kbd class="calibre14">Some</kbd>, then we enter the condition and the value contained by <kbd class="calibre14">Some</kbd> that is bound into the <kbd class="calibre14">piece</kbd> variable:</p>
<div><pre class="calibre22">while shift_y &lt; piece.states[piece.current_state as usize].len() &amp;&amp;
      piece.y + shift_y &lt; self.game_map.len() {</pre></div>
<p class="calibre3">This loop and its condition allow us to avoid a buffer overflow error by checking whether we're not outside of the game map limit for the current rotation (that is, <kbd class="calibre14">self.current_state</kbd>).</p>
<p class="calibre3">The same goes for the inner loop (which iterates over the blocks of a line):</p>
<div><pre class="calibre22">while shift_x &lt; piece.states[piece.current_state as usize][shift_y].len() &amp;&amp;
      (piece.x + shift_x as isize) &lt; self.game_map[piece.y + shift_y].len() as isize {</pre></div>
<p class="calibre3">It is in this loop that we write the blocks of the current <kbd class="calibre14">tetrimino</kbd> into the game map:</p>
<div><pre class="calibre22">if piece.states[piece.current_state as usize][shift_y][shift_x] != 0 {
    let x = piece.x + shift_x as isize;
    self.game_map[piece.y + shift_y][x as usize] =
        piece.states[piece.current_state as usize][shift_y][shift_x];
}</pre></div>
<p class="calibre3">If the current block of the current <kbd class="calibre14">tetrimino</kbd> isn't empty, then we put it into the game map (it's as simple as that).</p>
<p class="calibre3">Once done, this is where we call the <kbd class="calibre14">check_lines</kbd> method. But now you'll certainly wonder why we don't call it directly inside the <kbd class="calibre14">if let</kbd> condition. Well, it's for the exact same reason that we didn't use the <kbd class="calibre14">for</kbd> loop inside the <kbd class="calibre14">check_lines</kbd> method, <kbd class="calibre14">self</kbd> is already mutably borrowed by the following line:</p>
<div><pre class="calibre22">if let Some(ref mut piece) = self.current_piece {</pre></div>
<p class="calibre3">That's right: if an element of a type is borrowed, then its parent is mutably borrowed as well!</p>
<p class="calibre3">With these two methods, our <kbd class="calibre14">Tetris</kbd> type is now fully implemented (minus the small required modifications that will come later). Time to add the <kbd class="calibre14">SDL</kbd> events handling!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">SDL events</h1>
                
            
            
                
<p class="calibre3">There aren't many different events to handle:</p>
<ul class="calibre10">
<li class="calibre11"><em class="calibre21">Left</em> and <em class="calibre21">right arrow</em> keys to move the <kbd class="calibre14">tetrimino</kbd> to the right or the left</li>
<li class="calibre11"><em class="calibre21">Up arrow</em> key to make the <kbd class="calibre14">tetrimino</kbd> rotate</li>
<li class="calibre11"><em class="calibre21">Down arrow</em> key to make the <kbd class="calibre14">tetrimino</kbd> descend one block</li>
<li class="calibre11"><em class="calibre21">Spacebar</em> to make the <kbd class="calibre14">tetrimino</kbd> descend to the bottom instantly</li>
<li class="calibre11"><em class="calibre21">Escape</em> to quit the game</li>
</ul>
<p class="calibre3">It's still possible to add some later on (such as pausing the game with the <em class="calibre21">return</em> key, for example) but for now, let's focus on these ones. For this, go back inside the main loop of the game (inside the <kbd class="calibre14">main</kbd> function) and replace the current event handling with the following function:</p>
<div><pre class="calibre22">fn handle_events(tetris: &amp;mut Tetris, quit: &amp;mut bool, timer: &amp;mut SystemTime,
                 event_pump: &amp;mut sdl2::EventPump) -&gt; bool {
    let mut make_permanent = false;
    if let Some(ref mut piece) = tetris.current_piece {
        let mut tmp_x = piece.x;
        let mut tmp_y = piece.y;

        for event in event_pump.poll_iter() {
          match event {
          Event::Quit { .. } |
          Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; <br class="calibre6"/>                {
                    *quit = true;
                    break
                }
           Event::KeyDown { keycode: Some(Keycode::Down), .. } =&gt;<br class="calibre6"/>                {
                    *timer = SystemTime::now();
                    tmp_y += 1;
                }
           Event::KeyDown { keycode: Some(Keycode::Right), .. } =&gt; <br class="calibre6"/>                {
                    tmp_x += 1;
                }
            Event::KeyDown { keycode: Some(Keycode::Left), .. } =&gt; <br class="calibre6"/>                {
                    tmp_x -= 1;
                }
            Event::KeyDown { keycode: Some(Keycode::Up), .. } =&gt; <br class="calibre6"/>                {
                    piece.rotate(&amp;tetris.game_map);
                }
           Event::KeyDown { keycode: Some(Keycode::Space), .. } =&gt; <br class="calibre6"/>               {
                  let x = piece.x;
                  let mut y = piece.y;
           while piece.change_position(&amp;tetris.game_map, x, y + 1) <br class="calibre6"/>           == true {
                        y += 1;
                   }
                    make_permanent = true;
                }
                _ =&gt; {}
            }
        }
        if !make_permanent {
         if piece.change_position(&amp;tetris.game_map, tmp_x, tmp_y)<br class="calibre6"/>           == <br class="calibre6"/>            false &amp;&amp;
               tmp_y != piece.y {
                make_permanent = true;
            }
        }
    }
    if make_permanent {
        tetris.make_permanent();
        *timer = SystemTime::now();
    }
    make_permanent
}</pre></div>
<p class="calibre3">Quite a big one:</p>
<div><pre class="calibre22">let mut make_permanent = false;</pre></div>
<p class="calibre3">This variable will tell us whether the current <kbd class="calibre14">tetrimino</kbd> is still falling. If not, then it becomes <kbd class="calibre14">true</kbd>, the <kbd class="calibre14">tetrimino</kbd> is then put into the game map and we generate a new one. Luckily for us, we already wrote all the needed functions to perform these operations:</p>
<div><pre class="calibre22">if let Some(ref mut piece) = tetris.current_piece {</pre></div>
<p class="calibre3">This is simple pattern binding. If our game doesn't have a current piece (for some reason), then we don't do anything and just leave:</p>
<div><pre class="calibre22">let mut tmp_x = piece.x;
let mut tmp_y = piece.y;</pre></div>
<p class="calibre3">If there is a move on the <kbd class="calibre14">x</kbd> or on the <kbd class="calibre14">y</kbd> axis, we'll write it into these variables and then we'll test whether the <kbd class="calibre14">tetrimino</kbd> can actually go there:</p>
<div><pre class="calibre22">for event in event_pump.poll_iter() {</pre></div>
<p class="calibre3">As there can be multiple events that happened since the last time we came into this function, we need to loop over all of them.</p>
<p class="calibre3">Now we're arriving at the interesting part:</p>
<div><pre class="calibre22">match event {
    Event::Quit { .. } |
    Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
        *quit = true;
        break
    }
    Event::KeyDown { keycode: Some(Keycode::Down), .. } =&gt; {
        *timer = SystemTime::now();
        tmp_y += 1;
    }
    Event::KeyDown { keycode: Some(Keycode::Right), .. } =&gt; {
        tmp_x += 1;
    }
    Event::KeyDown { keycode: Some(Keycode::Left), .. } =&gt; {
        tmp_x -= 1;
    }
    Event::KeyDown { keycode: Some(Keycode::Up), .. } =&gt; {
        piece.rotate(&amp;tetris.game_map);
    }
    Event::KeyDown { keycode: Some(Keycode::Space), .. } =&gt; {
      let x = piece.x;
      let mut y = piece.y;
      while piece.change_position(&amp;tetris.game_map, x, y + 1) ==  <br class="calibre6"/>      true {
            y += 1;
        }
        make_permanent = true;
    }
    _ =&gt; {}
}</pre></div>
<p class="calibre3">We can almost consider this small code as the core of our application, without it, no interaction with the program is possible. If you want more interactions, this is where you'll add them:</p>
<div><pre class="calibre22">Event::Quit { .. } |
Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
    *quit = true;
    break
}</pre></div>
<p class="calibre3">If we receive a <em class="calibre21">quit</em> event from <kbd class="calibre14">sdl</kbd> or if we receive an <kbd class="calibre14">Escape</kbd>, <kbd class="calibre14">KeyDown</kbd> event, we set the <kbd class="calibre14">quit</kbd> variable to <kbd class="calibre14">true</kbd>. It'll be used outside of this function to then leave the main loop--and therefore leave the program itself. Then we <em class="calibre21">break;</em> no need to go further since we know that we're leaving the game:</p>
<div><pre class="calibre22">Event::KeyDown { keycode: Some(Keycode::Down), .. } =&gt; {
    *timer = SystemTime::now();
    tmp_y += 1;
}</pre></div>
<p class="calibre3">If the <em class="calibre21">down arrow</em> is pressed, we need to make our <kbd class="calibre14">tetrimino</kbd> descend by one block and also put the <kbd class="calibre14">timer</kbd> value to now. <kbd class="calibre14">timer</kbd> is used to know at what speed the <kbd class="calibre14">tetrimino</kbd> blocks are falling. The shorter the time, the faster they'll descend.</p>
<p class="calibre3">For now, it isn't used in this function, so we'll see how to handle it outside of it:</p>
<div><pre class="calibre22">Event::KeyDown { keycode: Some(Keycode::Right), .. } =&gt; {
    tmp_x += 1;
}
Event::KeyDown { keycode: Some(Keycode::Left), .. } =&gt; {
    tmp_x -= 1;
}</pre></div>
<p class="calibre3">In here, we handle the <em class="calibre21">right</em> and <em class="calibre21">left arrow</em> keys. It's just like the <em class="calibre21">down arrow</em> key, except we don't need to change the <kbd class="calibre14">timer</kbd> variable:</p>
<div><pre class="calibre22">Event::KeyDown { keycode: Some(Keycode::Up), .. } =&gt; {
    piece.rotate(&amp;tetris.game_map);
}</pre></div>
<p class="calibre3">If we receive an <em class="calibre21">up arrow</em> key pressed event, we rotate the <kbd class="calibre14">tetrimino</kbd>:</p>
<div><pre class="calibre22">Event::KeyDown { keycode: Some(Keycode::Space), .. } =&gt; {
   let x = piece.x;
   let mut y = piece.y;
  while piece.change_position(&amp;tetris.game_map, x, y + 1) == true {
        y += 1;
    }
    make_permanent = true;
}</pre></div>
<p class="calibre3">And finally the last of our events: the <em class="calibre21">spacebar</em> key pressed event. Here, we move the <kbd class="calibre14">tetrimino</kbd> down as much as we can and then set the <kbd class="calibre14">make_permanent</kbd> variable to <kbd class="calibre14">true</kbd>.</p>
<p class="calibre3">With this, that's it for our events. However, like we said before if you want to add more events, this is where you should put them.</p>
<p class="calibre3">Time to put all this into our main loop:</p>
<div><pre class="calibre22">fn print_game_information(tetris: &amp;Tetris) {
    println!("Game over...");
    println!("Score:           {}", tetris.score);
    // println!("Number of lines: {}", tetris.nb_lines);
    println!("Current level:   {}", tetris.current_level);
    // Check highscores here and update if needed
}

let mut tetris = Tetris::new();
let mut timer = SystemTime::now();

loop {
    if match timer.elapsed() {
        Ok(elapsed) =&gt; elapsed.as_secs() &gt;= 1,
        Err(_) =&gt; false,
    } {
        let mut make_permanent = false;
        if let Some(ref mut piece) = tetris.current_piece {
            let x = piece.x;
            let y = piece.y + 1;
            make_permanent =  <br class="calibre6"/>             !piece.change_position(&amp;tetris.game_map,  <br class="calibre6"/>             x, y);
        }
        if make_permanent {
            tetris.make_permanent();
        }
        timer = SystemTime::now();
    }

    // We need to draw the tetris "grid" in here.

    if tetris.current_piece.is_none() {
        let current_piece = tetris.create_new_tetrimino();
        if !current_piece.test_current_position(&amp;tetris.game_map) {
            print_game_information(&amp;tetris);
            break
        }
        tetris.current_piece = Some(current_piece);
    }
    let mut quit = false;
    if !handle_events(&amp;mut tetris, &amp;mut quit, &amp;mut timer, &amp;mut <br class="calibre6"/>     event_pump) {
        if let Some(ref mut piece) = tetris.current_piece {
            // We need to draw our current tetrimino in here.
        }
    }
    if quit {
        print_game_information(&amp;tetris);
        break
    }

    // We need to draw the game map in here.

    sleep(Duration::new(0, 1_000_000_000u32 / 60));
}</pre></div>
<p class="calibre3">Doesn't seem that long, right? Just a few comments where we're supposed to draw our <kbd class="calibre14">Tetris</kbd>, but otherwise everything is in there, which means that our <kbd class="calibre14">Tetris</kbd> is now fully functional (even though it isn't displayed).</p>
<p class="calibre3">Let's explain what's happening in there:</p>
<div><pre class="calibre22">let mut tetris = Tetris::new();
let mut timer = SystemTime::now();</pre></div>
<p class="calibre3">In here, we initialize both our <kbd class="calibre14">Tetris</kbd> object and the <kbd class="calibre14">timer</kbd>. The timer will be used to let us know when the <kbd class="calibre14">tetrimino</kbd> is supposed to descend by one block:</p>
<div><pre class="calibre22">if match timer.elapsed() {
    Ok(elapsed) =&gt; elapsed.as_secs() &gt;= 1,
    Err(_) =&gt; false,
} {
    let mut make_permanent = false;
    if let Some(ref mut piece) = tetris.current_piece {
        let x = piece.x;
        let y = piece.y + 1;
        make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>         x, y);
    }
    if make_permanent {
        tetris.make_permanent();
    }
    timer = SystemTime::now();
}</pre></div>
<p class="calibre3">This code checks whether it's been one second or more since the last time the <kbd class="calibre14">tetrimino</kbd> descended by one block. If we want to handle levels, we'll need to replace the following line:</p>
<div><pre class="calibre22">Ok(elapsed) =&gt; elapsed.as_secs() &gt;= 1,</pre></div>
<p class="calibre3">Its replacement will need to be something more generic and we'll add an array to store the different levels' speed of descent.</p>
<p class="calibre3">So coming back to the code, if it's been one second or more then we try to make the <kbd class="calibre14">tetrimino</kbd> descend by one block. If it cannot, then we put it into the game map and re-initialize the <kbd class="calibre14">timer</kbd> variable.</p>
<p class="calibre3">Once again, you might wonder why we had to create the <kbd class="calibre14">make_permanent</kbd> variable instead of directly checking the output of:</p>
<div><pre class="calibre22">!piece.change_position(&amp;tetris.game_map, x, y)</pre></div>
<p class="calibre3">It has an <kbd class="calibre14">if</kbd> condition, right? Well, just like the previous times, it's because of the borrow checker. We borrow <kbd class="calibre14">tetris</kbd> here:</p>
<div><pre class="calibre22">if let Some(ref mut piece) = tetris.current_piece {</pre></div>
<p class="calibre3">So as long as we're in this condition, we can't use <kbd class="calibre14">tetris</kbd> mutably, which is why we store the result of the condition in <kbd class="calibre14">make_permanent</kbd> so we can use the <kbd class="calibre14">make_permanent</kbd> method after:</p>
<div><pre class="calibre22">if tetris.current_piece.is_none() {
    let current_piece = tetris.create_new_tetrimino();
    if !current_piece.test_current_position(&amp;tetris.game_map) {
        print_game_information(&amp;tetris);
        return
    }
    tetris.current_piece = Some(current_piece);
}</pre></div>
<p class="calibre3">If there is no current <kbd class="calibre14">tetrimino</kbd>, we need to generate a new one, which we do by calling the <kbd class="calibre14">create_new_tetrimino</kbd> method. Then we check whether it can be put into the game on the top line by calling the <kbd class="calibre14">test_current_position</kbd> method. If not, then it means the game is over and we quit. Otherwise, we store the newly-generated <kbd class="calibre14">tetrimino</kbd> in <kbd class="calibre14">tetris.current_piece</kbd> and we move on.</p>
<p class="calibre3">Two things are missing here:</p>
<ul class="calibre10">
<li class="calibre11">Since we don't handle the increase of lines sent, nor the score, nor the level, there's no need to print them</li>
<li class="calibre11">We didn't add yet the highscores loading/overwrite</li>
</ul>
<p class="calibre3">Of course, we'll add all this later on:</p>
<div><pre class="calibre22">let mut quit = false;
if !handle_events(&amp;mut tetris, &amp;mut quit, &amp;mut timer, &amp;mut event_pump) {
    if let Some(ref mut piece) = tetris.current_piece {
        // We need to draw our current tetrimino in here.
    }
}
if quit {
    print_game_information(&amp;tetris);
    break
}</pre></div>
<p class="calibre3">This code calls the <kbd class="calibre14">handle_events</kbd> function and acts according to its output. It returns whether the current <kbd class="calibre14">tetrimino</kbd> has been put into the game map or not. If it is the case, then there is no need to draw it.</p>
<p class="calibre3">We now need to do the following remaining things:</p>
<ul class="calibre10">
<li class="calibre11">Add the score, levels, and number of lines sent</li>
<li class="calibre11">Load/overwrite the highscores if needed</li>
<li class="calibre11">Actually draw the <kbd class="calibre14">Tetris</kbd></li>
</ul>
<p class="calibre3">Seems like we're getting very close to the end! Let's start by adding the score, number of lines sent, and levels!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Score, level, lines sent</h1>
                
            
            
                
<p class="calibre3">The biggest required change will be the level handling. You need to create an array with different times to increase the <kbd class="calibre14">tetrimino</kbd>'s speed of descent and to check whether the level needs to be changed or not (based on the number of lines).</p>
<p class="calibre3">The score will be updated in the following cases:</p>
<ul class="calibre10">
<li class="calibre11">When the <kbd class="calibre14">tetrimino</kbd> is made permanent</li>
<li class="calibre11">When a line is sent</li>
<li class="calibre11">When the player makes a <kbd class="calibre14">Tetris</kbd> (no more blocks in the game map)</li>
</ul>
<p class="calibre3">Let's start with the easiest change—the score.</p>
<p class="calibre3">First, let's add the following method into our <kbd class="calibre14">Tetris</kbd> type:</p>
<div><pre class="calibre22">fn update_score(&amp;mut self, to_add: u32) {
    self.score += to_add;
}</pre></div>
<p class="calibre3">We can suppose that no additional explanations are required here.</p>
<p class="calibre3">Next, let's update a few methods:</p>
<div><pre class="calibre22">fn check_lines(&amp;mut self) {
    let mut y = 0;
    let mut score_add = 0;

    while y &lt; self.game_map.len() {
        let mut complete = true;

        for x in &amp;self.game_map[y] {
            if *x == 0 {
                complete = false;
                break
            }
        }
        if complete == true {
            score_add += self.current_level;
            self.game_map.remove(y);
            y -= 1;
        }
        y += 1;
    }
    if self.game_map.len() == 0 {
        // A "tetris"!
        score_add += 1000;
    }
    self.update_score(score_add);
    while self.game_map.len() &lt; 16 {
        // we'll add this method just after!
        self.increase_line();
        self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0,<br class="calibre6"/>         0]);
    }
}</pre></div>
<p class="calibre3">As usual, we create a temporary variable (here, <kbd class="calibre14">score_add</kbd>) and once the borrow of <kbd class="calibre14">self</kbd> is over, we call the <kbd class="calibre14">update_score</kbd> method. There is also the usage of the <kbd class="calibre14">increase_line</kbd> method. We haven't defined it yet; it'll come just after.</p>
<p class="calibre3">The second method is <kbd class="calibre14">make_permanent</kbd>:</p>
<div><pre class="calibre23">fn make_permanent(&amp;mut self) {
    let mut to_add = 0;
    if let Some(ref mut piece) = self.current_piece {
        let mut shift_y = 0;

        while shift_y &lt; piece.states[piece.current_state as <br class="calibre6"/>         usize].len() &amp;&amp;
              piece.y + shift_y &lt; self.game_map.len() {
            let mut shift_x = 0;

            while shift_x &lt; piece.states[piece.current_state as usize] <br class="calibre6"/>             [shift_y].len() &amp;&amp;
                  (piece.x + shift_x as isize) &lt; self.game_map[piece.y  <br class="calibre6"/>                   + shift_y].len() as isize {
                if piece.states[piece.current_state as usize][shift_y] <br class="calibre6"/>                 [shift_x] != 0 {
                    let x = piece.x + shift_x as isize;
                    self.game_map[piece.y + shift_y][x as usize] =
                        piece.states[piece.current_state as usize]    <br class="calibre6"/>                         [shift_y][shift_x];
                }
                shift_x += 1;
            }
            shift_y += 1;
        }
        to_add += self.current_level;
    }
    self.update_score(to_add);
    self.check_lines();
    self.current_piece = None;
}</pre></div>
<p class="calibre3">Include this just above the <kbd class="calibre14">self.check_lines</kbd> call.</p>
<p class="calibre3">With these two methods updated, we now have the score handling fully implemented.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Levels and lines sent</h1>
                
            
            
                
<p class="calibre3">The next two being strongly bound (the level depends directly on the number of lines sent), we'll implement them at the same time.</p>
<p class="calibre3">Before doing anything else, let's define the two following <kbd class="calibre14">const</kbd>:</p>
<div><pre class="calibre22">const LEVEL_TIMES: [u32; 10] = [1000, 850, 700, 600, 500, 400, 300, 250, 221, 190];
const LEVEL_LINES: [u32; 10] = [20,   40,  60,  80,  100, 120, 140, 160, 180, 200];</pre></div>
<p class="calibre3">The first one corresponds to the times before the current <kbd class="calibre14">tetrimino</kbd> descends by one block. Each case being a different level.</p>
<p class="calibre3">The second one corresponds to how many lines the player needs before getting to the next level.</p>
<p class="calibre3">Next, let's add the following method in our <kbd class="calibre14">Tetris</kbd> type:</p>
<div><pre class="calibre22">fn increase_line(&amp;mut self) {
    self.nb_lines += 1;
    if self.nb_lines &gt; LEVEL_LINES[self.current_level as usize - 1] {
        self.current_level += 1;
    }
}</pre></div>
<p class="calibre3">Nothing complicated. Just be careful when reading the <kbd class="calibre14">LEVEL_LINES</kbd> const because our <kbd class="calibre14">current_level</kbd> variable starts at <kbd class="calibre14">1</kbd> and not 0.</p>
<p class="calibre3">Next, we'll need to update how we determine whether the time is up or not. To do so, let's write another function:</p>
<div><pre class="calibre22">fn is_time_over() {
    match timer.elapsed() {
        Ok(elapsed) =&gt; {
            let millis = elapsed.as_secs() as u32 * 1000 + <br class="calibre6"/>             elapsed.subsec_nanos() / 1_000_000;
            millis &gt; LEVEL_TIMES[tetris.current_level as usize - 1]
        }
        Err(_) =&gt; false,
    }
}</pre></div>
<p class="calibre3">A small but tricky one. The problem is that the type returned by <kbd class="calibre14">timer.elapsed</kbd> (which is <kbd class="calibre14">Duration</kbd>) doesn't provide a method to get the number of milliseconds, so we need to get it ourselves.</p>
<p class="calibre3">First, we get the number of seconds elapsed and then multiply it by 1,000 (because 1 second = 1,000 milliseconds). Finally, we get the number of nanoseconds (in the current second) and divide it by 1,000,000 (because 1 millisecond = 1 million nanoseconds).</p>
<p class="calibre3">We can now compare the results to see whether the <kbd class="calibre14">tetrimino</kbd> should descend or not and return the result:</p>
<div><pre class="calibre22">if is_time_over(&amp;tetris, &amp;timer) {
    let mut make_permanent = false;
    if let Some(ref mut piece) = tetris.current_piece {
        let x = piece.x;
        let y = piece.y + 1;
        make_permanent = !piece.change_position(&amp;tetris.game_map,<br class="calibre6"/>         x, y);
    }
    if make_permanent {
        tetris.make_permanent();
    }
    timer = SystemTime::now();
}</pre></div>
<p class="calibre3">And with this, we've finished this part. Let's make the last one now: the highscore loading/overwriting!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Highscores loading/overwriting</h1>
                
            
            
                
<p class="calibre3">We already saw how to perform the I/O operations in the previous chapter, so it'll be very quick to do:</p>
<div><pre class="calibre22">const NB_HIGHSCORES: usize = 5;

fn update_vec(v: &amp;mut Vec&lt;u32&gt;, value: u32) -&gt; bool {
    if v.len() &lt; NB_HIGHSCORES {
        v.push(value);<br class="calibre6"/>        v.sort();
        true
    } else {
        for entry in v.iter_mut() {
            if value &gt; *entry {
                *entry = value;
                return true;
            }
        }
        false
    }
}

fn print_game_information(tetris: &amp;Tetris) {
    let mut new_highest_highscore = true;
    let mut new_highest_lines_sent = true;
    if let Some((mut highscores, mut lines_sent)) = <br class="calibre6"/>     load_highscores_and_lines() {
        new_highest_highscore = update_vec(&amp;mut highscores,  <br class="calibre6"/>         tetris.score);
        new_highest_lines_sent = update_vec(&amp;mut lines_sent,  <br class="calibre6"/>         tetris.nb_lines);
        if new_highest_highscore || new_highest_lines_sent {
            save_highscores_and_lines(&amp;highscores, &amp;lines_sent);
        }
    } else {
        save_highscores_and_lines(&amp;[tetris.score], &amp;<br class="calibre6"/>         [tetris.nb_lines]);
    }
    println!("Game over...");
    println!("Score:           {}{}",
             tetris.score,
             if new_highest_highscore { " [NEW HIGHSCORE]"} else {   <br class="calibre6"/>              "" });
    println!("Number of lines: {}{}",
             tetris.nb_lines,
             if new_highest_lines_sent { " [NEW HIGHSCORE]"} else {  <br class="calibre6"/>              "" });
    println!("Current level:   {}", tetris.current_level);
}</pre></div>
<p class="calibre3">Not much to explain with this code. For the moment, we limited the number of each highscore to <kbd class="calibre14">5</kbd>. Just update it as you want.</p>
<p class="calibre3">And with this code, all the mechanisms are implemented. All that's left is to actually draw the game!</p>
<p class="calibre3">Here is the full code for this chapter:</p>
<div><pre class="calibre22">extern crate rand;
extern crate sdl2;

use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::{Canvas, Texture, TextureCreator};
use sdl2::video::{Window, WindowContext};

use std::fs::File;
use std::io::{self, Read, Write};
use std::thread::sleep;
use std::time::{Duration, SystemTime};

const TETRIS_HEIGHT: usize = 40;
const HIGHSCORE_FILE: &amp;'static str = "scores.txt";
const LEVEL_TIMES: [u32; 10] = [1000, 850, 700, 600, 500, 400, 300, 250, 221, 190];
const LEVEL_LINES: [u32; 10] = [20,   40,  60,  80,  100, 120, 140, 160, 180, 200];
const NB_HIGHSCORES: usize = 5;

type Piece = Vec&lt;Vec&lt;u8&gt;&gt;;
type States = Vec&lt;Piece&gt;;

trait TetriminoGenerator {
    fn new() -&gt; Tetrimino;
}

struct TetriminoI;

impl TetriminoGenerator for TetriminoI {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![1, 1, 1, 1],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0],
                              vec![0, 1, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoJ;

impl TetriminoGenerator for TetriminoJ {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![2, 2, 2, 0],
                              vec![2, 0, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![2, 2, 0, 0],
                              vec![0, 2, 0, 0],
                              vec![0, 2, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 0, 2, 0],
                              vec![2, 2, 2, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![2, 0, 0, 0],
                              vec![2, 0, 0, 0],
                              vec![2, 2, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoL;

impl TetriminoGenerator for TetriminoL {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![3, 3, 3, 0],
                              vec![0, 0, 3, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 3, 0, 0],
                              vec![0, 3, 0, 0],
                              vec![3, 3, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![3, 0, 0, 0],
                              vec![3, 3, 3, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![3, 3, 0, 0],
                              vec![3, 0, 0, 0],
                              vec![3, 0, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoO;

impl TetriminoGenerator for TetriminoO {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![4, 4, 0, 0],
                              vec![4, 4, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 5,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoS;

impl TetriminoGenerator for TetriminoS {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![0, 5, 5, 0],
                              vec![5, 5, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 5, 0, 0],
                              vec![0, 5, 5, 0],
                              vec![0, 0, 5, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoZ;

impl TetriminoGenerator for TetriminoZ {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![6, 6, 0, 0],
                              vec![0, 6, 6, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 0, 6, 0],
                              vec![0, 6, 6, 0],
                              vec![0, 6, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct TetriminoT;

impl TetriminoGenerator for TetriminoT {
    fn new() -&gt; Tetrimino {
        Tetrimino {
            states: vec![vec![vec![7, 7, 7, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![7, 7, 0, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![7, 7, 7, 0],
                              vec![0, 0, 0, 0],
                              vec![0, 0, 0, 0]],
                         vec![vec![0, 7, 0, 0],
                              vec![0, 7, 7, 0],
                              vec![0, 7, 0, 0],
                              vec![0, 0, 0, 0]]],
            x: 4,
            y: 0,
            current_state: 0,
        }
    }
}

struct Tetrimino {
    states: States,
    x: isize,
    y: usize,
    current_state: u8,
}

impl Tetrimino {
    fn rotate(&amp;mut self, game_map: &amp;[Vec&lt;u8&gt;]) {
        let mut tmp_state = self.current_state + 1;
        if tmp_state as usize &gt;= self.states.len() {
            tmp_state = 0;
        }
        let x_pos = [0, -1, 1, -2, 2, -3];
        for x in x_pos.iter() {
            if self.test_position(game_map, tmp_state as usize,
                                  self.x + x, self.y) == true {
                self.current_state = tmp_state;
                self.x += *x;
                break
            }
        }
    }

    fn test_position(&amp;self, game_map: &amp;[Vec&lt;u8&gt;],
                     tmp_state: usize, x: isize, y: usize) -&gt; bool {
        for shift_y in 0..4 {
            for shift_x in 0..4 {
                let x = x + shift_x;
                if self.states[tmp_state][shift_y][shift_x as usize] != 0 &amp;&amp;
                    (y + shift_y &gt;= game_map.len() ||
                     x &lt; 0 ||
                     x as usize &gt;= game_map[y + shift_y].len() ||
                     game_map[y + shift_y][x as usize] != 0) {
                    return false;
                }
            }
        }
        return true;
    }

    fn test_current_position(&amp;self, game_map: &amp;[Vec&lt;u8&gt;]) -&gt; bool {
        self.test_position(game_map, self.current_state as usize, self.x, self.y)
    }

    fn change_position(&amp;mut self, game_map: &amp;[Vec&lt;u8&gt;], new_x: isize, new_y: usize) -&gt; bool {
        if self.test_position(game_map, self.current_state as usize, new_x, new_y) == true {
            self.x = new_x as isize;
            self.y = new_y;
            true
        } else {
            false
        }
    }
}

struct Tetris {
    game_map: Vec&lt;Vec&lt;u8&gt;&gt;,
    current_level: u32,
    score: u32,
    nb_lines: u32,
    current_piece: Option&lt;Tetrimino&gt;,
}

impl Tetris {
    fn new() -&gt; Tetris {
        let mut game_map = Vec::new();
        for _ in 0..16 {
            game_map.push(vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
        Tetris {
            game_map: game_map,
            current_level: 1,
            score: 0,
            nb_lines: 0,
            current_piece: None,
        }
    }

    fn update_score(&amp;mut self, to_add: u32) {
        self.score += to_add;
    }

    fn increase_level(&amp;mut self) {
        self.current_level += 1;
    }

    fn increase_line(&amp;mut self) {
        self.nb_lines += 1;
        if self.nb_lines &gt; LEVEL_LINES[self.current_level as usize - 1] {
            self.increase_level();
        }
    }

    fn check_lines(&amp;mut self) {
        let mut y = 0;
        let mut score_add = 0;

        while y &lt; self.game_map.len() {
            let mut complete = true;

            for x in &amp;self.game_map[y] {
                if *x == 0 {
                    complete = false;
                    break
                }
            }
            if complete == true {
                score_add += self.current_level;
                self.game_map.remove(y);
                y -= 1;
            }
            y += 1;
        }
        if self.game_map.len() == 0 {
            // A "tetris"!
            score_add += 1000;
        }
        self.update_score(score_add);
        while self.game_map.len() &lt; 16 {
            self.increase_line();
            self.game_map.insert(0, vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }
    }

    fn create_new_tetrimino(&amp;self) -&gt; Tetrimino {
        static mut PREV: u8 = 7;
        let mut rand_nb = rand::random::&lt;u8&gt;() % 7;
        if unsafe { PREV } == rand_nb {
            rand_nb = rand::random::&lt;u8&gt;() % 7;
        }
        unsafe { PREV = rand_nb; }
        match rand_nb {
            0 =&gt; TetriminoI::new(),
            1 =&gt; TetriminoJ::new(),
            2 =&gt; TetriminoL::new(),
            3 =&gt; TetriminoO::new(),
            4 =&gt; TetriminoS::new(),
            5 =&gt; TetriminoZ::new(),
            6 =&gt; TetriminoT::new(),
            _ =&gt; unreachable!(),
        }
    }

    fn make_permanent(&amp;mut self) {
        let mut to_add = 0;
        if let Some(ref mut piece) = self.current_piece {
            let mut shift_y = 0;

            while shift_y &lt; piece.states[piece.current_state as usize].len() &amp;&amp;
                  piece.y + shift_y &lt; self.game_map.len() {
                let mut shift_x = 0;

                while shift_x &lt; piece.states[piece.current_state as usize] <br class="calibre6"/>                  [shift_y].len() &amp;&amp;
                      (piece.x + shift_x as isize) &lt; self.game_map[piece.y + <br class="calibre6"/>                       shift_y].len() as isize {
                    if piece.states[piece.current_state as usize][shift_y][shift_x]  <br class="calibre6"/>                    != 0 {
                        let x = piece.x + shift_x as isize;
                        self.game_map[piece.y + shift_y][x as usize] =
                            piece.states[piece.current_state as usize][shift_y]<br class="calibre6"/>                            [shift_x];
                    }
                    shift_x += 1;
                }
                shift_y += 1;
            }
            to_add += self.current_level;
        }
        self.update_score(to_add);
        self.check_lines();
        self.current_piece = None;
    }
}

fn handle_events(tetris: &amp;mut Tetris, quit: &amp;mut bool, timer: &amp;mut SystemTime,
                 event_pump: &amp;mut sdl2::EventPump) -&gt; bool {
    let mut make_permanent = false;
    if let Some(ref mut piece) = tetris.current_piece {
        let mut tmp_x = piece.x;
        let mut tmp_y = piece.y;

        for event in event_pump.poll_iter() {
            match event {
                Event::Quit { .. } |
                Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
                    *quit = true;
                    break
                }
                Event::KeyDown { keycode: Some(Keycode::Down), .. } =&gt; {
                    *timer = SystemTime::now();
                    tmp_y += 1;
                }
                Event::KeyDown { keycode: Some(Keycode::Right), .. } =&gt; {
                    tmp_x += 1;
                }
                Event::KeyDown { keycode: Some(Keycode::Left), .. } =&gt; {
                    tmp_x -= 1;
                }
                Event::KeyDown { keycode: Some(Keycode::Up), .. } =&gt; {
                    piece.rotate(&amp;tetris.game_map);
                }
                Event::KeyDown { keycode: Some(Keycode::Space), .. } =&gt; {
                    let x = piece.x;
                    let mut y = piece.y;
                    while piece.change_position(&amp;tetris.game_map, x, y + 1) == true <br class="calibre6"/>                    {
                        y += 1;
                    }
                    make_permanent = true;
                }
                _ =&gt; {}
            }
        }
        if !make_permanent {
            if piece.change_position(&amp;tetris.game_map, tmp_x, tmp_y) == false &amp;&amp;
               tmp_y != piece.y {
                make_permanent = true;
            }
        }
    }
    if make_permanent {
        tetris.make_permanent();
        *timer = SystemTime::now();
    }
    make_permanent
}

fn write_into_file(content: &amp;str, file_name: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(file_name)?;
    f.write_all(content.as_bytes())
}

fn read_from_file(file_name: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(file_name)?;
    let mut content = String::new();
    f.read_to_string(&amp;mut content)?;
    Ok(content)
}

fn slice_to_string(slice: &amp;[u32]) -&gt; String {
    slice.iter().map(|highscore| highscore.to_string()).collect::&lt;Vec&lt;String&gt;&gt;().join(" ")
}

fn save_highscores_and_lines(highscores: &amp;[u32], number_of_lines: &amp;[u32]) -&gt; bool {
    let s_highscores = slice_to_string(highscores);
    let s_number_of_lines = slice_to_string(number_of_lines);
    write_into_file(&amp;format!("{}\n{}\n", s_highscores, s_number_of_lines), HIGHSCORE_FILE).is_ok()
}

fn line_to_slice(line: &amp;str) -&gt; Vec&lt;u32&gt; {
    line.split(" ").filter_map(|nb| nb.parse::&lt;u32&gt;().ok()).collect()
}

fn load_highscores_and_lines() -&gt; Option&lt;(Vec&lt;u32&gt;, Vec&lt;u32&gt;)&gt; {
    if let Ok(content) = read_from_file(HIGHSCORE_FILE) {
        let mut lines = content.splitn(2, "\n").map(|line| line_to_slice(line)).collect::&lt;Vec&lt;_&gt;&gt;();
        if lines.len() == 2 {
            let (lines_sent, highscores) = (lines.pop().unwrap(), lines.pop().unwrap());
            Some((highscores, lines_sent))
        } else {
            None
        }
    } else {
        None
    }
}

fn update_vec(v: &amp;mut Vec&lt;u32&gt;, value: u32) -&gt; bool {
    if v.len() &lt; NB_HIGHSCORES {
        v.push(value);
        true
    } else {
        for entry in v.iter_mut() {
            if value &gt; *entry {
                *entry = value;
                return true;
            }
        }
        false
    }
}

fn print_game_information(tetris: &amp;Tetris) {
    let mut new_highest_highscore = true;
    let mut new_highest_lines_sent = true;
    if let Some((mut highscores, mut lines_sent)) = load_highscores_and_lines() {
        new_highest_highscore = update_vec(&amp;mut highscores, tetris.score);
        new_highest_lines_sent = update_vec(&amp;mut lines_sent, tetris.nb_lines);
        if new_highest_highscore || new_highest_lines_sent {
            save_highscores_and_lines(&amp;highscores, &amp;lines_sent);
        }
    } else {
        save_highscores_and_lines(&amp;[tetris.score], &amp;[tetris.nb_lines]);
    }
    println!("Game over...");
    println!("Score:           {}{}",
             tetris.score,
             if new_highest_highscore { " [NEW HIGHSCORE]"} else { "" });
    println!("Number of lines: {}{}",
             tetris.nb_lines,
             if new_highest_lines_sent { " [NEW HIGHSCORE]"} else { "" });
    println!("Current level:   {}", tetris.current_level);
}

fn is_time_over(tetris: &amp;Tetris, timer: &amp;SystemTime) -&gt; bool {
    match timer.elapsed() {
        Ok(elapsed) =&gt; {
            let millis = elapsed.as_secs() as u32 * 1000 + elapsed.subsec_nanos() /  <br class="calibre6"/>             1_000_000;
            millis &gt; LEVEL_TIMES[tetris.current_level as usize - 1]
        }
        Err(_) =&gt; false,
    }
}

fn main() {<br class="calibre6"/>    let sdl_context = sdl2::init().expect("SDL initialization failed");
    let mut tetris = Tetris::new();
    let mut timer = SystemTime::now();

    let mut event_pump = sdl_context.event_pump().expect("Failed to get SDL event <br class="calibre6"/>     pump");

    let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;
    let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;

    loop {
        if is_time_over(&amp;tetris, &amp;timer) {
            let mut make_permanent = false;
            if let Some(ref mut piece) = tetris.current_piece {
                let x = piece.x;
                let y = piece.y + 1;
                make_permanent = !piece.change_position(&amp;tetris.game_map, x, y);
            }
            if make_permanent {
                tetris.make_permanent();
            }
            timer = SystemTime::now();
        }

        // We need to draw the tetris "grid" in here.

        if tetris.current_piece.is_none() {
            let current_piece = tetris.create_new_tetrimino();
            if !current_piece.test_current_position(&amp;tetris.game_map) {
                print_game_information(&amp;tetris);
                break
            }
            tetris.current_piece = Some(current_piece);
        }
        let mut quit = false;
        if !handle_events(&amp;mut tetris, &amp;mut quit, &amp;mut timer, &amp;mut event_pump) {
            if let Some(ref mut piece) = tetris.current_piece {
                // We need to draw our current tetrimino in here.
            }
        }
        if quit {
            print_game_information(&amp;tetris);
            break
        }

        // We need to draw the game map in here.

        sleep(Duration::new(0, 1_000_000_000u32 / 60));
    }
}<br class="calibre6"/></pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">Phew! That was quite the chapter! But now, all the game's mechanisms are here so adding the last remaining parts (such as the drawing) will be a piece of cake.</p>
<p class="calibre3">Once again, be sure to understand this chapter before starting to read the next one.</p>


            

            
        
    </body></html>