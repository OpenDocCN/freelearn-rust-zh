<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Must-Have Macro Crates</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the most useful features of Rust is its crate ecosystem. In languages such as C/C++, it's sometimes troublesome to find the proper library to use, and then it can be difficult to actually use it. This is almost straightforward in Rust, and in this  chapter, we will see some of the most interesting crates, which give us great metaprogramming primitives:</p>
<ul>
<li><strong>Serde</strong>: Data serialization and deserialization support</li>
<li><strong>Nom</strong>: Zero-copy byte-level parser creation</li>
<li><strong>Lazy static</strong>: Lazily initialized static variables</li>
<li><strong>Derive builder</strong>: Derive the common builder pattern for your structures</li>
<li><strong>Failure</strong>: Easy error handling</li>
<li><strong>Log and env_logger</strong>: Logging for your software</li>
<li><strong>CLAP</strong>: Creating command-line interfaces</li>
<li><strong>Maud</strong>: Compile-time templates with huge performance</li>
<li><strong>Diesel</strong>: MySQL/MariaDB, PostgreSQL, and SQLite database management, and ORM</li>
<li><strong>Rocket</strong>: Nightly only high-performance web framework</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with external data</h1>
                </header>
            
            <article>
                
<p>Sometimes, we do not have complete control of our software stack. Usually, if you want to create a project, you will need to contact external data sources, which can lead to many issues, since achieving compatibility between your code and external APIs or sources can be difficult. Moreover, it can lead to performance loss, which we should avoid as much as possible. Let's check some efficient and easy-to-use solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data serialization and deserialization</h1>
                </header>
            
            <article>
                
<p>When it comes to data serialization and deserialization in Rust, there is no doubt we are talking about serde (<a href="https://crates.io/crates/serde">https://crates.io/crates/serde</a>). Serde, from <em>serialization and deserialization</em>, gives us a unique tool to be able to transform our data structures to JSON, TOML, XML, or any other serializable format. Let's see how it works.</p>
<p>We start with a simple structure:</p>
<pre style="padding-left: 60px">struct MyData {<br/>    field1: String,<br/>    field2: u32,<br/>    field3: Vec&lt;u8&gt;,<br/>}</pre>
<p>And we add <kbd>serde</kbd> and <kbd>serde_derive</kbd> as dependencies to our <kbd>Cargo.toml</kbd> file:</p>
<pre style="padding-left: 60px">[dependencies]<br/>serde = "1.0.0"<br/>serde_derive = "1.0.0"</pre>
<p>Then, in our <kbd>main.rs</kbd> file, we just need to import the crates using <kbd>extern crate</kbd> and derive the <kbd>Serialize</kbd> trait for our structure:</p>
<pre style="padding-left: 60px">extern crate serde;<br/>#[macro_use]<br/>extern crate serde_derive;<br/><br/>#[derive(Debug, Serialize)]<br/>struct MyData {<br/>    field1: String,<br/>    field2: u32,<br/>    field3: Vec&lt;u8&gt;,<br/>}</pre>
<p>Now, we will need a <em>frontend</em> for our serializable structure. This is because <kbd>serde</kbd> by itself only gives our structure the ability to be serialized, but not the language into which it will get serialized. Let's use JSON as an example, since it's a very well-known object notation language. We first add the dependency to the <kbd>Cargo.toml</kbd> file:</p>
<pre style="padding-left: 60px">serde_json = "1.0.0"</pre>
<p>Then, we import it in our <kbd>main.rs</kbd> file and check the data serialization:</p>
<pre style="padding-left: 60px">extern crate serde_json;<br/><br/>fn main() {<br/>    let example = MyData {<br/>        field1: "Test field".to_owned(),<br/>        field2: 33_940,<br/>        field3: vec![65, 22, 96, 43],<br/>    };<br/><br/>    let json = serde_json::to_string_pretty(&amp;example)<br/>                .expect("could not generate JSON string");<br/>    println!("{}", json);<br/>}</pre>
<p>If we execute <kbd>cargo run</kbd>, we will see that the output of this code is the following:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a73ee9dc-390d-42d1-9736-d48313fb7755.png" style="width:14.50em;height:11.08em;"/></div>
<p>This is a perfectly formatted and prettified JSON structure. OK, so how can we convert that string back into our data structure? We need to derive <kbd>Deserialize</kbd>:</p>
<pre style="padding-left: 60px">#[derive(Debug, Serialize, Deserialize)]<br/>struct MyData {<br/>    field1: String,<br/>    field2: u32,<br/>    field3: Vec&lt;u8&gt;,<br/>}<br/><br/>fn main() {<br/>    let example = MyData {<br/>        field1: "Test field".to_owned(),<br/>        field2: 33_940,<br/>        field3: vec![65, 22, 96, 43],<br/>    };<br/><br/>    let json = serde_json::to_string_pretty(&amp;example)<br/>                .expect("could not generate JSON string");<br/>    println!("JSON:");<br/>    println!("{}", json);<br/><br/>    let example_back: MyData = serde_json::from_str(&amp;json)<br/>                        .expect("could not parse JSON string");<br/>    println!("Back from JSON:");<br/>    println!("{:?}", example_back);<br/>}</pre>
<p>This will give us this output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/71155785-3f5e-49bc-97e7-b49549eacd88.png" style="width:36.50em;height:13.17em;"/></div>
<p>This means that we can go back and forward, from JSON to a memory structure, really easily! But, of course this only works for direct structure <kbd>&lt;-&gt;</kbd> object serialization/deserialization. It won't work if any of them have different fields or names for fields. Or does it?</p>
<p>Well, not directly of course, but we can ask <kbd>serde</kbd> to modify some parameters of our structure when serializing or deserializing it. For example, since in Rust we should use snake case for our structure fields, and <em>pascal</em> case for enumeration and structure names, we might think it's not possible to deserialize structures with pascal case fields or enumerations with snake case variants.</p>
<p>Thankfully, the <kbd>serde</kbd> crate provides some attributes to personalize this behaviour. For example, let's suppose we want to represent the following structure in Rust:</p>
<pre style="padding-left: 60px">{<br/>    "FirstData": 56,<br/>    "SecondData": "hello, world",<br/>    "ThirdData": -1.23<br/>}</pre>
<p>We have to first create a Rust structure that will hold this information, like this:</p>
<pre style="padding-left: 60px">struct MyData {<br/>    first_data: u32,<br/>    second_data: String,<br/>    third_data: f32,<br/>}</pre>
<p>And then, we derive the appropriate traits. To rename the fields, we need to use the <kbd>#[serde]</kbd> attribute with the <kbd>rename_all</kbd> directive at the structure level, as you can see in the following code snippet:</p>
<pre style="padding-left: 60px">extern crate serde;<br/>#[macro_use]<br/>extern crate serde_derive;<br/>extern crate serde_json;<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>#[serde(rename_all = "PascalCase")]<br/>struct MyData {<br/>    first_data: u32,<br/>    second_data: String,<br/>    third_data: f32,<br/>}<br/><br/>fn main() {<br/>    let json = r#"{<br/>        "FirstData": 56,<br/>        "SecondData": "hello, world",<br/>        "ThirdData": -1.23<br/>    }"#;<br/><br/>    let in_rust: MyData = serde_json::from_str(json)<br/>                            .expect("JSON parsing failed");<br/>    println!("In Rust: {:?}", in_rust);<br/><br/>    let back_to_json = serde_json::to_string_pretty(&amp;in_rust)<br/>                        .expect("Rust to JSON failed");<br/>    println!("In JSON: {}", back_to_json);<br/>}</pre>
<p>When you run it, you will see that the output is exactly as expected:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ccb30b4f-49aa-46cc-832b-db6e1d11355c.png" style="width:39.92em;height:5.83em;"/></div>
<p>You can choose between <kbd>"lowercase"</kbd>, <kbd>"PascalCase"</kbd>, <kbd>"camelCase"</kbd>, <kbd>"snake_case"</kbd>, <kbd>"SCREAMING_SNAKE_CASE"</kbd>, and <kbd>"kebab-case"</kbd>. You can also rename one particular field, which is especially useful if the original structure has a reserved keyword (such as <kbd>type</kbd>). In this case, you can use <kbd>#[serde(rename = "type")]</kbd> in the field and use the name you want in your Rust structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serializing and deserializing complex structures</h1>
                </header>
            
            <article>
                
<p>In some cases, you might want to serialize or deserialize complex data structures. Most of the time, you will have a crate that does this for you (such as the <em>chrono</em> crate for dates and times). But in some cases this is not enough. Suppose you have a data structure that has a field that can take a value of either 1 or 2, and that each of them means something different. In Rust, you would use an enumeration for it, but we may not always have control of external APIs, for example.</p>
<p>Let's look at this structure:</p>
<pre style="padding-left: 60px">{<br/>    "timestamp": "2018-01-16T15:43:04",<br/>    "type": 1,<br/>}</pre>
<p>And let's say we have some code, almost ready to compile, which represents this structure:</p>
<pre style="padding-left: 60px">#[derive(Debug)]<br/>enum DateType {<br/>    FirstType,<br/>    SecondType,<br/>}<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct MyDate {<br/>    timestamp: NaiveDateTime,<br/>    #[serde(rename = "type")]<br/>    date_type: DateType,<br/>}</pre>
<p>As you can see, we will need to define that <kbd>NaiveDateTime</kbd> structure. We will need to add the following to our <kbd>Cargo.toml</kbd> file:</p>
<pre style="padding-left: 60px">[dependencies.chrono]<br/>version = "0.4.0"<br/>features = ["serde"]</pre>
<p>And then add the imports at the top of the <kbd>main.rs</kbd> file:</p>
<pre style="padding-left: 60px">extern crate chrono;<br/>use chrono::NaiveDateTime;</pre>
<p>The only thing left is to implement <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> for <kbd>DateType</kbd>. But what if this enumeration is not part of our crate and we cannot modify it? We can, in this case, specify a way of making it work by using a function in our crate, adding the function name as a serde <kbd>deserialize_with</kbd> attribute in the <kbd>MyDate</kbd> type:</p>
<pre style="padding-left: 60px">#[derive(Debug, Serialize, Deserialize)]<br/>struct MyDate {<br/>    timestamp: NaiveDateTime,<br/>    #[serde(rename = "type",<br/>            deserialize_with = "deserialize_date_type")]    <br/>    date_type: DateType,<br/>}</pre>
<p>Then, we will need to implement that function. It is required that the function has the following signature:</p>
<pre style="padding-left: 60px">use serde::{Deserializer, Serializer};<br/><br/>fn deserialize_date_type&lt;'de, D&gt;(deserializer: D)<br/>    -&gt; Result&lt;DateType, D::Error&gt;<br/>    where D: Deserializer&lt;'de&gt;<br/>{<br/>    unimplemented!()<br/>}<br/><br/>fn serialize_date_type&lt;S&gt;(date_type: &amp;DateType, serializer: S)<br/>    -&gt; Result&lt;S::Ok, S::Error&gt;<br/>    where S: Serializer<br/>{<br/>    unimplemented!()<br/>}</pre>
<p>Then, it's as simple as using the <kbd>Deserializer</kbd> and <kbd>Serializer</kbd> traits. You can get the full API documentation by running <kbd>cargo doc</kbd>, but we will find out how to do it for this particular case. Let's start with the <kbd>Serialize</kbd> implementation, since it's simpler than the <kbd>Deserialize</kbd> implementation. You will just need to call the <kbd>serialize_u8()</kbd> (or any other integer) method with the appropriate value, as you can see in the following code snippet:</p>
<pre style="padding-left: 60px">fn serialize_date_type&lt;S&gt;(date_type: &amp;DateType, serializer: S)<br/>    -&gt; Result&lt;S::Ok, S::Error&gt;<br/>    where S: Serializer<br/>{<br/>    use serde::Serializer;<br/><br/>    serializer.serialize_u8(match date_type {<br/>        DateType::FirstType =&gt; 1,<br/>        DateType::SecondType =&gt; 2,<br/>    })<br/>}</pre>
<p>As you can see, we just serialize an integer depending on the variant of the date type. To select which integer to serialize, we just match the enumeration. The <kbd>Deserializer</kbd> trait uses the visitor pattern, though, so we also <span>need to </span>implement a small structure that implements the <kbd>Visitor</kbd> trait. This is not very difficult, but can be a bit complex the first time we do it. Let's check it out:</p>
<pre style="padding-left: 60px">fn deserialize_date_type&lt;'de, D&gt;(deserializer: D)<br/>    -&gt; Result&lt;DateType, D::Error&gt;<br/>    where D: Deserializer&lt;'de&gt;<br/>{<br/>    use std::fmt;<br/>    use serde::Deserializer;<br/>    use serde::de::{self, Visitor};<br/><br/>    struct DateTypeVisitor;<br/><br/>    impl&lt;'de&gt; Visitor&lt;'de&gt; for DateTypeVisitor {<br/>        type Value = DateType;<br/><br/>        fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter)<br/>            -&gt; fmt::Result<br/>        {<br/>            formatter.write_str("an integer between 1 and 2")<br/>        }<br/><br/>        fn visit_u64&lt;E&gt;(self, value: u64)<br/>            -&gt; Result&lt;Self::Value, E&gt;<br/>            where E: de::Error<br/>        {<br/>            match value {<br/>                1 =&gt; Ok(DateType::FirstType),<br/>                2 =&gt; Ok(DateType::SecondType),<br/>                _ =&gt; {<br/>                    let error =<br/>                        format!("type out of range: {}", value);<br/>                    Err(E::custom(error))<br/>                }<br/>            }<br/>        }<br/><br/>        // Similar for other methods, if you want:<br/>        //   - visit_i8<br/>        //   - visit_i16<br/>        //   - visit_i32<br/>        //   - visit_i64<br/>        //   - visit_u8<br/>        //   - visit_u16<br/>        //   - visit_u32<br/>    }<br/><br/>    deserializer.deserialize_u64(DateTypeVisitor)<br/>}</pre>
<p>As you can see, I implemented the <kbd>visit_u64()</kbd> function for <kbd>Visitor</kbd>. This is because <kbd>serde_json</kbd> seems to use that function when serializing and deserializing integers. You can implement the rest if you want <kbd>Visitor</kbd> to be compatible with other serialization and deserialization frontends (such as XML, TOML, and others). You can see that the structure and the <kbd>Visitor</kbd> trait implementations are defined inside the function, so we do not pollute the namespace outside the function.</p>
<p>You will be able to test it with a new <kbd>main()</kbd> function:</p>
<pre style="padding-left: 60px">fn main() {<br/>    let json = r#"{<br/>        "timestamp": "2018-01-16T15:43:04",<br/>        "type": 1<br/>    }"#;<br/><br/>    let in_rust: MyDate = serde_json::from_str(json)<br/>                            .expect("JSON parsing failed");<br/>    println!("In Rust: {:?}", in_rust);<br/><br/></pre>
<pre style="padding-left: 60px">    let back_to_json = serde_json::to_string_pretty(&amp;in_rust)<br/>                        .expect("Rust to JSON failed");<br/>    println!("In JSON: {}", back_to_json);<br/>}</pre>
<p>It should show the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e541b3dd-ef75-4e98-98ad-eb5e59060045.png" style="width:37.17em;height:5.17em;"/></div>
<p>You can of course implement the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits for full structures and enumerations, if the <kbd>serde</kbd> attributes are not enough for your needs. Their implementation is close to the ones seen in these functions, but you will need to check the API for more complex data serialization and deserialization. You can find a great guide at <a href="https://serde.rs/">https://serde.rs/</a> explaining the specific options for this crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing byte streams</h1>
                </header>
            
            <article>
                
<p>Sometimes, you might want to parse byte streams or byte slices to get valuable data. An example could be parsing a TCP byte stream to get HTTP data. Thanks to <kbd>Rust</kbd> and the <kbd>Nom</kbd> crate, we have an extremely efficient parser generator, which will not add extra overhead by copying data within your crate.</p>
<p>With the <kbd>Nom</kbd><span> crate</span>, you create functions that will read the input data byte by byte and return the parsed data. The aim in this section is not to master the <kbd>Nom</kbd><span> crate,</span> but to understand its power and point you to the appropriate documentation. So, let's see the adapted example from Zbigniew Siciarz's <span class="packt_screen">24 days of Rust</span> (<a href="https://siciarz.net/24-days-rust-nom-part-1/">https://siciarz.net/24-days-rust-nom-part-1/</a>), where he showed a short example of how to parse the first line of the HTTP protocol. You can read more complex tutorials on his blog.</p>
<p>Let's first define what the first line of the protocol looks like:</p>
<pre style="padding-left: 60px"><span class="kd">let</span><span class="w"> </span><span class="n">first_line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"GET /home/ HTTP/1.1</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span></pre>
<p>As you can see, the <kbd>first_line</kbd> variable is a byte array (denoted by the <kbd>b</kbd> before the string). It just has the method as the first word, in this case <kbd>GET</kbd>, but it could be <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, or any of the rest methods. We will stick to these four for simplicity. Then, we can read the URL the client is trying to get, and finally, the HTTP protocol version which will be <kbd>1.1</kbd> in this case. The line ends with a carriage return and a new line.</p>
<p><kbd>Nom</kbd> uses a macro called <kbd>named!()</kbd>, where you define a parser function. The name of the macro comes from the fact that you are giving a name to the function and then its implementation.</p>
<p>If we want to start checking the first HTTP line, we will need to parse the <kbd>request</kbd> method. To do that, we have to tell the parser that the first line can be any of the possible <kbd>request</kbd> methods. We can do this by using the <kbd>alt!()</kbd> macro with multiple <kbd>tag!()</kbd> macros, one per protocol. Let's add <kbd>Nom</kbd> to our <kbd>Cargo.toml</kbd> file and start coding the method parsing:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate nom;<br/><br/>named!(parse_method, <br/>    alt!(<br/>        tag!("GET") |<br/>        tag!("POST") |<br/>        tag!("PUT") |<br/>        tag!("DELETE")<br/>    )<br/>);<br/><br/>fn main() {<br/>    let first_line = b"GET /home/ HTTP/1.1\r\n";<br/>    println!("{:?}", parse_method(&amp;first_line[..]));<br/>}</pre>
<p>This will output the following:</p>
<pre style="padding-left: 60px"><strong>Ok(([32, 47, 104, 111, 109, 101, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], [71, 69, 84]))</strong></pre>
<p>What is happening here? This seems like just a bunch of numbers, one after the other. Well, as we mentioned earlier, <kbd>Nom</kbd> works byte by byte, and does not care (unless we tell it) about the string representation of things. In this case, it has correctly found a <kbd>GET</kbd>, bytes 71, 69, and 84 in ASCII, and the rest is still not parsed. It returns a tuple with the unparsed data first and the parsed data second.</p>
<p>We can tell <kbd>Nom</kbd> that we want to read the actual <kbd>GET</kbd> string by mapping the result to the <kbd>str::from_utf8</kbd> function. Let's change the parser accordingly:</p>
<pre style="padding-left: 60px">named!(parse_method&lt;&amp;[u8], &amp;str&gt;,<br/>    alt!(<br/>        map_res!(tag!("GET"), str::from_utf8) |<br/>        map_res!(tag!("POST"), str::from_utf8) |<br/>        map_res!(tag!("PUT"), str::from_utf8) |<br/>        map_res!(tag!("DELETE"), str::from_utf8)<br/>    )<br/>);</pre>
<p>As you can see, apart from adding the <kbd>map_res!()</kbd> macro, I had to specify that the <kbd>parse_method</kbd> returns <kbd>&amp;str</kbd> after parsing the input, since <kbd>Nom</kbd> assumes that your parsers will return byte slices by default. This will output the following:</p>
<pre style="padding-left: 60px"><strong>Ok(([32, 47, 104, 111, 109, 101, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], "GET"))</strong></pre>
<p>We can even create an enumeration and map it directly, as you can see here:</p>
<pre style="padding-left: 60px">#[derive(Debug)]<br/>enum Method {<br/>    Get,<br/>    Post,<br/>    Put,<br/>    Delete,<br/>}<br/><br/>impl Method {<br/>    fn from_bytes(b: &amp;[u8]) -&gt; Result&lt;Self, String&gt; {<br/>        match b {<br/>            b"GET" =&gt; Ok(Method::Get),<br/>            b"POST" =&gt; Ok(Method::Post),<br/>            b"PUT" =&gt; Ok(Method::Put),<br/>            b"DELETE" =&gt; Ok(Method::Delete),<br/>            _ =&gt; {<br/>                let error = format!("invalid method: {}",<br/>                                    str::from_utf8(b)<br/>                                        .unwrap_or("not UTF-8"));<br/>                Err(error)<br/>            }<br/>        }<br/>    }<br/>}<br/><br/>named!(parse_method&lt;&amp;[u8], Method&gt;,<br/>    alt!(<br/>        map_res!(tag!("GET"), Method::from_bytes) |<br/>        map_res!(tag!("POST"), Method::from_bytes) |<br/>        map_res!(tag!("PUT"), Method::from_bytes) |<br/>        map_res!(tag!("DELETE"), Method::from_bytes)<br/>    )<br/>);</pre>
<p>We can combine multiple parsers and create variables in one parser that will be reused in the next one. This is useful, for example, when some parts of the data contain information for parsing the rest. This is the case with the HTTP content length header, which lets you know how much you should parse later. Let's use it to parse the complete request:</p>
<pre style="padding-left: 60px">use std::str;<br/><br/>#[derive(Debug)]<br/>struct Request {<br/>    method: Method,<br/>    url: String,<br/>    version: String,<br/>}<br/><br/>named!(parse_request&lt;&amp;[u8], Request&gt;, ws!(do_parse!(<br/>    method: parse_method &gt;&gt;<br/>    url: map_res!(take_until!(" "), str::from_utf8) &gt;&gt;<br/>    tag!("HTTP/") &gt;&gt;<br/>    version: map_res!(take_until!("\r"), str::from_utf8) &gt;&gt;<br/>    (Request {<br/>        method,<br/>        url: url.to_owned(),<br/>        version: version.to_owned()<br/>    })<br/>)));<br/><br/>fn main() {<br/>    let first_line = b"GET /home/ HTTP/1.1\r\n";<br/>    println!("{:?}", parse_request(&amp;first_line[..]));<br/>}</pre>
<p>Let's see what's happening here. We created the structure to store the line data and then we created a parser by using the <kbd>ws!()</kbd> macro (which will automatically consume spacers between tokens). The <kbd>do_parse!()</kbd> macro allows us to create a sequence of many parsers.</p>
<p>We call the <kbd>parse_method()</kbd> parser we just created for the request method and then we just store the other two strings as variables. We then just need to create the structure with the variables. Note that I also changed the call in the <kbd>main()</kbd> function. Let's see the result:</p>
<pre style="padding-left: 60px"><strong>Ok(([], Request { method: Get, url: "/home/", version: "1.1" }))</strong></pre>
<p>As we can see, there are no more bytes to parse, and the <kbd>Request</kbd> structure has been properly generated. You can generate parsers for extremely complex structures and you could, for example, parse the URL to get the segments, or the version number to get the major and minor version numbers, and so on. The only limitations are your needs.</p>
<p>In this case, we did some copying when calling <kbd>to_owned()</kbd> for the two strings, but we needed it if we wanted to generate an owned field. You can use explicit lifetimes to avoid a lot of copying if you require faster processing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about useful small crates</h1>
                </header>
            
            <article>
                
<p>While data handling probably creates some of the most bug-prone code, we should also learn about some small libraries that make our lives much easier. This is the case for the following crates, where some macros can prevent us from writing lots of error-prone or potentially non-optimal code, making our final executables faster and easier to develop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating lazily evaluated statics</h1>
                </header>
            
            <article>
                
<p>We have seen in previous chapters how, in nightly Rust, it is possible to call some trivial constant functions that are evaluated at compile time. Nevertheless, this might not be enough for our needs, and we might not even want to use nightly Rust.</p>
<p>In this case, we can use a great crate, and the macro with the same name—<kbd>lazy_static</kbd>. This macro allows us to create static variables that will run the code to be generated on their first use. Let's check it, for example, for a <kbd>HashMap</kbd>. Creating a <kbd>HashMap</kbd> or adding values to it cannot be done during compile time. As we saw in previous chapters, this can be improved by using the <kbd>phf</kbd> crate. But what if we want to add values to the <kbd>HashMap</kbd> based on some environment variable? This is where <kbd>lazy_static!{}</kbd> comes in:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate lazy_static;<br/><br/>use std::collections::HashMap;<br/><br/>lazy_static! {<br/>    static ref MY_MAP: HashMap&lt;&amp;'static str, &amp;'static str&gt; = {<br/>        use std::env;<br/><br/>        let mut map = HashMap::new();<br/>        if let Ok(val) = env::var("GEN_MAP") {<br/>            if val == "true" {<br/>                map.insert("firstKey", "firstValue");<br/>                map.insert("secondKey", "secondValue");<br/>            }<br/>        }<br/><br/>        map<br/>    };<br/>}<br/><br/><br/>fn main() {<br/>    for (key, value) in MY_MAP.iter() {<br/>        println!("{}: {}", key, value);<br/>    }<br/>}</pre>
<p>As you can see, we create a <kbd>HashMap</kbd> at runtime the first time we use it, so it will not be defined until we call <kbd>MyMap.iter()</kbd>, and if we were to use it again, it wouldn't need to be recreated. Not only that, it depends on the <kbd>GEN_MAP</kbd> environment variable. So, if we run the program with <kbd>cargo run</kbd>, it won't show anything; but if we run it with <kbd>GEN_MAP=true cargo run</kbd>, it will show the two key-values.</p>
<p>Under the hood, this will create a new type that implements <kbd>Deref</kbd> to <kbd>HashMap</kbd>. This will call to the <kbd>initialize()</kbd> function the first time it tries to get to the underlying type, generating the actual <kbd>HashMap</kbd>. This is very efficient if you only want one initialization of something you will be using more than once.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding boilerplate code for the builder pattern</h1>
                </header>
            
            <article>
                
<p>This one is pretty straightforward. If you know about the builder pattern, you will know that it's a very useful pattern to create structures. We can avoid writing the whole new builder structure by using the <kbd>derive_builder</kbd> crate. So, let's add it to our <kbd>Cargo.toml</kbd> file and check how it works:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate derive_builder;<br/><br/>use std::path::PathBuf;<br/><br/>#[derive(Default, Debug, Builder)]<br/>#[builder(setter(into), default)]<br/>struct MyData {<br/>    field1: u8,<br/>    field2: PathBuf,<br/>    field3: String,<br/>}<br/><br/><br/>fn main() {<br/>    let data = MyDataBuilder::default()<br/>                .field2("path/to/file.png")<br/>                .field3("Some string")<br/>                .build().unwrap();<br/><br/>    println!("{:?}", data);<br/>}</pre>
<p>As you can see, we just added <kbd>#[derive(Build)]</kbd> to the structure and added some extra parameters, such as allowing the use of default values for non-initialized fields and allowing generic parameters (<kbd>Into&lt;T&gt;</kbd>) for setters. Note that it requires the structure to implement the <kbd>Default</kbd> trait.</p>
<p>This enables us to initialize the structure with mere <kbd>&amp;str</kbd> variables, for example, and then the builder will do the rest. As you can see, it will create a <kbd>{your_structure}Builder</kbd> structure that you will use to build the main one. Make sure you check all the little options that let you adapt the builder to your needs on the crate page at <a href="https://crates.io/">crates.io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing errors</h1>
                </header>
            
            <article>
                
<p>If you have used multiple libraries in Rust, you will probably have noticed that managing errors is not straightforward. We have the awesome <kbd>?</kbd> operator, but if a function has multiple errors, it's not so easy to use. We can create our own error types, have variants for each of them, and have an <kbd>Into</kbd> trait implementation for each of the errors we might encounter. This is a tedious approach, but until recently it was the only way.</p>
<p>Luckily, we have a crate that can help us with that. This crate provides us with a <kbd>Fail</kbd> trait, which already guarantees thread safety and already provides default conversion implementations from all standard library error types. It also gives us some macros that help us with some boilerplate code. Let's see an example of how this would work:</p>
<pre style="padding-left: 60px">extern crate failure;<br/><br/>use std::fs::File;<br/>use std::io::Read;<br/><br/>use failure::{Error, ResultExt};<br/><br/>fn main() {<br/>    match read_file() {<br/>        Err(e) =&gt; {<br/>            eprintln!("Error: {}", e);<br/><br/>            for cause in e.causes().skip(1) {<br/>                eprintln!("Caused by: {}", cause);<br/>            }<br/>        },<br/>        Ok(content) =&gt; {<br/>            println!("{}…",<br/>                     content.chars()<br/>                            .take(15)<br/>                            .collect::&lt;String&gt;());<br/>        }<br/>    }<br/>}<br/><br/>fn read_file() -&gt; Result&lt;String, Error&gt; {<br/>    let file_name = "Cargo.toml";<br/>    let mut file = File::open(file_name)<br/>                    .context("error opening the file")?;<br/><br/>    let mut content = String::new();<br/>    file.read_to_string(&amp;mut content)<br/>        .context("error reading the file")?;<br/><br/>    Ok(content)<br/>}</pre>
<p>In this simple example, we get the first characters of the <kbd>Cargo.toml</kbd> file. As you can see, we are returning <kbd>std::io::Errors</kbd> converted into <kbd>failure::Errors</kbd> with the <kbd>?</kbd> operator. Then, we can iterate over the errors if they exist. If something goes wrong, this will be the output of the code. We have added some context for each of the potential errors, so that the output gets properly printed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0894515a-9967-4fbd-9b0b-14375bcd09ec.png" style="width:28.17em;height:2.50em;"/></div>
<p>You can also create your error traits and derive the <kbd>Fail</kbd> trait, thanks to the <kbd>failure_derive</kbd> crate. I recommend checking the complete documentation and using it for all your new projects. It brings many advantages over doing it yourself and even using the predecessor <kbd>error-chain</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging efficiently in Rust</h1>
                </header>
            
            <article>
                
<p>Logging is one of the most important parts of many applications and it's good to know that Rust has us covered in this regard. The default go-to crate should be the <kbd>log</kbd> crate, which provides us with useful macros for logging. Then, you can use the backend you want for the loggers, such as the <kbd>env_logger</kbd> crate or the <kbd>log4rs</kbd> crate.</p>
<p>The <kbd>log</kbd> crate gives us some macros, mainly <kbd>trace!()</kbd>, <kbd>debug!()</kbd>, <kbd>info!()</kbd>,  <kbd>warn!()</kbd>, and <kbd>error!()</kbd>, in ascending order of <span>relevance,</span> which we can use to log events that happen in our application. It provides some more boilerplate, but that is basically it, you will now have to configure how those macros behave. For that, you have the actual implementations.</p>
<p>If you want an easy to use, common logger, you should go for <kbd>env_logger</kbd>. It has a small footprint and can be configured with environment variables. If you need extra configuration for things such as multiple outputs, both console and files, and extra configuration, you should go for an alternative such as <kbd>log4rs</kbd>. Let's check a small <kbd>env_logger</kbd> example to see the power of this logging mechanism. You will need to add <kbd>log</kbd> and <kbd>env_logger</kbd> to your <kbd>Cargo.toml</kbd> file:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate log;<br/>extern crate env_logger;<br/><br/>fn main() {<br/>    env_logger::init();<br/><br/>    trace!("Logging {} small thing(s)", 1);<br/>    debug!("Some debug information:  {}",<br/>            "the answer is 42");<br/>    info!("This is an interesting information");<br/>    error!("An error happened, do something!");<br/>}</pre>
<p>If we run that using <kbd>cargo run</kbd>, we will see this output, since errors are shown by default:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5f1c3606-53c0-41c1-8fa4-1be168be5de5.png" style="width:45.58em;height:1.17em;"/></div>
<p>But we can run it with a different <kbd>RUST_LOG</kbd> environment variable, such as <kbd>RUST_LOG=trace cargo run</kbd>. This should show the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb3286b2-07a9-4f1f-a77e-3a898745014f.png" style="width:43.67em;height:4.33em;"/></div>
<p>As you can see, colors denote the importance of the message. Note that running <kbd>cargo</kbd> with the <kbd>RUST_LOG</kbd> variable will show a lot of extra output, since cargo itself uses <kbd>env_logger</kbd>. I recommend you read the full documentation of this crate, since it enables you to change formatters, loggers, and much more besides the default behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating command-line interfaces</h1>
                </header>
            
            <article>
                
<p>Creating a command-line interface is not always easy. In C/C++, you need to start parsing arguments and then decide which flags are set and whether they comply with all the conditions. This is a non-issue in Rust thanks to <strong>Command-Line Argument Parser</strong> (<strong>CLAP</strong>). The CLAP crate, enables us to create very complex command-line interfaces with just a bit of code.</p>
<p>Not only that; it will create the help menus for us and it will also be maintainable since it will be easy to add or remove parameters and flags. It will ensure that the input we receive is valid and it will even create command-line completion scripts for the most-used shells.</p>
<p>You can generate the complete CLI with macros, but I personally prefer to use simple Rust code. It has a few <kbd>helper</kbd> macros, though, to gather some information. Remember to add <kbd>clap</kbd> to your <kbd>Cargo.toml</kbd> file and let's see how we would create a simple command-line interface:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate clap;<br/><br/>use clap::{App, Arg};<br/><br/>fn main() {<br/>    let matches = App::new(crate_name!())<br/>                    .version(crate_version!())<br/>                    .about(crate_description!())<br/>                    .author(crate_authors!())<br/>                    .arg(<br/>                       Arg::with_name("user")<br/>                           .help("The user to say hello to")<br/>                           .value_name("username")<br/>                           .short("u")<br/>                           .long("username")<br/>                           .required(true)<br/>                           .takes_value(true)<br/>                    )<br/>                    .get_matches();<br/><br/>    let user = matches.value_of("user")<br/>            .expect("somehow the user did not give the username");<br/><br/>    println!("Hello, {}", user);<br/>}</pre>
<p>As you can see, we defined a CLI with the crate name, description, version, and authors, which will be taken from the <kbd>Cargo.toml</kbd> file at compile time so that we do not need to update it for every change. It then defines a required <kbd>user</kbd> argument, which takes a value and uses it to print the value. The <kbd>expect()</kbd> here is safe because <kbd>clap</kbd> makes sure that the argument is provided, since we asked it to with <kbd>required(true)</kbd>. If we simply execute <kbd>cargo run</kbd>, we will see the following error:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ac17912-ba27-4605-9f41-23b2b5caa043.png" style="width:35.67em;height:8.33em;"/></div>
<p>It tells us that it needs the <kbd>username</kbd> parameter and points us to the <kbd>--help</kbd> flag, automatically added by <kbd>clap</kbd> along with the <kbd>-V</kbd> flag, to show the crate version information. If we run it with <kbd>cargo run -- --help</kbd>, we will see the <kbd>help</kbd> output. Note that any argument to cargo after a double dash will be passed as an argument to the executable. Let's check it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/821db47c-3714-4b34-949b-8475481ee21b.png" style="width:31.67em;height:13.92em;"/></div>
<p>As we can see, it shows really well-formatted help text. If we want to actually see the result of passing a proper username, we can execute it with <kbd>cargo run -- -u {username}</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae79cfa0-f144-4de3-bd1f-1aa8db50ad1e.png" style="width:36.58em;height:4.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Rust for web development</h1>
                </header>
            
            <article>
                
<p>You might think that Rust is only meant to be used for complex system development, or that it should be used where security is the number one concern. Thinking of using it for web development might sound to you like huge overkill. We already have proven web-oriented languages that have worked until now, such as PHP or JavaScript, right?</p>
<p>This is far from true. Many projects use the web as their platform and for them, it's sometimes more important to be able to receive a lot of traffic without investing in expensive servers rather than using legacy technologies, especially in new products. This is where Rust comes in handy. Thanks to its speed and some really well thought out web-oriented frameworks, Rust performs even better than the legacy web programming languages.</p>
<p>Rust is even trying to replace some of the JavaScript on the client side of applications, since Rust can compile to WebAssembly, making it extremely powerful for heavy client-side web workloads. We will not learn how to compile for web clients in this book, but we will learn about some crates that allow you work on efficient web development with Rust.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating extremely efficient templates</h1>
                </header>
            
            <article>
                
<p>We have seen that Rust is a really efficient language and as you have seen in the last two chapters, metaprogramming allows for the creation of even more efficient code. Rust has great templating language support, such as Handlebars and Tera. Rust's Handlebars implementation is much faster than the JavaScript implementation, while Tera is a template engine created for Rust based on Jinja2.</p>
<p>In both cases, you define a template file and then you use Rust to parse it. Even though this will be reasonable for most web development, in some cases, it might be slower than pure Rust alternatives. This is where the Maud crate comes in. We will see how it works and how it achieves orders of magnitude faster performance than its counterparts.</p>
<p>To use Maud, you will need nightly Rust, since it uses procedural macros. As we saw in previous chapters, if you are using <kbd>rustup</kbd> you can simply run <kbd>rustup override set nightly</kbd>. Then, you will need to add Maud to your <kbd>Cargo.toml</kbd> file in the <kbd>[dependencies]</kbd> section:</p>
<pre style="padding-left: 60px">[dependencies]<br/>maud = "0.17.2</pre>
<p>Maud brings an <kbd>html!{}</kbd> procedural macro that enables you to write HTML in Rust. You will therefore need to import the necessary crate and macro in your <kbd>main.rs</kbd> or <kbd>lib.rs</kbd> file, as you will see in the following code. Remember to also add the procedural macro feature at the beginning of the crate:</p>
<pre style="padding-left: 60px">#![feature(proc_macro)]<br/><br/>extern crate maud;<br/>use maud::html;</pre>
<p>You will now be able to use the <kbd>html!{}</kbd> macro in your <kbd>main()</kbd> function. This macro will return a <kbd>Markup</kbd> object, which you can then convert to a <kbd>String</kbd> or return to Rocket or Iron for your website implementation (you will need to use the relevant Maud features in that case). Let's see what a short template implementation looks like:</p>
<pre style="padding-left: 60px">fn main() {<br/>    use maud::PreEscaped;<br/><br/>    let user_name = "FooBar";<br/>    let markup = html! {<br/>        (PreEscaped("&lt;!DOCTYPE html&gt;"))<br/>        html {<br/>            head {<br/>                title { "Test website" }<br/>                meta charset="UTF-8";<br/>            }<br/>            body {<br/>                header {<br/>                    nav {<br/>                        ul {<br/>                            li { "Home" }<br/>                            li { "Contact Us" }<br/>                        }<br/>                    }<br/>                }<br/>                main {<br/>                    h1 { "Welcome to our test template!" }<br/>                    p { "Hello, " (user_name) "!" }<br/>                }<br/>                footer {<br/>                    p { "Copyright © 2017 - someone" }<br/>                }<br/>            }<br/>        }<br/>    };<br/>    println!("{}", markup.into_string());<br/>}</pre>
<p>It seems like a complex template, but it contains just the basic information a new website should have. We first add a doctype, making sure it will not escape the content (that is what the <kbd>PreEscaped</kbd> is for) and then we start the HTML document with two parts: the <kbd>head</kbd> and the <kbd>body</kbd>. In the <kbd>head</kbd>, we add the required title and the <kbd>charset</kbd> <kbd>meta</kbd> element to tell the browser that we will be using UTF-8.</p>
<p>Then, the <kbd>body</kbd> contains the three usual sections, even though this can of course be modified. One <kbd>header</kbd>, one <kbd>main</kbd> section, and one <kbd>footer</kbd>. I added some example information in each of the sections and showed you how to add a dynamic variable in the <kbd>main</kbd> section inside a paragraph.</p>
<p>The interesting syntax here is that you can create elements with attributes, such as the <kbd>meta</kbd> element, even without content, by finishing it early with a semicolon. You can use any HTML tag and add variables. The generated code will be escaped, except if you ask for non-escaped data, and it will be minified so that it occupies the least space when being transmitted.</p>
<p>Inside the parentheses, you can call any function or variable that returns a type that implements the <kbd>Display</kbd> trait and you can even add any Rust code if you add braces around it, with the last statement returning a <kbd>Display</kbd> element. This works on attributes too.</p>
<p>This gets processed at compile time, so that at runtime it will only need to perform the minimum possible amount of work, making it extremely efficient. And not only that; the template will be typesafe thanks to Rust's compile-time guarantees, so you won't forget to close a tag or an attribute. There is a complete guide to the templating engine that can be found at <a href="https://maud.lambda.xyz/">https://maud.lambda.xyz/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting with a database</h1>
                </header>
            
            <article>
                
<p>If we want to use SQL/relational databases in Rust, there is no other crate to think about than Diesel. If you need access to NoSQL databases such as Redis or MongoDB, you will also find proper crates, but since the most used databases are relational databases, we will check Diesel here.</p>
<p>Diesel makes working with MySQL/MariaDB, PostgreSQL, and SQLite very easy by providing a great ORM and typesafe query builder. It prevents all potential SQL injections at compile time, but is still extremely fast. In fact, it's usually faster than using prepared statements, due to the way it manages connections to databases. Without entering into technical details, we will check how this stable framework works.</p>
<p>The development of Diesel has been impressive and it's already working in stable Rust. It even has a stable 1.x version, so let's check how we can map a simple table. Diesel comes with a command-line interface program, which makes it much easier to use. To install it, run <kbd>cargo install diesel_cli</kbd>. Note that, by default,<span> this </span>will try to install it for PostgreSQL, MariaDB/MySQL, and SQLite.</p>
<p>For this short tutorial, you need to have SQLite 3 development files installed, but if you want to avoid installing all MariaDB/MySQL or PostgreSQL files, you should run the following command:</p>
<pre style="padding-left: 60px"><strong>cargo install --no-default-features --features sqlite diesel_cli</strong></pre>
<p>Then, since we will be using SQLite for our short test, add a file named <kbd>.env</kbd> to the current directory, with the following content:</p>
<pre style="padding-left: 60px">DATABASE_URL=test.sqlite</pre>
<p>We can now run <kbd>diesel setup</kbd> and <kbd>diesel migration generate initial_schema</kbd>. This will create the <kbd>test.sqlite</kbd> SQLite database and a <kbd>migrations</kbd> folder, with the first empty initial schema migration. Let's add this to the initial schema <kbd>up.sql</kbd> file:</p>
<pre style="padding-left: 60px">CREATE TABLE 'users' (<br/>  'username' TEXT NOT NULL PRIMARY KEY,<br/>  'password' TEXT NOT NULL,<br/>  'email' TEXT UNIQUE<br/>);</pre>
<p>In its counterpart <kbd>down.sql</kbd> file, we will need to drop the created table:</p>
<pre style="padding-left: 60px">DROP TABLE `users`;</pre>
<p>Then, we can execute <kbd>diesel migration run</kbd> and check that everything went smoothly. We can execute <kbd>diesel migration redo</kbd> to check that the rollback and recreation worked properly. We can now start using the ORM. We will need to add diesel, <kbd>diesel_infer_schema</kbd>, and <kbd>dotenv</kbd> to our <kbd>Cargo.toml</kbd>. The <kbd>dotenv</kbd> crate will read the <kbd>.env</kbd> file to generate the environment variables. If you want to avoid using all the MariaDB/MySQL or PostgreSQL features, you will need to configure <kbd>diesel</kbd> for it:</p>
<pre style="padding-left: 60px">[dependencies]<br/>dotenv = "0.10.1"<br/><br/>[dependencies.diesel]<br/>version = "1.1.1"<br/>default-features = false<br/>features = ["sqlite"]<br/><br/>[dependencies.diesel_infer_schema]<br/>version = "1.1.0"<br/>default-features = false<br/>features = ["sqlite"]</pre>
<p>Let's now create a structure that we will be able to use to retrieve data from the database. We will also need some boilerplate code to make everything work:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate diesel;<br/>#[macro_use]<br/>extern crate diesel_infer_schema;<br/>extern crate dotenv;<br/><br/>use diesel::prelude::*;<br/>use diesel::sqlite::SqliteConnection;<br/>use dotenv::dotenv;<br/>use std::env;<br/><br/>#[derive(Debug, Queryable)]<br/>struct User {<br/>    username: String,<br/>    password: String,<br/>    email: Option&lt;String&gt;,<br/>}<br/><br/>fn establish_connection() -&gt; SqliteConnection {<br/> dotenv().ok();<br/><br/> let database_url = env::var("DATABASE_URL")<br/> .expect("DATABASE_URL must be set");<br/> SqliteConnection::establish(&amp;database_url)<br/> .expect(&amp;format!("error connecting to {}", database_url))<br/>}<br/><br/>mod schema {<br/> infer_schema!("dotenv:DATABASE_URL");<br/>}</pre>
<p>Here, the <kbd>establish_connection()</kbd> function will call <kbd>dotenv()</kbd> so that the variables in the <kbd>.env</kbd> file get to the environment, and then it uses that <kbd>DATABASE_URL</kbd> variable to establish the connection with the SQLite database and returns the handle.</p>
<p>The schema module will contain the schema of the database. The <kbd>infer_schema!()</kbd> macro will get the <kbd>DATABASE_URL</kbd> variable and connect to the database at compile time to generate the schema. Make sure you run all the migrations before compiling.</p>
<p>We can now develop a small <kbd>main()</kbd> function with the basics to list all of the users from the database:</p>
<pre style="padding-left: 60px">fn main() {<br/>    use schema::users::dsl::*;<br/><br/>    let connection = establish_connection();<br/>    let all_users = users<br/>       .load::&lt;User&gt;(&amp;connection)<br/>       .expect("error loading users");<br/><br/>    println!("{:?}", all_users);<br/>}</pre>
<div class="packt_infobox">This will just load all of the users from the database into a list. Notice the <kbd>use</kbd> statement at the beginning of the function. This retrieves the required information from the schema for the <kbd>users</kbd> table so that we can then call <kbd>users.load()</kbd>.</div>
<p>As you can see in the guides at <a href="http://diesel.rs/guides/">diesel.rs</a>, you can also generate <kbd>Insertable</kbd> objects, which might not have some of the fields with default values, and you can perform complex queries by filtering the results in the same way you would write a <kbd>SELECT</kbd> statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a complete web server</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are multiple web frameworks for Rust. Some of them work in stable Rust, such as Iron and Nickel Frameworks, and some don't, such as Rocket. We will talk about the latter since, even if it forces you to use the latest nightly branch, it's so much more powerful than the rest that it really makes no sense to use any of the others if you have the option to use Rust nightly.</p>
<p>Using Diesel with Rocket, apart from the funny wordplay joke, works seamlessly. You will probably be using the two of them together, but in this section we will learn how to create a small Rocket server without any further complexity. There are some boilerplate code implementations that add database, cache, OAuth, templating, response compression, JavaScript minification, and SASS minification to the website, such as my Rust web template (<a href="https://github.com/Razican/Rust-web-template">https://github.com/Razican/Rust-web-template</a>) in GitHub if you need to start developing a real-life Rust web application.</p>
<p>Rocket trades that nightly instability, which will break your code more often than not, for simplicity and performance. Developing a Rocket application is really easy and the performance of the results is astonishing. It's even faster than using some other, seemingly simpler frameworks, and of course, it's much faster than most of the frameworks in other languages. So, how does it feel to develop a Rocket application?</p>
<p>We start by adding the latest <kbd>rocket</kbd> and <kbd>rocket_codegen</kbd> crates to our <kbd>Cargo.toml</kbd> file and adding a nightly override to our current directory by running <kbd>rustup override set nightly</kbd>. The <kbd>rocket</kbd> crate contains all the code to run the server, while the <kbd>rocket_codegen</kbd> crate is actually a compiler plugin that modifies the language to adapt it for web development. We can now write the default <kbd>Hello, world!</kbd> Rocket example:</p>
<pre style="padding-left: 60px">#![feature(plugin)]<br/>#![plugin(rocket_codegen)]<br/><br/>extern crate rocket;<br/><br/>#[get("/")]<br/>fn index() -&gt; &amp;'static str {<br/>    "Hello, world!"<br/>}<br/><br/>fn main() {<br/>    rocket::ignite().mount("/", routes![index]).launch();<br/>}</pre>
<p>In this example, we can see how we ask Rust to let us use plugins to then import the <kbd>rocket_codegen</kbd> plugin. This will enable us to use attributes such as <kbd>#[get]</kbd> or <kbd>#[post]</kbd> with request information that will generate boilerplate code when compiled, leaving our code fairly simple for our development. Also, note that this code has been checked with Rocket 0.3 and it might fail in a future version, since the library is not stable yet.</p>
<p>In this case, you can see that the <kbd>index()</kbd> function will respond to any <kbd>GET</kbd> request with a base URL. This can be modified to accept only certain URLs, or to get the path of something from the URL. You can also have overlapping routes with different priorities, so that if one is not taken for a request guard, the next will be tried.</p>
<p>And, talking about request guards, you can create objects that can be generated when processing a request that will only let the request process a given function if they are properly built. This means that you can, for example, create a <kbd>User</kbd> object that will get generated by checking the cookies in the request and comparing them in a Redis database, only allowing the execution of the function for logged-in users. This easily prevents many logic flaws.</p>
<p>The <kbd>main()</kbd> function ignites the Rocket and mounts the index route at <kbd>/</kbd>. This means that you can have multiple routes with the same path mounted at different route paths and they do not need to know about the whole path in the URL. In the end, it will launch the Rocket server and if you run it with <kbd>cargo run</kbd>, it will show the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c271111-1912-48b4-812f-e78e5fb32511.png" style="width:28.75em;height:13.25em;"/></div>
<p>If you go to the URL, you will see the <kbd>Hello, World!</kbd> message. Rocket is highly configurable. It has a <kbd>rocket_contrib</kbd> crate which offers templates and further features, and you can create responders to add GZip compression to responses. You can also create your own error responders when an error occurs.</p>
<p>You can also configure the behavior of Rocket by using the <kbd>Rocket.toml</kbd> file and environment variables. As you can see in this last output, it is running in development mode, which adds some debugging information. You can configure different behaviors for staging and production modes and make them perform faster. Also, make sure that you compile the code in <kbd>--release</kbd> mode in production.</p>
<p>If you want to develop a web application in Rocket, make sure you check <a href="https://rocket.rs/">https://rocket.rs/</a> for further information. Future releases also look promising. Rocket will implement native CSRF and XSS prevention, which, in theory, should prevent all XSS and CSRF attacks at compile time. It will also make further customizations to the engine possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about many crates that will make your life writing Rust code much easier. You learned how they can not only allow you to write less code, but that they can help you write faster code. We also saw how easy it is to use a crate from <a href="https://crates.io/">https://crates.io/</a>, which gives us superpowers when using code written by others.</p>
<p>In the next chapter, you will learn how to develop your own macros, similar to the ones seen here, and you will also learn how to create your own procedural macros and plugins.</p>


            </article>

            
        </section>
    </body></html>