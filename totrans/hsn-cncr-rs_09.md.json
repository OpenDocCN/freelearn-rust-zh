["```rs\nvoid sim_free_bufs(mars_t* mars);\nvoid sim_clear_core(mars_t* mars);\n\nint sim_alloc_bufs(mars_t* mars);\nint sim_load_warrior(mars_t* mars, uint32_t pos, \n                     const insn_t* const code, uint16_t len);\nint sim_mw(mars_t* mars, const uint16_t * const war_pos_tab,\n           uint32_t *death_tab );\n```", "```rs\nextern crate cc;\n\nfn main() {\n    cc::Build::new()\n        .file(\"c_src/sim.c\")\n        .flag(\"-std=c11\")\n        .flag(\"-O3\")\n        .flag(\"-Wall\")\n        .flag(\"-Werror\")\n        .flag(\"-Wunused\")\n        .flag(\"-Wpedantic\")\n        .flag(\"-Wunreachable-code\")\n        .compile(\"mars\");\n}\n```", "```rs\ntypedef struct insn_st {\n  uint16_t a, b;\n  uint16_t in;\n} insn_t;\n```", "```rs\n#[derive(PartialEq, Eq, Copy, Clone, Debug, Default)]\n#[repr(C)]\npub struct Instruction {\n    a: u16,\n    b: u16,\n    ins: u16,\n}\n```", "```rs\nbit         15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\nfield       |-flags-| |–-opcode–-| |–mod-| |b-mode| |a-mode|\n```", "```rs\npub struct InstructionBuilder {\n    core_size: u16,\n    ins: u16,\n    a: u16,\n    b: u16,\n}\n```", "```rs\nimpl InstructionBuilder {\n    pub fn new(core_size: u16) -> Self {\n        InstructionBuilder {\n            core_size,\n            ins: 0_u16,\n            a: 0,\n            b: 0,\n        }\n    }\n```", "```rs\n    pub fn modifier(mut self, modifier: Modifier) -> Self {\n        let modifier_no = modifier as u16;\n        self.ins &= !MODIFIER_MASK;\n        self.ins |= modifier_no << MODIFIER_MASK.trailing_zeros();\n        self\n    }\n```", "```rs\nconst AMODE_MASK: u16 = 0b0000_0000_0000_0111;\nconst BMODE_MASK: u16 = 0b0000_0000_0011_1000;\nconst MODIFIER_MASK: u16 = 0b0000_0001_1100_0000;\nconst OP_CODE_MASK: u16 = 0b0011_1110_0000_0000;\nconst FLAG_MASK: u16 = 0b1100_0000_0000_0000;\n```", "```rs\nenum ex_op {\n    EX_DAT,             /* must be 0 */\n    EX_SPL,\n    EX_MOV,\n    EX_DJN,\n    EX_ADD,\n    EX_JMZ,\n    EX_SUB,\n    EX_SEQ,\n    EX_SNE,\n    EX_SLT,\n    EX_JMN,\n    EX_JMP,\n    EX_NOP,\n    EX_MUL,\n    EX_MODM,\n    EX_DIV,             /* 16 */\n};\n```", "```rs\n#[derive(PartialEq, Eq, Copy, Clone, Debug, Rand)]\npub enum OpCode {\n    Dat,  // 0\n    Spl,  // 1\n    Mov,  // 2\n    Djn,  // 3\n    Add,  // 4\n    Jmz,  // 5\n    Sub,  // 6\n    Seq,  // 7\n    Sne,  // 8\n    Slt,  // 9\n    Jmn,  // 10\n    Jmp,  // 11\n    Nop,  // 12\n    Mul,  // 13\n    Modm, // 14\n    Div,  // 15\n}\n```", "```rs\ntypedef struct mars_st {\n  uint32_t nWarriors;\n\n  uint32_t cycles;\n  uint16_t coresize;\n  uint32_t processes;\n\n  uint16_t maxWarriorLength;\n\n  w_t* warTab;\n  insn_t* coreMem;\n  insn_t** queueMem;\n} mars_t;\n```", "```rs\n#[repr(C)]\npub struct Mars {\n    n_warriors: u32,\n    cycles: u32,\n    core_size: u16,\n    processes: u32,\n    max_warrior_length: u16,\n    war_tab: *mut WarTable,\n    core_mem: *mut Instruction,\n    queue_mem: *const *mut Instruction,\n}\n```", "```rs\n#[repr(C)]\nstruct WarTable {\n    tail: *mut *mut Instruction,\n    head: *mut *mut Instruction,\n    nprocs: u32,\n    succ: *mut WarTable,\n    pred: *mut WarTable,\n    id: u32,\n}\n```", "```rs\n#[link(name = \"mars\")]\nextern \"C\" {\n    fn sim_alloc_bufs(mars: *mut Mars) -> isize;\n    fn sim_free_bufs(mars: *mut Mars) -> ();\n    fn sim_clear_core(mars: *mut Mars) -> ();\n    fn sim_load_warrior(mars: *mut Mars, pos: u32, \n                        code: *const Instruction, \n                        len: u16) -> isize;\n    fn sim_mw(mars: *mut Mars, war_pos_tab: *const u16, \n              death_tab: *mut u32) -> isize;\n}\n```", "```rs\nint sim_load_warrior(mars_t* mars, uint32_t pos, \n                     const insn_t* const code, uint16_t len);\n```", "```rs\nfn sim_load_warrior(mars: *mut Mars, pos: u32, \n                    code: *const Instruction, \n                    len: u16) -> isize;\n```", "```rs\nimpl MarsBuilder {\n    pub fn freeze(self) -> Mars {\n        let mut mars = Mars {\n            n_warriors: 2,\n            cycles: u32::from(self.cycles.unwrap_or(10_000)),\n            core_size: self.core_size.unwrap_or(8_000),\n            processes: self.processes.unwrap_or(10_000),\n            max_warrior_length: self.max_warrior_length.unwrap_or(100),\n            war_tab: ptr::null_mut(),\n            core_mem: ptr::null_mut(),\n            queue_mem: ptr::null_mut(),\n        };\n        unsafe {\n            sim_alloc_bufs(&mut mars);\n        }\n        mars\n    }\n```", "```rs\n    pub fn core_size(mut self, core_size: u16) -> Self {\n        self.core_size = Some(core_size);\n        self\n    }\n\n    pub fn cycles(mut self, cycles: u16) -> Self {\n        self.cycles = Some(cycles);\n        self\n    }\n\n    pub fn processes(mut self, processes: u32) -> Self {\n        self.processes = Some(processes);\n        self\n    }\n\n    pub fn max_warrior_length(mut self, max_warrior_length: u16) -> Self {\n        self.max_warrior_length = Some(max_warrior_length);\n        self\n    }\n}\n```", "```rs\nunsafe {\n    sim_alloc_bufs(&mut mars);\n}\n```", "```rs\nint sim_alloc_bufs(mars_t* mars) {\n    mars->coreMem = (insn_t*)malloc(sizeof(insn_t) * mars->coresize);\n    mars->queueMem = (insn_t**)malloc(sizeof(insn_t*) * \n                       (mars->nWarriors * mars->processes + 1));\n    mars->warTab = (w_t*)malloc(sizeof(w_t)*mars->nWarriors);\n\n    return (mars->coreMem\n            && mars->queueMem\n            && mars->warTab);\n}\n```", "```rs\nimpl Drop for Mars {\n    fn drop(&mut self) {\n        unsafe { sim_free_bufs(self) }\n    }\n}\n```", "```rs\nvoid sim_free_bufs(mars_t* mars)\n{\n    free(mars->coreMem);\n    free(mars->queueMem);\n    free(mars->warTab);\n}\n```", "```rs\nimpl Mars {\n    /// Competes two Individuals at random locations\n    ///\n    /// The return of this function indicates the winner. \n    /// `Winner::Right(12)` will mean that the 'right' player \n    /// won 12 more rounds than did 'left'. This may mean they\n    /// tied 40_000 times or maybe they only played 12 rounds \n    /// and right won each time.\n    pub fn compete(&mut self, rounds: u16, left: &Individual, \n                   right: &Individual) -> Winner {\n        let mut wins = Winner::Tie;\n        for _ in 0..rounds {\n            let core_size = self.core_size;\n            let half_core = (core_size / 2) - self.max_warrior_length;\n            let upper_core = core_size - self.max_warrior_length;\n            let left_pos = thread_rng().gen_range(0, upper_core);\n            let right_pos = if (left_pos + self.max_warrior_length) \n                               < half_core {\n                thread_rng().gen_range(half_core + 1, upper_core)\n            } else {\n                thread_rng().gen_range(0, half_core)\n            };\n            wins = wins + self.compete_inner(left, left_pos, \n                                             right, right_pos);\n        }\n        tally_fitness(wins);\n        BATTLES.fetch_add(1, Ordering::Relaxed);\n        wins\n    }\n```", "```rs\n    pub fn compete_inner(\n        &mut self,\n        left: &Individual,\n        left_pos: u16,\n        right: &Individual,\n        right_pos: u16,\n    ) -> Winner {\n        let (left_len, left_code) = left.as_ptr();\n        let (right_len, right_code) = right.as_ptr();\n\n        let warrior_position_table: Vec<u16> = vec![left_pos, right_pos];\n        let mut deaths: Vec<u32> = vec![u32::max_value(), \n                                        u32::max_value()];\n```", "```rs\n        unsafe {\n            sim_clear_core(self);\n```", "```rs\n            assert_eq!(\n                0,\n                sim_load_warrior(self, left_pos.into(), \n                                 left_code, left_len)\n            );\n            assert_eq!(\n                0,\n                sim_load_warrior(self, right_pos.into(), \n                                 right_code, right_len)\n            );\n```", "```rs\n            let alive = sim_mw(self, \n                               warrior_position_table.as_ptr(),     \n                               deaths.as_mut_ptr());\n            assert_ne!(-1, alive);\n        }\n```", "```rs\n        let left_dead = deaths[0] != u32::max_value();\n        let right_dead = deaths[1] != u32::max_value();\n        match (left_dead, right_dead) {\n            (false, false) | (true, true) => Winner::Tie,\n            (true, false) => Winner::Right(1),\n            (false, true) => Winner::Left(1),\n        }\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use individual::*;\n\n    #[test]\n    fn imp_vs_dwarf() {\n        let core_size = 8_000;\n        let rounds = 100;\n        let mut mars = MarsBuilder::default()\n                           .core_size(core_size).freeze();\n        let imp = ringers::imp(core_size);\n        let dwarf = ringers::dwarf(core_size);\n        let res = mars.compete(rounds, &imp, &dwarf);\n        println!(\"RES: {:?}\", res);\n        match res {\n            Winner::Left(_) | Winner::Tie => { \n                panic!(\"imp should lose to dwarf\")\n            },\n            Winner::Right(_) => {}\n        }\n    }\n}\n```", "```rs\nextern crate byteorder;\nextern crate feruscore;\n\nuse byteorder::{BigEndian, ReadBytesExt};\nuse feruscore::individual::*;\nuse feruscore::instruction::*;\nuse feruscore::mars::*;\nuse std::io::{self, Cursor, Read};\n```", "```rs\n#[derive(Debug)]\nstruct Config {\n    pub rounds: u16,\n    pub core_size: u16,\n    pub cycles: u16,\n    pub processes: u16,\n    pub max_warrior_length: u16,\n    pub left_chromosome_size: u16,\n    pub right_chromosome_size: u16,\n    pub left: Individual,\n    pub right: Individual,\n    pub left_pos: u16,\n    pub right_pos: u16,\n}\n```", "```rs\nimpl Config {\n    pub fn new(rdr: &mut Cursor<Vec<u8>>) -> io::Result<Config> {\n        let rounds = (rdr.read_u16::<BigEndian>()? % 1000).max(1);\n        let core_size = (rdr.read_u16::<BigEndian>()? % 24_000).max(256);\n        let cycles = (rdr.read_u16::<BigEndian>()? % 10_000).max(100);\n        let processes = (rdr.read_u16::<BigEndian>()? % 1024).max(2);\n        let max_warrior_length = (rdr.read_u16::<BigEndian>()? % 256).max(4);\n        let left_chromosome_size = (rdr.read_u16::<BigEndian>()? \n                                       % max_warrior_length).max(2);\n        let right_chromosome_size = (rdr.read_u16::<BigEndian>()? \n                                        % max_warrior_length).max(2);\n```", "```rs\n        let left = Config::mk_individual(rdr, \n                                         max_warrior_length,\n                                         left_chromosome_size, \n                                         core_size)?;\n        let right =\n            Config::mk_individual(rdr, \n                                  max_warrior_length, \n                                  right_chromosome_size, \n                                  core_size)?;\n```", "```rs\n    fn mk_individual(\n        rdr: &mut Cursor<Vec<u8>>,\n        max_chromosome_size: u16,\n        chromosome_size: u16,\n        core_size: u16,\n    ) -> io::Result<Individual> {\n        assert!(chromosome_size <= max_chromosome_size);\n        let mut indv = IndividualBuilder::new();\n        for _ in 0..(chromosome_size as usize) {\n            let builder = InstructionBuilder::new(core_size);\n            let a_field = rdr.read_i8()?;\n            let b_field = rdr.read_i8()?;\n            let a_mode = match rdr.read_u8()? % 5 {\n                0 => Mode::Direct,\n                1 => Mode::Immediate,\n                2 => Mode::Indirect,\n                3 => Mode::Decrement,\n                _ => Mode::Increment,\n            };\n            let b_mode = match rdr.read_u8()? % 5 {\n                0 => Mode::Direct,\n                1 => Mode::Immediate,\n                2 => Mode::Indirect,\n                3 => Mode::Decrement,\n                _ => Mode::Increment,\n            };\n```", "```rs\n            let modifier = match rdr.read_u8()? % 7 {\n                0 => Modifier::F,\n                1 => Modifier::A,\n                2 => Modifier::B,\n                3 => Modifier::AB,\n                4 => Modifier::BA,\n                5 => Modifier::X,\n                _ => Modifier::I,\n            };\n```", "```rs\n            let opcode = match rdr.read_u8()? % 16 {\n                0 => OpCode::Dat,   // 0\n                1 => OpCode::Spl,   // 1\n                2 => OpCode::Mov,   // 2\n                3 => OpCode::Djn,   // 3\n                4 => OpCode::Add,   // 4\n                5 => OpCode::Jmz,   // 5\n                6 => OpCode::Sub,   // 6\n                7 => OpCode::Seq,   // 7\n                8 => OpCode::Sne,   // 8\n                9 => OpCode::Slt,   // 9\n                10 => OpCode::Jmn,  // 10\n                11 => OpCode::Jmp,  // 11\n                12 => OpCode::Nop,  // 12\n                13 => OpCode::Mul,  // 13\n                14 => OpCode::Modm, // 14\n                _ => OpCode::Div,   // 15\n            };\n```", "```rs\n            let inst = builder\n                .a_field(a_field)\n                .b_field(b_field)\n                .a_mode(a_mode)\n                .b_mode(b_mode)\n                .modifier(modifier)\n                .opcode(opcode)\n                .freeze();\n            indv = indv.push(inst);\n        }\n        Ok(indv.freeze())\n    }\n```", "```rs\n        let left_pos =\n            Config::adjust_pos(core_size, \n                               rdr.read_u16::<BigEndian>()?, \n                               max_warrior_length);\n        let right_pos =\n            Config::adjust_pos(core_size, \n                               rdr.read_u16::<BigEndian>()?, \n                               max_warrior_length);\n```", "```rs\n    fn adjust_pos(core_size: u16, mut pos: u16, space: u16) -> u16 {\n        pos %= core_size;\n        if (pos + space) > core_size {\n            let past = (pos + space) - core_size;\n            pos - past\n        } else {\n            pos\n        }\n    }\n```", "```rs\n        Ok(Config {\n            rounds,\n            core_size,\n            cycles,\n            processes,\n            max_warrior_length,\n            left_chromosome_size,\n            right_chromosome_size,\n            left,\n            right,\n            left_pos,\n            right_pos,\n        })\n    }\n```", "```rs\nfn main() {\n    let mut input: Vec<u8> = Vec::with_capacity(1024);\n    let result = io::stdin().read_to_end(&mut input);\n    if result.is_err() {\n        return;\n    }\n    let mut rdr = Cursor::new(input);\n    if let Ok(config) = Config::new(&mut rdr) {\n        let mut mars = MarsBuilder::default()\n            .core_size(config.core_size)\n            .cycles(config.cycles)\n            .processes(u32::from(config.processes))\n            .max_warrior_length(config.max_warrior_length as u16)\n            .freeze();\n        mars.compete_inner(\n            &config.left,\n            config.left_pos,\n            &config.right,\n            config.right_pos,\n        );\n    }\n}\n```", "```rs\n[package]\nname = \"feruscore\"\nversion = \"0.2.0\"\nauthors = [\"Brian L. Troutwine <brian@troutwine.us>\"]\n\n[dependencies]\nrand = \"0.4\"\nrand_derive = \"0.3\"\nlibc = \"0.2.0\"\nbyteorder = \"1.0\"\nnum_cpus = \"1.0\"\n\n[build-dependencies]\ncc = \"1.0\"\n\n[dev-dependencies]\nquickcheck = \"0.6\"\ncriterion = \"0.2\"\n\n[[bench]]\nname = \"mars_bench\"\nharness = false\n\n[[bin]]\nname = \"feruscore\"\n\n[[bin]]\nname = \"fuzz_target\"\n```", "```rs\nextern crate feruscore;\nextern crate num_cpus;\nextern crate rand;\n\nuse feruscore::individual::*;\nuse feruscore::mars::*;\nuse rand::{thread_rng, Rng};\nuse std::fs::{self, DirBuilder, File};\nuse std::io::{self, BufWriter};\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::mpsc;\nuse std::{thread, time};\n```", "```rs\n// configuration\nconst POPULATION_SIZE: usize = 1_048_576 / 8; \nconst CHROMOSOME_SIZE: u16 = 100;\nconst CORE_SIZE: u16 = 8000;\nconst GENE_MUTATION_CHANCE: u32 = 100;\nconst ROUNDS: u16 = 100;\n\n// reporting\nstatic GENERATIONS: AtomicUsize = AtomicUsize::new(0);\n```", "```rs\nfn sort_by_tournament(mars: &mut Mars, \n                      mut population: Vec<Individual>) \n    -> Vec<Individual> \n{\n    let mut i = population.len() - 1;\n    while i >= (population.len() / 2) {\n        let left_idx = thread_rng().gen_range(0, i);\n        let mut right_idx = left_idx;\n        while left_idx == right_idx {\n            right_idx = thread_rng().gen_range(0, i);\n        }\n        match mars.compete(ROUNDS, \n                           &population[left_idx], \n                           &population[right_idx]) \n        {\n            Winner::Right(_) => {\n                population.swap(i, right_idx);\n            }\n            Winner::Left(_) => {\n                population.swap(i, left_idx);\n            }\n            Winner::Tie => {}\n        }\n        i -= 1;\n    }\n    population\n}\n```", "```rs\nfn main() {\n    let mut out_recvs = Vec::with_capacity(num_cpus::get());\n    let mut in_sends = Vec::with_capacity(num_cpus::get());\n\n    let total_children = 128;\n\n    let thr_portion = POPULATION_SIZE / num_cpus::get();\n    for _ in 0..num_cpus::get() {\n        let (in_snd, in_rcv) = mpsc::sync_channel(1);\n        let (out_snd, out_rcv) = mpsc::sync_channel(1);\n        let mut population: Vec<Individual> = (0..thr_portion)\n            .into_iter()\n            .map(|_| Individual::new(CHROMOSOME_SIZE))\n            .collect();\n        population.pop();\n        population.pop();\n        population.push(ringers::imp(CORE_SIZE));\n        population.push(ringers::dwarf(CORE_SIZE));\n        let _ = thread::spawn(move || island(in_rcv, \n                                             out_snd, \n                                             total_children));\n        in_snd.send(population).unwrap();\n        in_sends.push(in_snd);\n        out_recvs.push(out_rcv);\n    }\n```", "```rs\n    let _ = thread::spawn(report);\n```", "```rs\n    let mut mars = MarsBuilder::default().core_size(CORE_SIZE).freeze();\n    let mut global_population: Vec<Individual> = \n        Vec::with_capacity(POPULATION_SIZE);\n    loop {\n        for out_rcv in &mut out_recvs {\n            let mut pop = out_rcv.recv().unwrap();\n            global_population.append(&mut pop);\n        }\n```", "```rs\n        assert_eq!(global_population.len(), POPULATION_SIZE);\n        thread_rng().shuffle(&mut global_population);\n```", "```rs\n        let generation = GENERATIONS.fetch_add(1, Ordering::Relaxed);\n        if generation % 100 == 0 {\n            global_population = sort_by_tournament(&mut mars, \n                                                   global_population);\n            checkpoint(generation, &global_population)\n                .expect(\"could not checkpoint\");\n        }\n```", "```rs\n        let split_idx = global_population.len() / num_cpus::get();\n\n        for in_snd in &mut in_sends {\n            let idx = global_population.len() - split_idx;\n            let pop = global_population.split_off(idx);\n            in_snd.send(pop).unwrap();\n        }\n    }\n}\n```", "```rs\nfn island(\n    recv: mpsc::Receiver<Vec<Individual>>,\n    snd: mpsc::SyncSender<Vec<Individual>>,\n    total_children: usize,\n) -> () {\n    let mut mars = MarsBuilder::default().core_size(CORE_SIZE).freeze();\n\n    while let Ok(mut population) = recv.recv() {\n```", "```rs\n        // tournament, fitness and selection of parents\n        population = sort_by_tournament(&mut mars, population);\n```", "```rs\n        // reproduce\n        let mut child_idx = 0;\n        let mut parent_idx = population.len() - 1;\n        while child_idx < total_children {\n            let left_idx = parent_idx;\n            let right_idx = parent_idx - 1;\n            parent_idx -= 2;\n\n            population[child_idx] = population[left_idx]\n                                    .reproduce(&population[right_idx]);\n            child_idx += 1;\n            population[child_idx] = population[left_idx]\n                                    .reproduce(&population[right_idx]);\n            child_idx += 1;\n        }\n```", "```rs\n        for i in 0..32 {\n            population[child_idx + i] = Individual::new(CHROMOSOME_SIZE)\n        }\n```", "```rs\n        // mutation\n        for indv in population.iter_mut() {\n            indv.mutate(GENE_MUTATION_CHANCE);\n        }\n```", "```rs\n        snd.send(population).expect(\"could not send\");\n    }\n}\n```", "```rs\nGENERATION(5459):\n    RUNTIME (sec):  31248\n    BATTLES:        41181\n       BATTLES/s:   14340\n    FITNESS:\n        00...10:    151\n        11...20:    2\n        21...30:    0\n        31...40:    1\n        41...50:    0\n        51...60:    0\n        61...60:    2\n        71...70:    1\n        81...80:    0\n        91...100:   41024\n```", "```rs\n[package]\nname = \"sniffer\"\nversion = \"0.2.0\"\nauthors = [\"Brian L. Troutwine <brian@troutwine.us>\"]\n\n[dependencies]\npnet = \"0.21\"\nrlua = \"0.13\"\n\n[[bin]]\nname = \"sniffer\"\n```", "```rs\nextern crate pnet;\nextern crate rlua;\n\nuse pnet::datalink::Channel::Ethernet;\nuse pnet::datalink::{self, DataLinkReceiver, MacAddr, \n                     NetworkInterface};\nuse pnet::packet::ethernet::{EtherType, EthernetPacket};\nuse rlua::{prelude, Function, Lua};\nuse std::fs::File;\nuse std::io::{prelude::*, BufReader};\nuse std::path::Path;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::mpsc;\nuse std::{env, thread};\n```", "```rs\nstatic SKIPPED_PACKETS: AtomicUsize = AtomicUsize::new(0);\n\n#[derive(Debug)]\nenum Payload {\n    Packet {\n        source: MacAddr,\n        destination: MacAddr,\n        kind: EtherType,\n    },\n    Pulse(u64),\n}\n```", "```rs\nfn watch_interface(mut rx: Box<DataLinkReceiver>, snd: mpsc::SyncSender<Payload>) {\n    loop {\n        match rx.next() {\n            Ok(packet) => {\n                let packet = EthernetPacket::new(packet).unwrap();\n\n                let payload: Payload = Payload::Packet {\n                    source: packet.get_source(),\n                    destination: packet.get_destination(),\n                    kind: packet.get_ethertype(),\n                };\n                if snd.try_send(payload).is_err() {\n                    SKIPPED_PACKETS.fetch_add(1, Ordering::Relaxed);\n                }\n            }\n            Err(e) => {\n                panic!(\"An error occurred while reading: {}\", e);\n            }\n        }\n    }\n}\n```", "```rs\nfn timer(snd: mpsc::SyncSender<Payload>) -> () {\n    use std::{thread, time};\n    let one_second = time::Duration::from_millis(1000);\n\n    let mut pulses = 0;\n    loop {\n        thread::sleep(one_second);\n        snd.send(Payload::Pulse(pulses)).unwrap();\n        pulses += 1;\n    }\n}\n```", "```rs\nfn main() {\n    let interface_name = env::args().nth(1).unwrap();\n    let pulse_fn_file_arg = env::args().nth(2).unwrap();\n    let pulse_fn_file = Path::new(&pulse_fn_file_arg);\n    assert!(pulse_fn_file.exists());\n    let interface_names_match = |iface: &NetworkInterface| {\n        iface.name == interface_name\n    };\n\n    // Find the network interface with the provided name\n    let interfaces = datalink::interfaces();\n    let interface = interfaces\n        .into_iter()\n        .filter(interface_names_match)\n        .next()\n        .unwrap();\n```", "```rs\n    let lua = Lua::new();\n    let pulse_fn = eval(&lua, pulse_fn_file, Some(\"pulse\")).unwrap();\n```", "```rs\nfn eval<'a>(lua: &'a Lua, path: &Path, name: Option<&str>) \n    -> prelude::LuaResult<Function<'a>> \n{\n    let f = File::open(path).unwrap();\n    let mut reader = BufReader::new(f);\n\n    let mut buf = Vec::new();\n    reader.read_to_end(&mut buf).unwrap();\n    let s = ::std::str::from_utf8(&buf).unwrap();\n\n    lua.eval(s, name)\n}\n```", "```rs\n    let (snd, rcv) = mpsc::sync_channel(100);\n\n    let timer_snd = snd.clone();\n    let _ = thread::spawn(move || timer(timer_snd));\n\n    let _iface_handler = match datalink::channel(&interface, \n                                                 Default::default()) \n    {\n        Ok(Ethernet(_tx, rx)) => {\n            let snd = snd.clone();\n            thread::spawn(|| watch_interface(rx, snd))\n        }\n        Ok(_) => panic!(\"Unhandled channel type\"),\n        Err(e) => panic!(\n            \"An error occurred when creating the datalink channel: {}\",\n            e\n        ),\n    };\n```", "```rs\n    let destinations = lua.create_table().unwrap();\n    let sources = lua.create_table().unwrap();\n    let kinds = lua.create_table().unwrap();\n```", "```rs\n    while let Ok(payload) = rcv.recv() {\n        match payload {\n            Payload::Packet {\n                source,\n                destination,\n                kind,\n            } => {\n                let d_cnt = destinations\n                                .get(destination.to_string())\n                                .unwrap_or(0);\n                destinations\n                    .set(destination.to_string(), d_cnt + 1)\n                    .unwrap();\n\n                let s_cnt = sources.get(source.to_string()).unwrap_or(0);\n                sources.set(source.to_string(), s_cnt + 1).unwrap();\n\n                let k_cnt = kinds.get(kind.to_string()).unwrap_or(0);\n                kinds.set(kind.to_string(), k_cnt + 1).unwrap();\n            }\n```", "```rs\n            Payload::Pulse(id) => {\n                let skipped_packets = SKIPPED_PACKETS\n                                      .swap(0, Ordering::Relaxed);\n                pulse_fn\n                    .call::<_, ()>((\n                        id,\n                        skipped_packets,\n                        destinations.clone(),\n                        sources.clone(),\n                        kinds.clone(),\n                    ))\n                    .unwrap()\n            }\n        }\n    }\n}\n```", "```rs\nfunction (id, skipped_packets, dest_tbl, src_tbl, kind_tbl)\n   print(\"ID: \", id)\n   print(\"SKIPPED PACKETS: \", skipped_packets)\n   print(\"DESTINATIONS:\")\n   for k,v in pairs(dest_tbl) do\n      print(k, v)\n   end\n   print(\"SOURCES:\")\n   for k,v in pairs(src_tbl) do\n      print(k, v)\n   end\n   print(\"KINDS:\")\n   for k,v in pairs(kind_tbl) do\n      print(k, v)\n   end\nend\n```", "```rs\n> ./target/release/sniffer en0 examples/pulse.lua\nID:     0\nSKIPPED PACKETS:    0\nDESTINATIONS:\n5c:f9:38:8b:4a:b6   11\n8c:59:73:1d:c8:73   16\nSOURCES:\n5c:f9:38:8b:4a:b6   16\n8c:59:73:1d:c8:73   11\nKINDS:\nIpv4    27\nID:     1\nSKIPPED PACKETS:    0\nDESTINATIONS:\n5c:f9:38:8b:4a:b6   14\n8c:59:73:1d:c8:73   20\nSOURCES:\n5c:f9:38:8b:4a:b6   20\n8c:59:73:1d:c8:73   14\nKINDS:\nIpv4    34\n```", "```rs\n[package]\nname = \"embed_quantiles\"\nversion = \"0.1.0\"\nauthors = [\"Brian L. Troutwine <brian@troutwine.us>\"]\n\n[dependencies]\nquantiles = \"0.7\"\n\n[lib]\nname = \"embed_quantiles\"\ncrate-type = [\"staticlib\"]\n```", "```rs\nextern crate quantiles;\n\nuse quantiles::ckms::CKMS;\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn alloc_ckms(error: f64) -> *mut CKMS<f32> {\n    let ckms = Box::new(CKMS::new(error));\n    Box::into_raw(ckms)\n}\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn free_ckms(ckms: *mut CKMS<f32>) -> () {\n    unsafe {\n        let ckms = Box::from_raw(ckms);\n        drop(ckms);\n    }\n}\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn ckms_insert(ckms: &mut CKMS<f32>, value: f32) -> () {\n    ckms.insert(value)\n}\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn query(ckms: &mut CKMS<f32>, q: f64, \n                        quant: *mut f32) \n    -> i8 \n{\n    unsafe {\n        if let Some((_, res)) = ckms.query(q) {\n            *quant = res;\n            0\n        } else {\n            -1\n        }\n    }\n}\n```", "```rs\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n```", "```rs\nstruct ckms;\n\nstruct ckms* alloc_ckms(double error);\nvoid free_ckms(struct ckms* ckms);\nvoid ckms_insert(struct ckms* ckms, float value);\nint8_t query(struct ckms* ckms, double q, float* quant);\n```", "```rs\nint main(void) {\n  srand(time(NULL));\n\n  struct ckms* ckms = alloc_ckms(0.001);\n\n  for (int i=1; i <= 1000000; i++) {\n    ckms_insert(ckms, (float)rand()/(float)(RAND_MAX/10000));\n  }\n\n  float quant = 0.0;\n  if (query(ckms, 0.75, &quant) < 0) {\n    printf(\"ERROR IN QUERY\");\n    return 1;\n  }\n  printf(\"75th percentile: %f\\n\", quant);\n\n  free_ckms(ckms);\n  return 0;\n}\n```", "```rs\nCC ?= $(shell which cc)\nCARGO ?= $(shell which cargo)\nOS := $(shell uname)\n\nrun: clean build\n        ./target/release/embed_quantiles\n\nclean:\n        $(CARGO) clean\n        rm -f ./target/release/embed_quantiles\n\nbuild:\n        $(CARGO) build --release\nifeq ($(OS),Darwin) # Assumption: CC == Clang\n        $(CC) -std=c11 -Wall -Werror -Wpedantic -O3 c_src/main.c \\\n                -L target/release/ -l embed_quantiles \\\n                -o target/release/embed_quantiles\nelse # Assumption: CC == GCC\n        $(CC) -std=c11 -Wall -Werror -Wpedantic -O3 c_src/main.c \\\n                -L target/release/ -lpthread -Wl,–no-as-needed -ldl \\\n                -lm -lembed_quantiles \\\n                -o target/release/embed_quantiles\nendif\n\n.PHONY: clean run\n```", "```rs\n> make run\n/home/blt/.cargo/bin/cargo clean\nrm -f ./target/release/embed_quantiles\n/home/blt/.cargo/bin/cargo build --release\n   Compiling quantiles v0.7.1\n   Compiling embed_quantiles v0.1.0\n    Finished release [optimized] target(s) in 0.91 secs\ncc -std=c11 -Wall -Werror -Wpedantic -O3 c_src/main.c \\\n        -L target/release/ -lpthread -Wl,–no-as-needed -ldl \\\n        -lm -lembed_quantiles \\\n        -o target/release/embed_quantiles\n./target/release/embed_quantiles\n75th percentile: 7499.636230\n```", "```rs\n[package]\nname = \"zero_count\"\nversion = \"0.1.0\"\nauthors = [\"Brian L. Troutwine <brian@troutwine.us>\"]\n\n[dependencies]\n\n[lib]\nname = \"zero_count\"\ncrate-type = [\"dylib\"]\n```", "```rs\n#[no_mangle]\npub extern \"C\" fn tail_zero_count(arr: *const u16, len: usize) -> u64 {\n    let mut zeros: u64 = 0;\n    unsafe {\n        for i in 0..len {\n            zeros += (*arr.offset(i as isize)).trailing_zeros() as u64\n        }\n    }\n    zeros\n}\n```", "```rs\nimport ctypes\nimport random\n\nlength = 1000000\nlzc = ctypes.cdll.LoadLibrary(\"target/release/libzero_count.dylib\")\narr = (ctypes.c_uint16 * length)(*[random.randint(0, 65000) for _ in range(0, length)])\nprint(lzc.tail_zero_count(ctypes.pointer(arr), length))\n```", "```rs\n> python zero_count.py\n1000457\n>  python zero_count.py\n999401\n> python zero_count.py\n1002295\n```", "```rs\ndefmodule Beamcoin.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :beamcoin,\n     version: \"0.1.0\",\n     elixir: \"~> 1.5\",\n     start_permanent: Mix.env == :prod,\n     compilers: [:rustler] ++ Mix.compilers(),\n     deps: deps(),\n     rustler_crates: rustler_crates()]\n  end\n\n  def application do\n    [extra_applications: [:logger]]\n  end\n\n  defp deps do\n    [{:rustler, github: \"hansihe/rustler\", sparse: \"rustler_mix\"}]\n  end\n\n  defp rustler_crates do\n    [beamcoin: [\n      path: \"native/beamcoin\",\n      mode: mode(Mix.env)\n    ]]\n  end\n\n  defp mode(:prod), do: :release\n  defp mode(_), do: :debug\nend\n```", "```rs\n  defp rustler_crates do\n    [beamcoin: [\n      path: \"native/beamcoin\",\n      mode: mode(Mix.env)\n    ]]\n  end\n```", "```rs\n[package]\nname = \"beamcoin\"\nversion = \"0.1.0\"\nauthors = []\n\n[lib]\nname = \"beamcoin\"\npath = \"src/lib.rs\"\ncrate-type = [\"dylib\"]\n\n[dependencies]\nrustler = { git = \"https://github.com/hansihe/rustler\", branch = \"master\" }\nrustler_codegen = { git = \"https://github.com/hansihe/rustler\", branch = \"master\" }\nlazy_static = \"0.2\"\nnum_cpus = \"1.0\"\nscoped-pool = \"1.0.0\"\nsha2 = \"0.7\"\n```", "```rs\n#[macro_use]\nextern crate lazy_static;\nextern crate num_cpus;\nextern crate scoped_pool;\nextern crate sha2;\n#[macro_use]\nextern crate rustler;\n\nuse rustler::{thread, Encoder, Env, Error, Term};\nuse scoped_pool::Pool;\nuse sha2::Digest;\nuse std::mem;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::{mpsc, Arc};\n```", "```rs\nconst DIFFICULTY: usize = 6;\n```", "```rs\nlazy_static! {\n    static ref POOL: Pool = Pool::new(num_cpus::get());\n}\n```", "```rs\nrustler_atoms! {\n    atom ok;\n    atom error;\n}\n\nrustler_export_nifs! {\n    \"Elixir.Beamcoin\",\n    [(\"native_mine\", 0, mine)],\n    None\n}\n```", "```rs\n#[derive(Debug)]\nstruct Solution(u64, String);\n\nfn mine<'a>(caller: Env<'a>, _args: &[Term<'a>]) \n    -> Result<Term<'a>, Error> \n{\n    thread::spawn::<thread::ThreadSpawner, _>(caller, move |env| {\n        let is_solved = Arc::new(AtomicBool::new(false));\n        let (sender, receiver) = mpsc::channel();\n\n        for i in 0..num_cpus::get() {\n            let sender_n = sender.clone();\n            let is_solved = is_solved.clone();\n\n            POOL.spawn(move || {\n                search_for_solution(i as u64, num_cpus::get() as u64, \n                                    sender_n, is_solved);\n            });\n        }\n\n        match receiver.recv() {\n            Ok(Solution(i, hash)) => (atoms::ok(), i, hash).encode(env),\n            Err(_) => (\n                atoms::error(),\n                \"Worker threads disconnected before the \\\n                 solution was found\".to_owned(),\n            ).encode(env),\n        }\n    });\n\n    Ok(atoms::ok().encode(caller))\n}\n```", "```rs\nfn search_for_solution(\n    mut number: u64,\n    step: u64,\n    sender: mpsc::Sender<Solution>,\n    is_solved: Arc<AtomicBool>,\n) -> () {\n    let id = number;\n    while !is_solved.load(Ordering::Relaxed) {\n        if let Some(solution) = verify_number(number) {\n            if let Ok(_) = sender.send(solution) {\n                is_solved.store(true, Ordering::Relaxed);\n                break;\n            } else {\n                println!(\"Worker {} has shut down without \\\n                         finding a solution.\", id);\n            }\n        }\n        number += step;\n    }\n}\n```", "```rs\nfn verify_number(number: u64) -> Option<Solution> {\n    let number_bytes: [u8; 8] = unsafe { \n        mem::transmute::<u64, [u8; 8]>(number) \n    };\n    let hash = sha2::Sha256::digest(&number_bytes);\n\n    let top_idx = hash.len() - 1;\n    // Hex chars are 16 bits, we have 8 bits. /2 is conversion.\n    let trailing_zero_bytes = DIFFICULTY / 2;\n\n    let mut jackpot = true;\n    for i in 0..trailing_zero_bytes {\n        jackpot &= hash[top_idx - i] == 0;\n    }\n\n    if jackpot {\n        Some(Solution(number, format!(\"{:X}\", hash)))\n    } else {\n        None\n    }\n}\n```", "```rs\ndefmodule Beamcoin do\n  use Rustler, otp_app: :beamcoin\n\n  require Logger\n\n  def mine do\n    :ok = native_mine()\n\n    start = System.system_time(:seconds)\n    receive do\n      {:ok, number, hash} ->\n        done = System.system_time(:seconds)\n        total = done - start\n        Logger.info(\"Solution found in #{total} seconds\")\n        Logger.info(\"The number is: #{number}\")\n        Logger.info(\"The hash is: #{hash}\")\n      {:error, reason} ->\n        Logger.error(inspect reason)\n    end\n  end\n\n  def native_mine, do: :erlang.nif_error(:nif_not_loaded)\nend\n```", "```rs\n> MIX_ENV=prod iex -S mix\nErlang/OTP 20 [erts-9.3] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nCompiling NIF crate :beamcoin (native/beamcoin)...\n    Finished release [optimized] target(s) in 0.70 secs\nInteractive Elixir (1.6.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)>\n```", "```rs\niex(1)> Beamcoin.mine\n\n23:30:45.243 [info]  Solution found in 3 seconds\n\n23:30:45.243 [info]  The number is: 10097471\n\n23:30:45.243 [info]  The hash is: 2354BB63E90673A357F53EBC96141D5E95FD26B3058AFAD7B1F7BACC9D000000\n:ok\n```"]