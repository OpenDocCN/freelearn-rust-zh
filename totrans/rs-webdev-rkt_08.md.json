["```rs\n    #[get(\"/users/<_uuid>\", format = \"text/html\")]\n    pub async fn get_user(mut _db: Connection<DBConnection>, _uuid: &str) -> HtmlResponse {\n        todo!(\"will implement later\")\n    }\n    ```", "```rs\n    const USER_HTML_PREFIX: &str = r#\"<!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n    <meta charset=\"utf-8\" />\n    <title>Our Application User</title>\n    </head>\n    <body>\"#;\n    const USER_HTML_SUFFIX: &str = r#\"</body>\n    </html>\"#;\n    ```", "```rs\n    use rocket_db_pools::sqlx::{FromRow, PgConnection};\n    use std::error::Error;\n    ```", "```rs\n    impl User{}\n    ```", "```rs\n    pub async fn find(connection: &mut PgConnection, uuid: &str) -> Result<Self, Box<dyn Error>> {\n        let parsed_uuid = Uuid::parse_str(uuid)?;\n        let query_str = \"SELECT * FROM users WHERE uuid = \n        $1\";\n        Ok(sqlx::query_as::<_, Self>(query_str)\n            .bind(parsed_uuid)\n            .fetch_one(connection)\n            .await?)\n    }\n    ```", "```rs\npub async fn find(db: &mut Connection<DBConnection>, uuid: &str) -> ... {\n    ...\n        .fetch_one(&mut *db)\n        .await?)\n}\n```", "```rs\n    #[derive(Debug, sqlx::Type)]\n    #[sqlx(transparent)]\n    pub struct OurDateTime(DateTime<Utc>);\n    ```", "```rs\n    pub fn to_html_string(&self) -> String {\n        format!(\n            r#\"<div><span class=\"label\">UUID: \n            </span>{uuid}</div>\n    <div><span class=\"label\">Username: </span>{username}</div>\n    <div><span class=\"label\">Email: </span>{email}</div>\n    <div><span class=\"label\">Description: </span>{description}</div>\n    <div><span class=\"label\">Status: </span>{status}</div>\n    <div><span class=\"label\">Created At: </span>{created_at}</div>\n    <div><span class=\"label\">Updated At: </span>{updated_at}</div>\"#,\n            uuid = self.uuid,\n            username = self.username,\n            email = self.email,\n            description = self.description.as_ref().\n            unwrap_or(&String::from(\"\")),\n            status = self.status.to_string(),\n            created_at = self.created_at.0.to_rfc3339(),\n            updated_at = self.updated_at.0.to_rfc3339(),\n        )\n    }\n    ```", "```rs\n    pub struct OurDateTime(pub DateTime<Utc>);\n    ```", "```rs\n    use std::fmt;\n    ...\n    impl fmt::Display for UserStatus {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> \n        fmt::Result {\n            match *self {\n                UserStatus::Inactive => write!(f, \n               \"Inactive\"),\n                UserStatus::Active => write!(f, \"Active\"),\n            }\n        }\n    }\n    ```", "```rs\n    use rocket::http::Status;\n    use rocket::response::content::RawHtml;\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    #[get(\"/users/<uuid>\", format = \"text/html\")]\n    pub async fn get_user(mut db: Connection<DBConnection>, uuid: &str) -> HtmlResponse {\n        let connection = db\n            .acquire()\n            .await\n            .map_err(|_| Status::InternalServerError)?;\n    }\n    ```", "```rs\n    ...\n        let user = User::find(connection, uuid)\n            .await\n            .map_err(|_| Status::NotFound)?;\n    ```", "```rs\n    ...\n        let mut html_string = String::from(USER_HTML_PREFIX);\n        html_string.push_str(&user.to_html_string());\n        html_string.push_str(format!(r#\"<a href=\"\n        /users/edit/{}\">Edit User</a>\"#, \n        user.uuid).as_ref());\n        html_string.push_str(r#\"<a href=\"/users\">User \n        List</a>\"#);\n        html_string.push_str(USER_HTML_SUFFIX);\n        Ok(RawHtml(html_string))\n    ```", "```rs\n#[get(\"/users?<_pagination>\", format = \"text/html\")]\n```", "```rs\npub async fn get_users(\n```", "```rs\n    mut _db: Connection<DBConnection>,\n```", "```rs\n    _pagination: Option<Pagination>,\n```", "```rs\n) -> HtmlResponse {\n```", "```rs\n    todo!(\"will implement later\")\n```", "```rs\n}\n```", "```rs\n    use super::pagination::{Pagination};\n    use crate::fairings::db::DBConnection;\n    use rocket_db_pools::Connection;\n    use rocket_db_pools::sqlx::{Acquire, FromRow, PgConnection};\n    ...\n    impl User {\n    ...\n        pub async fn find_all(\n            db: &mut Connection<DBConnection>,\n            pagination: Option<Pagination>,\n    ) -> Result<(Vec<Self>, Option<Pagination>), \n        Box<dyn Error>> {\n            if pagination.is_some() {\n    return Self::find_all_with_pagination(db, \n                &(pagination.unwrap())).await;\n            } else {\n                return Self::find_all_without_\n                pagination(db).await;\n            }\n        }\n    }\n    ```", "```rs\n    pub const DEFAULT_LIMIT: usize = 10;\n    ```", "```rs\n    use super::pagination::{Pagination, DEFAULT_LIMIT};\n    ...\n    async fn find_all_without_pagination(db: &mut Connection<DBConnection>) -> Result<(Vec<Self>, Option<Pagination>), Box<dyn Error>> {\n        let query_str = \"SELECT * FROM users ORDER BY \n        created_at DESC LIMIT $1\";\n        let connection = db.acquire().await?;\n        let users = sqlx::query_as::<_, Self>(query_str)\n            .bind(DEFAULT_LIMIT as i32)\n            .fetch_all(connection)\n            .await?;\n    }\n    ```", "```rs\n{\n    ...\n    let mut new_pagination: Option<Pagination> = None;\n    if users.len() == DEFAULT_LIMIT {\n        let query_str = \"SELECT EXISTS(SELECT 1 FROM \n        users WHERE created_at < $1 ORDER BY \n        created_at DESC LIMIT 1)\";\n        let connection = db.acquire().await?;\n        let exists = sqlx::query_as::<_,\n        BoolWrapper>(query_str)\n            .bind(&users.last().unwrap().created_at)\n            .fetch_one(connection)\n            .await?;\n        if exists.0 {\n            new_pagination = Some(Pagination {\n                next: users.last().unwrap().\n                created_at.to_owned(),\n                limit: DEFAULT_LIMIT,\n            });\n        }\n    }\n    Ok((users, new_pagination))\n}\n```", "```rs\n    use rocket_db_pools::sqlx::FromRow;\n    #[derive(FromRow)]\n    pub struct BoolWrapper(pub bool);\n    ```", "```rs\n    async fn find_all_with_pagination(db: &mut Connection<DBConnection>, pagination: &Pagination) -> Result<(Vec<Self>, Option<Pagination>), Box<dyn Error>> {\n        let query_str =\n            \"SELECT * FROM users WHERE created_at < $1 \n             ORDER BY created_at DESC LIMIT \n    2\";\n        let connection = db.acquire().await?;\n        let users = sqlx::query_as::<_, Self>(query_str)\n            .bind(&pagination.next)\n            .bind(DEFAULT_LIMIT as i32)\n            .fetch_all(connection)\n            .await?;\n        let mut new_pagination: Option<Pagination> = None;\n        if users.len() == DEFAULT_LIMIT {\n            let query_str = \"SELECT EXISTS(SELECT 1 FROM \n            users WHERE created_at < $1 ORDER BY \n            created_at DESC LIMIT 1)\";\n            let connection = db.acquire().await?;\n            let exists = sqlx::query_as::<_, \n            BoolWrapper>(query_str)\n                .bind(&users.last().unwrap().created_at)\n                .fetch_one(connection)\n                .await?;\n            if exists.0 {\n                new_pagination = Some(Pagination {\n                    next: users.last().unwrap().\n                    created_at.to_owned(),\n                    limit: DEFAULT_LIMIT,\n                });\n            }\n        }\n        Ok((users, new_pagination))\n    }\n    ```", "```rs\n    #[get(\"/users?<pagination>\", format = \"text/html\")]\n    pub async fn get_users(mut db: Connection<DBConnection>,\n        pagination: Option<Pagination>) -> HtmlResponse {\n        let (users, new_pagination) = User::find_all(&mut \n        db, pagination)\n            .await\n            .map_err(|_| Status::NotFound)?;\n    }\n    ```", "```rs\n    ...\n    let mut html_string = String::from(USER_HTML_PREFIX);\n    for user in users.iter() {\n        html_string.push_str(&user.to_html_string());\n        html_string\n            .push_str(format!(r#\"<a href=\"/users/{}\">See \n             User</a><br/>\"#, user.uuid).as_ref());\n        html_string.push_str(\n            format!(r#\"<a href=\"/users/edit/{}\">Edit \n            User</a><br/>\"#, user.uuid).as_ref(),\n        );\n    }\n    ```", "```rs\n    if let Some(pg) = new_pagination {\n        html_string.push_str(\n            format!(\n                r#\"<a href=\"/users?pagination.next={}&\n                pagination.limit={}\">Next</a><br/>\"#,\n                &(pg.next.0).timestamp_nanos(),\n                &pg.limit,\n            )\n            .as_ref(),\n        );\n    }\n    ```", "```rs\n    html_string.push_str(r#\"<a href=\"/users/new\">New user</a>\"#);\n    html_string.push_str(USER_HTML_SUFFIX);\n    Ok(RawHtml(html_string))\n    ```", "```rs\n    use chrono::{offset::Utc, DateTime, TimeZone};\n    use rocket::data::ToByteUnit;\n    ```", "```rs\n    #[derive(Debug, sqlx::Type, Clone)]\n    ```", "```rs\n     impl<'r> FromFormField<'r> for OurDateTime {\n        fn from_value(field: ValueField<'r>) -> form::\n        Result<'r, Self> {\n            let timestamp = field.value.parse::<i64>()?;\n            Ok(OurDateTime(\n            Utc.timestamp_nanos(timestamp)))\n        }\n        ...\n    }\n    ```", "```rs\n    async fn from_data(field: DataField<'r, '_>) -> form::Result<'r, Self> {\n        let limit = field\n            .request\n            .limits()\n            .get(\"form\")\n            .unwrap_or_else(|| 8.kibibytes());\n        ...\n    }\n    ```", "```rs\n    let bytes = field.data.open(limit).into_bytes().await?;\n    if !bytes.is_complete() {\n        return Err((None, Some(limit)).into());\n    }\n    let bytes = bytes.into_inner();\n    ```", "```rs\n    let time_string = std::str::from_utf8(&bytes)?;\n    let timestamp = time_string.parse::<i64>()?;\n    Ok(OurDateTime(Utc.timestamp_nanos(timestamp)))\n    ```", "```rs\n    #[get(\"/users/new\", format = \"text/html\")]\n    pub async fn new_user() -> HtmlResponse {\n        let mut html_string = String::from(USER_HTML_\n        PREFIX);\n        html_string.push_str(\n            r#\"<form accept-charset=\"UTF-8\" action=\"/\n            users\" autocomplete=\"off\" method=\"POST\">\n        <div>\n            <label for=\"username\">Username:</label>\n            <input name=\"username\" type=\"text\"/>\n        </div>\n        <div>\n            <label for=\"email\">Email:</label>\n            <input name=\"email\" type=\"email\"/>\n        </div>\n        <div>\n            <label for=\"password\">Password:</label>\n            <input name=\"password\" type=\"password\"/>\n        </div>\n        <div>\n            <label for=\"password_confirmation\">Password \n            Confirmation:</label>\n            <input name=\"password_confirmation\" \n            type=\"password\"/>\n        </div>\n        <div>\n            <label for=\"description\">Tell us a little bit \n            more about yourself:</label>\n            <textarea name=\"description\"></textarea>\n        </div>\n        <button type=\"submit\" value=\"Submit\">Submit</\n         button>\n    </form>\"#,\n        );\n        html_string.push_str(USER_HTML_SUFFIX);\n        Ok(RawHtml(html_string))\n    }\n    ```", "```rs\n    #[derive(Debug, FromForm)]\n    pub struct NewUser<'r> {\n        #[field(validate = len(5..20).or_else(msg!(\"name \n        cannot be empty\")))]\n        pub username: &'r str,\n        pub email: &'r str,\n        pub password: &'r str,\n        #[field(validate = eq(self.password).or_\n        else(msg!(\"password confirmation mismatch\")))]\n        pub password_confirmation: &'r str,\n        #[field(default = \"\")]\n        pub description: Option<&'r str>,\n    }\n    ```", "```rs\n#[field(name = uncased(\"html-field-name\"))]\n```", "```rs\n#[field(name = \"some-other-name\")]\n```", "```rs\n#[field(default = \"default value\")]\n```", "```rs\n#[field(validate = validation_function())]\n```", "```rs\n#[field(validate = len(5..20).or_else(msg!(\"name cannot be empty\")))]\n```", "```rs\n    use rocket::form::{self, Error as FormError, FromForm};\n    use zxcvbn::zxcvbn;\n    ...\n    fn validate_password(password: &str) -> form::Result<'_, ()> {\n        let entropy = zxcvbn(password, &[]);\n        if entropy.is_err() || entropy.unwrap().score()\n        < 3 {\n            return Err(FormError::validation(\"weak \n            password\").into());\n        }\n        Ok(())\n    }\n    ```", "```rs\n    use regex::Regex;\n    ...\n    fn validate_email(email: &str) -> form::Result<'_, ()> {\n        const EMAIL_REGEX: &str = r#\"(?:[a-z0-9!#$%&\n        '*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]\n        +)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\\n        x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\\n        x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[\n        a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-\n        z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][\n        0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][\n        0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\n        \\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01\n        -\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])\"#;\n        let email_regex = Regex::new(EMAIL_REGEX).\n        unwrap();\n        if !email_regex.is_match(email) {\n            return Err(FormError::validation(\"invalid \n            email\").into());\n        }\n        Ok(())\n    }\n    ```", "```rs\n    pub struct NewUser<'r> {\n        ...\n        #[field(validate = validate_email().\n        or_else(msg!(\"invalid email\")))]\n        pub email: &'r str,\n        #[field(validate = validate_password()\n        .or_else(msg!(\"weak password\")))]\n        pub password: &'r str,\n        ...\n    }\n    ```", "```rs\nammonia = \"3.1.2\"\nargon2 = \"0.3\"\nrand_core = {version = \"0.6\", features = [\"std\"]}\n```", "```rs\n    use ammonia::Builder;\n    use std::collections::hash_set::HashSet;\n    pub fn clean_html(src: &str) -> String {\n        Builder::default()\n            .tags(HashSet::new())\n            .clean(src)\n            .to_string()\n    }\n    ```", "```rs\n    use super::clean_html;\n    use argon2::{password_hash::{rand_core::OsRng, PasswordHasher, SaltString},Argon2};\n    ```", "```rs\n    pub async fn create<'r>(\n        connection: &mut PgConnection,\n        new_user: &'r NewUser<'r>,\n    ) -> Result<Self, Box<dyn Error>> {\n        let uuid = Uuid::new_v4();\n        let username = &(clean_html(new_user.username));\n        let description = &(new_user.description.map(\n        |desc| clean_html(desc)));\n    }\n    ```", "```rs\n    let salt = SaltString::generate(&mut OsRng);\n    let argon2 = Argon2::default();\n    let password_hash = argon2.hash_password(new_user.password.as_bytes(), &salt);\n    if password_hash.is_err() {\n        return Err(\"cannot create password hash\".into());\n    }\n    ```", "```rs\n    let query_str = r#\"INSERT INTO users\n    (uuid, username, email, password_hash, description, status)\n    VALUES\n    ($1, $2, $3, $4, $5, $6)\n    RETURNING *\"#;\n    Ok(sqlx::query_as::<_, Self>(query_str)\n        .bind(uuid)\n        .bind(username)\n        .bind(new_user.email)\n        .bind(password_hash.unwrap().to_string())\n        .bind(description)\n        .bind(UserStatus::Inactive)\n        .fetch_one(connection)\n        .await?)\n    ```", "```rs\nuse crate::models::{pagination::Pagination, user::{NewUser, User}};\nuse rocket::form::{Contextual, Form};\nuse rocket::request::FlashMessage;\nuse rocket::response::{content::RawHtml, Flash, Redirect};\n```", "```rs\n    #[post(\"/users\", format = \"application/x-www-form-urlencoded\", data = \"<user_context>\")]\n    pub async fn create_user<'r>(\n        mut db: Connection<DBConnection>,\n        user_context: Form<Contextual<'r, NewUser<'r>>>,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {}\n    ```", "```rs\n    if user_context.value.is_none() {\n        let error_message = format!(\n            \"<div>{}</div>\",\n            user_context\n                .context\n                .errors()\n                .map(|e| e.to_string())\n                .collect::<Vec<_>>()\n                .join(\"<br/>\")\n        );\n        return Err(Flash::error(Redirect::to(\"/\n        users/new\"), error_message));\n    }\n    ```", "```rs\n    let new_user = user_context.value.as_ref().unwrap();\n    let connection = db.acquire().await.map_err(|_| {\n        Flash::error(\n            Redirect::to(\"/users/new\"),\n            \"<div>Something went wrong when creating \n             user</div>\",\n        )\n    })?;\n    let user = User::create(connection, new_user).await.map_err(|_| {\n        Flash::error(\n            Redirect::to(\"/users/new\"),\n            \"<div>Something went wrong when creating \n            user</div>\",\n        )\n    })?;\n    Ok(Flash::success(\n        Redirect::to(format!(\"/users/{}\", user.uuid)),\n        \"<div>Successfully created user</div>\",\n    ))\n    ```", "```rs\n    get_user(\n        mut db: Connection<DBConnection>,\n        uuid: &str,\n        flash: Option<FlashMessage<'_>>,\n    )\n    ```", "```rs\n    if flash.is_some() {\n        html_string.push_str(flash.unwrap().message());\n    }\n    ```", "```rs\n    new_user(flash: Option<FlashMessage<'_>>)\n    ```", "```rs\nif flash.is_some() {\n    html_string.push_str(flash.unwrap().message());\n}\n```", "```rs\n    #[get(\"/users/edit/<uuid>\", format = \"text/html\")]\n    pub async fn edit_user(mut db: Connection<DBConnection>,    uuid: &str, flash: Option<FlashMessage<'_>>) -> HtmlResponse {}\n    ```", "```rs\n    let connection = db\n        .acquire()\n        .await\n        .map_err(|_| Status::InternalServerError)?;\n    let user = User::find(connection, uuid)\n        .await\n        .map_err(|_| Status::NotFound)?;\n    ```", "```rs\n    let mut html_string = String::from(USER_HTML_PREFIX);\n    if flash.is_some() {\n        html_string.push_str(flash.unwrap().message());\n    }\n    html_string.push_str(\n        format!(\n            r#\"<form accept-charset=\"UTF-8\" action=\"/\n            users/{}\" autocomplete=\"off\" method=\"POST\">\n    <input type=\"hidden\" name=\"_METHOD\" value=\"PUT\"/>\n    <div>\n        <label for=\"username\">Username:</label>\n        <input name=\"username\" type=\"text\" value=\"{}\"/>\n    </div>\n    <div>\n        <label for=\"email\">Email:</label>\n        <input name=\"email\" type=\"email\" value=\"{}\"/>\n    </div>\n    <div>\n        <label for=\"old_password\">Old password:</label>\n        <input name=\"old_password\" type=\"password\"/>\n    </div>\n    <div>\n        <label for=\"password\">New password:</label>\n        <input name=\"password\" type=\"password\"/>\n    </div>\n    <div>\n        <label for=\"password_confirmation\">Password \n        Confirmation:</label>\n        <input name=\"password_confirmation\" type=\n        \"password\"/>\n    </div>\n    <div>\n        <label for=\"description\">Tell us a little bit more \n        about yourself:</label>\n        <textarea name=\"description\">{}</textarea>\n    </div>\n    <button type=\"submit\" value=\"Submit\">Submit</button>\n    </form>\"#,\n            &user.uuid,\n            &user.username,\n            &user.email,\n            &user.description.unwrap_or_else(|| \n            \"\".to_string()),\n        )\n        .as_ref(),\n    );\n    html_string.push_str(USER_HTML_SUFFIX);\n    Ok(RawHtml(html_string))\n    ```", "```rs\n    #[derive(Debug, FromForm)]\n    pub struct EditedUser<'r> {\n        #[field(name = \"_METHOD\")]\n        pub method: &'r str,\n        #[field(validate = len(5..20).or_else(msg!(\"name \n        cannot be empty\")))]\n        pub username: &'r str,\n        #[field(validate = validate_email()\n        .or_else(msg!(\"invalid email\")))]\n        pub email: &'r str,\n        pub old_password: &'r str,\n        pub password: &'r str,\n        pub password_confirmation: &'r str,\n        #[field(default = \"\")]\n        pub description: Option<&'r str>,\n    }\n    ```", "```rs\n    fn skip_validate_password<'v>(password: &'v str, old_password: &'v str, password_confirmation: &'v str) -> form::Result<'v, ()> {\n        if old_password.is_empty() {\n            return Ok(());\n        }\n        validate_password(password)?;\n        if password.ne(password_confirmation) {\n            return Err(FormError::validation(\"password \n            confirmation mismatch\").into());\n        }\n        Ok(())\n    }\n    ```", "```rs\n    #[field(validate = skip_validate_password(self.old_password, self.password_confirmation))]\n    pub password: &'r str,\n    ```", "```rs\n    use argon2::{password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString}, Argon2};\n    use chrono::offset::Utc;\n    ```", "```rs\n    pub async fn update<'r>(db: &mut Connection<DBConnection>, uuid: &'r str, user: &'r EditedUser<'r>) -> Result<Self, Box<dyn Error>> {}\n    ```", "```rs\n    let connection = db.acquire().await?;\n    let old_user = Self::find(connection, uuid).await?;\n    ```", "```rs\n    let now = OurDateTime(Utc::now());\n    let username = &(clean_html(user.username));\n    let description = &(user.description.map(|desc| clean_html(desc)));\n    ```", "```rs\n    let mut set_strings = vec![\n        \"username = $1\",\n        \"email = $2\",\n        \"description = $3\",\n        \"updated_at = $4\",\n    ];\n    let mut where_string = \"$5\";\n    let mut password_string = String::new();\n    let is_with_password = !user.old_password.is_empty();\n    ```", "```rs\n    if is_with_password {\n        let old_password_hash = PasswordHash::\n        new(&old_user.password_hash)\n            .map_err(|_| \"cannot read password hash\")?;\n        let argon2 = Argon2::default();\n        argon2\n            .verify_password(user.password.as_bytes(), \n            &old_password_hash)\n            .map_err(|_| \"cannot confirm old password\")?;\n        let salt = SaltString::generate(&mut OsRng);\n        let new_hash = argon2\n            .hash_password(user.password.as_bytes(), \n            &salt)\n            .map_err(|_| \"cannot create password hash\")?;\n        password_string.push_str(\n        new_hash.to_string().as_ref());\n        set_strings.push(\"password_hash = $5\");\n        where_string = \"$6\";\n    }\n    ```", "```rs\n    let query_str = format!(\n        r#\"UPDATE users SET {} WHERE uuid = {} RETURNING \n        *\"#,\n        set_strings.join(\", \"),\n        where_string,\n    );\n    let connection = db.acquire().await?;\n    let mut binded = sqlx::query_as::<_, Self>(&query_str)\n        .bind(username)\n        .bind(user.email)\n        .bind(description)\n        .bind(&now);\n    if is_with_password {\n        binded = binded.bind(&password_string);\n    }\n    let parsed_uuid = Uuid::parse_str(uuid)?;\n    Ok(binded.bind(parsed_uuid).fetch_one(connection).await?)\n    ```", "```rs\n    use crate::models::{pagination::Pagination, user::{EditedUser, NewUser, User}};\n    ```", "```rs\n    #[post(\"/users/<uuid>\", format = \"application/x-www-form-urlencoded\", data = \"<user_context>\")]\n    pub async fn update_user<'r>(db: Connection<DBConnection>, uuid: &str, user_context: Form<Contextual<'r, EditedUser<'r>>>) -> Result<Flash<Redirect>, Flash<Redirect>> {}\n    ```", "```rs\n    if user_context.value.is_none() {\n        let error_message = format!(\n            \"<div>{}</div>\",\n            user_context\n                .context\n                .errors()\n                .map(|e| e.to_string())\n                .collect::<Vec<_>>()\n                .join(\"<br/>\")\n        );\n        return Err(Flash::error(\n            Redirect::to(format!(\"/users/edit/{}\", uuid)),\n            error_message,\n        ));\n    }\n    ```", "```rs\n    let user_value = user_context.value.as_ref().unwrap();\n    match user_value.method {\n        \"PUT\" => put_user(db, uuid, user_context).await,\n        \"PATCH\" => patch_user(db, uuid, user_\n        context).await,\n        _ => Err(Flash::error(\n            Redirect::to(format!(\"/users/edit/{}\", uuid)),\n            \"<div>Something went wrong when updating \n            user</div>\",\n        )),\n    }\n    ```", "```rs\n    #[put(\"/users/<uuid>\", format = \"application/x-www-form-urlencoded\", data = \"<user_context>\")]\n    pub async fn put_user<'r>(mut db: Connection<DBConnection>, uuid: &str, user_context: Form<Contextual<'r, EditedUser<'r>>>) -> Result<Flash<Redirect>, Flash<Redirect>> {}\n    ```", "```rs\nlet user_value = user_context.value.as_ref().unwrap();\nlet user = User::update(&mut db, uuid, user_value).await.map_err(|_| {\n    Flash::error(\n        Redirect::to(format!(\"/users/edit/{}\", uuid)),\n        \"<div>Something went wrong when updating \n        user</div>\",\n    )\n})?;\nOk(Flash::success(\n    Redirect::to(format!(\"/users/{}\", user.uuid)),\n    \"<div>Successfully updated user</div>\",\n))\n```", "```rs\n    #[patch(\"/users/<uuid>\", format = \"application/x-www-form-urlencoded\", data = \"<user_context>\")]\n    pub async fn patch_user<'r>(db: Connection<DBConnection>, uuid: &str, user_context: Form<Contextual<'r, EditedUser<'r>>>) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        put_user(db, uuid, user_context).await\n    }\n    ```", "```rs\n    user::edit_user,\n    user::update_user,\n    user::put_user,\n    ```", "```rs\n    pub async fn destroy(connection: &mut PgConnection, uuid: &str) -> Result<(), Box<dyn Error>> {\n        let parsed_uuid = Uuid::parse_str(uuid)?;\n        let query_str = \"DELETE FROM users WHERE uuid = \n        $1\";\n        sqlx::query(query_str)\n            .bind(parsed_uuid)\n            .execute(connection)\n            .await?;\n        Ok(())\n    }\n    ```", "```rs\n#[delete(\"/users/<uuid>\", format = \"application/x-www-form-urlencoded\")]\npub async fn delete_user(\n    mut db: Connection<DBConnection>,\n    uuid: &str,\n) -> Result<Flash<Redirect>, Flash<Redirect>> {\n    let connection = db.acquire().await.map_err(|_| {\n        Flash::error(\n            Redirect::to(\"/users\"),\n            \"<div>Something went wrong when deleting \n            user</div>\",\n        )\n    })?;\n    User::destroy(connection, uuid).await.map_err(|_| {\n        Flash::error(\n            Redirect::to(\"/users\"),\n            \"<div>Something went wrong when deleting \n            user</div>\",\n        )\n    })?;\n    Ok(Flash::success(\n        Redirect::to(\"/users\"),\n        \"<div>Successfully deleted user</div>\",\n    ))\n}\n```", "```rs\n    #[post(\"/users/delete/<uuid>\", format = \"application/x-www-form-urlencoded\")]\n    pub async fn delete_user_entry_point(\n        db: Connection<DBConnection>,\n        uuid: &str,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        delete_user(db, uuid).await\n    }\n    ```", "```rs\n    user::delete_user,\n    user::delete_user_entry_point,\n    ```", "```rs\n    html_string\n        .push_str(format!(r#\"<a href=\"/users/edit/{}\">Edit \n        User</a><br/>\"#, user.uuid).as_ref());\n    html_string.push_str(\n        format!(\n            r#\"<form accept-charset=\"UTF-8\" action=\"/\n            users/delete/{}\" autocomplete=\"off\" \n            method=\"POST\"><button type=\"submit\" \n            value=\"Submit\">Delete</button></form>\"#,\n            user.uuid\n        )\n        .as_ref(),\n    );\n    ```"]