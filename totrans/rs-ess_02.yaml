- en: Chapter 2. Using Variables and Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we look at the basic building blocks of a Rust program: variables
    and their types. We discuss variables of primitive types, whether their type has
    to be declared or not, and the scope of variables. Immutability, one of the cornerstones
    of Rust''s safety strategy, is also discussed and illustrated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values and primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding variables to values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of a variable and shadowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checking and conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stack and the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code examples will center on building a text-based game called Monster Attack.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ideally, a program should be self-documenting by using descriptive variable
    names and easy to read code, but there are always cases where additional comments
    about a program''s structure or algorithms are needed. Rust follows the C convention
    and has the following convention for marking comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line comments** (`//`): Everything on the line after `//` is commentary and
    not compiled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block or multi-line comments** (`/* */`): Everything between the start `/*`
    and the end `*/` is not compiled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the preferred Rust style is to use only line comments even for multiple
    lines, like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use the block comments only to comment out code.
  prefs: []
  type: TYPE_NORMAL
- en: Rust also has a doc comment (`///`) that is useful in larger projects that require
    an official documentation for customers and developers. Such comments have to
    appear before an item (like a function) on a separate line to document that item.
    In these comments, you can use Markdown formatting syntax; for more information,
    go to [https://en.wikipedia.org/wiki/Markdown](https://en.wikipedia.org/wiki/Markdown).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `doc` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll see more relevant uses of doc comments in later code snippets. The rustdoc
    tool can compile these comments into a project's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Global constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, an application needs a few values that are in fact constants; they do
    not change in the course of the program. For example: the name of our game, which
    is "Monster Attack", is a constant, as is the maximum value of health, which is
    the number 100\. We must be able to use them in `main()` or any other function
    in our program, so they are placed at the top of the code file. They live in the
    global scope of the program. Such constants are declared with the `static` keyword
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Names of constants must be in uppercase and underscores can be used to separate
    words. Their type must also be indicated; `MAX_HEALTH` is a 32-bit integer (`i32`)
    and `GAME_NAME` is a string (`str`). As we will discuss further, the declaration
    of types for variables is done in exactly the same way although this is often
    optional when the compiler can infer the type from the code's context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry too much about the `&''static` indication for now. Remember that
    Rust is a low-level language, so many things must be specified in detail. The
    `&` annotation is a reference to something (it contains the memory address of
    a value); here it contains the reference to the string. However, if we only use
    `&str` and compile, we get an error for that line. Have a look at the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `2:22` means that we have an error on line 2 and position 22, so we must
    set the line numbering in our editor. We must add the lifetime specifier `'static`
    to the type annotation so that we get `&'static str`. The lifetime of an object
    in Rust is very important because it says how long the object will live in the
    program's memory. The Rust compiler adds the code to remove an object when its
    lifetime is over, freeing the memory that it occupied. The `'static` lifetime
    is the longest possible lifetime; such an object stays alive throughout the entire
    application, and so it is available to all of its code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when we add this specifier, the compiler gives us the ``warning: static
    item is never used: `MAX_HEALTH`, #[warn(dead_code)] on by default`` warning and
    an analogous warning for `GAME_NAME`.'
  prefs: []
  type: TYPE_NORMAL
- en: These warnings do not prevent the compilation, so at this stage, we have an
    executable. However, the compiler is right. These objects are never used in the
    program's code; so, in a complete program, you should either use them or throw
    them out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It takes a while before an aspiring Rust developer starts to regard the Rust
    compiler as his or her friend and not an annoying machine that keeps spitting
    out errors and warnings. As long as you see this message at the end of the compiler
    output, `error: aborting due to previous errors`, no (new) executable is made.
    But remember, correcting the errors eliminates runtime problems, so this can save
    you a lot of time that would be otherwise wasted tracking nasty bugs. Often, the
    error messages are accompanied with helpful notes on how to eliminate the error.
    Even the warnings can point you to flaws in your code. Rust also warns us when
    something is declared but not used in the code that follows, such as unused variables,
    functions, imported modules, and so on. It even warns us if we make a variable
    mutable (which means that its value can be changed) when it should not be or when
    code doesn''t get executed. The compiler does such a good job that when you reach
    the stage where all errors and warnings are eliminated, your program will most
    likely run correctly!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides static values, we can also use simple constant values whose value never
    changes. Constants always have to be typed, for example, `const PI: f32 = 3.14;`
    they are more local in scope than static values.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler automatically substitutes the value of the constant everywhere
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Printing with string interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An obvious way to use variables is to print out their values, as we have done
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The constant PI exists in the standard library, to use this value insert this
    statement at the top: use `std::f32::consts;` and then use the PI value as follows:
    `println!("{}", consts::PI);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument of `println!` is a literal format string that contains a
    `{}` placeholder. The value of the constant or variable after the comma is converted
    to a string and replaces the {}. There can be more than one placeholder, and they
    can be numbered in order so that they can be used repeatedly, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The placeholder can also contain one or more named arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Special ways of formatting can be indicated inside `{}` after a colon (`:`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following formatting possibilities exist according to the type that must
    be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`o` for octal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` for lower hexadecimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` for upper hexadecimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` for a pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b` for binary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e` for lower exponential notation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E` for upper exponential notation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` for debugging purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format!` macro has the same parameters and works in the same way as `println!`,
    but it returns a string instead of printing out.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://doc.rust-lang.org/std/fmt/](http://doc.rust-lang.org/std/fmt/)
    for an overview of all the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Values and primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constants that have been initialized have a value. Values exist in different
    types: `70` is an integer, `3.14` is a float, and `Z` and `q` are of the `char`
    type (they are characters). Characters are unicode values that take 4 bytes of
    memory each. `Godzilla` is a string of type `&str` (which is a Unicode UTF8 by
    default), `true` and `false` are of the `bool` type; they are Boolean values.
    Integers can be written in different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal format with `0x` (for example, `0x46` for `70`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Octal format with `0o`, (for example, `0o106` for `70`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary format with `0b`, (for example, `0b1000110`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underscores can be used for readability, as in `1_000_000`. Sometimes, the
    compiler will urge you to indicate more explicitly the type of number with a suffix.
    For example, the number after `u` or `i` is the number of memory bits used, namely
    `8`, `16`, `32`, or `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10usize` denotes an unsigned integer of machine word size `usize`, which can
    be any of the `u8`, `u16`, `u32`, or `u64` types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10isize` denotes a signed integer of machine word size `isize`, which can
    be any of the types among `i8`, `i16`, `i32`, and `i64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding cases, for a 64-bit operating system `usize` is in fact `u64`
    and `isize` is equivalent to `i64`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3.14f32` denotes a 32-bit floating point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3.14f64` denotes a 64-bit floating point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The numeric types `i32` and `f64` are the defaults if no suffix is given, but
    in that case, to differentiate between them, you must end an `f64` value with
    `.0`, like this: `let e = 7.0;`.'
  prefs: []
  type: TYPE_NORMAL
- en: Indicating a specific type is only needed when the compiler signals that it
    cannot infer the type of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is like any other C-like language when it comes to the different operators
    that exist on values and their precedence (go to [http://doc.rust-lang.org/reference.html#binary-operator-expressions](http://doc.rust-lang.org/reference.html#binary-operator-expressions)
    for more information on this). However, note that Rust does not have increment
    (`++`) or decrement (`--`) operators. To compare two values for equality, use
    `==` and to test whether they are different use `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: There is even the empty value `()` of zero size, which is the only value of
    the so-called unit type `()`. This is used to indicate the return value when an
    expression or a function returns nothing (no value), as is the case for a function
    that only prints to the console. `()` is not the equivalent of a null value in
    other languages; `()` means no value, whereas null is a value.
  prefs: []
  type: TYPE_NORMAL
- en: Consulting Rust documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The quickest way to find more detailed information about a Rust topic is to
    browse the documentation screen of the standard library at [http://doc.rust-lang.org/std/](http://doc.rust-lang.org/std/).
    On its left-hand side, you can find a listing of all the available crates that
    you can browse for more details. However, the most useful feature is the search
    box at the top; you can type in a few letters or a word to get a number of useful
    references. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consulting Rust documentation](img/image00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an exercise for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to change the value of a constant. This is of course not allowed. What error
    do you get? Have a look at `Chapter2/exercises/change_constant.rs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look up the `println!` macro in the documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the `fmt` specification and write a program that will print the `3.2f32`
    value as `+003.20`. Refer to `Chapter2/exercises/formatting.rs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding variables to values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing all values in constants is not an option. It is not good because constants
    live as long as the program and therefore be changed, and often we want to change
    values. In Rust, we can bind a value to a variable by using a `let` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike many other languages such as Python or Go, the semicolon (`;`) is needed
    here to end the statement. Otherwise, the compiler will throw the `` error: expected
    one of `.`, `;`, or an operator, found `}` `` error at us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to create bindings only when they are used in the rest of the
    program, but you needn''t worry because the Rust compiler warns us about that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For prototyping purposes, you can suppress the warning by prefixing the variable
    name with a `_` , like in `let _ energy = 5;`. In general, `_` is used for variables
    that we don't need.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding declaration, we didn't need to indicate the type;
    Rust inferred the type of `energy` to be an integer, which the `let` binding triggered.
    If the type is not obvious, the compiler searches in the code context to check
    from where the variable gets a value or how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: However, giving type hints like `let energy = 5u16;` is also okay; this way
    you help the compiler a bit by indicating the type of energy, which is a 2-byte
    unsigned integer in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `energy` variable by using it in an expression; for example,
    by assigning it to another variable or by printing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some other declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The value of `magic_number` could also be written as `3.14_f32`; the `_` separates
    the digits from the type to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: Declarations can replace previous declarations of the same variable. A statement
    like `let energy = "Abundant";` would now bind energy to the value `Abundant`
    of string type. The old declaration can no longer be used and its memory is freed.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable and immutable variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we get a boost from swallowing a health pack and our energy rises to
    value 25\. However, if we write `energy = 25;`, we get an `` error: re-assignment
    of immutable variable `energy` `` error. So, what is wrong here?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, Rust applies a programmer's wisdom here; a lot of bugs come from inadvertent
    or wrong changes made to variables, so don't let the code change a value unless
    you have deliberately allowed it!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are by default **immutable** in Rust, which is very similar to what
    functional languages do. In pure functional languages, mutability is not even
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a mutable variable because its value can change during code execution,
    you have to indicate that explicitly with `mut`. Have a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply declaring a variable as `let n;` is also not enough. If we do this,
    we will get ``error: unable to infer enough type information about `_`; type annotations
    required``. The compiler needs a value to infer its type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can give the compiler this information by assigning a value to `n`, like
    `n = -2;`, but as the message says, we could also indicate its type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can even use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The type (here `i32`) follows the variable name after a colon (`:`) (as we
    already showed for global constants), optionally followed by an initialization.
    In general, the type is indicated like `n: T`, where `n` is a variable and `T`
    is a type, and it is read as variable `n` is of the type `T`. So, this is the
    inverse of what is done in C/C++, Java, or C#, where one would write `T n`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For primitive types, this can be done simply with a suffix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to use an uninitialized variable results in the `error: use of possibly
    uninitialized variable` error (try it out). Local variables have to be initialized
    before they can be used in order to prevent undefined behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with a mutable global constant. What do you have to do to
    allow it? Why would that be? (For an example code, see `mutable_constant.rs`.)
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler does not recognize a name in your code, you will get an `unresolved
    name` error. This may probably be just a typo, but it will be caught early on
    at compilation and not at runtime!
  prefs: []
  type: TYPE_NORMAL
- en: Scope of a variable and shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All variables defined in `bindings.rs` have local scope delimited by `{ }` of
    the function, which happens to be `main()` here, and this applies to any function.
    After the ending `}`, they go out of scope and their memory allocation is freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even make a more limited scope inside a function by defining a code
    block that contains all the code within a pair of curly braces (`{ }`), as in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A variable defined in the block (like `inner`) is only known inside that block.
    A variable in the block can also have the same name as a variable in an enclosing
    scope (like `outer`), which is replaced (shadowed) by the block variable until
    the block ends. What do you think will happen when you try to print `inner` after
    the block? Try it out.
  prefs: []
  type: TYPE_NORMAL
- en: So, why would you want to use a code block? In the *Expressions* section, we
    will see that a code block can return a value that can be bound to a variable
    with let. A code block can also be empty (`{ }`).
  prefs: []
  type: TYPE_NORMAL
- en: Type checking and conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust has to know the type of each variable so that it can check (at compile
    time) whether they are only used in the manner in which their type permits. This
    way programs are type safe and a whole range of bugs can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also means that we cannot change the type of a variable during its lifetime
    because of static typing; for example, the score variable in the following snippet
    cannot change from an integer to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the compiler error, ``error: mismatched types: expected `int`, found
    `&''static str` (expected int, found &-ptr``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are allowed to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Rust lets us redefine variables; each `let` binding creates a new variable score
    that hides the previous one, which is freed from memory. This is actually quite
    useful because variables are immutable by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding strings with `+` (like the players in the following code) is not defined
    in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get `` error: binary operation `+` cannot be applied to type `&str`
    ``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, you can use the `to_string()` method to convert the value to a String
    type like this: `let player3 = player1.to_string() + player2;`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you could use the `format!` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In both the cases, `player3` has the value `"RobJane"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find out what happens when you assign a value from a variable of a certain
    type to another variable of a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is again not allowed; we get the same error (``error: mismatched types:
    expected `u32`, found `i32` (expected u32, found i32)``). To enable maximal type
    checking, Rust does not permit automatic (or implicit) conversions of one type
    to another like C++ does; therefore, it avoids a lot of hard-to-find bugs. For
    example, the numbers after the decimal point are lost when a `f32` value is converted
    to an `i32` value; this could lead to errors when done automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, do an explicit conversion (a casting) with the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When points contain a negative value, the sign would be lost after conversion.
    Similarly, when casting from a wider value like a float to an integer, the decimal
    part is truncated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the value must be convertible to the new type as a string cannot
    be converted to an integer, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Aliasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It can be useful sometimes to give a new, more descriptive or a shorter name
    to an existing type. This can be done with the `type` keyword, as in the following
    example where we needed a specific (but size-limited) variable for `MagicPower`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A type name starts with a capital letter, as does each word that is part of
    the name. What happens when we change the value `7800` to `78000`? The compiler
    detects this with the following warning, `warning: literal out of range for its
    type`.'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is an **expression-oriented** language, which means that most pieces of
    code are in fact expressions, that is, they compute a value and return that value
    (in that sense, values are also expressions). However, expressions by themselves
    do not form meaningful code; they must be used in statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `let` bindings like the following are declaration statements; they are
    not expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, `a + b` is an expression, and if we omit the semicolon at the end,
    the resulting value (here `7`) is returned. This is often used when a function
    needs to return its value (see examples in the next chapter). Ending an expression
    with a semicolon like `a + b;` suppresses the value of an expression, thereby
    throwing away the return value and making it an expression statement that returns
    the unit value `()`. A code is usually a sequence of statements, one on each code
    line, and Rust has to know when a statement ends; this is why nearly every Rust
    code line ends with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think the assignment `m = 42;` is? This is not a binding because
    there is no `let`. That should have happened on a previous code line. It is an
    expression that returns the unit value `()`. A compound binding like `let p =
    q = 3;` is not allowed in Rust; it returns the `error: unresolved name q` error.
    However, you can chain `let` bindings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an exercise for you. Print out the values of a, b, and n after this
    code snippet and explain the value of `a` (for example code, see `compound_let.rs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A code block is also an expression, which will return the value of its last
    expression if we omit the semicolon. For example, in the following code snippet,
    `n1` gets the value `7`, but `n2` gets no value (or rather the unit value `()`)
    because the return value of the second code block was suppressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the variables `a` and `b` are declared in a code block and live only as
    long as the block itself lives as they are local to the block. Note that the semicolon
    after the closing brace of the block (`};`) is needed. To print the unit value
    `()`, we need {`:?`} as the format specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The stack and the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since memory allocation is very important in Rust, we must have a good picture
    of what is going on. A program''s memory is divided into the stack and heap memory
    parts; to get more background on these concepts, read the information on the classic
    web page at [https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap).
    Primitive values such as numbers (like 32 in the figure), characters, and true/false
    values are stored on the stack, while the value of more complex objects that could
    grow in size are stored in the heap memory. Heap values are referenced by a variable
    on the stack, which contains the memory address of the object on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stack and the heap](img/image00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While the stack has a limited size, the size of the heap can grow as and when
    more space is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the following program and try to visualize the program''s
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Values are stored in memory and so they have memory addresses. The `health`
    variable contains an integer value `32` that is stored in the stack at location
    `0x23fba4`, while the variable game contains a string, which is stored in the
    heap starting at location `0x23fb90`. (These were the addresses when I executed
    the program, but they will be different when you run the program.)
  prefs: []
  type: TYPE_NORMAL
- en: The variables to which the values are bound are pointers or references to the
    values. They point to them; `game` is a reference to Space Invaders. The address
    of a value is given by the `&` operator. So, `&health` is the address where value
    `32` is stored, and `&game` is the address where the Space Invaders' value is
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print these addresses by using the format string `{:p}` for pointers
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the following situation in memory (memory addresses will be different
    at each execution):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stack and the heap](img/image00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can make an alias, which is another reference that points to the same place
    in memory, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the value that is being referred to rather than the `game2` reference
    itself, dereference it with the asterisk `*` operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(println! is clever, so println!("{}", game2);` line will also print the
    same value as `println!("game: {}", &game);`.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is a bit simplified because Rust will allocate values to
    the stack that will not change in size as much as it is possible, but this is
    meant to give you a better idea of what a reference to a value means.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know already that a `let` binding is immutable, so the value cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If `y` is declared with `let y = &health;`, then `*y` is the value `32`. Reference
    variables can also be given a type like `let x: &i64;` and such references can
    be passed around in code. After this `let` binding, `x` does not really point
    yet to a value and it does not contain a memory address. In Rust, there is no
    way to create a null pointer as you can in other languages; if you try to assign
    a nil, null, or even a unit value `()` to x, this will result in an error. This
    feature alone saves Rust programmers from countless bugs. Furthermore, trying
    to use `x` in an expression; for example, `println!("{:?}", x);` will result in
    the ``error: use of possibly uninitialized variable: `x`error`` error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutable reference to an immutable variable is forbidden; otherwise, the immutable
    variable could be changed through its mutable reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the ``error: cannot borrow immutable local variable `tricks` as
    mutable`` error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A reference to a mutable score variable can either be immutable or mutable
    respectively, such as `score2` and `score3` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The value of `score` can be only changed through a mutable reference such as
    `score3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons that we will see later, you can only make one mutable reference
    to a mutable variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This throws the ``error: cannot borrow `score` as mutable more than once at
    a time`` error.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we touch the heart of Rust's memory safety system, where borrowing a variable
    is one of its key concepts. We will explore this in more detail in [Chapter 6](part0056.xhtml#aid-1LCVG2
    "Chapter 6. Pointers and Memory Safety"), *Pointers and Memory Safety*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap is a much larger memory part than the stack, so it is important that
    memory locations are freed as soon as they are no longer needed. The Rust compiler
    sees when a variable ends its lifetime (or in other words, goes out of scope)
    and inserts a code at compile time to free its memory when the code is executed.
    This behavior is unique to Rust and is not present in other commonly used languages.
    Stack values can be boxed, that is, allocated in the heap by creating a `Box`
    around them, as is the case for the value of `x` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`Box` is an object that references a value on the heap. We''ll also look at
    this more closely in the *Boxes* section of [Chapter 6](part0056.xhtml#aid-1LCVG2
    "Chapter 6. Pointers and Memory Safety"), *Pointers and Memory Safety*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with variables in Rust and got acquainted
    with many of the common compiler error messages. We explored types and the default
    immutability of variables that are the cornerstones of Rust's safety behavior.
    In the following chapter, we will start writing some useful code by using program
    logic and functions.
  prefs: []
  type: TYPE_NORMAL
