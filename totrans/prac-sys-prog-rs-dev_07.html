<html><head></head><body>
		<div><h1 id="_idParaDest-80"><em class="italic">Chapter 5</em>: <a id="_idTextAnchor083"/>Memory Management in Rust</h1>
			<p>In <em class="italic">Section 1</em>, <em class="italic">Getting Started with Systems Programming in Rust</em>, we covered Cargo (the Rust development toolkit), a tour of the Rust language, an introduction to the Rust Standard Library, and standard library modules for managing process environment, command-line, and time-related functions. While the focus of <em class="italic">Section 1</em>, <em class="italic">Getting Started with Systems Programming in Rust</em>, was to provide an overview of the landscape and the foundation for system programming in Rust, <em class="italic">Section 2</em>, <em class="italic">Manage and Control System Resources in Rust</em>, gets into the details of how to manage and control system resources in Rust, including memory, files, terminals, processes, and threads. </p>
			<p>We are now entering <em class="italic">Section 2</em>, <em class="italic">Manage and Control System Resources in Rust</em>, of the book. <em class="italic">Figure 5.1</em> provides the context for this section: </p>
			<div><div><img src="img/Figure_5.1_B16405.jpg" alt="Figure 5.1 – Managing system resources"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Managing system resources</p>
			<p>In this chapter, we will focus on memory management. The following are the key learning outcomes for this chapter:</p>
			<ul>
				<li>The basics of <strong class="bold">operating system (OS)</strong> memory management</li>
				<li>Understanding the memory layout of Rust programs</li>
				<li>The Rust memory management lifecycle</li>
				<li>Adding a dynamic data structure to a template engine</li>
			</ul>
			<p>We will begin the chapter with an overview (or a refresher for those already familiar with the topic) of the general principles of memory management in OSes, including the memory management lifecycle and the layout of a process in memory. We will then cover the memory layout of a running Rust program. This will cover how a Rust program is laid out in memory and the characteristics of the heap, stack, and static data segments. In the third section, we learn about the Rust memory management lifecycle, how it differs from other programming languages, and how memory is allocated, manipulated, and released in Rust programs. Lastly, we will enhance the template engine that we started to build in <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, with a dynamic data structure.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>Rustup and Cargo must be installed in a local development environment. </p>
			<p>The complete code for this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter05</a>.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor085"/>The basics of OS memory management</h1>
			<p>In<a id="_idIndexMarker324"/> this section, we will go into the fundamentals of memory management in modern OSes. Those already familiar with this topic can skim through this section quickly as a refresher.</p>
			<p>Memory is <a id="_idIndexMarker325"/>among the most fundamental and critical resources available to a running program (process). Memory management deals with the allocation, use, manipulation, ownership transfer, and eventual release of memory used by a process. Without memory management, executing a program is not possible. Memory management is performed by a combination of components, such as the kernel, program instructions, memory allocators, and garbage collectors, but the exact mechanism varies across programming languages and OSes.</p>
			<p>In this section, we will look at the memory management lifecycle and then learn the details of how memory is laid out for a process by the operating system.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor086"/>The memory management lifecycle</h2>
			<p>In this section, we will<a id="_idIndexMarker326"/> cover the different activities associated with memory management:</p>
			<ol>
				<li>The memory management lifecycle <em class="italic">begins</em> when a binary executable is run. The operating system allocates a virtual memory address space for the program and initializes various segments of memory based on the instructions in the binary executable.</li>
				<li>Memory management activities <em class="italic">continue</em> as the program processes various inputs coming in from I/O devices such as files, networks, and standard input (from the command line).</li>
				<li>The memory management lifecycle <em class="italic">ends</em> when the program is terminated (or if the program ends abnormally due to error).</li>
			</ol>
			<p><em class="italic">Figure 5.2</em> shows a typical memory management cycle:</p>
			<div><div><img src="img/Figure_5.2_B16405.jpg" alt="Figure 5.2 – Memory lifecycle"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Memory lifecycle</p>
			<p>Memory management <a id="_idIndexMarker327"/>essentially involves four components—<strong class="bold">allocation</strong>, <strong class="bold">use and manipulation</strong>, <strong class="bold">deallocation/release</strong>, and <strong class="bold">tracking usage</strong>:</p>
			<ul>
				<li><strong class="bold">Memory allocation</strong>: This is <a id="_idIndexMarker328"/>explicitly done in low-level programming languages by programmers, but is performed transparently in high-level languages. Memory allocated can either be of a <em class="italic">fixed-size</em> (where the size of a data type is determined at compilation time, such as integers, Booleans, or fixed-size arrays) or <em class="italic">dynamically-sized</em> (where the memory is increased or decreased or relocated dynamically at runtime, for example, resizable arrays).</li>
				<li><strong class="bold">Memory use and manipulation</strong>: The<a id="_idIndexMarker329"/> following steps are typical activities performed in a program:<p>1. Defining a named memory area of a particular type (for example, declaring a new variable <em class="italic">x </em>of type integer)</p><p>2. Initializing a variable</p><p>3. Modifying the value of the variable</p><p>4. Copying or moving values to another variable </p><p>5. Creating and manipulating references to values </p></li>
				<li><strong class="bold">Memory release</strong>: This is<a id="_idIndexMarker330"/> explicitly performed by the programmer in low-level languages, but is handled automatically in high-level languages such as Java, Python, JavaScript, and Ruby<a id="_idIndexMarker331"/> using a component called the <strong class="bold">garbage collector</strong>.</li>
				<li><strong class="bold">Memory tracking</strong>: This is <a id="_idIndexMarker332"/>done at the kernel level. A program invokes <em class="italic">system calls</em> to allocate and deallocate memory. System calls are executed by the <em class="italic">kernel</em>, which keeps track of memory allocations and releases per process.</li>
				<li><strong class="bold">Swapping/paging</strong>: This is<a id="_idIndexMarker333"/> also done by the <em class="italic">kernel</em>. Modern OSes virtualize physical memory resources. Processes do not directly interact with actual physical memory addresses. The kernel assigns virtual address space to each process. The total sum of virtual address space allocated to all processes in a <a id="_idIndexMarker334"/>system can be more than the amount of physical memory available in the system, but the processes don't know (or care) about this. The OS manages this using virtual memory management, which ensures that the processes are insulated from each other, and programs have access to the committed memory over their lifetime. Swapping and paging are<a id="_idIndexMarker335"/> techniques in <strong class="bold">virtual memory management</strong>.<p class="callout-heading">Paging and swapping</p><p class="callout">How does the operating system map the virtual memory address space to physical memory? To achieve this, the virtual address space allocated to programs is split into fixed-size pages (for example 4 KB or 8 KB chunks). A <strong class="bold">page</strong> is a <a id="_idIndexMarker336"/>fixed-length contiguous block of virtual memory. Thus the virtual memory allocated to a program is divided into multiple fixed-length pages. The corresponding unit on the physical RAM is a <strong class="bold">page frame</strong>, which is <a id="_idIndexMarker337"/>a fixed-length block of RAM. Multiple page-frames add up to the total physical memory on a system.</p><p class="callout">At any point in time, only<a id="_idIndexMarker338"/> some of the <em class="italic">virtual pages</em> of a program need to be present in the <em class="italic">physical page frames</em>. The rest are<a id="_idIndexMarker339"/> stored on disk in the <em class="italic">swap area</em>, which is a reserved area of the disk. The kernel maintains a page table to track the location of each page in the virtual memory space allocated to a program. When a program tries to access a memory location on a page, and if the page is not on the page frame, the page is located on disk and is then swapped into the main memory. Likewise, unused pages in RAM are swapped back into the disk (secondary storage) to make space for active processes. This process is<a id="_idIndexMarker340"/> called <strong class="bold">paging</strong>.</p><p class="callout">If the same technique is applied at the process level (rather than the page level), it is called <strong class="bold">swapping</strong>, where the<a id="_idIndexMarker341"/> pages of one process are swapped from memory to disk to make way for another process to be loaded into memory.</p><p class="callout">This aspect of memory management that deals with mapping physical RAM to virtual address space is called <strong class="bold">virtual memory management</strong>. This ensures that processes have access to adequate memory<a id="_idIndexMarker342"/> as needed, and are also isolated from each other and from the kernel. This way, a program cannot accidentally (or deliberately) write to the memory space of the kernel or another process, protecting against memory corruption, undefined behavior, and security issues.</p></li>
			</ul>
			<p>We have learned about the memory management lifecycle of a process. Let's now understand how a program is laid out in memory by the operating system.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor087"/>The process memory layout</h2>
			<p>We will now look at the <a id="_idIndexMarker343"/>structure of the virtual address space allocated by the kernel to a single process. <em class="italic">Figure 5.3</em> shows the memory layout for a process on <strong class="bold">Linux</strong>, but similar mechanisms exist for <strong class="bold">Unix</strong> and <strong class="bold">Windows</strong> OS variants:</p>
			<div><div><img src="img/Figure_5.3_B16405.jpg" alt="Figure 5.3 – Process memory layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Process memory layout</p>
			<p>A <strong class="bold">process</strong> is a <a id="_idIndexMarker344"/>running program. When a program is started up, the operating system loads it into memory, gives it access to the command-line parameters and environment variables, and starts executing the program instructions.</p>
			<p>The operating system allocates the process some amount of memory. Such allocated memory has a structure associated with it, which is <a id="_idIndexMarker345"/>called the <strong class="bold">memory layout</strong> of the process. The<a id="_idIndexMarker346"/> memory layout of a process contains<a id="_idIndexMarker347"/> several <strong class="bold">memory regions</strong> (also called<strong class="bold"> segments</strong>), which are nothing but blocks of <em class="italic">memory pages</em> (which was described in the previous subsection). These segments are shown in <em class="italic">Figure 5.3</em>, and described next.</p>
			<p>The portion of <em class="italic">Figure 5.3</em> marked <strong class="bold">A</strong> shows that the overall virtual memory space allocated to a process is split into <strong class="bold">Kernel space</strong> and <strong class="bold">User space</strong>. Kernel space<a id="_idIndexMarker348"/> is the area of memory where the portion of the kernel is loaded that assists the program in managing and communicating with hardware resources. This includes kernel code, the kernel's own memory area, and space marked <strong class="bold">Reserved</strong>. In this chapter, we will <a id="_idIndexMarker349"/>focus only on the <strong class="bold">User space</strong>, as <a id="_idIndexMarker350"/>that is the area that is actually used by the program. The kernel space of virtual memory is not accessible to the program.</p>
			<p>The user space is segregated into several memory segments, which are described here:</p>
			<ul>
				<li><strong class="bold">Text segment</strong> contains<a id="_idIndexMarker351"/> the program's code and other read-only <a id="_idIndexMarker352"/>data such as <em class="italic">string literals</em> and <em class="italic">const parameters</em>. This portion is directly loaded from the program binary (executable or library).</li>
				<li><strong class="bold">Data segment</strong> stores<a id="_idIndexMarker353"/> global and static variables that are initialized with <a id="_idIndexMarker354"/>non-zero values.</li>
				<li><strong class="bold">BSS segment</strong> contains<a id="_idIndexMarker355"/> uninitialized<a id="_idIndexMarker356"/> variables.</li>
				<li><strong class="bold">Heap</strong> is used for<a id="_idIndexMarker357"/> dynamic memory<a id="_idIndexMarker358"/> allocation. The address space of the process continues to grow as memory gets allocated on the heap. The heap grows upward, which means new items are added at addresses greater than previous items.</li>
				<li><strong class="bold">Stack</strong> is used <a id="_idIndexMarker359"/>for <em class="italic">local variables</em>, and also <em class="italic">function parameters</em> (in some platform architectures). Stacks<a id="_idIndexMarker360"/> grow downwards, which means that items put earlier in the stack occupy lower address spaces.<p class="callout-heading">Tip</p><p class="callout">Note that the stack and the heap are allocated at opposite ends of the process address space. As the <em class="italic">stack size</em> increases, it grows downwards, and as the <em class="italic">heap size</em> increases, it grows upwards. In the event that they meet, a stack overflow error occurs or a memory allocation call on the heap will fail.</p></li>
				<li>In<a id="_idIndexMarker361"/> between the stack and the heap, there is also the area where any <strong class="bold">shared memory</strong> (memory shared across processes), <strong class="bold">shared libraries</strong> used<a id="_idIndexMarker362"/> by the program, or <strong class="bold">memory-mapped</strong> areas (areas of memory that reflect a file on a disk) are located.</li>
				<li>Above the stack, there is a segment<a id="_idIndexMarker363"/> where <strong class="bold">command-line arguments</strong> passed to the program and the <strong class="bold">environment variables</strong> set for<a id="_idIndexMarker364"/> the process are stored.</li>
			</ul>
			<p>Memory management is<a id="_idIndexMarker365"/> a complex topic and a lot of details have been left out in the interest of keeping the discussion focused on memory management in Rust. However, the basics of virtual memory management and virtual memory addresses described earlier are critical for understanding the next section on how Rust performs memory management.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor088"/>Understanding the memory layout of Rust programs</h1>
			<p>In the <a id="_idIndexMarker366"/>previous section, we discussed <a id="_idIndexMarker367"/>the fundamentals of memory management in modern OSes. In this section, we will discuss how a running Rust program is laid out in memory by the operating system, and the characteristics of the different parts of the virtual memory are used by Rust programs.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor089"/>Rust program memory layout</h2>
			<p>In order to understand how <a id="_idIndexMarker368"/>Rust achieves the combination of low-memory footprint, memory safety, and performance, it is necessary to understand how Rust programs are laid out in memory and how they can be controlled programmatically.</p>
			<p>A low-memory footprint depends on the efficient management of memory allocations, the copying of values, and deallocations. Memory safety deals with ensuring that there is no unsafe access to values stored in memory. Performance depends on understanding the implications of storing a value in the stack versus the heap versus the static data segment. Where Rust shines is that all these tasks are not fully left to the programmer like in C/C++. The Rust compiler and its ownership system does a lot of the heavy-lifting, preventing entire classes of memory bugs. Let's now look at the topic in detail.</p>
			<p>The memory layout of a <a id="_idIndexMarker369"/>Rust program is shown in <em class="italic">Figure 5.4</em>:</p>
			<div><div><img src="img/Figure_5.4_B16405.jpg" alt="Figure 5.4 – Rust program memory layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Rust program memory layout</p>
			<p>Let's walk through this figure to understand the memory layout of a Rust program:</p>
			<ul>
				<li><code>cargo build</code>) is read into system memory by the kernel and executed, it becomes a process. The operating system assigns each process its own private user space so that different Rust processes don't interfere with each other accidentally.</li>
				<li><strong class="bold">Text segment</strong>: Executable<a id="_idIndexMarker371"/> instructions of the Rust program are placed here. This is placed below the stack and heap to prevent any overflows from overwriting it. This segment is <em class="italic">read-only</em> so that its contents are not accidentally overwritten. However, multiple processes can <em class="italic">share</em> the text segment. Let's take the example of a text editor written in Rust running in <em class="italic">process 1</em>. If a second copy of the editor is to be executed, then the system will create a new process with its own private memory space (let's call it <em class="italic">process 2</em>), but will not reload the program instruction of the editor. Instead, it will create a reference to the text instructions of <em class="italic">process 1</em>. But the rest of the memory (the data, stack, and so on) is not shared across processes.</li>
				<li><code>Rc</code> (single-threaded reference-counting pointer) and <code>Arc</code> (thread-safe reference counting pointer).</p><p class="callout">Examples of types in <a id="_idIndexMarker377"/>Rust with a <em class="italic">dynamic size</em> are <code>Vectors</code>, <code>Strings</code>, and other <code>collection</code> types, and these are heap-allocated.</p><p class="callout">Primitive types such as integers are stack-allocated by default, but the programmer can allocate memory in the heap by using a <code>Box&lt;T&gt;</code> type (for example, <code>let y =3</code> allocates memory for integer <code>y</code> on the stack and initializes it to <code>3</code>, whereas <code>let x: Box&lt;i32&gt; = Box::new(3)</code> allocates a value for integer <code>x</code> on the heap and initializes it to <code>3</code>).</p></li>
				<li><strong class="bold">Stack segment</strong>: The <a id="_idIndexMarker378"/>stack is the region of the process memory that stores <em class="italic">temporary (local) variables</em>, <em class="italic">function parameters</em>, and the <em class="italic">return address</em> of the instruction (which is to be executed after the function call is over). By default, all memory allocations in Rust are on the stack. Whenever a function is called, its variables get memory-allocated on the stack. Memory allocation happens in contiguous memory locations one<a id="_idIndexMarker379"/> above the other, in a <em class="italic">stack data structure</em>.</li>
			</ul>
			<p>To summarize, here is how the virtual memory<a id="_idIndexMarker380"/> allocated to a running Rust program looks:</p>
			<ul>
				<li>The <em class="italic">code instructions</em> of a Rust program go into the <em class="italic">text segment</em> area.</li>
				<li>The <em class="italic">primitive data types</em> are allocated on the <em class="italic">stack</em>.</li>
				<li>The static variables are located in the <em class="italic">data segment</em>.</li>
				<li>The <em class="italic">heap-allocated values</em> (values whose size is not known at compilation time, such as vectors and strings) are stored in the <em class="italic">heap area of the data segment</em>.</li>
				<li>The <em class="italic">uninitialized variables</em> are in the <em class="italic">BSS segment</em>.</li>
			</ul>
			<p>Of these, the Rust programmer does not have much control over the <em class="italic">text</em> segment and <em class="italic">BSS</em> segments, and only primarily works with the <em class="italic">stack</em>, <em class="italic">heap</em>, and <em class="italic">static</em> areas of memory. In the next section, we will delve into the characteristics of these three memory areas. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor090"/>The characteristics of stack, heap, and static memory</h2>
			<p>We have seen how the different types of variables declared in a Rust program are allocated in different regions of the process space. Of the three memory segments, we have discussed – <strong class="bold">text</strong>, <strong class="bold">data</strong>, and <strong class="bold">stack</strong> – the text area is not under the control of the Rust programmer, but the programmer has the flexibility to decide whether to place a value (that is, allocate memory) on the stack, heap, or as a static variable. However, there are strong implications of this decision because the stack, static variables, and the heap are managed quite differently, and their lifetimes are also different. Understanding these trade-offs is an important part of writing any Rust program. Let's look at them more closely.</p>
			<p><em class="italic">Table 5.1</em> summarizes the<a id="_idIndexMarker381"/> characteristics of stack-allocated versus heap-allocated versus<a id="_idIndexMarker382"/> static-segment memory. Recall from <em class="italic">Figure 5.4</em> that stack-allocated <a id="_idIndexMarker383"/>memory belongs to the <em class="italic">stack segment</em>, and heap and static variables belong to the <em class="italic">data segment</em> of virtual memory address space:</p>
			<div><div><img src="img/B16405_05_Table_01.jpg" alt="Table 5.1 – Characteristics of the stack, heap, and static memory areas"/>
				</div>
			</div>
			<p class="figure-caption"><img src="img/B16405_05_Table_02.png" alt="Table 5.1 – Characteristics of the stack, heap, and static memory areas"/></p>
			<p class="figure-caption">Table 5.1 – Characteristics of the stack, heap, and static memory areas</p>
			<p class="callout-heading">Is it important to understand the memory locations of values?</p>
			<p class="callout">For people who have worked with other high-level programming languages, understanding whether a variable was stored in the stack, heap, or static data segments won't have really been necessary, as the language compiler, runtime, and garbage collector will have abstracted away these details and made it easy for the programmer.</p>
			<p class="callout">But in Rust, especially for writing system-oriented programs, awareness of the memory layout and the memory model is necessary to select appropriate and efficient data structures for various parts of the system design. And in many cases, this knowledge is necessary even to get the Rust program to compile!</p>
			<p>In this section, we have covered the memory layout of Rust programs and understood the characteristics of the stack and data segment memory areas. In the next section, we will provide an overview of the Rust memory management lifecycle and a comparison with other programming languages. We will also look at the three steps of the Rust memory management lifecycle in detail.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor091"/>The Rust memory management lifecycle</h1>
			<p>Computer <a id="_idIndexMarker384"/>programs can be modeled as finite state machines. A <a id="_idIndexMarker385"/>running program accepts different forms of inputs (for example, file inputs, command-line arguments, network calls, interrupts, and so on) and transitions from one state to another. Take the case of a device driver. It can be in either of the following states: <em class="italic">uninitialized</em>, <em class="italic">active</em>, or <em class="italic">inactive</em>. When a device driver is just booted up (loaded into memory), it is in the <em class="italic">uninitialized</em> state. When the device registers are initialized and ready to accept events, it goes into the <em class="italic">active</em> state. It can be put in suspended mode and not ready to accept inputs, in which case it goes into the <em class="italic">inactive</em> state. You can extend this concept further. For a communications device like a serial port, the device driver can be in the <em class="italic">sending</em> or <em class="italic">receiving</em> state. Interrupts can trigger the transitions from one state to another. Likewise, every kind of program, whether it is a kernel component, command-line tool, network server, or an e-commerce application, can be modeled in terms of states and transitions.</p>
			<p>Why is the discussion around state important for memory management? Because, state is represented in a program by the programmer as a set of variables with values, and these values are stored in the virtual memory of a running program (process). Since a program goes through numerous state transitions (top social media site programs handle several hundred million state transitions per day), all this state and these transitions are represented in memory and then persisted to disk. Every component of the modern layered application stack (including frontend apps, backend servers, the network stack, other system programs, and operating system kernel utilities) needs to be able to efficiently allocate, use, and release memory. Hence, it is important to understand how the memory layout of a program changes over its lifetime, and what the programmer can do to make it efficient.</p>
			<p>With this background, let's move on to an overview of the Rust memory management lifecycle.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor092"/>Overview of the Rust memory management lifecycle</h2>
			<p>Let's now compare the <a id="_idIndexMarker386"/>memory management<a id="_idIndexMarker387"/> lifecycle for other programming languages with Rust. Let's also take a look at <em class="italic">Figure 5.5</em>, which shows how memory management in Rust works, in comparison with other programming languages:</p>
			<div><div><img src="img/Figure_5.5_B16405.jpg" alt="Figure 5.5 – Memory management in other programming languages"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Memory management in other programming languages</p>
			<p>In order to appreciate the Rust memory model, it is important to understand how memory management is done in other programming languages. <em class="italic">Figure 5.5</em> shows how two sets of programming languages—high-level and low-level—manage memory and compare it with Rust.</p>
			<p>There are three main steps in the memory management lifecycle:</p>
			<ol>
				<li value="1">Memory allocation</li>
				<li>Memory use and manipulation</li>
				<li>Memory release (deallocation)</li>
			</ol>
			<p>The way these three <a id="_idIndexMarker388"/>steps are performed varies across programming languages.</p>
			<p>High-level languages (such as Java, JavaScript, and Python) hide a lot of the details of memory management from the programmer (who has limited control), automate memory deallocation using a garbage collector component, and do not provide direct access to memory pointers to the programmer.</p>
			<p>Low-level (also known as system) programming languages such as C/C++ provide a complete degree of control to the programmer but do not provide any safety nets. Managing memory efficiently is left solely to the skills and meticulousness of the developer.</p>
			<p>Rust combines the best of both worlds. A Rust programmer has full control over memory allocation, being able to manipulate and move around values and references in memory, but is subjected to strict Rust ownership rules. Memory deallocation is automated by the compiler-generated code.</p>
			<p class="callout-heading">High-level versus low-level programming languages</p>
			<p class="callout">Note that the terms <strong class="bold">high-level</strong> and <strong class="bold">low-level</strong> are used to classify programming languages based on the<a id="_idIndexMarker389"/> level of abstraction provided to the programmer. Languages that provide higher-level<a id="_idIndexMarker390"/> programming abstractions are easier to program in and take away many of the hard responsibilities around memory management, at the cost of lack of control for the programmer.</p>
			<p class="callout">On the other hand, system languages such as C and C++ provide full control and responsibility to the programmer to manage memory and other system resources.</p>
			<p>We have seen an overview of the memory management approaches of Rust versus other programming languages. Let's now see them in more detail in the following subsections. </p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor093"/>Memory allocation</h2>
			<p>Memory allocation is<a id="_idIndexMarker391"/> the process of storing a value (it can be an integer, string, vector, or higher-level data structures such as network ports, parsers, or e-commerce orders) to a location in memory. As part of memory allocation, a programmer instantiates a data type (primitive or user-defined) and assigns an initial value to it. The Rust program invokes system calls to allocate memory.</p>
			<p>In higher-level languages, the programmer declares variables using the specified syntax. The language compiler (in conjunction with the language runtime) handles the allocation and exact location of the various data types in virtual memory.</p>
			<p>In C/C++, the programmer controls memory allocation (and reallocation) through the system call interfaces provided. The language (compiler, runtime) does not intervene in the programmer's decision.</p>
			<p>In Rust, by default, when the programmer initializes a data type and assigns it a value, the operating system allocates memory on the stack. This applies to all primitive types (integers, floating points, char, Boolean, fixed-length arrays), function local variables, function parameters, and other fixed-length data types (such as smart pointers). But the programmer has the option to explicitly place a primitive data type on the heap by using <code>Box&lt;T&gt;</code> smart pointers. Secondly, all dynamic values (for example, strings and vectors whose size changes at runtime) are stored on the heap, and the smart pointer to this heap data is placed on the stack. To summarize, for fixed-length variables, values are stored on the stack, variables with a dynamic length are allocated memory on the heap segment, and a pointer to the starting location of heap-allocated memory is stored on the stack.</p>
			<p>Let's now look at some additional information about memory allocation.</p>
			<p>All data types declared in a Rust program have their size calculated at compile time; they are not dynamically allocated or freed. So what, then, is dynamic?</p>
			<p>When there are values that change over time (for example, a <code>String</code> whose value is not known at compile time or a collection where the number of elements is not known upfront), these are allocated at runtime on the heap, but a reference to such data is stored as a pointer (which has a fixed size) on the stack.</p>
			<p>For example, run the following code:</p>
			<pre>use std::mem;
fn main() {
    println!("Size of string is {:?}", 
        mem::size_of::&lt;String&gt;());
}</pre>
			<p>When you run this program on a 64-bit system, the size of <code>String</code> will be printed as <code>String</code> without even creating a string variable or assigning a value to it? This is because Rust does not care how long a string is, in order to compute its size. Sound strange? This is how it works.</p>
			<p>In Rust, <code>String</code> is a smart <a id="_idIndexMarker392"/>pointer. This is illustrated in <em class="italic">Figure 5.6</em>. It has three components: a <code>String</code> smart pointer occupies 64 bits (or 8 bytes), hence the total size occupied by a variable of the <code>String</code> type is 24 bytes. This is regardless of the actual value contained in the string, which is stored in the heap, while the smart pointer (24 bytes) is stored on the stack. Note that even though the size of the <code>String</code> smart pointer is fixed, the actual size of the memory allocated on the heap may vary as the value of string changes during program runtime.</p>
			<div><div><img src="img/Figure_5.6_B16405.jpg" alt="Figure 5.6 – Structure of a String smart pointer in Rust"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Structure of a String smart pointer in Rust</p>
			<p>In this subsection, we have discussed various aspects of memory allocation in a Rust program. In the next subsection, we will look at the second step of the memory management lifecycle, which is about memory manipulation and use within the Rust program.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Memory use and manipulation</h2>
			<p>Memory use and manipulation refer<a id="_idIndexMarker393"/> to program instructions such as modifying the value assigned to a variable, copying a value to another variable, moving the ownership of a value from one variable to another, and creating new references to an existing value. In Rust, <code>copy</code>, <code>move</code>, and <code>clone</code> are three fundamental memory manipulation operations. The <code>move</code> operation transfers ownership of data from one variable to another. The <code>copy</code> operation allows a value associated with a variable to be duplicated with a bit-wise copy. Implementing the <code>clone</code> trait on a data type allows the duplication of values instead of move semantics.</p>
			<p>All primitive data types (such as integers, bools, and chars) implement the <code>copy</code> trait by default. This means assigning a variable of the primitive data type to another variable of same type copies the value (duplicates). User-defined data types such as structs can implement <code>copy</code> if all their data members also implement the <code>copy</code> trait.</p>
			<p>Anything that does not implement <code>copy</code> is moved by default. For example, for the <code>Vec</code> data type, all operations (for example, passing a <code>Vec</code> value as a function argument, returning a <code>Vec</code> from a function, assignment, pattern matching) are <em class="italic">move</em> operations. Rust does not have a <code>Move</code> trait explicitly because it is the default.</p>
			<p>For non-copy data types, <code>move</code> is the default behavior. To implement arbitrary <code>copy</code> operations on non-copy types, the <code>clone</code> trait can be implemented on the type.</p>
			<p>More details can be found in the Rust book at <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>. In high-level languages, the programmer can initialize a variable, assign values to variables, and copy values to other variables. Generally, high-level languages do not have explicit pointer semantics or arithmetic but use references. The difference is that a pointer refers to the exact memory address of a value, but references are aliases for another variable. While the programmer uses reference semantics, the language internally implements pointer operations.</p>
			<p>In C/C++, the <a id="_idIndexMarker394"/>programmer can also initialize variables, and assign and copy values. In addition, pointer operations are possible. Pointers allow you to write directly to any memory allocated by the process. The problem with this model is that this gives rise to several types of memory safety issues, such as free-after-use, double-free, and buffer overflows.</p>
			<p>In Rust, memory use and manipulation are governed by certain rules:</p>
			<ul>
				<li>First, all variables in Rust are immutable by default. If a value contained in a variable needs to be altered, the variable has to be declared explicitly as mutable (with the <code>mut</code> keyword).</li>
				<li>Secondly, there are ownership rules that apply to data access, which are listed in a later subsection.</li>
				<li>Third, there are rules of references (borrowing) that apply when it comes to sharing a value with one or more variables, which is also covered later.</li>
				<li>Fourth, there are lifetimes, which give information to the compiler about how two or more references relate to each other. This helps the compiler prevent memory safety issues by checking if the references are valid.</li>
			</ul>
			<p>These concepts and rules make programming in Rust very different (and more difficult at times) from other programming languages. But it is also these very concepts that impart super-powers to Rust in areas of memory and thread-safety. Importantly, Rust provides these benefits without runtime costs.</p>
			<p>Let's now recap the Rust rules for ownership and for borrowing and references in the subsections that follow.</p>
			<h3>Rust ownership rules</h3>
			<p>Ownership is arguably <a id="_idIndexMarker395"/>Rust's most unique feature. It gives memory safety to Rust programs without an external garbage collector or relying entirely on the programmer's skillset. There are three ownership rules in Rust, which are listed here. More details can be found at the following link: <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a>.</p>
			<p class="callout-heading">The rules governing Rust ownership</p>
			<p class="callout">In Rust, every value has an owner. At any point in time, for a given value, there can be only one owner. A value is dropped (the memory associated with it is deallocated) when its owner goes out of scope. Some examples of the scope of a variable are a function, a <code>for</code> loop, a statement, or an arm of a match expression. More details on scope can be found here: <a href="https://doc.rust-lang.org/reference/destructors.html#drop-scopes">https://doc.rust-lang.org/reference/destructors.html#drop-scopes</a>.</p>
			<p>The really interesting aspect of Rust is that these ownership rules are not meant for the programmer to memorize, but the Rust compiler enforces these rules. Another significant implication of these ownership rules is that the same rules also ensure thready safety, in addition to memory safety.</p>
			<h3>Rust borrowing and references</h3>
			<p>In Rust, references<a id="_idIndexMarker396"/> simply borrow a value and are indicated by the <code>&amp;</code> symbol. They basically allow you to refer to a value without taking ownership of the value. This is unlike smart pointers such as <code>String</code>, <code>Vector</code>, <code>Box</code>, and <code>Rc</code>, which own the value they point to.</p>
			<p>Taking a reference to a value <a id="_idIndexMarker397"/>is called <strong class="bold">borrowing</strong>, which is a temporary reference to an object, but it has to be returned and cannot be destroyed by the borrower (only the owner can deallocate memory). If there are multiple borrows of a value, the compiler ensures that all borrows end before the object is destroyed. This eliminates memory errors such as <strong class="bold">use-after-free</strong> and <strong class="bold">double-free</strong> errors.</p>
			<p>More details on Rust borrowing and references can be found at <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</a>.</p>
			<p class="callout-heading">The rules governing Rust references</p>
			<p class="callout">A value stored in memory can either have one mutable reference to it or any number of immutable references (but not both).</p>
			<p class="callout">References must <a id="_idIndexMarker398"/>always be valid. The borrow checker portion of the Rust compiler stops compilation if invalid references are found in code. When it's ambiguous, the Rust compiler also asks the programmer to explicitly specify the lifetime of references.</p>
			<p>In this subsection, we have covered several rules governing the manipulation of variables and values in memory and the rules governing them. In the next subsection, we will look at the last aspect of the memory management lifecycle, which is about deallocating memory after use.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>Memory deallocation</h2>
			<p>Memory deallocation deals<a id="_idIndexMarker399"/> with the question of how to release memory back to the operating system from the Rust program. Stack-allocated values are automatically released, as this is a managed-memory area. Static variables have a lifetime until the end of the program, so they get released automatically when the program terminates. The real question around memory release applies to heap-allocated memory.</p>
			<p>Some of these values may not be required to be held in memory until the end of the program, in which case they can be released. But the mechanism of such memory release varies widely across different programming language groups:</p>
			<ul>
				<li>Higher-level languages do not require the programmers to explicitly release memory when they are no longer needed. Instead, they use a <a id="_idIndexMarker400"/>mechanism called <strong class="bold">garbage collection</strong>. In this model, a runtime component<a id="_idIndexMarker401"/> called <strong class="bold">garbage collector</strong> analyzes the <em class="italic">heap-allocated</em> memory of the process, determines the unused objects using specialized algorithms, and deallocates them. This helps improve memory safety, prevents memory leaks, and makes programming easier for developers.</li>
				<li>In C/C++, the<a id="_idIndexMarker402"/> deallocation of memory is the responsibility of the programmer. Forgetting to release memory causes <strong class="bold">memory leaks</strong>. Accessing<a id="_idIndexMarker403"/> values after memory has been released causes memory safety issues. In large, complex code bases, or in code maintained by multiple people, this causes serious issues.</li>
				<li>Rust takes a very different approach to memory deallocation. Rust neither has a <code>Drop</code> trait) for a type, and that will be called by the compiler-generated code. The benefit of this approach is that it gives fine-grained memory control (like C/C++) while freeing the Rust programmer from having to manually deallocate memory (like high-level languages), without the drawbacks of the garbage collector (latency and unpredictable GC pauses).</li>
				<li>Note that in Rust, only the owner of a value can release the memory associated with it. References do not own the data they point to, so cannot deallocate memory. But smart pointers own the data they point to. The compiler generates code that calls the <code>drop</code> method from the <code>Drop</code> trait associated with the smart pointer when the smart pointer goes out of scope.</li>
				<li>Also, these memory deallocation rules apply only to heap-allocated memory as the other two types of memory segments (stack and statics) are managed directly by the operating system.</li>
			</ul>
			<p>We have so far seen the rules governing memory allocation, manipulation, and release in Rust programs. All these collectively aim to achieve the primary goal of memory safety without an external garbage collector, which is truly one of the highlights of the Rust programming language. The following callout section describes the various types of memory vulnerabilities and how Rust prevents them.</p>
			<h3>What is memory safety?</h3>
			<p><strong class="bold">Memory safety</strong> simply <a id="_idIndexMarker406"/>means that in any possible execution path of a program, there is no access to invalid memory. The following are some of the prominent categories of memory safety bugs:</p>
			<ul>
				<li><strong class="bold">Double-free</strong>: Attempting to release the same memory location(s) more than once. This can result in <a id="_idIndexMarker407"/>undefined behavior or memory corruption. Rust ownership rules allow the release of memory only by the owner of a value, and at any point, there can be only one owner of a value allocated in the heap. Rust thus prevents this class of memory safety bugs.</li>
				<li><strong class="bold">Use-after-free</strong>: A memory <a id="_idIndexMarker408"/>location is accessed after it has been released by the program. The memory being accessed may have been allocated to another pointer, so the original pointer to this memory may inadvertently corrupt the value at the memory location causing undefined behavior or security issues through arbitrary code execution. Rust reference and lifetime rules enforced by the borrow checker in the compiler always ensure that a reference is valid before use. Rust borrow checker prevents a situation where a reference outlives the value it points to.</li>
				<li><strong class="bold">Buffer overflow</strong>: The<a id="_idIndexMarker409"/> program attempts to store a value in memory beyond the allocated range. This can corrupt data, cause a program to crash, or result in the execution of malicious code. Rust associates capacity with a buffer and performs bounds check on access. So, in safe Rust code, it is not possible to overflow a buffer. Rust will panic if you attempt to write out of bounds.</li>
				<li><strong class="bold">Uninitialized memory use</strong>: The program reads data from a buffer that was allocated but not initialized with <a id="_idIndexMarker410"/>values. This causes undefined behavior because the memory location can hold indeterminate values. Rust prevents reading from uninitialized memory.</li>
				<li><strong class="bold">Null pointer dereference</strong>: The program writes to memory with a null pointer, causing segmentation faults. A null pointer<a id="_idIndexMarker411"/> is not possible in safe Rust because Rust ensures that a reference does not outlive the value it refers to, and Rust's lifetime rules require functions manipulating references to declare how the references from input and output are linked, using lifetime annotations.</li>
			</ul>
			<p>We have thus seen how Rust achieves memory safety through its unique system of immutable-by-default variables, ownership rules, lifetimes, reference rules, and borrow-checker.</p>
			<p>With this, we conclude this section on the Rust memory management lifecycle. In the next section, we will implement a dynamic data structure in Rust.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor096"/>Implementing a dynamic data structure</h1>
			<p>In <a id="_idIndexMarker412"/>this section, we will enhance the template engine from <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, to add support for multiple template variables in one statement. We will achieve this by converting a static data structure into a dynamic data structure.</p>
			<p>We will refresh our memory with the model of the template engine shown in <em class="italic">Figure 5.7</em>:</p>
			<div><div><img src="img/Figure_5.7_B16405.jpg" alt="Figure 5.7 – Conceptual model of the template engine (from Chapter 3, Introduction to the Rust Standard Library and Key Crates for Systems Programming)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Conceptual model of the template engine (from <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, Introduction to the Rust Standard Library and Key Crates for Systems Programming)</p>
			<p>You will recall that we<a id="_idIndexMarker413"/> implemented a template engine in <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, to parse an input statement with a template variable and convert it into a dynamic HTML statement using context data provided. We will enhance the template variable feature in this section. We will first discuss the design changes and then implement the code changes.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Changes to the design of the template engine</h2>
			<p>In <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, we<a id="_idIndexMarker414"/> implemented the <strong class="bold">template variable</strong> content type, wherein the following was input at the command line:</p>
			<pre>&lt;p&gt; Hello {{name}} &lt;/p&gt;</pre>
			<p>This will generate the following HTML statement:</p>
			<pre>&lt;p&gt; Hello Bob &lt;/p&gt;</pre>
			<p>We provided the value of <code>name=Bob</code> as context data in the <code>main()</code> program.</p>
			<p>Let's enhance the feature for the <code>template variable</code> content type in this chapter. So far, our implementation works if there is <em class="italic">one</em> template variable. But if there is more than one template variable (as provided in the following example), it does not yet work.</p>
			<p>Our expectation is that the following code should work, assuming we provide the values of <code>city=Boston</code> and <code>name=Bob</code> as context data in the <code>main()</code> program:</p>
			<pre>&lt;p&gt; Hello {{name}}. Are you from {{city}}? &lt;/p&gt;</pre>
			<p>This will generate the following HTML statement:</p>
			<pre>&lt;p&gt; Hello Bob. Are you from Boston? &lt;/p&gt;</pre>
			<p>You will notice that there are two template variables in the input statement here—<code>name</code> and <code>city</code>. We will have to enhance our design to support this, starting with the <code>ExpressionData</code> struct, which<a id="_idIndexMarker415"/> stores the result of the parsing of the template-variable statement.</p>
			<p>Let's look at the data structure <code>ExpressionData</code>. We can start with the code from <code>Chapter03</code> located at <a href="https://github.com/PacktPublishing/Practical-System-programming-for-Rust-developers/tree/master/Chapter03">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter03</a>:</p>
			<pre>#[derive(PartialEq, Debug)]
pub struct <strong class="bold">ExpressionData</strong> {
    pub head: Option&lt;String&gt;,
    pub variable: String,
    pub tail: Option&lt;String&gt;,
}</pre>
			<p>In our implementation, the input value of <code>&lt;p&gt; Hello {{name}}. How are you? &lt;/p&gt;</code> will be tokenized into the <code>ExpressionData</code> struct as follows:</p>
			<pre>Head = Hello
Variable = name
Tail = How are you?</pre>
			<p>In the preceding design, we allowed the following format:</p>
			<pre>&lt;String literal&gt; &lt;template variable&gt; &lt;String literal&gt;</pre>
			<p>The string literal before the <code>template variable</code> was mapped to the <code>Head</code> field in <code>ExpressionData</code>, and the string literal after the <code>template variable</code> was mapped to the <code>Tail</code> field of <code>ExpressionData</code>.</p>
			<p>As you can see, we have made provision for only one <code>template variable</code> in the data structure (the <code>variable</code> field is of type <code>String</code>). In order to accommodate multiple <code>template variable</code> in a statement, we must alter the struct, to allow the <code>variable</code> field to store more than one <code>template variable</code> entry.</p>
			<p>In addition to allowing multiple template variables, we also need to accommodate a more flexible structure of input statements. In our current implementation, we accommodate one string literal before <code>template variable</code>, and one literal after it. But in the real world, an<a id="_idIndexMarker416"/> input statement can have any number of string literals, as shown in the following example:</p>
			<pre>&lt;p&gt; Hello , Hello {{name}}. Can you tell me if you are living 
    in {{city}}? For how long? &lt;/p&gt;</pre>
			<p>So, we have the following changes to make to our template engine:</p>
			<ul>
				<li>Allow for the parsing of more than one template variable per statement</li>
				<li>Allow for the parsing of more than two string literals in the input statement</li>
			</ul>
			<p>To allow for these changes, we have to redesign the <code>ExpressionData</code> struct. We also need to modify the methods that deal with <code>ExpressionData</code> to implement the parsing functionality for these two changes. </p>
			<p>Let's review the summary of changes to be made to the design, which is shown in <em class="italic">Figure 5.8</em>. This figure is from <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, but the components to be changed are highlighted in the figure:</p>
			<div><div><img src="img/Figure_5.8_B16405.jpg" alt="Figure 5.8 – Changes to the design of the template engine"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Changes to the design of the template engine</p>
			<p>In this subsection, we designed a dynamic data structure for the template engine we are building throughout several chapters of the book. In the next subsection, we will write the code to implement this.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Coding the dynamic data structure</h2>
			<p>As <a id="_idIndexMarker417"/>indicated in <em class="italic">Figure 5.7</em>, we will be modifying the following components of the template engine in this chapter:</p>
			<ul>
				<li>The <code>ExpressionData</code> struct</li>
				<li>The <code>get_expression_data()</code> function</li>
				<li>The <code>generate_html_template_var()</code> function</li>
				<li>The <code>main()</code> function</li>
			</ul>
			<p>We will start with the changes to the <code>ExpressionData</code> struct:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>#[derive(PartialEq, Debug, Clone)]
pub struct <strong class="bold">ExpressionData</strong> {
    pub expression: String,
    pub var_map: Vec&lt;String&gt;,
    pub gen_html: String,
}</pre>
			<p>We have fully revamped the structure of <code>ExpressionData</code>. It now has three fields. The descriptions of the <a id="_idIndexMarker418"/>fields are provided here:</p>
			<ul>
				<li><code>expression</code>: The expression input by the user is stored here.</li>
				<li><code>var_map</code>: Instead of a single <code>String</code> field as earlier, we now have a vector of strings to store <em class="italic">multiple template variables</em> in a statement. We have used a vector instead of the array because we do not know at compile time how many template variables there will be in the user input. For vectors, memory is allocated dynamically on the heap.</li>
				<li><code>gen_html</code>: The generated HTML statement corresponding to the input is stored here.<p class="callout-heading">What are dynamic data structures?</p><p class="callout"><code>ExpressionData</code> is an example of a dynamic data structure. It is dynamic because the memory allocation for the field <code>var_map</code> changes dynamically at runtime depending on how many <em class="italic">template variables</em> are present in the input, and the total length of the <em class="italic">expression</em> field (which is based on the count and length of the string literals in the input statement). Expression data is an example of a user-defined data structure that is associated with smart pointers as its field members contain dynamic values.</p></li>
			</ul>
			<p>Due to this<a id="_idIndexMarker420"/> change to the structure of <code>ExpressionData</code>, we have to alter the following two functions: <code>get_expression_data()</code> and <code>generate_html_template_var()</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>pub fn <strong class="bold">get_expression_data</strong>(input_line: &amp;str) -&gt; ExpressionData {
    let expression_iter = input_line.split_whitespace();
    let mut template_var_map: Vec&lt;String&gt; = vec![];
    for word in expression_iter {
        if check_symbol_string(word, "{{") &amp;&amp; 
            check_symbol_string(word, "}}") {
           <strong class="bold"> template_var_map.push(word.to_string());</strong>
        }
    }
    ExpressionData {
        expression: input_line.into(),
        var_map: template_var_map,
        gen_html: "".into(),
    }
}</pre>
			<p>In the preceding code, we are doing the following:</p>
			<ul>
				<li>Splitting the input statement into words separated by whitespace (<code>expression_iter</code>)</li>
				<li>Iterating through the words to parse only the template variables</li>
				<li>Adding the template variables to a vector of strings <code>template_var_map.push(word.to_string());</code></li>
				<li>Constructing <a id="_idIndexMarker421"/>the <code>ExpressionData</code> struct and returning from the function<p class="callout-heading">Dynamic memory allocation</p><p class="callout">In the preceding function, the following statement shows dynamic memory allocation:</p><p class="callout"><code>template_var_map.push(word.to_string());</code></p><p class="callout">This statement adds each template variable found in the input statement to a collection of vectors, which is then stored in the <code>ExpressionData</code> struct. Each <code>push()</code> statement on the vector is translated by the Rust Standard Library into a memory allocation—<code>ExpressionData</code> is a dynamic data structure. Likewise, when the variable of type <code>ExpressionData</code> goes out of scope, memory is deallocated for all the elements of the struct (including the vector of strings).</p></li>
			</ul>
			<p>We will now modify the function that generates HTML output:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/lib.rs</p>
			<pre>pub fn <strong class="bold">generate_html_template_var</strong>(
    content: &amp;mut ExpressionData,
    context: HashMap&lt;String, String&gt;,
) -&gt; &amp;mut ExpressionData {
    content.gen_html = content.expression.clone();
    for var in &amp;content.var_map {
        let (_h, i) = get_index_for_symbol(&amp;var, '{');
        let (_j, k) = get_index_for_symbol(&amp;var, '}');
        let var_without_braces = &amp;var[i + 2..k];
        let val = context.get(var_without_braces).unwrap();
        content.gen_html = content.gen_html.replace(var, val);
    }
    content
}</pre>
			<p>This function accepts two inputs—the <code>ExpressionData</code> type and the <code>context</code> HashMap. Let's understand the logic through an example. Let's also assume the following input values are passed to the function:</p>
			<ul>
				<li>The expression <a id="_idIndexMarker423"/>field of <code>content</code> has <code>&lt;p&gt; {{name}} {{city}} &lt;/p&gt;</code>. </li>
				<li>The following values are contained in the <code>var_map</code> field of <code>content</code>: <code>[{{name}},{{city}}]</code> </li>
				<li>The following context data is passed to the function in the <code>content</code> HashMap: <code>name=Bob</code> and <code>city=Boston</code>.</li>
			</ul>
			<p>Here is the processing that we perform in the function:</p>
			<ol>
				<li value="1">We iterate through the list of template variables contained in the <code>var_map</code> field of <code>content</code>.</li>
				<li>For each iteration, we first strip out the leading and trailing curly braces from the template variable values stored in the <code>var_map</code> field of <code>content</code>. So <code>{{name}}</code> becomes <code>name</code> and <code>{{city}}</code> becomes <code>city</code>. We then look them up in the <code>context</code> HashMap and retrieve the value (yielding <code>Bob</code> and <code>Boston</code>).</li>
				<li>The last step is to replace all instances of <code>{{name}}</code> in the input string with <code>Bob</code> and all instances of <code>{{city}}</code> with <code>Boston</code>. The resultant string is stored in the <code>gen_html</code> field of the <code>content</code> struct, which is of type <code>ExpressionData</code>.</li>
			</ol>
			<p>And finally, we will modify the <code>main()</code> function as follows. The main change in the <code>main()</code> function, compared to <a href="B16405_03_Final_NM_ePUB.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Introduction to the Rust Standard Library and Key Crates for Systems Programming</em>, is the change in the parameters to be passed to the <code>generate_hml_template_var()</code> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/main.rs</p>
			<pre>use std::collections::HashMap;
use std::io;
use std::io::BufRead;
use template_engine::*;
fn <strong class="bold">main()</strong> {
    let mut context: HashMap&lt;String, String&gt; = HashMap::new();
    context.insert("name".to_string(), "Bob".to_string());
    context.insert("city".to_string(), "Boston".to_string());
 
    for line in io::stdin().lock().lines() {
        match get_content_type(&amp;line.unwrap().clone()) {
            ContentType::TemplateVariable(mut content) =&gt; {
                let html = generate_html_template_var(&amp;mut 
                    content, context.clone());
                println!("{}", html.gen_html);
            }
            ContentType::Literal(text) =&gt; println!("{}", 
                text),
            ContentType::Tag(TagType::ForTag) =&gt; println!("For 
                Tag not implemented"),
            ContentType::Tag(TagType::IfTag) =&gt; println!("If 
                Tag not implemented"),
            ContentType::Unrecognized =&gt; println!(
                "Unrecognized input"),
        }
    }
}</pre>
			<p>With these changes, we<a id="_idIndexMarker424"/> can run the program with <code>cargo run</code>, and enter the following in the command line:</p>
			<pre>&lt;p&gt; Hello {{name}}. Are you from {{city}}? &lt;/p&gt;</pre>
			<p>You will see the following generated HTML statement displayed on your terminal:</p>
			<pre>&lt;p&gt; Hello Bob. Are you from Boston? &lt;/p&gt;</pre>
			<p>In this section, we converted the <code>ExpressionData</code> struct from a static to a dynamic data structure, and modified the associated functions to add the following features to the template engine:</p>
			<ul>
				<li>Allow for the parsing of more than one template variable per statement</li>
				<li>Allow for the parsing of more than two string literals in the input statement</li>
			</ul>
			<p>Now, let's end the chapter with a summary.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor099"/>Summary</h1>
			<p>In this chapter, we looked in depth at the memory layout of a standard process in the Linux environment, and then the memory layout of a Rust program. We compared the memory management lifecycle in different programming languages and how Rust takes a different approach to memory management. We learned how memory is allocated, manipulated, and released in a Rust program, and looked at the rules governing memory management in Rust, including ownership and reference rules. We looked at the different types of memory safety issues and how Rust prevents them from using its ownership model, lifetimes, reference rules, and borrow checker.</p>
			<p>We then returned to our template engine implementation example from <code>Chapter03</code> and added a couple of features to the template engine. We achieved this by converting a static data structure into a dynamic data structure and learned how memory is allocated dynamically. Dynamic data structures are very useful in programs that deal with external inputs, for example, in programs that accept incoming data from network sockets or file descriptors, where it is not known in advance what the size of incoming data will be, which is likely to be the case for most real-world complex programs that you will be writing using Rust over the course of your professional career.</p>
			<p>This concludes the memory management topic. In the next chapter, we will take a closer look at the Rust Standard Library modules that deal with file and directory operations.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor100"/>Further reading</h1>
			<p><strong class="bold">Understanding Ownership in Rust</strong>: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a></p>
		</div>
	</body></html>