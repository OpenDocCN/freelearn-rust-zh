<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-184"><em class="italic">Chapter 12</em>: <a id="_idTextAnchor194"/>Writing Unsafe Rust and FFI</h1>
			<p>In the previous chapter, we learned about the network primitives built into the Rust Standard Library and saw how to write programs that communicate over TCP and UDP. In this chapter, we will conclude the book by covering a few advanced topics related to <strong class="bold">unsafe Rust</strong> and <strong class="bold">foreign function interfaces</strong> (<strong class="bold">FFIs</strong>).</p>
			<p>We have seen how the Rust compiler enforces rules of ownership for memory and thread safety. While this is a blessing most of the time, there may be situations when you want to implement a new low-level data structure or call out to external programs written in other languages. Or, you may want to perform other operations prohibited by the Rust compiler, such as dereferencing raw pointers, mutating static variables, or dealing with uninitialized memory. Have you wondered how the Rust Standard Library itself makes system calls to manage resources, when system calls involve dealing with raw pointers? The answer lies in understanding unsafe Rust and FFIs.</p>
			<p>In this chapter, we'll first look at why and how Rust code bases use unsafe Rust code. Then, we'll cover the basics of FFIs and talk about special considerations while working with them. We'll also write Rust code that calls a C function, and a C program that calls a Rust function.</p>
			<p>We will cover these topics in the following order:</p>
			<ul>
				<li>Introducing unsafe Rust</li>
				<li>Introducing FFIs</li>
				<li>Reviewing guidelines for safe FFIs</li>
				<li>Calling Rust from C (project)</li>
				<li>Understanding the ABI</li>
			</ul>
			<p>By the end of this chapter, you will have learned when and how to use unsafe Rust. You will learn how to interface Rust to other programming languages, through FFIs, and learn how to work with them. You'll also get an overview of a few advanced topics, such as <strong class="bold">application binary interfaces</strong> (<strong class="bold">ABIs</strong>), conditional compilation, data layout conventions, and providing instructions to the linker. Understanding these will be helpful when building Rust binaries for different target platforms, and for linking Rust code with code written in other programming languages.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Technical requirements</h1>
			<p>Verify that <strong class="source-inline">rustup</strong>, <strong class="source-inline">rustc</strong>, and <strong class="source-inline">cargo</strong> have been installed correctly with the following command: </p>
			<p class="source-code">rustup --version</p>
			<p class="source-code">rustc --version </p>
			<p class="source-code">cargo --version</p>
			<p>Since this chapter involves compiling C code and generating a binary, you will need to set up the C development environment on your development machine. After setup, run the following command to verify that the installation is successful:</p>
			<p class="source-code">gcc --version</p>
			<p>If this command does not execute successfully, please revisit your installation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is recommended that those developing on a Windows platform use a Linux virtual machine to try out the code in this chapter.</p>
			<p class="callout">The code in this section has been tested on Ubuntu 20.04 (LTS) x64 and should work on any other Linux variant.</p>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12</a>.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor196"/>Introducing unsafe Rust</h1>
			<p>So far in this book, we've <a id="_idIndexMarker845"/>seen and used Rust language that enforces memory and type safety at compilation time and prevents various kinds of undefined behavior, such as memory overflows, null or invalid pointer constructions, and data races. This is <em class="italic">safe</em> Rust. In fact, the Rust Standard Library gives us good tools and utilities to write safe, idiomatic Rust, and helps to keep the program safe (and you sane!).</p>
			<p>But in some situations, the compiler can <em class="italic">get in the way</em>. The Rust compiler performs static analysis of code that is conservative (meaning the Rust compiler does not mind generating a few false positives and rejecting valid code, as long as it does not let bad code get through). You, as a programmer, know that a piece of code is safe, but the compiler thinks it is risky, so it rejects this code. This includes operations such as system calls, type coercions, and direct manipulations of memory pointers, which are used in the development of several categories of system software.</p>
			<p>Another example is in embedded systems where registers are accessed through a fixed memory address and require the dereferencing of pointers. So, to enable such actions, the Rust language provides the <strong class="source-inline">unsafe</strong> keyword. For Rust as a system programming language, it is essential to enable the programmer to have the means to write low-level code to interface directly with the <a id="_idIndexMarker846"/>operating system, bypassing the Rust Standard Library if needed. <em class="italic">This is unsafe Rust</em>. This is the part of the Rust language that does not adhere to the rules of the borrow checker.</p>
			<p>Unsafe Rust can be thought of as a superset of safe Rust. It is a superset because it allows you to do all the things you can do in standard Rust, but you can do more things that are otherwise prohibited by the Rust compiler. In fact, Rust's own compiler, and the standard library, include unsafe Rust code that is carefully written.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor197"/>How do you distinguish between safe and unsafe Rust code?</h2>
			<p>Rust provides a <a id="_idIndexMarker847"/>convenient and intuitive mechanism <a id="_idIndexMarker848"/>where a block of code can be enclosed within an unsafe block using the <strong class="source-inline">unsafe</strong> keyword. Try the following code:</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let num = 23;</p>
			<p class="source-code">    let borrowed_num = &amp;num; // immutable reference to num</p>
			<p class="source-code">    let raw_ptr = borrowed_num as *const i32; // cast the </p>
			<p class="source-code">    // reference borrowed_num to raw pointer</p>
			<p class="source-code">    assert!(*raw_ptr == 23);</p>
			<p class="source-code">}</p>
			<p>Compile this code with <strong class="source-inline">cargo check</strong> (or run it from Rust playground IDE). You'll see the following error message:</p>
			<p class="source-code"><strong class="bold">error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block</strong></p>
			<p>Let's now modify the code by enclosing the dereferencing of the raw pointer within an <strong class="source-inline">unsafe</strong> block:</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let num = 23;</p>
			<p class="source-code">    let borrowed_num = &amp;num; // immutable reference to num</p>
			<p class="source-code">    let raw_ptr = borrowed_num as *const i32; // cast </p>
			<p class="source-code">    // reference borrowed_num to raw pointer</p>
			<p class="source-code">    <strong class="bold">unsafe {</strong></p>
			<p class="source-code"><strong class="bold">        assert!(*raw_ptr == 23);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>You will see that the <a id="_idIndexMarker849"/>compilation is successful <a id="_idIndexMarker850"/>now, even though this code can potentially cause undefined behavior. This is because, once you enclose some code within an unsafe block, the compiler expects the programmer to ensure the safety of unsafe code.</p>
			<p>Let's now look at the kind of operations unsafe Rust enables.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Operations in unsafe Rust</h2>
			<p>There are really <a id="_idIndexMarker851"/>only five key operations in the <em class="italic">unsafe</em> category – dereferencing a <a id="_idIndexMarker852"/>raw pointer, working with mutable static variables, implementing unsafe traits, calling an external function through an FFI interface, and sharing union structs across FFI boundaries.</p>
			<p>We'll look at the first three in this section and the last two in the next section:</p>
			<ul>
				<li><strong class="bold">You can dereference a raw pointer</strong>: Unsafe <a id="_idIndexMarker853"/>Rust has two new types called <strong class="bold">raw pointers</strong> – <strong class="source-inline">*const T</strong> is a pointer <a id="_idIndexMarker854"/>type that corresponds <a id="_idIndexMarker855"/>to <strong class="source-inline">&amp;T</strong> (immutable reference type) in safe Rust, and <strong class="source-inline">*mut T</strong> is a pointer <a id="_idIndexMarker856"/>type that corresponds <a id="_idIndexMarker857"/>to <strong class="source-inline">&amp;mut T</strong> (mutable reference type in safe Rust). Unlike Rust reference types, these raw pointers can have both immutable and mutable pointers to a value at the same time or have multiple pointers simultaneously to the same value in memory. There is no automatic cleanup of memory when these pointers go out of scope, and these pointers can be null or refer to invalid memory locations too. The guarantees provided by Rust for memory safety do not apply to these pointer types. Examples of how to define and access pointers in an unsafe block are shown next:<p class="source-code">fn main() {</p><p class="source-code">    let mut a_number = 5;</p><p class="source-code">    // Create an immutable pointer to the value 5</p><p class="source-code">    let raw_ptr1 = &amp;a_number as *const i32;</p><p class="source-code">    // Create a mutable pointer to the value 5</p><p class="source-code">    let raw_ptr2 = &amp;mut a_number as *mut i32;</p><p class="source-code"> </p><p class="source-code">    unsafe {</p><p class="source-code">        println!("raw_ptr1 is: {}", *raw_ptr1);</p><p class="source-code">        println!("raw_ptr2 is: {}", *raw_ptr2);</p><p class="source-code">    }</p><p class="source-code">}</p><p>You'll note from this code that we've simultaneously created both an immutable reference and a mutable reference to the same value, by casting from the corresponding immutable and mutable reference types. Note that to create the raw pointers, we do not need an <strong class="source-inline">unsafe</strong> block, but only for dereferencing them. This is because dereferencing a raw pointer may result in unpredictable behavior as the borrow checker does not take responsibility for verifying its validity or lifetime.</p></li>
				<li><strong class="bold">Accessing or modifying a mutable static variable</strong>: Static variables have a fixed memory <a id="_idIndexMarker858"/>address and they can <a id="_idIndexMarker859"/>be marked as mutable. But if a <a id="_idIndexMarker860"/>static variable is marked <a id="_idIndexMarker861"/>as mutable, accessing and modifying it is an unsafe operation, and has to be enclosed in an <strong class="source-inline">unsafe</strong> block. In the example shown next, we are declaring a mutable static variable that is initialized with a default value for the number of threads to be spawned. Then, in the <strong class="source-inline">main()</strong> function, we are checking for an environment variable, which if specified will override the default. This override of the value in the static variable must be enclosed in an <em class="italic">unsafe</em> block:<p class="source-code">static mut THREAD_COUNT: u32 = 4;</p><p class="source-code">use std::env::var;</p><p class="source-code">fn change_thread_count(count: u32) {</p><p class="source-code">    unsafe {</p><p class="source-code">        THREAD_COUNT = count;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">fn main() {</p><p class="source-code">    if let Some(thread_count) = </p><p class="source-code">        var("THREAD_COUNT").ok() {</p><p class="source-code">        change_thread_count(thread_count.parse::</p><p class="source-code">            &lt;u32&gt;()</p><p class="source-code">            .unwrap());</p><p class="source-code">    };</p><p class="source-code">    unsafe {</p><p class="source-code">        println!("Thread count is: {}", THREAD_COUNT);</p><p class="source-code">    }</p><p class="source-code">}</p><p>This code snippet shows the declaration of a mutable static variable, <strong class="source-inline">THREAD_COUNT</strong>, initialized to <strong class="source-inline">4</strong>. When the <strong class="source-inline">main()</strong> function executes, it looks for an environmental variable with the name <strong class="source-inline">THREAD_COUNT</strong>. If the <strong class="source-inline">env</strong> variable is <a id="_idIndexMarker862"/>found, it calls the <strong class="source-inline">change_thread_count()</strong> function, which <a id="_idIndexMarker863"/>mutates the value of <a id="_idIndexMarker864"/>the static <a id="_idIndexMarker865"/>variable in an <strong class="source-inline">unsafe</strong> block. The <strong class="source-inline">main()</strong> function then prints out the value in an <strong class="source-inline">unsafe</strong> block.</p></li>
				<li><strong class="bold">Implementing an unsafe trait</strong>: Let's try to understand this with an example. Let's say we have a <a id="_idIndexMarker866"/>custom struct containing a raw <a id="_idIndexMarker867"/>pointer that we want to <em class="italic">send</em> or <em class="italic">share</em> across threads. Recall from <a href="B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150"><em class="italic">Chapter 9</em></a>, <em class="italic">Managing Concurrency</em>, that for a type to be sent or shared across threads, it needs to implement the <strong class="source-inline">Send</strong> or <strong class="source-inline">Sync</strong> traits. To implement these two traits for the raw pointer, we have to use unsafe Rust, as shown:<p class="source-code">struct MyStruct(*mut u16);</p><p class="source-code">unsafe impl Send for MyStruct {}</p><p class="source-code">unsafe impl Sync for MyStruct {}</p><p>The reason for the <strong class="source-inline">unsafe</strong> keyword is because raw pointers have untracked ownership, which then becomes the responsibility of the programmer to track and manage.</p></li>
			</ul>
			<p>There are two more features of unsafe Rust that are related to interfacing with other programming languages, which we will discuss in the next section on FFIs.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor199"/>Introducing FFIs</h1>
			<p>In this section, we'll <a id="_idIndexMarker868"/>understand what FFI is, and then see the two unsafe Rust features related to FFI.</p>
			<p>To understand FFI, let's look at the following two examples:</p>
			<ul>
				<li>There is a blazing-fast machine learning algorithm written in Rust for linear regression. A Java or Python developer wants to use this Rust library. How can this be done?</li>
				<li>You want to make Linux <strong class="bold">syscalls</strong> without using the Rust Standard Library (which essentially means you want to either implement a feature that's not available in the standard library or want to improve an existing feature). How would you do it?</li>
			</ul>
			<p>While there may be other ways to solve this problem, one popular method is to use FFI. </p>
			<p>In the first example, you can wrap the Rust library with an FFI defined in Java or Python. In the second example, Rust has a keyword, <strong class="source-inline">extern</strong>, with which an FFI to a C function can be set up and called. Let's see an example of the second case next:</p>
			<p class="source-code">use std::ffi::{CStr, CString};</p>
			<p class="source-code">use std::os::raw::c_char;</p>
			<p class="source-code">extern "C" {</p>
			<p class="source-code">    fn getenv(s: *const c_char) -&gt; *mut c_char;</p>
			<p class="source-code">}</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let c1 = CString::new("MY_VAR").expect("Error");</p>
			<p class="source-code">    unsafe {</p>
			<p class="source-code">        println!("env got is {:?}", CStr::from_ptr(getenv(</p>
			<p class="source-code">            c1.as_ptr())));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, in the <strong class="source-inline">main()</strong> function, we are invoking the <strong class="source-inline">getenv()</strong> external C function (instead of directly using the Rust Standard Library) to retrieve the value of the <strong class="source-inline">MY_VAR</strong> environment variable. The <strong class="source-inline">getenv()</strong> function accepts a <strong class="source-inline">*const c_char</strong> type parameter as input. To create this type, we are first instantiating the <strong class="source-inline">CString</strong> type, passing in the name of the environment variable, and then converting it into the required function input parameter type using the <strong class="source-inline">as_ptr()</strong> method. The <strong class="source-inline">getenv()</strong> function returns a <strong class="source-inline">*mut c_char</strong> type. To convert this into a Rust-compatible type, we are using the <strong class="source-inline">Cstr::from_ptr()</strong> function.</p>
			<p>Note the two main considerations here:</p>
			<ul>
				<li>We are specifying the call to the C function within an <strong class="source-inline">extern "C"</strong> block. This block contains the signature of the function that we want to call. Note that the data types in the function are not Rust data types, but those that belong to C.</li>
				<li>We are importing a couple of modules – <strong class="source-inline">std::ffi</strong> and <strong class="source-inline">std::os::raw</strong> – from the Rust <a id="_idIndexMarker869"/>Standard Library. The <strong class="source-inline">ffi</strong> module provides utility functions and data structures related to FFI bindings, which makes it easier to do data mapping across non-Rust interfaces. We are using the <strong class="source-inline">CString</strong> and <strong class="source-inline">CStr</strong> types from the <strong class="source-inline">ffi</strong> module, to transfer UTF-8 strings to and from C. The <strong class="source-inline">os::raw</strong> module contains platform-specific types that map to the C data types so that the Rust code that interacts with C will refer to the correct types. </li>
			</ul>
			<p>Now, let's run the program using the following: </p>
			<p class="source-code">MY_VAR="My custom value" cargo -v run --bin ffi</p>
			<p>You'll see the value of <strong class="source-inline">MY_VAR</strong> printed out to the console. With this, we have successfully retrieved the value of an environment variable using a call to an external C function.</p>
			<p>Recall that we learned how to get and set environment variables in previous chapters using the Rust Standard Library. Now we have done something similar, but this time using the Rust FFI interface to invoke a C library function. Note that the call to the C function is enclosed in an <strong class="source-inline">unsafe</strong> block.</p>
			<p>So far, we've seen how to invoke a C function from Rust. Later, in the <em class="italic">Calling Rust from C (project)</em> section, we'll see how to do it the other way around, that is, invoke a Rust function from C.</p>
			<p>Let's now take a look at another feature of unsafe Rust, which is to define and access fields of a union struct, for communicating with a C function across an FFI interface.</p>
			<p>Unions are data structures used in C, and are not memory-safe. This is because in a union type, you can set the instance of a <strong class="source-inline">union</strong> <a id="_idIndexMarker870"/>to one of the invariants and access it as another invariant. Rust does not directly provide <strong class="source-inline">union</strong> as a type in safe Rust. Rust, however, has a type <a id="_idIndexMarker871"/>of union called a <strong class="bold">tagged union</strong>, which is implemented as the <strong class="source-inline">enum</strong> data type in safe Rust. Let's see an example of <strong class="source-inline">union</strong>:</p>
			<p class="source-code">#[repr(C)]</p>
			<p class="source-code">union MyUnion {</p>
			<p class="source-code">    f1: u32,</p>
			<p class="source-code">    f2: f32,</p>
			<p class="source-code">}</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let float_num = MyUnion {f2: 2.0};</p>
			<p class="source-code">    let f = unsafe { float_num.f2 };</p>
			<p class="source-code">    println!("f is {:.3}",f);</p>
			<p class="source-code">}</p>
			<p>In the code shown, we are first using a <strong class="source-inline">repr(C)</strong> annotation, which tells the compiler that the order, size, and alignment of fields in the <strong class="source-inline">MyUnion</strong> union is what you would expect in the C language (we'll discuss more about <strong class="source-inline">repr(C)</strong> in the <em class="italic">Understanding the ABI </em>section). We're then defining two invariants of the union: one is an integer of type <strong class="source-inline">u32</strong> and the other is a float of type <strong class="source-inline">f32</strong>. For any given instance of this union, only one of these invariants is valid. In the code, we're creating an instance of this union, initializing it with a <strong class="source-inline">float</strong> invariant, and then accessing its value from the <strong class="source-inline">unsafe</strong> block. </p>
			<p>Run the program with the following:</p>
			<p class="source-code">cargo run </p>
			<p>You'll see the value <strong class="source-inline">f is 2.000</strong> printed to your terminal. So far, it looks right. Now, let's try to access the union as an integer, instead of a float type. To do this, just alter one line of code. Locate the following line:</p>
			<p class="source-code">let f = unsafe { float_num.f2 };</p>
			<p>Change it to the following:</p>
			<p class="source-code">let f = unsafe { float_num.f1 };</p>
			<p>Run the program again. This time, you won't get an error but you'll see an invalid value printed like this. The reason is that the value in the memory location pointed to is now being interpreted as an integer even though we had stored a float value:</p>
			<p class="source-code"><strong class="bold">f is 1073741824</strong></p>
			<p>Using unions in C is <a id="_idIndexMarker872"/>dangerous unless it is done with the utmost care, and Rust provides the ability to work with unions as part of unsafe Rust.</p>
			<p>So far, you've seen what unsafe Rust and FFI are. You've also seen examples of calling unsafe and external functions. In the next section, we'll discuss guidelines for creating safe FFI interfaces.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor200"/>Reviewing guidelines for safe FFIs</h1>
			<p>In this <a id="_idIndexMarker873"/>section, we'll look at a few guidelines to keep in mind <a id="_idIndexMarker874"/>while interfacing with other languages using FFI in Rust:</p>
			<ul>
				<li><strong class="bold">The extern keyword</strong>: Any foreign <a id="_idIndexMarker875"/>function defined with an <strong class="source-inline">extern</strong> keyword in Rust is inherently unsafe, and such calls must be done from an <strong class="source-inline">unsafe</strong> block.</li>
				<li><strong class="bold">Data layout</strong>: Rust does not provide guarantees on how data is laid out in memory, because it takes <a id="_idIndexMarker876"/>charge of allocations, reallocations, and deallocations. But when working with other (foreign) languages, explicit use of a C-compatible layout (using the <strong class="source-inline">#repr(C)</strong> annotation) is important to maintain memory safety. We've seen an example earlier of how to use this. Another thing to note is that only C-compatible types should be used as parameters or return values for external functions. Examples of C-compatible types in Rust include integers, floats, <strong class="source-inline">repr(C)</strong>-annotated structs, and pointers. Examples of Rust types incompatible with C include trait objects, dynamically sized types, and enums with fields. There are tools available such as <strong class="source-inline">rust-bindgen</strong> and <strong class="source-inline">cbindgen</strong> that can help in generating types that are compatible between Rust and C (with some caveats).</li>
				<li><strong class="bold">Platform-dependent types</strong>: C has many platform-dependent types, such as <strong class="source-inline">int</strong> and <strong class="source-inline">long</strong>, which means the <a id="_idIndexMarker877"/>exact length of these types vary based on the platform architecture. When interacting with C functions that use these types, the Rust Standard Library <strong class="source-inline">std::raw</strong> module can be used, which offers type aliases that are portable across platforms. <strong class="source-inline">c_char</strong> and <strong class="source-inline">c_uint</strong> are two examples of raw types we used in an example earlier. In addition to the standard library, the <strong class="source-inline">libc</strong> crate also provides such portable type aliases for these data types.</li>
				<li><strong class="bold">References and pointers</strong>: Due to differences between C's pointer types and Rust's reference types, Rust <a id="_idIndexMarker878"/>code should not use reference types but rather pointer types while working across FFI boundaries. Any Rust code that dereferences a pointer type must make null checks before use.</li>
				<li><strong class="bold">Memory management</strong>: Each programming <a id="_idIndexMarker879"/>language has its own way of doing memory management. When transmitting data between language boundaries, it is important to be clear about which language has the responsibility to release memory, to avoid <em class="italic">double-free</em> or <em class="italic">use-after-free</em> issues. It is recommended practice for Rust code to not implement the <strong class="source-inline">Drop</strong> trait for any type that is transmitted directly to foreign code. It is even safer to use only <strong class="source-inline">Copy</strong> types for use across FFI boundaries.</li>
				<li><strong class="bold">Panic</strong>: When calling Rust from other language code, it must be ensured that the Rust code does not <a id="_idIndexMarker880"/>panic, or it should use a panic-handling mechanism such as <strong class="source-inline">std::panic::catch_unwind</strong> or <strong class="source-inline">#[panic_handler]</strong> (which we saw in <a href="B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150"><em class="italic">Chapter 9</em></a>, <em class="italic">Managing</em> <em class="italic">Concurrency</em>). This will ensure that the Rust code will not abort or return in an unstable state.</li>
				<li><strong class="bold">Exposing a Rust library to a foreign language</strong>: Exposing a Rust library and its functions to a <a id="_idIndexMarker881"/>foreign language (such as Java, Python, or Ruby) should only be done through a C-compatible API. </li>
			</ul>
			<p>This concludes the section on writing safe FFI interfaces. In the next section, we'll see an example of using a Rust library from C code.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Calling Rust from C (project)</h1>
			<p>In this section, we will <a id="_idIndexMarker882"/>demonstrate the setup needed to <a id="_idIndexMarker883"/>build a Rust shared library (with a <strong class="source-inline">.so</strong> extension on Linux) incorporating an FFI interface and invoke it from a C program. The C program would be a simple program that just prints out a greeting message. The example is deliberately kept simple to enable you (as you're not expected to be familiar with complex C syntax) to focus on the steps involved, and for easy verification of this first FFI program in a variety of operating system environments.</p>
			<p>Here are the steps that we will go through to develop and test a working example of a C program that calls a function from a Rust library using the FFI interface:</p>
			<ol>
				<li value="1">Create a new Cargo lib project.</li>
				<li>Modify <strong class="source-inline">Cargo.toml</strong> to specify that we want a shared library to be built.</li>
				<li>Write an FFI in Rust (in the form of a C-compatible API).</li>
				<li>Build the Rust shared library.</li>
				<li>Verify whether the Rust shared library has been built correctly.</li>
				<li>Create a C program that invokes a function from the Rust shared library.</li>
				<li>Build the C program specifying the path of the Rust shared library.</li>
				<li>Set <strong class="source-inline">LD_LIBRARY_PATH</strong>.</li>
				<li>Run the C program.</li>
			</ol>
			<p>Let's get going and execute the aforementioned steps:</p>
			<ol>
				<li value="1">Create a new cargo project:<p class="source-code"><strong class="bold">cargo new --lib ffi &amp;&amp; cd ffi</strong></p></li>
				<li>Add the following to <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">[lib]</p><p class="source-code">name = "ffitest"</p><p class="source-code">crate-type = ["dylib"]</p></li>
				<li>Write <a id="_idIndexMarker884"/>an FFI in Rust <a id="_idIndexMarker885"/>in <strong class="source-inline">src/lib.rs</strong>:<p class="source-code">#[no_mangle]</p><p class="source-code">pub extern "C" fn see_ffi_in_action() {</p><p class="source-code">    println!("Congrats! You have successfully invoked </p><p class="source-code">        Rust shared library from a C program");</p><p class="source-code">}</p><p>The <strong class="source-inline">#[no_mangle]</strong> annotation tells the Rust compiler that the <strong class="source-inline">see_ffi_in_action()</strong> function should be accessible to external programs with the same name. Otherwise, by default, the Rust compiler alters it.</p><p>The function uses the <strong class="source-inline">extern "C"</strong> keyword. As discussed earlier, the Rust compiler makes any functions marked with <strong class="source-inline">extern</strong> compatible with C code. The <strong class="source-inline">"C"</strong> keyword in <strong class="source-inline">extern "C"</strong> indicates the standard C calling convention on the target platform. In this function, we are simply printing out a greeting.</p></li>
				<li>Build the Rust shared library from the <strong class="source-inline">ffi</strong> folder with the following command:<p class="source-code"><strong class="bold">cargo build --release</strong></p><p>If the build completes successfully, you'll see a shared library with the name <strong class="source-inline">libffitest.so</strong>, created in the <strong class="source-inline">target/release</strong> directory.</p></li>
				<li>Verify whether the shared library has been built correctly:<p class="source-code"><strong class="bold">nm -D target/release/libffitest.so | grep see_ffi_in_action</strong></p><p>The <strong class="source-inline">nm</strong> command-line utility is used to examine binary files (including libraries and executables) and view the symbols in these object files. Here, we are checking whether <a id="_idIndexMarker886"/>the function that we have written is included in <a id="_idIndexMarker887"/>the shared library. You should see a result similar to this:</p><p class="source-code"><strong class="bold">000000000005df30 T see_ffi_in_action</strong></p><p>If you don't see something similar, the shared library may not have been built correctly. Please revisit the previous steps. (Note that the shared library is created with a <strong class="source-inline">.dylib</strong> extension on the Mac platform.)</p></li>
				<li>Let's create a C program that invokes the function from the Rust shared library that we have built. Create a <strong class="source-inline">rustffi.c</strong> file in the root of the <strong class="source-inline">ffi</strong> project folder and add the following code:<p class="source-code">#include "rustffi.h"</p><p class="source-code">int main(void) {</p><p class="source-code">        see_ffi_in_action();</p><p class="source-code">}</p><p>This is a simple C program that includes a header file and has a <strong class="source-inline">main()</strong> function that in turn invokes a <strong class="source-inline">see_ffi_in_action()</strong> function. At this point, the C program does not know where this function is located. We'll provide this information to the C compiler when we build the binary. Let's now write the header file that's referred to in this program. Create a <strong class="source-inline">rustffi.h</strong> file in the same folder as the C source file, and include the following:</p><p class="source-code">void see_ffi_in_action();</p><p>This header file declares the function signature, which denotes that this function does not return any value or take any input parameter.</p></li>
				<li>Build the C binary with the following command, from the root folder of the project:<p class="source-code"><strong class="bold">gcc rustffi.c -Ltarget/release -lffitest -o ffitest</strong></p><p>Let's break up the command for better understanding:</p><p><strong class="source-inline">gcc</strong>: Invokes the GCC compiler.</p><p><strong class="source-inline">-Ltarget/release</strong>: The <strong class="source-inline">–L</strong> flag specifies to <a id="_idIndexMarker888"/>the compiler to look for <a id="_idIndexMarker889"/>the shared library in the folder target/release.</p><p><strong class="source-inline">-lffitest</strong>: The <strong class="source-inline">–l</strong> flag tells the compiler that the name of the shared library is <strong class="source-inline">ffitest</strong>. Note that the actual library built is called <strong class="source-inline">libffitest.so</strong>, but the compiler knows that the <strong class="source-inline">lib</strong> prefix and <strong class="source-inline">.so</strong> suffix are part of the standard shared library name, so it is sufficient to specify <strong class="source-inline">ffitest</strong> for the <strong class="source-inline">–l</strong> flag.</p><p><strong class="source-inline">rustffi.c</strong>: This is the source file to be compiled.</p><p><strong class="source-inline">-o ffitest</strong>: Tells the compiler to generate the output executable with the name <strong class="source-inline">ffitest</strong>.</p></li>
				<li>Set the <strong class="source-inline">LD_LIBRARY_PATH</strong> environment variable, which in Linux specifies the paths in which the libraries will be searched:<p class="source-code"><strong class="bold">export LD_LIBRARY_PATH=$(rustc --print sysroot)/lib:target/release:$LD_ LIBRARY_PATH</strong></p></li>
				<li>Run the executable with the following:<p class="source-code"><strong class="bold">./ffitest</strong></p></li>
			</ol>
			<p>You should see the following message displayed on your terminal:</p>
			<p class="source-code"><strong class="bold">Congrats! You have successfully invoked Rust shared library from a C program</strong></p>
			<p>If you have reached this far, congratulations!</p>
			<p>You have <a id="_idIndexMarker890"/>written a shared library in Rust that contains a function <a id="_idIndexMarker891"/>with a C-compatible API. You have then invoked this Rust library from a C program. This is FFI in action.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor202"/>Understanding the ABI</h1>
			<p>This section provides a brief <a id="_idIndexMarker892"/>introduction to the ABI and a few related (advanced) features of Rust that deal with conditional compilation options, data layout conventions, and link options.</p>
			<p>The <strong class="bold">ABI</strong> is a set of conventions and standards that compilers and linkers adhere to, for function-calling conventions, and for specifying data layouts (type, alignment, offset). </p>
			<p>To understand the significance of the ABI, let's draw an analogy with APIs, which are a well-known concept in application programming. When a program wants to access an external component or library at the source-code level, it looks for the definition of the API exposed by that external component. The external component can be a library or an external service accessible over the network. The API specifies the name of the functions that can be called, the parameters (along with their names and data types) that need to be passed to invoke the function, and the type of value returned from the function.</p>
			<p>An ABI can be seen as the equivalent of an API but at the binary level. The compiler and linker need a way to specify how a calling program can locate the called function within a binary object file, and how to deal with the arguments and return values (types and order of arguments and return type). But unlike source code, in the case of the binaries produced, details such as the length of integers, padding rules, and whether the function parameters are stored on the stack or registers vary by platform architecture (for example, x86, x64, AArch32) and operating system (for example, Linux and Windows). A 64-bit operating system can have different ABIs for executing 32-bit and 64-bit binaries. A Windows-based program will not know how to access a library built on Linux, as they use different ABIs.</p>
			<p>While the study of ABIs is a <a id="_idIndexMarker893"/>specialized topic in itself, it is sufficient to understand the significance of ABIs and see what features Rust provides to specify ABI-related parameters while writing code. We'll cover the following – <em class="italic">conditional compilation options</em>, <em class="italic">data layout conventions</em>, and <em class="italic">link options</em>:</p>
			<ul>
				<li><strong class="bold">Conditional compilation options</strong>: Rust allows <a id="_idIndexMarker894"/>specifying conditional compilation options using the <strong class="source-inline">cfg</strong> macro. The following are examples of <strong class="source-inline">cfg</strong> options:<p class="source-code">#[cfg(target_arch = "x86_64")]  </p><p class="source-code">#[cfg(target_os = "linux")] </p><p class="source-code">#[cfg(target_family = "windows")] </p><p class="source-code">#[cfg(target_env = "gnu")] </p><p class="source-code">#[cfg(target_pointer_width = "32")]</p><p>These annotations are attached to a function declaration as shown in this example:</p><p class="source-code">// Only if target OS is Linux and architecture is x86, </p><p class="source-code">// include this function in build </p><p class="source-code">#[cfg(all(target_os = "linux", target_arch = "x86"))] </p><p class="source-code">// all conditions must be true  </p><p class="source-code">fn do_something() { // ... }</p><p>More details about the various <a id="_idIndexMarker895"/>conditional compilation options can be found at <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">https://doc.rust-lang.org/reference/conditional-compilation.html</a>.</p></li>
				<li><strong class="bold">Data layout conventions</strong>: Apart from <a id="_idIndexMarker896"/>the platform and operating system considerations, data layout is another aspect that is <a id="_idIndexMarker897"/>important to understand, especially while transferring data across FFI boundaries.<p>In Rust, as in other languages, type, alignment, and offsets are associated with its data elements. For example, say you declare a struct of the following type:</p><p class="source-code">struct MyStruct {</p><p class="source-code">    member1: u16,</p><p class="source-code">    member2: u8,</p><p class="source-code">    member3: u32,</p><p class="source-code">}</p><p>It may be represented internally, as shown, on a processor with 32-bit (4-byte) word size:</p><p class="source-code">struct Mystruct {</p><p class="source-code">    member1: u16,</p><p class="source-code">    _padding1: [u8; 2], // to make overall size </p><p class="source-code">                        // multiple of 4</p><p class="source-code">    member2: u8,</p><p class="source-code">    _padding2: [u8; 3], // to align `member2`</p><p class="source-code">    member3: u32,</p><p class="source-code">}</p><p>This is done in order to reconcile the differences in the integer sizes with the processor word size. The idea is that the whole struct will have a size that's a multiple of 32 bits, and there may be multiple layout options to achieve this. This internal layout for Rust data structures can also be annotated as <strong class="source-inline">#[repr(Rust)]</strong>. But if there is data that needs to pass through an FFI boundary, the accepted standard is to use the data layout of C (annotated as <strong class="source-inline">#[repr(C)]</strong> ). In this layout, the order, size, and alignment of fields are as it is done in C programs. This is important to ensure the compatibility of data across the FFI boundary. </p><p>Rust <a id="_idIndexMarker898"/>guarantees that if the <strong class="source-inline">#[repr(C)]</strong> attribute is applied to a struct, the layout of the struct <a id="_idIndexMarker899"/>will be compatible with the platform's representation in C. There are automated tools, such as <strong class="source-inline">cbindgen</strong>, that can help generate the C data layout from Rust programs.</p></li>
				<li><strong class="bold">Link options</strong>: The <a id="_idIndexMarker900"/>third aspect we will cover regarding <a id="_idIndexMarker901"/>calling functions from other binaries is the <strong class="source-inline">link</strong> annotation. Take the following example:<p class="source-code">#[link(name = "my_library")]</p><p class="source-code">extern {</p><p class="source-code">    static a_c_function() -&gt; c_int;</p><p class="source-code">}</p><p>The <strong class="source-inline">#[link(...)]</strong> attribute is used to instruct the linker to link against <strong class="source-inline">my_library</strong>  in order to resolve the symbols. It instructs the Rust compiler how to link to native libraries. This annotation can also be used to specify the kind of library to link to (<em class="italic">static</em> or <em class="italic">dynamic</em>). The following annotation tells <strong class="source-inline">rustc</strong> to link to a <em class="italic">static</em> library with the name <strong class="source-inline">my_other_library</strong>:</p><p class="source-code">#[link(name = "my_other_library", kind = "static")]</p></li>
			</ul>
			<p>In this section, we've seen what an ABI is and its significance. We've also looked at how to specify instructions <a id="_idIndexMarker902"/>to t<a id="_idTextAnchor203"/>he compiler and linker through various annotations in code, for aspects such as the target platform, operating system, data layout, and link instructions.</p>
			<p>This concludes this section. The intent of this section was only to introduce a few advanced topics related to the ABI, FFI, and associated instructions to the compiler and linker. For more details, refer <a id="_idIndexMarker903"/>to the following link: <a href="https://doc.rust-lang.org/nomicon/">https://doc.rust-lang.org/nomicon/</a>.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor204"/>Summary</h1>
			<p>In this chapter, we reviewed the basics of unsafe Rust and understood the key differences between safe and unsafe Rust. We saw how unsafe Rust enables us to perform operations that would not be allowed in safe Rust, such as dereferencing raw pointers, accessing or mutating static variables, working with unions, implementing unsafe traits, and calling external functions. We also looked at what a foreign function interface is, and how to write one in Rust. We wrote an example of invoking a C function from Rust. Also, in the example project, we wrote a Rust shared library and invoked it from a C program. We saw guidelines for how to write safe FFIs in Rust. We took a look at the ABI and annotations that can be used to specify conditional compilation, data layout, and link options.</p>
			<p>With this, we conclude this chapter, and also this book.</p>
			<p>I thank you for joining me on this journey into the world of system programming with Rust, and wish you the very best with exploring the topic further.</p>
		</div>
	</body></html>