<html><head></head><body>
		<div><h1 id="_idParaDest-184"><em class="italic">Chapter 12</em>: <a id="_idTextAnchor194"/>Writing Unsafe Rust and FFI</h1>
			<p>In the previous chapter, we learned about the network primitives built into the Rust Standard Library and saw how to write programs that communicate over TCP and UDP. In this chapter, we will conclude the book by covering a few advanced topics related to <strong class="bold">unsafe Rust</strong> and <strong class="bold">foreign function interfaces</strong> (<strong class="bold">FFIs</strong>).</p>
			<p>We have seen how the Rust compiler enforces rules of ownership for memory and thread safety. While this is a blessing most of the time, there may be situations when you want to implement a new low-level data structure or call out to external programs written in other languages. Or, you may want to perform other operations prohibited by the Rust compiler, such as dereferencing raw pointers, mutating static variables, or dealing with uninitialized memory. Have you wondered how the Rust Standard Library itself makes system calls to manage resources, when system calls involve dealing with raw pointers? The answer lies in understanding unsafe Rust and FFIs.</p>
			<p>In this chapter, we'll first look at why and how Rust code bases use unsafe Rust code. Then, we'll cover the basics of FFIs and talk about special considerations while working with them. We'll also write Rust code that calls a C function, and a C program that calls a Rust function.</p>
			<p>We will cover these topics in the following order:</p>
			<ul>
				<li>Introducing unsafe Rust</li>
				<li>Introducing FFIs</li>
				<li>Reviewing guidelines for safe FFIs</li>
				<li>Calling Rust from C (project)</li>
				<li>Understanding the ABI</li>
			</ul>
			<p>By the end of this chapter, you will have learned when and how to use unsafe Rust. You will learn how to interface Rust to other programming languages, through FFIs, and learn how to work with them. You'll also get an overview of a few advanced topics, such as <strong class="bold">application binary interfaces</strong> (<strong class="bold">ABIs</strong>), conditional compilation, data layout conventions, and providing instructions to the linker. Understanding these will be helpful when building Rust binaries for different target platforms, and for linking Rust code with code written in other programming languages.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Technical requirements</h1>
			<p>Verify that <code>rustup</code>, <code>rustc</code>, and <code>cargo</code> have been installed correctly with the following command: </p>
			<pre>rustup --version
rustc --version 
cargo --version</pre>
			<p>Since this chapter involves compiling C code and generating a binary, you will need to set up the C development environment on your development machine. After setup, run the following command to verify that the installation is successful:</p>
			<pre>gcc --version</pre>
			<p>If this command does not execute successfully, please revisit your installation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is recommended that those developing on a Windows platform use a Linux virtual machine to try out the code in this chapter.</p>
			<p class="callout">The code in this section has been tested on Ubuntu 20.04 (LTS) x64 and should work on any other Linux variant.</p>
			<p>The Git repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter12</a>.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor196"/>Introducing unsafe Rust</h1>
			<p>So far in this book, we've <a id="_idIndexMarker845"/>seen and used Rust language that enforces memory and type safety at compilation time and prevents various kinds of undefined behavior, such as memory overflows, null or invalid pointer constructions, and data races. This is <em class="italic">safe</em> Rust. In fact, the Rust Standard Library gives us good tools and utilities to write safe, idiomatic Rust, and helps to keep the program safe (and you sane!).</p>
			<p>But in some situations, the compiler can <em class="italic">get in the way</em>. The Rust compiler performs static analysis of code that is conservative (meaning the Rust compiler does not mind generating a few false positives and rejecting valid code, as long as it does not let bad code get through). You, as a programmer, know that a piece of code is safe, but the compiler thinks it is risky, so it rejects this code. This includes operations such as system calls, type coercions, and direct manipulations of memory pointers, which are used in the development of several categories of system software.</p>
			<p>Another example is in embedded systems where registers are accessed through a fixed memory address and require the dereferencing of pointers. So, to enable such actions, the Rust language provides the <code>unsafe</code> keyword. For Rust as a system programming language, it is essential to enable the programmer to have the means to write low-level code to interface directly with the <a id="_idIndexMarker846"/>operating system, bypassing the Rust Standard Library if needed. <em class="italic">This is unsafe Rust</em>. This is the part of the Rust language that does not adhere to the rules of the borrow checker.</p>
			<p>Unsafe Rust can be thought of as a superset of safe Rust. It is a superset because it allows you to do all the things you can do in standard Rust, but you can do more things that are otherwise prohibited by the Rust compiler. In fact, Rust's own compiler, and the standard library, include unsafe Rust code that is carefully written.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor197"/>How do you distinguish between safe and unsafe Rust code?</h2>
			<p>Rust provides a <a id="_idIndexMarker847"/>convenient and intuitive mechanism <a id="_idIndexMarker848"/>where a block of code can be enclosed within an unsafe block using the <code>unsafe</code> keyword. Try the following code:</p>
			<pre>fn main() {
    let num = 23;
    let borrowed_num = &amp;num; // immutable reference to num
    let raw_ptr = borrowed_num as *const i32; // cast the 
    // reference borrowed_num to raw pointer
    assert!(*raw_ptr == 23);
}</pre>
			<p>Compile this code with <code>cargo check</code> (or run it from Rust playground IDE). You'll see the following error message:</p>
			<pre><strong class="bold">error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block</strong></pre>
			<p>Let's now modify the code by enclosing the dereferencing of the raw pointer within an <code>unsafe</code> block:</p>
			<pre>fn main() {
    let num = 23;
    let borrowed_num = &amp;num; // immutable reference to num
    let raw_ptr = borrowed_num as *const i32; // cast 
    // reference borrowed_num to raw pointer
    <strong class="bold">unsafe {</strong>
<strong class="bold">        assert!(*raw_ptr == 23);</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>You will see that the <a id="_idIndexMarker849"/>compilation is successful <a id="_idIndexMarker850"/>now, even though this code can potentially cause undefined behavior. This is because, once you enclose some code within an unsafe block, the compiler expects the programmer to ensure the safety of unsafe code.</p>
			<p>Let's now look at the kind of operations unsafe Rust enables.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Operations in unsafe Rust</h2>
			<p>There are really <a id="_idIndexMarker851"/>only five key operations in the <em class="italic">unsafe</em> category – dereferencing a <a id="_idIndexMarker852"/>raw pointer, working with mutable static variables, implementing unsafe traits, calling an external function through an FFI interface, and sharing union structs across FFI boundaries.</p>
			<p>We'll look at the first three in this section and the last two in the next section:</p>
			<ul>
				<li><code>*const T</code> is a pointer <a id="_idIndexMarker854"/>type that corresponds <a id="_idIndexMarker855"/>to <code>&amp;T</code> (immutable reference type) in safe Rust, and <code>*mut T</code> is a pointer <a id="_idIndexMarker856"/>type that corresponds <a id="_idIndexMarker857"/>to <code>&amp;mut T</code> (mutable reference type in safe Rust). Unlike Rust reference types, these raw pointers can have both immutable and mutable pointers to a value at the same time or have multiple pointers simultaneously to the same value in memory. There is no automatic cleanup of memory when these pointers go out of scope, and these pointers can be null or refer to invalid memory locations too. The guarantees provided by Rust for memory safety do not apply to these pointer types. Examples of how to define and access pointers in an unsafe block are shown next:<pre>fn main() {
    let mut a_number = 5;
    // Create an immutable pointer to the value 5
    let raw_ptr1 = &amp;a_number as *const i32;
    // Create a mutable pointer to the value 5
    let raw_ptr2 = &amp;mut a_number as *mut i32;
 
    unsafe {
        println!("raw_ptr1 is: {}", *raw_ptr1);
        println!("raw_ptr2 is: {}", *raw_ptr2);
    }
}</pre><p>You'll note from this code that we've simultaneously created both an immutable reference and a mutable reference to the same value, by casting from the corresponding immutable and mutable reference types. Note that to create the raw pointers, we do not need an <code>unsafe</code> block, but only for dereferencing them. This is because dereferencing a raw pointer may result in unpredictable behavior as the borrow checker does not take responsibility for verifying its validity or lifetime.</p></li>
				<li><code>unsafe</code> block. In the example shown next, we are declaring a mutable static variable that is initialized with a default value for the number of threads to be spawned. Then, in the <code>main()</code> function, we are checking for an environment variable, which if specified will override the default. This override of the value in the static variable must be enclosed in an <em class="italic">unsafe</em> block:<pre>static mut THREAD_COUNT: u32 = 4;
use std::env::var;
fn change_thread_count(count: u32) {
    unsafe {
        THREAD_COUNT = count;
    }
}
fn main() {
    if let Some(thread_count) = 
        var("THREAD_COUNT").ok() {
        change_thread_count(thread_count.parse::
            &lt;u32&gt;()
            .unwrap());
    };
    unsafe {
        println!("Thread count is: {}", THREAD_COUNT);
    }
}</pre><p>This code snippet shows the declaration of a mutable static variable, <code>THREAD_COUNT</code>, initialized to <code>4</code>. When the <code>main()</code> function executes, it looks for an environmental variable with the name <code>THREAD_COUNT</code>. If the <code>env</code> variable is <a id="_idIndexMarker862"/>found, it calls the <code>change_thread_count()</code> function, which <a id="_idIndexMarker863"/>mutates the value of <a id="_idIndexMarker864"/>the static <a id="_idIndexMarker865"/>variable in an <code>unsafe</code> block. The <code>main()</code> function then prints out the value in an <code>unsafe</code> block.</p></li>
				<li><code>Send</code> or <code>Sync</code> traits. To implement these two traits for the raw pointer, we have to use unsafe Rust, as shown:<pre>struct MyStruct(*mut u16);
unsafe impl Send for MyStruct {}
unsafe impl Sync for MyStruct {}</pre><p>The reason for the <code>unsafe</code> keyword is because raw pointers have untracked ownership, which then becomes the responsibility of the programmer to track and manage.</p></li>
			</ul>
			<p>There are two more features of unsafe Rust that are related to interfacing with other programming languages, which we will discuss in the next section on FFIs.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor199"/>Introducing FFIs</h1>
			<p>In this section, we'll <a id="_idIndexMarker868"/>understand what FFI is, and then see the two unsafe Rust features related to FFI.</p>
			<p>To understand FFI, let's look at the following two examples:</p>
			<ul>
				<li>There is a blazing-fast machine learning algorithm written in Rust for linear regression. A Java or Python developer wants to use this Rust library. How can this be done?</li>
				<li>You want to make Linux <strong class="bold">syscalls</strong> without using the Rust Standard Library (which essentially means you want to either implement a feature that's not available in the standard library or want to improve an existing feature). How would you do it?</li>
			</ul>
			<p>While there may be other ways to solve this problem, one popular method is to use FFI. </p>
			<p>In the first example, you can wrap the Rust library with an FFI defined in Java or Python. In the second example, Rust has a keyword, <code>extern</code>, with which an FFI to a C function can be set up and called. Let's see an example of the second case next:</p>
			<pre>use std::ffi::{CStr, CString};
use std::os::raw::c_char;
extern "C" {
    fn getenv(s: *const c_char) -&gt; *mut c_char;
}
fn main() {
    let c1 = CString::new("MY_VAR").expect("Error");
    unsafe {
        println!("env got is {:?}", CStr::from_ptr(getenv(
            c1.as_ptr())));
    }
}</pre>
			<p>Here, in the <code>main()</code> function, we are invoking the <code>getenv()</code> external C function (instead of directly using the Rust Standard Library) to retrieve the value of the <code>MY_VAR</code> environment variable. The <code>getenv()</code> function accepts a <code>*const c_char</code> type parameter as input. To create this type, we are first instantiating the <code>CString</code> type, passing in the name of the environment variable, and then converting it into the required function input parameter type using the <code>as_ptr()</code> method. The <code>getenv()</code> function returns a <code>*mut c_char</code> type. To convert this into a Rust-compatible type, we are using the <code>Cstr::from_ptr()</code> function.</p>
			<p>Note the two main considerations here:</p>
			<ul>
				<li>We are specifying the call to the C function within an <code>extern "C"</code> block. This block contains the signature of the function that we want to call. Note that the data types in the function are not Rust data types, but those that belong to C.</li>
				<li>We are importing a couple of modules – <code>std::ffi</code> and <code>std::os::raw</code> – from the Rust <a id="_idIndexMarker869"/>Standard Library. The <code>ffi</code> module provides utility functions and data structures related to FFI bindings, which makes it easier to do data mapping across non-Rust interfaces. We are using the <code>CString</code> and <code>CStr</code> types from the <code>ffi</code> module, to transfer UTF-8 strings to and from C. The <code>os::raw</code> module contains platform-specific types that map to the C data types so that the Rust code that interacts with C will refer to the correct types. </li>
			</ul>
			<p>Now, let's run the program using the following: </p>
			<pre>MY_VAR="My custom value" cargo -v run --bin ffi</pre>
			<p>You'll see the value of <code>MY_VAR</code> printed out to the console. With this, we have successfully retrieved the value of an environment variable using a call to an external C function.</p>
			<p>Recall that we learned how to get and set environment variables in previous chapters using the Rust Standard Library. Now we have done something similar, but this time using the Rust FFI interface to invoke a C library function. Note that the call to the C function is enclosed in an <code>unsafe</code> block.</p>
			<p>So far, we've seen how to invoke a C function from Rust. Later, in the <em class="italic">Calling Rust from C (project)</em> section, we'll see how to do it the other way around, that is, invoke a Rust function from C.</p>
			<p>Let's now take a look at another feature of unsafe Rust, which is to define and access fields of a union struct, for communicating with a C function across an FFI interface.</p>
			<p>Unions are data structures used in C, and are not memory-safe. This is because in a union type, you can set the instance of a <code>union</code> <a id="_idIndexMarker870"/>to one of the invariants and access it as another invariant. Rust does not directly provide <code>union</code> as a type in safe Rust. Rust, however, has a type <a id="_idIndexMarker871"/>of union called a <code>enum</code> data type in safe Rust. Let's see an example of <code>union</code>:</p>
			<pre>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
fn main() {
    let float_num = MyUnion {f2: 2.0};
    let f = unsafe { float_num.f2 };
    println!("f is {:.3}",f);
}</pre>
			<p>In the code shown, we are first using a <code>repr(C)</code> annotation, which tells the compiler that the order, size, and alignment of fields in the <code>MyUnion</code> union is what you would expect in the C language (we'll discuss more about <code>repr(C)</code> in the <em class="italic">Understanding the ABI </em>section). We're then defining two invariants of the union: one is an integer of type <code>u32</code> and the other is a float of type <code>f32</code>. For any given instance of this union, only one of these invariants is valid. In the code, we're creating an instance of this union, initializing it with a <code>float</code> invariant, and then accessing its value from the <code>unsafe</code> block. </p>
			<p>Run the program with the following:</p>
			<pre>cargo run </pre>
			<p>You'll see the value <code>f is 2.000</code> printed to your terminal. So far, it looks right. Now, let's try to access the union as an integer, instead of a float type. To do this, just alter one line of code. Locate the following line:</p>
			<pre>let f = unsafe { float_num.f2 };</pre>
			<p>Change it to the following:</p>
			<pre>let f = unsafe { float_num.f1 };</pre>
			<p>Run the program again. This time, you won't get an error but you'll see an invalid value printed like this. The reason is that the value in the memory location pointed to is now being interpreted as an integer even though we had stored a float value:</p>
			<pre><strong class="bold">f is 1073741824</strong></pre>
			<p>Using unions in C is <a id="_idIndexMarker872"/>dangerous unless it is done with the utmost care, and Rust provides the ability to work with unions as part of unsafe Rust.</p>
			<p>So far, you've seen what unsafe Rust and FFI are. You've also seen examples of calling unsafe and external functions. In the next section, we'll discuss guidelines for creating safe FFI interfaces.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor200"/>Reviewing guidelines for safe FFIs</h1>
			<p>In this <a id="_idIndexMarker873"/>section, we'll look at a few guidelines to keep in mind <a id="_idIndexMarker874"/>while interfacing with other languages using FFI in Rust:</p>
			<ul>
				<li><code>extern</code> keyword in Rust is inherently unsafe, and such calls must be done from an <code>unsafe</code> block.</li>
				<li><code>#repr(C)</code> annotation) is important to maintain memory safety. We've seen an example earlier of how to use this. Another thing to note is that only C-compatible types should be used as parameters or return values for external functions. Examples of C-compatible types in Rust include integers, floats, <code>repr(C)</code>-annotated structs, and pointers. Examples of Rust types incompatible with C include trait objects, dynamically sized types, and enums with fields. There are tools available such as <code>rust-bindgen</code> and <code>cbindgen</code> that can help in generating types that are compatible between Rust and C (with some caveats).</li>
				<li><code>int</code> and <code>long</code>, which means the <a id="_idIndexMarker877"/>exact length of these types vary based on the platform architecture. When interacting with C functions that use these types, the Rust Standard Library <code>std::raw</code> module can be used, which offers type aliases that are portable across platforms. <code>c_char</code> and <code>c_uint</code> are two examples of raw types we used in an example earlier. In addition to the standard library, the <code>libc</code> crate also provides such portable type aliases for these data types.</li>
				<li><strong class="bold">References and pointers</strong>: Due to differences between C's pointer types and Rust's reference types, Rust <a id="_idIndexMarker878"/>code should not use reference types but rather pointer types while working across FFI boundaries. Any Rust code that dereferences a pointer type must make null checks before use.</li>
				<li><code>Drop</code> trait for any type that is transmitted directly to foreign code. It is even safer to use only <code>Copy</code> types for use across FFI boundaries.</li>
				<li><code>std::panic::catch_unwind</code> or <code>#[panic_handler]</code> (which we saw in <a href="B16405_09_Final_NM_ePUB.xhtml#_idTextAnchor150"><em class="italic">Chapter 9</em></a>, <em class="italic">Managing</em> <em class="italic">Concurrency</em>). This will ensure that the Rust code will not abort or return in an unstable state.</li>
				<li><strong class="bold">Exposing a Rust library to a foreign language</strong>: Exposing a Rust library and its functions to a <a id="_idIndexMarker881"/>foreign language (such as Java, Python, or Ruby) should only be done through a C-compatible API. </li>
			</ul>
			<p>This concludes the section on writing safe FFI interfaces. In the next section, we'll see an example of using a Rust library from C code.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Calling Rust from C (project)</h1>
			<p>In this section, we will <a id="_idIndexMarker882"/>demonstrate the setup needed to <a id="_idIndexMarker883"/>build a Rust shared library (with a <code>.so</code> extension on Linux) incorporating an FFI interface and invoke it from a C program. The C program would be a simple program that just prints out a greeting message. The example is deliberately kept simple to enable you (as you're not expected to be familiar with complex C syntax) to focus on the steps involved, and for easy verification of this first FFI program in a variety of operating system environments.</p>
			<p>Here are the steps that we will go through to develop and test a working example of a C program that calls a function from a Rust library using the FFI interface:</p>
			<ol>
				<li value="1">Create a new Cargo lib project.</li>
				<li>Modify <code>Cargo.toml</code> to specify that we want a shared library to be built.</li>
				<li>Write an FFI in Rust (in the form of a C-compatible API).</li>
				<li>Build the Rust shared library.</li>
				<li>Verify whether the Rust shared library has been built correctly.</li>
				<li>Create a C program that invokes a function from the Rust shared library.</li>
				<li>Build the C program specifying the path of the Rust shared library.</li>
				<li>Set <code>LD_LIBRARY_PATH</code>.</li>
				<li>Run the C program.</li>
			</ol>
			<p>Let's get going and execute the aforementioned steps:</p>
			<ol>
				<li value="1">Create a new cargo project:<pre><strong class="bold">cargo new --lib ffi &amp;&amp; cd ffi</strong></pre></li>
				<li>Add the following to <code>Cargo.toml</code>:<pre>[lib]
name = "ffitest"
crate-type = ["dylib"]</pre></li>
				<li>Write <a id="_idIndexMarker884"/>an FFI in Rust <a id="_idIndexMarker885"/>in <code>src/lib.rs</code>:<pre>#[no_mangle]
pub extern "C" fn see_ffi_in_action() {
    println!("Congrats! You have successfully invoked 
        Rust shared library from a C program");
}</pre><p>The <code>#[no_mangle]</code> annotation tells the Rust compiler that the <code>see_ffi_in_action()</code> function should be accessible to external programs with the same name. Otherwise, by default, the Rust compiler alters it.</p><p>The function uses the <code>extern "C"</code> keyword. As discussed earlier, the Rust compiler makes any functions marked with <code>extern</code> compatible with C code. The <code>"C"</code> keyword in <code>extern "C"</code> indicates the standard C calling convention on the target platform. In this function, we are simply printing out a greeting.</p></li>
				<li>Build the Rust shared library from the <code>ffi</code> folder with the following command:<pre><code>libffitest.so</code>, created in the <code>target/release</code> directory.</p></li>
				<li>Verify whether the shared library has been built correctly:<pre><code>nm</code> command-line utility is used to examine binary files (including libraries and executables) and view the symbols in these object files. Here, we are checking whether <a id="_idIndexMarker886"/>the function that we have written is included in <a id="_idIndexMarker887"/>the shared library. You should see a result similar to this:</p><pre><code>.dylib</code> extension on the Mac platform.)</p></li>
				<li>Let's create a C program that invokes the function from the Rust shared library that we have built. Create a <code>rustffi.c</code> file in the root of the <code>ffi</code> project folder and add the following code:<pre>#include "rustffi.h"
int main(void) {
        see_ffi_in_action();
}</pre><p>This is a simple C program that includes a header file and has a <code>main()</code> function that in turn invokes a <code>see_ffi_in_action()</code> function. At this point, the C program does not know where this function is located. We'll provide this information to the C compiler when we build the binary. Let's now write the header file that's referred to in this program. Create a <code>rustffi.h</code> file in the same folder as the C source file, and include the following:</p><pre>void see_ffi_in_action();</pre><p>This header file declares the function signature, which denotes that this function does not return any value or take any input parameter.</p></li>
				<li>Build the C binary with the following command, from the root folder of the project:<pre><code>gcc</code>: Invokes the GCC compiler.</p><p><code>-Ltarget/release</code>: The <code>–L</code> flag specifies to <a id="_idIndexMarker888"/>the compiler to look for <a id="_idIndexMarker889"/>the shared library in the folder target/release.</p><p><code>-lffitest</code>: The <code>–l</code> flag tells the compiler that the name of the shared library is <code>ffitest</code>. Note that the actual library built is called <code>libffitest.so</code>, but the compiler knows that the <code>lib</code> prefix and <code>.so</code> suffix are part of the standard shared library name, so it is sufficient to specify <code>ffitest</code> for the <code>–l</code> flag.</p><p><code>rustffi.c</code>: This is the source file to be compiled.</p><p><code>-o ffitest</code>: Tells the compiler to generate the output executable with the name <code>ffitest</code>.</p></li>
				<li>Set the <code>LD_LIBRARY_PATH</code> environment variable, which in Linux specifies the paths in which the libraries will be searched:<pre><strong class="bold">export LD_LIBRARY_PATH=$(rustc --print sysroot)/lib:target/release:$LD_ LIBRARY_PATH</strong></pre></li>
				<li>Run the executable with the following:<pre><strong class="bold">./ffitest</strong></pre></li>
			</ol>
			<p>You should see the following message displayed on your terminal:</p>
			<pre><strong class="bold">Congrats! You have successfully invoked Rust shared library from a C program</strong></pre>
			<p>If you have reached this far, congratulations!</p>
			<p>You have <a id="_idIndexMarker890"/>written a shared library in Rust that contains a function <a id="_idIndexMarker891"/>with a C-compatible API. You have then invoked this Rust library from a C program. This is FFI in action.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor202"/>Understanding the ABI</h1>
			<p>This section provides a brief <a id="_idIndexMarker892"/>introduction to the ABI and a few related (advanced) features of Rust that deal with conditional compilation options, data layout conventions, and link options.</p>
			<p>The <strong class="bold">ABI</strong> is a set of conventions and standards that compilers and linkers adhere to, for function-calling conventions, and for specifying data layouts (type, alignment, offset). </p>
			<p>To understand the significance of the ABI, let's draw an analogy with APIs, which are a well-known concept in application programming. When a program wants to access an external component or library at the source-code level, it looks for the definition of the API exposed by that external component. The external component can be a library or an external service accessible over the network. The API specifies the name of the functions that can be called, the parameters (along with their names and data types) that need to be passed to invoke the function, and the type of value returned from the function.</p>
			<p>An ABI can be seen as the equivalent of an API but at the binary level. The compiler and linker need a way to specify how a calling program can locate the called function within a binary object file, and how to deal with the arguments and return values (types and order of arguments and return type). But unlike source code, in the case of the binaries produced, details such as the length of integers, padding rules, and whether the function parameters are stored on the stack or registers vary by platform architecture (for example, x86, x64, AArch32) and operating system (for example, Linux and Windows). A 64-bit operating system can have different ABIs for executing 32-bit and 64-bit binaries. A Windows-based program will not know how to access a library built on Linux, as they use different ABIs.</p>
			<p>While the study of ABIs is a <a id="_idIndexMarker893"/>specialized topic in itself, it is sufficient to understand the significance of ABIs and see what features Rust provides to specify ABI-related parameters while writing code. We'll cover the following – <em class="italic">conditional compilation options</em>, <em class="italic">data layout conventions</em>, and <em class="italic">link options</em>:</p>
			<ul>
				<li><code>cfg</code> macro. The following are examples of <code>cfg</code> options:<pre>#[cfg(target_arch = "x86_64")]  
#[cfg(target_os = "linux")] 
#[cfg(target_family = "windows")] 
#[cfg(target_env = "gnu")] 
#[cfg(target_pointer_width = "32")]</pre><p>These annotations are attached to a function declaration as shown in this example:</p><pre>// Only if target OS is Linux and architecture is x86, 
// include this function in build 
#[cfg(all(target_os = "linux", target_arch = "x86"))] 
// all conditions must be true  
fn do_something() { // ... }</pre><p>More details about the various <a id="_idIndexMarker895"/>conditional compilation options can be found at <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">https://doc.rust-lang.org/reference/conditional-compilation.html</a>.</p></li>
				<li><code>#[repr(Rust)]</code>. But if there is data that needs to pass through an FFI boundary, the accepted standard is to use the data layout of C (annotated as <code>#[repr(C)]</code> ). In this layout, the order, size, and alignment of fields are as it is done in C programs. This is important to ensure the compatibility of data across the FFI boundary. </p><p>Rust <a id="_idIndexMarker898"/>guarantees that if the <code>#[repr(C)]</code> attribute is applied to a struct, the layout of the struct <a id="_idIndexMarker899"/>will be compatible with the platform's representation in C. There are automated tools, such as <code>cbindgen</code>, that can help generate the C data layout from Rust programs.</p></li>
				<li><code>link</code> annotation. Take the following example:<pre>#[link(name = "my_library")]
extern {
    static a_c_function() -&gt; c_int;
}</pre><p>The <code>#[link(...)]</code> attribute is used to instruct the linker to link against <code>my_library</code>  in order to resolve the symbols. It instructs the Rust compiler how to link to native libraries. This annotation can also be used to specify the kind of library to link to (<em class="italic">static</em> or <em class="italic">dynamic</em>). The following annotation tells <code>rustc</code> to link to a <em class="italic">static</em> library with the name <code>my_other_library</code>:</p><pre>#[link(name = "my_other_library", kind = "static")]</pre></li>
			</ul>
			<p>In this section, we've seen what an ABI is and its significance. We've also looked at how to specify instructions <a id="_idIndexMarker902"/>to t<a id="_idTextAnchor203"/>he compiler and linker through various annotations in code, for aspects such as the target platform, operating system, data layout, and link instructions.</p>
			<p>This concludes this section. The intent of this section was only to introduce a few advanced topics related to the ABI, FFI, and associated instructions to the compiler and linker. For more details, refer <a id="_idIndexMarker903"/>to the following link: <a href="https://doc.rust-lang.org/nomicon/">https://doc.rust-lang.org/nomicon/</a>.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor204"/>Summary</h1>
			<p>In this chapter, we reviewed the basics of unsafe Rust and understood the key differences between safe and unsafe Rust. We saw how unsafe Rust enables us to perform operations that would not be allowed in safe Rust, such as dereferencing raw pointers, accessing or mutating static variables, working with unions, implementing unsafe traits, and calling external functions. We also looked at what a foreign function interface is, and how to write one in Rust. We wrote an example of invoking a C function from Rust. Also, in the example project, we wrote a Rust shared library and invoked it from a C program. We saw guidelines for how to write safe FFIs in Rust. We took a look at the ABI and annotations that can be used to specify conditional compilation, data layout, and link options.</p>
			<p>With this, we conclude this chapter, and also this book.</p>
			<p>I thank you for joining me on this journey into the world of system programming with Rust, and wish you the very best with exploring the topic further.</p>
		</div>
	</body></html>