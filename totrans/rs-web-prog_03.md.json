["```rs\ncargo new web_app\n```", "```rs\n└── web_app\n    ├── Cargo.toml\n    └── src\n         └── main.rs\n```", "```rs\n[dependencies]\nactix-web = \"4.0.1\"\n```", "```rs\nuse actix_web::{web, App, HttpServer, Responder, \n                HttpRequest};\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = \n        req.match_info().get(\"name\").unwrap_or(\"World\");\n    format!(\"Hello {}!\", name)\n}\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n        .route(\"/\", web::get().to(greet))\n        .route(\"/{name}\", web::get().to(greet))\n        .route(\"/say/hello\", web::get().to(|| \n                    async { \"Hello Again!\" }))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n```", "```rs\ncargo run\n```", "```rs\nFinished dev [unoptimized + debuginfo] target(s) in 0.21s\n Running `target/debug/web_app`\n```", "```rs\nfn main() {\n    let test_closure = |string_input| {\n        println!(\"{}\", string_input);\n    };\n    test_closure(\"test\");\n}\n```", "```rs\ntest\n```", "```rs\n    test_closure(\"test\");\n    test_closure(23);\n```", "```rs\n7 |     test_closure(23);\n  |                  ^^ expected `&str`, found integer\n```", "```rs\nfn main() {\n    {\n        let test_closure = |string_input| {\n            println!(\"{}\", string_input);\n            };\n    }\n    test_closure(\"test\");\n}\n```", "```rs\nfn main() {\n    let another_str = \"case\";\n    let test_closure = |string_input| {\n        println!(\"{} {}\", string_input, another_str);\n    };\n    test_closure(\"test\");\n}\n```", "```rs\ntest case\n```", "```rs\nlet test_closure = move |string_input| {\n    println!(\"{} {}\", string_input, another_str);\n};\n```", "```rs\nfn add_doubles(closure: fn(i32) -> i32, \n               one: i32, two: i32) -> i32 {\n    return closure(one) + closure(two)\n}\nfn main() {\n    let closure = |int_input| {\n        return int_input * 2\n    };\n    let outcome = add_doubles(closure, 2, 3);\n    println!(\"{}\", outcome);\n}\n```", "```rs\nfn add_doubles(closure: Box<dyn Fn(i32) -> i32>, \n               one: i32, two: i32) -> i32 {\n    return closure(one) + closure(two)\n}\nfn main() {\n    let one = 2;\n    let closure = move |int_input| {\n        return int_input * one\n    };\n    let outcome = add_doubles(Box::new(closure), 2, 3);\n    println!(\"{}\", outcome);\n}\n```", "```rs\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new()\n        .route(\"/\", web::get().to(greet))\n        .route(\"/{name}\", web::get().to(greet))\n        .route(\"/say/hello\", web::get().to(\n        || async { \"Hello Again!\" }))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n```", "```rs\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        println!(\"http server factory is firing\");\n        App::new()\n        .route(\"/\", web::get().to(greet))\n        .route(\"/{name}\", web::get().to(greet))\n        .route(\"/say/hello\", web::get().to(\n               || async { \"Hello Again!\" }))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .workers(3)\n    .run()\n    .await\n}\n```", "```rs\n    Finished dev [unoptimized + debuginfo] target(s) in \n    2.45s\n     Running `target/debug/web_app`\nhttp server factory is firing\nhttp server factory is firing\nhttp server factory is firing\n```", "```rs\nuse std::{thread, time};\nfn do_something(number: i8) -> i8 {\n    println!(\"number {} is running\", number);\n    let two_seconds = time::Duration::new(2, 0);\n    thread::sleep(two_seconds);\n    return 2\n}\nfn main() {\n    let now = time::Instant::now();\n    let one: i8 = do_something(1);\n    let two: i8 = do_something(2);\n    let three: i8 = do_something(3);\n    println!(\"time elapsed {:?}\", now.elapsed());\n    println!(\"result {}\", one + two + three);\n}\n```", "```rs\nnumber 1 is running\nnumber 2 is running\nnumber 3 is running\ntime elapsed 6.0109845s\nresult 6\n```", "```rs\nuse std::thread::JoinHandle;\n```", "```rs\nlet now = time::Instant::now();\nlet thread_one: JoinHandle<i8> = thread::spawn(\n    || do_something(1));\nlet thread_two: JoinHandle<i8> = thread::spawn(\n    || do_something(2));\nlet thread_three: JoinHandle<i8> = thread::spawn(\n    || do_something(3));\nlet result_one = thread_one.join();\nlet result_two = thread_two.join();\nlet result_three = thread_three.join();\nprintln!(\"time elapsed {:?}\", now.elapsed());\nprintln!(\"result {}\", result_one.unwrap() +\n          result_two.unwrap() + result_three.unwrap());\n```", "```rs\nnumber 1 is running\nnumber 3 is running\nnumber 2 is running\ntime elapsed 2.002991041s\nresult 6\n```", "```rs\nmatch thread_result {\n    Ok(result) => {\n        println!(\"the result for {} is {}\", \n                  result, name);\n    }\n    Err(result) => {\n    if let Some(string) = result.downcast_ref::<String>() {\n        println!(\"the error for {} is: {}\", name, string);\n    } else {\n        println!(\"there error for {} does not have a \n                  message\", name);\n        }\n    }\n}\n```", "```rs\n[dependencies]\nfutures = \"0.3.21\"\n```", "```rs\nuse futures::executor::block_on;\nuse std::{thread, time};\n```", "```rs\nasync fn do_something(number: i8) -> i8 {\n    println!(\"number {} is running\", number);\n    let two_seconds = time::Duration::new(2, 0);\n    thread::sleep(two_seconds);\n    return 2\n}\n```", "```rs\nfn main() {\n    let now = time::Instant::now();\n    let future_one = do_something(1);\n    let outcome = block_on(future_one);\n    println!(\"time elapsed {:?}\", now.elapsed());\n    println!(\"Here is the outcome: {}\", outcome);\n}\n```", "```rs\nnumber 1 is running\ntime elapsed 2.00018789s\nHere is the outcome: 2\n```", "```rs\nfn main() {\n    let now = time::Instant::now();\n    let future_one = do_something(1);\n    let two_seconds = time::Duration::new(2, 0);\n    thread::sleep(two_seconds);\n    let outcome = block_on(future_one);\n    println!(\"time elapsed {:?}\", now.elapsed());\n    println!(\"Here is the outcome: {}\", outcome);\n}\n```", "```rs\nnumber 1 is running\ntime elapsed 4.000269667s\nHere is the outcome: 2\n```", "```rs\nlet future_two = async {\n    return do_something(2).await\n};\nlet future_two = block_on(future_two);\nprintln!(\"Here is the outcome: {:?}\", future_two);\n```", "```rs\nlet future_three = async {\n    let outcome_one = do_something(2).await;\n    let outcome_two = do_something(3).await;\n    return outcome_one + outcome_two\n};\nlet future_outcome = block_on(future_three);\nprintln!(\"Here is the outcome: {:?}\", future_outcome);\n```", "```rs\nnumber 2 is running\nnumber 3 is running\nHere is the outcome: 4\n```", "```rs\nuse futures::join\n```", "```rs\nlet future_four = async {\n    let outcome_one = do_something(2);\n    let outcome_two = do_something(3);\n    let results = join!(outcome_one, outcome_two);\n    return results.0 + results.1\n};\nlet now = time::Instant::now();\nlet result = block_on(future_four);\nprintln!(\"time elapsed {:?}\", now.elapsed());\nprintln!(\"here is the result: {:?}\", result);\n```", "```rs\nasync-std = \"1.11.0\"\n```", "```rs\nuse std::vec::Vec;\nuse async_std;\nuse futures::future::join_all;\n```", "```rs\nlet async_outcome = async {\n    // 1.\n    let mut futures_vec = Vec::new();\n    let future_four = do_something(4);\n    let future_five = do_something(5);\n    // 2.\n    futures_vec.push(future_four);\n    futures_vec.push(future_five);\n    // 3\\. \n    let handles = futures_vec.into_iter().map(\n    async_std::task::spawn).collect::<Vec<_>>();\n    // 4.\n    let results = join_all(handles).await;\n    return results.into_iter().sum::<i8>();\n};\n```", "```rs\nlet now = time::Instant::now();\nlet result = block_on(async_outcome);\nprintln!(\"time elapsed for join vec {:?}\", now.elapsed());\nprintln!(\"Here is the result: {:?}\", result);\n```", "```rs\nnumber 4 is running\nnumber 5 is running\ntime elapsed for join vec 2.007713458s\nHere is the result: 4\n```", "```rs\n    use std::sync::Arc;\n    ```", "```rs\n    use std::thread;\n    ```", "```rs\n    let names = Arc::new(vec![\"dave\", \"chloe\", \"simon\"]);\n    ```", "```rs\n    let reference_data = Arc::clone(&names);\n    ```", "```rs\n    let new_thread = thread::spawn(move || {\n    ```", "```rs\n        println!(\"{}\", reference_data[1]);\n    ```", "```rs\n    });\n    ```", "```rs\n    use std::sync::Mutex;\n    ```", "```rs\n    use std::thread;\n    ```", "```rs\n    let count = Mutex::new(0);\n    ```", "```rs\n    let new_thread = thread::spawn(move || {\n    ```", "```rs\n         count.lock().unwrap() += 1;\n    ```", "```rs\n    });\n    ```", "```rs\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new( || {\n        App::new()\n        .route(\"/\", web::get().to(greet))\n        .route(\"/{name}\", web::get().to(greet))\n        .route(\"/say/hello\", web::get().to(|| \n               async { \"Hello Again!\" }))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .workers(3)\n    .run()\n    .await\n}\n```", "```rs\n`main` function is not allowed to be `async`\n```", "```rs\nuse actix_web::{web, App, HttpServer, Responder};\nuse futures::future;\nasync fn utils_one() -> impl Responder {\n    \"Utils one reached\\n\"\n}\nasync fn health() -> impl Responder {\n    \"All good\\n\"\n}\n```", "```rs\n#[actix_rt::main]\nasync fn main() -> std::io::Result<()> {\n    let s1 = HttpServer::new(move || {\n            App::new().service(web::scope(\"/utils\").route(\n            \"/one\", web::get().to(utils_one)))\n        })\n        .bind(\"0.0.0.0:3006\")?\n        .run();\n    let s2 = HttpServer::new(move || {\n            App::new().service(web::resource(\n            \"/health\").route(web::get().to(health)))\n        })\n        .bind(\"0.0.0.0:8080\")?\n        .run();\n    future::try_join(s1, s2).await?;\n    Ok(())\n}\n```", "```rs\n    future::try_join(s1, s2).await?;\n    Ok(())\n}\n```", "```rs\nmatch join(s1, s2).await {\n    Ok(v) => v,\n    Err(e) => return Err(e.into()),\n}\n```", "```rs\nmatch join(s1, s2).await {\n    Ok(v) => v,\n    Err(e) => panic!(\"unwrap resulted in {}\", e),\n}\n```", "```rs\ntokio = { version = \"1.17.0\", features = [\"full\"] }\n```", "```rs\n#[tokio::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new( || {\n        App::new()\n        .route(\"/\", web::get().to(greet))\n        .route(\"/{name}\", web::get().to(greet))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .bind(\"127.0.0.1:8081\")?\n    .workers(3)\n    .run()\n    .await\n}\n```", "```rs\n├── main.rs\n└── views\n    ├── auth\n    │   ├── login.rs\n    │   ├── logout.rs\n    │   └── mod.rs\n    ├── mod.rs\n```", "```rs\nuse actix_web::{App, HttpServer};\nmod views;\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let app = App::new();\n        return app\n    })\n        .bind(\"127.0.0.1:8000\")?\n        .run()\n        .await\n}\n```", "```rs\npub async fn login() -> String {\n    format!(\"Login view\")\n}\n```", "```rs\npub async fn logout() -> String {\n    format!(\"Logout view\")\n}\n```", "```rs\nmod login;\nmod logout;\nuse actix_web::web::{ServiceConfig, get, scope};\npub fn auth_views_factory(app: &mut ServiceConfig) {\n    app.service(scope(\"v1/auth\").route(\"login\", \n                get().to(login::login)).route(\"logout\", \n                get().to(logout::logout))\n    );\n}\n```", "```rs\nmod auth;\nuse auth::auth_views_factory;\nuse actix_web::web::ServiceConfig;\npub fn views_factory(app: &mut ServiceConfig) {\n    auth_views_factory(app);\n}\n```", "```rs\nuse actix_web::{App, HttpServer};\nmod views;\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        let app = \n            App::new().configure(views::views_factory);\n        return app\n    })\n        .bind(\"127.0.0.1:8000\")?\n        .run()\n        .await\n}\n```"]