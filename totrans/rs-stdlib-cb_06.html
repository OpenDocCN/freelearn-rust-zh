<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Handling Errors</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Providing user-defined error types</li>
<li class="mce-root">Providing logging</li>
<li>Creating a custom logger</li>
<li class="mce-root">Implementing the Drop trait</li>
<li class="mce-root">Understanding RAII</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="mce-root">Mistakes happen, and that's okay. We are only human after all. The important thing in life and in programming is not which errors we make, but how we deal with them. Rust helps us with the programming aspect of this principle by providing us with an error handling concept that guarantees that we <em>have</em> to think about the consequences of failure when dealing with functions that can fail, as they don't return a value directly but wrapped in a <kbd>Result</kbd> that has to be opened somehow. The only thing left is designing our code in a way that integrates nicely with this concept.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing user-defined error types</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we learned about a few ways to handle functions that have to deal with different kinds of errors. So far, we have:</p>
<ul>
<li>Simply panicked when encountering them</li>
<li>Returned only one kind of error and converted all others into it</li>
<li>Returned different kinds of errors in a <kbd>Box</kbd></li>
</ul>
<p>Most of these have been used because we didn't reach this recipe yet. Now, we are going to learn about the preferred way of doing things, creating a custom kind of <kbd>Error</kbd> that contains multiple sub-errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a Rust project to work on during this chapter with <kbd>cargo new chapter-six</kbd>.</li>
<li>Navigate to the newly created <kbd>chapter-six</kbd> folder. For the rest of this chapter, we will assume that your command line is currently in this directory.</li>
<li>Inside the folder <kbd>src</kbd>, create a new folder called <kbd>bin</kbd>.</li>
<li>Delete the generated <kbd>lib.rs</kbd> file, as we are not creating a library.</li>
<li>In the folder <kbd>src/bin</kbd>, create a file called <kbd>custom_error.rs</kbd>.</li>
<li>Add the following code and run it with <kbd>cargo run --bin custom_error</kbd>:</li>
</ol>
<pre style="padding-left: 60px">1   use std::{error, fmt, io, num, result};<br/>2   use std::fs::File;<br/>3   use std::io::{BufReader, Read};<br/>4 <br/>5   #[derive(Debug)]<br/>6   // This is going to be our custom Error type<br/>7   enum AgeReaderError {<br/>8     Io(io::Error),<br/>9     Parse(num::ParseIntError),<br/>10    NegativeAge(),<br/>11  }<br/>12 <br/>13  // It is common to alias Result in an Error module<br/>14  type Result&lt;T&gt; = result::Result&lt;T, AgeReaderError&gt;;<br/>15 <br/>16  impl error::Error for AgeReaderError {<br/>17    fn description(&amp;self) -&gt; &amp;str {<br/>18      // Defer to the existing description if possible<br/>19      match *self {<br/>20      AgeReaderError::Io(ref err) =&gt; err.description(),<br/>21      AgeReaderError::Parse(ref err) =&gt; err.description(),<br/>22      // Descriptions should be as short as possible<br/>23      AgeReaderError::NegativeAge() =&gt; "Age is negative",<br/>24      }<br/>25    }<br/>26 <br/>27    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {<br/>28      // Return the underlying error, if any<br/>29      match *self {<br/>30        AgeReaderError::Io(ref err) =&gt; Some(err),<br/>31        AgeReaderError::Parse(ref err) =&gt; Some(err),<br/>32        AgeReaderError::NegativeAge() =&gt; None,<br/>33      }<br/>34    }<br/>35  }<br/>36 <br/>37  impl fmt::Display for AgeReaderError {<br/>38    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>39      // Write a detailed description of the problem<br/>40      match *self {<br/>41        AgeReaderError::Io(ref err) =&gt; write!(f, "IO error: {}", <br/>           err),<br/>42        AgeReaderError::Parse(ref err) =&gt; write!(f, "Parse <br/>           error: {}", err),<br/>43        AgeReaderError::NegativeAge() =&gt; write!(f, "Logic error: <br/>           Age cannot be negative"),<br/>44      }<br/>45    }<br/>46  }<br/>47 <br/>48  // Implement From&lt;T&gt; for every sub-error<br/>49  impl From&lt;io::Error&gt; for AgeReaderError {<br/>50    fn from(err: io::Error) -&gt; AgeReaderError {<br/>51    AgeReaderError::Io(err)<br/>52    }<br/>53  }<br/>54 <br/>55  impl From&lt;num::ParseIntError&gt; for AgeReaderError {<br/>56    fn from(err: num::ParseIntError) -&gt; AgeReaderError {<br/>57    AgeReaderError::Parse(err)<br/>58    }<br/>59  }<br/>60 <br/>61  fn main() {<br/>62    // Assuming a file called age.txt exists<br/>63    const FILENAME: &amp;str = "age.txt";<br/>64    let result = read_age(FILENAME);<br/>65    match result {<br/>66      Ok(num) =&gt; println!("{} contains the age {}", FILENAME, <br/>         num),<br/>67      Err(AgeReaderError::Io(err)) =&gt; eprintln!("Failed to open <br/>         the file {}: {}", FILENAME, err),<br/>68      Err(AgeReaderError::Parse(err)) =&gt; eprintln!(<br/>69       "Failed to read the contents of {} as a number: {}",<br/>70        FILENAME, err<br/>71         ),<br/>72      Err(AgeReaderError::NegativeAge()) =&gt; eprintln!("The age in <br/>         the file is negative"),<br/>73      }<br/>74  }<br/>75 <br/>76  // Read an age out of a file<br/>77  fn read_age(filename: &amp;str) -&gt; Result&lt;i32&gt; {<br/>78    let file = File::open(filename)?;<br/>79    let mut buf_reader = BufReader::new(file);<br/>80    let mut content = String::new();<br/>81    buf_reader.read_to_string(&amp;mut content)?;<br/>82    let age: i32 = content.trim().parse()?;<br/>83    if age.is_positive() {<br/>84      Ok(age)<br/>85    } else {<br/>86      Err(AgeReaderError::NegativeAge())<br/>87    }<br/>88  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The purpose of our example is to read a file, <kbd>age.txt</kbd>, and return the number written in it, assuming that it represents some kind of age. We can encounter three errors during this process:</p>
<ul>
<li>Failure to read the file (maybe it doesn't exist)</li>
<li>Failure to read its content as a number (it could contain text as well)</li>
<li>The number could be negative</li>
</ul>
<p>These possible error states are the possible variants of our <kbd>Error enum</kbd>: <kbd>AgeReaderError</kbd>[7]. It is usual to name the variants after the sub-errors they represent. Because a failure to read the file raises an <kbd>io::Error</kbd>, we name our corresponding variant <kbd>AgeReaderError::Io</kbd>[8]. A failure to parse a <kbd>&amp;str</kbd> as an <kbd>i32</kbd> raises a <kbd>num::ParseIntError</kbd>, so we name our encompassing variant <kbd>AgeReaderError::Parse</kbd>[9].</p>
<div class="packt_tip">These two <kbd>std</kbd> errors show the naming convention of errors neatly. If you have many different errors that can be returned by a module, export them via their full name, such as <kbd>num::ParseIntError</kbd>. If your module only returns one kind of <kbd>Error</kbd>, simply export it as <kbd>Error</kbd>, such as <kbd>io::Error</kbd>. We intentionally don't follow this convention in the recipe because the distinct name <kbd>AgeReaderError</kbd> makes it easier to talk about it. If this recipe was included, one for one, in a crate, we could achieve the conventional effect by exporting it as <kbd>pub type Error = AgeReaderError;</kbd>.</div>
<p>The next thing we create is an alias for our own <kbd>Result</kbd>[14]:</p>
<pre style="padding-left: 30px">type Result&lt;T&gt; = result::Result&lt;T, AgeReaderError&gt;;</pre>
<p>This is an extremely common pattern for your own errors, which makes working with them a charm, as we see in the return type of <kbd>read_age</kbd>[77]:</p>
<pre style="padding-left: 30px">fn read_age(filename: &amp;str) -&gt; Result&lt;i32&gt; { ... }</pre>
<p>Looks nice, doesn't it? In order to use our <kbd>enum</kbd> as an <kbd>Error</kbd> though, we need to implement it first [16]. The <kbd>Error</kbd> trait requires two things: a <kbd>description</kbd>[17], which is a short explanation of what went wrong, and a <kbd>cause</kbd>[27], which is simply a <em>redirection</em> to the underlying error, if any. You can (and should) provide a detailed description of the problem at hand by also implementing <kbd>Display</kbd> for your <kbd>Error</kbd>[37]. In all of these implementations, you should refer to the underlying error if possible, as with the following line [20]:</p>
<pre style="padding-left: 30px">AgeReaderError::Io(ref err) =&gt; err.description()</pre>
<p>The last thing you need to provide for a good own <kbd>Error</kbd> is a <kbd>From</kbd> implementation for every sub-error. In our case this would be <kbd>From&lt;io::Error&gt;</kbd>[49] and <kbd>From&lt;num::ParseIntError&gt;</kbd>[55]. This way, the <kbd>try</kbd> operator (<kbd>?</kbd>) will automatically convert the involved errors for us.</p>
<p>After implementing all necessary traits, you can return the custom <kbd>Error</kbd> from any function and unwrap values in it with the aforementioned operator. In this example, when checking the result of <kbd>read_age</kbd>, we didn't have to <kbd>match</kbd> the returned value. In a real <kbd>main</kbd> function, we would probably just call <kbd>.expect("…")</kbd> on it, but we matched the individual error variants anyway to show you how nicely you can react to different problems when using known error types [65 to 73]:</p>
<pre style="padding-left: 30px">match result {<br/>    Ok(num) =&gt; println!("{} contains the age {}", FILENAME, num),<br/>    Err(AgeReaderError::Io(err)) =&gt; eprintln!("Failed to open the file <br/>    {}: {}", FILENAME, err),<br/>    Err(AgeReaderError::Parse(err)) =&gt; eprintln!(<br/>        "Failed to read the contents of {} as a number: {}",<br/>        FILENAME, err<br/>    ),<br/>    Err(AgeReaderError::NegativeAge()) =&gt; eprintln!("The age in the file is negative"),<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">A crate's <kbd>Error</kbd> is usually put inside an own <kbd>error</kbd> module for organizational reasons and then exported directly for optimal usability. The relevant <kbd>lib.rs</kbd> entries would look like this:</p>
<pre style="padding-left: 30px">mod error;<br/>pub use error::Error;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing logging</h1>
                </header>
            
            <article>
                
<p>In a big application, things will sooner or later not go as planned. But that's okay, as long as you have provided a system for your users to know what went wrong and, if possible, why. One time-tested tool to accomplish this is detailed logs that let the user specify for themselves how much diagnosis they want to see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps:</p>
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that has been generated earlier for you.</p>
</li>
<li>
<p><span>Under</span> <kbd>[dependencies]</kbd><span>, add the following line:</span></p>
</li>
</ol>
<pre style="padding-left: 60px">log = "0.4.1"<br/>env_logger = "0.5.3"</pre>
<ol start="3">
<li>If you want, you can go to log's (<a href="https://crates.io/crates/log">https://crates.io/crates/log</a>) or <kbd>env_logger</kbd>'s (<a href="https://crates.io/crates/env_log">https://crates.io/crates/env_log</a>) crates.io pages to check for the newest version and use that one instead.</li>
<li><span>In the folder</span> <kbd>bin</kbd><span>, create a file called</span> <kbd>logging.rs</kbd>.</li>
<li>
<p>Add the following code and run it with <kbd>RUST_LOG=logging cargo run --bin logging</kbd> if you're on a Unix-based system. Otherwise, run <kbd>$env:RUST_LOG="logging"; cargo run --bin logging</kbd> on Windows:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   extern crate env_logger;<br/>2   #[macro_use]<br/>3   extern crate log;<br/>4   use log::Level;<br/>5 <br/>6   fn main() {<br/>7     // env_logger's priority levels are:<br/>8     // error &gt; warn &gt; info &gt; debug &gt; trace<br/>9     env_logger::init();<br/>10    // All logging calls log! in the background<br/>11    log!(Level::Debug, "env_logger has been initialized");<br/>12 <br/>13    // There are convenience macros for every logging level <br/>       however<br/>14    info!("The program has started!");<br/>15 <br/>16    // A log's target is its parent module per default <br/>17    // ('logging' in our case, as we're in a binary)<br/>18    // We can override this target however:<br/>19    info!(target: "extra_info", "This is additional info that <br/>       will only show if you \<br/>20    activate info level logging for the extra_info target");<br/>21 <br/>22    warn!("Something that requires your attention happened");<br/>23 <br/>24    // Only execute code if logging level is active<br/>25    if log_enabled!(Level::Debug) {<br/>26    let data = expensive_operation();<br/>27    debug!("The expensive operation returned: \"{}\"", data);<br/>28    }<br/>29 <br/>30    error!("Something terrible happened!");<br/>31  }<br/>32 <br/>33  fn expensive_operation() -&gt; String {<br/>34    trace!("Starting an expensive operation");<br/>35    let data = "Imagine this is a very very expensive <br/>       task".to_string();<br/>36    trace!("Finished the expensive operation");<br/>37    data<br/>38  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Rust's logging system is based on the <kbd>log</kbd> crate, which provides a common <em>facade</em> for all things logging. This means that it doesn't actually provide any functionality, just the interface. The implementation is left to other crates, <kbd>env_logger</kbd> in our case. This split into facade and implementation is pretty useful, as anyone can create a cool new way of logging stuff which is automatically compatible with any crate.</p>
<div class="packt_tip">The choice of logging implementation used should be up to the consumer of your code. If you write a crate, don't use any implementation but simply log all things via the <kbd>log</kbd> crate only. Your (or someone else's) executable that uses the crate can then simply initialize their logger of choice[9] in order to actually process the log calls.</div>
<p>The <kbd>log</kbd> crate provides the <kbd>log!</kbd> macro[11], which accepts a log <kbd>Level</kbd>, a message that can be formatted the same way as in <kbd>println!</kbd>, and an optional <kbd>target</kbd>. You could log stuff like this, but it's more readable to use the convenience macros for every logging level, <kbd>error!</kbd>, <kbd>warn!</kbd>, <kbd>info!</kbd>, <kbd>debug!</kbd>, and <kbd>trace!</kbd>, which all simply call <kbd>log!</kbd> in the background. A log's <kbd>target</kbd>[19] is an additional property that helps the logger implementation group the logs thematically. If you omit the <kbd>target</kbd>, it defaults to the current <kbd>module</kbd>. So, for example, if you logged something from the <kbd>foo</kbd> crate, its <kbd>target</kbd> would default to <kbd>foo</kbd>. If you logged something in its submodule <kbd>foo::bar</kbd>, its <kbd>target</kbd> would default to <kbd>bar</kbd>. If you then consumed the crate in a <kbd>main.rs</kbd> and logged something there, its <kbd>target</kbd> would default to <kbd>main</kbd>.</p>
<p>Another goodie that <kbd>log</kbd> provides is the <kbd>log_enabled!</kbd> macro, which returns whether or not the currently active logger is set to process a certain warning level. This is especially useful in combination with <kbd>Debug</kbd> logs that provide useful information at the cost of an expensive operation.</p>
<p><kbd>env_logger</kbd> is a logger implementation provided by the Rust nursery. It prints its logs on <kbd>stderr</kbd> and uses pretty colors for different logging levels if supported by your Terminal. It relies on a <kbd>RUST_LOG</kbd> envvar to filter which logs should be displayed. If you don't define said variable, it will default to <kbd>error</kbd>, which means that it will print only the log level <kbd>error</kbd> from all targets. As you can guess, other possible values include <kbd>warn</kbd>, <kbd>info</kbd>, <kbd>debug</kbd>, and <kbd>trace</kbd>. These will, however, not only filter the specified level, but all levels <em>above</em> it as well, where the hierarchy is defined like this:</p>
<pre>error &gt; warn &gt; info &gt; debug &gt; trace</pre>
<p>This means that setting your <kbd>RUST_LOG</kbd> to <kbd>warn</kbd> will show all <kbd>warn</kbd> and all <kbd>error</kbd> logs. Setting it to <kbd>debug</kbd> will show <kbd>error</kbd>, <kbd>warn</kbd>, <kbd>info</kbd>, and <kbd>debug</kbd>.</p>
<p>Instead of error levels, you can set <kbd>RUST_LOG</kbd> to targets, which will show all logs of the selected targets regardless of their log levels. This is what we do in our example, we set <kbd>RUST_LOG</kbd> to <kbd>logging</kbd> in order to show all logs with a <kbd>target</kbd> called <kbd>logging</kbd>, which is the standard target for all logs in our binary. If you wanted, you could combine a level filter with a target filter like this: <kbd>logging=warn</kbd>, which would only show <kbd>warn</kbd> and <kbd>error</kbd> logs with a <kbd>target</kbd> of <kbd>logging</kbd>.</p>
<p>You can combine different filters with a comma. If you want all logs of this example to be displayed, you can set your variable to <kbd>logging,extra_info</kbd>, which filters for both the targets <kbd>logging</kbd> and <kbd>extra_info</kbd>.</p>
<p>Lastly, you can filter your logs by content with a slash (<kbd>/</kbd>), after which you can write down a regex that has to be matched. If you set <kbd>RUST_LOG</kbd> to <kbd>logging=debug/expensive</kbd> for instance, only logs with the logging level of <kbd>debug</kbd> and upwards with the <kbd>target</kbd> of <kbd>logging</kbd> that also contain the word <kbd>expensive</kbd> will be displayed.</p>
<p>Wow, that's a lot of configuration! I advise you to experiment a bit with the different filtering modes and run the example in order to get a feeling for how the parts fit together. If you need additional information, all possibilities for the value of <kbd>RUST_LOG</kbd> in the current version of <kbd>env_logger</kbd> are documented at <a href="https://docs.rs/env_logger/">https://docs.rs/env_logger/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you've never worked with a logger before, you might wonder what the difference between certain log levels is. Of course, you can use them for whatever purpose you want, but the following conventions are usual for loggers in many languages:</p>
<table>
<tbody>
<tr>
<td><strong>Log level</strong></td>
<td><strong>Usage</strong></td>
<td><strong>Example</strong></td>
</tr>
<tr>
<td><kbd>Error</kbd></td>
<td>Some major problem occurred that might terminate the program soon. If the application is a service that should always run, a system administrator should immediately be notified.</td>
<td>The connection to the database has been broken.</td>
</tr>
<tr>
<td><kbd>Warn</kbd></td>
<td>An issue that's not severe or has an automatic workaround has happened. Someone should check this out at some point and fix it.</td>
<td>A user's configuration file contains unrecognized options that have been ignored.</td>
</tr>
<tr>
<td><kbd>Info</kbd></td>
<td>Some information that might be useful to look at at a later point. This logs normal conditions.</td>
<td>The user has started or stopped a process. A default value has been used because no configuration has been provided.</td>
</tr>
<tr>
<td><kbd>Debug</kbd></td>
<td>Information that is helpful to programmers or sysadmins when trying to fix a problem. Contrary to many other languages, a debug log is <em>not</em> removed in release builds.</td>
<td>The parameters passed to a major function. The current state of the application at various points.</td>
</tr>
<tr>
<td><kbd>Trace</kbd></td>
<td>Very low-level signals of control flow that are only useful to a programmer trying to chase a bug. Allows the reconstruction of a stack trace.</td>
<td>The parameters of a minor helper function. The beginning and end of a function.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Many languages also contain a <kbd>Fatal</kbd> log level. In Rust, a good old <kbd>panic!()</kbd> is used for that. If you want to log your panics in some special way as well, you can replace the usual reaction to a panic by simply printing it to <kbd>stderr</kbd> by calling <kbd>std::panic::set_hook()</kbd> with whatever functionality you want. An example of what this might look like is as follows:</p>
<pre>    std::panic::set_hook(Box::new(|e| {<br/>        println!("Oh noes, something went wrong D:");<br/>        println!("{:?}", e);<br/>    }));<br/>    panic!("A thing broke");</pre>
<p>A good alternative to <kbd>env_logger</kbd> is the <kbd>slog</kbd> crate, which provides excellent extensible structured logging at the cost of a steepened learning curve. Plus, its output looks pretty. If that sounds interesting, be sure to check it out at <a href="https://github.com/slog-rs/slog">https://github.com/slog-rs/slog.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom logger</h1>
                </header>
            
            <article>
                
<p>Sometimes you or your users might have very specific logging needs. In this recipe, we are going to learn how to create a custom logger to work with the <kbd>log</kbd> crate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>
<p>Under <kbd>[dependencies]</kbd>, if you didn't do so in the last recipe, add the following line:</p>
</li>
</ol>
<pre style="padding-left: 60px">log = "0.4.1"</pre>
<p>If you want, you can go to log's crates.io page (<a href="https://crates.io/crates/log">https://crates.io/crates/log</a>) to check for the newest version and use that one instead.</p>
<ol start="3">
<li><span>In the folder</span> <kbd>bin</kbd><span>, create a file called</span> <kbd>custom_logger.rs</kbd>.</li>
<li><span>Add the following code and run it with</span> <kbd>RUST_LOG=custom_logger cargo run --bin custom_logger</kbd> <span>if you're on a Unix-based system. Otherwise, run</span> <kbd>$env:RUST_LOG="custom_logger"; cargo run --bin custom_logger</kbd> <span>on Windows:</span></li>
</ol>
<pre style="padding-left: 60px">1   #[macro_use]<br/>2   extern crate log;<br/>3 <br/>4   use log::{Level, Metadata, Record};<br/>5   use std::fs::{File, OpenOptions};<br/>6   use std::io::{self, BufWriter, Write};<br/>7   use std::{error, fmt, result};<br/>8   use std::sync::RwLock;<br/>9   use std::time::{SystemTime, UNIX_EPOCH};<br/>10 <br/>11  // This logger will write logs into a file on disk<br/>12  struct FileLogger {<br/>13    level: Level,<br/>14    writer: RwLock&lt;BufWriter&lt;File&gt;&gt;,<br/>15  }<br/>16 <br/>17  impl log::Log for FileLogger {<br/>18    fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool {<br/>19      // Check if the logger is enabled for a certain log level<br/>20      // Here, you could also add own custom filtering based on <br/>         targets or regex<br/>21      metadata.level() &lt;= self.level<br/>22    }<br/>23 <br/>24    fn log(&amp;self, record: &amp;Record) {<br/>25      if self.enabled(record.metadata()) {<br/>26        let mut writer = self.writer<br/>27          .write()<br/>28          .expect("Failed to unlock log file writer in write <br/>             mode");<br/>29        let now = SystemTime::now();<br/>30        let timestamp = now.duration_since(UNIX_EPOCH).expect(<br/>31         "Failed to generate timestamp: This system is <br/>            operating before the unix epoch",<br/>32        );<br/>33        // Write the log into the buffer<br/>34        write!(<br/>35          writer,<br/>36          "{} {} at {}: {}\n",<br/>37          record.level(),<br/>38          timestamp.as_secs(),<br/>39          record.target(),<br/>40          record.args()<br/>41        ).expect("Failed to log to file");<br/>42      }<br/>43      self.flush();<br/>44    }<br/>45 <br/>46    fn flush(&amp;self) {<br/>47      // Write the buffered logs to disk<br/>48      self.writer<br/>49        .write()<br/>50        .expect("Failed to unlock log file writer in write <br/>               mode")<br/>51        .flush()<br/>52        .expect("Failed to flush log file writer");<br/>53    }<br/>54  }<br/>55 <br/>56  impl FileLogger {<br/>57    // A convenience method to set everything up nicely<br/>58    fn init(level: Level, file_name: &amp;str) -&gt; Result&lt;()&gt; {<br/>59      let file = OpenOptions::new()<br/>60        .create(true)<br/>61        .append(true)<br/>62        .open(file_name)?;<br/>63      let writer = RwLock::new(BufWriter::new(file));<br/>64      let logger = FileLogger { level, writer };<br/>65      // set the global level filter that log uses to optimize <br/>         ignored logs<br/>66      log::set_max_level(level.to_level_filter());<br/>67      // set this logger as the one used by the log macros<br/>68      log::set_boxed_logger(Box::new(logger))?;<br/>69      Ok(())<br/>70    }<br/>71  }</pre>
<p style="padding-left: 60px">This is the custom error used in our logger:</p>
<pre style="padding-left: 60px">73  // Our custom error for our FileLogger<br/>74  #[derive(Debug)]<br/>75  enum FileLoggerError {<br/>76    Io(io::Error),<br/>77    SetLogger(log::SetLoggerError),<br/>78  }<br/>79 <br/>80  type Result&lt;T&gt; = result::Result&lt;T, FileLoggerError&gt;;<br/>81  impl error::Error for FileLoggerError {<br/>82    fn description(&amp;self) -&gt; &amp;str {<br/>83      match *self {<br/>84        FileLoggerError::Io(ref err) =&gt; err.description(),<br/>85        FileLoggerError::SetLogger(ref err) =&gt; <br/>           err.description(),<br/>86      }<br/>87    }<br/>88  <br/>89    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {<br/>90      match *self {<br/>91        FileLoggerError::Io(ref err) =&gt; Some(err),<br/>92        FileLoggerError::SetLogger(ref err) =&gt; Some(err),<br/>93      }<br/>94    }<br/>95  }<br/>96 <br/>97  impl fmt::Display for FileLoggerError {<br/>98    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>99      match *self {<br/>100       FileLoggerError::Io(ref err) =&gt; write!(f, "IO error: {}", <br/>           err),<br/>101       FileLoggerError::SetLogger(ref err) =&gt; write!(f, "Parse <br/>           error: {}", err),<br/>102     }<br/>103   }<br/>104 }<br/>105 <br/>106 impl From&lt;io::Error&gt; for FileLoggerError {<br/>107   fn from(err: io::Error) -&gt; FileLoggerError {<br/>108     FileLoggerError::Io(err)<br/>109   }<br/>110 }<br/>111 <br/>112 impl From&lt;log::SetLoggerError&gt; for FileLoggerError {<br/>113   fn from(err: log::SetLoggerError) -&gt; FileLoggerError {<br/>114     FileLoggerError::SetLogger(err)<br/>115   }<br/>116 }</pre>
<p style="padding-left: 60px">Initializing and using the logger:</p>
<pre style="padding-left: 60px">118 fn main() {<br/>119   FileLogger::init(Level::Info, "log.txt").expect("Failed to <br/>       init <br/>      FileLogger");<br/>120   trace!("Beginning the operation");<br/>121   info!("A lightning strikes a body");<br/>122   warn!("It's moving");<br/>123   error!("It's alive!");<br/>124   debug!("Dr. Frankenstein now knows how it feels to be god");<br/>125   trace!("End of the operation");<br/>126 }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our <kbd>FileLogger</kbd> will, as the name suggests, log things to a file. It also accepts a maximum logging level on initialization.</p>
<div class="packt_tip">You should not get used to directly logging things on a disk. As stated by <em>The Twelve-Factor App guidelines</em> (<a href="https://12factor.net/logs">https://12factor.net/logs</a>), logs should be treated as event streams, in the form of a raw dump to <kbd>stdout</kbd>. The production environment can then route all log streams to their final destination over <kbd>systemd</kbd> or a dedicated log router such as <kbd>Logplex</kbd> (<a href="https://github.com/heroku/logplex">https://github.com/heroku/logplex</a>) or <kbd>Fluentd</kbd> (<a href="https://github.com/fluent/fluentd">https://github.com/fluent/fluentd</a>). These will then decide if the logs should be sent to a file, an analysis system like <kbd>Splunk</kbd> (<a href="https://www.splunk.com/">https://www.splunk.com/</a>), or a data warehouse like <kbd>Hive</kbd> (<a href="http://hive.apache.org/">http://hive.apache.org/</a>).</div>
<p>Every logger needs to implement the <kbd>log::Log</kbd> trait, which consists of the <kbd>enabled</kbd>, <kbd>log</kbd>, and <kbd>flush</kbd> methods. <kbd>enabled</kbd> should return if a certain log event is accepted by the logger. Here, you can go wild with whatever filtering logic you want [18]. This method is never called directly by <kbd>log</kbd>, so its only purpose is to serve you as a helper method inside of the <kbd>log</kbd> method, which we are going to discuss shortly. <kbd>flush</kbd> [46] is treated the same way. It should apply whatever changes you have buffered in your logging, but it is never called by <kbd>log</kbd>.</p>
<p>In fact, if your logger doesn't interact with the filesystem or the network, it will probably simply implement <kbd>flush</kbd> by doing nothing:</p>
<pre>fn flush(&amp;self) {}</pre>
<p>The real bread and butter of the <kbd>Log</kbd> implementation is the <kbd>log</kbd> method[24], though, as it is called whenever a logging macro is invoked. The implementation typically starts with the following line, followed by the actual logging and a finishing call to <kbd>self.flush()</kbd>[25]:</p>
<pre>if self.enabled(record.metadata()) {</pre>
<p>Our actual logging then consists of simply writing a combination of the current logging level, Unix timestamp, target, and logging message to the file and flushing it afterward.</p>
<p>Technically speaking, our call to <kbd>self.flush()</kbd> should be inside the <kbd>if</kbd> block as well, but that would require additional scope around the mutably borrowed <kbd>writer</kbd> in order to not borrow it twice. Because this is not relevant to the underlying lesson here, as in, how to create a logger, we placed it outside the block in order to make the example more readable. By the way, the way we borrow <kbd>writer</kbd> from an <kbd>RwLock</kbd> is the subject of the <em>Accessing resources in parallel with RwLocks </em>in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml">Chapter 8</a>, <em>Parallelism and Rayon</em>. For now, it's enough to know that an <kbd>RwLock</kbd> is a <kbd>RefCell</kbd> that is safe to use in a parallel environment such as a logger.</p>
<p>After implementing <kbd>Log</kbd> for <kbd>FileLogger</kbd>, the user can use it as the logger called by <kbd>log</kbd>. To do that, the user has to do two things:</p>
<ul>
<li>Tell <kbd>log</kbd> which log <kbd>Level</kbd> is going to be the maximum accepted by our logger via <kbd>log::set_max_level()</kbd> [66]. This is needed because <kbd>log</kbd> optimizes <kbd>.log()</kbd> calls on our logger away during runtime if they use log levels over our maximum level. The function accepts a <kbd>LevelFilter</kbd> instead of a <kbd>Level</kbd>, which is why we have to convert our level with <kbd>to_level_filter()</kbd> first [66]. The reason for this type is explained in the <em>There's more...</em> section.</li>
<li>Specify the logger with <kbd>log::set_boxed_logger()</kbd>[68]. <kbd>log</kbd> accepts a box because it treats its logger implementation as a trait object, which we discussed in the <em>Boxing data</em> section of <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a>, <em>Advanced Data Structures</em>. If you want a (very) minor performance gain, you can also use <kbd>log::set_logger()</kbd>, which accepts a <kbd>static</kbd> which you would have to create via the <kbd>lazy_static</kbd> crate first. See  <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a>, <em>Advanced Data Structures</em>, and the recipe <em>Creating lazy static objects</em>, for more on that.</li>
</ul>
<p>This is conventionally done in a provided <kbd>.init()</kbd> method on the logger, just like with <kbd>env_logger</kbd>, which we implement in line [58]:</p>
<pre>    fn init(level: Level, file_name: &amp;str) -&gt; Result&lt;()&gt; {<br/>        let file = OpenOptions::new()<br/>            .create(true)<br/>            .append(true)<br/>            .open(file_name)?;<br/>        let writer = RwLock::new(BufWriter::new(file));<br/>        let logger = FileLogger { level, writer };<br/>        log::set_max_level(level.to_level_filter());<br/>        log::set_boxed_logger(Box::new(logger))?;<br/>        Ok(())<br/>    }</pre>
<p>While we're on it, we can also open the file in the same method. Other possibilities include letting the user pass a <kbd>File</kbd> directly to <kbd>init</kbd> as a parameter or, for maximum flexibility, making the logger a generic one that accepts any stream implementing <kbd>Write</kbd>.</p>
<p>We then return a custom error created in the lines that follow [74 to 116].</p>
<p>An example initialization of our logger might look like this [119]:</p>
<pre>FileLogger::init(Level::Info, "log.txt").expect("Failed to init FileLogger");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For simplicity's sake, <kbd>FileLogger</kbd> doesn't discriminate against any targets. A more sophisticated logger, like <kbd>env_logger</kbd>, can set different logging levels on different targets. For this purpose, <kbd>log</kbd> provides us with the <kbd>LevelFilter</kbd> enum, which has an <kbd>Off</kbd> state that corresponds to <em>no logging enabled for this target.</em> If you need to create such a logger, be sure to remember said enum. You can get some inspiration about how to implement target-based filters by looking at the source code of <kbd>env_logger</kbd> at <a href="https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs">https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs</a>.</p>
<div class="packt_tip">In a really user-friendly logger, you'll want to display the timestamp in the user's own local time. For all things related to time measurement, time zones, and dates, check out the <kbd>chrono</kbd> crate at <a href="https://crates.io/crates/chrono">https://crates.io/crates/chrono</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Boxing data</em> recipe in <span><a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a></span><span>, <em>Advanced Data Structures</em></span></li>
<li><em>Creating lazy static objects </em>recipe <span>in </span><em><span><a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a></span></em><em><span>, Advanced Data Structures</span></em></li>
<li><em>Accessing resources in parallel with RwLocks</em> <span>recipe</span><span> in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Drop trait</h1>
                </header>
            
            <article>
                
<p>Where traditional object-oriented languages have destructors, Rust has the <kbd>Drop</kbd> trait, which consists of a single <kbd>drop</kbd> function that is called whenever a variable's lifetime has ended. By implementing it, you can perform whatever cleanup or advanced logging is necessary. You can also automatically free resources via RAII, as we're going to see in the next recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>In the folder <kbd>bin</kbd>, create a file called <kbd>drop.rs</kbd>.</p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin drop</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   use std::fmt::Debug;<br/>2 <br/>3   struct CustomSmartPointer&lt;D&gt;<br/>4   where<br/>5   D: Debug,<br/>6   {<br/>7   data: D,<br/>8   }<br/>9 <br/>10  impl&lt;D&gt; CustomSmartPointer&lt;D&gt;<br/>11  where<br/>12  D: Debug,<br/>13  {<br/>14    fn new(data: D) -&gt; Self {<br/>15    CustomSmartPointer { data }<br/>16    }<br/>17  }<br/>18 <br/>19  impl&lt;D&gt; Drop for CustomSmartPointer&lt;D&gt;<br/>20  where<br/>21  D: Debug,<br/>22  {<br/>23    // This will automatically be called when a variable is <br/>       dropped<br/>24    // It cannot be called manually<br/>25    fn drop(&amp;mut self) {<br/>26    println!("Dropping CustomSmartPointer with data `{:?}`", <br/>       self.data);<br/>27    }<br/>28  }<br/>29 <br/>30  fn main() {<br/>31    let a = CustomSmartPointer::new("A");<br/>32    let b = CustomSmartPointer::new("B");<br/>33    let c = CustomSmartPointer::new("C");<br/>34    let d = CustomSmartPointer::new("D");<br/>35 <br/>36    // The next line would cause a compiler error,<br/>37    // as destructors cannot be explicitely called<br/>38    // c.drop();<br/>39 <br/>40    // The correct way to drop variables early is the following:<br/>41    std::mem::drop(c);<br/>42  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This example, adapted with slight changes from the second edition of the Rust book (<a href="https://doc.rust-lang.org/book/second-edition/">https://doc.rust-lang.org/book/second-edition/</a>), shows you how to start the implementation of a custom smart pointer. In our case, all it does is print the <kbd>Debug</kbd> information of the data stored when its dropped [26]. We do this by implementing the <kbd>Drop</kbd> trait with its single <kbd>drop</kbd> function [25], which the compiler automatically calls whenever a variable is dropped. All smart pointers are implemented this way.</p>
<p>The moment of a variable drop will nearly always be when it leaves its scope. For this reason, we cannot call the <kbd>drop</kbd> function directly[38]. The compiler will still call it when it exits its scope, so the cleanup will happen twice, resulting in undefined behavior. If you need to drop a variable early, you can tell the compiler to do so for you by calling <kbd>std::mem:drop</kbd> on it [41].</p>
<p>Variables that exit their scope are dropped in a <strong>LIFO</strong> way: <strong>Last In, First Out</strong>. That means that the last variable to be declared will be the first one to be dropped. If we allocate the variables <kbd>a</kbd>, <kbd>b</kbd>, <kbd>c</kbd>, and <kbd>d</kbd> in exactly that order, they will be dropped in the order <kbd>d</kbd>, <kbd>c</kbd>, <kbd>b</kbd>, <kbd>a</kbd>. In our example, we drop <kbd>c</kbd> early[41], so our order becomes <kbd>c</kbd>, <kbd>d</kbd>, <kbd>b</kbd>, <kbd>a</kbd> instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Do you want to know how a sophisticated low-level function like <kbd>std::mem::drop</kbd> is implemented:</p>
<pre style="padding-left: 30px">pub fn drop&lt;T&gt;(_x: T) { }</pre>
<p>That's right, it does nothing! The reason this works is that it takes <kbd>T</kbd> by value, moving it into the function. The function does nothing and all its owned variables go out of scope. Hurray for Rust's borrow checker!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Boxing data</em> <span>recipe in </span><span><a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a></span><span>, <em>Advanced Data Structures</em></span><span>.</span></li>
<li><em>Sharing ownership with smart pointers</em> recipe in <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a>, <em>Advanced Data Structures</em>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding RAII</h1>
                </header>
            
            <article>
                
<p>We can go one step further than simple destructors. We can create structs that can give the user temporary access to some resource or functionality and automatically revoke it again when the user is done. This concept is called <strong>RAII</strong>, which stands for <strong>Resource Acquisition Is Initialization</strong>. Or, in other words, the validity of a resource is tied to the lifetime of a variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">Follow these steps:</span></p>
<ol>
<li>
<p>Open the <kbd>Cargo.toml</kbd> file that was generated earlier for you.</p>
</li>
<li>
<p>In the folder <kbd>bin</kbd>, create a file called <kbd>raii.rs</kbd>.</p>
</li>
<li>
<p>Add the following code and run it with <kbd>cargo run --bin raii</kbd>:</p>
</li>
</ol>
<pre style="padding-left: 60px">1   use std::ops::Deref;<br/>2 <br/>3   // This represents a low level, close to the metal OS feature <br/>     that<br/>4   // needs to be locked and unlocked in some way in order to be   <br/>     accessed<br/>5   // and is usually unsafe to use directly<br/>6   struct SomeOsSpecificFunctionalityHandle;<br/>7 <br/>8   // This is a safe wrapper around the low level struct<br/>9   struct SomeOsFunctionality&lt;T&gt; {<br/>10    // The data variable represents whatever useful information<br/>11    // the user might provide to the OS functionality<br/>12    data: T,<br/>13    // The underlying struct is usually not savely movable,<br/>14    // so it's given a constant address in a box<br/>15    inner: Box&lt;SomeOsSpecificFunctionalityHandle&gt;,<br/>16  }<br/>17 <br/>18  // Access to a locked SomeOsFunctionality is wrapped in a guard<br/>19  // that automatically unlocks it when dropped<br/>20  struct SomeOsFunctionalityGuard&lt;'a, T: 'a&gt; {<br/>21    lock: &amp;'a SomeOsFunctionality&lt;T&gt;,<br/>22  }<br/>23 <br/>24  impl SomeOsSpecificFunctionalityHandle {<br/>25    unsafe fn lock(&amp;self) {<br/>26      // Here goes the unsafe low level code<br/>27    }<br/>28    unsafe fn unlock(&amp;self) {<br/>29      // Here goes the unsafe low level code<br/>30    }<br/>31  }</pre>
<p style="padding-left: 60px">Now comes the implementations for the <kbd>structs</kbd>:</p>
<pre style="padding-left: 60px"><br/>33  impl&lt;T&gt; SomeOsFunctionality&lt;T&gt; {<br/>34    fn new(data: T) -&gt; Self {<br/>35      let handle = SomeOsSpecificFunctionalityHandle;<br/>36        SomeOsFunctionality {<br/>37          data,<br/>38          inner: Box::new(handle),<br/>39        }<br/>40    }<br/>41 <br/>42    fn lock(&amp;self) -&gt; SomeOsFunctionalityGuard&lt;T&gt; {<br/>43      // Lock the underlying resource.<br/>44      unsafe {<br/>45        self.inner.lock();<br/>46      }<br/>47 <br/>48      // Wrap a reference to our locked selves in a guard<br/>49      SomeOsFunctionalityGuard { lock: self }<br/>50    }<br/>51  }<br/>52 <br/>53  // Automatically unlock the underlying resource on drop<br/>54  impl&lt;'a, T&gt; Drop for SomeOsFunctionalityGuard&lt;'a, T&gt; {<br/>55    fn drop(&amp;mut self) {<br/>56      unsafe {<br/>57        self.lock.inner.unlock();<br/>58      }<br/>59    }<br/>60  }<br/>61 <br/>62  // Implementing Deref means we can directly<br/>63  // treat SomeOsFunctionalityGuard as if it was T<br/>64  impl&lt;'a, T&gt; Deref for SomeOsFunctionalityGuard&lt;'a, T&gt; {<br/>65    type Target = T;<br/>66 <br/>67    fn deref(&amp;self) -&gt; &amp;T {<br/>68    &amp;self.lock.data<br/>69    }<br/>70  }<br/><br/></pre>
<p style="padding-left: 60px">And finally, the actual usage:</p>
<pre style="padding-left: 60px">72  fn main() {<br/>73    let foo = SomeOsFunctionality::new("Hello World");<br/>74    {<br/>75      // Locking foo returns an unlocked guard<br/>76      let bar = foo.lock();<br/>77      // Because of the Deref implementation on the guard,<br/>78      // we can use it as if it was the underlying data<br/>79      println!("The string behind foo is {} characters long", <br/>         bar.len());<br/>80 <br/>81      // foo is automatically unlocked when we exit this scope<br/>82    }<br/>83    // foo could now be unlocked again if needed<br/>84  }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Well, that's a load of complicated code.</p>
<p>Let's start by introducing the structures that participate in this example:</p>
<ul>
<li><kbd><span>SomeOsSpecificFunctionalityHandle</span></kbd> [6] stands for an unspecified feature of your operating system that operates on some data and is presumably unsafe to use directly. We assume this feature locks some resource of the operating system that needs to be unlocked again.</li>
<li>
<div>
<div><kbd><span>SomeOsFunctionality</span> </kbd> [9] represents a safe wrapper around the feature, plus some data <kbd>T</kbd> that might be useful for it.</div>
</div>
</li>
<li><kbd><span>SomeOsFunctionalityGuard</span></kbd> [20] is an RAII guard created by using the <kbd>lock</kbd> function. When it is dropped, it will automatically unlock the underlying resource. Additionally, it can be directly used as if it was the data <kbd>T</kbd> itself.</li>
</ul>
<p>These functions might look a bit abstract, as they don't do anything specific, but instead act on <em>some</em> unspecified OS feature. This is because most of the really useful candidates are already present in the standard library—see <kbd>File</kbd>, <kbd>RwLock</kbd>, <kbd>Mutex</kbd>, and so on. What's left are particularly domain-specific use cases when writing low-level libraries or dealing with some special, homemade resource that needs automatic unlocking. When you see yourself writing either, you will appreciate the elegance of RAII.</p>
<p>The implementation of the structs introduces some new concepts that might look a bit confusing if encountered for the first time. In the implementation of <kbd>SomeOsSpecificFunctionalityHandle</kbd>, we can spot some <kbd>unsafe</kbd> keywords [25 , 28 and 44] :</p>
<pre style="padding-left: 30px">impl SomeOsSpecificFunctionalityHandle {<br/>    unsafe fn lock(&amp;self) {<br/>        // Here goes the unsafe low level code<br/>    }<br/>    unsafe fn unlock(&amp;self) {<br/>        // Here goes the unsafe low level code<br/>    }<br/>}<br/>...<br/>fn lock(&amp;self) -&gt; SomeOsFunctionalityGuard&lt;T&gt; {<br/>    // Lock the underlying resource.<br/>    unsafe {<br/>        self.inner.lock();<br/>    }<br/><br/></pre>
<pre style="padding-left: 30px">    // Wrap a reference to our locked selves in a guard<br/>    SomeOsFunctionalityGuard { lock: self }<br/>}</pre>
<p>Let's start with the unsafe block [44 to 46]:</p>
<pre style="padding-left: 30px">unsafe {<br/>    self.inner.lock();<br/>}</pre>
<p>The <kbd>unsafe</kbd> keyword tells the compiler to treat the previous block in a special way. It disables the borrow checker and lets you do all kinds of crazy stuff: dereference raw pointers like in C, modify a mutable static variable, and call unsafe functions. In return, the compiler doesn't give you any guarantees about it either. It might, for instance, access invalid memory, resulting in a <strong>SEGFAULT</strong>. If you want to read more about the <kbd>unsafe</kbd> keyword, check out its section in the second edition of the official Rust book at <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html</a>.</p>
<p>Generally speaking, writing unsafe code should be avoided. It is, however, okay to do so when:</p>
<ul>
<li>You're writing some code that directly interfaces with the OS and you want to create a safe wrapper around the unsafe parts, which is what we are doing here</li>
<li>You are absolutely 100% completely certain that what you're doing, in a very specific context, is actually not problematic, contrary to the compiler's opinion</li>
</ul>
<p>If you're wondering why the <kbd>unsafe</kbd> block is empty, that's again because we are not using any actual OS resources in this recipe. If you wanted to use any, the code handling them would go in those two empty blocks.</p>
<p>The other use for the <kbd>unsafe</kbd> keyword is the following [25]:</p>
<p class="mce-root"/>
<pre style="padding-left: 30px">unsafe fn lock(&amp;self) { ... }</pre>
<p>This marks the function itself as unsafe, meaning that it can only be called inside <kbd>unsafe</kbd> blocks. Remember, calling <kbd>unsafe</kbd> code in a function doesn't make the function automatically unsafe because the function could be a safe wrapper around it.</p>
<p>Let's move on now from our hypothetical low-level implementation of <kbd>SomeOsSpecificFunctionalityHandle</kbd> <span>to our realistic implementation of its safe wrapper, </span><kbd>SomeOsFunctionality</kbd><span>[33]. Its constructor comes with no surprises (see</span> <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml">Chapter 1</a>, <em>Learning the Basics</em> and the <em>Using the constructor pattern</em> <span>recipe </span><span>if you need a refresher on that):</span></p>
<div>
<pre style="padding-left: 30px">fn new(data: T) -&gt; Self {<br/>    let handle = SomeOsSpecificFunctionalityHandle;<br/>    SomeOsFunctionality {<br/>        data,<br/>        inner: Box::new(handle),<br/>    }<br/>}</pre>
<p>We simply prepare the underlying OS functionality and store it with the user-provided data in our <kbd>struct</kbd>. We <kbd>Box</kbd> the handle because, as explained in a comment in the code earlier at lines [13 and 14], the low-level struct interfacing with the OS is often not safe to move. Because we don't want to restrict our user from moving our safe wrapper, however, we make the handle movable by putting in on the heap via a <kbd>Box</kbd>, which gives it a permanent address. What is then moved is simply the smart pointer pointing to the address. For more about that, read <a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a>, <em>Advanced Data Structures</em> and the <em>Boxing data </em>recipe.</p>
<p>The actual wrapping takes place in the <kbd>lock</kbd> method:</p>
<pre style="padding-left: 30px">fn lock(&amp;self) -&gt; SomeOsFunctionalityGuard&lt;T&gt; {<br/>    // Lock the underlying resource.<br/>    unsafe {<br/>        self.inner.lock();<br/>    }<br/><br/>    // Wrap a reference to our locked selves in a guard<br/>    SomeOsFunctionalityGuard { lock: self }<br/>}</pre></div>
<p>When working with an actual OS feature or custom resource, you'll want to guarantee that <kbd>self.inner.lock()</kbd> is safe to call in this context before doing so, otherwise, the wrapper won't be safe. This is also where you can do interesting things with <kbd>self.data</kbd>, which you can potentially use in combination with the resource mentioned.</p>
<p>After locking our stuff up, we return a RAII guard with a reference to our structure [49] that will unlock our resource when it is dropped. Looking at the implementation of <kbd>SomeOsFunctionalityGuard</kbd>, you can see that we don't need to implement any kind of new function for it. We just need to implement two traits. We begin with <kbd>Drop</kbd>[54], which you have met in the previous recipe. Implementing it means that we can unlock the resource when the guard is dropped by accessing it through our reference to <kbd>SomeOsFunctionality</kbd>. Again, make sure to arrange the environment in a way that guarantees that <kbd>self.lock.inner.unlock()</kbd> is actually safe before calling it.</p>
<p>Since we are basically creating a kind of smart pointer to <kbd>data</kbd>, we can use the <kbd>Deref</kbd> trait [64]. Implementing <kbd>Deref for B</kbd> with a <kbd>Target</kbd> of <kbd>A</kbd> allows a reference to <kbd>B</kbd> to be dereferenced into <kbd>A</kbd>. Or in other, slightly less accurate words, it lets <kbd>B</kbd> act as if it was <kbd>A</kbd>. In our case, implementing <kbd>Deref for SomeOsFunctionalityGuard</kbd> with a <kbd>Target</kbd> of <kbd>T</kbd> means that we can use our guard as if it was the underlying data. Because this can cause great confusion to the user if implemented poorly, Rust advises you to only implement it on smart pointers and nothing else.</p>
<p>Implementing <kbd>Deref</kbd> is of course not mandatory for the RAII pattern, but can prove pretty useful, as we're going to see in a moment.</p>
<p>Let's look at how we can now use all of our fancy functions:</p>
<pre class="mce-root" style="padding-left: 30px">fn main() {<br/>    let foo = SomeOsFunctionality::new("Hello World");<br/>    {<br/>        let bar = foo.lock();<br/>        println!("The string behind foo is {} characters long", <br/>        bar.len());<br/>    }<br/>}</pre>
<p>The user should never have to use <kbd>SomeOsSpecificFunctionalityHandle</kbd> <span>directly, as it's</span> <kbd>unsafe</kbd><span>. Instead, he can construct an instance of</span> <kbd>SomeOsFunctionality</kbd><span>, which he can pass around and store however he wants [73]. Whenever he needs to use the cool feature behind it, he can call</span> <kbd>lock</kbd> <span>in whatever scope he is in right now, and he will receive a guard that will clean up after him after the work is done [81]. Because he implemented</span> <kbd>Deref</kbd><span>, he can use the guard directly as if it was the underlying data. In our example,</span> <kbd>data</kbd> <span>is a</span> <kbd>&amp;str</kbd><span>, so we can use the methods of</span> <kbd>str</kbd> <span>directly on our guard like we do in line [79] by calling</span> <kbd>.len()</kbd> <span>on it.</span></p>
<div>
<div>
<p>After this little scope ends, our guard calls <kbd>unlock</kbd> on the resource and, because <kbd>foo</kbd> independently still lives on, we can continue locking it again however much we want.</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This example is tailored to be in line with the implementations of <kbd>RwLock</kbd> and <kbd>Mutex</kbd>. The only thing missing is an extra layer of indirection that has been omitted to not make this recipe even more complex. <kbd><span>SomeOsSpecificFunctionalityHandle</span></kbd> shouldn't contain actual implementations of <kbd>lock</kbd> and <kbd>unlock</kbd>, but instead, pass the calls onto a stored implementation that is specific to whatever OS you're using. For example, say you have a struct, <kbd><span>windows::SomeOsSpecificFunctionalityHandle</span></kbd>, for a Windows-based implementation and a struct, <kbd><span>unix::SomeOsSpecificFunctionalityHandle</span></kbd>, for a Unix-based implementation. <kbd><span>SomeOsSpecificFunctionalityHandle</span></kbd> should then, conditionally, depending on the operating system that is being run, pass its <kbd>lock</kbd> and <kbd>unlock</kbd> calls onto the correct implementations. These may have many more features. The Windows one could maybe have a <kbd>awesome_windows_thing()</kbd> function that might be useful to the unlucky Windows developer that needs it. The Unix implementation could have a <kbd>confusing_posix_thing()</kbd> function that does some very weird things that only Unix hackers would understand. The important thing is that our  <kbd><span>SomeOsSpecificFunctionalityHandle</span></kbd> should represent a common interface of the implementations. In our case, that means that every supported OS has the ability to <kbd>lock</kbd> and <kbd>unlock</kbd> the resource in question.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Using the constructor pattern</em> recipe in <a href="0620f24b-d897-497a-b000-d63a1426c3ff.xhtml">Chapter 1</a>, <em>Learning the Basics</em></li>
<li><em>Boxing data</em> <span>recipe in </span><span><a href="6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml">Chapter 5</a></span><span>, <em>Advanced Data Structures</em></span></li>
<li><em>Accessing resources in parallel with RwLocks</em> recipe in <a href="ca93ce61-1a86-4588-9da0-766bed49876f.xhtml" target="_blank">Chapter 7</a>, <em>Parallelism and Rayon</em></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>