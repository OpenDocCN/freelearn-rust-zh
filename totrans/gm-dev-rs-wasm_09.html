<html><head></head><body>
		<div id="_idContainer086">
			<h1 id="_idParaDest-111"><em class="italic"><a id="_idTextAnchor166"/>Chapter 7</em>: Sound Effects and Music</h1>
			<p>Take a moment and think of the game Tetris. If you're like me, you're probably already humming its theme song, <em class="italic">Korobeiniki</em>, because that song is so synonymous with the game itself. Beyond the appeal of music, sound effects are crucial for creating an immersive experience. We play games with more than just the touch of a keyboard or joystick and the use of our eyes; we hear Mario jump or Sonic catch a ring. While our game may be playable, it's just not a game without some sound. To play sound in our game, we'll need to learn how to use the browser's Web Audio API for both short and long sounds.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Adding the Web Audio API to the engine</li>
				<li>Playing sound effects</li>
				<li>Playing long music</li>
			</ul>
			<p>By the end of this chapter, you won't just see RHB run, jump, and dodge obstacles, but you'll be able to hear him too after we add sound effects and music to our game. Let's get started!</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>The technical requirements are largely unchanged from the previous chapters. You will need the <strong class="source-inline">sound</strong> assets from the <strong class="source-inline">sound</strong> directory in the assets download at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. </p>
			<p>All sounds are from open sound collections and are used with permission. See the <strong class="source-inline">sounds/credits.txt</strong> file for more information. The code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_7</a>. </p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3JUdA2R">https://bit.ly/3JUdA2R</a></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor168"/>Adding the Web Audio API to the engine</h1>
			<p>In this section, we'll<a id="_idIndexMarker623"/> be using the browser's Web Audio API to <a id="_idIndexMarker624"/>add sound to our game. The API is incredibly full-featured, allowing for mixing audio sources and special effects, but we're just going to use it to play background music and sounds. In fact, the Web Audio API is its own book and, if you're interested, you can find one at <a href="https://webaudioapi.com/book/">https://webaudioapi.com/book/</a>. While it would be fun to add things such as spatialized audio to our game, we're going to focus on just adding some music and sound effects. I encourage you to experiment on your own when making your own, more complicated games.</p>
			<p>Once we've got an overview of the Web Audio API, we'll create a module to play sounds in Rust, load the sounds in the same way as we load our images, and finally, add that sound to th<a id="_idTextAnchor169"/>e engine.</p>
			<p>The Web Audio API is a relatively new technology that is meant to replace older technology for audio, such as QuickTime and Flash, as well as being a more flexible solution than using audio elements. It's supported by all the major browsers, with only old versions of Internet Explorer being a potential problem. Given that the last release of Internet Explorer was in 2013, with Windows using the Edge browser instead, your game is probably okay with sacrificing that market.</p>
			<p>The Web Audio API may initially look familiar when compared to Canvas. As with Canvas, you create a context that then provides an API for playing sounds. At that point, the similarity ends. Because the Web Audio API has all the features I mentioned earlier, it can be hard to figure out how to do the basic act of playing a sound. Unlike Canvas, there's no <strong class="source-inline">drawImage</strong> equivalent called <strong class="source-inline">playSound</strong> or something like that. Instead, you have to get the sound data, create <strong class="source-inline">AudioBufferSourceNode</strong>, connect it to a destination, and then finally start it. This enables some really impressive effects (such as the ones found at <a href="https://webaudiodemos.appspot.com/">https://webaudiodemos.appspot.com/</a>) but means that, for our game, we'll write the one-time code and forget all about it. In JavaScript, the code to load and prepare a sound for playback looks like the following:</p>
			<p class="source-code">const audioContext = new AudioContext();</p>
			<p class="source-code">let sound = await fetch("SFX_Jump_23.mp3");</p>
			<p class="source-code">let soundBuffer = await sound.arrayBuffer();</p>
			<p class="source-code">let decodedArray = await audioContext.decodeAudioData(soundBuffer);</p>
			<p>It starts by creating a new <strong class="source-inline">AudioContext</strong>, which is built into the browser engine, then fetching a sound file from the server. The <strong class="source-inline">fetch</strong> call eventually returns a response, which we'll need to decode. We do this by first getting its <strong class="source-inline">arrayBuffer</strong>, which consumes it, and then we use the <strong class="source-inline">audioContext</strong> we created at the beginning to decode the buffer into a sound that can be played. Note how everything is asynchronous, which will cause us a little trouble in the Rust code as we map JavaScript promises to Rust futures. The previous code should only be done <em class="italic">once </em>for any sound resource since loading and decoding the file can take significant time.</p>
			<p>The following code will play a sound:</p>
			<p class="source-code">let trackSource = audioContext.createBufferSource();</p>
			<p class="source-code">trackSource.buffer = decodedArray;</p>
			<p class="source-code">trackSource.connect(audioContext.destination);</p>
			<p class="source-code">trackSource.start();</p>
			<p>Ugh, that's not intuitive, but it's what we have. Fortunately, we can wrap it in a few simple functions that we'll be able to remember, and forget all about it. It creates the <strong class="source-inline">AudioBufferSourceNode</strong> we need with <strong class="source-inline">createBufferSource</strong>, assigns it the array that we decoded into audio data in the previous section, connects it to the <strong class="source-inline">audioContext</strong>, and finally, plays<a id="_idIndexMarker625"/> the sound with <strong class="source-inline">start</strong>. It's important to<a id="_idIndexMarker626"/> know that you cannot call <strong class="source-inline">start</strong> on <strong class="source-inline">trackSource</strong> twice, but fortunately, the creation of a buffer source is very fast and won't require us to cache it.</p>
			<p>That's great! We know the eight lines of code to play a sound in JavaScript, but how do we get this into our engi<a id="_idTextAnchor170"/>ne?</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor171"/>Playing a sound in Rust</h2>
			<p>We're<a id="_idIndexMarker627"/> going <a id="_idIndexMarker628"/>to<a id="_idIndexMarker629"/> create a <strong class="source-inline">sound</strong> module that's very similar to our <strong class="source-inline">browser</strong> module, a series of functions that just delegate right to the underlying JavaScript. It will be a very bottom-up approach, where we'll create our utility functions and then create the final functions that use them. We'll start by focusing on the parts we need for a <strong class="source-inline">play_sound</strong> function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember that you want these functions to be very small – it's a <em class="italic">thin</em> layer between Rust and JavaScript – but also to change the interface to better match what you want to do. So, eventually, rather than talking about buffer sources and contexts, we'll want to call that <strong class="source-inline">play_sound</strong> function we wish existed in the first place.</p>
			<p>We'll start by creating the module in a file named <strong class="source-inline">sound.rs</strong> living alongside the rest of our modules in <strong class="source-inline">src</strong>. Don't forget to add a reference to it in <strong class="source-inline">src/lib.rs</strong>, as shown here:</p>
			<p class="source-code">#[macro_use]</p>
			<p class="source-code">mod browser;</p>
			<p class="source-code">mod engine;</p>
			<p class="source-code">mod game;</p>
			<p class="source-code">mod segments;</p>
			<p class="source-code"><strong class="bold">mod sound;</strong></p>
			<p>That's<a id="_idIndexMarker630"/> the<a id="_idIndexMarker631"/> part I <a id="_idIndexMarker632"/>always forget. Our first function will create an <strong class="source-inline">AudioContext</strong> in a <em class="italic">Rusty</em> way as opposed to the JavaScript way we already saw, and that's as follows:</p>
			<p class="source-code">use anyhow::{anyhow, Result};</p>
			<p class="source-code">use web_sys::AudioContext;</p>
			<p class="source-code">pub fn create_audio_context() -&gt; Result&lt;AudioContext&gt; {</p>
			<p class="source-code">    AudioContext::new().map_err(|err| anyhow!</p>
			<p class="source-code">        ("Could not create audio context: {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>As usual, the Rust version of the code is more verbose than the JavaScript version. That's the price we pay for the positives of Rust. None of this code is particularly new; we're mapping <strong class="source-inline">new AudioContext</strong> to <strong class="source-inline">AudioContext::new</strong>, and we're mapping the <strong class="source-inline">JsResult</strong> error to an <strong class="source-inline">anyhow</strong> result that it might return, to be more Rust-friendly. This code doesn't compile though; take a moment and think about why. It's the infamous feature flags for <strong class="source-inline">web-sys</strong> in <strong class="source-inline">Cargo.toml</strong> that we haven't added <strong class="source-inline">AudioContext</strong> to, so <a id="_idIndexMarker633"/>let's<a id="_idIndexMarker634"/> add that <a id="_idIndexMarker635"/>now:</p>
			<p class="source-code">[dependencies.web-sys]</p>
			<p class="source-code">version = "0.3.55"</p>
			<p class="source-code">features = ["console",</p>
			<p class="source-code">           "Window",</p>
			<p class="source-code">           "Document",</p>
			<p class="source-code">           "HtmlCanvasElement",</p>
			<p class="source-code">           "CanvasRenderingContext2d",</p>
			<p class="source-code">           "Element",</p>
			<p class="source-code">           "HtmlImageElement",</p>
			<p class="source-code">           "Response",</p>
			<p class="source-code">           "Performance",</p>
			<p class="source-code">           "KeyboardEvent",</p>
			<p class="source-code">           "<strong class="bold">AudioContext</strong>"</p>
			<p class="source-code">           ]</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Documentation for the <strong class="source-inline">AudioContext</strong> bindings can be found at <a href="https://bit.ly/3tv5PsD">https://bit.ly/3tv5PsD</a>. Remember you can search the <strong class="source-inline">web-sys</strong> documentation for any JavaScript object to find its corresponding Rust library.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Depending on your editor of choice, you may need to restart <strong class="source-inline">rust-analyzer</strong> to get correct compiler errors and code actions when adding a new file to the project (such as <strong class="source-inline">sound.rs</strong>) and/or adding feature flags to the <strong class="source-inline">Cargo.toml</strong> file.</p>
			<p>Now that we've set up the <strong class="source-inline">sound</strong> module, created the function to create <strong class="source-inline">AudioContext</strong>, and refreshed our memory on the process of adding a new feature to the <strong class="source-inline">web-sys</strong> dependency, we can go ahead and add a little more code to play sounds. Let's <a id="_idIndexMarker636"/>introduce all the remaining <a id="_idIndexMarker637"/>feature <a id="_idIndexMarker638"/>flags you'll need to add to <strong class="source-inline">web-sys</strong> in <strong class="source-inline">Cargo.toml</strong>:</p>
			<p class="source-code">[dependencies.web-sys]</p>
			<p class="source-code">version = "0.3.55"</p>
			<p class="source-code">features = ["console",</p>
			<p class="source-code">           "Window",</p>
			<p class="source-code">           "Document",</p>
			<p class="source-code">           "HtmlCanvasElement",</p>
			<p class="source-code">           "CanvasRenderingContext2d",</p>
			<p class="source-code">           "Element",</p>
			<p class="source-code">           "HtmlImageElement",</p>
			<p class="source-code">           "Response",</p>
			<p class="source-code">           "Performance",</p>
			<p class="source-code">           "KeyboardEvent",</p>
			<p class="source-code">           "AudioContext",</p>
			<p class="source-code">           "<strong class="bold">AudioBuffer</strong>",</p>
			<p class="source-code">           "<strong class="bold">AudioBufferSourceNode</strong>",</p>
			<p class="source-code">           "<strong class="bold">AudioDestinationNode</strong>",</p>
			<p class="source-code">           ]</p>
			<p>The three features, <strong class="source-inline">AudioBuffer</strong>, <strong class="source-inline">AudioBufferSourceNode</strong>, and <strong class="source-inline">AudioDestinationNode</strong>, correspond to those same objects in the original JavaScript code. For instance, the <strong class="source-inline">let trackSource = audioContext.createBufferSource();</strong> function returned <strong class="source-inline">AudioBufferSourceNode</strong>. The <strong class="source-inline">web-sys</strong> authors have chosen to hide a large number of audio features under individual flags, so we need to name them one at a time.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember to check the feature flags whenever you can't use a <strong class="source-inline">web-sys</strong> feature. It's always listed in the documentation with a note such as "This API requires the following crate features to be activated: <strong class="source-inline">AudioContext</strong>."</p>
			<p>Now that we have the features ready, we can add the rest of the code without worrying about <a id="_idIndexMarker639"/>those <a id="_idIndexMarker640"/>errors. Back <a id="_idIndexMarker641"/>in the <strong class="source-inline">sound</strong> module, the code will look like this:</p>
			<p class="source-code">use anyhow::{anyhow, Result};</p>
			<p class="source-code">use web_sys::{AudioBuffer, AudioBufferSourceNode, AudioContext, AudioDestinationNode, AudioNode};</p>
			<p class="source-code">...</p>
			<p class="source-code">fn create_buffer_source(ctx: &amp;AudioContext) -&gt; Result&lt;AudioBufferSourceNode&gt; {</p>
			<p class="source-code">    ctx.create_buffer_source()</p>
			<p class="source-code">        .map_err(|err| anyhow!("Error creating buffer </p>
			<p class="source-code">            source {:#?}", err))</p>
			<p class="source-code">}</p>
			<p class="source-code">fn connect_with_audio_node(</p>
			<p class="source-code">    buffer_source: &amp;AudioBufferSourceNode,</p>
			<p class="source-code">    destination: &amp;AudioDestinationNode,</p>
			<p class="source-code">) -&gt; Result&lt;AudioNode&gt; {</p>
			<p class="source-code">    buffer_source</p>
			<p class="source-code">        .connect_with_audio_node(&amp;destination)</p>
			<p class="source-code">        .map_err(|err| anyhow!("Error connecting audio </p>
			<p class="source-code">            source to destination {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>In this book, we've typically gone through the code one function at a time, but for these two it's not necessary. These functions correspond to the calls to <strong class="source-inline">audioContext.createBufferSource</strong> and <strong class="source-inline">trackSource.connect(audioContext.destionation)</strong> respectively. We've converted the code from the object-oriented style of JavaScript into a slightly more procedural format with the functions taking parameters, in part so that we can map errors from the <strong class="source-inline">JsValue</strong> types into proper Rust <strong class="source-inline">Error</strong> types via the <strong class="source-inline">anyhow!</strong> macro. </p>
			<p>Now that <a id="_idIndexMarker642"/>we<a id="_idIndexMarker643"/> have the three functions, we need to play a sound. We can go ahead and write the<a id="_idIndexMarker644"/> function that plays it right below them, shown here:</p>
			<p class="source-code">pub fn play_sound(ctx: &amp;AudioContext, buffer: &amp;AudioBuffer) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    let track_source = create_buffer_source(ctx)?;</p>
			<p class="source-code">    track_source.set_buffer(Some(&amp;buffer));</p>
			<p class="source-code">    connect_with_audio_node(&amp;track_source, </p>
			<p class="source-code">    &amp;ctx.destination())?;</p>
			<p class="source-code">        track_source</p>
			<p class="source-code">        .start()</p>
			<p class="source-code">        .map_err(|err| anyhow! </p>
			<p class="source-code">            ("Could not start sound!{:#?}", err))</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">play_sound</strong> function accepts <strong class="source-inline">AudioContext</strong> and <strong class="source-inline">AudioBuffer</strong> as parameters, then returns the result of the <strong class="source-inline">start</strong> call, with <strong class="source-inline">JsValue</strong> mapped to <strong class="source-inline">Error</strong>. We haven't created an <strong class="source-inline">AudioBuffer</strong> yet anywhere, so don't worry that you don't know how to as we'll cross that bridge when we come to it. What we have here is a function that is very similar to the original JavaScript for playing a sound, but with the additional error handling that comes with Rust, including using the <strong class="source-inline">?</strong> operator to make it easier to read, and a little bit of additional work around <strong class="source-inline">None</strong> in the <strong class="source-inline">track_source.set_buffer(Some(&amp;buffer));</strong> line, where we need to wrap a reference to <strong class="source-inline">AudioBuffer</strong> in <strong class="source-inline">Some</strong> because <strong class="source-inline">track_source</strong> has an optional buffer. In JavaScript, this is <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong>, but in Rust, we need to use the <strong class="source-inline">Option</strong> type. Otherwise, both the JavaScript and Rust versions do the same thing to play a sound:</p>
			<ol>
				<li>Create <strong class="source-inline">AudioBufferSource</strong> from <strong class="source-inline">AudioContext</strong>.</li>
				<li>Set <strong class="source-inline">AudioBuffer</strong> on the source.</li>
				<li>Connect <strong class="source-inline">AudioBufferSource</strong> to the <strong class="source-inline">AudioContext</strong> destination.</li>
				<li>Call <strong class="source-inline">start</strong> to play the sound.</li>
			</ol>
			<p>This <a id="_idIndexMarker645"/>seems<a id="_idIndexMarker646"/> like <a id="_idIndexMarker647"/>a lot, but in reality, it's very fast, so there's not much use in caching <strong class="source-inline">AudioBufferSource</strong>, especially since you can only call <strong class="source-inline">start</strong> once. Now that we can play a sound, it's time to load a sound resource and decode it, so that we have an <strong class="source-inline">AudioBuffer</strong> to <a id="_idTextAnchor172"/>play. Let's do that now.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor173"/>Loading the sound</h2>
			<p>To load a <a id="_idIndexMarker648"/>sound from the server, we'll need to<a id="_idIndexMarker649"/> translate the following code, which you've already seen, into Rust:</p>
			<p class="source-code">let sound = await fetch("SFX_Jump_23.mp3");</p>
			<p class="source-code">let soundBuffer = await sound.arrayBuffer();</p>
			<p class="source-code">let decodedArray = await audioContext.decodeAudioData(soundBuffer);</p>
			<p>Fetching the resource is something we can already do in our <strong class="source-inline">browser</strong> module, but we don't have a handy way to get its <strong class="source-inline">arrayBuffer</strong>, so we'll need to add that. We'll also need to create a Rust version of <strong class="source-inline">decodeAudioData</strong>. Let's start with the changes we need to add to <strong class="source-inline">browser</strong>, which are modifications to existing methods. We'll want to split the<a id="_idIndexMarker650"/> old <strong class="source-inline">fetch_json</strong> function, which looks like this:</p>
			<p class="source-code">pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {</p>
			<p class="source-code">    let resp_value = fetch_with_str(json_path).await?;</p>
			<p class="source-code">    let resp: Response = resp_value</p>
			<p class="source-code">        .dyn_into()</p>
			<p class="source-code">        .map_err(|element| anyhow!("Error converting {:#?} </p>
			<p class="source-code">            to Response", element))?;</p>
			<p class="source-code">    JsFuture::from(</p>
			<p class="source-code">        resp.json()</p>
			<p class="source-code">            .map_err(|err| anyhow!("Could not get JSON from </p>
			<p class="source-code">                response {:#?}", err))?,</p>
			<p class="source-code">    )</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .map_err(|err| anyhow!("error fetching json {:#?}", err</p>
			<p class="source-code">        ))</p>
			<p class="source-code">}</p>
			<p>We need to split it into two functions that first fetch <strong class="source-inline">Result&lt;Response&gt;</strong>, then a second that converts it into JSON:</p>
			<p class="source-code">pub async fn fetch_response(resource: &amp;str) -&gt; Result&lt;Response&gt; {</p>
			<p class="source-code">    fetch_with_str(resource)</p>
			<p class="source-code">        .await?</p>
			<p class="source-code">        .dyn_into()</p>
			<p class="source-code">        .map_err(|err| anyhow!("error converting fetch to </p>
			<p class="source-code">            Response {:#?}", err))</p>
			<p class="source-code">}</p>
			<p class="source-code">pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {</p>
			<p class="source-code">   <strong class="bold"> let resp = fetch_response(json_path).await?;</strong></p>
			<p class="source-code">    JsFuture::from(</p>
			<p class="source-code">        resp.json()</p>
			<p class="source-code">            .map_err(|err| anyhow!("Could not get JSON from </p>
			<p class="source-code">                response {:#?}", err))?,</p>
			<p class="source-code">    )</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .map_err(|err| anyhow!("error fetching JSON {:#?}", err</p>
			<p class="source-code">        ))</p>
			<p class="source-code">}</p>
			<p>This is a<a id="_idIndexMarker651"/> classic case of <em class="italic">the second person pays for abstraction</em>, where we wrote the code we needed in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>,<em class="italic"> Drawing Sprites</em>, to load<a id="_idIndexMarker652"/> JSON, but now we need a version of <strong class="source-inline">fetch</strong> that can handle multiple kinds of responses, specifically, sound files that will be accessible as an <strong class="source-inline">ArrayBuffer</strong> instead. That code will need <strong class="source-inline">fetch_response</strong> but will convert it into a different object. Let's write that code now, right below <strong class="source-inline">fetch_json</strong>:</p>
			<p class="source-code">pub async fn fetch_array_buffer(resource: &amp;str) -&gt; Result&lt;ArrayBuffer&gt; {</p>
			<p class="source-code">    let array_buffer = fetch_response(resource)</p>
			<p class="source-code">        .await?</p>
			<p class="source-code">        .array_buffer()</p>
			<p class="source-code">        .map_err(|err| anyhow!("Error loading array buffer </p>
			<p class="source-code">            {:#?}", err))?;</p>
			<p class="source-code">    JsFuture::from(array_buffer)</p>
			<p class="source-code">        .await</p>
			<p class="source-code">        .map_err(|err| anyhow!("Error converting array </p>
			<p class="source-code">            buffer into a future {:#?}", err))?</p>
			<p class="source-code">        .dyn_into()</p>
			<p class="source-code">        .map_err(|err| anyhow!("Error converting raw </p>
			<p class="source-code">            JSValue to ArrayBuffer {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>Just as <strong class="source-inline">fetch_json</strong> does, this starts by calling <strong class="source-inline">fetch_response</strong> with the passed-in resource. Then, it<a id="_idIndexMarker653"/> calls the <strong class="source-inline">array_buffer()</strong> function on that response, which will return a promise that resolves to <strong class="source-inline">ArrayBuffer</strong>. Then, we convert from a promise to <strong class="source-inline">JsFuture</strong> as usual, in order to use the <strong class="source-inline">await</strong> syntax. Finally, we call <strong class="source-inline">dyn_into</strong> to convert the <strong class="source-inline">JsValue</strong> that all <strong class="source-inline">Promise</strong> types return into <strong class="source-inline">ArrayBuffer</strong>. I've skipped over it, but at each step, we use <strong class="source-inline">map_err</strong> to convert the <strong class="source-inline">JsValue</strong> errors into <strong class="source-inline">Error</strong> types. </p>
			<p>The <strong class="source-inline">ArrayBuffer</strong> type is a JavaScript type that isn't available to our code yet. It's a core JavaScript type, defined in the ECMAScript standard, and in order to use it directly, we need to add the <strong class="source-inline">js-sys</strong> crate. This is somewhat surprising, as we are already pulling in <strong class="source-inline">wasm-bindgen</strong> and <strong class="source-inline">web-sys</strong>, which are both dependent on JavaScript, so why do we need to pull in yet another crate for <strong class="source-inline">ArrayBuffer</strong>? This has to do with how the various crates are arranged. The <strong class="source-inline">web-sys</strong> crate has all the web APIs where <strong class="source-inline">js-sys</strong> is limited to code that is in the ECMAScript standard. Up to now, we haven't had to use anything in core JavaScript except what was exposed by <strong class="source-inline">web-sys</strong>, but this changes with <strong class="source-inline">ArrayBuffer</strong>.</p>
			<p>In order for this code to compile, you'll need to add <strong class="source-inline">js-sys = "0.3.55"</strong> to the list of dependencies in <strong class="source-inline">Cargo.toml</strong>. It is already in <strong class="source-inline">dev-dependencies</strong>, so you can just move it from there. You'll also need to add a <strong class="source-inline">use</strong> <strong class="source-inline">js_sys::ArrayBuffer</strong> declaration to import the <strong class="source-inline">ArrayBuffer</strong> struct<strong class="source-inline">.</strong></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The various libraries are likely to change in small ways after the publication of this book. If you have any difficulties with these dependencies, check the documentation at <a href="https://github.com/rustwasm/wasm-bindgen">https://github.com/rustwasm/wasm-bindgen</a>. </p>
			<p>Now<a id="_idIndexMarker654"/> that <a id="_idIndexMarker655"/>we can fetch a sound file and get it as an <strong class="source-inline">ArrayBuffer</strong>, we're ready to write our version of <strong class="source-inline">await audioContext.decodeAudioData(soundBuffer)</strong>. By now, you may have noticed that we're following the same pattern for wrapping every JavaScript function like this:</p>
			<ol>
				<li value="1">Convert any function that returns a promise, such as <strong class="source-inline">decode_audio_data</strong>, into <strong class="source-inline">JsFuture</strong> so you can use it in asynchronous Rust code.</li>
				<li>Map any errors from <strong class="source-inline">JsValue</strong> into your own error types; in this case, we're using <strong class="source-inline">anyhow::Result</strong> but you may want more specific errors.</li>
				<li>Use the <strong class="source-inline">?</strong> operator to propagate errors.</li>
				<li>Check for feature flags, particularly when using <strong class="source-inline">web_sys</strong> and you just <em class="italic">know</em> a library exists.</li>
			</ol>
			<p>To this, we'll add one more step.</p>
			<ol>
				<li value="5">Cast from <strong class="source-inline">JsValue</strong> types to more specific types using the <strong class="source-inline">dyn_into</strong> function.</li>
			</ol>
			<p>Following that same pattern, the Rust version of <strong class="source-inline">decodeAudioData</strong> goes in the <strong class="source-inline">sound</strong> module, like this:</p>
			<p class="source-code">pub async fn decode_audio_data(</p>
			<p class="source-code">    ctx: &amp;AudioContext,</p>
			<p class="source-code">    array_buffer: &amp;ArrayBuffer,</p>
			<p class="source-code">) -&gt; Result&lt;AudioBuffer&gt; {</p>
			<p class="source-code">    JsFuture::from(</p>
			<p class="source-code">        ctx.decode_audio_data(&amp;array_buffer)</p>
			<p class="source-code">            .map_err(|err| anyhow!("Could not decode audio from array buffer {:#?}", err))?,</p>
			<p class="source-code">    )</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .map_err(|err| anyhow!("Could not convert promise to </p>
			<p class="source-code">        future {:#?}", err))?</p>
			<p class="source-code">    .dyn_into()</p>
			<p class="source-code">    .map_err(|err| anyhow!("Could not cast into AudioBuffer </p>
			<p class="source-code">        {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>You'll <a id="_idIndexMarker656"/>need to <a id="_idIndexMarker657"/>make sure you add <strong class="source-inline">use</strong> declarations for <strong class="source-inline">js_sys::ArrayBuffer</strong> and <strong class="source-inline">wasm_bindgen_futures::JsFuture</strong>, and also <strong class="source-inline">wasm_bindgen::JsCast</strong> to bring the <strong class="source-inline">dyn_into</strong> function into scope. Once again instead of directly calling the method on <strong class="source-inline">AudioContext</strong>, in this case <strong class="source-inline">decodeAudioData</strong>, we've created a function that wraps the call. It borrows a reference to <strong class="source-inline">AudioContext</strong> as the first parameter and takes the <strong class="source-inline">ArrayBuffer</strong> type as the second parameter. This allows us to encapsulate the mapping of errors and casting of results into a function.</p>
			<p>This function then delegates to <strong class="source-inline">ctx.decode_audio_data</strong>, passing it <strong class="source-inline">ArrayBuffer</strong>, but if that's all it did we wouldn't really need it. It then takes any error from <strong class="source-inline">ctx.decode_audio_data</strong> and maps it to <strong class="source-inline">Error</strong> with <strong class="source-inline">anyhow!</strong>; in fact, as you can see, it will ultimately do this at every step in the process, pairing that with the <strong class="source-inline">?</strong> operator to propagate the error. It takes a promise from <strong class="source-inline">decode_audio_data</strong> and creates <strong class="source-inline">JsFuture</strong> from it, then immediately calls <strong class="source-inline">await</strong> to wait for completion, corresponding to the <strong class="source-inline">await</strong> call in JavaScript. After handling any errors converting the promise to <strong class="source-inline">JsFuture</strong>, we use the <strong class="source-inline">dyn_into</strong> function to cast it to <strong class="source-inline">AudioBuffer</strong>, ultimately handling any errors with that as well.</p>
			<p>That function is the most complicated of the wrapper functions, so let's reiterate the steps we did when translating from one line of JavaScript to nine lines of Rust:</p>
			<ol>
				<li value="1">Convert any function that returns a promise into <strong class="source-inline">JsFuture</strong> so you can use it in asynchronous Rust code.</li>
			</ol>
			<p>In this case, <strong class="source-inline">decode_audio_data</strong> returned a promise, and we converted it into <strong class="source-inline">JsFuture</strong> with <strong class="source-inline">JsFuture::from</strong>, then immediately called <strong class="source-inline">await</strong> on it.</p>
			<ol>
				<li value="2">Map<a id="_idIndexMarker658"/> any <a id="_idIndexMarker659"/>errors from <strong class="source-inline">JsValue</strong> into your own error type; in this case, we're using <strong class="source-inline">anyhow::Result</strong>, but you may want more specific errors.</li>
			</ol>
			<p>We did this three times, as every call seemed to return a <strong class="source-inline">JsValue</strong> version of the result, adding clarifying language to the error messages.</p>
			<ol>
				<li value="3">Cast from <strong class="source-inline">JsValue</strong> types to more specific types using the <strong class="source-inline">dyn_into</strong> function.</li>
			</ol>
			<p>We did this to convert the ultimate result of <strong class="source-inline">decode_audio_data</strong> from <strong class="source-inline">JsValue</strong> to <strong class="source-inline">AudioBuffer</strong>, and Rust's compiler could infer the appropriate type from the return value of the function.</p>
			<ol>
				<li value="4">Don't forget to use the <strong class="source-inline">?</strong> operator to propagate errors; note how this function does that twice.</li>
			</ol>
			<p>We used the <strong class="source-inline">?</strong> operator twice to make the function easier to read.</p>
			<ol>
				<li value="5">Check for feature flags, particularly when using <strong class="source-inline">web_sys</strong> and you just <em class="italic">know</em> a library exists.</li>
			</ol>
			<p><strong class="source-inline">AudioBuffer</strong> is feature flagged, but we added that back at the beginning.</p>
			<p>This process is a bit more complicated to explain than it is in practice. For the most part, you can follow the compiler and use tools such as <strong class="source-inline">rust-analyzer</strong> to do things such as automatically add <strong class="source-inline">use</strong> declarations.</p>
			<p>Now that we've got all the utilities, we need to play a sound. It's time to add that feature<a id="_idIndexMarker660"/> to <a id="_idIndexMarker661"/>the<a id="_idTextAnchor174"/> <strong class="source-inline">engine</strong> module so our game can use it.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor175"/>Adding audio to the engine</h2>
			<p>The<a id="_idIndexMarker662"/> functions<a id="_idIndexMarker663"/> we just <a id="_idIndexMarker664"/>created in the <strong class="source-inline">sound</strong> module could be used by the engine directly via delegation functions, but we don't want to make the game worry about <strong class="source-inline">AudioContext</strong>, <strong class="source-inline">AudioBuffer</strong>, and things like that. Just like <strong class="source-inline">Renderer</strong>, we'll create an <strong class="source-inline">Audio</strong> struct that encapsulates the details of that implementation. We'll also create a <strong class="source-inline">Sound</strong> struct to convert <strong class="source-inline">AudioBuffer</strong> into a friendlier type for the rest of the system. Those will be very small, as shown here:</p>
			<p class="source-code">#[derive(Clone)]</p>
			<p class="source-code">pub struct Audio {</p>
			<p class="source-code">    context: AudioContext,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[derive(Clone)]</p>
			<p class="source-code">pub struct Sound {</p>
			<p class="source-code">    buffer: AudioBuffer,</p>
			<p class="source-code">}</p>
			<p>These structs are added to the bottom of the <strong class="source-inline">engine</strong> module, but they can really be put anywhere in the file. Don't forget to import <strong class="source-inline">AudioContext</strong> and <strong class="source-inline">AudioBuffer</strong>! If you're finding yourself getting confused as <strong class="source-inline">engine</strong> and <strong class="source-inline">game</strong> get larger, you're welcome to break that up into multiple files with a <strong class="source-inline">mod.rs</strong> file and a directory, but to follow along, everything needs to end up in the <strong class="source-inline">engine</strong> module. I'm not going to do that because, while it makes the code a bit easier to navigate, it makes it harder to explain and follow along with. Breaking it up into smaller chunks later is an excellent exercise to make sure you understand the code we're writing.</p>
			<p>Now that we have a struct representing <strong class="source-inline">Audio</strong> holding <strong class="source-inline">AudioContext</strong>, and a corresponding <strong class="source-inline">Sound</strong> holding <strong class="source-inline">AudioBuffer</strong>, we can add <strong class="source-inline">impl</strong> to <strong class="source-inline">Audio</strong>, which uses the functions we wrote earlier to play a sound. Now, we'll want to add <strong class="source-inline">impl</strong> to the <strong class="source-inline">Audio</strong> struct to play<a id="_idIndexMarker665"/> sounds and load them. Let's start with the load<a id="_idIndexMarker666"/> implementation, which is <a id="_idIndexMarker667"/>probably the hardest, as seen here:</p>
			<p class="source-code">impl Audio {</p>
			<p class="source-code">    pub fn new() -&gt; Result&lt;Self&gt; {</p>
			<p class="source-code">        Ok(Audio {</p>
			<p class="source-code">            context: sound::create_audio_context()?,</p>
			<p class="source-code">        })</p>
			<p class="source-code">    }</p>
			<p class="source-code">    pub async fn load_sound(&amp;self, filename: &amp;str) -&gt;         Result&lt;Sound&gt; {</p>
			<p class="source-code">        let array_buffer = </p>
			<p class="source-code">            browser::fetch_array_buffer(filename).await?;</p>
			<p class="source-code">        let audio_buffer = </p>
			<p class="source-code">            sound::decode_audio_data(&amp;self.context, </p>
			<p class="source-code">                &amp;array_buffer).await?;</p>
			<p class="source-code">        Ok(Sound {</p>
			<p class="source-code">            buffer: audio_buffer,</p>
			<p class="source-code">        })</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This <strong class="source-inline">impl</strong> will start with two methods, the familiar <strong class="source-inline">new</strong> method that creates an <strong class="source-inline">Audio</strong> struct with <strong class="source-inline">AudioContext</strong>. Pay attention to the fact that <strong class="source-inline">new</strong> returns a result in this case, because <strong class="source-inline">create_audio_context</strong> can fail. Then, we have the <strong class="source-inline">load_sound</strong> method, which also returns a result, this time of the <strong class="source-inline">Sound</strong> type, which is only three lines. This is a sign we did something right with the way we organized our functions in the <strong class="source-inline">sound</strong> and <strong class="source-inline">browser</strong> modules, as we can simply call our <strong class="source-inline">fetch_array_buffer</strong> and <strong class="source-inline">decode_audio_data</strong> functions to get <strong class="source-inline">AudioBuffer</strong> and then wrap it in a <strong class="source-inline">Sound</strong> struct. We return a result and propagate errors via <strong class="source-inline">?</strong>. If <a id="_idIndexMarker668"/>loading <a id="_idIndexMarker669"/>a <a id="_idIndexMarker670"/>sound was simple, then playing it is easy in this method on the <strong class="source-inline">Audio</strong> implementation:</p>
			<p class="source-code">impl Audio {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn play_sound(&amp;self, sound: &amp;Sound) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">        sound::play_sound(&amp;self.context, &amp;sound.buffer)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>For <strong class="source-inline">play_sound</strong>, we really just delegate, passing along <strong class="source-inline">AudioContext</strong> that <strong class="source-inline">Audio</strong> holds and <strong class="source-inline">AudioBuffer</strong> from the passed-in sound. </p>
			<p>We've written a module to play sounds in the API, added loading sounds to the browser, and finally created an audio portion of our game engine. That's enough to play a sound effect in the <a id="_idIndexMarker671"/>engine; now we need to add it<a id="_idIndexMarker672"/> to<a id="_idTextAnchor176"/><a id="_idIndexMarker673"/> our game, and here it's going to get complicated.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor177"/>Playing sound effects</h1>
			<p>Adding sound <a id="_idIndexMarker674"/>effects to our game is a challenge for several reasons:</p>
			<ul>
				<li>Effects must only occur once:</li>
			</ul>
			<p>We'll be adding a sound effect for jumping (<em class="italic">boing!</em>) and want to make sure that it only happens one time. Fortunately, we have something for that already, our state machine! We can use <strong class="source-inline">RedHatBoyContext</strong> to play a sound when something happens, something like this (don't add it yet):</p>
			<p class="source-code">impl RedHatBoyContext {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn play_jump_sound(audio: &amp;Audio) {</p>
			<p class="source-code">        audio.play_sound(self.sound)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This leads directly into our second challenge.</p>
			<ul>
				<li>Playing audio on transitions:</li>
			</ul>
			<p>We want to play the sound at the moment of transition, but most transitions won't play a sound. Remember our state machine uses <strong class="source-inline">transition</strong> to transition from one event to another, and while we could pass in the audio there it would only be used by a small portion of the code in that method. It's a code smell, so we won't do that. <strong class="source-inline">RedHatBoyContext</strong> will have to own the audio and the sound. This isn't ideal, we'd prefer there to be only one audio in the system, but that's not workable with our state machine. That leads to our third problem.</p>
			<ul>
				<li><strong class="source-inline">AudioContext</strong> and <strong class="source-inline">AudioBuffer</strong> are not <strong class="source-inline">Copy</strong>:</li>
			</ul>
			<p>In order to use syntax such as <strong class="source-inline">self.state = self.state.jump();</strong> in the <strong class="source-inline">RedHatBoy</strong> implementation and have each state transition consume <strong class="source-inline">RedHatBoyContext</strong>, we needed <strong class="source-inline">RedHatBoyContext</strong> to be <strong class="source-inline">Copy</strong>. Unfortunately, <strong class="source-inline">AudioContext</strong> and <strong class="source-inline">AudioBuffer</strong> are not <strong class="source-inline">Copy</strong>, which means <strong class="source-inline">Audio</strong> and <strong class="source-inline">Sound</strong> cannot be <strong class="source-inline">Copy</strong> and, therefore, if <strong class="source-inline">RedHatBoyContext</strong> is going to hold audio and a sound, it cannot also be a copy. This stinks, but we can fix it by refactoring <strong class="source-inline">RedHatBoyContext</strong> and <strong class="source-inline">RedHatBoy</strong> to use the <strong class="source-inline">clone</strong> function as needed.</p>
			<p>Having <strong class="source-inline">RedHatBoyContext</strong> own an audio means that there will be more than one <strong class="source-inline">Audio</strong> object in the system potentially, where the other will play music. This is redundant but mostly harmless, so it's the solution we'll go with. It gets us moving forward with development, and in the end, the solution works well. When in doubt, choose the<a id="_idIndexMarker675"/> solution that ships.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may wonder why we don't store a reference to <strong class="source-inline">Audio</strong> in <strong class="source-inline">RedHatBoyContext</strong>. Ultimately, <strong class="source-inline">Game</strong> is static in our engine, and therefore, an <strong class="source-inline">Audio</strong> reference must be guaranteed to live as long as <strong class="source-inline">Game</strong> if it's stored as a reference on <strong class="source-inline">RedHatBoyContext</strong>.</p>
			<p class="callout">There are other options, including using the service locator pattern (<a href="https://bit.ly/3A4th2f">https://bit.ly/3A4th2f</a>) or passing in the audio into the <strong class="source-inline">update</strong> function as a parameter, but they all take longer to get us to our end goal of playi<a id="_idTextAnchor178"/>ng a sound, which is the real goal of this chapter. </p>
			<p>Before we can add a sound effect to the game, we're going to refactor the code to hold an <strong class="source-inline">Audio</strong> element. Then we'll play the sound effect.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor179"/>Refactoring RedHatBoyContext and RedHatBoy</h2>
			<p>We're<a id="_idIndexMarker676"/> going<a id="_idIndexMarker677"/> to prepare <strong class="source-inline">RedHatBoyContext</strong> and <strong class="source-inline">RedHatBoy</strong> to hold audio and a song before we actually do it because that will make it easier to add the sound. Let's start by making <strong class="source-inline">RedHatBoyContext</strong> just <strong class="source-inline">clone</strong>, as shown here:</p>
			<p class="source-code"><strong class="bold">#[derive(Clone)]</strong></p>
			<p class="source-code">struct RedHatBoyContext {</p>
			<p class="source-code">    frame: u8,</p>
			<p class="source-code">    position: Point,</p>
			<p class="source-code">    velocity: Point,</p>
			<p class="source-code">}</p>
			<p>All we've done is removed the <strong class="source-inline">Copy</strong> trait from the <strong class="source-inline">derive</strong> declaration. This will cause compiler errors on <strong class="source-inline">RedHatBoyStateMachine</strong> and <strong class="source-inline">RedHatBoyState&lt;S&gt;</strong>, which both derive <strong class="source-inline">Copy</strong>, so you'll need to remove that declaration on those structures as well. Once you've done that, you'll see a bunch of errors like this:</p>
			<p class="source-code">nerror[E0507]: cannot move out of `self.state` which is behind a mutable reference</p>
			<p class="source-code">   --&gt; src/game.rs:134:22</p>
			<p class="source-code">    |</p>
			<p class="source-code">134 |         self.state_machine = self.state_machine.run();</p>
			<p class="source-code">    |                      ^^^^^^^^^^ move occurs because `self.state` has type `RedHatBoyStateMachine`, which does not implement the `Copy` trait</p>
			<p>As expected, the calls to <strong class="source-inline">self.state.&lt;method&gt;</strong>, where the method takes <strong class="source-inline">self</strong>, all fail to compile, because <strong class="source-inline">RedHatBoyStateMachine</strong> doesn't implement <strong class="source-inline">Copy</strong> anymore. The solution, and we'll do this on every line with this compiler error, is to explicitly clone the state when we want to make the change. Here's the <strong class="source-inline">run_right</strong> function with the error:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn run_right(&amp;mut self) {</p>
			<p class="source-code">        self.state_machine = self.state_machine.            transition(Event::Run);</p>
			<p class="source-code">    }</p>
			<p>And, here it is with the fix:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn run_right(&amp;mut self) {</p>
			<p class="source-code">        self.state_machine = self.state_machine</p>
			<p class="source-code"><strong class="bold">            clone().</strong>transition(Event::Run);</p>
			<p class="source-code">    }</p>
			<p>Perhaps <a id="_idIndexMarker678"/>the<a id="_idIndexMarker679"/> most teeth-grindingly offensive instance of this is in the <strong class="source-inline">transition</strong> method, where we will get a move because of the <strong class="source-inline">match</strong> statement, shown here:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            _ =&gt; <strong class="bold">self</strong>,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>The trouble with this section is that <strong class="source-inline">self</strong> is moved into the <strong class="source-inline">match</strong> statement and cannot be returned in the default case. Trying to use <strong class="source-inline">match</strong> and <strong class="source-inline">self</strong> to get around the issue causes all of the typestate methods, such as <strong class="source-inline">land_on</strong> and <strong class="source-inline">knock_out</strong>, to fail because they need to consume <strong class="source-inline">self</strong>. The <em class="italic">cleanest</em> fix is shown here:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self<strong class="bold">.clone()</strong>, event) {</p>
			<p class="source-code">             ...</p>
			<p class="source-code">             _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>It's gross, I admit, but we are able to keep progressing.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">I know what you're thinking – performance! We're cloning on each transition! You're absolutely right, but do you know that the performance is adversely impacted? The first rule of performance is <em class="italic">measure first</em>, and until we measure this, we don't actually know if the final version of this code is a problem. I spent a lot of time trying to avoid this <strong class="source-inline">clone</strong> call because of performance concerns, and it turned out not to make much of a difference at all. Make it work, then make it fast.</p>
			<p>Once you<a id="_idIndexMarker680"/> fix <a id="_idIndexMarker681"/>that error a few times, you're ready to add the audio and the sound to <strong class="source-inline">RedHatBoyContext</strong>, but what sound will we play?</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor180"/>Adding a sound effect </h2>
			<p>Using the Web <a id="_idIndexMarker682"/>Audio API, we can play any sound format that is supported by the <strong class="source-inline">audio</strong> HTML element, which includes all the common formats of WAV, MP3, MP4, and Ogg. In addition, in 2017, the MP3 license expired, so if you're concerned about that, don't be; you can use MP3 files for sounds without worry.</p>
			<p>Since the Web Audio API is compatible with so many audio formats, you can use sound from all over the internet, provided it's released under the appropriate license. The sound effect we'll be using for jumping is available at <a href="https://opengameart.org/content/8-bit-jump-1">https://opengameart.org/content/8-bit-jump-1</a> and is released under the <em class="italic">Creative Commons public domain</em> license, so we can use it without concern. You don't need to download that bundle and browse through it, although you can, but the jump sound is already bundled with this book's assets at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a> in the <strong class="source-inline">sounds</strong> directory. The specific file we want is <strong class="source-inline">SFX_Jump_23.mp3</strong>. You'll want to copy that file into the <strong class="source-inline">static</strong> directory of your Rust project so that it will be available for your game.</p>
			<p>Now that <strong class="source-inline">RedHatBoyContext</strong> is ready to hold the <strong class="source-inline">Audio</strong> struct, and the <strong class="source-inline">SFX_Jump_23.mp3</strong> file is available to be loaded, we can start adding that code. Start with<a id="_idIndexMarker683"/> adding <strong class="source-inline">Audio</strong> and <strong class="source-inline">Sound</strong> to <strong class="source-inline">RedHatBoyContext</strong> as shown here:</p>
			<p class="source-code">#[derive(Clone)]</p>
			<p class="source-code">pub struct RedHatBoyContext {</p>
			<p class="source-code">    pub frame: u8,</p>
			<p class="source-code">    pub position: Point,</p>
			<p class="source-code">    pub velocity: Point,</p>
			<p class="source-code">    <strong class="bold">audio: Audio,</strong></p>
			<p class="source-code">    <strong class="bold">jump_sound: Sound,</strong></p>
			<p class="source-code">}</p>
			<p>Remember to add <strong class="source-inline">use</strong> declarations for <strong class="source-inline">Audio</strong> and <strong class="source-inline">Sound</strong> to the <strong class="source-inline">red_hat_boy_states</strong> module. The code will stop compiling because <strong class="source-inline">RedHatBoyContext</strong> is being initialized without <strong class="source-inline">audio</strong> or <strong class="source-inline">jump_sound</strong>, so we'll need to add that. <strong class="source-inline">RedHatBoyContext</strong> is initialized in the <strong class="source-inline">new</strong> method of the <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> implementation so we'll change that method to take <strong class="source-inline">Audio</strong> and <strong class="source-inline">Sound</strong> objects that we'll pass into <strong class="source-inline">RedHatBoyContext</strong> as shown here:</p>
			<p class="source-code">impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">    fn new<strong class="bold">(audio: Audio, jump_sound: Sound</strong>) -&gt; Self {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            game_object: RedHatBoyContext {</p>
			<p class="source-code">                frame: 0,</p>
			<p class="source-code">                position: Point {</p>
			<p class="source-code">                    x: STARTING_POINT,</p>
			<p class="source-code">                    y: FLOOR,</p>
			<p class="source-code">                },</p>
			<p class="source-code">                velocity: Point { x: 0, y: 0 },</p>
			<p class="source-code">                <strong class="bold">audio</strong>,</p>
			<p class="source-code">                <strong class="bold">jump_sound</strong>,</p>
			<p class="source-code">            },</p>
			<p class="source-code">            _state: Idle {},</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We could create an <strong class="source-inline">Audio</strong> object here, but then the <strong class="source-inline">new</strong> method would need to return <strong class="source-inline">Result&lt;Self&gt;</strong> and I don't think that's appropriate. This will move the compiler error, because where we call <strong class="source-inline">RedHatBoyState&lt;Idle&gt;::new</strong> is now wrong. That is in <strong class="source-inline">RedHatBoy::new</strong>, which can now also take <strong class="source-inline">Audio</strong> and <strong class="source-inline">Sound</strong> objects and pass them through.</p>
			<p>This leads us to our infamous <strong class="source-inline">initialize</strong> function in our <strong class="source-inline">Game</strong> implementation, which fails to compile because it calls <strong class="source-inline">RedHatBoy::new</strong> without <strong class="source-inline">Audio</strong> or <strong class="source-inline">Sound</strong>. This is the<a id="_idIndexMarker684"/> appropriate place to load a file, both because it is <strong class="source-inline">async</strong> and because it returns a result. We'll create an <strong class="source-inline">Audio</strong> object in <strong class="source-inline">initialize</strong>, load up the sound we want, and pass it to the <strong class="source-inline">RedHatBoy::new</strong> function, as shown here:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                <strong class="bold">let audio = Audio::new()?;</strong></p>
			<p class="source-code">                <strong class="bold">let sound = audio.load_sound</strong></p>
			<p class="source-code"><strong class="bold">                    ("SFX_Jump_23.mp3").await?;</strong></p>
			<p class="source-code">                let rhb = RedHatBoy::new(</p>
			<p class="source-code">                    sheet,</p>
			<p class="source-code">                    engine::load_image("rhb.png").await?,</p>
			<p class="source-code">                    <strong class="bold">audio</strong>,</p>
			<p class="source-code">                    <strong class="bold">sound</strong>,</p>
			<p class="source-code">                );</p>
			<p class="source-code">                ...</p>
			<p class="source-code">            }</p>
			<p>This will get the app compiling again, but we don't do anything with <strong class="source-inline">audio</strong> or <strong class="source-inline">sound</strong>. Remember that all this work was done because we wanted to make sure the sound is only <a id="_idIndexMarker685"/>played <em class="italic">once</em> when we jump, and the way to ensure that is to put the playing of the sound in the transition from <strong class="source-inline">Running</strong> to <strong class="source-inline">Jumping</strong>. Transitions are done in the various <strong class="source-inline">From</strong> implementations via methods on <strong class="source-inline">RedHatBoyContext</strong>. Let's write a small function called <strong class="source-inline">play_jump_sound</strong> on <strong class="source-inline">RedHatBoyContext</strong>, as shown here:</p>
			<p class="source-code">impl RedHatBoyContext {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn play_jump_sound(self) -&gt; Self {</p>
			<p class="source-code">        if let Err(err) = self.audio.play_sound</p>
			<p class="source-code">           (&amp;self.jump_sound) {</p>
			<p class="source-code">            log!("Error playing jump sound {:#?}", err);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function is written a little differently than the other transition side effect functions in this implementation, because <strong class="source-inline">play_sound</strong> returns a result, but in order to be consistent with the other transition methods, <strong class="source-inline">play_jump_sound</strong> really shouldn't. Fortunately, failing to play a sound, while annoying, isn't fatal, so we'll log the error and continue if the sound couldn't be played. The code now compiles, but we need to add the call to <strong class="source-inline">play_jump_sound</strong> to the transition. Look for <strong class="source-inline">jump</strong> on <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> and modify that transition to call <strong class="source-inline">play_jump_sound</strong>, as <a id="_idIndexMarker686"/>shown here:</p>
			<p class="source-code">    impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        pub fn jump(self) -&gt; RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self</p>
			<p class="source-code">                    .context</p>
			<p class="source-code">                    .reset_frame()</p>
			<p class="source-code">                    .set_vertical_velocity(JUMP_SPEED)</p>
			<p class="source-code">                    <strong class="bold">.play_jump_sound(),</strong></p>
			<p class="source-code">                _state: Jumping {},</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p>When this compiles, run the game and you'll see, and hear, RHB jump onto a platform.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer085">
					<img alt="Figure 7.1 – Can you hear it?" src="image/Figure_7.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Can you hear it?</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If, like most developers I know, you have 20+ browser tabs open right now, you may want to close them. It can slow down the browser's sound playback and make the sound timing off.</p>
			<p>Now that you've played one sound effect, consider adding more, for example, when RHB crashes<a id="_idIndexMarker687"/> into an obstacle, or lands cleanly, or slides. The choices are up to you! After you've had a <a id="_idTextAnchor181"/>little fun with sound effects, let's add some background music.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor182"/>Playing long music</h1>
			<p>You might<a id="_idIndexMarker688"/> think that playing music will mean detecting whether the sound is complete and restarting it. This is probably true for the browser's implementation, but fortunately, you don't have to do it. The Web Audio API already has a flag on the <strong class="source-inline">AudioBufferSourceNode</strong> loop that will play the sound on a loop until it is explicitly stopped. This will make playing background audio rather simple. We can add a flag to the <strong class="source-inline">play_sound</strong> function in the <strong class="source-inline">sound</strong> module for the <strong class="source-inline">loop</strong> parameter, as <a id="_idIndexMarker689"/>shown here:</p>
			<p class="source-code"><strong class="bold">fn create_track_source(ctx: &amp;AudioContext, buffer: &amp;AudioBuffer) -&gt; Result&lt;AudioBufferSourceNode&gt; {</strong></p>
			<p class="source-code">    <strong class="bold">let track_source = create_buffer_source(ctx)?;</strong></p>
			<p class="source-code">    <strong class="bold">track_source.set_buffer(Some(&amp;buffer));</strong></p>
			<p class="source-code">    <strong class="bold">connect_with_audio_node(&amp;track_source, </strong></p>
			<p class="source-code"><strong class="bold">        &amp;ctx.destination())?;</strong></p>
			<p class="source-code">    <strong class="bold">Ok(track_source)</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">pub enum LOOPING {</strong></p>
			<p class="source-code"><strong class="bold">    NO,</strong></p>
			<p class="source-code"><strong class="bold">    YES,</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">pub fn play_sound(ctx: &amp;AudioContext, buffer: &amp;AudioBuffer<strong class="bold">, looping: LOOPING)</strong> -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    let track_source = <strong class="bold">create_track_source</strong>(ctx, buffer)?;</p>
			<p class="source-code">    <strong class="bold">if matches!(looping, LOOPING::YES) {</strong></p>
			<p class="source-code"><strong class="bold">        track_source.set_loop(true);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    track_source</p>
			<p class="source-code">        .start()</p>
			<p class="source-code">        .map_err(|err| anyhow!("Could not start sound! </p>
			<p class="source-code">            {:#?}", err))</p>
			<p class="source-code">}</p>
			<p>This starts with the <strong class="source-inline">create_track_source</strong> function, which is actually a refactoring of the <strong class="source-inline">play_sound</strong> function. It takes the first three lines of it and extracts them into a separate function for readability. After that, we create a <strong class="source-inline">LOOPING</strong> enum and use it to check whether we should call <strong class="source-inline">set_loop</strong> on <strong class="source-inline">track_source</strong>. You might wonder why we don't just pass <strong class="source-inline">bool</strong> as the third parameter, and the answer is that it is going to be much easier to read the first line of code shown here than the second:</p>
			<p class="source-code">play_sound(ctx, buffer, LOOPING::YES)</p>
			<p class="source-code">play_sound(ctx, buffer, true)</p>
			<p>Six months from now, when I don't know what that Boolean is for, I'll have to look it up, whereas the version with the enum is obvious. By adding this flag, our program stops compiling <a id="_idIndexMarker690"/>because <strong class="source-inline">Audio</strong> in the engine is still calling <strong class="source-inline">play_sound</strong> with two parameters. We can quickly fix that, as shown here:</p>
			<p class="source-code">impl Audio {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn play_sound(&amp;self, sound: &amp;Sound) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">        sound::play_sound(&amp;self.context, &amp;sound.buffer<strong class="bold">, </strong></p>
			<p class="source-code"><strong class="bold">            sound::LOOPING::NO</strong>)</p>
			<p class="source-code">    }</p>
			<p>We'll also add a new method to play background music, which is just playing a sound with looping turned on:</p>
			<p class="source-code">impl Audio {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn play_looping_sound(&amp;self, sound: &amp;Sound) -&gt; </p>
			<p class="source-code">        Result&lt;()&gt; {</p>
			<p class="source-code">        sound::play_sound(&amp;self.context, &amp;sound.buffer, </p>
			<p class="source-code">            sound::LOOPING::YES)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I like how the engine has progressively less flexibility than the <strong class="source-inline">sound</strong> module. The <strong class="source-inline">sound</strong> and <strong class="source-inline">browser</strong> modules are wrappers around the browser functionality; the engine provides utilities to help you make a game. Now that the engine provides a way to play background music, we can actually add it to the game. In the assets, there's a second file in the <strong class="source-inline">sounds</strong> directory, <strong class="source-inline">background_song.mp3</strong>, which you can copy into the <strong class="source-inline">static</strong> directory of this project. Once you've done that, we can load and play the background<a id="_idIndexMarker691"/> music in our <strong class="source-inline">Game::initialize</strong> function:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                let audio = Audio::new()?;</p>
			<p class="source-code">                let sound = audio.load_sound</p>
			<p class="source-code">                    ("SFX_Jump_23.mp3").await?;</p>
			<p class="source-code">               <strong class="bold"> let background_music = audio.load_sound</strong></p>
			<p class="source-code"><strong class="bold">                    ("background_song.mp3").await?;</strong></p>
			<p class="source-code">               <strong class="bold">     audio.play_looping_sound</strong></p>
			<p class="source-code"><strong class="bold">                        (&amp;background_music)?;</strong></p>
			<p class="source-code">                let rhb = RedHatBoy::new(</p>
			<p class="source-code">                    sheet,</p>
			<p class="source-code">                    engine::load_image("rhb.png").await?,</p>
			<p class="source-code">                    audio,</p>
			<p class="source-code">                    sound,</p>
			<p class="source-code">                );</p>
			<p class="source-code">                ...</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Check out <a href="https://gamesounds.xyz/">https://gamesounds.xyz/</a> for royalty-free sounds for your games.</p>
			<p>Here, we load the second song, <strong class="source-inline">background_song.mp3</strong>, and play it immediately with <strong class="source-inline">play_looping_sound</strong>. On most browsers, you won't hear the music until you click the canvas to give it focus, so check that if you don't hear anything. One thing to note is that, even though that sound is going to go out of scope, the browser will happily keep playing it. We've passed along the song to the browser and it's in charge now. Nothing changes about the creation of <strong class="source-inline">RedHatBoy</strong> as the audio is moved into it, and it will eventually be in charge of playing sound effects for the game.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You may want to mute your browser while developing, as each time the browser refreshes, the song will restart.</p>
			<p>There you <a id="_idIndexMarker692"/>have it! A proper game with music and soun<a id="_idTextAnchor183"/>d effects! Now to add a UI, so we can actually click <strong class="bold">New Game</strong> on it.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor184"/>Summary</h1>
			<p>In this chapter, you added sounds to your game using the Web Audio API and got an overview of the API itself. The Web Audio API is very broad and has a ton of features, and I'd encourage you to explore it. Your first challenge is to use the <strong class="source-inline">gain</strong> property to change the volume of the music, which is rather loud at the moment. The Web Audio API also supports features such as stereo surround sound and programmatically generated music. Have some fun and try it out!</p>
			<p>You also added a new module to the game, and further extended the game engine to support it. We even covered refactoring and made some trade-offs to ensure the game would finish without requiring a time-consuming <em class="italic">ideal</em> design. I encourage you to take some time to add more sound effects to the game; you have the skills now to make RHB <em class="italic">thud</em> when he lands or crashes into a rock. Speaking of crashing into rocks, you're probably sick of having to hit <em class="italic">refresh</em> every time you do that, so in the next chapter, we'll add a small UI with a wonderful <strong class="bold">New Game</strong> button.</p>
		</div>
	</body></html>