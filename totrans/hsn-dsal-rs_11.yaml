- en: Random and Combinatorial
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机和组合
- en: 'While sorting and searching are two very fundamental problems in computer science,
    they are far from the only ones. In fact, those problems have been thoroughly
    solved by people who deeply specialize in such things. In today''s world, it is
    more likely that a solution to a real-world problem involves generating random
    numbers, the best possible combination of several items (combinatorics) , "rolling
    up" several time periods into single numbers, and visualizing the results. Random
    number generation algorithms and solving combinatorial problems efficiently have
    become very important. Especially for the latter, the implementation will be specific
    to the solution, but there are fundamental approaches that remain. In this chapter,
    we will discuss a few of these fundamental approaches and learn about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然排序和搜索是计算机科学中两个非常基本的问题，但它们远非唯一。实际上，这些问题已经被那些深入研究这些领域的人彻底解决了。在当今世界，解决现实世界问题的解决方案更有可能涉及生成随机数、几个项目的最佳组合（组合数学）、将几个时间段“合并”成单个数字，以及可视化结果。随机数生成算法和高效解决组合问题已经成为非常重要的。特别是对于后者，实现将特定于解决方案，但有一些基本方法仍然存在。在本章中，我们将讨论这些基本方法之一，并了解以下内容：
- en: Implementing backtracking algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现回溯算法
- en: Utilizing dynamic programming techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用动态规划技术
- en: How a pseudo-random number generator works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪随机数生成器的工作原理
- en: Pseudo-random numbers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪随机数
- en: In the last few years, random number generation has seen an interesting rise
    in popularity, yet many developers simply accept the generator provided by whatever
    technology they use. However, good random numbers are critical for many applications,
    such as encryption and security (or the lack thereof; see 2010's Sony PlayStation
    3 security incident that prompted a famous XKCD—[https://xkcd.com/221/](https://xkcd.com/221/)),
    simulation, games, statistics, and biology.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，随机数生成在受欢迎程度上有了显著的提升，然而许多开发者只是简单地接受他们所使用的技术提供的生成器。然而，好的随机数对于许多应用至关重要，如加密和安全（或者缺乏安全；参见2010年索尼PlayStation
    3安全事件，该事件引发了一个著名的XKCD——[https://xkcd.com/221/](https://xkcd.com/221/)），模拟、游戏、统计学和生物学。
- en: 'As a basic principle: the more random a sequence is, the better. The reason
    for this is obvious. If any number in a sequence of random numbers is statistically
    dependent on one of the others, it becomes a pattern that can be predicted, and
    there is no such thing as predictable randomness. Thus, the numbers in a random
    sequence have to be statistically independent to qualify as good random numbers.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则是：序列越随机越好。原因很明显。如果一个随机数序列中的任何数字在统计上依赖于另一个数字，它就变成了可以预测的模式，而可预测的随机性是不存在的。因此，随机序列中的数字在统计上必须是独立的，才能被认为是好的随机数。
- en: To get these random numbers, either a pseudo-random number generator or a true
    random number generator can be used (or you can buy a book—[https://www.rand.org/pubs/monograph_reports/MR1418.html](https://www.rand.org/pubs/monograph_reports/MR1418.html)).
    Since computers are deterministic machines, the latter is impossible without an
    external influence, which is why there have actually been (unsuccessful) devices
    to try and achieve truly random numbers. **Pseudo-random number generators** (**PRNGs**),
    on the other hand, are deterministic, but start off using fairly random input
    (mouse pointer movements, network traffic, and so on) and periodically produce
    numbers based on that seed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些随机数，可以使用伪随机数生成器或真正的随机数生成器（或者你可以买一本书——[https://www.rand.org/pubs/monograph_reports/MR1418.html](https://www.rand.org/pubs/monograph_reports/MR1418.html)）。由于计算机是确定性机器，没有外部影响的情况下，后者是不可能的，这也是为什么实际上已经有过（失败的）尝试去实现真正的随机数。另一方面，**伪随机数生成器**（**PRNGs**）是确定性的，但开始时使用相当随机的输入（鼠标指针移动、网络流量等），并定期基于这个种子产生数字。
- en: PRNGs also enjoy a speed advantage (since there is no physical interaction required,
    such as measuring atmospheric noise) and the output is often good enough for many
    applications. In fact, if the seed is very close to random, PRNGs do a great job,
    as can be seen in modern cryptography.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PRNGs还享有速度优势（因为不需要物理交互，例如测量大气噪声），并且输出对于许多应用来说通常足够好。事实上，如果种子非常接近随机，PRNGs可以做得很好，这在现代密码学中可以见到。
- en: 'There are a range of institutions researching PRNGs and their effectiveness
    at producing cryptographically saved random numbers, for example, Germany''s BSI
    provides an in-depth analysis paper ([https://bit.ly/2AOIcBl](https://bit.ly/2AOIcBl)).
    This is a fascinating topic with a close relationship to IT security. For non-security
    researchers, however, there is a simple way to appraise the quality of a random
    number generator at a glance: visual inspection. When randomly deciding whether
    to plot each single pixel in a scatter plot, there should not be any visible pattern.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多机构正在研究PRNG及其在生成加密保存的随机数方面的有效性，例如，德国的BSI提供了一份深入的分析论文([https://bit.ly/2AOIcBl](https://bit.ly/2AOIcBl))。这是一个与IT安全密切相关且非常有趣的话题。然而，对于非安全研究人员来说，有一种简单的方法可以一眼评估随机数生成器的质量：视觉检查。在随机决定是否在散点图中绘制每个单独的像素时，不应该有任何可见的模式。
- en: 'The following graph is of Python''s `numpy.random` random generator, which
    was created to provide the same number from the same seed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表是Python的 `numpy.random` 随机数生成器，它是为了从相同的种子提供相同的数字而创建的：
- en: '![](img/2c0d09b7-25d1-4729-ab5f-928e2671e060.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c0d09b7-25d1-4729-ab5f-928e2671e060.png)'
- en: It fares well enough for statistical work and some simulations, but should not
    be relied upon for cryptographic work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计工作和一些模拟来说，它已经足够好了，但不应该依赖于它来进行加密工作。
- en: 'Regardless of the type of work, a bad random generator should never look like
    this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论工作类型如何，一个糟糕的随机生成器永远不会像这样：
- en: '![](img/f2e87459-49e0-44b1-b2b6-a443b57bd0bd.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2e87459-49e0-44b1-b2b6-a443b57bd0bd.png)'
- en: As the pattern indicates, there are systemic errors that can be found in this
    random generator! Unfortunately, this is not unheard of, even in widely used technologies
    such as PHP on Windows ([https://boallen.com/random-numbers.html](https://boallen.com/random-numbers.html)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如模式所示，在这个随机生成器中可以找到系统错误！遗憾的是，这并不罕见，即使在像Windows上的PHP这样的广泛使用的技术中也是如此([https://boallen.com/random-numbers.html](https://boallen.com/random-numbers.html))。
- en: Thanks to the seed, PRNGs can create reproducible as well as close-to-random
    numbers, which comes in handy for simulations or simply drawing a random sample
    for data science purposes. One very old and well researched method is the **linear
    congruential generator**, or **LCG**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了种子，PRNG可以创建可重复以及接近随机的数字，这对于模拟或简单地为了数据科学目的抽取随机样本来说非常有用。一个非常古老且经过充分研究的方法是**线性同余生成器**，或**LCG**。
- en: LCG
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LCG
- en: 'The LCG is one of the oldest ways of generating a pseudo-random number sequence.
    It follows a simple, recursive formula:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: LCG是生成伪随机数序列的最古老方法之一。它遵循一个简单、递归的公式：
- en: '![](img/2b3715dd-f677-4fd7-bdcb-e69c831c3e76.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b3715dd-f677-4fd7-bdcb-e69c831c3e76.png)'
- en: '*X* denotes the random number (or, more precisely, the *n^(th)* random number
    in the sequence). It is based on its predecessor multiplied by a factor, *a*,
    and offset by a constant, *c*. The modulo operator makes sure that there is no
    overflow. What''s the first *X*? The seed! So a random number sequence will start
    with the seed, providing determinism if needed.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*X* 表示随机数（或者更准确地说，序列中的 *n^(th)* 随机数）。它是基于其前驱数乘以一个因子 *a*，并偏移一个常数 *c*。模运算符确保没有溢出。第一个
    *X* 是什么？种子！因此，随机数序列将从种子开始，如果需要的话，提供确定性。'
- en: 'These parameter settings are subject to significant testing; in fact, many
    library and compiler developers have different settings. The Wikipedia page provides
    an overview ([https://en.wikipedia.org/wiki/Linear_congruential_generator](https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数设置需要经过显著的测试；实际上，许多库和编译器开发者有不同的设置。维基百科页面提供了一个概述([https://en.wikipedia.org/wiki/Linear_congruential_generator](https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use))：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This parameter setting, while chosen at random, does not look terrible:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数设置虽然随机选择，但看起来并不糟糕：
- en: '![](img/31d8bf3a-5b17-41b4-9e07-42c761314588.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31d8bf3a-5b17-41b4-9e07-42c761314588.png)'
- en: 'The bitmap that was generated as a bad example previously also used the LCG,
    but with another random parameter setting:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之前作为糟糕示例生成的位图也使用了LCG，但使用了另一个随机参数设置：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since the result is obviously bad, this goes to show how important the parameters
    are here. Typically, these are not settings you should adjust (or you''d know
    about them). Similarly, two scientists came up with a particular set of magic
    numbers that allow for a better random number generator: the Wichmann-Hill PRNG.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果显然很糟糕，这表明参数在这里是多么重要。通常，这些不是你应该调整的设置（或者你会知道它们）。同样，两位科学家提出了一组特定的“魔法数字”，这允许更好的随机数生成器：Wichmann-Hill
    PRNG。
- en: Wichmann-Hill
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wichmann-Hill
- en: An extended approach to the LCG was taken by Brian Wichmann and David Hill when
    they invented their random number generator. It is based on the LCG, but uses
    three of them modified and combined by (magic) prime numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Brian Wichmann 和 David Hill 发明他们的随机数生成器时，他们采取了一种扩展的 LCG 方法。它基于 LCG，但使用三个经过修改并按（魔法）素数组合的
    LCG。
- en: 'These numbers, when added together, produce a sequence that is 6,953,607,871,644
    (or 6.95 * 10^(12)) numbers long, which means that calling the PRNG after this
    number of calls will make it start over:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字相加后，产生一个长度为 6,953,607,871,644（或 6.95 * 10^(12)）的序列，这意味着在调用这个数量的 PRNG 之后，它将重新开始：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The generator does well, as the visual inspection shows. In fact, the Wichmann-Hill
    generator was used in various technologies and applications in the past, so this
    is not surprising.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表现良好，正如视觉检查所显示的。事实上，Wichmann-Hill 生成器在过去被用于各种技术和应用中，所以这并不令人惊讶。
- en: 'Here is the visual analysis:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是视觉分析：
- en: '![](img/1bf57847-cdea-4317-bd4a-30959cb3e01c.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bf57847-cdea-4317-bd4a-30959cb3e01c.png)'
- en: Clearly, implementing every variation of the random generator is not efficient
    for every project. Luckily, there is an excellent crate on [https://crates.io/](https://crates.io/)
    called `rand`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为每个随机生成器的变体实现都是不高效的。幸运的是，在 [https://crates.io/](https://crates.io/) 上有一个出色的
    crate 叫做 `rand`。
- en: The rand crate
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rand crate
- en: 'When talking about random number generators, there is an excellent crate that
    cannot be skipped: `rand`. Since Rust''s standard library does not include a random
    function, this crate provides that, and more.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到随机数生成器时，有一个非常出色的 crate 不能跳过：`rand`。由于 Rust 的标准库不包含随机函数，这个 crate 提供了那个，还有更多。
- en: In particular, there are several implementations that come with the `rand` crate,
    ranging from regular PRNGs, to an interface to the OS number generator (`/dev/random`
    on Unix-like systems), including a compatible interface for other targets, such
    as web assembly!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`rand` crate 提供了多种实现，从常规的 PRNG 到操作系统数字生成器的接口（在类 Unix 系统上是 `/dev/random`），还包括适用于其他目标（如
    WebAssembly）的兼容接口！
- en: The features are impossible to describe in this chapter, so more information
    on these can be found in their own book ([https://rust-random.github.io/book/](https://rust-random.github.io/book/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性在本章中难以描述，因此更多关于这些特性的信息可以在它们自己的书中找到（[https://rust-random.github.io/book/](https://rust-random.github.io/book/)）。
- en: Back to front
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从后往前
- en: There are types of problems that humans can solve a lot easier than computers.
    These are typically somewhat spatial in nature (for example, a traveling salesman,
    knapsack problem) and rely on patterns, both of which are domains humans are great
    at. Another name for this class of problems is optimization problems, with solutions
    that minimize or maximize a particular aspect (for example, a minimum distance
    or maximum value). A subset of this class is constraint satisfaction problems,
    where a solution has to conform to a set of rules while minimizing or maximizing
    another attribute.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些问题人类比计算机更容易解决。这些问题通常具有某种空间性质（例如，旅行商问题、背包问题），并且依赖于模式，这两者都是人类擅长的领域。这类问题的另一个名称是优化问题，其解决方案旨在最小化或最大化某个特定方面（例如，最小距离或最大值）。这个类别的子集是约束满足问题，其中解决方案必须符合一组规则，同时最小化或最大化另一个属性。
- en: The brute force approach that's used to create these solutions is an algorithmic
    class called backtracking, in which many small choices are recursively added together
    to form a solution. Fundamentally, this search for the optimal solution can run
    to find all possible combinations (*exhaustive* search) or stop early. Why recursion?
    What makes it better suited than regular loops?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些解决方案所使用的暴力方法是算法类别中的回溯法，其中许多小的选择通过递归组合在一起形成一个解决方案。从根本上说，这种寻找最优解的搜索可以运行以找到所有可能的组合（*穷举搜索*）或提前停止。为什么是递归？什么让它比常规循环更适合？
- en: 'A typical constraint satisfaction problem requires incrementally adding items
    to a set of existing items and then evaluating their quality. A backtracking algorithm
    is such that it can backtrack once it encounters a bad solution early on so that
    it can skip at the best possible time. This is much clearer when talking about
    an example, so here are two famous problems that can be solved with regular backtracking
    algorithms: the 0-1 knapsack problem, and the N queens problem.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的约束满足问题需要逐步向现有物品集合中添加物品，然后评估它们的质量。回溯算法就是这样，一旦它早期遇到一个坏解决方案，它就可以回溯，以便在最佳可能的时间跳过。在讨论例子时，这一点会更加清晰，所以这里有可以通过常规回溯算法解决的两个著名问题：0-1背包问题和N皇后问题。
- en: Packing bags or the 0-1 knapsack problem
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包背包或0-1背包问题
- en: 'The knapsack problem is very real: any time you fly with a cheap airline with
    cabin baggage only, things get complicated. Do I really need *this*? I could just
    leave my DSLR at home and use my phone for pictures, right?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题非常现实：每次你只带随身行李乘坐廉价航空公司时，事情就会变得复杂。我真的需要**这个**吗？我可以在家留下我的数码单反相机，用手机拍照，对吧？
- en: 'These are statements that express the potential value of an item and the considerations
    regarding its weight (or volume on these flights), and we typically want to bring
    the most valuable (to us) items on a trip. While this smells like an algorithmic
    problem, it''s far from simple. Let''s start with the goal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是表达物品潜在价值和关于其重量（或这些航班上的体积）的考虑的陈述，我们通常希望带上最有价值的（对我们来说）物品出行。虽然这听起来像是一个算法问题，但它远非简单。让我们从目标开始：
- en: '*Given n items (with weights and values), find the subset of items providing
    the highest value without exceeding the knapsack''s capacity, W.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*给定n个物品（具有重量和价值），找到提供最高价值且不超过背包容量W的物品子集。*'
- en: 'Derived from this, the way to implement the solution can be constructed as
    follows: as an exhaustive search algorithm, every possible solution can be the
    best solution. However, this will only become clear once all solutions are evaluated.
    Thus, let''s generate every possible solution first and then worry about the best
    one.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基础上，构建解决方案的方式可以如下构建：作为一个穷举搜索算法，每个可能的解决方案都可以是最佳解决方案。然而，这只有在所有解决方案都被评估之后才会变得清晰。因此，让我们首先生成所有可能的解决方案，然后再考虑最佳方案。
- en: 'For any recursive scenario, it''s important to worry about the exit condition
    first: when should the recursion stop and what will it return? In the case of
    the knapsack problem, the stopping condition is built around the current weight:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何递归场景，首先关注退出条件非常重要：递归何时停止以及它将返回什么？在背包问题的情况下，停止条件是围绕当前重量构建的：
- en: The weight exceeds the capacity
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量超过容量
- en: The current weight is at capacity
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前重量已达到容量
- en: There are no items left
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有剩余的物品
- en: If the capacity is already exceeded, the algorithm returns the data type's minimum
    value and "backtracks" on this execution branch. However, if the weight is exactly
    the same as the capacity, or there are no more items left, a neutral value is
    returned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容量已经超过，算法返回数据类型的最小值，并在该执行分支上进行“回溯”。然而，如果重量正好等于容量，或者没有剩余物品，则返回一个中性值。
- en: 'What does the return value indicate, then? It''s the total value of the items
    and, since this is a search for maximum value, the return value of the two possibilities
    are compared:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么返回值表示什么？它是物品的总价值，由于这是一个寻找最大价值的过程，所以比较两种可能性的返回值：
- en: Including the item
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括物品
- en: Excluding the item
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除物品
- en: 'Thus, we''ll take the maximum of the return values of a recursive call either
    with or without the current item, thereby excluding any combination that exceeds
    the capacity provided:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将取递归调用有或没有当前物品的返回值的最大值，从而排除任何超过提供的容量组合：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A note on architecture: since this example is going to be improved using dynamic
    programming (refer to the following code), a nice way to structure this is to
    create and implement a trait for either technique:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于架构的说明：由于这个例子将使用动态规划（参考以下代码）进行改进，因此一个很好的结构方法是创建并实现一个针对这两种技术的特性：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One question about the runtime complexity of this algorithm remains—and it''s
    not very clear cut this time. Some people suggest that it''s *O(2^n)*, but there
    are two main growth factors: the capacity, as well as the number of available
    items. In this book, the graphs will focus on the number of items to be added
    to the bag, which exercises (pseudo) polynomial complexity (greater than *O(n²)*).
    Regardless, you should know that this is an expensive problem to solve using backtracking.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此算法的运行时间复杂度的问题仍然存在——这次并不那么明确。有些人建议它是*O(2^n)*，但有两个主要增长因素：容量以及可用物品的数量。在这本书中，图表将关注要添加到包中的物品数量，这涉及到（伪）多项式复杂度（大于*O(n²)*）。无论如何，你应该知道这是一个使用回溯法解决的高成本问题。
- en: Another popular example in universities for backtracking is the 8 queens problem
    (or, in its general form, the N queens problem).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学中，回溯法的另一个流行例子是8后问题（或者，在其一般形式中，N后问题）。
- en: N queens
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N后问题
- en: 'The N queens chess problem (the generalized version of the 8 queens problem/puzzle)
    is defined as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: N后棋问题（8后问题/谜题的推广版本）定义如下：
- en: '*On a chessboard with N by N squares, place N queens so that they cannot attack
    each other.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*在一个N×N的棋盘上，放置N个王棋，使得它们不能相互攻击。*'
- en: 'As a first step, it''s important to understand the ways a queen can move in
    chess, which is luckily straightforward: they can move in a straight line up,
    down, left, right, and diagonally, as demonstrated in the following diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，理解棋盘中王棋的移动方式非常重要，幸运的是，这很简单：王棋可以直线向上、向下、向左、向右以及斜线移动，如下面的图示所示：
- en: '![](img/0ede9858-d92b-47a9-ab9c-387780b662ba.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ede9858-d92b-47a9-ab9c-387780b662ba.png)'
- en: 'With this known, the rest is very similar to the preceding knapsack problem,
    but with a few more possibilities caused by various placement options. There are
    a number of strategies to tackle that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，其余部分与前面的背包问题非常相似，但由各种放置选项引起的可能性更多。有几种策略可以应对这种情况：
- en: Each cell individually, which would result in a large number of recursive calls
    quickly
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独对每个单元格进行操作，这会导致大量的递归调用迅速发生
- en: Each row (or column) individually, and iterate over the cells within
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独对每一行（或列）进行操作，并对单元格进行迭代
- en: 'The latter is clearly the preferred method, since a 10 by 10 board results
    in 100 recursive calls for each individual cell (including allocations, for example)
    and thereby quickly results in a stack overflow. Hence, the second option (by
    row) is the best trade-off, since each row/column has to have at least one queen
    placed and it rules out any other queen placements there:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 后者显然是首选方法，因为10×10的棋盘会导致每个单独的单元格有100次递归调用（包括分配等），因此很快就会导致栈溢出。因此，第二种选择（按行）是最佳权衡，因为每一行/列至少要放置一个王棋，并且排除了其他王棋的放置：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The strategy is simple: for each cell in a row, check whether a valid queen
    can be placed under the current conditions. Then, descend deeper into the recursion
    and end it as soon as a valid setting has been found. The result looks as follows
    (*n = 4*):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 策略很简单：对于每一行的每个单元格，检查在当前条件下是否可以放置一个有效的王棋。然后，深入递归，一旦找到有效的设置就结束。结果如下（*n = 4*）：
- en: '![](img/120777b3-5cad-42d7-b860-1edf3089a16d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/120777b3-5cad-42d7-b860-1edf3089a16d.png)'
- en: 'However, the computational complexity of this algorithm grows exponentially
    (*O(2^n)*), which means that for large *n*, it will not finish in any reasonable
    amount of time:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此算法的计算复杂度呈指数增长（*O(2^n)*），这意味着对于大的*n*，它将不会在任何合理的时间内完成：
- en: '![](img/7e11657e-47e3-4caa-a2a7-32d896a6ddeb.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e11657e-47e3-4caa-a2a7-32d896a6ddeb.png)'
- en: The output graph for N queens problems
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: N后问题的输出图
- en: While this particular problem is probably more like a teaching problem, this
    approach can certainly be applied to other (similar) use cases, especially in
    the spatial domain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个特定的问题可能更像是一个教学问题，但这种方法肯定可以应用于其他（类似）用例，尤其是在空间域中。
- en: Advanced problem solving
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级问题解决
- en: Backtracking calculates and finds the best overall solution to a particular
    problem. However, as described in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*, there are problems that have a really large computational
    complexity, which leads to a really long running time. Since this is unlikely
    to be solved by simply making computers faster, smarter approaches are required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯算法计算并找到特定问题的最佳整体解决方案。然而，如[第8章](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml)中所述，*算法评估*，有些问题具有非常大的计算复杂度，这导致运行时间非常长。由于这不太可能通过仅仅提高计算机的速度和智能来解决，因此需要更智能的方法。
- en: With several strategies and techniques available, the choice is yours to find
    an approach that best solves your problem. The position of Rust in this space
    can be critical, thanks to its great speed and memory efficiency, so keeping an
    eye on solutions for complex problems might pay off in the future (in the author's
    opinion).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在多种策略和技术可供选择的情况下，选择一种最适合解决你问题的方法是你的选择。由于Rust在速度和内存效率方面的优势，它在这一领域的位置可能至关重要，因此关注复杂问题的解决方案可能在将来（在作者看来）会得到回报。
- en: 'First up is a surprising programming technique that is aimed at improving the
    complexities of backtracking algorithms: dynamic programming.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一种旨在提高回溯算法复杂度的令人惊讶的编程技术：动态规划。
- en: Dynamic programming
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划
- en: 'The concept of dynamic programming is one of these techniques that you thought
    had a different name: caching. The fundamental idea is to save relevant temporary
    results to a cache and use this precomputed result instead of recalculating something
    over and over again!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划的概念是这些你本以为有不同名称的技术之一：缓存。基本思想是将相关的临时结果保存到缓存中，并使用这个预先计算的结果，而不是反复重新计算！
- en: This means that a problem and a potential solution have to be examined to find
    relevant sub-problems, so any result can be cached. The main upside of this approach
    is that it finds the globally best solution possible, but at the price of a potentially
    high runtime complexity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着必须检查问题和潜在解决方案，以找到相关的子问题，因此任何结果都可以被缓存。这种方法的优点是它找到了可能的全局最佳解决方案，但代价是可能的高运行时间复杂度。
- en: The knapsack problem improved
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背包问题改进
- en: 'As an example, let''s examine the recursive calls of the knapsack solver. For
    brevity, this knapsack is to be filled using a list of three items where the weight
    is uniformly one and has a capacity of two. Since the backtracking algorithm walks
    through the list of items in order (and tries either to include or exclude a particular
    item), the knapsack solver can be seen as a function *K* that maps any items that
    are remaining as well as capacity remaining to a particular value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查背包求解器的递归调用。为了简洁起见，这个背包将使用三个物品的列表来填充，每个物品的重量均匀为1，容量为2。由于回溯算法按顺序遍历物品列表（并尝试包含或排除特定物品），背包求解器可以看作是一个函数
    *K*，它将任何剩余的物品以及剩余容量映射到特定的值：
- en: '![](img/935f3d69-113b-4aee-87fd-1b6e2c40c5c3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/935f3d69-113b-4aee-87fd-1b6e2c40c5c3.png)'
- en: Therefore, at the same level, the same input parameter leads to the same value
    and this is easy to cache. In the preceding diagram, the nodes marked by the rectangle
    are calculated at least twice. This example was taken from the GeeksforGeeks'
    article ([https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/))
    regarding the 0-1 knapsack problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在相同级别上，相同的输入参数导致相同的值，这很容易缓存。在先前的图中，被矩形标记的节点至少被计算了两次。这个例子是从GeeksforGeeks的文章中摘取的（[https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/))，关于0-1背包问题。
- en: 'Before anything else, we can now implement a different trait to the backtracking:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，我们现在可以给回溯算法实现一个不同的特性：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implementation then follows and, as a function with two input parameters, each
    combination of input parameters can be saved in a two-dimensional array, which
    reduces the runtime complexity to walking this matrix, leading to a *O(n * W)*
    runtime complexity:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行实现，作为一个有两个输入参数的函数，每个输入参数的组合都可以保存在一个二维数组中，这降低了运行时间复杂度到遍历这个矩阵，导致 *O(n * W)*
    的运行时间复杂度：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code went from a recursive call chain to constructing a matrix where the
    maximum value for a particular combination is just a lookup, which seriously improves
    the absolute and relative runtime (20 items take 41,902 +/- 10,014 ns when using
    backtracking and 607 +/- 138 ns for dynamic programming):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从递归调用链转变为构建一个矩阵，其中特定组合的最大值只是一个查找，这极大地提高了绝对和相对运行时间（使用回溯法时，20个物品需要41,902 +/-
    10,014纳秒，而动态规划则需要607 +/- 138纳秒）：
- en: '![](img/d895dca2-11eb-4ad4-adb7-df59e03c4ce4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d895dca2-11eb-4ad4-adb7-df59e03c4ce4.png)'
- en: The output graph for Knapsack problems
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题的输出图
- en: 'In relative terms, the runtime complexity improved significantly:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相对而言，运行时间复杂度有了显著提升：
- en: '![](img/a5934e0b-59c8-4831-9b69-d836b2795ddf.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5934e0b-59c8-4831-9b69-d836b2795ddf.png)'
- en: The runtime complexity graph comparison between dynamic programming and backtracking
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划和回溯法的运行时间复杂度对比图
- en: Employing this strategy (or similar) to problems that allow for that kind of
    optimization permits far higher input parameters and therefore enable it to solve
    real-world problems! Imagine an airline trying to work out the most valuable cargo
    it can bring, but it's limited to 40 different items at once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种策略（或类似策略）应用于允许这种优化的问题，可以允许更高的输入参数，因此能够解决现实世界问题！想象一下，一家航空公司试图计算出它能携带的最有价值货物，但它一次只能限制在40种不同的物品中。
- en: Since there are many harder problems (for example, a problem class called NP-hard
    problems), people came up with ways to find good solutions as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多更难的问题（例如，一个称为NP难问题的问题类），人们想出了找到良好解决方案的方法。
- en: Metaheuristic approaches
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元启发式方法
- en: Dynamic programming is great for constraint satisfaction problems. However,
    better solutions can be found using something akin to systematic guessing, or
    metaheuristics. These problem-agnostic solution generators can be classified in
    several ways, for instance, whether they are population-based, inspired by nature,
    and searching globally or locally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划非常适合约束满足问题。然而，通过类似系统猜测或元启发式方法可以找到更好的解决方案。这些与问题无关的解决方案生成器可以根据多种方式分类，例如，它们是否基于群体、是否受自然界启发，以及是在全局还是局部搜索。
- en: Whichever optimization algorithm is chosen, it will treat the problem like a
    search problem, trying to find the best possible solution within the solutions
    provided. Absent of any guarantees to find the best solution possible, it will
    typically find a good enough solution. Thanks to the expensive runtimes of NP-hard
    problems, a wide variety of ways can lead to a better solution than a more specific
    solution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种优化算法，它都会将问题视为搜索问题，试图在提供的解决方案中找到最佳可能的解决方案。在没有找到最佳解决方案的保证的情况下，它通常会找到一个足够好的解决方案。多亏了NP难问题的昂贵运行时间，有各种各样的方法可以找到比更具体解决方案更好的解决方案。
- en: 'Popular metaheuristics include the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的元启发式方法包括以下几种：
- en: Simulated annealing
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟退火
- en: Genetic algorithms
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传算法
- en: Particle swarm optimization
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子群优化
- en: Ant colony optimization
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蚂蚁群优化
- en: Tabu search
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免搜索
- en: Rust's ecosystem features several crates that implement these metaheuristic
    strategies. The progress of some of these crates can be tracked on [http://www.arewelearningyet.com/metaheuristics/](http://www.arewelearningyet.com/metaheuristics/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的生态系统具有几个实现这些元启发式策略的crate。一些这些crate的进展可以在[http://www.arewelearningyet.com/metaheuristics/](http://www.arewelearningyet.com/metaheuristics/)上追踪。
- en: Example metaheuristic – genetic algorithms
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子——遗传算法
- en: Examples include the traveling salesman problem, where a tour of the shortest
    path connecting *n* cities has to be found. With a *O(n!)* runtime complexity,
    only 20 cities prove to be computationally very expensive, but it can be solved
    well enough for a very large *n* by starting off with a random order of cities
    (tour), and then repeatedly recombining or randomly changing (mutating) several
    of these tours only to select the best ones and restarting the process with these.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，旅行商问题，其中需要找到连接*n*个城市的最短路径的旅行。其运行时间复杂度为*O(n!)*，只有20个城市在计算上非常昂贵，但可以通过从城市的随机顺序（旅行）开始，然后反复重新组合或随机改变（变异）这些旅行中的几个，只选择最好的，并使用这些旅行重新开始过程来解决足够好。
- en: 'Using the `rsgenetic` crate ([https://crates.io/crates/rsgenetic](https://crates.io/crates/rsgenetic)),
    implementing the solution becomes a matter of implementing the `TspTour` trait,
    which requires a `fitness()` function to be supplied so that a solution can be
    evaluated, the `crossover()` function to recombine two parents into a new offspring
    tour, and the `mutate()` function to apply random changes to a tour:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rsgenetic`crate ([https://crates.io/crates/rsgenetic](https://crates.io/crates/rsgenetic))，实现解决方案变成实现`TspTour`trait的问题，这需要提供一个`fitness()`函数以便评估解决方案，一个`crossover()`函数将两个父代重新组合成新的后代旅行，以及一个`mutate()`函数对旅行应用随机变化：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once these are implemented, the framework allows you to set a selector to select
    the best *n* solutions in each generation to create the next generation's population.
    These steps are repeated until the fitness values stagnate (converge) and the
    highest fitness in the last generation can be considered a good solution for the
    problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这些，框架允许你设置一个选择器来选择每一代中最佳的*n*个解决方案以创建下一代的人口。这些步骤会重复进行，直到适应度值停滞（收敛），并且最后一代的最高适应度可以被认为是该问题的良好解决方案。
- en: 'Over several generations, a solution like this one can be found:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几代之后，可以找到这样的解决方案：
- en: '![](img/f26b4e7a-419a-4c98-85e5-d9c1b69a9816.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f26b4e7a-419a-4c98-85e5-d9c1b69a9816.png)'
- en: A more in-depth look at solving this problem in JavaScript, as well as in Rust
    (and Wasm), can be found on my blog at [https://blog.x5ff.xyz](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/#).
    A similar approach can be taken to arrange a highly valuable combination of items
    in a knapsack, which is left for you to find out.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的博客[https://blog.x5ff.xyz](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/#)中可以找到更深入地探讨在JavaScript以及Rust（和Wasm）中解决这个问题的方法。可以采取类似的方法来安排背包中高度有价值物品的组合，这留给你去发现。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Other than regular data structures and sorting, as well as searching methods,
    there are several other problems that arise. This chapter talks about a small
    subset of those: generating random numbers and solving constraint satisfaction
    problems.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规数据结构、排序以及搜索方法之外，还有许多其他问题出现。本章讨论了这些问题的一个小子集：生成随机数和解决约束满足问题。
- en: 'Random number generation is useful in lots of ways: encryption, gaming, gambling,
    simulations, data science—all require good random numbers. Good? There are two
    important types: pseudo-random numbers and "real" random numbers. While the latter
    has to be taken from the physical world (computers are deterministic), the former
    can be implemented with the LCG or the Wichmann-Hill generator (which combines
    LCGs using magic numbers).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成在许多方面都很有用：加密、游戏、赌博、模拟、数据科学—all都需要好的随机数。好的？有两种重要的类型：伪随机数和“真实”随机数。后者的来源必须是物理世界（计算机是确定性的），前者可以用LCG或Wichmann-Hill生成器（使用魔法数组合LCG）来实现。
- en: Constraint satisfaction problems are problems that find the best combination
    that conform to a set of constraints. A technique called backtracking builds a
    state of the current permutation by using recursion to generate all combinations,
    but tracking back on those that do not satisfy the required constraints. Both
    the 8 queens (or N queens) problem and the 0-1 knapsack problem are examples of
    backtracking algorithms that exhibit expensive runtime behavior.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 约束满足问题是寻找符合一组约束条件最佳组合的问题。一种称为回溯的技术通过递归生成所有组合来构建当前排列的状态，但会回溯那些不满足所需约束的组合。8皇后（或N皇后）问题和0-1背包问题都是展示昂贵运行时行为的回溯算法示例。
- en: Advanced techniques such as dynamic programming or metaheuristics (that return
    good enough solutions) can lead to a significant improvement in solving these
    challenges quicker (or for larger sizes). Rust, as a fast and efficient language,
    can play a significant role in these techniques in the future.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 高级技术，如动态规划或元启发式（返回足够好的解决方案）可以显著提高解决这些挑战的速度（或对于更大的规模）。作为一个快速且高效的编程语言，Rust在未来可以在这些技术中发挥重要作用。
- en: In the next chapter, we will look into algorithms that the Rust standard library
    provides.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rust标准库提供的算法。
- en: Questions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between PRNGs and RNGs?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PRNGs和RNGs之间的区别是什么？
- en: What crate provides random number generators in Rust?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个crate在Rust中提供随机数生成器？
- en: How can backtracking solve combinatorial problems?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用回溯法解决组合问题？
- en: What is dynamic programming?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是动态规划？
- en: How are metaheuristics a problem-agnostic approach to solving hard problems?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元启发式是如何成为解决难题的无特定问题方法的？
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的参考资料，您可能需要参考以了解本章所涵盖的内容：
- en: '[https://en.wikipedia.org/wiki/Random_number_generator_attack](https://en.wikipedia.org/wiki/Random_number_generator_attack)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Random_number_generator_attack](https://en.wikipedia.org/wiki/Random_number_generator_attack)'
- en: '[https://blog.x5ff.xyz](https://blog.x5ff.xyz)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.x5ff.xyz](https://blog.x5ff.xyz)'
- en: '[https://en.wikipedia.org/wiki/Metaheuristic](https://en.wikipedia.org/wiki/Metaheuristic)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Metaheuristic](https://en.wikipedia.org/wiki/Metaheuristic)'
