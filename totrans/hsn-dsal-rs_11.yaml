- en: Random and Combinatorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While sorting and searching are two very fundamental problems in computer science,
    they are far from the only ones. In fact, those problems have been thoroughly
    solved by people who deeply specialize in such things. In today''s world, it is
    more likely that a solution to a real-world problem involves generating random
    numbers, the best possible combination of several items (combinatorics) , "rolling
    up" several time periods into single numbers, and visualizing the results. Random
    number generation algorithms and solving combinatorial problems efficiently have
    become very important. Especially for the latter, the implementation will be specific
    to the solution, but there are fundamental approaches that remain. In this chapter,
    we will discuss a few of these fundamental approaches and learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing backtracking algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing dynamic programming techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How a pseudo-random number generator works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudo-random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, random number generation has seen an interesting rise
    in popularity, yet many developers simply accept the generator provided by whatever
    technology they use. However, good random numbers are critical for many applications,
    such as encryption and security (or the lack thereof; see 2010's Sony PlayStation
    3 security incident that prompted a famous XKCD—[https://xkcd.com/221/](https://xkcd.com/221/)),
    simulation, games, statistics, and biology.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a basic principle: the more random a sequence is, the better. The reason
    for this is obvious. If any number in a sequence of random numbers is statistically
    dependent on one of the others, it becomes a pattern that can be predicted, and
    there is no such thing as predictable randomness. Thus, the numbers in a random
    sequence have to be statistically independent to qualify as good random numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: To get these random numbers, either a pseudo-random number generator or a true
    random number generator can be used (or you can buy a book—[https://www.rand.org/pubs/monograph_reports/MR1418.html](https://www.rand.org/pubs/monograph_reports/MR1418.html)).
    Since computers are deterministic machines, the latter is impossible without an
    external influence, which is why there have actually been (unsuccessful) devices
    to try and achieve truly random numbers. **Pseudo-random number generators** (**PRNGs**),
    on the other hand, are deterministic, but start off using fairly random input
    (mouse pointer movements, network traffic, and so on) and periodically produce
    numbers based on that seed.
  prefs: []
  type: TYPE_NORMAL
- en: PRNGs also enjoy a speed advantage (since there is no physical interaction required,
    such as measuring atmospheric noise) and the output is often good enough for many
    applications. In fact, if the seed is very close to random, PRNGs do a great job,
    as can be seen in modern cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a range of institutions researching PRNGs and their effectiveness
    at producing cryptographically saved random numbers, for example, Germany''s BSI
    provides an in-depth analysis paper ([https://bit.ly/2AOIcBl](https://bit.ly/2AOIcBl)).
    This is a fascinating topic with a close relationship to IT security. For non-security
    researchers, however, there is a simple way to appraise the quality of a random
    number generator at a glance: visual inspection. When randomly deciding whether
    to plot each single pixel in a scatter plot, there should not be any visible pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph is of Python''s `numpy.random` random generator, which
    was created to provide the same number from the same seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c0d09b7-25d1-4729-ab5f-928e2671e060.png)'
  prefs: []
  type: TYPE_IMG
- en: It fares well enough for statistical work and some simulations, but should not
    be relied upon for cryptographic work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the type of work, a bad random generator should never look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2e87459-49e0-44b1-b2b6-a443b57bd0bd.png)'
  prefs: []
  type: TYPE_IMG
- en: As the pattern indicates, there are systemic errors that can be found in this
    random generator! Unfortunately, this is not unheard of, even in widely used technologies
    such as PHP on Windows ([https://boallen.com/random-numbers.html](https://boallen.com/random-numbers.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the seed, PRNGs can create reproducible as well as close-to-random
    numbers, which comes in handy for simulations or simply drawing a random sample
    for data science purposes. One very old and well researched method is the **linear
    congruential generator**, or **LCG**.
  prefs: []
  type: TYPE_NORMAL
- en: LCG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The LCG is one of the oldest ways of generating a pseudo-random number sequence.
    It follows a simple, recursive formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b3715dd-f677-4fd7-bdcb-e69c831c3e76.png)'
  prefs: []
  type: TYPE_IMG
- en: '*X* denotes the random number (or, more precisely, the *n^(th)* random number
    in the sequence). It is based on its predecessor multiplied by a factor, *a*,
    and offset by a constant, *c*. The modulo operator makes sure that there is no
    overflow. What''s the first *X*? The seed! So a random number sequence will start
    with the seed, providing determinism if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameter settings are subject to significant testing; in fact, many
    library and compiler developers have different settings. The Wikipedia page provides
    an overview ([https://en.wikipedia.org/wiki/Linear_congruential_generator](https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This parameter setting, while chosen at random, does not look terrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31d8bf3a-5b17-41b4-9e07-42c761314588.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The bitmap that was generated as a bad example previously also used the LCG,
    but with another random parameter setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the result is obviously bad, this goes to show how important the parameters
    are here. Typically, these are not settings you should adjust (or you''d know
    about them). Similarly, two scientists came up with a particular set of magic
    numbers that allow for a better random number generator: the Wichmann-Hill PRNG.'
  prefs: []
  type: TYPE_NORMAL
- en: Wichmann-Hill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An extended approach to the LCG was taken by Brian Wichmann and David Hill when
    they invented their random number generator. It is based on the LCG, but uses
    three of them modified and combined by (magic) prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'These numbers, when added together, produce a sequence that is 6,953,607,871,644
    (or 6.95 * 10^(12)) numbers long, which means that calling the PRNG after this
    number of calls will make it start over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The generator does well, as the visual inspection shows. In fact, the Wichmann-Hill
    generator was used in various technologies and applications in the past, so this
    is not surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the visual analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf57847-cdea-4317-bd4a-30959cb3e01c.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, implementing every variation of the random generator is not efficient
    for every project. Luckily, there is an excellent crate on [https://crates.io/](https://crates.io/)
    called `rand`.
  prefs: []
  type: TYPE_NORMAL
- en: The rand crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about random number generators, there is an excellent crate that
    cannot be skipped: `rand`. Since Rust''s standard library does not include a random
    function, this crate provides that, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, there are several implementations that come with the `rand` crate,
    ranging from regular PRNGs, to an interface to the OS number generator (`/dev/random`
    on Unix-like systems), including a compatible interface for other targets, such
    as web assembly!
  prefs: []
  type: TYPE_NORMAL
- en: The features are impossible to describe in this chapter, so more information
    on these can be found in their own book ([https://rust-random.github.io/book/](https://rust-random.github.io/book/)).
  prefs: []
  type: TYPE_NORMAL
- en: Back to front
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are types of problems that humans can solve a lot easier than computers.
    These are typically somewhat spatial in nature (for example, a traveling salesman,
    knapsack problem) and rely on patterns, both of which are domains humans are great
    at. Another name for this class of problems is optimization problems, with solutions
    that minimize or maximize a particular aspect (for example, a minimum distance
    or maximum value). A subset of this class is constraint satisfaction problems,
    where a solution has to conform to a set of rules while minimizing or maximizing
    another attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The brute force approach that's used to create these solutions is an algorithmic
    class called backtracking, in which many small choices are recursively added together
    to form a solution. Fundamentally, this search for the optimal solution can run
    to find all possible combinations (*exhaustive* search) or stop early. Why recursion?
    What makes it better suited than regular loops?
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical constraint satisfaction problem requires incrementally adding items
    to a set of existing items and then evaluating their quality. A backtracking algorithm
    is such that it can backtrack once it encounters a bad solution early on so that
    it can skip at the best possible time. This is much clearer when talking about
    an example, so here are two famous problems that can be solved with regular backtracking
    algorithms: the 0-1 knapsack problem, and the N queens problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Packing bags or the 0-1 knapsack problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The knapsack problem is very real: any time you fly with a cheap airline with
    cabin baggage only, things get complicated. Do I really need *this*? I could just
    leave my DSLR at home and use my phone for pictures, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are statements that express the potential value of an item and the considerations
    regarding its weight (or volume on these flights), and we typically want to bring
    the most valuable (to us) items on a trip. While this smells like an algorithmic
    problem, it''s far from simple. Let''s start with the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Given n items (with weights and values), find the subset of items providing
    the highest value without exceeding the knapsack''s capacity, W.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Derived from this, the way to implement the solution can be constructed as
    follows: as an exhaustive search algorithm, every possible solution can be the
    best solution. However, this will only become clear once all solutions are evaluated.
    Thus, let''s generate every possible solution first and then worry about the best
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For any recursive scenario, it''s important to worry about the exit condition
    first: when should the recursion stop and what will it return? In the case of
    the knapsack problem, the stopping condition is built around the current weight:'
  prefs: []
  type: TYPE_NORMAL
- en: The weight exceeds the capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current weight is at capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no items left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the capacity is already exceeded, the algorithm returns the data type's minimum
    value and "backtracks" on this execution branch. However, if the weight is exactly
    the same as the capacity, or there are no more items left, a neutral value is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does the return value indicate, then? It''s the total value of the items
    and, since this is a search for maximum value, the return value of the two possibilities
    are compared:'
  prefs: []
  type: TYPE_NORMAL
- en: Including the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excluding the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we''ll take the maximum of the return values of a recursive call either
    with or without the current item, thereby excluding any combination that exceeds
    the capacity provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A note on architecture: since this example is going to be improved using dynamic
    programming (refer to the following code), a nice way to structure this is to
    create and implement a trait for either technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'One question about the runtime complexity of this algorithm remains—and it''s
    not very clear cut this time. Some people suggest that it''s *O(2^n)*, but there
    are two main growth factors: the capacity, as well as the number of available
    items. In this book, the graphs will focus on the number of items to be added
    to the bag, which exercises (pseudo) polynomial complexity (greater than *O(n²)*).
    Regardless, you should know that this is an expensive problem to solve using backtracking.'
  prefs: []
  type: TYPE_NORMAL
- en: Another popular example in universities for backtracking is the 8 queens problem
    (or, in its general form, the N queens problem).
  prefs: []
  type: TYPE_NORMAL
- en: N queens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The N queens chess problem (the generalized version of the 8 queens problem/puzzle)
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*On a chessboard with N by N squares, place N queens so that they cannot attack
    each other.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, it''s important to understand the ways a queen can move in
    chess, which is luckily straightforward: they can move in a straight line up,
    down, left, right, and diagonally, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ede9858-d92b-47a9-ab9c-387780b662ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this known, the rest is very similar to the preceding knapsack problem,
    but with a few more possibilities caused by various placement options. There are
    a number of strategies to tackle that:'
  prefs: []
  type: TYPE_NORMAL
- en: Each cell individually, which would result in a large number of recursive calls
    quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row (or column) individually, and iterate over the cells within
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter is clearly the preferred method, since a 10 by 10 board results
    in 100 recursive calls for each individual cell (including allocations, for example)
    and thereby quickly results in a stack overflow. Hence, the second option (by
    row) is the best trade-off, since each row/column has to have at least one queen
    placed and it rules out any other queen placements there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The strategy is simple: for each cell in a row, check whether a valid queen
    can be placed under the current conditions. Then, descend deeper into the recursion
    and end it as soon as a valid setting has been found. The result looks as follows
    (*n = 4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/120777b3-5cad-42d7-b860-1edf3089a16d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the computational complexity of this algorithm grows exponentially
    (*O(2^n)*), which means that for large *n*, it will not finish in any reasonable
    amount of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e11657e-47e3-4caa-a2a7-32d896a6ddeb.png)'
  prefs: []
  type: TYPE_IMG
- en: The output graph for N queens problems
  prefs: []
  type: TYPE_NORMAL
- en: While this particular problem is probably more like a teaching problem, this
    approach can certainly be applied to other (similar) use cases, especially in
    the spatial domain.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced problem solving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtracking calculates and finds the best overall solution to a particular
    problem. However, as described in [Chapter 8](6ab96dc6-b8f5-4c03-88a3-f4a345f8cc9b.xhtml),
    *Algorithm Evaluation*, there are problems that have a really large computational
    complexity, which leads to a really long running time. Since this is unlikely
    to be solved by simply making computers faster, smarter approaches are required.
  prefs: []
  type: TYPE_NORMAL
- en: With several strategies and techniques available, the choice is yours to find
    an approach that best solves your problem. The position of Rust in this space
    can be critical, thanks to its great speed and memory efficiency, so keeping an
    eye on solutions for complex problems might pay off in the future (in the author's
    opinion).
  prefs: []
  type: TYPE_NORMAL
- en: 'First up is a surprising programming technique that is aimed at improving the
    complexities of backtracking algorithms: dynamic programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of dynamic programming is one of these techniques that you thought
    had a different name: caching. The fundamental idea is to save relevant temporary
    results to a cache and use this precomputed result instead of recalculating something
    over and over again!'
  prefs: []
  type: TYPE_NORMAL
- en: This means that a problem and a potential solution have to be examined to find
    relevant sub-problems, so any result can be cached. The main upside of this approach
    is that it finds the globally best solution possible, but at the price of a potentially
    high runtime complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The knapsack problem improved
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, let''s examine the recursive calls of the knapsack solver. For
    brevity, this knapsack is to be filled using a list of three items where the weight
    is uniformly one and has a capacity of two. Since the backtracking algorithm walks
    through the list of items in order (and tries either to include or exclude a particular
    item), the knapsack solver can be seen as a function *K* that maps any items that
    are remaining as well as capacity remaining to a particular value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/935f3d69-113b-4aee-87fd-1b6e2c40c5c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, at the same level, the same input parameter leads to the same value
    and this is easy to cache. In the preceding diagram, the nodes marked by the rectangle
    are calculated at least twice. This example was taken from the GeeksforGeeks'
    article ([https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/))
    regarding the 0-1 knapsack problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before anything else, we can now implement a different trait to the backtracking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation then follows and, as a function with two input parameters, each
    combination of input parameters can be saved in a two-dimensional array, which
    reduces the runtime complexity to walking this matrix, leading to a *O(n * W)*
    runtime complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code went from a recursive call chain to constructing a matrix where the
    maximum value for a particular combination is just a lookup, which seriously improves
    the absolute and relative runtime (20 items take 41,902 +/- 10,014 ns when using
    backtracking and 607 +/- 138 ns for dynamic programming):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d895dca2-11eb-4ad4-adb7-df59e03c4ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: The output graph for Knapsack problems
  prefs: []
  type: TYPE_NORMAL
- en: 'In relative terms, the runtime complexity improved significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5934e0b-59c8-4831-9b69-d836b2795ddf.png)'
  prefs: []
  type: TYPE_IMG
- en: The runtime complexity graph comparison between dynamic programming and backtracking
  prefs: []
  type: TYPE_NORMAL
- en: Employing this strategy (or similar) to problems that allow for that kind of
    optimization permits far higher input parameters and therefore enable it to solve
    real-world problems! Imagine an airline trying to work out the most valuable cargo
    it can bring, but it's limited to 40 different items at once.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are many harder problems (for example, a problem class called NP-hard
    problems), people came up with ways to find good solutions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Metaheuristic approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic programming is great for constraint satisfaction problems. However,
    better solutions can be found using something akin to systematic guessing, or
    metaheuristics. These problem-agnostic solution generators can be classified in
    several ways, for instance, whether they are population-based, inspired by nature,
    and searching globally or locally.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever optimization algorithm is chosen, it will treat the problem like a
    search problem, trying to find the best possible solution within the solutions
    provided. Absent of any guarantees to find the best solution possible, it will
    typically find a good enough solution. Thanks to the expensive runtimes of NP-hard
    problems, a wide variety of ways can lead to a better solution than a more specific
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Popular metaheuristics include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulated annealing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle swarm optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ant colony optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabu search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust's ecosystem features several crates that implement these metaheuristic
    strategies. The progress of some of these crates can be tracked on [http://www.arewelearningyet.com/metaheuristics/](http://www.arewelearningyet.com/metaheuristics/).
  prefs: []
  type: TYPE_NORMAL
- en: Example metaheuristic – genetic algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Examples include the traveling salesman problem, where a tour of the shortest
    path connecting *n* cities has to be found. With a *O(n!)* runtime complexity,
    only 20 cities prove to be computationally very expensive, but it can be solved
    well enough for a very large *n* by starting off with a random order of cities
    (tour), and then repeatedly recombining or randomly changing (mutating) several
    of these tours only to select the best ones and restarting the process with these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `rsgenetic` crate ([https://crates.io/crates/rsgenetic](https://crates.io/crates/rsgenetic)),
    implementing the solution becomes a matter of implementing the `TspTour` trait,
    which requires a `fitness()` function to be supplied so that a solution can be
    evaluated, the `crossover()` function to recombine two parents into a new offspring
    tour, and the `mutate()` function to apply random changes to a tour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once these are implemented, the framework allows you to set a selector to select
    the best *n* solutions in each generation to create the next generation's population.
    These steps are repeated until the fitness values stagnate (converge) and the
    highest fitness in the last generation can be considered a good solution for the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over several generations, a solution like this one can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f26b4e7a-419a-4c98-85e5-d9c1b69a9816.png)'
  prefs: []
  type: TYPE_IMG
- en: A more in-depth look at solving this problem in JavaScript, as well as in Rust
    (and Wasm), can be found on my blog at [https://blog.x5ff.xyz](https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/#).
    A similar approach can be taken to arrange a highly valuable combination of items
    in a knapsack, which is left for you to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than regular data structures and sorting, as well as searching methods,
    there are several other problems that arise. This chapter talks about a small
    subset of those: generating random numbers and solving constraint satisfaction
    problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Random number generation is useful in lots of ways: encryption, gaming, gambling,
    simulations, data science—all require good random numbers. Good? There are two
    important types: pseudo-random numbers and "real" random numbers. While the latter
    has to be taken from the physical world (computers are deterministic), the former
    can be implemented with the LCG or the Wichmann-Hill generator (which combines
    LCGs using magic numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: Constraint satisfaction problems are problems that find the best combination
    that conform to a set of constraints. A technique called backtracking builds a
    state of the current permutation by using recursion to generate all combinations,
    but tracking back on those that do not satisfy the required constraints. Both
    the 8 queens (or N queens) problem and the 0-1 knapsack problem are examples of
    backtracking algorithms that exhibit expensive runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced techniques such as dynamic programming or metaheuristics (that return
    good enough solutions) can lead to a significant improvement in solving these
    challenges quicker (or for larger sizes). Rust, as a fast and efficient language,
    can play a significant role in these techniques in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into algorithms that the Rust standard library
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between PRNGs and RNGs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What crate provides random number generators in Rust?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can backtracking solve combinatorial problems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is dynamic programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are metaheuristics a problem-agnostic approach to solving hard problems?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Random_number_generator_attack](https://en.wikipedia.org/wiki/Random_number_generator_attack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blog.x5ff.xyz](https://blog.x5ff.xyz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Metaheuristic](https://en.wikipedia.org/wiki/Metaheuristic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
