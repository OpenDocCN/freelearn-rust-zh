["```rs\n    pub mod guards;\n    ```", "```rs\n    pub mod auth;\n    ```", "```rs\n    use crate::fairings::db::DBConnection;\n    use crate::models::user::User;\n    use rocket::http::Status;\n    use rocket::request::{FromRequest, Outcome, Request};\n    use rocket::serde::Serialize;\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    #[derive(Serialize)]\n    pub struct CurrentUser {\n        pub user: User,\n    }\n    ```", "```rs\n    pub const LOGIN_COOKIE_NAME: &str = \"user_uuid\";\n    ```", "```rs\n    #[rocket::async_trait]\n    impl<'r> FromRequest<'r> for CurrentUser {\n        type Error = ();\n        async fn from_request(req: &'r Request<'_>) -> \n        Outcome<Self, Self::Error> {\n        }\n    }\n    ```", "```rs\n    let error = Outcome::Failure((Status::Unauthorized, ()));\n    ```", "```rs\n    let parsed_cookie = req.cookies().get_private(LOGIN_COOKIE_NAME);\n    if parsed_cookie.is_none() {\n        return error;\n    }\n    let cookie = parsed_cookie.unwrap();\n    let uuid = cookie.value();\n    ```", "```rs\n    let parsed_db = req.guard::<Connection<DBConnection>>().await;\n    if !parsed_db.is_success() {\n        return error;\n    }\n    let mut db = parsed_db.unwrap();\n    let parsed_connection = db.acquire().await;\n    if parsed_connection.is_err() {\n        return error;\n    }\n    let connection = parsed_connection.unwrap();\n    ```", "```rs\n    let found_user = User::find(connection, uuid).await;\n    if found_user.is_err() {\n        return error;\n    }\n    let user = found_user.unwrap();\n    Outcome::Success(CurrentUser { user })\n    ```", "```rs\n    {% extends \"template\" %}\n    {% block body %}\n      <form accept-charset=\"UTF-8\" action=\"login\" \n      autocomplete=\"off\" method=\"POST\">\n        <input type=\"hidden\" name=\"authenticity_token\" \n        value=\"{{ csrf_token }}\"/>\n        <fieldset>\n          <legend>Login</legend>\n          <div class=\"row\">\n            <div class=\"col-sm-12 col-md-3\">\n              <label for=\"username\">Username:</label>\n            </div>\n            <div class=\"col-sm-12 col-md\">\n              <input name=\"username\" type=\"text\" value=\"\" \n              />\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col-sm-12 col-md-3\">\n              <label for=\"password\">Password:</label>\n            </div>\n            <div class=\"col-sm-12 col-md\">\n              <input name=\"password\" type=\"password\" />\n            </div>\n          </div>\n          <button type=\"submit\" value=\"Submit\">\n          Submit</button>\n        </fieldset>\n      </form>\n    {% endblock %}\n    ```", "```rs\n    #[derive(FromForm)]\n    pub struct Login<'r> {\n        pub username: &'r str,\n        pub password: &'r str,\n        pub authenticity_token: &'r str,\n    }\n    ```", "```rs\n    fn verify_password(ag: &Argon2, reference: &str, password: &str) -> Result<(), OurError> {\n        let reference_hash = PasswordHash::new(\n        reference).map_err(|e| {\n            OurError::new_internal_server_error(\n            String::from(\"Input error\"), Some(\n            Box::new(e)))\n        })?;\n        Ok(ag\n            .verify_password(password.as_bytes(), \n            &reference_hash)\n            .map_err(|e| {\n                OurError::new_internal_server_error(\n                    String::from(\"Cannot verify \n                    password\"),\n                    Some(Box::new(e)),\n                )\n            })?)\n    }\n    ```", "```rs\n    let old_password_hash = PasswordHash::new(&old_user.password_hash).map_err(|e| {\n        OurError::new_internal_server_error(\n        String::from(\"Input error\"), Some(Box::new(e)))\n    })?;\n    let argon2 = Argon2::default();\n    argon2\n        .verify_password(user.old_password.as_bytes(), \n        &old_password_hash)\n        .map_err(|e| {\n            OurError::new_internal_server_error(\n                String::from(\"Cannot confirm old \n                password\"),\n                Some(Box::new(e)),\n            )\n        })?;\n    ```", "```rs\nlet argon2 = Argon2::default();\nverify_password(&argon2, &old_user.password_hash, user.old_password)?;\n```", "```rs\n    pub async fn find_by_login<'r>(\n        connection: &mut PgConnection,\n        login: &'r Login<'r>,\n    ) -> Result<Self, OurError> {\n        let query_str = \"SELECT * FROM users WHERE \n        username = $1\";\n        let user = sqlx::query_as::<_, Self>(query_str)\n            .bind(&login.username)\n            .fetch_one(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?;\n        let argon2 = Argon2::default();\n        verify_password(&argon2, &user.password_hash, \n        &login.password)?;\n        Ok(user)\n    }\n    ```", "```rs\n    pub mod session;\n    ```", "```rs\n    use super::HtmlResponse;\n    use crate::fairings::csrf::Token as CsrfToken;\n    use rocket::request::FlashMessage;\n    use rocket_dyn_templates::{context, Template};\n    #[get(\"/login\", format = \"text/html\")]\n    pub async fn new<'r>(flash: Option<FlashMessage<'_>>, csrf_token: CsrfToken) -> HtmlResponse {\n        let flash_string = flash\n            .map(|fl| format!(\"{}\", fl.message()))\n            .unwrap_or_else(|| \"\".to_string());\n        let context = context! {\n            flash: flash_string,\n            csrf_token: csrf_token,\n        };\n        Ok(Template::render(\"sessions/new\", context))\n    }\n    ```", "```rs\n    use crate::fairings::db::DBConnection;\n    use crate::guards::auth::LOGIN_COOKIE_NAME;\n    use crate::models::user::{Login, User};\n    use rocket::form::{Contextual, Form};\n    use rocket::http::{Cookie, CookieJar};\n    use rocket::response::{Flash, Redirect};\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    ...\n    #[post(\"/login\", format = \"application/x-www-form-urlencoded\", data = \"<login_context>\")]\n    pub async fn create<'r>(\n        mut db: Connection<DBConnection>,\n        login_context: Form<Contextual<'r, Login<'r>>>,\n        csrf_token: CsrfToken,\n        cookies: &CookieJar<'_>,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        let login_error = || Flash::error(\n        Redirect::to(\"/login\"), \"Cannot login\");\n        if login_context.value.is_none() {\n            return Err(login_error());\n        }\n        let login = login_context.value.as_ref().unwrap();\n        csrf_token\n            .verify(&login.authenticity_token)\n            .map_err(|_| login_error())?;\n        let connection = db.acquire().await.map_err(|_| \n        login_error())?;\n        let user = User::find_by_login(connection, login)\n            .await\n            .map_err(|_| login_error())?;\n        cookies.add_private(Cookie::new(LOGIN_COOKIE_NAME, \n        user.uuid.to_string()));\n        Ok(Flash::success(Redirect::to(\"/users\"), \"Login \n        successfully\"))\n    }\n    ```", "```rs\n    #[post(\"/logout\", format = \"application/x-www-form-urlencoded\")]\n    pub async fn delete(cookies: &CookieJar<'_>) -> Flash<Redirect> {\n        cookies.remove_private(\n        Cookie::named(LOGIN_COOKIE_NAME));\n        Flash::success(Redirect::to(\"/users\"), \"Logout \n        successfully\")\n    }\n    ```", "```rs\n    use our_application::routes::{self, post, session, user};\n    ...\n    async fn rocket() -> Rocket<Build> {\n        ...\n        routes![\n        ...\n            session::new,\n            session::create,\n            session::delete,\n        ]\n        ...\n    }\n    ```", "```rs\n    pub async fn edit_user(\n        mut db: Connection<DBConnection>,\n        ...\n    ) -> HtmlResponse {\n        let connection = db\n            .acquire()\n            .await\n            .map_err(|_| Status::InternalServerError)?;\n    let user = User::find(connection, \n        uuid).await.map_err(|e| e.status)?;\n        ...\n    }\n    ```", "```rs\n    use crate::guards::auth::CurrentUser;\n    ...\n    pub async fn edit_user(...\n        current_user: CurrentUser,\n    ) -> HtmlResponse {\n        ...\n        let context = context! {\n            form_url: format!(\"/users/{}\", uuid),\n            ...\n            user: &current_user.user,\n            current_user: &current_user,\n            ...\n        };\n        ...\n    }\n    ...\n    pub async fn update_user<'r>(...\n        current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        ...\n        match user_value.method {\n            \"PUT\" => put_user(db, uuid, user_context, \n            csrf_token, current_user).await,\n            \"PATCH\" => patch_user(db, uuid, user_context, \n            csrf_token, current_user).await,\n            ...\n        }\n    }\n    ...\n    pub async fn put_user<'r>(...\n        _current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ...\n    pub async fn patch_user<'r>(...\n        current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        put_user(db, uuid, user_context, csrf_token, \n        current_user).await\n    }\n    ...\n    pub async fn delete_user_entry_point(...\n        current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        delete_user(db, uuid, current_user).await\n    }\n    ...\n    pub async fn delete_user(...\n        _current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ```", "```rs\n    crate::guards::auth::CurrentUser;\n    ...\n    pub async fn create_post<'r>(...\n        _current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ...\n    pub async fn delete_post(...\n        _current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ```", "```rs\n    impl CurrentUser {\n        pub fn is(&self, uuid: &str) -> bool {\n            self.user.uuid.to_string() == uuid\n        }\n        pub fn is_not(&self, uuid: &str) -> bool {\n            !self.is(uuid)\n        }\n    }\n    ```", "```rs\n    pub fn new_unauthorized_error(debug: Option<Box<dyn Error>>) -> Self {\n        Self::new_error_with_status(Status::Unauthorized, \n        String::from(\"unauthorized\"), debug)\n    }\n    ```", "```rs\n    <body>\n      <header>\n        <a href=\"/users\" class=\"button\">Home</a>\n        {% if current_user %}\n    <form accept-charset=\"UTF-8\" action=\"/logout\" \n          autocomplete=\"off\" method=\"POST\" id=\"logout\"  \n          class=\"hidden\"></form>\n          <button type=\"submit\" value=\"Submit\" form=\"\n          logout\">Logout</button>\n        {% else %}\n          <a href=\"/login\" class=\"button\">Login</a>\n          <a href=\"/users/new\" class=\"button\">Signup</a>\n        {% endif %}\n      </header>\n      <div class=\"container\">\n    ```", "```rs\n    <a href=\"/users/new\" class=\"button\">New user</a>\n    ```", "```rs\n<a href=\"/users/edit/{{ user.uuid }}\" class=\"button\">Edit User</a>\n```", "```rs\n{% if current_user and current_user.user.uuid == user.uuid %}\n    <a href=\"/users/edit/{{user.uuid}}\" class=\"\n    button\">Edit User</a>\n{% endif %}\n```", "```rs\n    <a href=\"/users/edit/{{user.uuid}}\" class=\"button\">Edit User</a>\n    <form accept-charset=\"UTF-8\" action=\"/users/delete/{{user.uuid}}\" autocomplete=\"off\" method=\"POST\" id=\"deleteUser\" class=\"hidden\"></form>\n    <button type=\"submit\" value=\"Submit\" form=\"deleteUser\">Delete</button>\n    ```", "```rs\n{% if current_user and current_user.user.uuid == user.uuid %}\n     <a href... \n    ... \n    </button>\n{% endif %}\n```", "```rs\n    <form action=\"/users/{{ user.uuid }}/posts\" enctype=\"multipart/form-data\" method=\"POST\">\n    ...\n    </form>\n    ```", "```rs\n{% if current_user %}\n     <form action=\"/users/{{ user.uuid }}/posts\" enctype=\"multipart/form-data\" method=\"POST\"> \n    ... \n    </form>\n{% endif %}\n```", "```rs\n    <form accept-charset=\"UTF-8\" action=\"/users/{{user.uuid}}/posts/delete/{{post.uuid}}\" autocomplete=\"off\" method=\"POST\" id=\"deletePost\" class=\"hidden\"></form>\n    <button type=\"submit\" value=\"Submit\" form=\"deletePost\">Delete</button>\n    ```", "```rs\n{% if current_user and current_user.user.uuid == user.uuid %}\n    <form... \n    ... \n    </button>\n{% endif %}\n```", "```rs\npub async fn get_post(...\n    current_user: Option<CurrentUser>,\n) -> HtmlResponse {\n    ...\n    let context = context! {user, current_user, post: \n    &(post.to_show_post())};\n    Ok(Template::render(\"posts/show\", context))\n}\n```", "```rs\n    pub async fn get_posts(...\n        current_user: Option<CurrentUser>,\n    ) -> HtmlResponse {\n        let context = context! {\n            ...\n            current_user,\n        };\n        Ok(Template::render(\"posts/index\", context))\n    }\n    ```", "```rs\n    pub async fn create_post<'r>(...\n        current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        ...\n        if current_user.is_not(user_uuid) {\n            return Err(create_err());\n        }\n        ...\n    }\n    ```", "```rs\n    pub async fn delete_post(...\n        current_user: CurrentUser,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {\n        ...\n        if current_user.is_not(user_uuid) {\n            return Err(delete_err());\n        }\n        ...\n    }\n    ```", "```rs\n{\"next\":\"2022-02-22T22:22:22.222222Z\",\"limit\":10}\n```", "```rs\n    use rocket::serde::{Serialize, Serializer};\n    use serde::ser::SerializeStruct;\n    ...\n    impl Serialize for OurError {\n        fn serialize<S>(&self, serializer: S) -> \n        Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            let mut state = serializer.\n            serialize_struct(\"OurError\", 2)?;\n            state.serialize_field(\"status\", &self\n            .status.code)?;\n            state.serialize_field(\"message\", &self\n            .message)?;\n            state.end()\n        }\n    }\n    ```", "```rs\n    use rocket::serde::{Deserialize, Serialize};\n    ...\n    #[derive(Debug, sqlx::Type, Clone, Serialize, Deserialize)]\n    #[sqlx(transparent)]\n    pub struct OurDateTime(pub DateTime<Utc>);\n    ```", "```rs\n    use rocket::serde::{Deserialize, Serialize};\n    ...\n    #[derive(FromForm, Serialize, Deserialize)]\n    pub struct Pagination {...}\n    ```", "```rs\n    pub struct User {\n        ...\n        #[serde(skip_serializing)]\n        pub password_hash: String,\n        ...\n    }\n    ```", "```rs\n    #[derive(Serialize)]\n    pub struct UsersWrapper {\n        pub users: Vec<User>,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        #[serde(default)]\n        pub pagination: Option<Pagination>,\n    }\n    ```", "```rs\n    pub mod api;\n    ```", "```rs\n    use crate::errors::our_error::OurError;\n    use crate::fairings::db::DBConnection;\n    use crate::models::{\n        pagination::Pagination,\n        user::{User, UsersWrapper},\n    };\n    use rocket_db_pools::Connection;\n    ```", "```rs\n    use rocket::serde::json::Json;\n    ```", "```rs\n    #[get(\"/users\", format = \"json\", data = \"<pagination>\")]\n    pub async fn users(\n        mut db: Connection<DBConnection>,\n        pagination: Option<Json<Pagination>>,\n    ) -> Result<Json<UsersWrapper>, Json<OurError>> {}\n    ```", "```rs\n    let parsed_pagination = pagination.map(|p| p.into_inner());\n    ```", "```rs\n    let (users, new_pagination) = User::find_all(&mut db, parsed_pagination)\n        .await\n        .map_err(|_| OurError::new_internal_server_\n        error(String::from(\"Internal Error\"), None))?;\n    ```", "```rs\n    Ok(Json(UsersWrapper {\n        users,\n        pagination: new_pagination,\n    }))\n    ```", "```rs\n    use our_application::routes::{self, api, post, session, user};\n    ...\n    .mount(\"/\", ...)\n    .mount(\"/assets\", FileServer::from(relative!(\"static\")))\n    .mount(\"/api\", routes![api::users])\n    ```", "```rs\n    curl -X GET -H \"Content-Type: application/json\" -d \"{\\\"next\\\":\\\"2022-02-22T22:22:22.222222Z\\\",\\\"limit\\\":1}\" http://127.0.0.1:8000/api/users\n    ```", "```rs\n{\"users\":[{\"uuid\":\"8faa59d6-1079-424a-8eb9-09ceef1969c8\",\"username\":\"example\",\"email\":\"example@example.com\",\"description\":\"example\",\"status\":\"Inactive\",\"created_at\":\"2021-11-06T06:09:09.534864Z\",\"updated_at\":\"2021-11-06T06:09:09.534864Z\"}],\"pagination\":{\"next\":\"2021-11-06T06:09:09.534864Z\",\"limit\":1}}\n```", "```rs\n    hmac = \"0.12.1\"\n    jwt = \"0.16.0\"\n    sha2 = \"0.10.2\"\n    ```", "```rs\n    jwt_secret = \"fill with your own secret\"\n    ```", "```rs\n    pub struct JWToken {\n        pub secret: String,\n    }\n    ```", "```rs\n    use our_application::states::JWToken;\n    ...\n    struct Config {...\n        jwt_secret: String,\n    }\n    ...\n    async fn rocket() -> Rocket<Build> {\n        ...\n        let config: Config = our_rocket...\n        let jwt_secret = JWToken {\n            secret: String::from(config.jwt_\n            secret.clone()),\n        };\n        let final_rocket = our_rocket.manage(jwt_secret);\n        ...\n        final_rocket\n    }\n    ```", "```rs\n    use rocket::serde::{Deserialize, Serialize};\n    ```", "```rs\n#[derive(Deserialize)]\npub struct JWTLogin<'r> {\n    pub username: &'r str,\n    pub password: &'r str,\n}\n#[derive(Serialize)]\npub struct Auth {\n    pub token: String,\n}\n```", "```rs\n    impl<'r> JWTLogin<'r> {\n        pub async fn authenticate(\n            &self,\n            connection: &mut PgConnection,\n            secret: &'r str,\n        ) -> Result<Auth, OurError> {}\n    }\n    ```", "```rs\n    let auth_error =\n        || OurError::new_bad_request_error(\n        String::from(\"Cannot verify password\"), None);\n    ```", "```rs\n    let user = User::find_by_login(\n        connection,\n        &Login {\n            username: self.username,\n            password: self.password,\n            authenticity_token: \"\",\n        },\n    )\n    .await\n    .map_err(|_| auth_error())?;\n    verify_password(&Argon2::default(), &user.password_hash, self.password)?;\n    ```", "```rs\n    use hmac::{Hmac, Mac};\n    use jwt::{SignWithKey};\n    use sha2::Sha256;\n    use std::collections::BTreeMap; \n    ```", "```rs\nlet user_uuid = &user.uuid.to_string();\nlet key: Hmac<Sha256> =\n    Hmac::new_from_slice(secret.as_bytes()\n    ).map_err(|_| auth_error())?;\nlet mut claims = BTreeMap::new();\nclaims.insert(\"user_uuid\", user_uuid);\nlet token = claims.sign_with_key(&key).map_err(|_| auth_error())?;\nOk(Auth {\n    token: token.as_str().to_string(),\n})\n```", "```rs\n    use crate::models::user::{Auth, JWTLogin, User, UsersWrapper};\n    use crate::states::JWToken;\n    use rocket::State;\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    ```", "```rs\n    #[post(\"/login\", format = \"json\", data = \"<jwt_login>\")]\n    pub async fn login<'r>(\n        mut db: Connection<DBConnection>,\n        jwt_login: Option<Json<JWTLogin<'r>>>,\n        jwt_secret: &State<JWToken>,\n    ) -> Result<Json<Auth>, Json<OurError>> {\n        let connection = db\n            .acquire()\n            .await\n            .map_err(|_| OurError::new_internal_server_\n            error(String::from(\"Cannot login\"), None))?;\n        let parsed_jwt_login = jwt_login\n            .map(|p| p.into_inner())\n            .ok_or_else(|| OurError::new_bad_request_\n            error(String::from(\"Cannot login\"), None))?;\n        Ok(Json(\n            parsed_jwt_login\n                .authenticate(connection, &jwt_secret\n                .secret)\n                .await\n                .map_err(|_| OurError::new_internal_\n                server_error(String::from(\"Cannot login\"), \n                None))?,\n        ))\n    }\n    ```", "```rs\n    use crate::states::JWToken;\n    use hmac::{Hmac, Mac};\n    use jwt::{Header, Token, VerifyWithKey};\n    use sha2::Sha256;\n    use std::collections::BTreeMap;\n    ```", "```rs\n    pub struct APIUser {\n        pub user: User,\n    }\n    ```", "```rs\n    #[rocket::async_trait]\n    impl<'r> FromRequest<'r> for APIUser {\n        type Error = ();\n        async fn from_request(req: &'r Request<'_>) -> \n        Outcome<Self, Self::Error> {}\n    }\n    ```", "```rs\n    let error = || Outcome::Failure ((Status::Unauthorized, ()));\n    ```", "```rs\n    let parsed_header = req.headers().get_one(\"Authorization\");\n    if parsed_header.is_none() {\n        return error();\n    }\n    let token_str = parsed_header.unwrap();\n    ```", "```rs\n    let parsed_secret = req.rocket().state::<JWToken>();\n    if parsed_secret.is_none() {\n        return error();\n    }\n    let secret = &parsed_secret.unwrap().secret;\n    ```", "```rs\n    let parsed_key: Result<Hmac<Sha256>, _> = Hmac::new_from_slice(secret.as_bytes());\n    if parsed_key.is_err() {\n        return error();\n    }\n    let key = parsed_key.unwrap();\n    let parsed_token: Result<Token<Header, BTreeMap<String, String>, _>, _> = token_str.verify_with_key(&key);\n    if parsed_token.is_err() {\n        return error();\n    }\n    let token = parsed_token.unwrap();\n    let claims = token.claims();\n    let parsed_user_uuid = claims.get(\"user_uuid\");\n    if parsed_user_uuid.is_none() {\n        return error();\n    }\n    let user_uuid = parsed_user_uuid.unwrap();\n    ```", "```rs\n    let parsed_db = req.guard::<Connection<DBConnection>>().await;\n    if !parsed_db.is_success() {\n        return error();\n    }\n    let mut db = parsed_db.unwrap();\n    let parsed_connection = db.acquire().await;\n    if parsed_connection.is_err() {\n        return error();\n    }\n    let connection = parsed_connection.unwrap();\n    let found_user = User::find(connection, &user_uuid).await;\n    if found_user.is_err() {\n        return error();\n    }\n    let user = found_user.unwrap();\n    Outcome::Success(APIUser { user })\n    ```", "```rs\n    use crate::guards::auth::APIUser;\n    ...\n    #[get(\"/protected_users\", format = \"json\", data = \"<pagination>\")]\n    pub async fn authenticated_users(\n        db: Connection<DBConnection>,\n        pagination: Option<Json<Pagination>>,\n        _authorized_user: APIUser,\n    ) -> Result<Json<UsersWrapper>, Json<OurError>> {\n        users(db, pagination).await\n    }\n    ```", "```rs\n    ...\n    .mount(\"/api\", routes![api::users, api::login, \n     api::authenticated_users])\n    ...\n    ```", "```rs\ncurl -X GET -H \"Content-Type: application/json\" \\\n http://127.0.0.1:8000/api/protected_users\n```", "```rs\ncurl -X POST -H \"Content-Type: application/json\" \\\n  -d \"{\\\"username\\\":\\\"example\\\", \\\"password\\\": \\\"password\\\"}\" \\\n http://127.0.0.1:8000/api/login\n```", "```rs\n{\"token\":\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX3V1aWQiOiJmMGMyZDM4Yy0zNjQ5LTRkOWQtYWQ4My0wZGE4ZmZlY2 E2MDgifQ.XJIaKlIfrBEUw_Ho2HTxd7hQkowTzHkx2q_xKy8HMKA\"}\n```", "```rs\ncurl -X GET -H \"Content-Type: application/json\" \\T -H \"Content-Type: application/json\" \\\n -H \"Authorization: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX3V1aWQiOiJmMGMyZDM4Yy0zNjQ5LTRkOWQtYWQ4My0wZGE4ZmZlY2 E2MDgifQ.XJIaKlIfrBEUw_Ho2HTxd7hQkowTzHkx2q_xKy8HMKA\" \\\n http://127.0.0.1:8000/api/protected_users\n```"]