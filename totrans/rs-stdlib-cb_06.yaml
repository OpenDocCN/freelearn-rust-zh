- en: Handling Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Providing user-defined error types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户定义的错误类型
- en: Providing logging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供日志记录
- en: Creating a custom logger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义记录器
- en: Implementing the Drop trait
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Drop特性
- en: Understanding RAII
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解RAII
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Mistakes happen, and that's okay. We are only human after all. The important
    thing in life and in programming is not which errors we make, but how we deal
    with them. Rust helps us with the programming aspect of this principle by providing
    us with an error handling concept that guarantees that we *have* to think about
    the consequences of failure when dealing with functions that can fail, as they
    don't return a value directly but wrapped in a `Result` that has to be opened
    somehow. The only thing left is designing our code in a way that integrates nicely
    with this concept.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生，这是正常的。毕竟，我们都是凡人。生活和编程中的重要事情不是我们犯了什么错误，而是我们如何处理它们。Rust通过为我们提供一个错误处理概念来帮助我们处理这一原则的编程方面，该概念保证我们在处理可能失败的函数时必须考虑失败的结果，因为它们不直接返回值，而是被包裹在一个必须以某种方式打开的`Result`中。唯一剩下的事情是以一种与这个概念很好地集成的代码方式设计我们的代码。
- en: Providing user-defined error types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供用户定义的错误类型
- en: 'In the previous chapters, we learned about a few ways to handle functions that
    have to deal with different kinds of errors. So far, we have:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们了解了几种处理必须处理不同类型错误的函数的方法。到目前为止，我们有：
- en: Simply panicked when encountering them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到它们时直接崩溃
- en: Returned only one kind of error and converted all others into it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只返回一种错误，并将所有其他错误转换为它
- en: Returned different kinds of errors in a `Box`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Box`中返回不同类型的错误
- en: Most of these have been used because we didn't reach this recipe yet. Now, we
    are going to learn about the preferred way of doing things, creating a custom
    kind of `Error` that contains multiple sub-errors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些方法都已被使用，因为我们还没有达到这个配方。现在，我们将学习做事的优选方式，创建一种包含多个子错误的自定义`Error`类型。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a Rust project to work on during this chapter with `cargo new chapter-six`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter-six`创建一个Rust项目，在本章中工作。
- en: Navigate to the newly created `chapter-six` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`chapter-six`文件夹。在本章的其余部分，我们将假设您的命令行当前位于此目录。
- en: Inside the folder `src`, create a new folder called `bin`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内创建一个名为`bin`的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们不是创建一个库。
- en: In the folder `src/bin`, create a file called `custom_error.rs`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中创建一个名为`custom_error.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin custom_error`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin custom_error`运行它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The purpose of our example is to read a file, `age.txt`, and return the number
    written in it, assuming that it represents some kind of age. We can encounter
    three errors during this process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例目的是读取文件`age.txt`，并返回其中写下的数字，假设它代表某种年龄。在这个过程中，我们可能会遇到三种错误：
- en: Failure to read the file (maybe it doesn't exist)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件失败（可能它不存在）
- en: Failure to read its content as a number (it could contain text as well)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取其内容作为数字失败（它可能包含文本）
- en: The number could be negative
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可能是负数
- en: 'These possible error states are the possible variants of our `Error enum`:
    `AgeReaderError`[7]. It is usual to name the variants after the sub-errors they
    represent. Because a failure to read the file raises an `io::Error`, we name our
    corresponding variant `AgeReaderError::Io`[8]. A failure to parse a `&str` as
    an `i32` raises a `num::ParseIntError`, so we name our encompassing variant `AgeReaderError::Parse`[9].'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能的错误状态是`Error enum`的可能变体：`AgeReaderError`[7]。通常，我们会根据它们所代表的子错误来命名变体。因为读取文件失败会引发`io::Error`，所以我们把对应的变体命名为`AgeReaderError::Io`[8]。将`&str`解析为`i32`失败会引发`num::ParseIntError`，所以我们把包含的变体命名为`AgeReaderError::Parse`[9]。
- en: These two `std` errors show the naming convention of errors neatly. If you have
    many different errors that can be returned by a module, export them via their
    full name, such as `num::ParseIntError`. If your module only returns one kind
    of `Error`, simply export it as `Error`, such as `io::Error`. We intentionally
    don't follow this convention in the recipe because the distinct name `AgeReaderError`
    makes it easier to talk about it. If this recipe was included, one for one, in
    a crate, we could achieve the conventional effect by exporting it as `pub type
    Error = AgeReaderError;`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`std`错误清楚地展示了错误命名的约定。如果你有一个模块可以返回许多不同的错误，通过它们的完整名称导出它们，例如`num::ParseIntError`。如果你的模块只返回一种`Error`，只需将其导出为`Error`，例如`io::Error`。我们故意不遵循这个约定，因为在配方中，独特的名称`AgeReaderError`使得讨论它更容易。如果这个配方逐个包含在一个crate中，我们可以通过将其导出为`pub
    type Error = AgeReaderError;`来实现传统效果。
- en: 'The next thing we create is an alias for our own `Result`[14]:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来创建的是我们自己的`Result`[14]的别名：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is an extremely common pattern for your own errors, which makes working
    with them a charm, as we see in the return type of `read_age`[77]:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你自己错误的一个极其常见的模式，这使得与它们一起工作变得非常愉快，正如我们在`read_age`的返回类型中看到的那样[77]：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Looks nice, doesn''t it? In order to use our `enum` as an `Error` though, we
    need to implement it first [16]. The `Error` trait requires two things: a `description`[17],
    which is a short explanation of what went wrong, and a `cause`[27], which is simply
    a *redirection* to the underlying error, if any. You can (and should) provide
    a detailed description of the problem at hand by also implementing `Display` for
    your `Error`[37]. In all of these implementations, you should refer to the underlying
    error if possible, as with the following line [20]:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，不是吗？然而，为了使用我们的`enum`作为`Error`，我们首先需要实现它[16]。`Error`特质需要两件事：一个`description`[17]，它是对发生错误的一个简短解释，以及一个`cause`[27]，它简单地是将错误重定向到底层错误（如果有的话）。你可以（并且应该）通过实现`Display`为你的`Error`[37]来提供关于当前问题的详细描述。在这些实现中，如果可能的话，你应该参考底层错误，就像以下行[20]所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last thing you need to provide for a good own `Error` is a `From` implementation
    for every sub-error. In our case this would be `From<io::Error>`[49] and `From<num::ParseIntError>`[55].
    This way, the `try` operator (`?`) will automatically convert the involved errors
    for us.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为良好的自定义`Error`提供每个子错误的`From`实现。在我们的例子中，这将涉及`From<io::Error>`[49]和`From<num::ParseIntError>`[55]。这样，`try`操作符（`?`）将自动为我们转换涉及到的错误。
- en: 'After implementing all necessary traits, you can return the custom `Error`
    from any function and unwrap values in it with the aforementioned operator. In
    this example, when checking the result of `read_age`, we didn''t have to `match`
    the returned value. In a real `main` function, we would probably just call `.expect("…")`
    on it, but we matched the individual error variants anyway to show you how nicely
    you can react to different problems when using known error types [65 to 73]:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现所有必要的特性之后，你可以在任何函数中返回自定义的`Error`，并使用前面提到的操作符来解包其中的值。在这个例子中，当我们检查`read_age`的结果时，我们不需要`match`返回的值。在一个真正的`main`函数中，我们可能只是简单地调用`.expect("…")`，但我们仍然匹配了单独的错误变体，以便向您展示在使用已知的错误类型时，您如何优雅地应对不同的问题[65到73]：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A crate''s `Error` is usually put inside an own `error` module for organizational
    reasons and then exported directly for optimal usability. The relevant `lib.rs`
    entries would look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织原因，一个crate的`Error`通常被放在一个自定义的`error`模块中，然后直接导出以实现最佳可用性。相关的`lib.rs`条目可能看起来像这样：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Providing logging
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供日志记录
- en: In a big application, things will sooner or later not go as planned. But that's
    okay, as long as you have provided a system for your users to know what went wrong
    and, if possible, why. One time-tested tool to accomplish this is detailed logs
    that let the user specify for themselves how much diagnosis they want to see.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型应用程序中，事情迟早会不如预期。但没关系，只要你为用户提供了一个系统，让他们知道出了什么问题，如果可能的话，为什么，那就行了。一个经过时间考验的工具是详细的日志，它允许用户自己指定他们想要看到多少诊断信息。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following line:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want, you can go to log's ([https://crates.io/crates/log](https://crates.io/crates/log))
    or `env_logger`'s ([https://crates.io/crates/env_log](https://crates.io/crates/env_log))
    crates.io pages to check for the newest version and use that one instead.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以访问`log` ([https://crates.io/crates/log](https://crates.io/crates/log))
    或 `env_logger` ([https://crates.io/crates/env_log](https://crates.io/crates/env_log))
    的crate.io页面，检查最新版本并使用那个版本。
- en: In the folder `bin`, create a file called `logging.rs`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中创建一个名为`logging.rs`的文件。
- en: 'Add the following code and run it with `RUST_LOG=logging cargo run --bin logging`
    if you''re on a Unix-based system. Otherwise, run `$env:RUST_LOG="logging"; cargo
    run --bin logging` on Windows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是基于Unix的系统，请添加以下代码并使用`RUST_LOG=logging cargo run --bin logging`运行它。否则，在Windows上运行`$env:RUST_LOG="logging";
    cargo run --bin logging`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rust's logging system is based on the `log` crate, which provides a common *facade*
    for all things logging. This means that it doesn't actually provide any functionality,
    just the interface. The implementation is left to other crates, `env_logger` in
    our case. This split into facade and implementation is pretty useful, as anyone
    can create a cool new way of logging stuff which is automatically compatible with
    any crate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的日志系统基于`log` crate，它为所有日志事物提供了一个共同的*外观*。这意味着它实际上并不提供任何功能，只是提供了接口。实现留给其他crate，在我们的例子中是`env_logger`。这种外观和实现的分离非常实用，因为任何人都可以创建一种新的、酷的日志方式，这会自动与任何crate兼容。
- en: The choice of logging implementation used should be up to the consumer of your
    code. If you write a crate, don't use any implementation but simply log all things
    via the `log` crate only. Your (or someone else's) executable that uses the crate
    can then simply initialize their logger of choice[9] in order to actually process
    the log calls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应由你代码的使用者来决定使用的日志实现。如果你编写了一个crate，不要使用任何实现，而应仅通过`log` crate来记录所有事物。然后，使用该crate的（或他人的）可执行文件可以简单地初始化他们选择的日志记录器[9]，以便实际处理日志调用。
- en: The `log` crate provides the `log!` macro[11], which accepts a log `Level`,
    a message that can be formatted the same way as in `println!`, and an optional
    `target`. You could log stuff like this, but it's more readable to use the convenience
    macros for every logging level, `error!`, `warn!`, `info!`, `debug!`, and `trace!`,
    which all simply call `log!` in the background. A log's `target`[19] is an additional
    property that helps the logger implementation group the logs thematically. If
    you omit the `target`, it defaults to the current `module`. So, for example, if
    you logged something from the `foo` crate, its `target` would default to `foo`.
    If you logged something in its submodule `foo::bar`, its `target` would default
    to `bar`. If you then consumed the crate in a `main.rs` and logged something there,
    its `target` would default to `main`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` crate提供了`log!`宏[11]，它接受一个日志`Level`，一个可以像`println!`一样格式化的消息，以及一个可选的`target`。你可以这样记录事物，但使用每个日志级别的便利宏（`error!`、`warn!`、`info!`、`debug!`和`trace!`）更易于阅读，这些宏在后台简单地调用`log!`。日志的`target`[19]是一个额外的属性，有助于日志实现根据主题分组日志。如果你省略了`target`，它默认为当前的`module`。例如，如果你从`foo`
    crate记录了某些内容，它的`target`将默认为`foo`。如果你在其子模块`foo::bar`中记录了某些内容，它的`target`将默认为`bar`。如果你然后在`main.rs`中使用了该crate并记录了某些内容，它的`target`将默认为`main`。'
- en: Another goodie that `log` provides is the `log_enabled!` macro, which returns
    whether or not the currently active logger is set to process a certain warning
    level. This is especially useful in combination with `Debug` logs that provide
    useful information at the cost of an expensive operation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`提供的另一个好处是`log_enabled!`宏，它返回当前活动的日志记录器是否设置为处理特定的警告级别。这在与提供有用信息的昂贵操作的成本下特别有用。'
- en: '`env_logger` is a logger implementation provided by the Rust nursery. It prints
    its logs on `stderr` and uses pretty colors for different logging levels if supported
    by your Terminal. It relies on a `RUST_LOG` envvar to filter which logs should
    be displayed. If you don''t define said variable, it will default to `error`,
    which means that it will print only the log level `error` from all targets. As
    you can guess, other possible values include `warn`, `info`, `debug`, and `trace`.
    These will, however, not only filter the specified level, but all levels *above* it
    as well, where the hierarchy is defined like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`env_logger` 是 Rust 库提供的日志记录实现。它在其日志上打印到 `stderr`，并在你的终端支持的情况下使用漂亮的颜色来表示不同的日志级别。它依赖于一个
    `RUST_LOG` 环境变量来过滤应该显示哪些日志。如果你没有定义这个变量，它将默认为 `error`，这意味着它将只打印来自所有目标的 `error`
    级别的日志。正如你所猜到的，其他可能的值包括 `warn`、`info`、`debug` 和 `trace`。然而，这些不仅会过滤指定的级别，还会过滤其 **以上**
    的所有级别，其中层次结构定义如下：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that setting your `RUST_LOG` to `warn` will show all `warn` and all
    `error` logs. Setting it to `debug` will show `error`, `warn`, `info`, and `debug`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将你的 `RUST_LOG` 设置为 `warn` 将显示所有 `warn` 和 `error` 级别的日志。将其设置为 `debug` 将显示
    `error`、`warn`、`info` 和 `debug` 级别的日志。
- en: 'Instead of error levels, you can set `RUST_LOG` to targets, which will show
    all logs of the selected targets regardless of their log levels. This is what
    we do in our example, we set `RUST_LOG` to `logging` in order to show all logs
    with a `target` called `logging`, which is the standard target for all logs in
    our binary. If you wanted, you could combine a level filter with a target filter
    like this: `logging=warn`, which would only show `warn` and `error` logs with
    a `target` of `logging`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `RUST_LOG` 设置为目标，而不是错误级别，这将显示所选目标的全部日志，无论它们的日志级别如何。这就是我们在示例中所做的，我们将 `RUST_LOG`
    设置为 `logging` 以显示所有带有 `target` 调用 `logging` 的日志，这是我们二进制中所有日志的标准目标。如果你想的话，你可以像这样将级别过滤器与目标过滤器结合使用：`logging=warn`，这将只显示
    `logging` 目标中的 `warn` 和 `error` 级别的日志。
- en: You can combine different filters with a comma. If you want all logs of this
    example to be displayed, you can set your variable to `logging,extra_info`, which
    filters for both the targets `logging` and `extra_info`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用逗号组合不同的过滤器。如果你想显示此示例的所有日志，你可以将你的变量设置为 `logging,extra_info`，这将过滤 `logging`
    和 `extra_info` 目标。
- en: Lastly, you can filter your logs by content with a slash (`/`), after which
    you can write down a regex that has to be matched. If you set `RUST_LOG` to `logging=debug/expensive`
    for instance, only logs with the logging level of `debug` and upwards with the
    `target` of `logging` that also contain the word `expensive` will be displayed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用斜杠 (`/`) 后跟一个正则表达式来通过内容过滤日志，该正则表达式必须匹配。例如，如果你将 `RUST_LOG` 设置为 `logging=debug/expensive`，则只有具有
    `logging` 目标且包含单词 `expensive` 的 `debug` 级别以上的日志将被显示。
- en: Wow, that's a lot of configuration! I advise you to experiment a bit with the
    different filtering modes and run the example in order to get a feeling for how
    the parts fit together. If you need additional information, all possibilities
    for the value of `RUST_LOG` in the current version of `env_logger` are documented
    at [https://docs.rs/env_logger/](https://docs.rs/env_logger/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这有很多配置！我建议你尝试不同的过滤模式，并运行示例以了解各个部分是如何结合在一起的。如果你需要更多信息，`env_logger` 当前版本中 `RUST_LOG`
    值的所有可能性都在 [https://docs.rs/env_logger/](https://docs.rs/env_logger/) 中有文档说明。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you''ve never worked with a logger before, you might wonder what the difference
    between certain log levels is. Of course, you can use them for whatever purpose
    you want, but the following conventions are usual for loggers in many languages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过日志记录器，你可能想知道某些日志级别之间的区别。当然，你可以根据需要使用它们，但以下约定在许多语言的日志记录器中是常见的：
- en: '| **Log level** | **Usage** | **Example** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **日志级别** | **用法** | **示例** |'
- en: '| `Error` | Some major problem occurred that might terminate the program soon.
    If the application is a service that should always run, a system administrator
    should immediately be notified. | The connection to the database has been broken.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Error` | 发生了一些可能很快终止程序的重大问题。如果应用程序是一个应该始终运行的服务，系统管理员应立即被通知。 | 数据库连接已断开。
    |'
- en: '| `Warn` | An issue that''s not severe or has an automatic workaround has happened.
    Someone should check this out at some point and fix it. | A user''s configuration
    file contains unrecognized options that have been ignored. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Warn` | 发生了一些不是严重的问题或具有自动修复方法的错误。应该在某个时候有人检查并修复它。 | 一个用户的配置文件包含未识别的选项，这些选项已被忽略。
    |'
- en: '| `Info` | Some information that might be useful to look at at a later point.
    This logs normal conditions. | The user has started or stopped a process. A default
    value has been used because no configuration has been provided. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Info` | 可能会在以后查看的一些有用信息。这记录了正常条件。 | 用户已启动或停止了一个进程。由于没有提供配置，已使用默认值。|'
- en: '| `Debug` | Information that is helpful to programmers or sysadmins when trying
    to fix a problem. Contrary to many other languages, a debug log is *not* removed
    in release builds. | The parameters passed to a major function. The current state
    of the application at various points. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Debug` | 当尝试解决问题时对程序员或系统管理员有帮助的信息。与许多其他语言相反，调试日志在发布构建中不会被删除。 | 传递给主要函数的参数。应用程序在各个点的当前状态。|'
- en: '| `Trace` | Very low-level signals of control flow that are only useful to
    a programmer trying to chase a bug. Allows the reconstruction of a stack trace.
    | The parameters of a minor helper function. The beginning and end of a function.
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Trace` | 只有在程序员试图追踪错误时才有用的非常低级别的控制流信号。允许重建堆栈跟踪。 | 辅助函数的参数。函数的开始和结束。|'
- en: 'Many languages also contain a `Fatal` log level. In Rust, a good old `panic!()`
    is used for that. If you want to log your panics in some special way as well,
    you can replace the usual reaction to a panic by simply printing it to `stderr`
    by calling `std::panic::set_hook()` with whatever functionality you want. An example
    of what this might look like is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言也包含一个`Fatal`日志级别。在Rust中，传统的`panic!()`用于此目的。如果您想以某种特殊方式记录您的恐慌，可以通过调用`std::panic::set_hook()`并传递您想要的任何功能来简单地将其打印到`stderr`，从而替换对恐慌的常规反应。以下是一个示例：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A good alternative to `env_logger` is the `slog` crate, which provides excellent
    extensible structured logging at the cost of a steepened learning curve. Plus,
    its output looks pretty. If that sounds interesting, be sure to check it out at
    [https://github.com/slog-rs/slog.](https://github.com/slog-rs/slog)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`env_logger`的一个好替代品是`slog`包，它以陡峭的学习曲线为代价提供了出色的可扩展结构化日志。此外，它的输出看起来很漂亮。如果您对此感兴趣，请务必在[https://github.com/slog-rs/slog.](https://github.com/slog-rs/slog)上查看。'
- en: Creating a custom logger
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义日志记录器
- en: Sometimes you or your users might have very specific logging needs. In this
    recipe, we are going to learn how to create a custom logger to work with the `log`
    crate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您或您的用户可能会有非常具体的日志需求。在这个配方中，我们将学习如何创建一个自定义日志记录器以与`log`包一起使用。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    line:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`部分下，如果您在上一个配方中没有这样做，请添加以下行：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you want, you can go to log's crates.io page ([https://crates.io/crates/log](https://crates.io/crates/log))
    to check for the newest version and use that one instead.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以访问日志的crates.io页面([https://crates.io/crates/log](https://crates.io/crates/log))以检查最新版本，并使用该版本。
- en: In the folder `bin`, create a file called `custom_logger.rs`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中创建一个名为`custom_logger.rs`的文件。
- en: 'Add the following code and run it with `RUST_LOG=custom_logger cargo run --bin
    custom_logger` if you''re on a Unix-based system. Otherwise, run `$env:RUST_LOG="custom_logger";
    cargo run --bin custom_logger` on Windows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是基于Unix的系统，请添加以下代码并使用`RUST_LOG=custom_logger cargo run --bin custom_logger`运行它。否则，在Windows上运行`$env:RUST_LOG="custom_logger";
    cargo run --bin custom_logger`：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the custom error used in our logger:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在日志记录器中使用的自定义错误：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initializing and using the logger:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和使用日志记录器：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our `FileLogger` will, as the name suggests, log things to a file. It also accepts
    a maximum logging level on initialization.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义`FileLogger`，正如其名所示，会将日志记录到文件中。它还接受初始化时的最大日志级别。
- en: You should not get used to directly logging things on a disk. As stated by *The
    Twelve-Factor App guidelines* ([https://12factor.net/logs](https://12factor.net/logs)),
    logs should be treated as event streams, in the form of a raw dump to `stdout`.
    The production environment can then route all log streams to their final destination
    over `systemd` or a dedicated log router such as `Logplex` ([https://github.com/heroku/logplex](https://github.com/heroku/logplex))
    or `Fluentd` ([https://github.com/fluent/fluentd](https://github.com/fluent/fluentd)).
    These will then decide if the logs should be sent to a file, an analysis system
    like `Splunk` ([https://www.splunk.com/](https://www.splunk.com/)), or a data
    warehouse like `Hive` ([http://hive.apache.org/](http://hive.apache.org/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该习惯直接在磁盘上记录日志。正如 *The Twelve-Factor App 指南* ([https://12factor.net/logs](https://12factor.net/logs))
    所述，日志应该被视为事件流，以原始转储到 `stdout` 的形式。然后，生产环境可以将所有日志流通过 `systemd` 或专门的日志路由器（如 `Logplex`
    ([https://github.com/heroku/logplex](https://github.com/heroku/logplex)) 或 `Fluentd`
    [https://github.com/fluent/fluentd](https://github.com/fluent/fluentd)）路由到最终目的地。这些路由器将决定日志是否应该发送到文件、分析系统（如
    `Splunk` [https://www.splunk.com/](https://www.splunk.com/)）或数据仓库（如 `Hive` [http://hive.apache.org/](http://hive.apache.org/)）。
- en: Every logger needs to implement the `log::Log` trait, which consists of the
    `enabled`, `log`, and `flush` methods. `enabled` should return if a certain log
    event is accepted by the logger. Here, you can go wild with whatever filtering
    logic you want [18]. This method is never called directly by `log`, so its only
    purpose is to serve you as a helper method inside of the `log` method, which we
    are going to discuss shortly. `flush` [46] is treated the same way. It should
    apply whatever changes you have buffered in your logging, but it is never called
    by `log`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志记录器都需要实现 `log::Log` 特性，该特性包括 `enabled`、`log` 和 `flush` 方法。`enabled` 应该返回是否接受某个日志事件。在这里，你可以随心所欲地使用你想要的任何过滤逻辑[18]。这个方法永远不会直接被
    `log` 调用，所以它的唯一目的是作为 `log` 方法中的辅助方法，我们将在稍后讨论。`flush` [46] 被以相同的方式处理。它应该应用你在日志中缓存的任何更改，但它永远不会被
    `log` 调用。
- en: 'In fact, if your logger doesn''t interact with the filesystem or the network,
    it will probably simply implement `flush` by doing nothing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你的日志记录器不与文件系统或网络交互，它可能只是简单地通过不执行任何操作来实现 `flush`：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The real bread and butter of the `Log` implementation is the `log` method[24],
    though, as it is called whenever a logging macro is invoked. The implementation
    typically starts with the following line, followed by the actual logging and a
    finishing call to `self.flush()`[25]:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Log` 实现的核心是 `log` 方法[24]，因为每当调用日志宏时都会调用它。实现通常从以下行开始，然后是实际的日志记录，最后调用 `self.flush()`[25]：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our actual logging then consists of simply writing a combination of the current
    logging level, Unix timestamp, target, and logging message to the file and flushing
    it afterward.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际的日志记录操作只是简单地组合当前日志级别、Unix时间戳、目标地址和日志消息，然后将这些内容写入文件，并在之后刷新。
- en: Technically speaking, our call to `self.flush()` should be inside the `if` block
    as well, but that would require additional scope around the mutably borrowed `writer`
    in order to not borrow it twice. Because this is not relevant to the underlying
    lesson here, as in, how to create a logger, we placed it outside the block in
    order to make the example more readable. By the way, the way we borrow `writer`
    from an `RwLock` is the subject of the *Accessing resources in parallel with RwLocks *in [Chapter
    8](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism and Rayon*. For now,
    it's enough to know that an `RwLock` is a `RefCell` that is safe to use in a parallel
    environment such as a logger.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，我们的 `self.flush()` 调用也应该在 `if` 块内部，但这将需要围绕可变借用 `writer` 的额外作用域，以避免两次借用。由于这与这里的根本课程无关，即如何创建一个日志记录器，我们将它放在块外，以便使示例更易于阅读。顺便说一下，我们从
    `RwLock` 借用 `writer` 的方式是 [第 8 章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)
    中 *使用 RwLock 并行访问资源* 的主题。现在，只需知道 `RwLock` 是一个在并行环境（如日志记录器）中安全使用的 `RefCell` 就足够了。
- en: 'After implementing `Log` for `FileLogger`, the user can use it as the logger
    called by `log`. To do that, the user has to do two things:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `FileLogger` 实现 `Log` 之后，用户可以使用它作为 `log` 调用的日志记录器。为此，用户需要做两件事：
- en: Tell `log` which log `Level` is going to be the maximum accepted by our logger
    via `log::set_max_level()` [66]. This is needed because `log` optimizes `.log()`
    calls on our logger away during runtime if they use log levels over our maximum
    level. The function accepts a `LevelFilter` instead of a `Level`, which is why
    we have to convert our level with `to_level_filter()` first [66]. The reason for
    this type is explained in the *There's more...* section.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`log::set_max_level()` [66]告诉`log`日志级别，这是我们记录器能接受的最大日志级别。这是必需的，因为如果使用超过我们最大级别的日志级别，`log`会在运行时优化我们的记录器上的`.log()`调用。该函数接受一个`LevelFilter`而不是`Level`，这就是为什么我们首先需要用`to_level_filter()`将我们的级别转换的原因
    [66]。这种类型的原因在*更多内容...*部分中解释。
- en: Specify the logger with `log::set_boxed_logger()`[68]. `log` accepts a box because
    it treats its logger implementation as a trait object, which we discussed in the
    *Boxing data* section of [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*. If you want a (very) minor performance gain, you can
    also use `log::set_logger()`, which accepts a `static` which you would have to
    create via the `lazy_static` crate first. See  [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*, and the recipe *Creating lazy static objects*, for
    more on that.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`log::set_boxed_logger()`[68]指定记录器。`log`接受一个盒子，因为它将其记录器实现视为一个特质对象，我们在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*的*装箱数据*部分讨论过。如果你想要（非常）小的性能提升，你也可以使用`log::set_logger()`，它接受一个`static`，你首先需要通过`lazy_static`
    crate创建它。关于这一点，请参阅[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*和配方*创建懒加载静态对象*。
- en: 'This is conventionally done in a provided `.init()` method on the logger, just
    like with `env_logger`, which we implement in line [58]:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在提供的`.init()`方法上完成，就像`env_logger`一样，我们在第[58]行实现它。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While we're on it, we can also open the file in the same method. Other possibilities
    include letting the user pass a `File` directly to `init` as a parameter or, for
    maximum flexibility, making the logger a generic one that accepts any stream implementing
    `Write`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论这个话题时，我们也可以用同样的方法打开文件。其他可能性包括让用户直接将`File`传递给`init`作为参数，或者为了最大的灵活性，使记录器成为一个泛型记录器，它接受任何实现`Write`的流。
- en: We then return a custom error created in the lines that follow [74 to 116].
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在随后的行[74到116]返回一个自定义错误。
- en: 'An example initialization of our logger might look like this [119]:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录器的初始化示例可能看起来像这样 [119]：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: For simplicity's sake, `FileLogger` doesn't discriminate against any targets.
    A more sophisticated logger, like `env_logger`, can set different logging levels
    on different targets. For this purpose, `log` provides us with the `LevelFilter`
    enum, which has an `Off` state that corresponds to *no logging enabled for this
    target.* If you need to create such a logger, be sure to remember said enum. You
    can get some inspiration about how to implement target-based filters by looking
    at the source code of `env_logger` at [https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs](https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，`FileLogger`不对任何目标进行区分。一个更复杂的记录器，如`env_logger`，可以在不同的目标上设置不同的日志级别。为此，`log`为我们提供了`LevelFilter`枚举，它有一个`Off`状态，对应于*为此目标未启用日志记录*。如果你需要创建这样的记录器，务必记住这个枚举。你可以通过查看`env_logger`的源代码来获取一些关于如何实现基于目标的过滤器的灵感，源代码位于[https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs](https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs)。
- en: In a really user-friendly logger, you'll want to display the timestamp in the
    user's own local time. For all things related to time measurement, time zones,
    and dates, check out the `chrono` crate at [https://crates.io/crates/chrono](https://crates.io/crates/chrono).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真正用户友好的记录器中，你希望显示用户自己的本地时间戳。对于与时间测量、时区和日期相关的一切，请查看`chrono` crate，位于[https://crates.io/crates/chrono](https://crates.io/crates/chrono)。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*中的*装箱数据*配方
- en: '*Creating lazy static objects *recipe in *[Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)**,
    Advanced Data Structures*'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)**，高级数据结构*中的*创建懒加载静态对象*配方
- en: '*Accessing resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行和Rayon*中的*使用RwLocks并行访问资源*配方
- en: Implementing the Drop trait
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Drop特性
- en: Where traditional object-oriented languages have destructors, Rust has the `Drop`
    trait, which consists of a single `drop` function that is called whenever a variable's
    lifetime has ended. By implementing it, you can perform whatever cleanup or advanced
    logging is necessary. You can also automatically free resources via RAII, as we're
    going to see in the next recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统面向对象语言中，有析构函数，而 Rust 有 `Drop` 特性，它由一个单一的 `drop` 函数组成，当变量的生命周期结束时会被调用。通过实现它，你可以执行任何必要的清理或高级日志记录。你还可以通过
    RAII 自动释放资源，正如我们将在下一个菜谱中看到的。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the folder `bin`, create a file called `drop.rs`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中创建一个名为 `drop.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin drop`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin drop` 运行它：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This example, adapted with slight changes from the second edition of the Rust
    book ([https://doc.rust-lang.org/book/second-edition/](https://doc.rust-lang.org/book/second-edition/)),
    shows you how to start the implementation of a custom smart pointer. In our case,
    all it does is print the `Debug` information of the data stored when its dropped
    [26]. We do this by implementing the `Drop` trait with its single `drop` function
    [25], which the compiler automatically calls whenever a variable is dropped. All
    smart pointers are implemented this way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是从 Rust 书的第二版中稍作修改后得到的([https://doc.rust-lang.org/book/second-edition/](https://doc.rust-lang.org/book/second-edition/))，展示了如何开始实现自定义智能指针。在我们的例子中，它所做的只是在其被销毁时打印存储数据的
    `Debug` 信息[26]。我们通过实现 `Drop` 特性及其单一的 `drop` 函数[25]来完成这项工作，编译器会在变量被销毁时自动调用这个函数。所有智能指针都是这样实现的。
- en: The moment of a variable drop will nearly always be when it leaves its scope.
    For this reason, we cannot call the `drop` function directly[38]. The compiler
    will still call it when it exits its scope, so the cleanup will happen twice,
    resulting in undefined behavior. If you need to drop a variable early, you can
    tell the compiler to do so for you by calling `std::mem:drop` on it [41].
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变量销毁的时刻几乎总是它离开作用域的时候。因此，我们不能直接调用 `drop` 函数[38]。当它退出作用域时，编译器仍然会调用它，所以清理将会发生两次，导致未定义的行为。如果你需要提前销毁一个变量，你可以通过在它上面调用
    `std::mem:drop` 来告诉编译器这样做 [41]。
- en: 'Variables that exit their scope are dropped in a **LIFO** way: **Last In, First
    Out**. That means that the last variable to be declared will be the first one
    to be dropped. If we allocate the variables `a`, `b`, `c`, and `d` in exactly
    that order, they will be dropped in the order `d`, `c`, `b`, `a`. In our example,
    we drop `c` early[41], so our order becomes `c`, `d`, `b`, `a` instead.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变量退出其作用域时，会以 **LIFO** 方式被销毁：**后进先出**。这意味着最后声明的变量将是第一个被销毁的。如果我们按照 `a`、`b`、`c`
    和 `d` 的顺序分配变量，它们将被销毁的顺序将是 `d`、`c`、`b`、`a`。在我们的例子中，我们提前销毁 `c`[41]，所以我们的顺序变成了 `c`、`d`、`b`、`a`。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Do you want to know how a sophisticated low-level function like `std::mem::drop`
    is implemented:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道一个像 `std::mem::drop` 这样的复杂低级函数是如何实现的吗：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's right, it does nothing! The reason this works is that it takes `T` by
    value, moving it into the function. The function does nothing and all its owned
    variables go out of scope. Hurray for Rust's borrow checker!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，它什么也没做！这样做的原因是它通过值传递 `T`，将其移动到函数中。函数什么也不做，并且它所有的拥有变量都退出了作用域。为 Rust 的借用检查器欢呼！
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第五章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)的“*装箱数据*”菜谱中。
- en: '*Sharing ownership with smart pointers* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第五章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)的“*与智能指针共享所有权*”菜谱中。
- en: Understanding RAII
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 RAII
- en: We can go one step further than simple destructors. We can create structs that
    can give the user temporary access to some resource or functionality and automatically
    revoke it again when the user is done. This concept is called **RAII**, which
    stands for **Resource Acquisition Is Initialization**. Or, in other words, the
    validity of a resource is tied to the lifetime of a variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比简单的析构函数更进一步。我们可以创建可以给用户提供临时访问某些资源或功能的结构体，并在用户完成时自动撤销访问。这个概念被称为 **RAII**，代表
    **Resource Acquisition Is Initialization**。换句话说，资源的有效性与变量的生命周期绑定。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件。
- en: In the folder `bin`, create a file called `raii.rs`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中创建一个名为 `raii.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin raii`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用`cargo run --bin raii`运行它：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now comes the implementations for the `structs`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`structs`的实现：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, the actual usage:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的用法：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Well, that's a load of complicated code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是一堆复杂的代码。
- en: 'Let''s start by introducing the structures that participate in this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍参与这个示例的结构：
- en: '`SomeOsSpecificFunctionalityHandle` [6] stands for an unspecified feature of
    your operating system that operates on some data and is presumably unsafe to use
    directly. We assume this feature locks some resource of the operating system that
    needs to be unlocked again.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SomeOsSpecificFunctionalityHandle` [6]代表操作系统的一个未指定功能，该功能操作某些数据，并且可能直接使用是不安全的。我们假设这个功能锁定了一些需要再次解锁的操作系统资源。'
- en: '`SomeOsFunctionality ` [9] represents a safe wrapper around the feature, plus
    some data `T` that might be useful for it.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SomeOsFunctionality` [9]代表围绕该功能的保护器，以及一些可能对它有用的数据`T`。'
- en: '`SomeOsFunctionalityGuard` [20] is an RAII guard created by using the `lock`
    function. When it is dropped, it will automatically unlock the underlying resource.
    Additionally, it can be directly used as if it was the data `T` itself.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SomeOsFunctionalityGuard` [20]是通过使用`lock`函数创建的RAII保护器。当它被丢弃时，它将自动解锁底层资源。此外，它可以直接用作数据`T`本身。'
- en: These functions might look a bit abstract, as they don't do anything specific,
    but instead act on *some* unspecified OS feature. This is because most of the
    really useful candidates are already present in the standard library—see `File`,
    `RwLock`, `Mutex`, and so on. What's left are particularly domain-specific use
    cases when writing low-level libraries or dealing with some special, homemade
    resource that needs automatic unlocking. When you see yourself writing either,
    you will appreciate the elegance of RAII.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可能看起来有些抽象，因为它们并没有做任何具体的事情，而是作用于某些未指定的操作系统功能。这是因为大多数真正有用的候选者已经存在于标准库中——比如`File`、`RwLock`、`Mutex`等等。剩下的主要是特定领域的使用案例，当编写低级库或处理一些需要自动解锁的特殊、自制的资源时。当你发现自己正在编写这样的代码时，你会欣赏RAII的优雅。
- en: 'The implementation of the structs introduces some new concepts that might look
    a bit confusing if encountered for the first time. In the implementation of `SomeOsSpecificFunctionalityHandle`,
    we can spot some `unsafe` keywords [25 , 28 and 44] :'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的实现引入了一些可能初次遇到时会显得有些令人困惑的新概念。在`SomeOsSpecificFunctionalityHandle`的实现中，我们可以看到一些`unsafe`关键字[25,
    28和44]：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s start with the unsafe block [44 to 46]:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不安全块[44到46]开始：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `unsafe` keyword tells the compiler to treat the previous block in a special
    way. It disables the borrow checker and lets you do all kinds of crazy stuff:
    dereference raw pointers like in C, modify a mutable static variable, and call
    unsafe functions. In return, the compiler doesn''t give you any guarantees about
    it either. It might, for instance, access invalid memory, resulting in a **SEGFAULT**.
    If you want to read more about the `unsafe` keyword, check out its section in
    the second edition of the official Rust book at [https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`关键字告诉编译器以特殊方式处理前面的代码块。它禁用了借用检查器，并允许你做各种疯狂的事情：像C语言一样解引用原始指针，修改可变静态变量，调用不安全函数。作为交换，编译器也不会给你任何保证。例如，它可能会访问无效的内存，导致**SEGFAULT**。如果你想了解更多关于`unsafe`关键字的信息，请查看官方Rust书籍第二版中关于它的章节[https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html)。'
- en: 'Generally speaking, writing unsafe code should be avoided. It is, however,
    okay to do so when:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，应该避免编写不安全的代码。然而，在以下情况下这样做是可以接受的：
- en: You're writing some code that directly interfaces with the OS and you want to
    create a safe wrapper around the unsafe parts, which is what we are doing here
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在编写一些直接与操作系统交互的代码，并且你想要创建一个围绕不安全部分的安全包装器，这正是我们在这里所做的事情。
- en: You are absolutely 100% completely certain that what you're doing, in a very
    specific context, is actually not problematic, contrary to the compiler's opinion
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你绝对100%完全确信，在非常具体的上下文中，你所做的是没有问题的，这与编译器的观点相反。
- en: If you're wondering why the `unsafe` block is empty, that's again because we
    are not using any actual OS resources in this recipe. If you wanted to use any,
    the code handling them would go in those two empty blocks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么`unsafe`块是空的，那是因为我们在这个配方中没有使用任何实际的操作系统资源。如果你想使用，处理它们的代码将放在那两个空块中。
- en: 'The other use for the `unsafe` keyword is the following [25]:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe`关键字的其他用途如下[25]：'
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This marks the function itself as unsafe, meaning that it can only be called
    inside `unsafe` blocks. Remember, calling `unsafe` code in a function doesn't
    make the function automatically unsafe because the function could be a safe wrapper
    around it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将函数本身标记为不安全，意味着它只能在不安全的块中调用。记住，在函数中调用`unsafe`代码并不会使函数自动变为不安全，因为函数可能是一个围绕它的安全包装。
- en: 'Let''s move on now from our hypothetical low-level implementation of `SomeOsSpecificFunctionalityHandle`
    to our realistic implementation of its safe wrapper, `SomeOsFunctionality`[33].
    Its constructor comes with no surprises (see [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics* and the *Using the constructor pattern* recipe if you need
    a refresher on that):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从假设的低级实现`SomeOsSpecificFunctionalityHandle`转移到我们对其安全包装`SomeOsFunctionality`[33]的现实实现。其构造函数没有惊喜（如果你需要复习，请参阅[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*和*使用构造函数模式*配方）：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We simply prepare the underlying OS functionality and store it with the user-provided
    data in our `struct`. We `Box` the handle because, as explained in a comment in
    the code earlier at lines [13 and 14], the low-level struct interfacing with the
    OS is often not safe to move. Because we don't want to restrict our user from
    moving our safe wrapper, however, we make the handle movable by putting in on
    the heap via a `Box`, which gives it a permanent address. What is then moved is
    simply the smart pointer pointing to the address. For more about that, read [Chapter
    5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced Data Structures* and
    the *Boxing data *recipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是简单地准备底层的操作系统功能，并将其与用户提供的资料一起存储在我们的`struct`中。我们使用`Box`封装了句柄，因为，如代码中较早的注释（在第13行和第14行）所述，与操作系统交互的低级结构通常不安全移动。然而，我们不想限制用户移动我们的安全包装，因此，我们通过将句柄放入堆中并通过`Box`来使其可移动，这给它提供了一个永久地址。然后移动的仅仅是指向该地址的智能指针。关于这一点，请阅读[第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*和*装箱数据*配方。
- en: 'The actual wrapping takes place in the `lock` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的封装发生在`lock`方法中：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When working with an actual OS feature or custom resource, you'll want to guarantee
    that `self.inner.lock()` is safe to call in this context before doing so, otherwise,
    the wrapper won't be safe. This is also where you can do interesting things with
    `self.data`, which you can potentially use in combination with the resource mentioned.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当与实际的操作系统功能或自定义资源一起工作时，你希望在这样做之前确保`self.inner.lock()`在这个上下文中是安全的，否则，包装器将不会安全。这也是你可以对`self.data`做有趣事情的地方，你可能会将其与提到的资源结合起来使用。
- en: After locking our stuff up, we return a RAII guard with a reference to our structure
    [49] that will unlock our resource when it is dropped. Looking at the implementation
    of `SomeOsFunctionalityGuard`, you can see that we don't need to implement any
    kind of new function for it. We just need to implement two traits. We begin with
    `Drop`[54], which you have met in the previous recipe. Implementing it means that
    we can unlock the resource when the guard is dropped by accessing it through our
    reference to `SomeOsFunctionality`. Again, make sure to arrange the environment
    in a way that guarantees that `self.lock.inner.unlock()` is actually safe before
    calling it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在锁定我们的东西之后，我们返回一个RAII保护器，它包含对我们结构的引用[49]，当它被丢弃时将解锁我们的资源。查看`SomeOsFunctionalityGuard`的实现，你可以看到我们不需要为它实现任何新的函数。我们只需要实现两个特质。我们首先从`Drop`[54]开始，你在之前的配方中已经见过。实现它意味着我们可以在保护器通过`SomeOsFunctionality`的引用被丢弃时解锁资源。再次确保以某种方式安排环境，在调用`self.lock.inner.unlock()`之前确保它实际上是安全的。
- en: Since we are basically creating a kind of smart pointer to `data`, we can use
    the `Deref` trait [64]. Implementing `Deref for B` with a `Target` of `A` allows
    a reference to `B` to be dereferenced into `A`. Or in other, slightly less accurate
    words, it lets `B` act as if it was `A`. In our case, implementing `Deref for
    SomeOsFunctionalityGuard` with a `Target` of `T` means that we can use our guard
    as if it was the underlying data. Because this can cause great confusion to the
    user if implemented poorly, Rust advises you to only implement it on smart pointers
    and nothing else.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们基本上是在创建一个指向`data`的智能指针，我们可以使用`Deref`特质[64]。通过将`Target`设置为`A`实现`Deref for
    B`允许对`B`的引用被解引用到`A`。或者用稍微不准确的话来说，它让`B`表现得像`A`。在我们的例子中，通过将`Target`设置为`T`实现`Deref
    for SomeOsFunctionalityGuard`意味着我们可以像使用底层数据一样使用我们的守护者。因为如果实现不当，这可能会给用户带来很大的困惑，Rust建议您只在对智能指针实现它，而不是其他任何东西。
- en: Implementing `Deref` is of course not mandatory for the RAII pattern, but can
    prove pretty useful, as we're going to see in a moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Deref`对于RAII模式来说当然不是强制的，但可能会非常有用，正如我们一会儿将要看到的。
- en: 'Let''s look at how we can now use all of our fancy functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们现在如何使用所有这些花哨的功能：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The user should never have to use `SomeOsSpecificFunctionalityHandle` directly,
    as it's `unsafe`. Instead, he can construct an instance of `SomeOsFunctionality`,
    which he can pass around and store however he wants [73]. Whenever he needs to
    use the cool feature behind it, he can call `lock` in whatever scope he is in
    right now, and he will receive a guard that will clean up after him after the
    work is done [81]. Because he implemented `Deref`, he can use the guard directly
    as if it was the underlying data. In our example, `data` is a `&str`, so we can
    use the methods of `str` directly on our guard like we do in line [79] by calling
    `.len()` on it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户永远不应该直接使用`SomeOsSpecificFunctionalityHandle`，因为它是不安全的。相反，他可以构建一个`SomeOsFunctionality`的实例，他可以随意传递和存储[73]。每次他需要使用它背后的酷功能时，他都可以在当前作用域中调用`lock`，并且他将收到一个在完成后会为他清理的守护者[81]。因为他实现了`Deref`，所以他可以直接使用守护者，就像它是底层数据一样。在我们的例子中，`data`是一个`&str`，所以我们可以在我们的守护者上直接使用`str`的方法，就像我们在第[79]行所做的那样，通过调用`.len()`。
- en: After this little scope ends, our guard calls `unlock` on the resource and,
    because `foo` independently still lives on, we can continue locking it again however
    much we want.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小范围结束之后，我们的守护者对资源调用`unlock`，因为`foo`独立地仍然存在，我们可以继续以我们想要的任何方式再次锁定它。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example is tailored to be in line with the implementations of `RwLock`
    and `Mutex`. The only thing missing is an extra layer of indirection that has
    been omitted to not make this recipe even more complex. `SomeOsSpecificFunctionalityHandle`
    shouldn't contain actual implementations of `lock` and `unlock`, but instead,
    pass the calls onto a stored implementation that is specific to whatever OS you're
    using. For example, say you have a struct, `windows::SomeOsSpecificFunctionalityHandle`,
    for a Windows-based implementation and a struct, `unix::SomeOsSpecificFunctionalityHandle`,
    for a Unix-based implementation. `SomeOsSpecificFunctionalityHandle` should then,
    conditionally, depending on the operating system that is being run, pass its `lock`
    and `unlock` calls onto the correct implementations. These may have many more
    features. The Windows one could maybe have a `awesome_windows_thing()` function
    that might be useful to the unlucky Windows developer that needs it. The Unix
    implementation could have a `confusing_posix_thing()` function that does some
    very weird things that only Unix hackers would understand. The important thing
    is that our  `SomeOsSpecificFunctionalityHandle` should represent a common interface
    of the implementations. In our case, that means that every supported OS has the
    ability to `lock` and `unlock` the resource in question.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是为了与`RwLock`和`Mutex`的实现保持一致。唯一缺少的是为了不让这个配方更加复杂而省略的一个额外的间接层。`SomeOsSpecificFunctionalityHandle`不应该包含`lock`和`unlock`的实际实现，而应该将调用传递给存储的实现，该实现针对您正在使用的任何操作系统。例如，假设您有一个针对基于Windows的实现的结构体`windows::SomeOsSpecificFunctionalityHandle`和一个针对基于Unix的实现的结构体`unix::SomeOsSpecificFunctionalityHandle`。`SomeOsSpecificFunctionalityHandle`应该根据正在运行的操作系统，有条件地将它的`lock`和`unlock`调用传递到正确的实现。这些可能具有更多功能。Windows的那个可能有一个`awesome_windows_thing()`函数，这可能对需要它的不幸的Windows开发者很有用。Unix实现可能有一个`confusing_posix_thing()`函数，它做一些只有Unix黑客才能理解的非常奇怪的事情。重要的是，我们的`SomeOsSpecificFunctionalityHandle`应该代表实现的一个通用接口。在我们的例子中，这意味着每个支持的操作系统都有能力锁定和解除锁定相关的资源。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using the constructor pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用构造器模式* 的配方在 [第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*'
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据装箱* 的配方在 [第5章](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)，*高级数据结构*'
- en: '*Accessing resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用RwLocks并行访问资源* 的配方在 [第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性与Rayon*'
