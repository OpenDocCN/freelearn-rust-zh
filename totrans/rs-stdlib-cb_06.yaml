- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing user-defined error types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom logger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Drop trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding RAII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mistakes happen, and that's okay. We are only human after all. The important
    thing in life and in programming is not which errors we make, but how we deal
    with them. Rust helps us with the programming aspect of this principle by providing
    us with an error handling concept that guarantees that we *have* to think about
    the consequences of failure when dealing with functions that can fail, as they
    don't return a value directly but wrapped in a `Result` that has to be opened
    somehow. The only thing left is designing our code in a way that integrates nicely
    with this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Providing user-defined error types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we learned about a few ways to handle functions that
    have to deal with different kinds of errors. So far, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Simply panicked when encountering them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returned only one kind of error and converted all others into it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returned different kinds of errors in a `Box`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these have been used because we didn't reach this recipe yet. Now, we
    are going to learn about the preferred way of doing things, creating a custom
    kind of `Error` that contains multiple sub-errors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-six`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the newly created `chapter-six` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the folder `src`, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `custom_error.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin custom_error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of our example is to read a file, `age.txt`, and return the number
    written in it, assuming that it represents some kind of age. We can encounter
    three errors during this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Failure to read the file (maybe it doesn't exist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure to read its content as a number (it could contain text as well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number could be negative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These possible error states are the possible variants of our `Error enum`:
    `AgeReaderError`[7]. It is usual to name the variants after the sub-errors they
    represent. Because a failure to read the file raises an `io::Error`, we name our
    corresponding variant `AgeReaderError::Io`[8]. A failure to parse a `&str` as
    an `i32` raises a `num::ParseIntError`, so we name our encompassing variant `AgeReaderError::Parse`[9].'
  prefs: []
  type: TYPE_NORMAL
- en: These two `std` errors show the naming convention of errors neatly. If you have
    many different errors that can be returned by a module, export them via their
    full name, such as `num::ParseIntError`. If your module only returns one kind
    of `Error`, simply export it as `Error`, such as `io::Error`. We intentionally
    don't follow this convention in the recipe because the distinct name `AgeReaderError`
    makes it easier to talk about it. If this recipe was included, one for one, in
    a crate, we could achieve the conventional effect by exporting it as `pub type
    Error = AgeReaderError;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we create is an alias for our own `Result`[14]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an extremely common pattern for your own errors, which makes working
    with them a charm, as we see in the return type of `read_age`[77]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks nice, doesn''t it? In order to use our `enum` as an `Error` though, we
    need to implement it first [16]. The `Error` trait requires two things: a `description`[17],
    which is a short explanation of what went wrong, and a `cause`[27], which is simply
    a *redirection* to the underlying error, if any. You can (and should) provide
    a detailed description of the problem at hand by also implementing `Display` for
    your `Error`[37]. In all of these implementations, you should refer to the underlying
    error if possible, as with the following line [20]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last thing you need to provide for a good own `Error` is a `From` implementation
    for every sub-error. In our case this would be `From<io::Error>`[49] and `From<num::ParseIntError>`[55].
    This way, the `try` operator (`?`) will automatically convert the involved errors
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'After implementing all necessary traits, you can return the custom `Error`
    from any function and unwrap values in it with the aforementioned operator. In
    this example, when checking the result of `read_age`, we didn''t have to `match`
    the returned value. In a real `main` function, we would probably just call `.expect("…")`
    on it, but we matched the individual error variants anyway to show you how nicely
    you can react to different problems when using known error types [65 to 73]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A crate''s `Error` is usually put inside an own `error` module for organizational
    reasons and then exported directly for optimal usability. The relevant `lib.rs`
    entries would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Providing logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a big application, things will sooner or later not go as planned. But that's
    okay, as long as you have provided a system for your users to know what went wrong
    and, if possible, why. One time-tested tool to accomplish this is detailed logs
    that let the user specify for themselves how much diagnosis they want to see.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to log's ([https://crates.io/crates/log](https://crates.io/crates/log))
    or `env_logger`'s ([https://crates.io/crates/env_log](https://crates.io/crates/env_log))
    crates.io pages to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `bin`, create a file called `logging.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `RUST_LOG=logging cargo run --bin logging`
    if you''re on a Unix-based system. Otherwise, run `$env:RUST_LOG="logging"; cargo
    run --bin logging` on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's logging system is based on the `log` crate, which provides a common *facade*
    for all things logging. This means that it doesn't actually provide any functionality,
    just the interface. The implementation is left to other crates, `env_logger` in
    our case. This split into facade and implementation is pretty useful, as anyone
    can create a cool new way of logging stuff which is automatically compatible with
    any crate.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of logging implementation used should be up to the consumer of your
    code. If you write a crate, don't use any implementation but simply log all things
    via the `log` crate only. Your (or someone else's) executable that uses the crate
    can then simply initialize their logger of choice[9] in order to actually process
    the log calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` crate provides the `log!` macro[11], which accepts a log `Level`,
    a message that can be formatted the same way as in `println!`, and an optional
    `target`. You could log stuff like this, but it's more readable to use the convenience
    macros for every logging level, `error!`, `warn!`, `info!`, `debug!`, and `trace!`,
    which all simply call `log!` in the background. A log's `target`[19] is an additional
    property that helps the logger implementation group the logs thematically. If
    you omit the `target`, it defaults to the current `module`. So, for example, if
    you logged something from the `foo` crate, its `target` would default to `foo`.
    If you logged something in its submodule `foo::bar`, its `target` would default
    to `bar`. If you then consumed the crate in a `main.rs` and logged something there,
    its `target` would default to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Another goodie that `log` provides is the `log_enabled!` macro, which returns
    whether or not the currently active logger is set to process a certain warning
    level. This is especially useful in combination with `Debug` logs that provide
    useful information at the cost of an expensive operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`env_logger` is a logger implementation provided by the Rust nursery. It prints
    its logs on `stderr` and uses pretty colors for different logging levels if supported
    by your Terminal. It relies on a `RUST_LOG` envvar to filter which logs should
    be displayed. If you don''t define said variable, it will default to `error`,
    which means that it will print only the log level `error` from all targets. As
    you can guess, other possible values include `warn`, `info`, `debug`, and `trace`.
    These will, however, not only filter the specified level, but all levels *above* it
    as well, where the hierarchy is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that setting your `RUST_LOG` to `warn` will show all `warn` and all
    `error` logs. Setting it to `debug` will show `error`, `warn`, `info`, and `debug`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of error levels, you can set `RUST_LOG` to targets, which will show
    all logs of the selected targets regardless of their log levels. This is what
    we do in our example, we set `RUST_LOG` to `logging` in order to show all logs
    with a `target` called `logging`, which is the standard target for all logs in
    our binary. If you wanted, you could combine a level filter with a target filter
    like this: `logging=warn`, which would only show `warn` and `error` logs with
    a `target` of `logging`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can combine different filters with a comma. If you want all logs of this
    example to be displayed, you can set your variable to `logging,extra_info`, which
    filters for both the targets `logging` and `extra_info`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you can filter your logs by content with a slash (`/`), after which
    you can write down a regex that has to be matched. If you set `RUST_LOG` to `logging=debug/expensive`
    for instance, only logs with the logging level of `debug` and upwards with the
    `target` of `logging` that also contain the word `expensive` will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, that's a lot of configuration! I advise you to experiment a bit with the
    different filtering modes and run the example in order to get a feeling for how
    the parts fit together. If you need additional information, all possibilities
    for the value of `RUST_LOG` in the current version of `env_logger` are documented
    at [https://docs.rs/env_logger/](https://docs.rs/env_logger/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve never worked with a logger before, you might wonder what the difference
    between certain log levels is. Of course, you can use them for whatever purpose
    you want, but the following conventions are usual for loggers in many languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log level** | **Usage** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `Error` | Some major problem occurred that might terminate the program soon.
    If the application is a service that should always run, a system administrator
    should immediately be notified. | The connection to the database has been broken.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Warn` | An issue that''s not severe or has an automatic workaround has happened.
    Someone should check this out at some point and fix it. | A user''s configuration
    file contains unrecognized options that have been ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `Info` | Some information that might be useful to look at at a later point.
    This logs normal conditions. | The user has started or stopped a process. A default
    value has been used because no configuration has been provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `Debug` | Information that is helpful to programmers or sysadmins when trying
    to fix a problem. Contrary to many other languages, a debug log is *not* removed
    in release builds. | The parameters passed to a major function. The current state
    of the application at various points. |'
  prefs: []
  type: TYPE_TB
- en: '| `Trace` | Very low-level signals of control flow that are only useful to
    a programmer trying to chase a bug. Allows the reconstruction of a stack trace.
    | The parameters of a minor helper function. The beginning and end of a function.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Many languages also contain a `Fatal` log level. In Rust, a good old `panic!()`
    is used for that. If you want to log your panics in some special way as well,
    you can replace the usual reaction to a panic by simply printing it to `stderr`
    by calling `std::panic::set_hook()` with whatever functionality you want. An example
    of what this might look like is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A good alternative to `env_logger` is the `slog` crate, which provides excellent
    extensible structured logging at the cost of a steepened learning curve. Plus,
    its output looks pretty. If that sounds interesting, be sure to check it out at
    [https://github.com/slog-rs/slog.](https://github.com/slog-rs/slog)
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you or your users might have very specific logging needs. In this
    recipe, we are going to learn how to create a custom logger to work with the `log`
    crate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, if you didn''t do so in the last recipe, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to log's crates.io page ([https://crates.io/crates/log](https://crates.io/crates/log))
    to check for the newest version and use that one instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the folder `bin`, create a file called `custom_logger.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `RUST_LOG=custom_logger cargo run --bin
    custom_logger` if you''re on a Unix-based system. Otherwise, run `$env:RUST_LOG="custom_logger";
    cargo run --bin custom_logger` on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the custom error used in our logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializing and using the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `FileLogger` will, as the name suggests, log things to a file. It also accepts
    a maximum logging level on initialization.
  prefs: []
  type: TYPE_NORMAL
- en: You should not get used to directly logging things on a disk. As stated by *The
    Twelve-Factor App guidelines* ([https://12factor.net/logs](https://12factor.net/logs)),
    logs should be treated as event streams, in the form of a raw dump to `stdout`.
    The production environment can then route all log streams to their final destination
    over `systemd` or a dedicated log router such as `Logplex` ([https://github.com/heroku/logplex](https://github.com/heroku/logplex))
    or `Fluentd` ([https://github.com/fluent/fluentd](https://github.com/fluent/fluentd)).
    These will then decide if the logs should be sent to a file, an analysis system
    like `Splunk` ([https://www.splunk.com/](https://www.splunk.com/)), or a data
    warehouse like `Hive` ([http://hive.apache.org/](http://hive.apache.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Every logger needs to implement the `log::Log` trait, which consists of the
    `enabled`, `log`, and `flush` methods. `enabled` should return if a certain log
    event is accepted by the logger. Here, you can go wild with whatever filtering
    logic you want [18]. This method is never called directly by `log`, so its only
    purpose is to serve you as a helper method inside of the `log` method, which we
    are going to discuss shortly. `flush` [46] is treated the same way. It should
    apply whatever changes you have buffered in your logging, but it is never called
    by `log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if your logger doesn''t interact with the filesystem or the network,
    it will probably simply implement `flush` by doing nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The real bread and butter of the `Log` implementation is the `log` method[24],
    though, as it is called whenever a logging macro is invoked. The implementation
    typically starts with the following line, followed by the actual logging and a
    finishing call to `self.flush()`[25]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our actual logging then consists of simply writing a combination of the current
    logging level, Unix timestamp, target, and logging message to the file and flushing
    it afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, our call to `self.flush()` should be inside the `if` block
    as well, but that would require additional scope around the mutably borrowed `writer`
    in order to not borrow it twice. Because this is not relevant to the underlying
    lesson here, as in, how to create a logger, we placed it outside the block in
    order to make the example more readable. By the way, the way we borrow `writer`
    from an `RwLock` is the subject of the *Accessing resources in parallel with RwLocks *in [Chapter
    8](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism and Rayon*. For now,
    it's enough to know that an `RwLock` is a `RefCell` that is safe to use in a parallel
    environment such as a logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'After implementing `Log` for `FileLogger`, the user can use it as the logger
    called by `log`. To do that, the user has to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Tell `log` which log `Level` is going to be the maximum accepted by our logger
    via `log::set_max_level()` [66]. This is needed because `log` optimizes `.log()`
    calls on our logger away during runtime if they use log levels over our maximum
    level. The function accepts a `LevelFilter` instead of a `Level`, which is why
    we have to convert our level with `to_level_filter()` first [66]. The reason for
    this type is explained in the *There's more...* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the logger with `log::set_boxed_logger()`[68]. `log` accepts a box because
    it treats its logger implementation as a trait object, which we discussed in the
    *Boxing data* section of [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*. If you want a (very) minor performance gain, you can
    also use `log::set_logger()`, which accepts a `static` which you would have to
    create via the `lazy_static` crate first. See  [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml),
    *Advanced Data Structures*, and the recipe *Creating lazy static objects*, for
    more on that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is conventionally done in a provided `.init()` method on the logger, just
    like with `env_logger`, which we implement in line [58]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While we're on it, we can also open the file in the same method. Other possibilities
    include letting the user pass a `File` directly to `init` as a parameter or, for
    maximum flexibility, making the logger a generic one that accepts any stream implementing
    `Write`.
  prefs: []
  type: TYPE_NORMAL
- en: We then return a custom error created in the lines that follow [74 to 116].
  prefs: []
  type: TYPE_NORMAL
- en: 'An example initialization of our logger might look like this [119]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity's sake, `FileLogger` doesn't discriminate against any targets.
    A more sophisticated logger, like `env_logger`, can set different logging levels
    on different targets. For this purpose, `log` provides us with the `LevelFilter`
    enum, which has an `Off` state that corresponds to *no logging enabled for this
    target.* If you need to create such a logger, be sure to remember said enum. You
    can get some inspiration about how to implement target-based filters by looking
    at the source code of `env_logger` at [https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs](https://github.com/sebasmagri/env_logger/blob/master/src/filter/mod.rs).
  prefs: []
  type: TYPE_NORMAL
- en: In a really user-friendly logger, you'll want to display the timestamp in the
    user's own local time. For all things related to time measurement, time zones,
    and dates, check out the `chrono` crate at [https://crates.io/crates/chrono](https://crates.io/crates/chrono).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating lazy static objects *recipe in *[Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml)**,
    Advanced Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Drop trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where traditional object-oriented languages have destructors, Rust has the `Drop`
    trait, which consists of a single `drop` function that is called whenever a variable's
    lifetime has ended. By implementing it, you can perform whatever cleanup or advanced
    logging is necessary. You can also automatically free resources via RAII, as we're
    going to see in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `bin`, create a file called `drop.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin drop`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example, adapted with slight changes from the second edition of the Rust
    book ([https://doc.rust-lang.org/book/second-edition/](https://doc.rust-lang.org/book/second-edition/)),
    shows you how to start the implementation of a custom smart pointer. In our case,
    all it does is print the `Debug` information of the data stored when its dropped
    [26]. We do this by implementing the `Drop` trait with its single `drop` function
    [25], which the compiler automatically calls whenever a variable is dropped. All
    smart pointers are implemented this way.
  prefs: []
  type: TYPE_NORMAL
- en: The moment of a variable drop will nearly always be when it leaves its scope.
    For this reason, we cannot call the `drop` function directly[38]. The compiler
    will still call it when it exits its scope, so the cleanup will happen twice,
    resulting in undefined behavior. If you need to drop a variable early, you can
    tell the compiler to do so for you by calling `std::mem:drop` on it [41].
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables that exit their scope are dropped in a **LIFO** way: **Last In, First
    Out**. That means that the last variable to be declared will be the first one
    to be dropped. If we allocate the variables `a`, `b`, `c`, and `d` in exactly
    that order, they will be dropped in the order `d`, `c`, `b`, `a`. In our example,
    we drop `c` early[41], so our order becomes `c`, `d`, `b`, `a` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you want to know how a sophisticated low-level function like `std::mem::drop`
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's right, it does nothing! The reason this works is that it takes `T` by
    value, moving it into the function. The function does nothing and all its owned
    variables go out of scope. Hurray for Rust's borrow checker!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sharing ownership with smart pointers* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding RAII
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can go one step further than simple destructors. We can create structs that
    can give the user temporary access to some resource or functionality and automatically
    revoke it again when the user is done. This concept is called **RAII**, which
    stands for **Resource Acquisition Is Initialization**. Or, in other words, the
    validity of a resource is tied to the lifetime of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `bin`, create a file called `raii.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin raii`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the implementations for the `structs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the actual usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, that's a load of complicated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by introducing the structures that participate in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SomeOsSpecificFunctionalityHandle` [6] stands for an unspecified feature of
    your operating system that operates on some data and is presumably unsafe to use
    directly. We assume this feature locks some resource of the operating system that
    needs to be unlocked again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SomeOsFunctionality ` [9] represents a safe wrapper around the feature, plus
    some data `T` that might be useful for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SomeOsFunctionalityGuard` [20] is an RAII guard created by using the `lock`
    function. When it is dropped, it will automatically unlock the underlying resource.
    Additionally, it can be directly used as if it was the data `T` itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions might look a bit abstract, as they don't do anything specific,
    but instead act on *some* unspecified OS feature. This is because most of the
    really useful candidates are already present in the standard library—see `File`,
    `RwLock`, `Mutex`, and so on. What's left are particularly domain-specific use
    cases when writing low-level libraries or dealing with some special, homemade
    resource that needs automatic unlocking. When you see yourself writing either,
    you will appreciate the elegance of RAII.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the structs introduces some new concepts that might look
    a bit confusing if encountered for the first time. In the implementation of `SomeOsSpecificFunctionalityHandle`,
    we can spot some `unsafe` keywords [25 , 28 and 44] :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the unsafe block [44 to 46]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unsafe` keyword tells the compiler to treat the previous block in a special
    way. It disables the borrow checker and lets you do all kinds of crazy stuff:
    dereference raw pointers like in C, modify a mutable static variable, and call
    unsafe functions. In return, the compiler doesn''t give you any guarantees about
    it either. It might, for instance, access invalid memory, resulting in a **SEGFAULT**.
    If you want to read more about the `unsafe` keyword, check out its section in
    the second edition of the official Rust book at [https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html](https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, writing unsafe code should be avoided. It is, however,
    okay to do so when:'
  prefs: []
  type: TYPE_NORMAL
- en: You're writing some code that directly interfaces with the OS and you want to
    create a safe wrapper around the unsafe parts, which is what we are doing here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are absolutely 100% completely certain that what you're doing, in a very
    specific context, is actually not problematic, contrary to the compiler's opinion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're wondering why the `unsafe` block is empty, that's again because we
    are not using any actual OS resources in this recipe. If you wanted to use any,
    the code handling them would go in those two empty blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other use for the `unsafe` keyword is the following [25]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This marks the function itself as unsafe, meaning that it can only be called
    inside `unsafe` blocks. Remember, calling `unsafe` code in a function doesn't
    make the function automatically unsafe because the function could be a safe wrapper
    around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on now from our hypothetical low-level implementation of `SomeOsSpecificFunctionalityHandle`
    to our realistic implementation of its safe wrapper, `SomeOsFunctionality`[33].
    Its constructor comes with no surprises (see [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics* and the *Using the constructor pattern* recipe if you need
    a refresher on that):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We simply prepare the underlying OS functionality and store it with the user-provided
    data in our `struct`. We `Box` the handle because, as explained in a comment in
    the code earlier at lines [13 and 14], the low-level struct interfacing with the
    OS is often not safe to move. Because we don't want to restrict our user from
    moving our safe wrapper, however, we make the handle movable by putting in on
    the heap via a `Box`, which gives it a permanent address. What is then moved is
    simply the smart pointer pointing to the address. For more about that, read [Chapter
    5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced Data Structures* and
    the *Boxing data *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual wrapping takes place in the `lock` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When working with an actual OS feature or custom resource, you'll want to guarantee
    that `self.inner.lock()` is safe to call in this context before doing so, otherwise,
    the wrapper won't be safe. This is also where you can do interesting things with
    `self.data`, which you can potentially use in combination with the resource mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: After locking our stuff up, we return a RAII guard with a reference to our structure
    [49] that will unlock our resource when it is dropped. Looking at the implementation
    of `SomeOsFunctionalityGuard`, you can see that we don't need to implement any
    kind of new function for it. We just need to implement two traits. We begin with
    `Drop`[54], which you have met in the previous recipe. Implementing it means that
    we can unlock the resource when the guard is dropped by accessing it through our
    reference to `SomeOsFunctionality`. Again, make sure to arrange the environment
    in a way that guarantees that `self.lock.inner.unlock()` is actually safe before
    calling it.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are basically creating a kind of smart pointer to `data`, we can use
    the `Deref` trait [64]. Implementing `Deref for B` with a `Target` of `A` allows
    a reference to `B` to be dereferenced into `A`. Or in other, slightly less accurate
    words, it lets `B` act as if it was `A`. In our case, implementing `Deref for
    SomeOsFunctionalityGuard` with a `Target` of `T` means that we can use our guard
    as if it was the underlying data. Because this can cause great confusion to the
    user if implemented poorly, Rust advises you to only implement it on smart pointers
    and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `Deref` is of course not mandatory for the RAII pattern, but can
    prove pretty useful, as we're going to see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can now use all of our fancy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The user should never have to use `SomeOsSpecificFunctionalityHandle` directly,
    as it's `unsafe`. Instead, he can construct an instance of `SomeOsFunctionality`,
    which he can pass around and store however he wants [73]. Whenever he needs to
    use the cool feature behind it, he can call `lock` in whatever scope he is in
    right now, and he will receive a guard that will clean up after him after the
    work is done [81]. Because he implemented `Deref`, he can use the guard directly
    as if it was the underlying data. In our example, `data` is a `&str`, so we can
    use the methods of `str` directly on our guard like we do in line [79] by calling
    `.len()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: After this little scope ends, our guard calls `unlock` on the resource and,
    because `foo` independently still lives on, we can continue locking it again however
    much we want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example is tailored to be in line with the implementations of `RwLock`
    and `Mutex`. The only thing missing is an extra layer of indirection that has
    been omitted to not make this recipe even more complex. `SomeOsSpecificFunctionalityHandle`
    shouldn't contain actual implementations of `lock` and `unlock`, but instead,
    pass the calls onto a stored implementation that is specific to whatever OS you're
    using. For example, say you have a struct, `windows::SomeOsSpecificFunctionalityHandle`,
    for a Windows-based implementation and a struct, `unix::SomeOsSpecificFunctionalityHandle`,
    for a Unix-based implementation. `SomeOsSpecificFunctionalityHandle` should then,
    conditionally, depending on the operating system that is being run, pass its `lock`
    and `unlock` calls onto the correct implementations. These may have many more
    features. The Windows one could maybe have a `awesome_windows_thing()` function
    that might be useful to the unlucky Windows developer that needs it. The Unix
    implementation could have a `confusing_posix_thing()` function that does some
    very weird things that only Unix hackers would understand. The important thing
    is that our  `SomeOsSpecificFunctionalityHandle` should represent a common interface
    of the implementations. In our case, that means that every supported OS has the
    ability to `lock` and `unlock` the resource in question.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using the constructor pattern* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boxing data* recipe in [Chapter 5](6b8b0c3c-2644-4684-b1f4-b1e08d62450c.xhtml), *Advanced
    Data Structures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
