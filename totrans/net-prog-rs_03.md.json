["```rs\n// chapter3/tcp-echo-server.rs\n\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\n\nuse std::io::{Read, Write, Error};\n\n// Handles a single client\nfn handle_client(mut stream: TcpStream) -> Result<(), Error> {\n    println!(\"Incoming connection from: {}\", stream.peer_addr()?);\n    let mut buf = [0; 512];\n    loop {\n        let bytes_read = stream.read(&mut buf)?;\n        if bytes_read == 0 { return Ok(()); }\n        stream.write(&buf[..bytes_read])?;\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"0.0.0.0:8888\")\n                               .expect(\"Could not bind\");\n    for stream in listener.incoming() {\n        match stream {\n            Err(e) => { eprintln!(\"failed: {}\", e) }\n            Ok(stream) => {\n                thread::spawn(move || {\n                    handle_client(stream)\n                    .unwrap_or_else(|error| eprintln!(\"{:?}\", error));\n                });\n            }\n        }\n    }\n}\n```", "```rs\n$ nc <server ip> 8888\ntest\ntest\nfoobar\nfoobar\nfoobarbaz\nfoobarbaz\n^C\n```", "```rs\n// chapter3/tcp-client.rs\n\nuse std::net::TcpStream;\nuse std::str;\nuse std::io::{self, BufRead, BufReader, Write};\n\nfn main() {\n    let mut stream = TcpStream::connect(\"127.0.0.1:8888\")\n                               .expect(\"Could not connect to server\");\n    loop {\n        let mut input = String::new();\n        let mut buffer: Vec<u8> = Vec::new();\n        io::stdin().read_line(&mut input)\n                   .expect(\"Failed to read from stdin\");\n        stream.write(input.as_bytes())\n              .expect(\"Failed to write to server\");\n\n        let mut reader = BufReader::new(&stream);\n\n        reader.read_until(b'\\n', &mut buffer)\n              .expect(\"Could not read into buffer\");\n        print!(\"{}\", str::from_utf8(&buffer)\n               .expect(\"Could not write buffer as string\"));\n    }\n}\n```", "```rs\n$ rustc tcp-client.rs && ./tcp-client\ntest\ntest\nfoobar\nfoobar\nfoobarbaz\nfoobarbaz\n^C\n```", "```rs\n$ cargo new --bin tcp-echo-random\n```", "```rs\n[package]\nname = \"tcp-echo-random\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nrand = \"0.3.17\"\n```", "```rs\n// chapter3/tcp-echo-random/src/main.rs\n\nextern crate rand;\n\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nuse rand::{thread_rng, Rng};\nuse std::time::Duration;\nuse std::io::{Read, Write, Error};\n\nfn handle_client(mut stream: TcpStream) -> Result<(), Error> {\n    let mut buf = [0; 512];\n    loop {\n        let bytes_read = stream.read(&mut buf)?;\n        if bytes_read == 0 { return Ok(()) }\n        let sleep = Duration::from_secs(*thread_rng()\n                             .choose(&[0, 1, 2, 3, 4, 5])\n                             .unwrap());\n        println!(\"Sleeping for {:?} before replying\", sleep);\n        std::thread::sleep(sleep);\n        stream.write(&buf[..bytes_read])?;\n    }\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8888\").expect(\"Could\n    not bind\");\n    for stream in listener.incoming() {\n        match stream {\n            Err(e) => eprintln!(\"failed: {}\", e),\n            Ok(stream) => {\n                thread::spawn(move || {\n                    handle_client(stream).unwrap_or_else(|error|\n                    eprintln!(\"{:?}\", error));\n                });\n            }\n        }\n    }\n}\n```", "```rs\n// chapter3/tcp-client-timeout.rs\n\nuse std::net::TcpStream;\nuse std::str;\nuse std::io::{self, BufRead, BufReader, Write};\nuse std::time::Duration;\nuse std::net::SocketAddr;\n\nfn main() {\n    let remote: SocketAddr = \"127.0.0.1:8888\".parse().unwrap();\n    let mut stream = TcpStream::connect_timeout(&remote,\n    Duration::from_secs(1))\n                               .expect(\"Could not connect to server\");\n    stream.set_read_timeout(Some(Duration::from_secs(3)))\n          .expect(\"Could not set a read timeout\");\n    loop {\n        let mut input = String::new();\n        let mut buffer: Vec<u8> = Vec::new();\n        io::stdin().read_line(&mut input).expect(\"Failed to read from\n        stdin\");\n        stream.write(input.as_bytes()).expect(\"Failed to write to\n        server\");\n\n        let mut reader = BufReader::new(&stream);\n\n        reader.read_until(b'\\n', &mut buffer)\n              .expect(\"Could not read into buffer\");\n        print!(\"{}\", str::from_utf8(&buffer)\n                    .expect(\"Could not write buffer as string\"));\n    }\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/tcp-echo-random`\nSleeping for Duration { secs: 2, nanos: 0 } before replying\nSleeping for Duration { secs: 1, nanos: 0 } before replying\nSleeping for Duration { secs: 1, nanos: 0 } before replying\nSleeping for Duration { secs: 5, nanos: 0 } before replying\n```", "```rs\n$ rustc tcp-client-timeout.rs && ./tcp-client-timeout\ntest\ntest\nfoo\nfoo\nbar\nbar\nbaz\nthread 'main' panicked at 'Could not read into buffer: Error { repr: Os { code: 35, message: \"Resource temporarily unavailable\" } }', src/libcore/result.rs:906:4\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\n// chapter3/udp-echo-server.rs\n\nuse std::thread;\nuse std::net::UdpSocket;\n\nfn main() {\n    let socket = UdpSocket::bind(\"0.0.0.0:8888\")\n                           .expect(\"Could not bind socket\");\n\n    loop {\n        let mut buf = [0u8; 1500];\n        let sock = socket.try_clone().expect(\"Failed to clone socket\");\n        match socket.recv_from(&mut buf) {\n            Ok((_, src)) => {\n                thread::spawn(move || {\n                    println!(\"Handling connection from {}\", src);\n                    sock.send_to(&buf, &src)\n                        .expect(\"Failed to send a response\");\n                });\n            },\n            Err(e) => {\n                eprintln!(\"couldn't recieve a datagram: {}\", e);\n            }\n        }\n    }\n}\n```", "```rs\n$ nc -u 127.0.0.1 8888\ntest\ntest\ntest\ntest\n^C\n```", "```rs\n// chapter3/udp-client.rs\n\nuse std::net::UdpSocket;\nuse std::{str,io};\n\nfn main() {\n    let socket = UdpSocket::bind(\"127.0.0.1:8000\")\n                           .expect(\"Could not bind client socket\");\n    socket.connect(\"127.0.0.1:8888\")\n          .expect(\"Could not connect to server\");\n    loop {\n        let mut input = String::new();\n        let mut buffer = [0u8; 1500];\n        io::stdin().read_line(&mut input)\n                   .expect(\"Failed to read from stdin\");\n        socket.send(input.as_bytes())\n              .expect(\"Failed to write to server\");\n\n        socket.recv_from(&mut buffer)\n              .expect(\"Could not read into buffer\");\n        print!(\"{}\", str::from_utf8(&buffer)\n                         .expect(\"Could not write buffer as string\"));\n    }\n}\n```", "```rs\n$ rustc udp-echo-server.rs && ./udp-echo-server\nHandling connection from 127.0.0.1:8000\nHandling connection from 127.0.0.1:8000\nHandling connection from 127.0.0.1:8000\n^C\n```", "```rs\n$ rustc udp-client.rs && ./udp-client\ntest\ntest\nfoo\nfoo\nbar\nbar\n^C\n```", "```rs\n// chapter3/udp-multicast.rs\n\nuse std::{env, str};\nuse std::net::{UdpSocket, Ipv4Addr};\n\nfn main() {\n    let mcast_group: Ipv4Addr = \"239.0.0.1\".parse().unwrap();\n    let port: u16 = 6000;\n    let any = \"0.0.0.0\".parse().unwrap();\n    let mut buffer = [0u8; 1600];\n    if env::args().count() > 1 {\n        // client case\n        let socket = UdpSocket::bind((any, port))\n                               .expect(\"Could not bind client socket\");\n        socket.join_multicast_v4(&mcast_group, &any)\n              .expect(\"Could not join multicast group\");\n        socket.recv_from(&mut buffer)\n              .expect(\"Failed to write to server\");\n        print!(\"{}\", str::from_utf8(&buffer)\n                         .expect(\"Could not write buffer as string\"));\n    } else {\n        // server case\n        let socket = UdpSocket::bind((any, 0))\n                               .expect(\"Could not bind socket\");\n        socket.send_to(\"Hello world!\".as_bytes(), &(mcast_group, port))\n              .expect(\"Failed to write data\");\n    }\n}\n```", "```rs\n$ rustc udp-multicast.rs && ./udp-multicast server\nHello world!\n```", "```rs\n// chapter3/ip-socket-addr.rs\n\n#![feature(ip)]\n\nuse std::net::{IpAddr, SocketAddr};\n\nfn main() {\n    // construct an IpAddr from a string and check it\n    // represents the loopback address\n    let local: IpAddr = \"127.0.0.1\".parse().unwrap();\n    assert!(local.is_loopback());\n\n    // construct a globally routable IPv6 address from individual\n    octets\n    // and assert it is classified correctly\n    let global: IpAddr = IpAddr::from([0, 0, 0x1c9, 0, 0, 0xafc8, 0,\n    0x1]);\n    assert!(global.is_global());\n\n    // construct a SocketAddr from a string an assert that the\n    underlying\n    // IP is a IPv4 address\n    let local_sa: SocketAddr = \"127.0.0.1:80\".parse().unwrap();\n    assert!(local_sa.is_ipv4());\n\n    // construct a SocketAddr from a IPv6 address and a port, assert\n    that\n    // the underlying address is indeed IPv6\n    let global_sa = SocketAddr::new(global, 80u16);\n    assert!(global_sa.is_ipv6());\n}\n```", "```rs\n// chapter3/lookup-host.rs\n\n#![feature(lookup_host)]\n\nuse std::env;\nuse std::net::lookup_host;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Please provide only one host name\");\n        std::process::exit(1);\n    } else {\n        let addresses = lookup_host(&args[1]).unwrap();\n        for address in addresses {\n            println!(\"{}\", address.ip());\n        }\n    }\n}\n```", "```rs\n$ rustc lookup-host.rs && ./lookup-host google.com\n2a00:1450:4009:810::200e\n216.58.206.110\n```", "```rs\n$ cargo new --bin ipnetwork-example\n```", "```rs\n[package]\nname = \"ipnetwork-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nipnetwork = \"0.12.7\"\n```", "```rs\n// chapter3/ipnetwork-example/src/main.rs\n\nextern crate ipnetwork;\n\nuse std::net::Ipv4Addr;\nuse ipnetwork::{IpNetwork, Ipv4Network, Ipv6Network};\n\nfn main() {\n    let net = IpNetwork::new(\"192.168.122.0\".parse().unwrap(), 22)\n                        .expect(\"Could not construct a network\");\n    let str_net: IpNetwork = \"192.168.122.0/22\".parse().unwrap();\n\n    assert!(net == str_net);\n    assert!(net.is_ipv4());\n\n    let net4: Ipv4Network = \"192.168.121.0/22\".parse().unwrap();\n    assert!(net4.size() == 2u64.pow(32 - 22));\n    assert!(net4.contains(Ipv4Addr::new(192, 168, 121, 3)));\n\n    let _net6: Ipv6Network = \"2001:db8::0/96\".parse().unwrap();\n    for addr in net4.iter().take(10) {\n        println!(\"{}\", addr);\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling ipnetwork v0.12.7\n   Compiling ipnetwork-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter3/ipnetwork-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.18 secs\n     Running `target/debug/ipnetwork-example`\n192.168.120.0\n192.168.120.1\n192.168.120.2\n192.168.120.3\n192.168.120.4\n192.168.120.5\n192.168.120.6\n192.168.120.7\n192.168.120.8\n192.168.120.9\n```", "```rs\n$ cargo new --bin mio-example\n```", "```rs\n[package]\nname = \"mio-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nmio = \"0.6.11\"\n```", "```rs\n// chapter3/mio-example/src/main.rs\n\nextern crate mio;\n\nuse mio::*;\nuse mio::tcp::TcpListener;\n\nuse std::net::SocketAddr;\nuse std::env;\n\n// This will be later used to identify the server on the event loop\nconst SERVER: Token = Token(0);\n\n// Represents a simple TCP server using mio\nstruct TCPServer {\n    address: SocketAddr,\n}\n\n// Implementation for the TCP server\nimpl TCPServer {\n    fn new(port: u32) -> Self {\n        let address = format!(\"0.0.0.0:{}\", port)\n            .parse::<SocketAddr>().unwrap();\n\n        TCPServer {\n            address,\n        }\n    }\n\n    // Actually binds the server to a given address and runs it\n    // This function also sets up the event loop that dispatches\n    // events. Later, we use a match on the token on the event\n    // to determine if the event is for the server.\n    fn run(&mut self) {\n        let server = TcpListener::bind(&self.address)\n            .expect(\"Could not bind to port\");\n        let poll = Poll::new().unwrap();\n        poll.register(&server, \n                       SERVER,\n                       Ready::readable(),\n                       PollOpt::edge()).unwrap();\n\n        let mut events = Events::with_capacity(1024);\n        loop {\n            poll.poll(&mut events, None).unwrap();\n\n            for event in events.iter() {\n                match event.token() {\n                    SERVER => {\n                        let (_stream, remote) =\n                        server.accept().unwrap();\n                        println!(\"Connection from {}\", remote);\n                    }\n                    _ => {\n                        unreachable!();\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Please provide only one port number as argument\");\n        std::process::exit(1);\n    }\n    let mut server = TCPServer::new(args[1].parse::<u32>()\n                               .expect(\"Could not parse as u32\"));\n    server.run();\n}\n```", "```rs\n$ cargo run 4321\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/mio-example 4321`\nConnection from 127.0.0.1:60955\nConnection from 127.0.0.1:60956\n^C\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"pnet-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo Bar <foo@bar.com>\"]\n\n[dependencies]\npnet = \"0.20.0\"\n```", "```rs\n$ cargo new --bin pnet-example\n```", "```rs\n// chapter3/pnet-example/src/main.rs\n\nextern crate pnet;\n\nuse pnet::datalink::{self, NetworkInterface};\nuse pnet::datalink::Channel::Ethernet;\nuse pnet::packet::ethernet::{EtherTypes, EthernetPacket};\nuse pnet::packet::ipv4::Ipv4Packet;\nuse pnet::packet::tcp::TcpPacket;\nuse pnet::packet::ip::IpNextHeaderProtocols;\nuse pnet::packet::Packet;\n\nuse std::env;\n\n// Handles a single ethernet packet\nfn handle_packet(ethernet: &EthernetPacket) {\n    match ethernet.get_ethertype() {\n        EtherTypes::Ipv4 => {\n            let header = Ipv4Packet::new(ethernet.payload());\n            if let Some(header) = header {\n                match header.get_next_level_protocol() {\n                    IpNextHeaderProtocols::Tcp => {\n                        let tcp = TcpPacket::new(header.payload());\n                        if let Some(tcp) = tcp {\n                            println!(\n                                \"Got a TCP packet {}:{} to {}:{}\",\n                                header.get_source(),\n                                tcp.get_source(),\n                                header.get_destination(),\n                                tcp.get_destination()\n                            );\n                        }\n                    }\n                    _ => println!(\"Ignoring non TCP packet\"),\n                }\n            }\n        }\n        _ => println!(\"Ignoring non IPv4 packet\"),\n    }\n}\n\nfn main() {\n    let interface_name = env::args().nth(1).unwrap();\n\n    // Get all interfaces\n    let interfaces = datalink::interfaces();\n    // Filter the list to find the given interface name\n    let interface = interfaces\n        .into_iter()\n        .filter(|iface: &NetworkInterface| iface.name == interface_name)\n        .next()\n        .expect(\"Error getting interface\");\n\n    let (_tx, mut rx) = match datalink::channel(&interface, Default::default()) {\n        Ok(Ethernet(tx, rx)) => (tx, rx),\n        Ok(_) => panic!(\"Unhandled channel type\"),\n        Err(e) => {\n            panic!(\n                \"An error occurred when creating the datalink channel:\n                {}\",e\n            )\n        }\n    };\n\n    // Loop over packets arriving on the given interface\n    loop {\n        match rx.next() {\n            Ok(packet) => {\n                let packet = EthernetPacket::new(packet).unwrap();\n                handle_packet(&packet);\n            }\n            Err(e) => {\n            panic!(\"An error occurred while reading: {}\", e);\n            }\n        }\n    }\n}\n```", "```rs\n$ ip a\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether f4:4d:30:ac:88:ee brd ff:ff:ff:ff:ff:ff\n    inet 192.168.5.15/22 brd 192.168.7.255 scope global enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::58c6:9ccc:e78c:caa6/64 scope link \n       valid_lft forever preferred_lft forever\n```", "```rs\n$ cargo build\n$ sudo ./target/debug/pnet-example enp1s0\nGot a TCP packet 192.168.0.2:53041 to 104.82.249.116:443\nGot a TCP packet 104.82.249.116:443 to 192.168.0.2:53041\nGot a TCP packet 192.168.0.2:53064 to 17.142.169.200:443\nGot a TCP packet 192.168.0.2:53064 to 17.142.169.200:443\nGot a TCP packet 17.142.169.200:443 to 192.168.0.2:53064\nGot a TCP packet 17.142.169.200:443 to 192.168.0.2:53064\nGot a TCP packet 192.168.0.2:53064 to 17.142.169.200:443\nGot a TCP packet 192.168.0.2:52086 to 52.174.153.60:443\nIgnoring non IPv4 packet\nGot a TCP packet 52.174.153.60:443 to 192.168.0.2:52086\nGot a TCP packet 192.168.0.2:52086 to 52.174.153.60:443\nIgnoring non IPv4 packet\nIgnoring non IPv4 packet\nIgnoring non IPv4 packet\nIgnoring non IPv4 packet\n```", "```rs\n$ cargo new --bin trust-dns-example\n```", "```rs\n[package]\nname = \"trust-dns-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\ntrust-dns-resolver = \"0.6.0\"\ntrust-dns = \"0.12.0\"\n```", "```rs\n// chapter3/trust-dns-example/src/main.rs\n\nextern crate trust_dns_resolver;\nextern crate trust_dns;\n\nuse std::env;\n\nuse trust_dns_resolver::Resolver;\nuse trust_dns_resolver::config::*;\n\nuse trust_dns::rr::record_type::RecordType;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Please provide a name to query\");\n        std::process::exit(1);\n    }\n    let resolver = Resolver::new(ResolverConfig::default(),\n                                 ResolverOpts::default()).unwrap();\n\n    // Add a dot to the given name\n    let query = format!(\"{}.\", args[1]);\n\n    // Run the DNS query\n    let response = resolver.lookup_ip(query.as_str());\n    println!(\"Using the synchronous resolver\");\n    for ans in response.iter() {\n        println!(\"{:?}\", ans);\n    }\n\n    println!(\"Using the system resolver\");\n    let system_resolver = Resolver::from_system_conf().unwrap();\n    let system_response = system_resolver.lookup_ip(query.as_str());\n    for ans in system_response.iter() {\n        println!(\"{:?}\", ans);\n    }\n\n    let ns = resolver.lookup(query.as_str(), RecordType::NS);\n    println!(\"NS records using the synchronous resolver\");\n    for ans in ns.iter() {\n        println!(\"{:?}\", ans);\n    }\n}\n```", "```rs\n$ cargo run google.com\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/trust-dns-example google.com`\nUsing the synchronous resolver\nLookupIp(Lookup { rdatas: [AAAA(2a00:1450:4009:811::200e), A(216.58.206.142)] })\nUsing the system resolver\nLookupIp(Lookup { rdatas: [A(216.58.206.110), AAAA(2a00:1450:4009:810::200e)] })\nNS records using the synchronous resolver\nLookup { rdatas: [NS(Name { is_fqdn: true, labels: [\"ns3\", \"google\", \"com\"] }), NS(Name { is_fqdn: true, labels: [\"ns1\", \"google\", \"com\"] }), NS(Name { is_fqdn: true, labels: [\"ns4\", \"google\", \"com\"] }), NS(Name { is_fqdn: true, labels: [\"ns2\", \"google\", \"com\"] })] }\n```"]