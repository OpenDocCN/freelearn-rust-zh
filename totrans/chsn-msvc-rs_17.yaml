- en: Bounded Microservices with AWS Lambda
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda 的有界微服务
- en: In the Last chapter we learned how to create serverless applications using AWS
    Lambda and the official `lambda-runtime` crate. It is useful for developers who
    use **Amazon Web Services** (**AWS**) and who especially want to use AWS Lambda.
    It differs from the approach where we created a standalone web server, because
    AWS Lambda stores, scales, and runs automatically, and the only thing we should
    provide is the compiled code of a microservice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 AWS Lambda 和官方的 `lambda-runtime` 包创建无服务器应用程序。这对于使用 **Amazon
    Web Services** (**AWS**) 的开发者尤其有用，尤其是那些特别想使用 AWS Lambda 的开发者。它与我们在创建独立网络服务器时的方法不同，因为
    AWS Lambda 会自动存储、扩展和运行，而我们唯一需要提供的是微服务的编译代码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Dealing with the AWS Lambda Rust runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 AWS Lambda Rust 运行时
- en: Deploying a microservice to AWS using the Serverless Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Serverless Framework 将微服务部署到 AWS
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To use the techniques from this chapter, you need a configured Docker instance,
    because AWS uses Amazon Linux AMI distribution to run lambdas, and we need the
    special environment to compile Rust code for that environment. You also need an
    account in AWS. Create one if you don''t have one. AWS provides a free trial period
    called Free Tier, which includes 1 million requests to AWS Lambda per month over
    the course of one year. You can read more about this trial period here: [https://aws.amazon.com/free/.](https://aws.amazon.com/free/)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的技术，您需要一个配置好的 Docker 实例，因为 AWS 使用 Amazon Linux AMI 分发版来运行 Lambda，我们需要为该环境编译
    Rust 代码的特殊环境。您还需要在 AWS 中有一个账户。如果您还没有，请创建一个。AWS 提供了一个名为 Free Tier 的免费试用期，为期一年，每月包含
    100 万次 AWS Lambda 请求。您可以在以下链接中了解更多关于这个试用期的信息：[https://aws.amazon.com/free/](https://aws.amazon.com/free/)
- en: 'You should also know how to use AWS Console. There will be some examples of
    using it in this chapter, but for production you have to know all its features,
    including using access controls to prevent malicious penetration to your microservice.
    You can read about AWS in a book called *Learning AWS*: [https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition](https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该知道如何使用 AWS 控制台。本章中将有使用它的示例，但为了生产环境，您必须了解其所有功能，包括使用访问控制来防止恶意渗透到您的微服务。您可以在一本名为《Learning
    AWS》的书中了解 AWS：[https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition](https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition)。
- en: In this chapter, we will create two examples of a serverless application. The
    first requires the Rust compiler 1.31 version or above and the `musl` library,
    and the second needs npm and Docker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建两个无服务器应用程序的示例。第一个示例需要 Rust 编译器 1.31 版本或更高版本以及 `musl` 库，而第二个示例则需要 npm
    和 Docker。
- en: 'You can find sources of all examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章所有示例的源代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/)
- en: Serverless architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构
- en: For the most part, in this book we have created microservices as standalone
    server applications. To deploy them you have to upload binaries to remote servers
    using continuous delivery tools. If you don't want to worry about making the binaries
    compatible with operating systems, you can use containers to deliver and deploy
    applications packed to images. It gives you the opportunity to use container orchestration
    services, such as Kubernetes. Container orchestration software simplifies scaling
    and configuring large applications that use containers to run microservices. If
    you try to think about this simplification further, you can find it helpful to
    use a predefined and preinstalled pool of containers with generic environment
    that will run small binaries with request-handling functions and without any HTTP
    middleware. In other words, you could write handlers for events and no more HTTP
    code. This approach is called serverless.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分内容中，我们已将微服务创建为独立的服务器应用程序。要部署它们，您必须使用持续交付工具将二进制文件上传到远程服务器。如果您不想担心使二进制文件与操作系统兼容，您可以使用容器来交付和部署打包到镜像中的应用程序。这为您提供了使用容器编排服务（如
    Kubernetes）的机会。容器编排软件简化了使用容器运行微服务的大型应用程序的扩展和配置。如果您进一步思考这种简化，您会发现使用预定义和预安装的容器池很有帮助，这些容器池具有通用的环境，可以运行带有请求处理功能的小型二进制文件，而不需要任何
    HTTP 中间件。换句话说，您可以为事件编写处理器，而无需编写更多的 HTTP 代码。这种方法被称为无服务器。
- en: In the next section we list the platforms that provide serverless infrastructure
    and that can be used to deploy serverless applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将列出提供无服务器基础设施并可用于部署无服务器应用程序的平台。
- en: AWS Lambda
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: 'AWS Lambda is an Amazon product that you can find here: [https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 是 Amazon 的一项产品，您可以在以下链接找到：[https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/).
- en: 'There is official support for the Rust programming language with the `lambda-runtime`
    crate: [https://github.com/awslabs/aws-lambda-rust-runtime](https://github.com/awslabs/aws-lambda-rust-runtime).
    We will use this crate in this chapter to demonstrate the serverless approach.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 Rust 编程语言提供了官方支持，使用 `lambda-runtime` 包：[https://github.com/awslabs/aws-lambda-rust-runtime](https://github.com/awslabs/aws-lambda-rust-runtime).
    我们将在本章中使用此包来演示无服务器方法。
- en: Azure Functions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Functions
- en: 'Azure Functions is the serverless product of Microsoft, and is part of the Azure
    platform: [https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)[.](https://azure.microsoft.com/en-us/services/functions/)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 是微软的无服务器产品，它是 Azure 平台的一部分：[https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)[.](https://azure.microsoft.com/en-us/services/functions/)
- en: There is no official Rust support at the moment, but you can use the `azure-functions`
    crate, which uses the internal worker protocol of Azure Functions based on GRPC
    to interact between the host and the language worker.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有官方的 Rust 支持，但您可以使用 `azure-functions` 包，该包使用基于 GRPC 的 Azure Functions 内部工作者协议在主机和语言工作者之间进行交互。
- en: Cloudflare Workers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloudflare Workers
- en: 'Cloudflare offers its own serverless product called Cloudflare Workers: [https://www.cloudflare.com/products/cloudflare-workers/](https://www.cloudflare.com/products/cloudflare-workers/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudflare 提供了自己的无服务器产品，称为 Cloudflare Workers：[https://www.cloudflare.com/products/cloudflare-workers/](https://www.cloudflare.com/products/cloudflare-workers/).
- en: 'This service is compatible with Rust because Cloudflare Workers implemented
    an awesome idea: **workers compiled to WebAssebly** (**WASM**). Since Rust has
    good support for WASM, you can easily use it to produce serverless workers for
    Cloudflare.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务与 Rust 兼容，因为 Cloudflare Workers 实现了一个很棒的想法：**将工作者编译为 WebAssembly**（**WASM**）。由于
    Rust 对 WASM 有良好的支持，您可以使用它轻松地为 Cloudflare 生成无服务器工作者。
- en: IBM Cloud Functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM Cloud Functions
- en: 'IBM provides its own serverless product based on Apache OpenWhisk: [https://console.bluemix.net/openwhisk/](https://console.bluemix.net/openwhisk/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: IBM 提供了自己的基于 Apache OpenWhisk 的无服务器产品：[https://console.bluemix.net/openwhisk/](https://console.bluemix.net/openwhisk/).
- en: You can write serverless functions using Rust, because the platform supports
    functions provided as Docker images and you can create a Docker image with your
    Rust functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Rust 编写无服务器函数，因为该平台支持以 Docker 镜像提供的函数，并且您可以使用 Rust 函数创建 Docker 镜像。
- en: Google Cloud Functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Functions
- en: 'Google Cloud Functions is a product of Google provided as a part of Google
    Cloud: [https://cloud.google.com/functions/](https://cloud.google.com/functions/).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions 是 Google 提供的产品，作为 Google Cloud 的一部分：[https://cloud.google.com/functions/](https://cloud.google.com/functions/).
- en: There is no support for Rust. Potentially, you can write native modules for
    Python environments using Rust and try to start them using Python code, but I
    can't find confirmation that this approach will work. In any case, I'm sure there
    will be an opportunity in the future to run Rust code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有支持。可能，你可以使用 Rust 为 Python 环境编写原生模块，并尝试使用 Python 代码启动它们，但我找不到确认这种方法是否可行的证据。无论如何，我确信将来会有机会运行
    Rust 代码。
- en: Minimal Rust microservices for AWS Lambda
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于 AWS Lambda 的最小 Rust 微服务
- en: In this section, we will create a microservice that works in a serverless environment
    using AWS Lambda. We will reimplement the random number generator from [Chapter
    4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data Serialization and Deserialization
    with Serde Crate,* in the *Data format for interaction with microservices* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个在 AWS Lambda 无服务器环境中工作的微服务。我们将重新实现第 4 章 [数据序列化和反序列化使用 Serde Crate](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml)
    中 *与微服务交互的数据格式* 部分的随机数生成器。
- en: Dependencies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'First, we need to create a new `minimal-lambda` crate and add the following
    dependencies to it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的 `minimal-lambda` crate 并向其中添加以下依赖项：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main dependency we need is `lambda_runtime`, which is an official crate
    for writing `lambda` functions for AWS Lambda platform using Rust. We used a version
    from GitHub because, at the time of writing, this crate was in active development.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的首要依赖项是 `lambda_runtime`，这是一个用于使用 Rust 为 AWS Lambda 平台编写 `lambda` 函数的官方
    crate。我们使用了 GitHub 上的版本，因为在编写本文时，这个 crate 正在积极开发。
- en: AWS prints the output of all the `lambda` functions as logs, and we will use
    the `simple_logger` crate, which prints all logs to *stdout*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 将所有 `lambda` 函数的输出打印为日志，我们将使用 `simple_logger` crate，它将所有日志打印到 *stdout*。
- en: 'We also need to override the name of a binary with lambda, because an environment
    that run, AWS Lambda expects to find a binary called `bootstrap` that implements
    the `lambda` function. Let''s rename the binary produced by our example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用 lambda 重写二进制的名称，因为运行 AWS Lambda 的环境期望找到一个名为 `bootstrap` 的二进制文件，该文件实现了
    `lambda` 函数。让我们将我们的示例生成的二进制文件重命名：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's enough to start writing a minimal microservice for a serverless environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始编写一个用于无服务器环境的最小微服务了。
- en: Developing a microservice
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个微服务
- en: 'We need the following types in our code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的代码中以下类型：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It make sense to look at imports from the `lambda_runtime` crate. The `lambda`
    macro is used to export a handler from a binary, which will be used by the AWS
    Lambda runtime. `Context` is a required parameter of a handler, and we also have 
     imported `HandlerError` to use in the returning `Result` value of a handler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查看从 `lambda_runtime` crate 的导入是有意义的。`lambda` 宏用于从二进制文件导出处理程序，该处理程序将由 AWS Lambda
    运行时使用。`Context` 是处理程序的必需参数，我们还有导入 `HandlerError` 以用于处理程序的返回 `Result` 值。
- en: 'Then we can write a main function that initializes `simple_logger` and wraps
    `rng_handler`, which we will implement in the following code, to export the handler
    of a lambda function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写一个主函数，初始化 `simple_logger` 并将 `rng_handler`（我们将在下面的代码中实现）包装起来，以导出 lambda
    函数的处理程序：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`rng_handler` is a function that expects a request and returns a response:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`rng_handler` 是一个函数，它期望一个请求并返回一个响应：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the implementation, we used a generator from the example in [Chapter 4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data
    Serialization and Deserialization with the Serde Crate,* in the *Data format for
    interaction with microservices* section, and also borrowed a request type that
    has to be deserializable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，我们使用了第 4 章 [使用 Serde Crate 的数据序列化和反序列化](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml)
    中的示例中的生成器，并在 *与微服务交互的数据格式* 部分借用了一个必须可序列化的请求类型：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding request type is an enumeration that has three variants that let
    a client choose one of three probability distributions to generate a random value.
    We also need a type to return responses with random values. We will also borrow
    it from the preceding code. Look at the struct we will use for responses:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个请求类型是一个枚举，有三个变体，允许客户端选择三个概率分布之一来生成随机值。我们还需要一个类型来返回带有随机值的响应。我们也将从前面的代码中借用它。看看我们将使用的响应结构体：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, this lambda function expects an `RngRequest` value in JSON format as a
    request that will be deserialized automatically, and a `RngResponse` result that
    will be serialized to JSON and returned to a client. Let's build this code and
    check how it works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个 lambda 函数期望一个 JSON 格式的 `RngRequest` 值作为请求，它将被自动反序列化，以及一个 `RngResponse`
    结果，它将被序列化为 JSON 并返回给客户端。让我们构建这段代码并检查它的工作情况。
- en: Building
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'To build a lambda function, we need to produce a binary that is compatible
    with Amazon Linux. You can use three methods to build a corresponding binary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 lambda 函数，我们需要生成一个与亚马逊 Linux 兼容的二进制文件。您可以使用三种方法来构建相应的二进制文件：
- en: Build it with a Linux distribution (compatible with x86_64).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与 x86_64 兼容的 Linux 发行版构建它。
- en: Build it in a Docker container of Amazon Linux.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在亚马逊 Linux 的 Docker 容器中构建它。
- en: Build it with the `musl` standard C library.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `musl` 标准C库构建它。
- en: 'We will use the latter method, because it minimizes the external dependencies
    of the produced binary. First, you have to install the `musl` library, which you
    can get here: [https://www.musl-libc.org/](https://www.musl-libc.org/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用后一种方法，因为它最小化了生成的二进制文件的外部依赖。首先，您必须安装 `musl` 库，您可以从这里获取：[https://www.musl-libc.org/](https://www.musl-libc.org/)。
- en: 'I did this with the following commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用以下命令完成了这项工作：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But if there is a package for your operating system, you should to install that
    instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您的操作系统有相应的包，您应该安装那个包。
- en: 'To build the code with the `musl` library we have to use `x86_64-unknown-linux-musl` as
    the target value. But we can set this target as the default for this project with
    a configuration file for cargo. Add a `.cargo/config` file to the project''s folder
    and add the following configuration to it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `musl` 库构建代码，我们必须将 `x86_64-unknown-linux-musl` 作为目标值。但我们可以通过 cargo 的配置文件将此目标设置为项目的默认值。在项目的文件夹中添加一个
    `.cargo/config` 文件，并添加以下配置：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make sure the compiler supports `musl` or add it using `rustup`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保编译器支持 `musl` 或使用 `rustup` 添加它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can simply build the lambda using the `cargo build` command. That produces
    a binary that's compiled with the `musl` library that we can upload to AWS.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `cargo build` 命令简单地构建 lambda。这将生成一个使用 `musl` 库编译的二进制文件，我们可以将其上传到 AWS。
- en: Deployment
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'We can deploy lambda to AWS using two tools:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个工具将 lambda 部署到 AWS：
- en: AWS CLI tool
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI 工具
- en: Web AWS Console
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web AWS 控制台
- en: 'The first is a little tedious, and in the next section of this chapter, you
    will see how to use the Serverless Framework to deploy an application consists
    of `lambda` functions. For this example, enter the AWS Console and go to the AWS
    Lambda product page. Click the *Create Function* button and, in the form that
    appears, enter the following values:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个步骤可能有点繁琐，在本书的下一节中，您将看到如何使用 Serverless Framework 来部署由 `lambda` 函数组成的应用程序。对于这个例子，进入
    AWS 控制台并转到 AWS Lambda 产品页面。点击 *创建函数* 按钮，在出现的表单中输入以下值：
- en: '**Name**: `minimal-lambda`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: `minimal-lambda`'
- en: '**Runtime**: Choose Use custom runtime in function code or layer'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**: 在函数代码或层中选择使用自定义运行时'
- en: '**Role**: Choose Create a new role from one or more templates'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**: 选择从一个或多个模板创建新角色'
- en: '**Role name**: `minimal-lambda-role`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色名称**: `minimal-lambda-role`'
- en: 'This is what the form should look like when you''ve finished:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您完成表单后应该看起来像的样子：
- en: '![](img/de5fedcd-8b29-4790-aae4-85866bafd712.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de5fedcd-8b29-4790-aae4-85866bafd712.png)'
- en: 'Click the Create function button, and while the function is being created,
    pack the binary to the zip file using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建函数按钮，在函数创建过程中，使用以下命令将二进制打包到 zip 文件中：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the form that appears, choose *Upload a .zip file* in the *Code entry type*
    of the *Function code* section:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的表单中，选择在 *函数代码* 部分的 *代码输入类型* 中 *上传一个 .zip 文件*：
- en: '![](img/d9965478-fd90-4c67-a0c7-6ffe4599c0a3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9965478-fd90-4c67-a0c7-6ffe4599c0a3.png)'
- en: 'Choose the file and upload it using the form. When the archive with the Rust
    function is uploaded, the function is ready to be called. Click on the Test button,
    and you will see a form in which you can enter the testing request in JSON format:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 选择文件并使用表单上传它。当带有 Rust 函数的存档上传后，函数就准备好被调用了。点击测试按钮，您将看到一个表单，您可以在其中输入 JSON 格式的测试请求：
- en: '![](img/39db553d-f8e4-48ac-859c-8f4b2714986d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39db553d-f8e4-48ac-859c-8f4b2714986d.png)'
- en: 'Enter the following JSON in it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中输入以下 JSON：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a serialized `RngRequest` value that generates random a value in the range
    0-100 using uniform distribution. Enter `uniform` in the Event name field and
    click the *Create* button, and the testing prerequisites will be stored. Now you
    can choose this request in the drop-down list to the left of the *Test* button.
    Choose *uniform* value and click the *Test* button to see the result of the response:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个序列化的 `RngRequest` 值，它使用均匀分布生成0-100范围内的随机值。在事件名称字段中输入 `uniform` 并点击 *创建*
    按钮，测试前提条件将被存储。现在您可以在 *测试* 按钮左侧的下拉列表中选择此请求。选择 *uniform* 值并点击 *测试* 按钮以查看响应结果：
- en: '![](img/58dd8017-b4da-4479-ad57-1204f568ca71.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58dd8017-b4da-4479-ad57-1204f568ca71.png)'
- en: Our microservice generated a value. If you click the *Test* button again, it
    will generate the next value. As you can see, there are log records printed by
    the `simple_logger` crate in the *Log output* section. And the execution of this
    function takes about 20 milliseconds.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的微服务产生了一个值。如果您再次点击 *测试* 按钮，它将生成下一个值。如您所见，在 *日志输出* 部分打印了由 `simple_logger`
    crate 生成的日志记录。并且此函数的执行大约需要20毫秒。
- en: The main benefit of AWS Lambda is access to all other AWS services. Let's create
    a more complex example that utilizes more services in order to show how to integrate
    `lambda` functions with other AWS infrastructure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda的主要好处是访问所有其他AWS服务。让我们创建一个更复杂的示例，利用更多服务来展示如何将 `lambda` 函数与其他AWS基础设施集成。
- en: Serverless Framework
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Serverless Framework
- en: 'In this section, we will port a serverless application from the Wild Rydes
    Serverless Workshops to Rust: [https://github.com/aws-samples/aws-serverless-workshops](https://github.com/aws-samples/aws-serverless-workshops).
    The idea of this example to provide a service that emulates ordering a ride on
    a unicorn.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从Wild Rydes Serverless Workshops将无服务器应用程序移植到Rust：[https://github.com/aws-samples/aws-serverless-workshops](https://github.com/aws-samples/aws-serverless-workshops)。此示例的目的是提供一个模拟订购独角兽骑乘服务的服务。
- en: 'We will use the Serverless Framework, which provides a useful tool that simplifies
    the deployment of applications using a declaration of the resources and their
    relations. This section was inspired by an example of Serverless Framework usage
    created by Andrei Maksimov, which is located here: [https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito](https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito).
    Let''s prepare the environment to write and build an application using the Serverless
    Framework.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Serverless Framework，它提供了一个有用的工具，可以简化使用资源声明及其关系的应用程序部署。本节灵感来源于Andrei Maksimov创建的Serverless
    Framework使用示例，位于此处：[https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito](https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito)。让我们准备环境，以便使用Serverless
    Framework编写和构建应用程序。
- en: Preparation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备
- en: 'First, you need to install the Serverless Framework using `npm`, which is supplied
    with Node.js:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用 `npm` 安装Serverless Framework，它随Node.js提供：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I installed it globally because I want to use it to create a new project from
    a Rust template of an application with multiple lambdas:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我全局安装了它，因为我想要使用它从具有多个lambdas的应用程序Rust模板创建新项目：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This command downloads the template automatically and will use the name provided
    to construct a blank application. It prints the following to the console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会自动下载模板，并使用提供的名称构建一个空白应用程序。它会在控制台打印以下内容：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the project is initialized, enter a folder of this project and add the **`serverless-finch`**
    plugin, which we will use to upload the assets of our application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目初始化时，进入此项目的文件夹并添加 **`serverless-finch`** 插件，我们将使用它来上传我们应用程序的资产：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `serverless-aws-rust-multi` template is a workspace and contains two crates:
    `hello` and `world`. Let''s rename them `lambda_1` and `lambda_2`. I have used
    this template to show you how an application can include more than one crate.
    After renaming the folders, we also have to replace the `members` of a `workspace`
    in the `Cargo.toml` configuration of the project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverless-aws-rust-multi` 模板是一个工作区，包含两个crate：`hello` 和 `world`。让我们将它们重命名为
    `lambda_1` 和 `lambda_2`。我已经使用这个模板来向您展示一个应用程序如何包含多个crate。在重命名文件夹后，我们还需要在项目的 `Cargo.toml`
    配置中替换 `workspace` 的 `members`：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we can leave `lambda_2` without changes and implement the functionality
    of the Wild Rydes example in the `lambda_1` crate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以不对 `lambda_2` 进行更改，并在 `lambda_1` crate 中实现Wild Rydes示例的功能。
- en: Implementation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The original sources of the templates contain some code similar to the previous
    example, but we will write the code from scratch, and you have to remove the original
    `main.rs` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的原始源代码包含一些与上一个示例类似的代码，但我们将从头编写代码，你必须删除原始的`main.rs`文件。
- en: Dependencies
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'In the `lambda_1` crate''s folder, add the following dependencies to `Cargo.toml`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lambda_1` crate的文件夹中，将以下依赖项添加到`Cargo.toml`中：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you read the previous chapters, you will be familiar with all crates from
    the list, including `lambda_runtime`, which we used in the previous section of
    this chapter. Let''s look at the types in `src/main.rs` that we will use from
    this crate:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了前面的章节，你将熟悉列表中的所有crate，包括我们在本章前面的部分中使用的`lambda_runtime`。让我们看看`src/main.rs`中我们将从该crate使用的类型：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We used the preceding types to implement the following sequence of actions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的类型实现了以下一系列操作：
- en: Parsing the request
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析请求
- en: Finding (generating) a `Unicorn` instance that will be declared later
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到（生成）稍后将声明的`Unicorn`实例
- en: Adding a record to the `DynamoDb` table
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`DynamoDb`表添加记录
- en: 'Our `main` function only calls a handler function that performs these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数只调用一个执行这些步骤的处理器函数：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We also initialized the logger to have to read them with CloudWatch services.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还初始化了日志记录器，以便使用CloudWatch服务读取它们。
- en: Handler
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: 'The handler performs the same logic as the original example, but it is completely
    rewritten with Rust and the `lambda_runtime` crate. Look at the implementation
    of the `handler` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器执行与原始示例相同的逻辑，但它完全用Rust和`lambda_runtime` crate重写。看看`handler`函数的实现：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Initially, this function creates a connection to DynamoDB using the default
    `Region` value, which initially reads environment variables to get an actual value,
    and if it doesn't find a region, it uses the `us-east-1` region. Then, the `handler`
    extracts a username provided by `Cognito` that we will use to authorize users
    and won't implement user registration manually.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这个函数使用默认的`Region`值连接到DynamoDB，它最初读取环境变量以获取实际值，如果没有找到区域，则使用`us-east-1`区域。然后，`handler`提取由`Cognito`提供的用户名，我们将使用它来授权用户，而不会手动实现用户注册。
- en: Then we generate the unique ID of a ride and extract the body of a request that
    is provided by a JSON string. You can't declare a complete `Request` struct, you
    have to parse it with two steps. The first uses the `lambda!` macro, and the second
    uses the `serde_json::from_str` function call. Then, we call the `find_unicorn`
    function, which we will implement later, and add a record to a database using
    the `record_ride` function call, which we will implement later in this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成一次骑行的唯一ID，并从提供的JSON字符串中提取请求的主体。你不能声明一个完整的`Request`结构体，你必须分两步解析它。第一步使用`lambda!`宏，第二步使用`serde_json::from_str`函数调用。然后，我们调用我们稍后将实现的`find_unicorn`函数，并使用`record_ride`函数调用将记录添加到数据库中，该函数我们将在本节稍后实现。
- en: When the record is added, we construct a response in two steps. First, we create
    the body of a response, and then we wrap it with extra values. We have to do this
    wrapping because we will use API Gateway to call the lambda with an external application
    shared by `S3`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录被添加时，我们分两步构建响应。首先，我们创建响应的主体，然后将其包裹在额外的值中。我们必须这样做包裹，因为我们将会使用API网关通过`S3`共享的外部应用程序调用lambda。
- en: Now we can have a look at structs that we need.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看我们需要的结构体了。
- en: Request and response types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应类型
- en: 'The main struct is `Unicorn`, which contains the creature we will ride:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的结构体是`Unicorn`，它包含我们将要骑乘的生物：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Every `Unicorn` has a `name`, `color`, and `gender`. We will store these values
    as items in a DynamoDB record. To simplify the creation of the instance in the
    code, we will add the following constructor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Unicorn`都有一个`name`、`color`和`gender`。我们将把这些值作为DynamoDB记录中的条目存储。为了简化代码中实例的创建，我们将添加以下构造函数：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may ask why we don't represent color and gender with enumerations. It's
    possible, but you have to be sure that the serialized values are exactly what
    you want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我们不用枚举来表示颜色和性别。这是可能的，但你必须确保序列化的值正是你想要的。
- en: 'The `Location` struct represents a point on a map that will be set by the UI
    of the application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`结构体表示地图上的一个点，它将由应用程序的UI设置：'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can declare a `Request` struct that contains `body` and `request_context`
    fields, which we will use to get a username provided by `Cognito`. You may have
    noticed that the `Location` structs have different renaming rules than other structs.
    That''s because the `Request` struct was parsed by API Gateway, but `Location`
    and `RequestBody` will be created by the frontend application, which uses other
    identifiers. `Request` represents the body as a `String`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明一个包含`body`和`request_context`字段的`Request`结构体，我们将使用它来获取由`Cognito`提供的用户名。您可能已经注意到`Location`结构体与其他结构体有不同的重命名规则。这是因为`Request`结构体是由API网关解析的，而`Location`和`RequestBody`将由前端应用创建，该应用使用其他标识符。`Request`将`body`表示为一个`String`：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`RequestContext` is a map that is filled by the runtime, and we will parse
    it to a struct:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestContext`是一个由运行时填充的映射，我们将将其解析到一个结构体中：'
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need an `Authorizer` field that only contains `claims` values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个只包含`claims`值的`Authorizer`字段：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We used `claims` to get the `cognito:username` value in the `handler`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`handler`中使用`claims`来获取`cognito:username`值。
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can declare a `Response`. It is also used by API Gateway and has to
    contain `status_code` and `headers`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明一个`Response`。它也被API网关使用，必须包含`status_code`和`headers`：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `body` field is represented by a `String` type that we will deserialize
    separately to the `ResponseBody` struct:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`字段由一个`String`类型表示，我们将将其单独反序列化到`ResponseBody`结构体中：'
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding fields are necessary for frontend applications from the workshop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的字段对于工作坊的前端应用是必要的。
- en: Now we can add functions to generate the `Unicorn` instance and to add a record
    to a database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加生成`Unicorn`实例和向数据库添加记录的功能。
- en: Functions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'The `find_unicorn` function picks one of the three predefined values of `Unicorn`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_unicorn`函数从`Unicorn`的三个预定义值中选择一个：'
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `record_ride` function constructs put requests from DynamoDB. To make this
    kind of request, we need to fill a `HashMap` with attributes only. If you want
    to learn more about how to interact with DynamoDB, you can return to [Chapter
    7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable Integration with Databases,*
    in which we explored interaction with databases in detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`record_ride`函数从DynamoDB构建put请求。要执行此类请求，我们需要填充一个只包含属性的`HashMap`。如果您想了解更多关于如何与DynamoDB交互的信息，您可以回到第7章，*与数据库的可靠集成*，其中我们详细探讨了与数据库的交互。'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We also need a function to prepare `AttributeValues` used by the `rusoto_dynamodb`
    crate from the types that can be represented as references to a string value:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来准备由`rusoto_dynamodb` crate使用的`AttributeValues`，这些类型可以表示为字符串值的引用：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last function we need is to convert the fields of `Unicorn` into a map:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个函数是将`Unicorn`的字段转换为映射：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will see a stored value that uses this layout with AWS Console later in
    this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，您将在AWS控制台中看到使用此布局的存储值。
- en: Configuration
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'The Serverless Framework uses a `serverless.yml` configuration file to deploy
    lambdas to AWS. Since we installed the `serverless-rust` plugin (which comes with
    the Rust template), we can use it to set a runtime. Fill in the parameters of
    the service described:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework使用一个`serverless.yml`配置文件来部署Lambda到AWS。由于我们安装了`serverless-rust`插件（它包含在Rust模板中），我们可以使用它来设置运行时。填写所描述服务的参数：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following parameter takes more control for configuring functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数为配置函数提供了更多控制：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also have to activate two plugins: one for building Rust lambdas and another
    for uploading assets to `S3`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须激活两个插件：一个用于构建Rust Lambda，另一个用于将资产上传到`S3`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can declare our functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明我们的函数：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first function has the associated `RustSlsLambdaRole` role that we will
    declare later. We need it to get access to some resources. The lambda takes a
    post and supports CORS to be called from the frontend, which works in a browser.
    We have also associated an authorizer, and use `RustSlsApiGatewayAuthorizer`,
    which we will declare later.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数关联着我们将要声明的`RustSlsLambdaRole`角色。我们需要它来访问一些资源。Lambda函数接收一个帖子并支持CORS，可以从前端调用，这在浏览器中工作。我们还关联了一个授权者，并使用`RustSlsApiGatewayAuthorizer`，我们将在后面声明。
- en: Resources
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Add a resources section that contains `Resources` and `Outputs` maps to declare
    the necessary resources and output variables. Let''s add `Resources`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个包含`Resources`和`Outputs`映射的资源部分，以声明必要的资源和输出变量。让我们添加`Resources`：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add an `S3` bucket declaration, where we place all the assets and set `WebsiteConfiguration`
    to set the default index file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`S3`存储桶声明，我们将所有资产放置在这里，并将`WebsiteConfiguration`设置为设置默认索引文件：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also have to add a policy to allow these files to be read by an external
    client, such as a browser:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加一个策略，允许外部客户端（如浏览器）读取这些文件：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The Wild Rydes application is configured to use `Cognito` with a client to
    authorize users with their accounts. Let''s configure it with the following declaration
    and activate email confirmations:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Wild Rydes应用程序配置为使用`Cognito`客户端授权用户使用其账户。让我们使用以下声明进行配置并激活电子邮件确认：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable Integration
    with Databases,* we used a JSON declaration of a table. You can configure a `DynamoDB`
    table using the Serverless Framework as well:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml)，*与数据库的可靠集成*中，我们使用了表的JSON声明。您也可以使用Serverless
    Framework配置`DynamoDB`表：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a role for our `lambda_1` crate:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的`lambda_1`crate添加一个角色：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And add these policies to this role:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这些策略添加到该角色中：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have to provide write access to the `DynamoDB` table for this role.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为此角色提供对`DynamoDB`表的写访问权限。
- en: 'Create an `authorizer`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`authorizer`：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare the output variables:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 声明输出变量：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last section of this long config declares the folder that the `serverless-finch`
    plugin will use to upload:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此长配置的最后部分声明了`serverless-finch`插件将使用的文件夹来上传：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, I used `rust-sls-aws` as the bucket name, but every `S3` bucket
    needs a unique global name, and you have to replace the bucket name in all the
    configs to deploy it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我使用了`rust-sls-aws`作为存储桶名称，但每个`S3`存储桶都需要一个唯一的全局名称，并且您必须替换所有配置中的存储桶名称才能部署。
- en: Deployment
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deployment
- en: Everything is ready for deployment. You need a working AWS account to run this
    application. But let's start by creating a user with the necessary permissions
    to deploy the application using AWS CLI.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 部署准备工作已经完成。您需要一个有效的AWS账户来运行此应用程序。但让我们先创建一个用户，该用户具有使用AWS CLI部署应用程序所需的必要权限。
- en: Permissions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Permissions
- en: 'To deploy this application, you need to have configured the AWS CLI tool and
    a user with the following permissions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署此应用程序，您需要配置AWS CLI工具和一个具有以下权限的用户：
- en: AWSLambdaFullAccess
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWSLambdaFullAccess
- en: IAMFullAccess
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAMFullAccess
- en: AmazonDynamoDBFullAccess
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonDynamoDBFullAccess
- en: AmazonAPIGatewayAdministrator
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonAPIGatewayAdministrator
- en: AmazonCognitoPowerUser
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonCognitoPowerUser
- en: CloudFormationAdministrator
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormationAdministrator
- en: 'It is worth noting that the latter was created manually and can be added when
    configuring the user by adding a JSON definition to the policy:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，后者是手动创建的，可以在配置用户时通过向策略中添加JSON定义来添加：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When you have created a user with the necessary credentials, you can build and
    deploy the application using the Serverless Framework, which builds all the lambdas
    automatically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建了一个具有必要凭证的用户后，您可以使用Serverless Framework构建和部署应用程序，该框架会自动构建所有lambdas。
- en: Script
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Script
- en: 'We need some values that are not known before deployment. We will use the `sls
    info -v` command to get the actual values that we need to configure the frontend.
    Create a bash script to add the necessary deployment functions. First, we need
    an `extract` function to get the second column aster space delimited of `sls info`
    output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些在部署前不知道的值。我们将使用`sls info -v`命令获取我们需要配置前端的实际值。创建一个bash脚本来添加必要的部署功能。首先，我们需要一个`extract`函数来获取`sls
    info`输出的第二列空格分隔的值：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To deploy an application with the Serverless Framework, you have to call the `sls
    deploy` command, but our application is more complex and we have to use a sequence
    of commands:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Serverless Framework部署应用程序，您必须调用`sls deploy`命令，但我们的应用程序更复杂，我们必须使用一系列命令：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the `deploy` function we download the frontend part of the Wild Rydes application
    from GitHub and only extract the folder we need to the `assets` folder of our
    project. Then we call `sls deploy` to deploy a stack of the application. Then
    we call `sls client deploy` to publish all assets to `S3`. When all parts are
    deployed we use the `extract` function to get all the necessary values to fill
    the `config.js` file, which is necessary to connect the deployed frontend with
    our lambda implemented with Rust. We construct a `config.js` file from the embedded
    template and upload it with the `aws s3 cp` command.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `deploy` 函数中，我们从 GitHub 下载 Wild Rydes 应用程序的前端部分，并将其所需文件夹提取到我们项目的 `assets`
    文件夹中。然后我们调用 `sls deploy` 来部署应用程序的堆栈。然后我们调用 `sls client deploy` 将所有资产发布到 `S3`。当所有部分都部署完毕后，我们使用
    `extract` 函数获取所有必要的值以填充 `config.js` 文件，这是连接已部署的前端与我们的 Rust 实现的 lambda 所必需的。我们使用嵌入式模板构建一个
    `config.js` 文件，并使用 `aws s3 cp` 命令上传它。
- en: Let's run this command.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个命令。
- en: Running
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'If you have downloaded the sources of the project for this chapter from GitHub,
    you can use the `deploy.sh` script to call the function we implemented previously.
    Provide the name of the `deploy` function to call it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从 GitHub 下载了本章项目的源代码，你可以使用 `deploy.sh` 脚本来调用我们之前实现的函数。提供要调用的 `deploy` 函数的名称：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It will start the building and deployment process with the Serverless Framework
    and will print something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用 Serverless Framework 开始构建和部署过程，并打印出类似以下内容：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The deployment takes time, and when it is finished the second command, `sls
    client deploy`, will be called to upload the assets folder with the `serverless-finch`
    plugin, and it prints the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 部署需要时间，完成后，将调用第二个命令 `sls client deploy`，使用 `serverless-finch` 插件上传 `assets`
    文件夹，并打印以下内容：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The script printed the link that we can use to connect to and test the application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本打印出了我们可以用来连接和测试应用的链接。
- en: Testing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Open the provided URL in a browser, and you will see the frontend Wild Rydes
    app.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开提供的 URL，你将看到 Wild Rydes 前端应用程序。
- en: Users have to click the GIDDY UP! button and register an account using `Cognito`,
    which is actually used in the background, and users don't need to interact directly
    with that service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须点击 *GIDDY UP!* 按钮，并使用 `Cognito` 注册账户，实际上这个服务是在后台使用的，用户不需要直接与该服务交互。
- en: 'You will see the cute UI. Click on the map and click the *Set Pickup* button,
    and you will see how the head of a unicorn moves to the point you set:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到可爱的用户界面。点击地图并点击 *设置取货* 按钮，你将看到独角兽的头如何移动到你设置的位置：
- en: '![](img/33b5290a-8241-4acf-b0ea-cff979995aeb.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33b5290a-8241-4acf-b0ea-cff979995aeb.png)'
- en: 'The name and the color of unicorn is generated by our `lambda` function that
    was created with Rust. If you open some pages of AWS Console you can see that
    there is a registered user on the *Users and groups* page of the *User Pools*
    section:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 独角兽的名称和颜色是由我们用 Rust 创建的 `lambda` 函数生成的。如果你打开 AWS 控制台的一些页面，你可以在 *用户池* 部分的 *用户和组*
    页面上看到一个注册的用户：
- en: '![](img/685ef40a-da5b-4092-bd5c-9ab2738814b2.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/685ef40a-da5b-4092-bd5c-9ab2738814b2.png)'
- en: 'We have two deployed lambdas, but actually the application only uses the first,
    which is called `rust-sls-dev-lambda_1`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部署了两个 lambda，但实际上应用程序只使用了第一个，称为 `rust-sls-dev-lambda_1`：
- en: '![](img/f0c392c6-1c8f-40f4-9154-8311801837c6.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0c392c6-1c8f-40f4-9154-8311801837c6.png)'
- en: 'If you enter the lambda''s page, click on the Monitoring tab, and open `CloudWatch`
    logs of the lambda, you can see the lambda generated a username and, is stored
    in the location we set:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入 lambda 的页面，点击 监控 标签，并打开 lambda 的 CloudWatch 日志，你可以看到 lambda 生成了一个用户名，并存储在我们设置的位置：
- en: '![](img/a6e64cbe-9197-4616-ba68-a001cad0af5c.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6e64cbe-9197-4616-ba68-a001cad0af5c.png)'
- en: 'The lambda also stored a record in DynamoDB, and you can also  find it on the *Tables*
    page of the DynamoDB section:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 还在 DynamoDB 中存储了一个记录，你也可以在 DynamoDB 部分的 *表格* 页面上找到它：
- en: '![](img/6da41e95-f05a-407f-8292-4690ce0abd40.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6da41e95-f05a-407f-8292-4690ce0abd40.png)'
- en: 'You can see the record that the lambda added. And if you click on the record,
    you will see the all the fields we populated with the `record_ride` function earlier:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 lambda 添加的记录。如果你点击记录，你将看到我们之前使用 `record_ride` 函数填充的所有字段：
- en: '![](img/9d7976d8-9b11-46c7-aba3-c64136a42344.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d7976d8-9b11-46c7-aba3-c64136a42344.png)'
- en: The application has been successfully ported to Rust, and it works as expected.
    Let's look at how we can clean up the resources we've used.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已成功移植到 Rust，并且按预期工作。让我们看看我们如何清理我们使用的资源。
- en: Updating and removing
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新和删除
- en: 'The Serverless Framework also provides the ability to update resources automatically
    if you call `sls deploy` again. We can add this as a function to the deployment
    bash script:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次调用`sls deploy`，Serverless Framework还提供了自动更新资源的能力。我们可以将此作为函数添加到部署bash脚本中：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This command is useful if you want to update the code of some of the lambdas,
    but don't want to leave the session maintained by `Cognito`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更新一些Lambda的代码，但又不想离开由`Cognito`维护的会话，这个命令很有用。
- en: 'To remove everything we deployed, we can use the following function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除我们部署的所有内容，我们可以使用以下函数：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It works because the Serverless Framework supports removing declared resources.
    I recommend you clean up everything after experimenting, because AWS will produce
    bills for services even if you don't use this demo.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以有效，是因为Serverless Framework支持移除声明的资源。我建议你在实验后清理所有内容，因为即使你不使用这个演示，AWS也会为服务产生账单。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied an alternative approach to microservice implementation—serverless
    architecture. This approach involves direct usage of functions that handle incoming
    requests. There are many providers of serverless infrastructure, and we used the popular
    AWS platform to port a serverless application to Rust.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究了微服务实现的一种替代方法——无服务器架构。这种方法涉及直接使用处理传入请求的函数。有许多无服务器基础设施的提供商，我们使用了流行的AWS平台将无服务器应用程序移植到Rust。
