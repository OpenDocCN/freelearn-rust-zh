- en: Bounded Microservices with AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Last chapter we learned how to create serverless applications using AWS
    Lambda and the official `lambda-runtime` crate. It is useful for developers who
    use **Amazon Web Services** (**AWS**) and who especially want to use AWS Lambda.
    It differs from the approach where we created a standalone web server, because
    AWS Lambda stores, scales, and runs automatically, and the only thing we should
    provide is the compiled code of a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the AWS Lambda Rust runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a microservice to AWS using the Serverless Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the techniques from this chapter, you need a configured Docker instance,
    because AWS uses Amazon Linux AMI distribution to run lambdas, and we need the
    special environment to compile Rust code for that environment. You also need an
    account in AWS. Create one if you don''t have one. AWS provides a free trial period
    called Free Tier, which includes 1 million requests to AWS Lambda per month over
    the course of one year. You can read more about this trial period here: [https://aws.amazon.com/free/.](https://aws.amazon.com/free/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also know how to use AWS Console. There will be some examples of
    using it in this chapter, but for production you have to know all its features,
    including using access controls to prevent malicious penetration to your microservice.
    You can read about AWS in a book called *Learning AWS*: [https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition](https://www.packtpub.com/virtualization-and-cloud/learning-aws-second-edition).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create two examples of a serverless application. The
    first requires the Rust compiler 1.31 version or above and the `musl` library,
    and the second needs npm and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find sources of all examples of this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter17/)'
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, in this book we have created microservices as standalone
    server applications. To deploy them you have to upload binaries to remote servers
    using continuous delivery tools. If you don't want to worry about making the binaries
    compatible with operating systems, you can use containers to deliver and deploy
    applications packed to images. It gives you the opportunity to use container orchestration
    services, such as Kubernetes. Container orchestration software simplifies scaling
    and configuring large applications that use containers to run microservices. If
    you try to think about this simplification further, you can find it helpful to
    use a predefined and preinstalled pool of containers with generic environment
    that will run small binaries with request-handling functions and without any HTTP
    middleware. In other words, you could write handlers for events and no more HTTP
    code. This approach is called serverless.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we list the platforms that provide serverless infrastructure
    and that can be used to deploy serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Lambda is an Amazon product that you can find here: [https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is official support for the Rust programming language with the `lambda-runtime`
    crate: [https://github.com/awslabs/aws-lambda-rust-runtime](https://github.com/awslabs/aws-lambda-rust-runtime).
    We will use this crate in this chapter to demonstrate the serverless approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Functions is the serverless product of Microsoft, and is part of the Azure
    platform: [https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)[.](https://azure.microsoft.com/en-us/services/functions/)'
  prefs: []
  type: TYPE_NORMAL
- en: There is no official Rust support at the moment, but you can use the `azure-functions`
    crate, which uses the internal worker protocol of Azure Functions based on GRPC
    to interact between the host and the language worker.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudflare Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloudflare offers its own serverless product called Cloudflare Workers: [https://www.cloudflare.com/products/cloudflare-workers/](https://www.cloudflare.com/products/cloudflare-workers/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This service is compatible with Rust because Cloudflare Workers implemented
    an awesome idea: **workers compiled to WebAssebly** (**WASM**). Since Rust has
    good support for WASM, you can easily use it to produce serverless workers for
    Cloudflare.'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IBM provides its own serverless product based on Apache OpenWhisk: [https://console.bluemix.net/openwhisk/](https://console.bluemix.net/openwhisk/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can write serverless functions using Rust, because the platform supports
    functions provided as Docker images and you can create a Docker image with your
    Rust functions.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Cloud Functions is a product of Google provided as a part of Google
    Cloud: [https://cloud.google.com/functions/](https://cloud.google.com/functions/).'
  prefs: []
  type: TYPE_NORMAL
- en: There is no support for Rust. Potentially, you can write native modules for
    Python environments using Rust and try to start them using Python code, but I
    can't find confirmation that this approach will work. In any case, I'm sure there
    will be an opportunity in the future to run Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal Rust microservices for AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a microservice that works in a serverless environment
    using AWS Lambda. We will reimplement the random number generator from [Chapter
    4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data Serialization and Deserialization
    with Serde Crate,* in the *Data format for interaction with microservices* section.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create a new `minimal-lambda` crate and add the following
    dependencies to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main dependency we need is `lambda_runtime`, which is an official crate
    for writing `lambda` functions for AWS Lambda platform using Rust. We used a version
    from GitHub because, at the time of writing, this crate was in active development.
  prefs: []
  type: TYPE_NORMAL
- en: AWS prints the output of all the `lambda` functions as logs, and we will use
    the `simple_logger` crate, which prints all logs to *stdout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to override the name of a binary with lambda, because an environment
    that run, AWS Lambda expects to find a binary called `bootstrap` that implements
    the `lambda` function. Let''s rename the binary produced by our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's enough to start writing a minimal microservice for a serverless environment.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need the following types in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It make sense to look at imports from the `lambda_runtime` crate. The `lambda`
    macro is used to export a handler from a binary, which will be used by the AWS
    Lambda runtime. `Context` is a required parameter of a handler, and we also have 
     imported `HandlerError` to use in the returning `Result` value of a handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can write a main function that initializes `simple_logger` and wraps
    `rng_handler`, which we will implement in the following code, to export the handler
    of a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`rng_handler` is a function that expects a request and returns a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation, we used a generator from the example in [Chapter 4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data
    Serialization and Deserialization with the Serde Crate,* in the *Data format for
    interaction with microservices* section, and also borrowed a request type that
    has to be deserializable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding request type is an enumeration that has three variants that let
    a client choose one of three probability distributions to generate a random value.
    We also need a type to return responses with random values. We will also borrow
    it from the preceding code. Look at the struct we will use for responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, this lambda function expects an `RngRequest` value in JSON format as a
    request that will be deserialized automatically, and a `RngResponse` result that
    will be serialized to JSON and returned to a client. Let's build this code and
    check how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a lambda function, we need to produce a binary that is compatible
    with Amazon Linux. You can use three methods to build a corresponding binary:'
  prefs: []
  type: TYPE_NORMAL
- en: Build it with a Linux distribution (compatible with x86_64).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build it in a Docker container of Amazon Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build it with the `musl` standard C library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the latter method, because it minimizes the external dependencies
    of the produced binary. First, you have to install the `musl` library, which you
    can get here: [https://www.musl-libc.org/](https://www.musl-libc.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I did this with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But if there is a package for your operating system, you should to install that
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the code with the `musl` library we have to use `x86_64-unknown-linux-musl` as
    the target value. But we can set this target as the default for this project with
    a configuration file for cargo. Add a `.cargo/config` file to the project''s folder
    and add the following configuration to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the compiler supports `musl` or add it using `rustup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now you can simply build the lambda using the `cargo build` command. That produces
    a binary that's compiled with the `musl` library that we can upload to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can deploy lambda to AWS using two tools:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS CLI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web AWS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first is a little tedious, and in the next section of this chapter, you
    will see how to use the Serverless Framework to deploy an application consists
    of `lambda` functions. For this example, enter the AWS Console and go to the AWS
    Lambda product page. Click the *Create Function* button and, in the form that
    appears, enter the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: `minimal-lambda`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: Choose Use custom runtime in function code or layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role**: Choose Create a new role from one or more templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role name**: `minimal-lambda-role`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what the form should look like when you''ve finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de5fedcd-8b29-4790-aae4-85866bafd712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Create function button, and while the function is being created,
    pack the binary to the zip file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the form that appears, choose *Upload a .zip file* in the *Code entry type*
    of the *Function code* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9965478-fd90-4c67-a0c7-6ffe4599c0a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose the file and upload it using the form. When the archive with the Rust
    function is uploaded, the function is ready to be called. Click on the Test button,
    and you will see a form in which you can enter the testing request in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39db553d-f8e4-48ac-859c-8f4b2714986d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the following JSON in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a serialized `RngRequest` value that generates random a value in the range
    0-100 using uniform distribution. Enter `uniform` in the Event name field and
    click the *Create* button, and the testing prerequisites will be stored. Now you
    can choose this request in the drop-down list to the left of the *Test* button.
    Choose *uniform* value and click the *Test* button to see the result of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58dd8017-b4da-4479-ad57-1204f568ca71.png)'
  prefs: []
  type: TYPE_IMG
- en: Our microservice generated a value. If you click the *Test* button again, it
    will generate the next value. As you can see, there are log records printed by
    the `simple_logger` crate in the *Log output* section. And the execution of this
    function takes about 20 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of AWS Lambda is access to all other AWS services. Let's create
    a more complex example that utilizes more services in order to show how to integrate
    `lambda` functions with other AWS infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will port a serverless application from the Wild Rydes
    Serverless Workshops to Rust: [https://github.com/aws-samples/aws-serverless-workshops](https://github.com/aws-samples/aws-serverless-workshops).
    The idea of this example to provide a service that emulates ordering a ride on
    a unicorn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Serverless Framework, which provides a useful tool that simplifies
    the deployment of applications using a declaration of the resources and their
    relations. This section was inspired by an example of Serverless Framework usage
    created by Andrei Maksimov, which is located here: [https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito](https://github.com/andreivmaksimov/serverless-framework-aws-lambda-amazon-api-gateway-s3-dynamodb-and-cognito).
    Let''s prepare the environment to write and build an application using the Serverless
    Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to install the Serverless Framework using `npm`, which is supplied
    with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I installed it globally because I want to use it to create a new project from
    a Rust template of an application with multiple lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This command downloads the template automatically and will use the name provided
    to construct a blank application. It prints the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the project is initialized, enter a folder of this project and add the **`serverless-finch`**
    plugin, which we will use to upload the assets of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `serverless-aws-rust-multi` template is a workspace and contains two crates:
    `hello` and `world`. Let''s rename them `lambda_1` and `lambda_2`. I have used
    this template to show you how an application can include more than one crate.
    After renaming the folders, we also have to replace the `members` of a `workspace`
    in the `Cargo.toml` configuration of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now we can leave `lambda_2` without changes and implement the functionality
    of the Wild Rydes example in the `lambda_1` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The original sources of the templates contain some code similar to the previous
    example, but we will write the code from scratch, and you have to remove the original
    `main.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `lambda_1` crate''s folder, add the following dependencies to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read the previous chapters, you will be familiar with all crates from
    the list, including `lambda_runtime`, which we used in the previous section of
    this chapter. Let''s look at the types in `src/main.rs` that we will use from
    this crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the preceding types to implement the following sequence of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding (generating) a `Unicorn` instance that will be declared later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a record to the `DynamoDb` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `main` function only calls a handler function that performs these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We also initialized the logger to have to read them with CloudWatch services.
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The handler performs the same logic as the original example, but it is completely
    rewritten with Rust and the `lambda_runtime` crate. Look at the implementation
    of the `handler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Initially, this function creates a connection to DynamoDB using the default
    `Region` value, which initially reads environment variables to get an actual value,
    and if it doesn't find a region, it uses the `us-east-1` region. Then, the `handler`
    extracts a username provided by `Cognito` that we will use to authorize users
    and won't implement user registration manually.
  prefs: []
  type: TYPE_NORMAL
- en: Then we generate the unique ID of a ride and extract the body of a request that
    is provided by a JSON string. You can't declare a complete `Request` struct, you
    have to parse it with two steps. The first uses the `lambda!` macro, and the second
    uses the `serde_json::from_str` function call. Then, we call the `find_unicorn`
    function, which we will implement later, and add a record to a database using
    the `record_ride` function call, which we will implement later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: When the record is added, we construct a response in two steps. First, we create
    the body of a response, and then we wrap it with extra values. We have to do this
    wrapping because we will use API Gateway to call the lambda with an external application
    shared by `S3`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can have a look at structs that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Request and response types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main struct is `Unicorn`, which contains the creature we will ride:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `Unicorn` has a `name`, `color`, and `gender`. We will store these values
    as items in a DynamoDB record. To simplify the creation of the instance in the
    code, we will add the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You may ask why we don't represent color and gender with enumerations. It's
    possible, but you have to be sure that the serialized values are exactly what
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Location` struct represents a point on a map that will be set by the UI
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare a `Request` struct that contains `body` and `request_context`
    fields, which we will use to get a username provided by `Cognito`. You may have
    noticed that the `Location` structs have different renaming rules than other structs.
    That''s because the `Request` struct was parsed by API Gateway, but `Location`
    and `RequestBody` will be created by the frontend application, which uses other
    identifiers. `Request` represents the body as a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`RequestContext` is a map that is filled by the runtime, and we will parse
    it to a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need an `Authorizer` field that only contains `claims` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We used `claims` to get the `cognito:username` value in the `handler`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare a `Response`. It is also used by API Gateway and has to
    contain `status_code` and `headers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `body` field is represented by a `String` type that we will deserialize
    separately to the `ResponseBody` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding fields are necessary for frontend applications from the workshop.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add functions to generate the `Unicorn` instance and to add a record
    to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find_unicorn` function picks one of the three predefined values of `Unicorn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `record_ride` function constructs put requests from DynamoDB. To make this
    kind of request, we need to fill a `HashMap` with attributes only. If you want
    to learn more about how to interact with DynamoDB, you can return to [Chapter
    7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable Integration with Databases,*
    in which we explored interaction with databases in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function to prepare `AttributeValues` used by the `rusoto_dynamodb`
    crate from the types that can be represented as references to a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function we need is to convert the fields of `Unicorn` into a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You will see a stored value that uses this layout with AWS Console later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Serverless Framework uses a `serverless.yml` configuration file to deploy
    lambdas to AWS. Since we installed the `serverless-rust` plugin (which comes with
    the Rust template), we can use it to set a runtime. Fill in the parameters of
    the service described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parameter takes more control for configuring functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to activate two plugins: one for building Rust lambdas and another
    for uploading assets to `S3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare our functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first function has the associated `RustSlsLambdaRole` role that we will
    declare later. We need it to get access to some resources. The lambda takes a
    post and supports CORS to be called from the frontend, which works in a browser.
    We have also associated an authorizer, and use `RustSlsApiGatewayAuthorizer`,
    which we will declare later.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a resources section that contains `Resources` and `Outputs` maps to declare
    the necessary resources and output variables. Let''s add `Resources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `S3` bucket declaration, where we place all the assets and set `WebsiteConfiguration`
    to set the default index file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to add a policy to allow these files to be read by an external
    client, such as a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The Wild Rydes application is configured to use `Cognito` with a client to
    authorize users with their accounts. Let''s configure it with the following declaration
    and activate email confirmations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml), *Reliable Integration
    with Databases,* we used a JSON declaration of a table. You can configure a `DynamoDB`
    table using the Serverless Framework as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a role for our `lambda_1` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And add these policies to this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have to provide write access to the `DynamoDB` table for this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `authorizer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the output variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last section of this long config declares the folder that the `serverless-finch`
    plugin will use to upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I used `rust-sls-aws` as the bucket name, but every `S3` bucket
    needs a unique global name, and you have to replace the bucket name in all the
    configs to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything is ready for deployment. You need a working AWS account to run this
    application. But let's start by creating a user with the necessary permissions
    to deploy the application using AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy this application, you need to have configured the AWS CLI tool and
    a user with the following permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: AWSLambdaFullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAMFullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonDynamoDBFullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonAPIGatewayAdministrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonCognitoPowerUser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormationAdministrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is worth noting that the latter was created manually and can be added when
    configuring the user by adding a JSON definition to the policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When you have created a user with the necessary credentials, you can build and
    deploy the application using the Serverless Framework, which builds all the lambdas
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need some values that are not known before deployment. We will use the `sls
    info -v` command to get the actual values that we need to configure the frontend.
    Create a bash script to add the necessary deployment functions. First, we need
    an `extract` function to get the second column aster space delimited of `sls info`
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy an application with the Serverless Framework, you have to call the `sls
    deploy` command, but our application is more complex and we have to use a sequence
    of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the `deploy` function we download the frontend part of the Wild Rydes application
    from GitHub and only extract the folder we need to the `assets` folder of our
    project. Then we call `sls deploy` to deploy a stack of the application. Then
    we call `sls client deploy` to publish all assets to `S3`. When all parts are
    deployed we use the `extract` function to get all the necessary values to fill
    the `config.js` file, which is necessary to connect the deployed frontend with
    our lambda implemented with Rust. We construct a `config.js` file from the embedded
    template and upload it with the `aws s3 cp` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run this command.
  prefs: []
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have downloaded the sources of the project for this chapter from GitHub,
    you can use the `deploy.sh` script to call the function we implemented previously.
    Provide the name of the `deploy` function to call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It will start the building and deployment process with the Serverless Framework
    and will print something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment takes time, and when it is finished the second command, `sls
    client deploy`, will be called to upload the assets folder with the `serverless-finch`
    plugin, and it prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The script printed the link that we can use to connect to and test the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the provided URL in a browser, and you will see the frontend Wild Rydes
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Users have to click the GIDDY UP! button and register an account using `Cognito`,
    which is actually used in the background, and users don't need to interact directly
    with that service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the cute UI. Click on the map and click the *Set Pickup* button,
    and you will see how the head of a unicorn moves to the point you set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33b5290a-8241-4acf-b0ea-cff979995aeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The name and the color of unicorn is generated by our `lambda` function that
    was created with Rust. If you open some pages of AWS Console you can see that
    there is a registered user on the *Users and groups* page of the *User Pools*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/685ef40a-da5b-4092-bd5c-9ab2738814b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have two deployed lambdas, but actually the application only uses the first,
    which is called `rust-sls-dev-lambda_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0c392c6-1c8f-40f4-9154-8311801837c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you enter the lambda''s page, click on the Monitoring tab, and open `CloudWatch`
    logs of the lambda, you can see the lambda generated a username and, is stored
    in the location we set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6e64cbe-9197-4616-ba68-a001cad0af5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The lambda also stored a record in DynamoDB, and you can also  find it on the *Tables*
    page of the DynamoDB section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da41e95-f05a-407f-8292-4690ce0abd40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the record that the lambda added. And if you click on the record,
    you will see the all the fields we populated with the `record_ride` function earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d7976d8-9b11-46c7-aba3-c64136a42344.png)'
  prefs: []
  type: TYPE_IMG
- en: The application has been successfully ported to Rust, and it works as expected.
    Let's look at how we can clean up the resources we've used.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and removing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Serverless Framework also provides the ability to update resources automatically
    if you call `sls deploy` again. We can add this as a function to the deployment
    bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This command is useful if you want to update the code of some of the lambdas,
    but don't want to leave the session maintained by `Cognito`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove everything we deployed, we can use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It works because the Serverless Framework supports removing declared resources.
    I recommend you clean up everything after experimenting, because AWS will produce
    bills for services even if you don't use this demo.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied an alternative approach to microservice implementation—serverless
    architecture. This approach involves direct usage of functions that handle incoming
    requests. There are many providers of serverless infrastructure, and we used the popular
    AWS platform to port a serverless application to Rust.
  prefs: []
  type: TYPE_NORMAL
