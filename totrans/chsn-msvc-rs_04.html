<html><head></head><body>
        

                            
                    <h1 class="header-title">Data Serialization and Deserialization with the Serde Crate</h1>
                
            
            
                
<p>Microservices can either interact with clients or each other. To implement interaction, you have to choose a protocol and a format to send messages from one communication participant to another. There are many formats and RPC frameworks that simplify the interaction process. In this chapter, we'll discover features of the <kbd>serde</kbd> crate, which helps you to make structs serializable and deserializable and compatible with different formats, such as JSON, CBOR, MessagePack, and BSON.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How to serialize and deserialize data</li>
<li>How to make custom types types serializable</li>
<li>Which serialization formats to choose and which to avoid</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">In this chapter, we'll explore some of the features that are available in the <kbd>serde</kbd> crates family. This family includes the inseparable pair – the <kbd>serde</kbd> and <kbd>serde_derive</kbd> crates. It also includes crates such as <kbd>serde_json</kbd>, <kbd>serde_yaml</kbd>, and <kbd>toml</kbd> that provide you support for special formats, such as JSON, YAML, and <strong><kbd>TOML</kbd></strong>. All of these crates are pure Rust and don't require any external dependencies.</p>
<p>You can get the source code of the examples in this chapter from GitHub at: <a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04">https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter04</a><a href="https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust-2018/tree/master/Chapter4">.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data formats for interaction with microservices</h1>
                
            
            
                
<p>Microservices can interact with different participants, such as clients, other microservices, and third-party APIs. Typically, interactions are performed by the network using serialized data messages in a certain format. In this section, we'll learn how to choose a format for these interactions. We'll also explore the basic features of a <kbd>serde</kbd> crate – how to make our structs serializable and use a specific format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The serde crate</h1>
                
            
            
                
<p>When I started to use Rust in my projects, I used to use the popular <kbd>rustc_serialize</kbd> crate. This wasn't bad, but I found that it wasn't flexible enough. For example, I couldn't use generic data types in my own structs. The <kbd>serde</kbd> crate was created to eliminate the shortcomings of the <kbd>rustc_serialize</kbd><strong> </strong>crate. <kbd>serde</kbd> has been the main crate for serialization and deserialization in Rust since the <kbd>serde</kbd> crate reached the 1.0 release branch.</p>
<p>We used this crate in the previous chapter to deserialize a configuration file. We're now going to use it to transform request and response data to text or binary data.</p>
<p>To explore serialization, we'll use a microservice that generates random numbers. We'll rewrite a very simple version without logging, reading arguments, environment variables, or configuration files. It will use the HTTP body to specify a range of random values and a random distribution to generate a number from.</p>
<p>Our service will handle requests for the <kbd>/random</kbd> path only. It will expect both a request and a response in JSON format. As mentioned, the <kbd>serde</kbd> crate provides serialization capabilities to the code. We also need the <kbd>serde_derive</kbd> crate to derive the serialization method automatically. The <kbd>serde</kbd> crate contains only core types and traits to make the serialization process universal and reusable, but specific formats are implemented in other crates. We'll use <kbd>serde_json</kbd>, which provides a <kbd>serializer</kbd> in JSON format.</p>
<p>Copy the code of the minimal random-number-generating service and add these dependencies to <kbd>Cargo.toml</kbd>:</p>
<pre>[dependencies]<br/>futures = "0.1"<br/>hyper = "0.12"<br/>rand = "0.5"<br/>serde = "1.0"<br/>serde_derive = "1.0"<br/>serde_json = "1.0"</pre>
<p>Import these crates into the <kbd>main.rs</kbd> source file:</p>
<pre>extern crate futures;<br/>extern crate hyper;<br/>extern crate rand;<br/>#[macro_use]<br/>extern crate serde_derive;<br/>extern crate serde_json;</pre>
<p>As you can see, we imported a macro from the <kbd>serde_derive</kbd> and <kbd>serde_json</kbd> crates to use a JSON <kbd>serializer</kbd>. We don't import the <kbd>serde</kbd> crate, because we won't use it directly, but it's necessary to use the macro. We can now look at the different parts of the code. At first, we'll examine the request and response types. After that, we'll implement a handler to use it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Serializing responses</h1>
                
            
            
                
<p>The service returns random numbers represented as the <kbd>f64</kbd> type. We want to return it packed to a JSON object, because we may need to add more fields to the object. It's simple to use objects in JavaScript. Declare the <kbd>RngResponse</kbd> struct and add the <kbd>#[derive(Serailize)]</kbd> attribute. This makes this struct serializable, as follows:</p>
<pre>#[derive(Serialize)]<br/>struct RngResponse {<br/>    value: f64,<br/>}</pre>
<p>To make this struct deserializable, we should derive the <kbd>Deserialize</kbd> trait. Deserialization may be useful it you want to use the same type for requests and responses. It's also important to derive both <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> if you want to use the same type in a server and a client.</p>
<p>The serialized object will be represented as a string, as follows:</p>
<pre>{ "value": 0.123456 }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deserializing requests</h1>
                
            
            
                
<p>The service will support complex requests in which you can specify a distribution and parameters. Let's add this enumeration to the source file:</p>
<pre>#[derive(Deserialize)]<br/>enum RngRequest {<br/>    Uniform {<br/>        range: Range&lt;i32&gt;,<br/>    },<br/>    Normal {<br/>        mean: f64,<br/>        std_dev: f64,<br/>    },<br/>    Bernoulli {<br/>        p: f64,<br/>    },<br/>}</pre>
<p>You may want to know what the serialized value looks like. <kbd>serde_derive</kbd> provides extra attributes, which you can use to tweak the serialization format. The current <kbd>deserializer</kbd> expects a <kbd>RngRequest</kbd> instance, as follows:</p>
<pre>RngRequest::Uniform {<br/>        range: 1..10,<br/>}</pre>
<p>This will be represented as the string:</p>
<pre>{ "Uniform": { "range": { "start": 1, "end": 10 } } }</pre>
<p>If you create your own protocol from scratch, there won't be any problems with the layout, because you can easily make it conform to any restrictions specified by serializers that are automatically generated by the <kbd>serde</kbd> crate. If you have to use an existing protocol, however, you can try to add extra attributes to a declaration. If this doesn't help, you can implement the <kbd>Serialize</kbd> or <kbd>Deserialize</kbd> traits manually. For example, let's say we want to use the following request format:</p>
<pre>{ "distribution": "uniform", "parameters": { "start": 1, "end": 10 } } }</pre>
<p>Add the <kbd>serde</kbd> attributes to the <kbd>RngRequest</kbd> declaration, which transform the <kbd>deserializer</kbd> to support the preceding format. The code will look as follows:</p>
<pre>#[derive(Deserialize)]<br/>#[serde(tag = "distribution", content = "parameters", rename_all = "lowercase")]<br/>enum RngRequest {<br/>    Uniform {<br/>        #[serde(flatten)]<br/>        range: Range&lt;i32&gt;,<br/>    },<br/>    Normal {<br/>        mean: f64,<br/>        std_dev: f64,<br/>    },<br/>    Bernoulli {<br/>        p: f64,<br/>    },<br/>}</pre>
<p>Now, the enumeration uses the aforementioned request format. There are a lot of attributes in the <kbd>serde_derive</kbd> crate and it's important to explore them in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tweaking serialization</h1>
                
            
            
                
<p><kbd>serde_derive</kbd> supports a lot of attributes that help you to avoid manual implementations of the <kbd>serializer</kbd> or <kbd>deserializer</kbd> for the struct. In this section, we take a look at useful attributes in detail. We'll learn how to change the letter case of variants, how to remove a level of nesting, and how to use specific names for a tag and for a content of an enumeration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the case of names</h1>
                
            
            
                
<p><kbd>serde_derive</kbd> maps names of fields in the code to fields of data. For example, the <kbd>title</kbd> field of a struct will expect the <kbd>title</kbd> field of a data object. If the protocol uses other names for fields, you have to take this into account to avoid warnings. For example, a struct in a protocol might contain the <kbd>stdDev</kbd> field, but if you use the name of this field in Rust, you get the following warning:</p>
<pre>warning: variable `stdDev` should have a snake case name such as `std_dev`</pre>
<p>You can fix this adding the <kbd>#![allow(non_snake_case)]</kbd> attribute, but this makes the code unsightly. A better solution is to use the <kbd>#[serde(rename="stdDev")]</kbd> attribute and use the other naming convention for serialization and deserialization only.</p>
<p>There are two variants of renaming attributes:</p>
<ul>
<li>Changing the naming convention for all variants</li>
<li>Changing the name of a field</li>
</ul>
<p>To change all variants of an enumeration, add the <kbd>#[serde(rename_all="...")]</kbd> attribute with one of the following values: <kbd>"lowercase"</kbd>, <kbd>"PascalCase"</kbd>, <kbd>"camelCase"</kbd>, <kbd>"snake_case"</kbd>, <kbd>"SCREAMING_SNAKE_CASE"</kbd>, or <kbd>"kebab-case"</kbd>. To be more representative, naming values are written according to the rules of their own convention.</p>
<p>To change the name of a field, use the <kbd>#[serde(rename="...")]</kbd> attribute with the name of the field used in the serialization process. You can see an example of the usage of this attribute in <a href="2dceb3bc-2f03-47d9-88cd-561b4f0b50d7.xhtml">Chapter 17</a>, <em>Bounded Microservices with AWS Lambda</em>.</p>
<p>Another reason to use renaming is when the names of fields are keywords in Rust. For example, a struct can't contain a field with the popular name <kbd>type</kbd>, because it's a keyword. You can rename it to <kbd>typ</kbd> in the struct and add <kbd>#[serde(rename="type")]</kbd> to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing a nesting</h1>
                
            
            
                
<p>The <kbd>serializer</kbd> derived automatically uses the same nesting structure as your type. If you need to reduce the levels of nesting, you can set the <kbd>#[serde(flatten)]</kbd> attribute to use fields without enclosing objects. In the previous example, we used the <kbd>Range</kbd> type from the standard library to set a range in which to generate a random value, but we also want to see the implementation details in the serialized data. To do this, we need the <kbd>start</kbd> and <kbd>end</kbd> fields of the <kbd>Range</kbd>. We added this attribute to the field to cut out the <kbd>{ "range": ... }</kbd> level of the structure.</p>
<p>For enumeration, <kbd>serde_derive</kbd> uses a tag as the name of the object. For example, the following JSON-RPC contains two variants:</p>
<pre>#[derive(Serialize, Deserialize)]<br/>enum RpcRequest {<br/>    Request { id: u32, method: String, params: Vec&lt;Value&gt; },<br/>    Notification { id: u32, method: String, params: Vec&lt;Value&gt; },<br/>}</pre>
<p>The <kbd>params</kbd> field contains an array of any JSON values represented by the <kbd>serde_json::Value</kbd> type, we'll explore this type later in this chapter. If you serialize an instance of this struct, it will include the name of a variant. Consider the following, for example:</p>
<pre>{ "Request": { "id": 1, "method": "get_user", "params": [123] } }</pre>
<p>This request isn't compatible with the JSON-RPC specification (<a href="https://www.jsonrpc.org/specification#request_object">https://www.jsonrpc.org/specification#request_object</a>). We can drop the enclosing object with the <kbd>#[serde(untagged)]</kbd> attribute and the struct becomes as follows:</p>
<pre>{ "id": 1, "method": "get_user", "params": [123] }</pre>
<p>After this change, this serialized data can be sent as JSON-RPC. However, if you still want to keep the variant value in a serialized data form, you have to use another approach, which is described in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using specific names for a tag and content</h1>
                
            
            
                
<p>In our example, we want to have two fields in a serialized data form: <kbd>distribution</kbd> and <kbd>parameters</kbd>. In the first field, we want to hold a variant of enumeration, but renamed so that it's in lowercase. In the second field, we'll keep the parameters of the specific variant.</p>
<p>To achieve this, you can write your own <kbd>Serializer</kbd> and <kbd>Deserializer</kbd>, an approach that we'll explore later in this chapter. For this case, however, we can use the <kbd>#[serde(tag = "...")]</kbd> and <kbd>#[serde(context = "...")]</kbd> attributes. <kbd>context</kbd> can only be used in a pair with <kbd>tag</kbd>.</p>
<p>We have added this to our <kbd>RngRequest</kbd>:</p>
<pre>#[serde(tag = "distribution", content = "parameters", rename_all = "lowercase")]</pre>
<p>This attribute specifies the <kbd>distribution</kbd> key of the serialized object to hold a variant of the enumeration. The variants of the enumeration move to the <kbd>parameters</kbd> field of the serialized object. The last attribute, <kbd>rename_all</kbd>, changes the case of the name of a variant. Without renaming, we would be forced to use title case for distributions, such as <kbd>"Uniform"</kbd> instead of the tidier <kbd>"uniform"</kbd>.</p>
<p>Sometimes, a serialized value has to include an object with a dynamic structure. Formats such as JSON support free data structures. I don't like unspecified structures, but we may need them to create services that are compatible with existent services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Any Value</h1>
                
            
            
                
<p class="mce-root">If you want to keep a certain part of your data deserialized but you don't know the structure of the data and you want to explore it later in runtime, you can use the generic <kbd>serde_json::Value</kbd>, which represents a value of any type. For example, the <kbd>serde_json</kbd> crate includes a <kbd>Value</kbd> object and a method to deserialize types from an instance of <kbd>Value</kbd>. This may be useful in difficult deserialization cases in which you need to reorder the representation before it's completely deserialized.</p>
<p>To use a generic <kbd>Value</kbd>, add it to your struct. Consider the following, for example:</p>
<pre>#[derive(Deserialize)]<br/>struct Response {<br/>    id: u32,<br/>    result: serde_json::Value,<br/>}</pre>
<p>Here, we used a generic value of the <kbd>serde_json</kbd> crate. When you need to deserialize it to a <kbd>User</kbd> struct, for example, you can use the <kbd>serde_json::from_value</kbd> function:</p>
<div><pre class="rust rust-example-rendered">let u: User = serde_json::from_value(&amp;response)?;</pre></div>
<p>In this section, we learned about deserialization processes. It's now time to add a handler to our server to process requests. This handler will deserialize the data, generate a random value, and return the data back in its serialized form to the client.</p>
<p>If I write a proxy service, should I deserialize and serialize requests to send them unchanged to another service? This depends on the purpose of the service. Serialization and deserialization take up a substantial amount of CPU resources. If the service is used to balance requests, you don't need the inner data of the request. This is especially the case if you only use HTTP headers to choose the destination of the request. However, you might want to use the processing benefits of deserialized data – for example, you can patch some values of the data before sending it to other microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using hyper</h1>
                
            
            
                
<p>We added the <kbd>RngRequest</kbd> and <kbd>Response</kbd> types and implemented the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits. Now we can use them with <kbd>serde_json</kbd> in a handler. In this section, we'll explore how get the full body of a request, deserialize it into an instance of a specific type, and serialize a response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading a body from a stream</h1>
                
            
            
                
<p>In fact, the body of a request in a <kbd>hyper</kbd> crate is a stream. You can't get access to the full body immediately, but you can read incoming chunks, write them to a vector, and use the resulting data set as a single object.</p>
<p>We don't have access to the whole body because it may be a huge block of data that we can't keep in the memory. Our service could be used, for example, to upload multiple terabytes of data files or for video streaming.</p>
<p>Since we're using an asynchronous approach, we can't block the current thread while we read the stream to the end. This is because it would block the thread and cause the program to stop working, because the same thread is used for polling streams.</p>
<p>The <kbd>serde</kbd> crate doesn't support the deserialization of a continuous flow of data, but you can create and use a <kbd>Deserializer</kbd> instance directly to handle infinite streams.</p>
<p>To read data from a stream, you have to take a <kbd>Stream</kbd> instance and put it into a <kbd>Future</kbd> object, which will collect the data from that stream. We'll explore this topic in the next chapter in more detail. Let's implement a <kbd>Future</kbd> that collects data from a <kbd>Stream</kbd> instance. Add the following code to a branch of the <kbd>/random</kbd> path in the <kbd>match</kbd> expression of the handler:</p>
<pre>(&amp;Method::POST, "/random") =&gt; {<br/>    let body = req.into_body().concat2()<br/>        .map(|chunks| {<br/>            let res = serde_json::from_slice::&lt;RngRequest&gt;(chunks.as_ref())<br/>                .map(handle_request)<br/>                .and_then(|resp| serde_json::to_string(&amp;resp));<br/>            match res {<br/>                Ok(body) =&gt; {<br/>                    Response::new(body.into())<br/>                },<br/>                Err(err) =&gt; {<br/>                    Response::builder()<br/>                        .status(StatusCode::UNPROCESSABLE_ENTITY)<br/>                        .body(err.to_string().into())<br/>                        .unwrap()<br/>                },<br/>            }<br/>        });<br/>    Box::new(body)<br/>}</pre>
<p>The <kbd>Request</kbd> instance has the <kbd>into_body</kbd> method, which returns the body of the request. We used the <kbd>Body</kbd> type to represent a body for our handler. The <kbd>Body</kbd> type is a stream of chunks that implement the <kbd>Stream</kbd> trait. It has the <kbd>concat2</kbd> method, which concatenates all chunks to a single object. This is possible because the <kbd>Chunk</kbd> type implements the <kbd>Extend</kbd> trait and can be extended with the other <kbd>Chunk</kbd>. The <kbd>concat2</kbd> method transforms the <kbd>Stream</kbd> to <kbd>Future</kbd>.</p>
<p>If you aren't familiar with the <kbd>futures</kbd> crate, you can learn more about it in the next chapter. For now, you can think of a <kbd>Future</kbd> object as a <kbd>Result</kbd> that will be completed later. You can think of a <kbd>Stream</kbd> as an <kbd>Iterator</kbd> that doesn't have a reference to any item and has to poll for the next item from a data stream.</p>
<p>After we take the whole body of a request, we can use deserialize. <kbd>serde_derive</kbd> derives a generic <kbd>deserializer</kbd>, so we have to use a crate to get a specific serialization format. In this case, we'll use the JSON format, so we'll use the <kbd>serde_json</kbd> crate. This includes a <kbd>from_slice</kbd> function, which creates a <kbd>Deserializer</kbd> for our type and uses it to read an instance from a buffer.</p>
<p>The <kbd>from_slice</kbd> method returns a <kbd>Result&lt;T, serde_json::Error&gt;</kbd> and we'll <kbd>map</kbd> this result to our own <kbd>handle_request</kbd> function, which reads the request and generates a response. We'll discuss this function later in this section.</p>
<p>When the result is ready, we use the <kbd>serde_json::to_string</kbd> function to convert the response to a JSON string. We use <kbd>and_then</kbd>, because <kbd>to_string</kbd> returns a Result and we have to handle errors if there are any.</p>
<p>We now have a <kbd>Result</kbd>, which contains a serialized response or <kbd>serde_json::Error</kbd> if anything goes wrong. We'll use the <kbd>match</kbd> expression to return a successful <kbd>Response</kbd> if the response is created and serialized to a <kbd>String</kbd> successfully or a response with the <kbd>UNPROCESSABLE_ENTITY</kbd> status and a body with an error message.</p>
<p>In our case, we created a <kbd>Future</kbd> object, which doesn't have any results. We have to add that future to a reactor to execute it. </p>
<p>When discussing the preceding code, we mentioned the <kbd>handle_request</kbd> function. Let's take a closer look at the implementation of this function:</p>
<pre>fn handle_request(request: RngRequest) -&gt; RngResponse {<br/>    let mut rng = rand::thread_rng();<br/>    let value = {<br/>        match request {<br/>            RngRequest::Uniform { range } =&gt; {<br/>                rng.sample(Uniform::from(range)) as f64<br/>            },<br/>            RngRequest::Normal { mean, std_dev } =&gt; {<br/>                rng.sample(Normal::new(mean, std_dev)) as f64<br/>            },<br/>            RngRequest::Bernoulli { p } =&gt; {<br/>                rng.sample(Bernoulli::new(p)) as i8 as f64<br/>            },<br/>        }<br/>    };<br/>    RngResponse { value }<br/>}</pre>
<p>The function takes a <kbd>RngRequest</kbd> value. The first line of the implementation uses a <kbd>rand::thread_rng</kbd> function to create a random-number-generator instance. We'll use the <kbd>sample</kbd> method to generate a random value.</p>
<p>Our request supports three kinds of distributions: <kbd>Uniform</kbd>, <kbd>Normal</kbd>, and <kbd>Bernoulli</kbd>. We used destructuring patterns to get the parameters of a request to create a distribution instance. After this, we used a deserialized request for sampling and converted the result into the <kbd>f64</kbd> type to pack it into the <kbd>RngResponse</kbd> value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom types</h1>
                
            
            
                
<p>When your microservice uses custom data structures, it needs a custom serialization format. You can add your own serialization by implementing the <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> traits, or by adding special attributes to your struct or field of struct. We'll explore both approaches here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom serialization</h1>
                
            
            
                
<p>We'll extend our random-number-generating service with two features – generating random colors and shuffling an array of bytes. For the first feature, we need to add the <kbd>Color</kbd> struct to hold the color components. Create a new file, <kbd>color.rs</kbd>, and add the following code to it:</p>
<pre>#[derive(Clone, PartialEq, Eq)]<br/>pub struct Color {<br/>    pub red: u8,<br/>    pub green: u8,<br/>    pub blue: u8,<br/>}</pre>
<p>Add two constant colors that we'll use later:</p>
<pre>pub const WHITE: Color = Color { red: 0xFF, green: 0xFF, blue: 0xFF };<br/>pub const BLACK: Color = Color { red: 0x00, green: 0x00, blue: 0x00 };</pre>
<p>The struct also implements <kbd>PartialEq</kbd> and <kbd>Eq</kbd> to compare a value with these constants.</p>
<p>We'll use a textual representation of color that's compatible with CSS. We'll support RGB colors in hex format and two textual colors: <kbd>black</kbd> and <kbd>white</kbd>. To convert a color to a string, implement the <kbd>Display</kbd> trait for <kbd>Color</kbd>:</p>
<pre>impl fmt::Display for Color {<br/>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>        match self {<br/>            &amp;WHITE =&gt; f.write_str("white"),<br/>            &amp;BLACK =&gt; f.write_str("black"),<br/>            color =&gt; {<br/>                write!(f, "#{:02X}{:02X}{:02X}", color.red, color.green, color.blue)<br/>            },<br/>        }<br/>    }<br/>}</pre>
<p>This implementation writes three color components to a string with the <kbd>'#'</kbd> prefix. Every color component byte is written in hex format with the <kbd>'0'</kbd> prefix for nonsignificant digits and with a width of two characters.</p>
<p>We can now use this formatter to implement the <kbd>Serialize</kbd> trait for the <kbd>Color</kbd> struct:</p>
<pre>impl Serialize for Color {<br/>    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br/>    where<br/>        S: Serializer,<br/>    {<br/>        serializer.serialize_str(&amp;self.to_string())<br/>    }<br/>}</pre>
<p>This <kbd>Serialize</kbd> implementation calls the <kbd>serialize_str</kbd> method of the <kbd>Serializer</kbd> to store a hex representation of a color to a string. Before implementing a custom deserialization, add all necessary imports to the <kbd>color.rs</kbd> file:</p>
<pre>use std::fmt;<br/>use std::str::FromStr;<br/>use std::num::ParseIntError;<br/>use serde::{de::{self, Visitor}, Deserialize, Deserializer, Serialize, Serializer};</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom deserialization</h1>
                
            
            
                
<p>Our <kbd>Color</kbd> type has to be convertible from a string. We can do this by implementing the <kbd>FromStr</kbd> trait, which makes it possible to call the <kbd>parse</kbd> method of <kbd>str</kbd> to parse the struct from a string:</p>
<pre>impl FromStr for Color {<br/>    type Err = ColorError;<br/><br/>    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {<br/>        match s {<br/>            "white" =&gt; Ok(WHITE.to_owned()),<br/>            "black" =&gt; Ok(BLACK.to_owned()),<br/>            s if s.starts_with("#") &amp;&amp; s.len() == 7 =&gt; {<br/>                let red = u8::from_str_radix(&amp;s[1..3], 16)?;<br/>                let green = u8::from_str_radix(&amp;s[3..5], 16)?;<br/>                let blue = u8::from_str_radix(&amp;s[5..7], 16)?;<br/>                Ok(Color { red, green, blue })<br/>            },<br/>            other =&gt; {<br/>                Err(ColorError::InvalidValue { value: other.to_owned() })<br/>            },<br/>        }<br/>    }<br/>}</pre>
<p>In this implementation, we use a match expression with four branches to check the cases. We indicate that the expression should have a textual value of either <kbd>"white"</kbd> or <kbd>"black"</kbd>, or that it can start with a <kbd>#</kbd>, and that it should contain exactly seven characters. Otherwise, an error should be returned to indicate that an unsupported format has been provided.</p>
<p>To implement the <kbd>Deserialization</kbd> trait, we need to add the <kbd>ColorVisitor</kbd> struct, which implements the <kbd>Visitor</kbd> trait of the <kbd>serde</kbd> crate. The <kbd>Visitor</kbd> trait is used to extract a value of a specific type from different input values. For example, we can use the <kbd>u32</kbd> and <kbd>str</kbd> input types to deserialize decimal values. The <kbd>ColorVisitor</kbd> in the following example tries to parse the incoming strings to a color. It has the following implementation:</p>
<pre>struct ColorVisitor;<br/><br/>impl&lt;'de&gt; Visitor&lt;'de&gt; for ColorVisitor {<br/>    type Value = Color;<br/><br/>    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {<br/>        formatter.write_str("a color value expected")<br/>    }<br/><br/>    fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt; Result&lt;Self::Value, E&gt; where E: de::Error {<br/>        value.parse::&lt;Color&gt;().map_err(|err| de::Error::custom(err.to_string()))<br/>    }<br/><br/>    fn visit_string&lt;E&gt;(self, value: String) -&gt; Result&lt;Self::Value, E&gt; where E: de::Error {<br/>        self.visit_str(value.as_ref())<br/>    }<br/>}</pre>
<p>As you can see, we use the <kbd>parse</kbd> method of <kbd>str</kbd>, which works with types that implement the <kbd>FromStr</kbd> trait to convert a string to a <kbd>Color</kbd> instance. We implemented two methods to extract values from different types of strings – the first for <kbd>String</kbd> instances and the second for <kbd>str</kbd> references. We can now add the <kbd>Color</kbd> type as a field in the other deserializable struct. Let's take a closer look at the <kbd>ColorError</kbd> type before we look closer at working with binary data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom error types with the failure crate</h1>
                
            
            
                
<p>The preceding parsing needs its own error type to cover both errors—incorrect parsing of numbers, and invalid variants. Let's declare the <kbd>ColorError</kbd> type in this section.</p>
<p>Error handling in Rust is particularly easy. There's a <kbd>Result</kbd> type that wraps successful and unsuccessful outcomes in a single entity. <kbd>Result</kbd> interprets any type as an error type and you can transform one result to another using the <kbd>try!</kbd> macro or the <kbd>?</kbd> operator. Joining different error types, however, is much more complicated. There's the <kbd>std::error::Error</kbd> trait, which provides a generic interface for all errors, but it's a little clumsy. To create errors in a more user-friendly way, you can use the <kbd>failure</kbd> crate.</p>
<p>This crate helps with error handling and contains extensive <kbd>failure::Error</kbd> types, which are compatible with other errors that implement the <kbd>std::Error::Error</kbd> trait. You can convert any error type that implements this trait to a generic <kbd>failure::Error</kbd>. This crate also includes macros that can be used to derive your own error type and the <kbd>failure::Fail</kbd> trait to implement extra features, such as <kbd>Backtrace</kbd>, which provides extra information about the primary cause of an error at runtime.</p>
<p>Declare this type in the <kbd>color.rs</kbd> file:</p>
<pre>#[derive(Debug, Fail)]<br/>pub enum ColorError {<br/>    #[fail(display = "parse color's component error: {}", _0)]<br/>    InvalidComponent(#[cause] ParseIntError),<br/>    #[fail(display = "invalid value: {}", value)]<br/>    InvalidValue {<br/>        value: String,<br/>    },<br/>}</pre>
<p>The <kbd>ColorError</kbd> enumeration has two variants: <kbd>InvalidComponent</kbd> for parsing issues and <kbd>InvalidValue</kbd> if the wrong value is provided. To implement the necessary error traits for this type, we derive the <kbd>Fail</kbd> trait with the <kbd>#[derive(Debug, Fail)]</kbd> attribute. The <kbd>Debug</kbd> trait implementation is also necessary for <kbd>Fail</kbd> deriving.</p>
<p>To create error messages, we added the <kbd>fail</kbd> attribute with a <kbd>display</kbd> parameter that expects a message with parameters to interpolate into a format string. For fields, you can use names, such as <kbd>value</kbd>, and numbers with the underscore prefix to indicate their field position. To insert the first field, for example, use the name <kbd>_0</kbd>. To mark a field as a nested error, use the <kbd>#[cause]</kbd> attribute.</p>
<p>Deriving the <kbd>Fail</kbd> trait won't implement <kbd>From</kbd> for types that we used as variants of the <kbd>ColorError</kbd> enum. You should do this yourself:</p>
<pre>impl From&lt;ParseIntError&gt; for ColorError {<br/>    fn from(err: ParseIntError) -&gt; Self {<br/>        ColorError::InvalidComponent(err)<br/>    }<br/>}</pre>
<p class="mce-root">The <kbd>ColorError</kbd> type is now ready to use with the <kbd>?</kbd> operator, and we can add random color generation to our microservice, together with the shuffling of a binary array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary data</h1>
                
            
            
                
<p>Before improving the microservice, add all the necessary dependencies to <kbd>Cargo.toml</kbd>:</p>
<pre>failure = "0.1"<br/>futures = "0.1"<br/>hyper = "0.12"<br/>rand = "0.5"<br/>serde = "1.0"<br/>serde_derive = "1.0"<br/>serde_json = "1.0"<br/>base64 = "0.9"<br/>base64-serde = "0.3"</pre>
<p>We're using a lot of dependencies that work well with each other, thanks to Rust and crates. As you might have noticed, we have added the <kbd>base64</kbd> crate and the <kbd>base64-serde</kbd> crate. The first is a binary-to-text converter and the second is necessary to work with a converter in the serialization processes of <kbd>serde</kbd>. Import all of these to <kbd>main.rs</kbd>:</p>
<pre>#[macro_use]<br/>extern crate failure;<br/>extern crate futures;<br/>extern crate hyper;<br/>extern crate rand;<br/>extern crate serde;<br/>#[macro_use]<br/>extern crate serde_derive;<br/>extern crate serde_json;<br/>extern crate base64;<br/>#[macro_use]<br/>extern crate base64_serde;<br/><br/>mod color;<br/><br/>use std::ops::Range;<br/>use std::cmp::{max, min};<br/>use futures::{future, Future, Stream};<br/>use hyper::{Body, Error, Method, Request, Response, Server, StatusCode};<br/>use hyper::service::service_fn;<br/>use rand::Rng;<br/>use rand::distributions::{Bernoulli, Normal, Uniform};<br/>use base64::STANDARD;<br/>use color::Color;</pre>
<p>We also added the <kbd>color</kbd> module and used <kbd>color:Color</kbd> from that module. We also imported macros from the <kbd>failure</kbd> and <kbd>base64_serde</kbd> crates.</p>
<p>Add two extra variants to the <kbd>RngRequest</kbd> enumeration for color generation and array shuffling:</p>
<pre>#[derive(Deserialize)]<br/>#[serde(tag = "distribution", content = "parameters", rename_all = "lowercase")]<br/>enum RngRequest {<br/>    Uniform {<br/>        #[serde(flatten)]<br/>        range: Range&lt;i32&gt;,<br/>    },<br/>    Normal {<br/>        mean: f64,<br/>        std_dev: f64,<br/>    },<br/>    Bernoulli {<br/>        p: f64,<br/>    },<br/>    Shuffle {<br/>        #[serde(with = "Base64Standard")]<br/>        data: Vec&lt;u8&gt;,<br/>    },<br/>    Color {<br/>        from: Color,<br/>        to: Color,<br/>    },<br/>}</pre>
<p>The <kbd>Shuffle</kbd> variant has field data of the  <kbd>Vec&lt;u8&gt;</kbd> type. Since JSON doesn't support binary data, we have to convert it to text. We added the <kbd>#[serde(with = "Base64Standard")]</kbd> attribute, which requires us to use the <kbd>Base64Standard</kbd> type for deserialization. You can customize fields with your own serialization and deserialization functions; now, we have to declare <kbd>Base64Standard</kbd>:</p>
<pre>base64_serde_type!(Base64Standard, STANDARD);</pre>
<p>We have to declare this since <kbd>base64_serde</kbd> doesn't contain predefined deserializers. This is because Base64 needs extra parameters that can't have universal values.</p>
<p>The <kbd>Color</kbd> variant contains two fields, which can be used to specify a range in which the color will be generated.</p>
<p>Add some new variants of a response to the <kbd>RngResponse</kbd> enumeration:</p>
<pre>#[derive(Serialize)]<br/>#[serde(rename_all = "lowercase")]<br/>enum RngResponse {<br/>    Value(f64),<br/>    #[serde(with = "Base64Standard")]<br/>    Bytes(Vec&lt;u8&gt;),<br/>    Color(Color),<br/>}</pre>
<p>We now have to improve the <kbd>handle_request</kbd> function with additional variants:</p>
<pre>fn handle_request(request: RngRequest) -&gt; RngResponse {<br/>    let mut rng = rand::thread_rng();<br/>    match request {<br/>        RngRequest::Uniform { range } =&gt; {<br/>            let value = rng.sample(Uniform::from(range)) as f64;<br/>            RngResponse::Value(value)<br/>        },<br/>        RngRequest::Normal { mean, std_dev } =&gt; {<br/>            let value = rng.sample(Normal::new(mean, std_dev)) as f64;<br/>            RngResponse::Value(value)<br/>        },<br/>        RngRequest::Bernoulli { p } =&gt; {<br/>            let value = rng.sample(Bernoulli::new(p)) as i8 as f64;<br/>            RngResponse::Value(value)<br/>        },<br/>        RngRequest::Shuffle { mut data } =&gt; {<br/>            rng.shuffle(&amp;mut data);<br/>            RngResponse::Bytes(data)<br/>        },<br/>        RngRequest::Color { from, to } =&gt; {<br/>            let red = rng.sample(color_range(from.red, to.red));<br/>            let green = rng.sample(color_range(from.green, to.green));<br/>            let blue = rng.sample(color_range(from.blue, to.blue));<br/>            RngResponse::Color(Color { red, green, blue})<br/>        },<br/>    }<br/>}</pre>
<p>We refactored the code a bit here and there are two extra branches. The first branch, for the <kbd>RngRequest::Shuffle</kbd> variant, uses the <kbd>shuffle</kbd> method of the <kbd>Rng</kbd> trait to shuffle incoming binary data and return it as converted to Base64 text.</p>
<p>The second variant, <kbd>RngRequest::Color</kbd>, uses the <kbd>color_range</kbd> function that we'll declare. This branch generates three colors in a range and returns a generated color. Let's explore the <kbd>color_range</kbd> function:</p>
<pre>fn color_range(from: u8, to: u8) -&gt; Uniform&lt;u8&gt; {<br/>    let (from, to) = (min(from, to), max(from, to));<br/>    Uniform::new_inclusive(from, to)<br/>}</pre>
<p>This function creates a new <kbd>Uniform</kbd> distribution with an inclusive range using <kbd>from</kbd> and <kbd>to</kbd> values. We're now ready to compile and test our microservice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling, running, and testing</h1>
                
            
            
                
<p>Compile this example and run it with the <kbd>cargo run</kbd> command. Use <kbd>curl</kbd> to send requests to the service. In the first request, we'll generate a random number with a uniform distribution:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>     --data '{"distribution": "uniform", "parameters": {"start": -100, "end": 100}}' \</strong><br/><strong>     http://localhost:8080/random</strong></pre>
<p>We sent a <kbd>POST</kbd> request to the <kbd>localhost:8080/random</kbd> URL with a JSON body. This will return <kbd>{"value":-55.0}</kbd>.</p>
<p>The next command requests a shuffle of the <kbd>"1234567890"</kbd> binary string converted to Base64:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>     --data '{"distribution": "shuffle", "parameters": { "data": "MTIzNDU2Nzg5MA==" } }' \</strong><br/><strong>     http://localhost:8080/random</strong></pre>
<p>The expected response will be <kbd>{"bytes":"MDk3NjgxNDMyNQ=="}</kbd>, which equals the string <kbd>"0976814325"</kbd>. You'll get another value for this request.</p>
<p>The next request will take a random color:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>     --data '{"distribution": "color", "parameters": { "from": "black", "to": "#EC670F" } }' \</strong><br/><strong>     http://localhost:8080/random</strong></pre>
<p>Here, we used both representations of a color value: a string value of <kbd>"black"</kbd> and a hex value of <kbd>"#EC670F"</kbd>. The response will be something similar to <kbd>{"color":"#194A09"}</kbd>.</p>
<p>The last example shows what happens if we try to send a request with an unsupported value:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>     --data '{"distribution": "gamma", "parameters": { "shape": 2.0, "scale": 5.0 } }' \</strong><br/><strong>     http://localhost:8080/random</strong></pre>
<p>Since the service doesn't support <kbd>"gamma"</kbd> distribution, it will return an error reading <kbd>"unknown variant `gamma`, expected one of `uniform`, `normal`, `bernoulli`, `shuffle`, `color` at line 1 column 24"</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Microservices with multiple formats</h1>
                
            
            
                
<p>Sometimes microservices have to be flexible and support multiple formats. For example, some modern clients use JSON, but some need XML or another format. In this section, we'll improve our microservices by adding the <strong>Concise Binary Object Representation</strong> (<strong>CBOR</strong>) serialization format.</p>
<div><strong>CBOR</strong> is a binary data serialization format based on JSON. It's more compact, supports binary strings, works faster, and is defined as a standard. You can read more about this at <a href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Different formats</h1>
                
            
            
                
<p>We need two extra crates: <kbd>queryst</kbd> for parsing parameters from the query string, and the <kbd>serde_cbor</kbd> crate to support the CBOR serialization format. Add these to your <kbd>Cargo.toml</kbd>:</p>
<pre>queryst = "2.0"<br/> serde_cbor = "0.8"</pre>
<p>Also, import them in <kbd>main.rs</kbd>:</p>
<pre>extern crate queryst;<br/>extern crate serde_cbor;</pre>
<p>Instead of using <kbd>serde_json::to_string</kbd> directly in the handler, we'll move it to a separate function that serializes data depending on the expected format:</p>
<pre>fn serialize(format: &amp;str, resp: &amp;RngResponse) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {<br/>    match format {<br/>        "json" =&gt; {<br/>            Ok(serde_json::to_vec(resp)?)<br/>        },<br/>        "cbor" =&gt; {<br/>            Ok(serde_cbor::to_vec(resp)?)<br/>        },<br/>        _ =&gt; {<br/>            Err(format_err!("unsupported format {}", format))<br/>        },<br/>    }<br/>}</pre>
<p>In this code, we used a match expression to detect a format. Significantly, we changed the <kbd>String</kbd> result to a binary type, <kbd>Vec&lt;u8&gt;</kbd>. We also used <kbd>failure::Error</kbd> as an error type, because both <kbd>serde_json</kbd> and <kbd>serde_cbor</kbd> have their own error types and we can convert them to a generic error using the <kbd>?</kbd> operator.</p>
<p>If the provided format is unknown, we can construct an <kbd>Error</kbd> with the <kbd>format_err!</kbd> macro of the <kbd>failure</kbd> crate. This macro works like the <kbd>println!</kbd> function, but it creates a generic error based on a string value.</p>
<p>We also changed the <kbd>Error</kbd> type in import section. Previously, it was the <kbd>hyper::Error</kbd> type from the <kbd>hyper</kbd> crate, but we'll now use the <kbd>failure::Error</kbd> type instead and use a crate name prefix for errors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parsing a query</h1>
                
            
            
                
<p>The HTTP URI can contain a query string with parameters that we can use to tune a request. The <kbd>Request</kbd> type has a method, <kbd>uri</kbd>, which returns a query string if it's available. We added the <kbd>queryst</kbd> crate, which parses a query string to <kbd>serde_json::Value</kbd>. We'll use this value to extract the <kbd>"format"</kbd> parameters from the query string. If the format isn't provided, we'll use <kbd>"json"</kbd> as a default value. Add the format-extracting block to the branch that handles requests to the <kbd>/random</kbd> path and use the <kbd>serialize</kbd> function that we previously declared:</p>
<pre>(&amp;Method::POST, "/random") =&gt; {<br/>    let format = {<br/>        let uri = req.uri().query().unwrap_or("");<br/>        let query = queryst::parse(uri).unwrap_or(Value::Null);<br/>        query["format"].as_str().unwrap_or("json").to_string()<br/>    };<br/>    let body = req.into_body().concat2()<br/>        .map(move |chunks| {<br/>            let res = serde_json::from_slice::&lt;RngRequest&gt;(chunks.as_ref())<br/>                .map(handle_request)<br/>                .map_err(Error::from)<br/>                .and_then(move |resp| serialize(&amp;format, &amp;resp));<br/>            match res {<br/>                Ok(body) =&gt; {<br/>                    Response::new(body.into())<br/>                },<br/>                Err(err) =&gt; {<br/>                    Response::builder()<br/>                        .status(StatusCode::UNPROCESSABLE_ENTITY)<br/>                        .body(err.to_string().into())<br/>                        .unwrap()<br/>                },<br/>            }<br/>        });<br/>    Box::new(body)<br/>},</pre>
<p>This code extracts a format value from a query string, processes a request, and returns a serialized value using a chosen format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking different formats</h1>
                
            
            
                
<p>Compile the code, run it, and use <kbd>curl</kbd> to check the result. First, let's check the traditional JSON format:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>       --data '{"distribution": "uniform", "parameters": {"start": -100, "end": 100}}' \</strong><br/><strong>       "http://localhost:8080/random?format=json"</strong></pre>
<p>This will return a JSON response that we've seen before: <kbd>{"value":-19.0}</kbd>. The next request will return a CBOR value:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong>       --data '{"distribution": "uniform", "parameters": {"start": -100, "end": 100}}' \</strong><br/><strong>       "http://localhost:8080/random?format=cbor"</strong></pre>
<p>This command won't print a response to the console, because it's in binary format. You'll see the following warning message:</p>
<pre>Warning: Binary output can mess up your terminal. Use "--output -" to tell <br/>Warning: curl to output it to your terminal anyway, or consider "--output <br/>Warning: &lt;FILE&gt;" to save to a file.</pre>
<p>Let's try to request a response in XML format:</p>
<pre><strong>$ curl --header "Content-Type: application/json" --request POST \</strong><br/><strong> --data '{"distribution": "uniform", "parameters": {"start": -100, "end": 100}}' \</strong><br/><strong> "http://localhost:8080/random?format=xml"</strong></pre>
<p>This has worked correctly; it printed <kbd>unsupported format xml</kbd> to indicate that it doesn't support XML format. Let's now move on to discussing transcoding <kbd>serde</kbd> values and looking at why XML isn't a format that's widely supported by <kbd>serde</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transcoding</h1>
                
            
            
                
<p>Sometimes, you'll be faced with situations in which you need to convert one format to another. In this instance, you can use the <kbd>serde_transcode</kbd> crate, which converts one format to another using a standard <kbd>serde</kbd> serialization process. The crate has a <kbd>transcode</kbd> function that expects a <kbd>serializer</kbd> and a <kbd>deserializer</kbd> as arguments. You can use it as follows:</p>
<pre class="rust rust-example-rendered">let mut deserializer = serde_json::Deserializer::from_reader(reader);
let mut serializer = serde_cbor::Serializer::pretty(writer);
serde_transcode::transcode(&amp;mut deserializer, &amp;mut serializer).unwrap();</pre>
<p>This code converts incoming JSON data into CBOR data. You can read more about this crate at: <a href="https://crates.io/crates/serde-transcode">https://crates.io/crates/serde-transcode</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">XML support</h1>
                
            
            
                
<p><kbd>serde</kbd> doesn't provide very good support for XML. The main reason for this is the complexity of the format. It has so many rules and exceptions that you can't describe the expected format in a simple form. However, there are also some implementations that aren't compatible with <kbd>serde</kbd>. The following links explain streaming, reading, and writing XML data: <a href="https://crates.io/crates/xml-rs">https://crates.io/crates/xml-rs</a> and <a href="https://crates.io/crates/quick-xml">https://crates.io/crates/quick-xml</a>.</p>
<p>Another format that isn't compatible with the <kbd>serde</kbd> infrastructure is Protocol Buffers (<a href="https://crates.io/crates/protobuf">https://developers.google.com/protocol-buffers/</a>). Developers often choose this format for performance reasons and to use one scheme of data for different applications. To use this format in Rust code, try to use the <kbd>protobuf</kbd> crate: <a href="https://crates.io/crates/protobuf">https://crates.io/crates/protobuf</a>.</p>
<p>In my opinion, it's better to use a format that's compatible with the <kbd>serde</kbd> crate in Rust for the following reasons:</p>
<ul>
<li>It's simpler to use in a code.</li>
<li>Structs don't need a scheme, because they're strict.</li>
<li>You can use a separated crate with a determined protocol.</li>
</ul>
<p>The only situation in which you shouldn't follow the <kbd>serde</kbd> approach is if you have to support a format that isn't compatible with <kbd>serde</kbd>, but has been used in existing services or clients.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we discussed serialization and deserialization processes using the <kbd>serde</kbd> crate. We looked at how <kbd>serde</kbd> supports multiple formats and can automatically derive <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> implementations for structs or enumerations. We implemented a service that generates random numbers from incoming parameters serialized in JSON format.</p>
<p>After that, you learned how to implement these traits yourself and add extra features to shuffle an array or to generate a random color. Finally, we discussed how to support multiple formats in one handler.</p>
<p>In the next chapter, you'll learn how to use full potential of asynchronous code, and write microservices with Rust that can handle thousands of clients simultaneously.</p>


            

            
        
    </body></html>