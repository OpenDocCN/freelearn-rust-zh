["```rs\nfn main() {\n    println!(\"hello world\");\n}\n```", "```rs\nrustc hello_world.rs\n```", "```rs\n.\\hello_world.exe\n```", "```rs\n./hello_world\n```", "```rs\ncargo new web_app\n```", "```rs\n└── web_app\n    ├── Cargo.toml\n    └── src\n         └── main.rs\n```", "```rs\n cargo run\n```", "```rs\n  Compiling web_app v0.1.0 (/Users/maxwellflitton/Documents/\n   github/books/Rust-Web_Programming-two/chapter02/web_app)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.15s\n     Running `target/debug/web_app`\nhello world\n```", "```rs\ncargo run --release\n```", "```rs\n    Finished release [optimized] target(s) in 2.63s\n     Running `target/release/web_app`\nhello world\n```", "```rs\n[dependencies]\nrand = \"0.7.3\"\n```", "```rs\nuse rand::prelude::*;\nfn generate_float(generator: &mut ThreadRng) -> f64 {\n    let placeholder: f64 = generator.gen();\n    return placeholder * 10.0\n}\nfn main() {\n    let mut rng: ThreadRng = rand::thread_rng();\n    let random_number = generate_float(&mut rng);\n    println!(\"{}\", random_number);\n}\n```", "```rs\n/// This function generates a float number using a number\n/// generator passed into the function.\n///\n/// # Arguments\n/// * generator (&mut ThreadRng): the random number\n/// generator to generate the random number\n///\n/// # Returns\n/// (f64): random number between 0 -> 10\nfn generate_float(generator: &mut ThreadRng) -> f64 {\n    let placeholder: f64 = generator.gen();\n    return placeholder * 10.0\n}\n```", "```rs\n/// This trait defines the struct to be a user.\ntrait IsUser {\n    /// This function proclaims that the struct is a user.\n    ///\n    /// # Arguments\n    /// None\n    ///\n    /// # Returns\n    /// (bool) true if user, false if not\n    fn is_user() -> bool {\n        return true\n    }\n}\n/// This struct defines a user\n///\n/// # Attributes\n/// * name (String): the name of the user\n/// * age (i8): the age of the user\nstruct User {\n    name: String,\n    age: i8\n}\n```", "```rs\ncargo doc --open\n```", "```rs\nuse std::env;\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    println!(\"{:?}\", args);\n}\n```", "```rs\ncargo run one two three\n```", "```rs\n[\"target/debug/interacting_with_cargo\", \"one\", \"two\", \"three\"]\n```", "```rs\ncargo run --release one two three\n```", "```rs\n[\"target/release/interacting_with_cargo\", \"one\", \"two\", \"three\"]\n```", "```rs\nlet args: Vec<String> = env::args().collect();\nlet path: &str = &args[0];\nif path.contains(\"/debug/\") {\n    println!(\"Debug is running\");\n}\nelse if path.contains(\"/release/\") {\n    println!(\"release is running\");\n}\nelse {\n    panic!(\"The setting is neither debug or release\");\n}\n```", "```rs\n[dependencies]\nclap = \"3.0.14\"\n```", "```rs\nuse clap::{Arg, App};\n```", "```rs\n    fn main() {\n    ```", "```rs\n        let app = App::new(\"booking\")\n    ```", "```rs\n            .version(\"1.0\")\n    ```", "```rs\n            .about(\"Books in a user\")\n    ```", "```rs\n            .author(\"Maxwell Flitton\");\n    ```", "```rs\n    . . .\n    ```", "```rs\n        let first_name = Arg::new(\"first name\")\n    ```", "```rs\n            .long(\"f\")\n    ```", "```rs\n            .takes_value(true)\n    ```", "```rs\n            .help(\"first name of user\")\n    ```", "```rs\n            .required(true);\n    ```", "```rs\n        let last_name = Arg::new(\"last name\")\n    ```", "```rs\n            .long(\"l\")\n    ```", "```rs\n            .takes_value(true)\n    ```", "```rs\n            .help(\"first name of user\")\n    ```", "```rs\n            .required(true);\n    ```", "```rs\n        let age = Arg::new(\"age\")\n    ```", "```rs\n            .long(\"a\")\n    ```", "```rs\n            .takes_value(true)\n    ```", "```rs\n            .help(\"age of the user\")\n    ```", "```rs\n            .required(true);\n    ```", "```rs\n        let app = app.arg(first_name).arg(last_name).arg(age);\n    ```", "```rs\n        let matches = app.get_matches();\n    ```", "```rs\n        let name = matches.value_of(\"first name\")\n    ```", "```rs\n            .expect(\"First name is required\");\n    ```", "```rs\n        let surname = matches.value_of(\"last name\")\n    ```", "```rs\n            .expect(\"Surname is required\");\n    ```", "```rs\n        let age: i8 = matches.value_of(\"age\")\n    ```", "```rs\n            .expect(\"Age is required\").parse().unwrap();\n    ```", "```rs\n        println!(\"{:?}\", name);\n    ```", "```rs\n        println!(\"{:?}\", surname);\n    ```", "```rs\n        println!(\"{:?}\", age);\n    ```", "```rs\n    }\n    ```", "```rs\ncargo run -- --help  \n```", "```rs\nbooking 1.0\nMaxwell Flitton\nBooks in a user\nUSAGE:\n    interacting_with_cargo --f <first name> --l <last name> \n                           --a <age>\nOPTIONS:\n        --a <age>           age of the user\n        --f <first name>    first name of user\n    -h, --help              Print help information\n        --l <last name>     first name of user\n    -V, --version           Print version information\n```", "```rs\ncargo run -- --f first --l second --a 32\n```", "```rs\n\"first\"\n\"second\"\n32\n```", "```rs\n├── main.rs\n└── to_do\n    ├── mod.rs\n```", "```rs\n├── main.rs\n└── to_do\n    ├── enums.rs\n    ├── mod.rs\n    └── structs\n        ├── base.rs\n        ├── done.rs\n        ├── mod.rs\n        └── pending.rs\n```", "```rs\npub enum TaskStatus {\n    DONE,\n    PENDING\n}\n```", "```rs\nimpl TaskStatus {\n    pub fn stringify(&self) -> String {\n        match &self {\n            &Self::DONE => {\"DONE\".to_string()},\n            &Self::PENDING => {\"PENDING\".to_string()}\n        }\n    }\n}\n```", "```rs\nuse std::fmt;\n```", "```rs\nimpl fmt::Display for TaskStatus {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match &self {\n            &Self::DONE => {write!(f, \"DONE\")},\n            &Self::PENDING => {write!(f, \"PENDING\")}\n        }\n    }\n}\n```", "```rs\nprintln!(\"{}\", TaskStatus::DONE);\nprintln!(\"{}\", TaskStatus::PENDING);\nlet outcome = TaskStatus::DONE.to_string();\nprintln!(\"{}\", outcome);\n```", "```rs\nDONE\nPENDING\nDONE\n```", "```rs\npub mod enums;\n```", "```rs\nuse super::super::enums::TaskStatus;\npub struct Base {\n    pub title: String,\n    pub status: TaskStatus\n}\n```", "```rs\nmod base;\n```", "```rs\nuse super::base::Base;\nuse super::super::enums::TaskStatus;\npub struct Pending {\n    pub super_struct: Base\n}\nimpl Pending {\n    pub fn new(input_title: &str) -> Self {\n        let base = Base{\n            title: input_title.to_string(),\n            status: TaskStatus::PENDING\n        };\n        return Pending{super_struct: base}\n    }\n}\n```", "```rs\nuse super::base::Base;\nuse super::super::enums::TaskStatus;\npub struct Done {\n    pub super_struct: Base\n}\nimpl Done {\n    pub fn new(input_title: &str) -> Self {\n        let base = Base {\n            title: input_title.to_string(),\n            status: TaskStatus::DONE\n        };\n        return Done{super_struct: base}\n    }\n}\n```", "```rs\nmod base;\npub mod done;\npub mod pending;\n```", "```rs\npub mod structs;\npub mod enums;\n```", "```rs\nmod to_do;\nuse to_do::structs::done::Done;\nuse to_do::structs::pending::Pending;\nfn main() {\n    let done = Done::new(\"shopping\");\n    println!(\"{}\", done.super_struct.title);\n    println!(\"{}\", done.super_struct.status.stringify());\n    let pending = Pending::new(\"laundry\");\n    println!(\"{}\", pending.super_struct.title);\n    println!(\"{}\", pending.super_struct.status.stringify()\n    );\n}\n```", "```rs\nshopping\nDONE\nlaundry\nPENDING\n```", "```rs\npub mod structs;\npub mod enums;\nuse enums::TaskStatus;\nuse structs::done::Done;\nuse structs::pending::Pending;\npub enum ItemTypes {\n    Pending(Pending),\n    Done(Done)\n}\npub fn to_do_factory(title: &str, \n                     status: TaskStatus) -> ItemTypes {\n    match status {\n        TaskStatus::DONE => {\n            ItemTypes::Done(Done::new(title))\n        },\n        TaskStatus::PENDING => {\n            ItemTypes::Pending(Pending::new(title))\n        }\n    }\n}\n```", "```rs\nmod to_do;\nuse to_do::to_do_factory;\nuse to_do::enums::TaskStatus;\nuse to_do::ItemTypes;\nfn main() {\n    let to_do_item = to_do_factory(\"washing\", \n                                   TaskStatus::DONE);\n    match to_do_item {\n        ItemTypes::Done(item) => {\n            println!(\"{}\", item.super_struct.status\n                     .stringify());\n            println!(\"{}\", item.super_struct.title);\n        },\n        ItemTypes::Pending(item) => {\n            println!(\"{}\", item.super_struct.status\n                     .stringify());\n            println!(\"{}\", item.super_struct.title);\n        }\n    }\n}\n```", "```rs\nlet to_do_item = to_do_factory(\"washing\", TaskStatus::DONE);\n```", "```rs\n├── mod.rs\n└── traits\n    ├── create.rs\n    ├── delete.rs\n    ├── edit.rs\n    ├── get.rs\n    └── mod.rs\n```", "```rs\npub mod create;\npub mod delete;\npub mod edit;\npub mod get;\n```", "```rs\npub mod traits;\n```", "```rs\npub trait Get {\n    fn get(&self, title: &str) {\n        println!(\"{} is being fetched\", title);\n    }\n}\n```", "```rs\npub trait Edit {\n    fn set_to_done(&self, title: &str) {\n        println!(\"{} is being set to done\", title);\n    }\n    fn set_to_pending(&self, title: &str) {\n        println!(\"{} is being set to pending\", title);\n    }\n}\n```", "```rs\npub trait Create {\n    fn create(&self, title: &str) {\n        println!(\"{} is being created\", title);\n    }\n}\n```", "```rs\npub trait Delete {\n    fn delete(&self, title: &str) {\n        println!(\"{} is being deleted\", title);\n    }\n}\n```", "```rs\nuse super::super::traits::get::Get;\nuse super::super::traits::delete::Delete;\nuse super::super::traits::edit::Edit;\n```", "```rs\nimpl Get for Done {}\nimpl Delete for Done {}\nimpl Edit for Done {}\n```", "```rs\nuse super::super::traits::get::Get;\nuse super::super::traits::edit::Edit;\nuse super::super::traits::create::Create;\n```", "```rs\nimpl Get for Pending {}\nimpl Edit for Pending {}\nimpl Create for Pending {}\n```", "```rs\nmod to_do;\nuse to_do::to_do_factory;\nuse to_do::enums::TaskStatus;\nuse to_do::ItemTypes;\nuse crate::to_do::traits::get::Get;\nuse crate::to_do::traits::delete::Delete;\nuse crate::to_do::traits::edit::Edit;\n```", "```rs\nfn main() {\n    let to_do_items = to_do_factory(\"washing\", \n                                    TaskStatus::DONE);\n    match to_do_items {\n        ItemTypes::Done(item) => {\n            item.get(&item.super_struct.title);\n            item.delete(&item.super_struct.title);\n        },\n        ItemTypes::Pending(item) => {\n            item.get(&item.super_struct.title);\n            item.set_to_done(&item.super_struct.title);\n        }\n    }\n}\n```", "```rs\nwashing is being fetched\nwashing is being deleted\n```", "```rs\n[dependencies]\nserde_json=\"1.0.59\"\n```", "```rs\nuse std::fs::File;\nuse std::fs;\nuse std::io::Read;\nuse serde_json::Map;\nuse serde_json::value::Value;\nuse serde_json::json;\n```", "```rs\npub fn read_file(file_name: &str) -> Map<String, Value> {\n    let mut file = File::open(file_name.to_string()).unwrap();\n    let mut data = String::new();\n    file.read_to_string(&mut data).unwrap();\n    let json: Value = serde_json::from_str(&data).unwrap();\n    let state: Map<String, Value> = json.as_object()\n                                    .unwrap().clone();\n    return state\n}\n```", "```rs\npub fn write_to_file(file_name: &str, \n                     state: &mut Map<String, Value>) {\n    let new_data = json!(state);\n    fs::write(\n          file_name.to_string(),\n          new_data.to_string()\n    ).expect(\"Unable to write file\");\n}\n```", "```rs\nmod state;\nuse std::env;\nuse state::{write_to_file, read_file};\nuse serde_json::value::Value;\nuse serde_json::{Map, json};\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let status: &String = &args[1];\n    let title: &String = &args[2];\n    let mut state: Map<String, Value> =\n    read_file(\"./state.json\");\n    println!(\"Before operation: {:?}\", state);\n    state.insert(title.to_string(), json!(status));\n    println!(\"After operation: {:?}\", state);\n    write_to_file(\"./state.json\", &mut state);\n}\n```", "```rs\ncargo run pending washing\n```", "```rs\nBefore operation: {}\nAfter operation: {\"washing\": String(\"pending\")}\n```", "```rs\nuse serde_json::Map;\nuse serde_json::value::Value;\npub trait Get {\n    fn get(&self, title: &String, state: &Map<String, Value>) {\n        let item: Option<&Value> = state.get(title);\n        match item {\n            Some(result) => {\n                println!(\"\\n\\nItem: {}\", title);\n                println!(\"Status: {}\\n\\n\", result);\n            },\n            None => println!(\"item: {} was not found\", \n                              title)\n        }\n    }\n}\n```", "```rs\nuse serde_json::Map;\nuse serde_json::value::Value;\nuse serde_json::json;\nuse crate::state::write_to_file;\npub trait Create {\n    fn create(&self, title: &String, status: &String,\n              state: &mut Map<String, Value>) {\n            state.insert(title.to_string(), json!(status));\n            write_to_file(\"./state.json\", state);\n            println!(\"\\n\\n{} is being created\\n\\n\", title);\n    }\n}\n```", "```rs\nuse serde_json::Map;\nuse serde_json::value::Value;\nuse crate::state::write_to_file;\npub trait Delete {\n    fn delete(&self, title: &String,\n        state: &mut Map<String, Value>) {\n        state.remove(title);\n        write_to_file(\"./state.json\", state);\n        println!(\"\\n\\n{} is being deleted\\n\\n\", title);\n    }\n}\n```", "```rs\nuse serde_json::Map;\nuse serde_json::value::Value;\nuse serde_json::json;\nuse crate::state::write_to_file;\nuse super::super::enums::TaskStatus;\npub trait Edit {\n    fn set_to_done(&self, title: &String,\n        state: &mut Map<String, Value>) {\n        state.insert(title.to_string(),\n        json!(TaskStatus::DONE.stringify()));\n        write_to_file(\"./state.json\", state);\n        println!(\"\\n\\n{} is being set to done\\n\\n\", title);\n    }\n    fn set_to_pending(&self, title: &String,\n        state: &mut Map<String, Value>) {\n        state.insert(title.to_string(),\n        json!(TaskStatus::PENDING.stringify()));\n        write_to_file(\"./state.json\", state);\n        println!(\"\\n\\n{} is being set to pending\\n\\n\", title);\n    }\n}\n```", "```rs\nuse serde_json::Map;\nuse serde_json::value::Value;\nuse super::to_do::ItemTypes;\nuse super::to_do::structs::done::Done;\nuse super::to_do::structs::pending::Pending;\nuse super::to_do::traits::get::Get;\nuse super::to_do::traits::create::Create;\nuse super::to_do::traits::delete::Delete;\nuse super::to_do::traits::edit::Edit;\n```", "```rs\nfn process_pending(item: Pending, command: String, \n                   state: &Map<String, Value>) {\n    let mut state = state.clone();\n    match command.as_str() {\n    \"get\" => item.get(&item.super_struct.title, &state),\n    \"create\" => item.create(&item.super_struct.title, \n    &item.super_struct.status.stringify(), &mut state),\n    \"edit\" => item.set_to_done(&item.super_struct.title, \n                               &mut state),\n    _ => println!(\"command: {} not supported\", command)\n    }\n}\n```", "```rs\nfn process_done(item: Done, command: String, \n                state: &Map<String, Value>) {\n    let mut state = state.clone();\n    match command.as_str() {\n        \"get\" => item.get(&item.super_struct.title, \n                          &state),\n        \"delete\" => item.delete(&item.super_struct.title, \n                                &mut state),\n        \"edit\" => \n             item.set_to_pending(&item.super_struct.title, \n                                 &mut state),\n        _ => println!(\"command: {} not supported\", command)\n    }\n}\n```", "```rs\npub fn process_input(item: ItemTypes, command: String, \n                     state: &Map<String, Value>) {\n    match item {\n        ItemTypes::Pending(item) => process_pending(item, \n                                    command, state),\n        ItemTypes::Done(item) => process_done(item, \n                                    command, state)\n    }\n}\n```", "```rs\nmod state;\nmod to_do;\nmod processes;\nuse std::env;\nuse serde_json::value::Value;\nuse serde_json::Map;\nuse state::read_file;\nuse to_do::to_do_factory;\nuse to_do::enums::TaskStatus;\nuse processes::process_input;\n```", "```rs\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let command: &String = &args[1];\n    let title: &String = &args[2];\n    let state: Map<String, Value> = read_file(\"./state.json\");\n    let status: String;\n    match &state.get(*&title) {\n        Some(result) => {\n            status = result.to_string().replace('\\\"', \"\");\n        }\n        None=> {\n            status = \"pending\".to_owned();\n        }\n    }\n    let item = to_do_factory(title, \n                             TaskStatus::from_string(\n                             status.to_uppercase()));\n    process_input(item, command.to_string(), &state);\n}\n```", "```rs\nimpl TaskStatus {\n    . . .\n    pub fn from_string(input_string: String) -> Self {\n        match input_string.as_str() {\n            \"DONE\" => TaskStatus::DONE,\n            \"PENDING\" => TaskStatus::PENDING,\n            _ => panic!(\"input {} not supported\", \n                        input_string)\n        }\n    }\n}\n```", "```rs\ncargo run create washing\n```"]