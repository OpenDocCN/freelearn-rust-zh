<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a Music Player</h1>
                
            
            
                
<p class="calibre3">In previous chapters you created an awesome game, so now let's move on to another exciting topic—desktop applications. We'll use the Rust bindings of the GTK+ library in order to code an MP3 music player. We'll have the opportunity to learn about threads to code the music player itself in the next chapter. But, in this chapter, we'll focus on the graphical interface, how to manage the layout of the interface, and how to manage user events.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Windows</li>
<li class="calibre11">Widgets</li>
<li class="calibre11">Events</li>
<li class="calibre11">Closures</li>
<li class="calibre11">Event loops</li>
<li class="calibre11">Containers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing the prerequisite</h1>
                
            
            
                
<p class="calibre3">Since GTK+ is a C library, we'll need to install it first. The Rust bindings use GTK+ version 3, so make sure you do not install the old version 2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing GTK+ on Linux</h1>
                
            
            
                
<p class="calibre3">On Linux, GTK+ can be installed through the package manager of your distribution.</p>
<p class="calibre3">On Ubuntu (or other Debian derivatives):</p>
<pre class="calibre23"><strong class="calibre5">sudo apt-get install libgtk-3-dev</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing GTK+ on Mac</h1>
                
            
            
                
<p class="calibre3">On OSX, you just need to run the following command:</p>
<pre class="calibre23"><strong class="calibre5">brew</strong><strong class="calibre5"> install gtk+3 gnome-icon-theme</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing GTK+ on Windows</h1>
                
            
            
                
<p class="calibre3">On Windows, you'll need to first download and install MSYS2, which provides a Unix-like environment on Windows. After it is installed, issue the following command in a MSYS2 shell:</p>
<pre class="calibre23"><strong class="calibre5">pacman -S mingw-w64-x86_64-gtk3</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating your first window</h1>
                
            
            
                
<p class="calibre3">Now we're ready to start using GTK+ from Rust. Let's create a new project for our music player:</p>
<pre class="calibre23"><strong class="calibre5">cargo new rusic --bin</strong></pre>
<p class="calibre3">Add the dependency on the <kbd class="calibre14">gio</kbd> and <kbd class="calibre14">gtk</kbd> crates in your <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">gio = "^0.3.0"
gtk = "^0.3.0"</pre>
<p class="calibre3">Replace the content of the <kbd class="calibre14">src/main.rs</kbd> file with this:</p>
<pre class="calibre22">extern crate gio;
extern crate gtk;

use std::env;

use gio::{ApplicationExt, ApplicationExtManual, ApplicationFlags};
use gtk::{
    Application,
    ApplicationWindow,
    WidgetExt,
    GtkWindowExt,
};

fn main() {
    let application = Application::new("com.github.rust-by-<br class="calibre6"/>     example", ApplicationFlags::empty())
        .expect("Application initialization failed");
    application.connect_startup(|application| {
        let window = ApplicationWindow::new(&amp;application);
        window.set_title("Rusic");
        window.show();
    });
    application.connect_activate(|_| {});
    application.run(&amp;env::args().collect::&lt;Vec&lt;_&gt;&gt;());
}</pre>
<p class="calibre3">Then, run the application with <kbd class="calibre14">cargo run</kbd>. You should see a small and empty window:</p>
<div><img src="img/00029.gif" class="calibre59"/></div>
<div><em class="calibre21"><em class="calibre21">Figure 5.1</em></em></div>
<p class="calibre3">If you saw this window, it means you have installed GTK+ correctly.</p>
<p class="calibre3">Let's explain this code in smaller chunks:</p>
<pre class="calibre22">extern crate gio;
extern crate gtk;</pre>
<p class="calibre3">As usual, when using an external crate, we need to declare it.</p>
<p class="calibre3">Then, we import the types and modules we'll use from the standard library, <kbd class="calibre14">gio</kbd>, and <kbd class="calibre14">gtk</kbd>:</p>
<pre class="calibre22">use std::env;

use gio::{ApplicationExt, ApplicationExtManual, ApplicationFlags};
use gtk::{
    Application,
    ApplicationWindow,
    WidgetExt,
    GtkWindowExt,
};</pre>
<p class="calibre3">After that, we start the <kbd class="calibre14">main</kbd> function:</p>
<pre class="calibre22">fn main() {
    let application = Application::new("com.github.rust-by-<br class="calibre6"/>     example", <br class="calibre6"/>     ApplicationFlags::empty())
        .expect("Application initialization failed");</pre>
<p class="calibre3">The first line of this function creates a new <kbd class="calibre14">gio</kbd> application. We provide an application ID that can be used to make sure the application is only run once. An <kbd class="calibre14">Application</kbd> makes it easier to manage applications and its windows.</p>
<p class="calibre3">Next, we create the window, set its title, and show it to the screen:</p>
<pre class="calibre23">    application.connect_startup(|application| {
        let window = ApplicationWindow::new(&amp;application);
        window.set_title("Rusic");
        window.show();
    });
    application.connect_activate(|_| {});</pre>
<p class="calibre3">After creating a new window, we set its title and show it.</p>
<p class="calibre3">Here, we're actually handling an event; the <kbd class="calibre14">startup</kbd> is a signal that is emitted when the application is registered- so, when it is ready to be used. As you can see in the documentation on GTK+ (<a href="https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup" class="calibre13">https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup</a>), signals are represented by strings. This signal is actually called <kbd class="calibre14">startup</kbd>, but the Rust method we used to connect this signal is <kbd class="calibre14">connect_startup</kbd>. So, we need to add <kbd class="calibre14">connect_</kbd> before the signal name and change the dashes to underscores.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Closure</h1>
                
            
            
                
<p class="calibre3">The argument of this method is somewhat special:</p>
<pre class="calibre22">|application| {
    let window = ApplicationWindow::new(&amp;application);
    window.set_title("Rusic");
    window.show();
}</pre>
<p class="calibre3">This is what we call a closure. A closure is a concise way of declaring a function that does not have a name and can capture the environment. Capturing the environment means that it can access the variables from outside the closure, something which is not possible to do with normal functions. The methods to connect a signal will run the function (in this case, a closure) passed as an argument. Here, create the window.</p>
<p class="calibre3">We could have decided to create a normal function, as the following code does:</p>
<pre class="calibre22">fn startup_handler(application: &amp;Application) {
    let window = ApplicationWindow::new(&amp;application);
    window.set_title("Rusic");
    window.show();
}

// In the main function:

    application.connect_startup(startup_handler);</pre>
<p class="calibre3">But that is less convenient than using a closure. Besides the fact that you might need to import other crates and types, you need to specify the types of the parameters and the return type. Indeed, type inference is available for closures but not for functions. Also, the function must be declared elsewhere, so it can become less readable than using a closure.</p>
<p class="calibre3">The rest of the <kbd class="calibre14">main</kbd> function is:</p>
<pre class="calibre22">    application.run(&amp;env::args().collect::&lt;Vec&lt;_&gt;&gt;());
}</pre>
<p class="calibre3">This starts the <kbd class="calibre14">gtk</kbd> event loop. This is an infinite loop that processes the user events like a button click or a request to close a window. It also manages other things like timeouts and asynchronous, IO-like network requests.</p>
<p class="calibre3">Some event handlers require you to return a value, which is the case for the signal <kbd class="calibre14">delete_event</kbd> where we need to return <kbd class="calibre14">Inhibit(false)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Preventing the default behavior of an event</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre14">Inhibit</kbd> type is only a wrapper over the <kbd class="calibre14">bool</kbd> type. It is used to indicate whether we should  stop propagating the event to the default handler or not. To see what this means, let's add an event handler for the window:</p>
<pre class="calibre22">window.connect_delete_event(|_, _| {
    Inhibit(true)
});</pre>
<p class="calibre3">If you run it, you'll note that we cannot close the window anymore. That's because we returned <kbd class="calibre14">Inhibit(true)</kbd> to indicate that we want to prevent the default behavior of the <kbd class="calibre14">delete_event</kbd> signal, which is to close the window.</p>
<p class="calibre3">Now let's try a slight variant of the previous code:</p>
<pre class="calibre22">window.connect_delete_event(|_, _| {
    Inhibit(false)
});</pre>
<p class="calibre3">In this case, we do not prevent the default handler from being run, so the window will be closed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a toolbar</h1>
                
            
            
                
<p class="calibre3">We'll start our music player by adding a toolbar with the buttons needed for such software:</p>
<ul class="calibre10">
<li class="calibre11">Open a file</li>
<li class="calibre11">Play</li>
<li class="calibre11">Pause</li>
<li class="calibre11">Stop</li>
<li class="calibre11">Previous/next song</li>
<li class="calibre11">Remove song from playlist</li>
</ul>
<p class="calibre3">That'll be a good start for our first non-empty window.</p>
<p class="calibre3">First of all, we'll need some additional import statements:</p>
<pre class="calibre22">use gtk::{
    ContainerExt,
    SeparatorToolItem,
    Toolbar,
    ToolButton,
};</pre>
<p class="calibre3">Then, we'll declare a constant because we'll use this value elsewhere:</p>
<pre class="calibre22">const PLAY_STOCK: &amp;str = "gtk-media-play";</pre>
<p class="calibre3">We'll explain what this is very soon.</p>
<p class="calibre3">We'll now create a toolbar and add it to the window:</p>
<pre class="calibre22">fn main() {
    // Same code to initialize gtk, create the window.
    application.connect_startup(|application| {
        // …

        let toolbar = Toolbar::new();
        window.add(&amp;toolbar);</pre>
<div><p class="calibre24">Note: Don't call <kbd class="calibre25">window.show()</kbd> yet, as we'll use another method ahead.</p>
</div>
<p class="calibre3">This code is pretty straightforward. The only thing to note is that the <kbd class="calibre14">gtk-rs</kbd> API requires a reference to values in most cases; in this case, we send a reference to the toolbar as a parameter to the <kbd class="calibre14">add()</kbd> method.</p>
<p class="calibre3">You'll see this <kbd class="calibre14">add()</kbd> method called literally everywhere. It allows you to add a widget to another. A widget is a component (visual or not) of a user interface. It can be a button, a menu, a separator, but it can also be an invisible component such as a box allowing you to place the widgets horizontally. We'll talk about containers like <kbd class="calibre14">gtk::Box</kbd> and how to lay out our widgets later in this chapter.</p>
<p class="calibre3">Let's add a button to this toolbar:</p>
<pre class="calibre23">    let open_button = ToolButton::new_from_stock("gtk-open");
    toolbar.add(&amp;open_button);</pre>
<p class="calibre3">This creates a toolbar button and adds it to the toolbar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Stock item</h1>
                
            
            
                
<p class="calibre3">Instead of using the usual <kbd class="calibre14">new()</kbd> constructor, we decided to use the <kbd class="calibre14">new_from_stock()</kbd> one here. This takes a string as an argument. This string is an identifier for the item that represents a built-in menu or toolbar item, such as <kbd class="calibre14">Open</kbd> or <kbd class="calibre14">Save</kbd>. These items have an icon and a label that is translated according to the user locale. By using stock items, you can quickly create a beautiful application that will look the same as other applications built with GTK+.</p>
<p class="calibre3">Let's show this window containing the toolbar:</p>
<pre class="calibre23">        window.show_all();
    });</pre>
<p class="calibre3">This goes right at the end of the startup event handler. Here, we use <kbd class="calibre14">show_all()</kbd> instead of only <kbd class="calibre14">show()</kbd> because we have more widgets to show. Instead of using <kbd class="calibre14">show_all()</kbd>, we could call <kbd class="calibre14">show()</kbd> on every single widget, but this can become cumbersome; that's why <kbd class="calibre14">show_all()</kbd> exists.</p>
<p class="calibre3">If you run this application, you'll see the following window with an open button:</p>
<div><img src="img/00030.gif" class="calibre60"/></div>
<div><em class="calibre21">Figure 5.2</em></div>
<p class="calibre3">Let's add the open buttons we'll need:</p>
<pre class="calibre23">    toolbar.add(&amp;SeparatorToolItem::new());

    let previous_button = ToolButton::new_from_stock("gtk-media-previous");
    toolbar.add(&amp;previous_button);

    let play_button = ToolButton::new_from_stock(PLAY_STOCK);
    toolbar.add(&amp;play_button);

    let stop_button = ToolButton::new_from_stock("gtk-media-stop");
    toolbar.add(&amp;stop_button);

    let next_button = ToolButton::new_from_stock("gtk-media-next");
    toolbar.add(&amp;next_button);

    toolbar.add(&amp;SeparatorToolItem::new());

    let remove_button = ToolButton::new_from_stock("gtk-remove");
    toolbar.add(&amp;remove_button);

    toolbar.add(&amp;SeparatorToolItem::new());

    let quit_button = ToolButton::new_from_stock("gtk-quit");
    toolbar.add(&amp;quit_button);</pre>
<p class="calibre3">This code should go right before the call to <kbd class="calibre14">window.show_all()</kbd>.  <kbd class="calibre14">SeparatorToolItem</kbd> , which was added several times to separate the buttons logically so that buttons for similar actions are grouped together.</p>
<p class="calibre3">Now we have an application that is starting to look like a music player, as follows:</p>
<div><img src="img/00031.jpeg" class="calibre36"/></div>
<div><em class="calibre21">Figure 5.3</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Improving the organization of the application</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre14">main</kbd> function is starting to get bigger, so we'll refactor our code a little to make it easier to update in the upcoming sections and chapters.</p>
<p class="calibre3">First, we'll create a new module called <kbd class="calibre14">toolbar</kbd>. As a reminder, here's how to do so:</p>
<ol class="calibre16">
<li value="1" class="calibre11">Create a new file: <kbd class="calibre14">src/toolbar.rs</kbd>.</li>
<li value="2" class="calibre11">Add a statement, <kbd class="calibre14">mod toolbar;</kbd>, at the top of the file <kbd class="calibre14">main.rs</kbd>.</li>
</ol>
<p class="calibre3">This new module <kbd class="calibre14">toolbar</kbd> will start with the import statement and the <kbd class="calibre14">const</kbd> declaration:</p>
<pre class="calibre22">use gtk::{
    ContainerExt,
    SeparatorToolItem,
    Toolbar,
    ToolButton,
};

const PLAY_STOCK: &amp;str = "gtk-media-play";</pre>
<p class="calibre3">We'll then create a new structure holding all the widgets that compose the toolbar:</p>
<pre class="calibre22">pub struct MusicToolbar {
    open_button: ToolButton,
    next_button: ToolButton,
    play_button: ToolButton,
    previous_button: ToolButton,
    quit_button: ToolButton,
    remove_button: ToolButton,
    stop_button: ToolButton,
    toolbar: Toolbar,
}</pre>
<p class="calibre3">We use the <kbd class="calibre14">pub</kbd> keyword here because we want to be able to use this type from other modules.</p>
<p class="calibre3">Then, we'll create a constructor for this <kbd class="calibre14">struct</kbd> that will create all the buttons, like we did earlier:</p>
<pre class="calibre22">impl MusicToolbar {
    pub fn new() -&gt; Self {
        let toolbar = Toolbar::new();

        let open_button = ToolButton::new_from_stock("gtk-open");
        toolbar.add(&amp;open_button);

        // ...

        let quit_button = ToolButton::new_from_stock("gtk-quit");
        toolbar.add(&amp;quit_button);

        MusicToolbar {
            open_button,
            next_button,
            play_button,
            previous_button,
            quit_button,
            remove_button,
            stop_button,
            toolbar
        }
    }
}</pre>
<p class="calibre3">The only difference with the previous code is that we now return a <kbd class="calibre14">struct MusicToolbar</kbd>. We'll also add a method in this <kbd class="calibre14">impl</kbd> to be able to access the <kbd class="calibre14">gtk::Toolbar</kbd> widget from the outside:</p>
<pre class="calibre23">    pub fn toolbar(&amp;self) -&gt; &amp;Toolbar {
        &amp;self.toolbar
    }</pre>
<p class="calibre3">That's all for now for this <kbd class="calibre14">toolbar</kbd> module. Let's go back to the <kbd class="calibre14">main</kbd> module. First, we need to import our new <kbd class="calibre14">MusicToolbar</kbd> type:</p>
<pre class="calibre22">use toolbar::MusicToolbar;</pre>
<p class="calibre3">Next, we'll create a structure like we did for our toolbar:</p>
<pre class="calibre22">struct App {
    toolbar: MusicToolbar,
    window: ApplicationWindow,
}</pre>
<p class="calibre3">And we will also create a constructor for it:</p>
<pre class="calibre22">impl App {
    fn new(application: Application) -&gt; Self {
        let window = ApplicationWindow::new(&amp;application);
        window.set_title("Rusic");

        let toolbar = MusicToolbar::new();
        window.add(toolbar.toolbar());

        window.show_all();

        let app = App {
            toolbar,
            window,
        };

        app.connect_events();

        app
    }
}</pre>
<p class="calibre3">Here, we created the window as we did before and then created our own <kbd class="calibre14">MusicToolbar</kbd> structure. We add the wrapped toolbar widget by sending the result of the <kbd class="calibre14">toolbar()</kbd> method (which returns the <kbd class="calibre14">gtk</kbd> widget) to the <kbd class="calibre14">add()</kbd> method.</p>
<p class="calibre3">After that, we used a little trick that enabled us to call a method on the <kbd class="calibre14">struct</kbd> yet to be created; we first assign the <kbd class="calibre14">struct</kbd> to a variable, then call the method and return the variable. This method is defined next, within the same <kbd class="calibre14">impl</kbd> block:</p>
<pre class="calibre23">    fn connect_events(&amp;self) {
    }</pre>
<p class="calibre3">We'll fill in this method in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding tool button events</h1>
                
            
            
                
<p class="calibre3">We'll continue by adding event handlers to some of the buttons.</p>
<p class="calibre3">First of all, we'll need new <kbd class="calibre14">use</kbd> statements:</p>
<pre class="calibre22">use gtk::{
    ToolButtonExt,
    WidgetExt,
};

use App;</pre>
<p class="calibre3">We import <kbd class="calibre14">ToolButtonExt</kbd>, which provides methods to be called on <kbd class="calibre14">ToolButton</kbd> and <kbd class="calibre14">App</kbd> from the <kbd class="calibre14">main</kbd> module, because we'll add a new method to this type:</p>
<pre class="calibre22">impl App {
    pub fn connect_toolbar_events(&amp;self) {
        let window = self.window.clone();
        self.toolbar.quit_button.connect_clicked(move |_| {
            window.destroy();
        });
    }
}</pre>
<p class="calibre3">In Rust, it's perfectly valid to declare a method in a module different to where the type was created. Here, we say that clicking the quit button will destroy the window, which will effectively exit the application.</p>
<p class="calibre3">Let's add another event that will toggle the play button image with the pause image:</p>
<pre class="calibre23">    let play_button = self.toolbar.play_button.clone();
    self.toolbar.play_button.connect_clicked(move |_| {
        if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
            play_button.set_stock_id(PAUSE_STOCK);
        } else {
            play_button.set_stock_id(PLAY_STOCK);
       }
    });</pre>
<p class="calibre3">This code requires a new constant to be added next to <kbd class="calibre14">PLAY_STOCK</kbd>:</p>
<pre class="calibre22">const PAUSE_STOCK: &amp;str = "gtk-media-pause";</pre>
<p class="calibre3">Let's first look at the body of the closure before looking at the peculiarities of this code. Here, we use a condition to check whether the button is showing the play image—if it is, we switch to the pause stock item. Otherwise, we switch back to the play icon.</p>
<p class="calibre3">But why do we need to clone the button and use this <kbd class="calibre14">move</kbd> keyword before the closure? Let's try the normal way, that is, how you would do that in most programming languages:</p>
<pre class="calibre22">self.toolbar.play_button.connect_clicked(|_| {
    if self.toolbar.play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
        self.toolbar.play_button.set_stock_id(PAUSE_STOCK);
    } else {
        self.toolbar.play_button.set_stock_id(PLAY_STOCK);
    }
});</pre>
<p class="calibre3">If we do that, we get the following compilation error:</p>
<pre class="calibre23"><strong class="calibre5">error[E0477]: the type `[closure@src/toolbar.rs:79:50: 85:10 self:&amp;&amp;App]` does not fulfill the required lifetime
  --&gt; src/toolbar.rs:79:34
   |
79 |         self.toolbar.play_button.connect_clicked(|_| {
   |                                  ^^^^^^^^^^^^^^^
   |
   = note: type must satisfy the static lifetime

error[E0495]: cannot infer an appropriate lifetime for capture of `self` by closure due to conflicting requirements
  --&gt; src/toolbar.rs:79:50
   |
79 |           self.toolbar.play_button.connect_clicked(|_| {
   |  __________________________________________________^
80 | |             if self.toolbar.play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
81 | |                 self.toolbar.play_button.set_stock_id(PAUSE_STOCK);
82 | |             } else {
83 | |                 self.toolbar.play_button.set_stock_id(PLAY_STOCK);
84 | |             }
85 | |         });
   | |_________^</strong></pre>
<p class="calibre3">And it continues even further to explain why the lifetime cannot be inferred.</p>
<p class="calibre3">Let's look at the signature of the <kbd class="calibre14">connect_clicked()</kbd> method to understand what's going on:</p>
<pre class="calibre22">fn connect_clicked&lt;F: Fn(&amp;Self) + 'static&gt;(&amp;self, f: F) -&gt; u64</pre>
<p class="calibre3">The <kbd class="calibre14">Fn(&amp;Self)</kbd> part means the function requires something that looks like a function that takes a parameter that is a reference to <kbd class="calibre14">Self</kbd> (<kbd class="calibre14">ToolButton</kbd> in this case). The <kbd class="calibre14">'static</kbd> part is a lifetime annotation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lifetime</h1>
                
            
            
                
<p class="calibre3">Lifetime is one of the Rust features that the compiler uses to ensure memory safety. The lifetime specifies the minimum duration an object must live to be used safely. Let's try to do something that is allowed in certain programming languages, but is actually an error to do so:</p>
<pre class="calibre22">fn get_element_inc(elements: &amp;[i32], index: usize) -&gt; &amp;i32 {
    let element = elements[index] + 1;
    &amp;element
}</pre>
<p class="calibre3">Here, we try to return a reference from a stack-allocated value. The problem is that this value will be deallocated when the function returns and the caller will try to access this deallocated value. In other programming languages, this code will compile fine and produce (hopefully) a segmentation fault at runtime. But Rust is a safe programming language and refuses to compile such code:</p>
<pre class="calibre23"><strong class="calibre5">error[E0597]: `element` does not live long enough
 --&gt; src/main.rs:3:6
  |
3 |     &amp;element
  |      ^^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here</strong></pre>
<p class="calibre3">The compile noticed that the value <kbd class="calibre14">element</kbd> will be deallocated at the end of the function; that's what the sentence on the last line means. This is right, because the lifetime of <kbd class="calibre14">element</kbd> starts from its declaration until the end of the scope where it is declared; here, the scope is the function. Here's an illustration of the lifetime of <kbd class="calibre14">element</kbd>:</p>
<div><img src="img/00032.jpeg" class="calibre61"/></div>
<div><em class="calibre21">Figure 5.4</em></div>
<p class="calibre3">But how does the compiler know what the required lifetime is for the returned value? To answer this question, let's add the lifetime annotations that were added by the compiler:</p>
<pre class="calibre22">fn get_element_inc&lt;'a&gt;(elements: &amp;'a [i32], index: usize) -&gt; &amp;'a i32 {
    let element = elements[index] + 1;
    &amp;element
}</pre>
<p class="calibre3">As you can see, the syntax for lifetimes is the same as the one used for labels—<kbd class="calibre14">'label</kbd>. When we want to specify the lifetimes, we need to declare the lifetime names between angle brackets, in a similar way to how we declare generic types. In this case, we specified that the lifetime of the returned value must be the same as the one from the parameter <kbd class="calibre14">elements</kbd>.</p>
<p class="calibre3">Let's annotate the code again with lifetimes:</p>
<div><img src="img/00033.jpeg" class="calibre62"/></div>
<div><em class="calibre21">Figure 5.5</em></div>
<p class="calibre3">Here, we clearly see that the lifetime of the returned value is smaller than the required one; that's why the compiler rejected our code.</p>
<p class="calibre3">In this case, there are two ways to fix this code (without changing the signature). One way to get a value that satisfies the lifetime <kbd class="calibre14">'a</kbd> is to get a reference to a value of the same lifetime; the parameter <kbd class="calibre14">elements</kbd> also has the lifetime <kbd class="calibre14">'a</kbd> , so we can write the following code:</p>
<pre class="calibre22">fn get_element&lt;'a&gt;(elements: &amp;'a [i32], index: usize) -&gt; &amp;'a i32 {
    &amp;elements[index]
}</pre>
<p class="calibre3">Another way is to return a reference to a value of lifetime <kbd class="calibre14">'static</kbd>. This special lifetime is equal to the duration of the program, that is, the value must live until the end of the program. One way to get such a lifetime is to use a literal:</p>
<pre class="calibre22">fn get_element&lt;'a&gt;(elements: &amp;'a [i32], index: usize) -&gt; &amp;'a i32 {
    &amp;42
}</pre>
<p class="calibre3">The lifetime <kbd class="calibre14">'static</kbd> satisfies the constraint <kbd class="calibre14">'a</kbd> because <kbd class="calibre14">'static</kbd> lives longer than the latter.</p>
<p class="calibre3">In both of these examples, the lifetime annotations were not required. We didn't have to specify the lifetime in the first place, thanks to a feature called lifetime elision; the compiler can infer what the required lifetimes are in most cases by following these simple rules:</p>
<ul class="calibre10">
<li class="calibre11">A different lifetime parameter is assigned to each parameter</li>
<li class="calibre11">If there's only one parameter that needs a lifetime, that lifetime is assigned to every lifetime in the return value (as for our <kbd class="calibre14">get_element</kbd> function)</li>
<li class="calibre11">If there are multiple parameters that need a lifetime, but one of them is for <kbd class="calibre14">&amp;self</kbd>, the lifetime for <kbd class="calibre14">self</kbd> is assigned to every lifetime in the return value</li>
</ul>
<p class="calibre3">Let's go back to the method signature:</p>
<pre class="calibre22">fn connect_clicked&lt;F: Fn(&amp;Self) + 'static&gt;(&amp;self, f: F) -&gt; u64</pre>
<p class="calibre3">Here, we notice that the parameter <kbd class="calibre14">f</kbd> has the <kbd class="calibre14">'static</kbd> lifetime. We now know that this means that this parameter must live until the end of the program. That's why we cannot use the <em class="calibre21">normal</em> version of the closure: because the lifetime of <kbd class="calibre14">self</kbd> is not <kbd class="calibre14">'static</kbd> , meaning the <kbd class="calibre14">app</kbd> will get deallocated when the <kbd class="calibre14">main</kbd> function ends. To make this work, we cloned the <kbd class="calibre14">play_button</kbd> variable:</p>
<pre class="calibre22">let play_button = self.toolbar.play_button.clone();</pre>
<p class="calibre3">Now we can use this new variable in the closure.</p>
<div><p class="calibre24">Note: Take note that cloning a GTK+ widget is really cheap; only a pointer is cloned.</p>
</div>
<p class="calibre3">However, trying to do the following will still result in a compilation error:</p>
<pre class="calibre22">let play_button = self.toolbar.play_button.clone();
self.toolbar.play_button.connect_clicked(|_| {
    if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
        play_button.set_stock_id(PAUSE_STOCK);
    } else {
        play_button.set_stock_id(PLAY_STOCK);
    }
});</pre>
<p class="calibre3">Here's the error:</p>
<pre class="calibre23"><strong class="calibre5">error[E0373]: closure may outlive the current function, but it borrows `play_button`, which is owned by the current function
  --&gt; src/toolbar.rs:80:50
   |
80 |         self.toolbar.play_button.connect_clicked(|_| {
   |                                                  ^^^ may outlive borrowed value `play_button`
81 |             if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
   |                ----------- `play_button` is borrowed here
   |
help: to force the closure to take ownership of `play_button` (and any other referenced variables), use the `move` keyword
   |
80 |         self.toolbar.play_button.connect_clicked(move |_| {
   |                                                  ^^^^^^^^</strong></pre>
<p class="calibre3">The problem with this code is that the closure can (and will) be called after the function returns, but the variable button is declared in the method <kbd class="calibre14">connect_toolbar_events()</kbd> and will be deallocated when it returns. Again, Rust prevents us from having a segmentation fault by checking if we correctly use references. The compiler talks about ownership; let's look at what that is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Ownership</h1>
                
            
            
                
<p class="calibre3">In Rust, there's no garbage collector to deallocate the memory when it's not needed anymore. Also, there's no need for the programmer to specify where the memory should be deallocated. But how can this work? The compiler is able to determine when to deallocate the memory thanks to the concept of ownership; only one variable can own a value. By this simple rule, the matter of when to deallocate the value is simple: when the owner goes out of scope, the value is deallocated.</p>
<p class="calibre3">Let's see an example of how deallocation is related to scope:</p>
<pre class="calibre22">let mut vec = vec!["string".to_string()];
if !vec.is_empty() {
    let element = vec.remove(0);
    // element is deallocated at the end of this scope.
}</pre>
<p class="calibre3">Here, we remove an element from the vector in a new scope—the block for the condition. The variable <kbd class="calibre14">element</kbd> will own the value that was removed from the vector (we also say that the value was moved from the vector to the variable <kbd class="calibre14">element</kbd>). Since it owns the value, the variable is not responsible for deallocating it when it goes out of scope. Thus, after the condition, the value <kbd class="calibre14">"string"</kbd> will be freed and cannot be accessed anymore.</p>
<p class="calibre3">Let's get back to our code:</p>
<pre class="calibre22">self.toolbar.play_button.connect_clicked(move |_| {
    if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
        play_button.set_stock_id(PAUSE_STOCK);
    } else {
        play_button.set_stock_id(PLAY_STOCK);
    }
});</pre>
<p class="calibre3">We added the keyword <kbd class="calibre14">move</kbd> to closure to indicate that the value must be moved into the closure. (That's actually what the compiler told us to do, if you remember the error message.) By doing so, we satisfy the borrow checker because the value is not borrowed anymore. This was causing a lifetime error, but has now been moved into the closure and will thus live as long as the closure itself.</p>
<p class="calibre3">Don't forget to add the call to this method in the method <kbd class="calibre14">App::new()</kbd>, right after the call to <kbd class="calibre14">connect_events()</kbd>:</p>
<pre class="calibre22">app.connect_events();
app.connect_toolbar_events();</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Containers</h1>
                
            
            
                
<p class="calibre3">We'll now add other widgets to our window: an image to show the cover of the song that is currently being played and a cursor to see the progression of the music. However, it is not possible to add multiple widgets to a window. To do so, we need to use containers.</p>
<p class="calibre3">Containers are a way to manage how multiple widgets will be shown.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Types of containers</h1>
                
            
            
                
<p class="calibre3">Here are simple non-visual containers:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">gtk::Box</kbd>: disposes widgets either horizontally or vertically</li>
<li class="calibre11"><kbd class="calibre14">gtk::Grid</kbd>: disposes widgets in rows and columns, like a table</li>
<li class="calibre11"><kbd class="calibre14">gtk::Fixed</kbd>: displays widgets at a very specific position in pixels</li>
<li class="calibre11"><kbd class="calibre14">gtk::Stack</kbd>: displays only one widget at a time</li>
</ul>
<p class="calibre3">All of these widgets, except <kbd class="calibre14">gtk::Fixed</kbd> , automatically rearrange the widgets when the window is resized. That's why you should avoid using this one.</p>
<p class="calibre3">Here are some more fancy containers:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">gtk::Notebook</kbd>: displays only one widget at a time, but the user can select which one to show by clicking on a tab</li>
<li class="calibre11"><kbd class="calibre14">gtk::Paned</kbd>: displays two widgets, separated by a handle that the user can drag to adjust the division between the widgets</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Box container</h1>
                
            
            
                
<p class="calibre3">We'll use a <kbd class="calibre14">gtk::Box</kbd> to arrange our widgets. First of all, remove the call to <kbd class="calibre14">Window::add()</kbd> that we added before:</p>
<pre class="calibre22">window.add(toolbar.toolbar());</pre>
<p class="calibre3">We remove this call because we'll instead add the toolbar to the box and the box to the window. Let's do that, but before we do, we'll add a couple of new imports:</p>
<pre class="calibre22">use gtk::{
    Adjustment,
    Image,
    ImageExt,
    Scale,
    ScaleExt,
};
use gtk::Orientation::{Horizontal, Vertical};</pre>
<p class="calibre3">Then, we create the box:</p>
<pre class="calibre22">let vbox = gtk::Box::new(Vertical, 0);
window.add(&amp;vbox);</pre>
<p class="calibre3">(This code goes into the <kbd class="calibre14">App::new()</kbd> method.)</p>
<p class="calibre3">Here, we fully qualified <kbd class="calibre14">gtk::Box</kbd> because <kbd class="calibre14">Box</kbd> is a type from the standard library that is automatically imported. We specified that the orientation of the box is vertical and there's no spacing (<kbd class="calibre14">0</kbd>) between the children widgets of the container.</p>
<p class="calibre3">Now we're ready to add widgets to this box:</p>
<pre class="calibre22">let toolbar = MusicToolbar::new();
vbox.add(toolbar.toolbar());

let cover = Image::new();
cover.set_from_file("cover.jpg");
vbox.add(&amp;cover);</pre>
<p class="calibre34">We first add our toolbar, then add an image and load a cover from a static file because we haven't yet written the code to extract the cover from an MP3 file.</p>
<p class="calibre3">Let's also add the cursor widget:</p>
<pre class="calibre22">let adjustment = Adjustment::new(0.0, 0.0, 10.0, 0.0, 0.0, 0.0);
let scale = Scale::new(Horizontal, &amp;adjustment);
scale.set_draw_value(false);
vbox.add(&amp;scale);</pre>
<p class="calibre3">The cursor widget is named <kbd class="calibre14">Scale</kbd>. This widget needs an <kbd class="calibre14">Adjustment</kbd>, which is an object that represents which values the cursor can take, and also contains the current value and the increment values. Again, since we don't know how to fetch the duration of a song from an MP3 file, we hardcode values for  <kbd class="calibre14">Adjustment</kbd>. We also disable the feature to show the actual value of the cursor by calling <kbd class="calibre14">set_draw_value(false)</kbd>.</p>
<p class="calibre3">If you run the application, you'll see the following:</p>
<div><img src="img/00034.jpeg" class="calibre63"/></div>
<div><em class="calibre21">Figure 5.6</em></div>
<p class="calibre3">(We can almost hear the music when looking at it.)</p>
<p class="calibre3">To conclude this section, we'll add a few fields to the <kbd class="calibre14">App</kbd> structure so that it becomes:</p>
<pre class="calibre22">struct App {
    adjustment: Adjustment,
    cover: Image,
    toolbar: MusicToolbar,
    window: ApplicationWindow,
}</pre>
<p class="calibre3">The end of the <kbd class="calibre14">App</kbd> constructor is then updated to:</p>
<pre class="calibre22">impl App {
    fn new(application: Application) -&gt; Self {
        // ...

        window.show_all();

        let app = App {
            adjustment,
            cover,
            toolbar,
            window,
        };

        app.connect_events();
        app.connect_toolbar_events();

        app
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a playlist</h1>
                
            
            
                
<p class="calibre3">We're now ready to add the playlist widget to our music player.</p>
<p class="calibre3">We'll use new crates, so add the following to the <kbd class="calibre14">main.rs</kbd> file:</p>
<pre class="calibre22">extern crate gdk_pixbuf;
extern crate id3;</pre>
<p class="calibre3">The crate <kbd class="calibre14">gdk_pixbuf</kbd> will be used to show and manipulate the cover and the <kbd class="calibre14">id3</kbd> crate to get the metadata from MP3 files.</p>
<p class="calibre3">Also, add the following to <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre22">gdk-pixbuf = "^0.3.0"
id3 = "^0.2.0"</pre>
<p class="calibre3">Next, we'll create a new module to contain this new widget:</p>
<pre class="calibre22">mod playlist;</pre>
<p class="calibre3">We'll start this module by adding a bunch of <kbd class="calibre14">use</kbd> statements:</p>
<pre class="calibre22">use std::path::Path;

use gdk_pixbuf::{InterpType, Pixbuf, PixbufLoader};
use gtk::{
    CellLayoutExt,
    CellRendererPixbuf,
    CellRendererText,
    ListStore,
    ListStoreExt,
    ListStoreExtManual,
    StaticType,
    ToValue,
    TreeIter,
    TreeModelExt,
    TreeSelectionExt,
    TreeView,
    TreeViewColumn,
    TreeViewColumnExt,
    TreeViewExt,
    Type,
    WidgetExt,
};
use id3::Tag;</pre>
<p class="calibre3">These will be followed by some constants:</p>
<pre class="calibre22">const THUMBNAIL_COLUMN: u32 = 0;
const TITLE_COLUMN: u32 = 1;
const ARTIST_COLUMN: u32 = 2;
const ALBUM_COLUMN: u32 = 3;
const GENRE_COLUMN: u32 = 4;
const YEAR_COLUMN: u32 = 5;
const TRACK_COLUMN: u32 = 6;
const PATH_COLUMN: u32 = 7;
const PIXBUF_COLUMN: u32 = 8;

const IMAGE_SIZE: i32 = 256;
const THUMBNAIL_SIZE: i32 = 64;</pre>
<p class="calibre3">The <kbd class="calibre14">*_COLUMN</kbd> constant represents the column we'll show in the playlist. The last one, <kbd class="calibre14">PIXBUF_COLUMN</kbd>, is a bit special: it will be a hidden column holding the cover of a bigger size so that we can show this image in the <kbd class="calibre14">cover</kbd> widget we created earlier.</p>
<p class="calibre3">Next, we'll create a new structure to hold the widget and its model:</p>
<pre class="calibre22">pub struct Playlist {
    model: ListStore,
    treeview: TreeView,
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The MVC pattern</h1>
                
            
            
                
<p class="calibre3">For the list and tree widgets, GTK+ follows the MVC pattern. MVC stands for Model-View-Controller.</p>
<p class="calibre3">Now we can add a constructor for our playlist:</p>
<pre class="calibre22">impl Playlist {
    pub fn new() -&gt; Self {
        let model = ListStore::new(&amp;[
            Pixbuf::static_type(),
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Type::String,
            Pixbuf::static_type(),
        ]);
        let treeview = TreeView::new_with_model(&amp;model);
        treeview.set_hexpand(true);
        treeview.set_vexpand(true);

        Self::create_columns(&amp;treeview);

        Playlist {
            model,
            treeview,
        }
    }
}</pre>
<p class="calibre3">The <kbd class="calibre14">gtk::ListStore</kbd> type is a model to represent the data as a list. Its constructor needs the types of the columns; in this case, most of the types are strings for the metadata of the MP3 files, such as the song title and author name. The first <kbd class="calibre14">Pixbuf</kbd> is for the thumbnail image and the last one is for the bigger image only shown for the music currently playing.</p>
<p class="calibre3">Next, we create a <kbd class="calibre14">TreeView</kbd>, which will actually be a view for a list since we initialize it with our list model. We then modify the widget so that it expands both vertically and horizontally, meaning that the widget will use as much space as possible. Finally, just before we return the <kbd class="calibre14">struct Playlist</kbd>, we call the <kbd class="calibre14">create_columns()</kbd> method, which will create the columns to be shown in this view. Let's see this new method:</p>
<pre class="calibre23">    fn create_columns(treeview: &amp;TreeView) {
        Self::add_pixbuf_column(treeview, THUMBNAIL_COLUMN as i32, <br class="calibre6"/>         Visible);
        Self::add_text_column(treeview, "Title", TITLE_COLUMN as i32);
        Self::add_text_column(treeview, "Artist", ARTIST_COLUMN as i32);
        Self::add_text_column(treeview, "Album", ALBUM_COLUMN as i32);
        Self::add_text_column(treeview, "Genre", GENRE_COLUMN as i32);
        Self::add_text_column(treeview, "Year", YEAR_COLUMN as i32);
        Self::add_text_column(treeview, "Track", TRACK_COLUMN as i32);
        Self::add_pixbuf_column(treeview, PIXBUF_COLUMN as i32, Invisible);
    }</pre>
<p class="calibre3">Here, we call two methods to create the different types of columns—we specify the header label and the column number of every column. As for the last parameter of the <kbd class="calibre14">add_pixbuf_column()</kbd> method, it indicates whether the column is visible or not. This parameter is of a custom type, so let's declare it:</p>
<pre class="calibre22">use self::Visibility::*;

#[derive(PartialEq)]
enum Visibility {
    Invisible,
    Visible,
}</pre>
<p class="calibre3">We also added a <kbd class="calibre14">use</kbd> statement to be able to directly use <kbd class="calibre14">Visible</kbd> instead of having to fully qualify it (<kbd class="calibre14">Visibility::Visible</kbd>).</p>
<p class="calibre3">Let's write the <kbd class="calibre14">add_text_column()</kbd> method:</p>
<pre class="sourcecode">    fn add_text_column(treeview: &amp;TreeView, title: &amp;str, column: i32) {
        let view_column = TreeViewColumn::new();
        view_column.set_title(title);
        let cell = CellRendererText::new();
        view_column.set_expand(true);
        view_column.pack_start(&amp;cell, true);
        view_column.add_attribute(&amp;cell, "text", column);
        treeview.append_column(&amp;view_column);
    }</pre>
<p class="calibre3">We start by creating the column itself and setting the label of the header by calling <kbd class="calibre14">set_title()</kbd>. Then, we create a <kbd class="calibre14">CellRenderer</kbd>, which indicates how the data from the model should be rendered in the view; here, we only want to show some text, so we chose <kbd class="calibre14">CellRendererText</kbd>, we set it to take up as much space as possible, and added the renderer to the column. Next comes a very important line:</p>
<pre class="calibre22">view_column.add_attribute(&amp;cell, "text", column);</pre>
<p class="calibre3">This line specifies that the view will set the <kbd class="calibre14">text</kbd> attribute from the data that comes from the model at the specified column.</p>
<p class="calibre3">At the end, we add the column to the view.</p>
<p class="calibre3">Now we'll write a similar function for the <kbd class="calibre14">pixbuf</kbd>:</p>
<pre class="calibre23">    fn add_pixbuf_column(treeview: &amp;TreeView, column: i32, visibility:<br class="calibre6"/>    Visibility) {
        let view_column = TreeViewColumn::new();
        if visibility == Visible {
            let cell = CellRendererPixbuf::new();
            view_column.pack_start(&amp;cell, true);
            view_column.add_attribute(&amp;cell, "pixbuf", column);
        }
        treeview.append_column(&amp;view_column);
    }</pre>
<p class="calibre3">Here, we create a new type of renderer (<kbd class="calibre14">CellRendererPixbuf</kbd>), which will show an image instead of text. This time, we set the <kbd class="calibre14">pixbuf</kbd> attribute because we want to show an image. The renderer is only created if the column is visible.</p>
<p class="calibre3">Now, all that's left is to write a function to get the actual widget to be able to add the widget in the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre23">    pub fn view(&amp;self) -&gt; &amp;TreeView {
        &amp;self.treeview
    }</pre>
<p class="calibre3">Let's go back to the method <kbd class="calibre14">App::new()</kbd> and create the playlist:</p>
<pre class="calibre22">let playlist = Playlist::new();
vbox.add(playlist.view());</pre>
<p class="calibre3">(Add this code right before creating the <kbd class="calibre14">Image</kbd>.)</p>
<p class="calibre3">We'll also add a <kbd class="calibre14">playlist</kbd> attribute in the structure:</p>
<pre class="calibre22">struct App {
    adjustment: Adjustment,
    cover: Image,
    playlist: Playlist,
    toolbar: MusicToolbar,
    window: Window,
}</pre>
<p class="calibre3">Also, don't forget to edit the creation of the structure to include the following new field:</p>
<pre class="calibre22">let app = App {
    adjustment,
    cover,
    playlist,
    toolbar,
    window,
};</pre>
<p class="calibre3">We're now ready to launch our application again to see an empty playlist:</p>
<div><img src="img/00035.jpeg" class="calibre64"/></div>
<div><em class="calibre21"><em class="calibre21">Figure 5.7</em></em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Opening MP3 files</h1>
                
            
            
                
<p class="calibre3">Let's finish this chapter by adding the ability to open MP3 files and show their metadata in the playlist widget we just created.</p>
<p class="calibre3">First of all, we'll remove this line:</p>
<pre class="calibre22">cover.set_from_file("cover.jpg");</pre>
<p class="calibre3">This is because the image will be set from the data of the MP3 files we play.</p>
<p class="calibre3">We'll use a new crate, so add this line in the <kbd class="calibre14">[dependencies]</kbd> section of your <kbd class="calibre14">Cargo.toml</kbd>:</p>
<pre class="calibre22">gtk-sys = "^0.5.0"</pre>
<p class="calibre3">Also, add the following line to your <kbd class="calibre14">main.rs</kbd>:</p>
<pre class="calibre22">extern crate gtk_sys;</pre>
<p class="calibre3">The <kbd class="calibre14">*-sys</kbd> crates of the <kbd class="calibre14">gtk-rs</kbd> ecosystem are low-level crates, the ones that directly bind to the GTK+ C library. Since they're very low-level and require the use of unsafe code, wrappers have been made; these are crates without the <kbd class="calibre14">-sys</kbd> suffix, such as <kbd class="calibre14">gtk</kbd> and <kbd class="calibre14">gdk</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reference-counting pointer</h1>
                
            
            
                
<p class="calibre3">We'll also change some code before we continue. Since we'll want to share our <kbd class="calibre14">Playlist</kbd> widget with different parts of our code, including some event handlers, we need a way of sharing a reference that will last long enough (remember the issue we had with the lifetime). One easy way of doing so is to use a reference-counting pointer type—<kbd class="calibre14">Rc</kbd>. So, in our <kbd class="calibre14">App</kbd> structure, let's change the <kbd class="calibre14">playlist</kbd> field to use an <kbd class="calibre14">Rc</kbd>:</p>
<pre class="calibre22">struct App {
    adjustment: Adjustment,
    cover: Image,
    playlist: Rc&lt;Playlist&gt;,
    toolbar: MusicToolbar,
    window: Window,
}</pre>
<p class="calibre3">This requires a new import at the top of the <kbd class="calibre14">main</kbd> module:</p>
<pre class="calibre22">use std::rc::Rc;</pre>
<p class="calibre3">Also, the creation of the playlist needs to be updated:</p>
<pre class="calibre22">let playlist = Rc::new(Playlist::new());</pre>
<p class="calibre3">We now wrap the <kbd class="calibre14">Paylist</kbd> inside an <kbd class="calibre14">Rc</kbd>. We can still use the playlist like before, as long as we're calling immutable methods, that is, methods that take <kbd class="calibre14">&amp;self</kbd> but not <kbd class="calibre14">&amp;mut self</kbd>. So, the next line is still valid:</p>
<pre class="calibre22">vbox.add(playlist.view());</pre>
<p class="calibre3">Before we create the method to add an MP3 file to the playlist, we'll need another method to set the <kbd class="calibre14">pixbuf</kbd> values in the model from the MP3 metadata. In the <kbd class="calibre14">impl Playlist</kbd>, add the following method:</p>
<pre class="calibre22">const INTERP_HYPER: InterpType = 3;

    fn set_pixbuf(&amp;self, row: &amp;TreeIter, tag: &amp;Tag) {
        if let Some(picture) = tag.pictures().next() {
            let pixbuf_loader = PixbufLoader::new();
            pixbuf_loader.set_size(IMAGE_SIZE, IMAGE_SIZE);
            pixbuf_loader.loader_write(&amp;picture.data).unwrap();
            if let Some(pixbuf) = pixbuf_loader.get_pixbuf() {
                let thumbnail = pixbuf.scale_simple(THUMBNAIL_SIZE, <br class="calibre6"/>                THUMBNAIL_SIZE, INTERP_HYPER).unwrap();
                self.model.set_value(row, THUMBNAIL_COLUMN,<br class="calibre6"/>                 &amp;thumbnail.to_value());
                self.model.set_value(row, PIXBUF_COLUMN, <br class="calibre6"/>                 &amp;pixbuf.to_value());
            }
            pixbuf_loader.close().unwrap();
        }
    }</pre>
<p class="calibre3">The type <kbd class="calibre14">Tag</kbd> represents the metadata of an MP3 file. We get the first picture contained in the file and we load it. If the loading was successful, we resize it to get a thumbnail and then we set the values in the model.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">ID3— MP3 metadata</h1>
                
            
            
                
<p class="calibre3">We're now ready to get all the relevant metadata from the MP3 files and add them to the playlist. Let's start the <kbd class="calibre14">Playlist::add()</kbd> method by fetching the metadata:</p>
<pre class="calibre23">    pub fn add(&amp;self, path: &amp;Path) {
        let filename =  <br class="calibre6"/>         path.file_stem().unwrap_or_default().to_str().unwrap_or_default();

        let row = self.model.append();

        if let Ok(tag) = Tag::read_from_path(path) {
            let title = tag.title().unwrap_or(filename);
            let artist = tag.artist().unwrap_or("(no artist)");
            let album = tag.album().unwrap_or("(no album)");
            let genre = tag.genre().unwrap_or("(no genre)");
            let year = tag.year().map(|year| <br class="calibre6"/>            year.to_string()).unwrap_or("(no  <br class="calibre6"/>            year)".to_string());
            let track = tag.track().map(|track| <br class="calibre6"/>            track.to_string()).unwrap_or("??".to_string());
            let total_tracks = tag.total_tracks().map(|total_tracks|  <br class="calibre6"/>            total_tracks.to_string()).unwrap_or("??".to_string());
            let track_value = format!("{} / {}", track, total_tracks);</pre>
<p class="calibre3">We first get the filename without the extension and convert it to a string; we'll show this if there's no song title in the file. Then, we read the metadata from the file and assign a default value such as <kbd class="calibre14">"(no artist)"</kbd> in case a value is missing by calling <kbd class="calibre14">unwrap_or()</kbd>, which gets the value from <kbd class="calibre14">Option</kbd> if or returns the argument if the value is <kbd class="calibre14">None</kbd>.</p>
<p class="calibre3">Now let's see the rest of the method:</p>
<pre class="calibre23">            self.set_pixbuf(&amp;row, &amp;tag);

            self.model.set_value(&amp;row, TITLE_COLUMN, &amp;title.to_value());
            self.model.set_value(&amp;row, ARTIST_COLUMN, &amp;artist.to_value());
            self.model.set_value(&amp;row, ALBUM_COLUMN, &amp;album.to_value());
            self.model.set_value(&amp;row, GENRE_COLUMN, &amp;genre.to_value());
            self.model.set_value(&amp;row, YEAR_COLUMN, &amp;year.to_value());
            self.model.set_value(&amp;row, TRACK_COLUMN, <br class="calibre6"/>             &amp;track_value.to_value());
        }
        else {
            self.model.set_value(&amp;row, TITLE_COLUMN, &amp;filename.to_value());
        }

        let path = path.to_str().unwrap_or_default();
        self.model.set_value(&amp;row, PATH_COLUMN, &amp;path.to_value());
    }</pre>
<p class="calibre3">Here, we create a new row in the model and call the <kbd class="calibre14">set_pixbuf()</kbd> we created just before. After that, we set the value in the new row. One special value is the path, which will be useful later when we want to play the selected song from the playlist; we'll only need to fetch the path and then play it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Opening files with a file dialog</h1>
                
            
            
                
<p class="calibre3">There's another function we'll need before we can handle the click event of the open button. We need a function that'll show a file dialog to allow the user to select a file:</p>
<pre class="calibre22">use std::path::PathBuf;

use gtk::{FileChooserAction, FileChooserDialog, FileFilter};

fn show_open_dialog(parent: &amp;ApplicationWindow) -&gt; Option&lt;PathBuf&gt; {
    let mut file = None;
    let dialog = FileChooserDialog::new(Some("Select an MP3 audio<br class="calibre6"/>     file"), <br class="calibre6"/>    Some(parent), FileChooserAction::Open);
    let filter = FileFilter::new();
    filter.add_mime_type("audio/mp3");
    filter.set_name("MP3 audio file");
    dialog.add_filter(&amp;filter);
    dialog.add_button("Cancel", RESPONSE_CANCEL);
    dialog.add_button("Accept", RESPONSE_ACCEPT);
    let result = dialog.run();
    if result == RESPONSE_ACCEPT {
        file = dialog.get_filename();
    }
    dialog.destroy();
    file
}</pre>
<p class="calibre3">This function starts by creating a new file dialog of the type <kbd class="calibre14">open</kbd>. Afterwards, it adds a filter to this dialog so that it only shows MP3 files. Then, we add two buttons using some constants that we'll define later. At the moment, we can show the dialog by calling <kbd class="calibre14">run()</kbd>; this function blocks until the dialog is closed and returns which button was clicked. After that, we check whether the accept button was clicked to save the filename that was selected by the user and we return that filename.</p>
<p class="calibre3">Here are the constants needed by the previous function:</p>
<pre class="calibre22">use gtk_sys::{GTK_RESPONSE_ACCEPT, GTK_RESPONSE_CANCEL};

const RESPONSE_ACCEPT: i32 = GTK_RESPONSE_ACCEPT as i32;
const RESPONSE_CANCEL: i32 = GTK_RESPONSE_CANCEL as i32;</pre>
<p class="calibre3">We're now ready to handle the click event of the open button. Add the following in the method <kbd class="calibre14">App::connect_toolbar_events()</kbd>:</p>
<pre class="calibre23">        let parent = self.window.clone();
        let playlist = self.playlist.clone();
        self.toolbar.open_button.connect_clicked(move |_| {
            let file = show_open_dialog(&amp;parent);
            if let Some(file) = file {
                playlist.add(&amp;file);
            }
        });</pre>
<p class="calibre3">In the event handler, we call the function we just defined and, if a file was selected, we call the <kbd class="calibre14">add()</kbd> method of the playlist.</p>
<p class="calibre3">You can now try the application and open an MP3 file. Here's what you'll see:</p>
<div><img src="img/00036.jpeg" class="calibre65"/></div>
<div><em class="calibre21">Figure 5.8</em></div>
<p class="calibre3">Let's add two more features before we end this chapter. The first one is to remove a song from the playlist.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deleting a song</h1>
                
            
            
                
<p class="calibre3">We need to add a method to the <kbd class="calibre14">Playlist</kbd> struct to remove the selected item:</p>
<pre class="calibre23">    pub fn remove_selection(&amp;self) {
        let selection = self.treeview.get_selection();
        if let Some((_, iter)) = selection.get_selected() {
            self.model.remove(&amp;iter);
        }
    }</pre>
<p class="calibre3">This first starts by getting the selection and, if there was one, we remove it from the model. We can now add an event handler for the remove button in the <kbd class="calibre14">App::connect_toolbar_events()</kbd> method:</p>
<pre class="calibre23">     let playlist = self.playlist.clone();
     self.toolbar.remove_button.connect_clicked(move |_| {
       playlist.remove_selection();
     });</pre>
<p class="calibre3">There's nothing new in this code; we simply clone the reference-counted playlist and call a method on it when the button is clicked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Displaying the cover when playing a song</h1>
                
            
            
                
<p class="calibre3">The other feature to add is to show a bigger cover when we click the play button. We'll start by adding a function to get the image from the selection in the playlist:</p>
<pre class="calibre23">    pub fn pixbuf(&amp;self) -&gt; Option&lt;Pixbuf&gt; {
        let selection = self.treeview.get_selection();
        if let Some((_, iter)) = selection.get_selected() {
            let value = self.model.get_value(&amp;iter, PIXBUF_COLUMN as i32);
            return value.get::&lt;Pixbuf&gt;();
        }
        None
    }</pre>
<p class="calibre3">This method to be added to the <kbd class="calibre14">Playlist</kbd> structure starts by getting the selection; if there's one, it simply gets the <kbd class="calibre14">pixbuf</kbd> from the model and returns it. Otherwise, it returns <kbd class="calibre14">None</kbd>.</p>
<p class="calibre3">We can now write a function that will fetch the cover from the playlist and show the image:</p>
<pre class="calibre22">use gtk::Image;

use playlist::Playlist;

fn set_cover(cover: &amp;Image, playlist: &amp;Playlist) {
    cover.set_from_pixbuf(playlist.pixbuf().as_ref());
    cover.show();
}</pre>
<p class="calibre3">Add this function in the <kbd class="calibre14">toolbar</kbd> module. And, finally, we can call this function from the click event handler of the play button:</p>
<pre class="calibre23">        let playlist = self.playlist.clone();
        let cover = self.cover.clone();
        self.toolbar.play_button.connect_clicked(move |_| {
            if play_button.get_stock_id() == Some(PLAY_STOCK.to_string()) {
                play_button.set_stock_id(PAUSE_STOCK);
                set_cover(&amp;cover, &amp;playlist);
            } else {
                play_button.set_stock_id(PLAY_STOCK);
            }
        });</pre>
<p class="calibre3">Here's the result after adding a song and clicking play:</p>
<div><img src="img/00037.jpeg" class="calibre66"/></div>
<div><em class="calibre21">Figure 5.9</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">This chapter started by showing you how to install GTK+ on your machine. You then learned how to use <kbd class="calibre14">gtk-rs</kbd> to create windows, to manage user events like mouse click, to add different types of widgets to your window, to arrange your widgets with containers, and to show beautiful icons with stock items. You also saw how to use complex GTK+ widgets that use the MVC pattern.</p>
<p class="calibre3">You also gained more knowledge of Rust in the areas of closures, lifetimes, and ownerships, which are key concepts in this language.</p>
<p class="calibre3">Finally, you learned how to extract the metadata of an MP3 file by getting the ID3 tags.</p>
<p class="calibre3">In the next chapter, we'll improve the music player so that it can actually play a song.</p>
<p class="calibre3"/>


            

            
        
    </body></html>