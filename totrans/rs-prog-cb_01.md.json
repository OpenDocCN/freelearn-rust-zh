["```rs\n$ rustc --version\nrustc 1.33.0 (2aa4c46cf 2019-02-28)\n```", "```rs\n{\n    \"rust-client.channel\":\"stable\"\n}\n```", "```rs\n$ rm -Rf ~/.rustup\n```", "```rs\nPS> rm ~/.rustup\n```", "```rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n```", "```rs\nuse std::io::{self, Write};\nuse std::f64;\n\nfn main() {\n    println!(\"Let's print some lines:\");\n    println!();\n    println!(\"Hello, world!\");\n    println!(\"{}, {}!\", \"Hello\", \"world\");\n    print!(\"Hello, \");\n    println!(\"world!\");\n```", "```rs\n    println!(\"Arguments can be referred to by their position: {0}, \n    {1}! and {1}, {0}! are built from the same arguments\", \"Hello\", \n    \"world\");\n\n    println!(\"Furthermore the arguments can be named: \\\"{greeting}, \n    {object}!\\\"\", greeting = \"Hello\", object = \"World\");\n\n    println!(\"Number formatting: Pi is {0:.3} or {0:.0} for short\", \n    f64::consts::PI);\n\n    println!(\"... and there is more: {0:>0width$}={0:>width$}=\n    {0:#x}\", 1535, width = 5);\n\n    let _ = write!(&mut io::stdout(), \"Underneath, it's all writing \n    to a stream...\");\n    println!();\n\n    println!(\"Write something!\");\n    let mut input = String::new();\n    if let Ok(n) = io::stdin().read_line(&mut input) {\n        println!(\"You wrote: {} ({} bytes) \", input, n);\n    }\n    else {\n        eprintln!(\"There was an error :(\");\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling hello-world v0.1.0 (/tmp/hello-world)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.37s\n     Running 'target/debug/hello-world'\nLet's print some lines:\n\nHello, world!\nHello, world!\nHello, world!\nArguments can be referred to by their position: Hello, world! and world, Hello! are built from the same arguments\nFurthermore the arguments can be named: \"Hello, World!\"\nNumber formatting: Pi is 3.142 or 3 for short\n... and there is more: 01535= 1535=0x5ff\nUnderneath, it's all writing to a stream...\nWrite something!\nHello, world!\nYou wrote: Hello, world!\n (14 bytes) \n```", "```rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n```", "```rs\n    #[test]\n    fn basic_math_stuff() {\n        assert_eq!(2 + 2, 4);\n\n        assert_eq!(3.14 + 22.86, 26_f32);\n\n        assert_eq!(2_i32.pow(2), 4);\n        assert_eq!(4_f32.sqrt(), 2_f32);\n\n        let a: u64 = 32;\n        let b: u64 = 64;\n\n        // Risky, this could overflow\n        assert_eq!(b - a, 32);\n        assert_eq!(a.overflowing_sub(b), (18446744073709551584, \n        true));\n        let mut c = 100;\n        c += 1;\n        assert_eq!(c, 101);\n    }\n```", "```rs\n    #[test]\n    #[should_panic]\n    fn attempt_overflows() {\n        let a = 10_u32;\n        let b = 11_u32;\n\n        // This will panic since the result is going to be an \n        // unsigned type which cannot handle negative numbers\n        // Note: _ means ignore the result\n        let _ = a - b; \n    }\n```", "```rs\n\n// Rust allows another macro type: derive. It allows to \"auto-implement\"\n// supported traits. Clone, Debug, Copy are typically handy to derive.\n#[derive(Clone, Debug, Copy)]\nstruct MyCustomStruct {\n    a: i32,\n    b: u32,\n    pub c: f32\n}\n\n// A typical Rust struct has an impl block for behavior\nimpl MyCustomStruct {\n\n    // The new function is static function, and by convention a \n    // constructor\n    pub fn new(a: i32, b: u32, c: f32) -> MyCustomStruct {\n        MyCustomStruct {\n            a: a, b: b, c: c\n        }\n    }\n\n    // Instance functions feature a \"self\" reference as the first \n    // parameter\n    // This self reference can be mutable or owned, just like other \n    // variables\n    pub fn sum(&self) -> f32 {\n        self.a as f32 + self.b as f32 + self.c\n    }\n}\n```", "```rs\n    use super::MyCustomStruct;\n\n    #[test]\n    fn test_custom_struct() {\n        assert_eq!(mem::size_of::<MyCustomStruct>(), \n            mem::size_of::<i32>() + mem::size_of::<u32>() + \n            mem::size_of::<f32>());\n\n        let m = MyCustomStruct::new(1, 2, 3_f32);\n        assert_eq!(m.a, 1);\n        assert_eq!(m.b, 2);\n        assert_eq!(m.c, 3_f32);\n\n        assert_eq!(m.sum(), 6_f32);\n        let m2 = m.clone();\n        assert_eq!(format!(\"{:?}\", m2), \"MyCustomStruct { a: 1, b: \n         2, \n        c: 3.0 }\");\n\n        let mut m3 = m;        \n        m3.a = 100;\n\n        assert_eq!(m2.a, 1);\n        assert_eq!(m.a, 1);\n        assert_eq!(m3.a, 100);\n    }\n```", "```rs\n$ cargo test\nCompiling data-types v0.1.0 (Rust-Cookbook/Chapter01/data-types)\nwarning: method is never used: `new`\n  --> src/lib.rs:13:5\n   |\n13 | pub fn new(a: i32, b: u32, c: f32) -> MyCustomStruct {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: #[warn(dead_code)] on by default\n\nwarning: method is never used: `sum`\n  --> src/lib.rs:19:5\n   |\n19 | pub fn sum(&self) -> f32 {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.50s\n     Running target/debug/deps/data_types-33e3290928407ff5\n\nrunning 3 tests\ntest tests::basic_math_stuff ... ok\ntest tests::attempt_overflows ... ok\ntest tests::test_custom_struct ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests data-types\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n```", "```rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn conditionals() {\n        let i = 20;\n        // Rust's if statement does not require parenthesis\n        if i < 2 {\n            assert!(i < 2);\n        } else if i > 2 {\n            assert!(i > 2);\n        } else {\n            assert_eq!(i, 2);\n        }\n    }\n}\n```", "```rs\n    #[test]\n    fn more_conditionals() {\n        let my_option = Some(10);\n\n        // If let statements can do simple pattern matching\n        if let Some(unpacked) = my_option {\n            assert_eq!(unpacked, 10);\n        } \n\n        let mut other_option = Some(2);\n        // there is also while let, which does the same thing\n        while let Some(unpacked) = other_option {\n\n            // if can also return values in assignments\n            other_option = if unpacked > 0 {\n                Some(unpacked - 1)\n            } else { \n                None\n            }\n        }\n        assert_eq!(other_option, None)\n    }\n```", "```rs\n    #[test]\n    fn loops() {\n\n        let mut i = 42;\n        let mut broke = false;\n\n        // a basic loop with control statements\n        loop {\n            i -= 1;\n            if i < 2 {\n                broke = true;\n                break;\n            } else if i > 2 {\n                continue;\n            }\n        }\n        assert!(broke);\n\n        // loops and other constructs can be named for better \n        readability ...\n        'outer: loop {\n            'inner: loop {\n                break 'inner; // ... and specifically jumped out of\n            }\n            break 'outer;\n        }\n```", "```rs\n        let mut iterations: u32 = 0;\n\n        let total_squared = loop {\n            iterations += 1;\n\n            if iterations >= 10 {\n                break iterations.pow(2);\n            }\n        };\n        assert_eq!(total_squared, 100);\n\n        for i in 0..10 { \n            assert!(i >= 0 && i < 10)\n        }\n\n        for v in vec![1, 1, 1, 1].iter() {\n            assert_eq!(v, &1);\n        }\n    }\n\n```", "```rs\n$ cargo test\n   Compiling execution-flow v0.1.0 (Rust-Cookbook/Chapter01/execution-flow)\nwarning: value assigned to `broke` is never read\n  --> src/lib.rs:20:17\n   |\n20 | let mut broke = false;\n   | ^^^^^\n   |\n   = note: #[warn(unused_assignments)] on by default\n   = help: maybe it is overwritten before being read?\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.89s\n     Running target/debug/deps/execution_flow-5a5ee2c7dd27585c\n\nrunning 3 tests\ntest tests::conditionals ... ok\ntest tests::loops ... ok\ntest tests::more_conditionals ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nuse rand::prelude::*;\n\npub fn monte_carlo_pi(iterations: usize) -> f32 {\n    let mut inside_circle = 0; \n    for _ in 0..iterations {\n\n        // generate two random coordinates between 0 and 1\n        let x: f32 = random::<f32>();\n        let y: f32 = random::<f32>();\n\n        // calculate the circular distance from 0, 0\n        if x.powi(2) + y.powi(2) <= 1_f32 {\n            // if it's within the circle, increase the count\n            inside_circle += 1;\n        }\n    }\n    // return the ratio of 4 times the hits to the total     \n    iterations\n    (4_f32 * inside_circle as f32) / iterations as f32\n}\n```", "```rs\n[dependencies]\nrand = \"^0.5\"\n```", "```rs\n#[cfg(test)]\nmod tests {\n    // import the parent crate's functions\n    use super::*;\n\n    fn is_reasonably_pi(pi: f32) -> bool {\n        pi >= 3_f32 && pi <= 4.5_f32\n    }\n\n    #[test]\n    fn test_monte_carlo_pi_1() {\n        let pi = monte_carlo_pi(1);\n        assert!(pi == 0_f32 || pi == 4_f32);\n    }\n\n    #[test]\n    fn test_monte_carlo_pi_500() {\n        let pi = monte_carlo_pi(500);\n        assert!(is_reasonably_pi(pi));\n    }\n```", "```rs\n    #[test]\n    fn test_monte_carlo_pi_1000() {\n        let pi = monte_carlo_pi(1000);\n        assert!(is_reasonably_pi(pi));\n    }\n\n    #[test]\n    fn test_monte_carlo_pi_5000() {\n        let pi = monte_carlo_pi(5000);\n        assert!(is_reasonably_pi(pi));\n    }\n}\n\n```", "```rs\n$ cargo test\n   Compiling libc v0.2.50\n   Compiling rand_core v0.4.0\n   Compiling rand_core v0.3.1\n   Compiling rand v0.5.6\n   Compiling rust-pilib v0.1.0 (Rust-Cookbook/Chapter01/rust-pilib)\n    Finished dev [unoptimized + debuginfo] target(s) in 3.78s\n     Running target/debug/deps/rust_pilib-d47d917c08b39638\n\nrunning 4 tests\ntest tests::test_monte_carlo_pi_1 ... ok\ntest tests::test_monte_carlo_pi_500 ... ok\ntest tests::test_monte_carlo_pi_1000 ... ok\ntest tests::test_monte_carlo_pi_5000 ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests rust-pilib\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n[dependencies]\nrust-pilib = { path = '../rust-pilib', version = '*'}\n```", "```rs\n// import from the module above\nuse printer::pretty_print_pi_approx;\n\nfn main() {\n    pretty_print_pi_approx(100_000);\n}\n```", "```rs\n// Rust will also accept if you implement it right away\nmod printer {\n    // import a function from an external crate (no more extern \n    declaration required!)\n    use rust_pilib::monte_carlo_pi;\n\n    // internal crates can always be imported using the crate \n    // prefix\n    use crate::rounding::round;\n\n    pub fn pretty_print_pi_approx(iterations: usize) {\n        let pi = monte_carlo_pi(iterations);\n        let places: usize = 2;\n\n        println!(\"Pi is ~ {} and rounded to {} places {}\", pi, \n        places, round(pi, places));\n    }\n}\n```", "```rs\n\npub fn round(nr: f32, places: usize) -> f32 {\n    let multiplier = 10_f32.powi(places as i32);\n    (nr * multiplier + 0.5).floor() / multiplier \n}\n\n#[cfg(test)]\nmod tests {\n    use super::round;\n\n    #[test]\n    fn round_positive() {\n       assert_eq!(round(3.123456, 2), 3.12);\n       assert_eq!(round(3.123456, 4), 3.1235);\n       assert_eq!(round(3.999999, 2), 4.0);\n       assert_eq!(round(3.0, 2), 3.0);\n       assert_eq!(round(9.99999, 2), 10.0); \n       assert_eq!(round(0_f32, 2), 0_f32);\n    }\n\n    #[test]\n    fn round_negative() {\n       assert_eq!(round(-3.123456, 2), -3.12);\n       assert_eq!(round(-3.123456, 4), -3.1235);\n       assert_eq!(round(-3.999999, 2), -4.0);\n       assert_eq!(round(-3.0, 2), -3.0);\n       assert_eq!(round(-9.99999, 2), -10.0);\n    }\n}\n```", "```rs\n// declare the module by its file name\nmod rounding;\n```", "```rs\n$ cargo run\n   Compiling libc v0.2.50\n   Compiling rand_core v0.4.0\n   Compiling rand_core v0.3.1\n   Compiling rand v0.5.6\n   Compiling rust-pilib v0.1.0 (Rust-Cookbook/Chapter01/rust-pilib)\n   Compiling pi-estimator v0.1.0 (Rust-Cookbook/Chapter01/pi-\n   estimator)\n    Finished dev [unoptimized + debuginfo] target(s) in 4.17s\n     Running `target/debug/pi-estimator`\n    Pi is ~ 3.13848 and rounded to 2 places 3.14\n```", "```rs\n$ cargo test\n   Compiling pi-estimator v0.1.0 (Rust-Cookbook/Chapter01/pi-\n   estimator)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running target/debug/deps/pi_estimator-1c0d8d523fadde02\n\nrunning 2 tests\ntest rounding::tests::round_negative ... ok\ntest rounding::tests::round_positive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n```", "```rs\n#[derive(Clone)]\nstruct Node<T> where T: Sized + Clone {\n    value: T,\n    next: Link<T>,\n}\n\nimpl<T> Node<T> where T: Sized + Clone {\n    fn new(value: T) -> Rc<RefCell<Node<T>>> {\n        Rc::new(RefCell::new(Node {\n            value: value,\n            next: None,\n        }))\n    }\n}\n```", "```rs\ntype Link<T> = Option<Rc<RefCell<Node<T>>>>;\n```", "```rs\n#[derive(Clone)]\npub struct List<T> where T: Sized + Clone {\n    head: Link<T>,\n    tail: Link<T>,\n    pub length: usize,\n}\n```", "```rs\nimpl<T> List<T> where T: Sized + Clone {\n    pub fn new_empty() -> List<T> {\n        List { head: None, tail: None, length: 0 }\n    }\n\n    pub fn append(&mut self, value: T) {\n        let new = Node::new(value);\n        match self.tail.take() {\n            Some(old) => old.borrow_mut().next = Some(new.clone()), \n            None => self.head = Some(new.clone())\n        }; \n        self.length += 1;\n        self.tail = Some(new);\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        self.head.take().map(|head| {\n            if let Some(next) = head.borrow_mut().next.take() {\n                self.head = Some(next);\n            } else {\n                self.tail.take();\n            }\n            self.length -= 1;\n            Rc::try_unwrap(head)\n                .ok()\n                .expect(\"Something is terribly wrong\")\n                .into_inner()\n                .value\n        })\n    }\n}\n```", "```rs\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    extern crate test;\n    use test::Bencher;\n\n    #[bench]\n    fn bench_list_append(b: &mut Bencher) {\n        let mut list = List::new_empty();\n        b.iter(|| {\n            list.append(10);\n        });\n    }\n```", "```rs\n    #[test]\n    fn test_list_new_empty() {\n        let mut list: List<i32> = List::new_empty();\n        assert_eq!(list.length, 0);\n        assert_eq!(list.pop(), None);\n    } \n\n    #[test]\n    fn test_list_append() {\n        let mut list = List::new_empty();\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        assert_eq!(list.length, 5);\n    }\n\n    #[test]\n    fn test_list_pop() {\n        let mut list = List::new_empty();\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        list.append(1);\n        assert_eq!(list.length, 5);\n        assert_eq!(list.pop(), Some(1));\n        assert_eq!(list.pop(), Some(1));\n        assert_eq!(list.pop(), Some(1));\n        assert_eq!(list.pop(), Some(1));\n        assert_eq!(list.pop(), Some(1));\n        assert_eq!(list.length, 0);\n        assert_eq!(list.pop(), None);\n    }\n}\n```", "```rs\nuse testing::List;\n\n#[test]\nfn test_list_insert_10k_items() {\n    let mut list = List::new_empty();\n    for _ in 0..10_000 {\n        list.append(100);\n    }\n    assert_eq!(list.length, 10_000);\n}\n```", "```rs\n$ cargo test\n   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.93s\n     Running target/debug/deps/testing-a0355a7fb781369f\n\nrunning 4 tests\ntest tests::test_list_new_empty ... ok\ntest tests::test_list_pop ... ok\ntest tests::test_list_append ... ok\ntest tests::bench_list_append ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/debug/deps/list_integration-77544dc154f309b3\n\nrunning 1 test\ntest test_list_insert_10k_items ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests testing\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\ncargo +nightly bench\n   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)\n    Finished release [optimized] target(s) in 0.81s\n     Running target/release/deps/testing-246b46f1969c54dd\n\nrunning 4 tests\ntest tests::test_list_append ... ignored\ntest tests::test_list_new_empty ... ignored\ntest tests::test_list_pop ... ignored\ntest tests::bench_list_append ... bench: 78 ns/iter (+/- 238)\n\ntest result: ok. 0 passed; 0 failed; 3 ignored; 1 measured; 0 filtered out\n\n```", "```rs\n/// \n/// A singly-linked list, with nodes allocated on the heap using \n///`Rc`s and `RefCell`s. Here's an image illustrating a linked list:\n/// \n/// \n/// ![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-\n///linked-list.svg)\n/// \n/// *Found on https://en.wikipedia.org/wiki/Linked_list*\n/// \n/// # Usage\n/// \n/// ```", "```rs\n/// \n#[derive(Clone)]\npub struct List<T> where T: Sized + Clone {\n[...]\n```", "```rs\n    ///\n    /// Appends a node to the list at the end.\n    /// \n    /// \n    /// # Panics\n    /// \n    /// This never panics (probably).\n    /// \n    /// # Safety\n    /// \n    /// No unsafe code was used.\n    /// \n    /// # Example\n    /// \n    /// ```", "```rs\n    /// \n    pub fn append(&mut self, value: T) {\n    [...]\n```", "```rs\n//!\n//! A simple singly-linked list for the Rust-Cookbook by Packt \n//! Publishing. \n//! \n//! Recipes covered in this module:\n//! - Documenting your code\n//! - Testing your documentation\n//! - Writing tests and benchmarks\n//! \n```", "```rs\n#![doc(html_logo_url = \"https://blog.x5ff.xyz/img/main/logo.png\")]\n```", "```rs\n    ///\n    /// Creates a new empty list.\n    /// \n    /// \n    pub fn new_empty() -> List<T> { \n        ...\n```", "```rs\n    ///\n    /// Creates a new empty list.\n    /// \n    /// \n    /// # Example\n```", "```rs\n    ///\n    /// Creates a new empty list.\n    /// \n    /// \n    /// # Example\n    /// \n    /// ```", "```rs\n    /// \n```", "```rs\n$ cargo +nightly test\n   Compiling testing v0.1.0 (Rust-Cookbook/Chapter01/testing)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.86s\n     Running target/debug/deps/testing-a0355a7fb781369f\n\nrunning 6 tests\n[...]\n   Doc-tests testing\n\nrunning 4 tests\ntest src/lib.rs - List (line 44) ... ok\ntest src/lib.rs - List<T>::new_empty (line 70) ... ok\ntest src/lib.rs - List<T>::append (line 94) ... ok\ntest src/lib.rs - List<T>::pop (line 121) ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs` ```", "```rs ```", "```rs\n/// \n/// A singly-linked list, with nodes allocated on the heap using `Rc`s and `RefCell`s. Here's an image illustrating a linked list:\n/// \n/// \n/// ![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n/// \n/// *Found on https://en.wikipedia.org/wiki/Linked_list*\n/// \n/// # Example\n/// \n/// ```", "```rs\n/// \n#[derive(Clone)]\npub struct List<T> where T: Sized + Clone { \n[...]\n```", "```rs\n$ cargo test\n[...]\n   Doc-tests testing\n\nrunning 4 tests\ntest src/lib.rs - List (line 46) ... ignored\ntest src/lib.rs - List<T>::append (line 94) ... ok\ntest src/lib.rs - List<T>::new_empty (line 70) ... ok\ntest src/lib.rs - List<T>::pop (line 121) ... ok\n\ntest result: ok. 3 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n```", "```rs\n    ///\n    /// Creates a new empty list.\n    /// \n    /// \n    /// # Example\n    /// \n    /// ```", "```rs\n    /// \n    pub fn new_empty() -> List<T> {\n        [...] \n```", "```rs\n#![doc(html_logo_url = \"https://blog.x5ff.xyz/img/main/logo.png\",\n       test(no_crate_inject, attr(allow(unused_variables), \n        deny(warnings))))]\n```", "```rs` ```", "```rs ```", "```rs\nuse std::io::{Read, Write};\n\n///\n/// Configuration for our application\n/// \npub struct Config {\n    values: Vec<(String, String)>\n}\n\n///\n/// A service for managing a configuration\n/// \npub struct KeyValueConfigService {}\n```", "```rs\n// Impls\n\nimpl Config {\n    pub fn new(values: Vec<(String, String)>) -> Config {\n        Config { values: values }\n    }\n}\n\nimpl KeyValueConfigService {\n    pub fn new() -> KeyValueConfigService {\n        KeyValueConfigService { }\n    }\n}\n```", "```rs\n///\n/// Provides a get() function to return values associated with\n/// the specified key.\n/// \npub trait ValueGetter {\n    fn get(&self, s: &str) -> Option<String>;\n}\n\n///\n/// Write a config\n/// \npub trait ConfigWriter {\n    fn write(&self, config: Config, to: &mut impl Write) -> std::io::Result<()>;\n}\n\n///\n/// Read a config\n/// \npub trait ConfigReader {\n    fn read(&self, from: &mut impl Read) -> std::io::Result<Config>;\n}\n```", "```rs\nimpl ConfigWriter for KeyValueConfigService {\n    fn write(&self, config: Config, mut to: &mut impl Write) -> std::io::Result<()> {\n        for v in config.values {\n            writeln!(&mut to, \"{0}={1}\", v.0, v.1)?;\n        }\n        Ok(())\n    }\n}\n\nimpl ConfigReader for KeyValueConfigService {\n    fn read(&self, from: &mut impl Read) -> std::io::Result<Config> {\n        let mut buffer = String::new();\n        from.read_to_string(&mut buffer)?;\n\n        // chain iterators together and collect the results\n        let values: Vec<(String, String)> = buffer\n            .split_terminator(\"\\n\") // split\n            .map(|line| line.trim()) // remove whitespace\n            .filter(|line| { // filter invalid lines\n                let pos = line.find(\"=\")\n                    .unwrap_or(0);\n                pos > 0 && pos < line.len() - 1\n            })\n            .map(|line| { // create a tuple from a line \n                let parts = line.split(\"=\")\n                                .collect::<Vec<&str>>();\n                (parts[0].to_string(), parts[1].to_string())\n            })\n            .collect(); // transform it into a vector\n        Ok(Config::new(values))\n    }\n}\n\nimpl ValueGetter for Config {\n    fn get(&self, s: &str) -> Option<String> {\n        self.values.iter()\n            .find_map(|tuple| if &tuple.0 == s {\n                    Some(tuple.1.clone())\n                } else {\n                    None\n            })\n    }\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn config_get_value() {\n        let config = Config::new(vec![(\"hello\".to_string(), \n        \"world\".to_string())]);\n        assert_eq!(config.get(\"hello\"), Some(\"world\".to_string()));\n        assert_eq!(config.get(\"HELLO\"), None);\n    }\n\n    #[test]\n    fn keyvalueconfigservice_write_config() {\n        let config = Config::new(vec![(\"hello\".to_string(), \n        \"world\".to_string())]);\n\n        let service = KeyValueConfigService::new();\n        let mut target = vec![];\n        assert!(service.write(config, &mut target).is_ok());\n\n        assert_eq!(String::from_utf8(target).unwrap(), \n        \"hello=world\\n\".to_string());\n    }\n\n     #[test]\n    fn keyvalueconfigservice_read_config() {\n\n        let service = KeyValueConfigService::new();\n        let readable = &format!(\"{}\\n{}\", \"hello=world\", \n        \"a=b\").into_bytes();\n\n        let config = service.read(&mut Cursor::new(readable))\n            .expect(\"Couldn't read from the vector\");\n\n        assert_eq!(config.values, vec![\n                (\"hello\".to_string(), \"world\".to_string()),\n                (\"a\".to_string(), \"b\".to_string())]);\n    }\n}\n```", "```rs\n$ cargo test\n   Compiling traits v0.1.0 (Rust-Cookbook/Chapter01/traits)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.92s\n     Running target/debug/deps/traits-e1d367b025654a89\n\nrunning 3 tests\ntest tests::config_get_value ... ok\ntest tests::keyvalueconfigservice_write_config ... ok\ntest tests::keyvalueconfigservice_read_config ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests traits\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n```", "```rs\n    #[test]\n    fn exploring_arrays() {\n        let mut arr: [usize; 3] = [0; 3];\n        assert_eq!(arr, [0, 0, 0]);\n\n        let arr2: [usize; 5] = [1,2,3,4,5];\n        assert_eq!(arr2, [1,2,3,4,5]);\n\n        arr[0] = 1;\n        assert_eq!(arr, [1, 0, 0]);\n        assert_eq!(arr[0], 1);\n        assert_eq!(mem::size_of_val(&arr), mem::size_of::<usize>()\n         * 3);\n    }\n```", "```rs\n    struct Point(f32, f32);\n\n    #[test]\n    fn exploring_tuples() {\n        let mut my_tuple: (i32, usize, f32) = (10, 0, -3.42);\n\n        assert_eq!(my_tuple.0, 10);\n        assert_eq!(my_tuple.1, 0);\n        assert_eq!(my_tuple.2, -3.42);\n\n        my_tuple.0 = 100;\n        assert_eq!(my_tuple.0, 100);\n\n        let (_val1, _val2, _val3) = my_tuple;\n\n        let point = Point(1.2, 2.1);\n        assert_eq!(point.0, 1.2);\n        assert_eq!(point.1, 2.1);\n    }\n```", "```rs\n    use std::mem;\n\n    #[test]\n    fn exploring_vec() {\n        assert_eq!(vec![0; 3], [0, 0, 0]);\n        let mut v: Vec<i32> = vec![];\n\n        assert_eq!(mem::size_of::<Vec<i32>>(),\n         mem::size_of::<usize>\n         () * 3);\n\n        assert_eq!(mem::size_of_val(&*v), 0);\n\n        v.push(10);\n\n        assert_eq!(mem::size_of::<Vec<i32>>(),\n         mem::size_of::<i32>() * 6);\n```", "```rs\n        assert_eq!(v[0], 10);\n\n        v.insert(0, 11);\n        v.push(12);\n        assert_eq!(v, [11, 10, 12]);\n        assert!(!v.is_empty());\n\n        assert_eq!(v.swap_remove(0), 11);\n        assert_eq!(v, [12, 10]);\n\n        assert_eq!(v.pop(), Some(10));\n        assert_eq!(v, [12]);\n\n        assert_eq!(v.remove(0), 12);\n\n        v.shrink_to_fit();\n        assert_eq!(mem::size_of_val(&*v), 0);\n    }\n\n```", "```rs\n$ cargo test\n   Compiling sequences v0.1.0 (Rust-Cookbook/Chapter01/sequences)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.28s\n     Running target/debug/deps/sequences-f931e7184f2b4f3d\n\nrunning 3 tests\ntest tests::exploring_arrays ... ok\ntest tests::exploring_tuples ... ok\ntest tests::exploring_vec ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests sequences\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug executable 'debug-me'\",\n            \"cargo\": {\n                \"args\": [\n                    \"build\",\n                    \"--bin=debug-me\",\n                    \"--package=debug-me\"\n                ],\n                \"filter\": {\n                    \"kind\": \"bin\"\n                }\n            },\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        },\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug unit tests in executable 'debug-me'\",\n            \"cargo\": {\n                \"args\": [\n                    \"test\",\n                    \"--no-run\",\n                    \"--bin=debug-me\",\n                    \"--package=debug-me\"\n                ],\n                \"filter\": {\n                    \"kind\": \"bin\"\n                }\n            },\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n```", "```rs\nstruct MyStruct {\n    prop: usize,\n}\n\nstruct Point(f32, f32);\n\nfn main() {\n    let a = 42;\n    let b = vec![0, 0, 0, 100];\n    let c = [1, 2, 3, 4, 5];\n    let d = 0x5ff;\n    let e = MyStruct { prop: 10 };\n    let p = Point(3.14, 3.14);\n\n    println!(\"Hello, world!\");\n}\n```"]