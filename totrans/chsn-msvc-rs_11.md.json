["```rs\nfn main() {\n    env_logger::init();\n    let sys = actix::System::new(\"router\");\n    server::new(|| {\n      // Insert `App` declaration here\n    }).workers(1)\n        .bind(\"127.0.0.1:8080\")\n        .unwrap()\n        .start();\n    let _ = sys.run();\n}\n```", "```rs\nlet app = App::with_state(State::default())\n    .middleware(middleware::Logger::default())\n    .middleware(IdentityService::new(\n            CookieIdentityPolicy::new(&[0; 32])\n            .name(\"auth-example\")\n            .secure(false),\n            ))\n    .middleware(Counter);\n```", "```rs\n#[derive(Default)]\nstruct State(RefCell<i64>);\n```", "```rs\napp.scope(\"/api\", |scope| {\n    scope\n        .route(\"/signup\", http::Method::POST, signup)\n        .route(\"/signin\", http::Method::POST, signin)\n        .route(\"/new_comment\", http::Method::POST, new_comment)\n        .route(\"/comments\", http::Method::GET, comments)\n})\n```", "```rs\n.route(\"/counter\", http::Method::GET, counter)\n```", "```rs\napp.handler(\n    \"/\",\n    fs::StaticFiles::new(\"./static/\").unwrap().index_file(\"index.html\")\n)\n```", "```rs\nfn get_request(url: &str) -> impl Future<Item = Vec<u8>, Error = Error> {\n    client::ClientRequest::get(url)\n        .finish().into_future()\n        .and_then(|req| {\n            req.send()\n                .map_err(Error::from)\n                .and_then(|resp| resp.body().from_err())\n                .map(|bytes| bytes.to_vec())\n        })\n}\n```", "```rs\nfn post_request<T, O>(url: &str, params: T) -> impl Future<Item = O, Error = Error>\nwhere\n    T: Serialize,\n    O: for <'de> Deserialize<'de> + 'static,\n{\n    client::ClientRequest::post(url)\n        .form(params).into_future().and_then(|req| {\n            req.send()\n                .map_err(Error::from).and_then(|resp| {\n                    if resp.status().is_success() {\n                        let fut = resp.json::<O>().from_err();\n                        boxed(fut)\n                    } else {\n                        error!(\"Microservice error: {}\", resp.status());\n                        let fut = Err(format_err!(\"microservice error\"))\n                            .into_future().from_err();\n                        boxed(fut)\n                    }\n                })\n        })\n}\n```", "```rs\nfn signup(params: Form<UserForm>) -> FutureResponse<HttpResponse> {\n    let fut = post_request(\"http://127.0.0.1:8001/signup\", params.into_inner())\n        .map(|_: ()| {\n            HttpResponse::Found()\n            .header(header::LOCATION, \"/login.html\")\n            .finish()\n        });\n    Box::new(fut)\n}\n```", "```rs\ntype FutureResponse<I, E = Error> = Box<dyn Future<Item = I, Error = E>>;\n```", "```rs\n#[derive(Deserialize, Serialize)]\npub struct UserForm {\n    email: String,\n    password: String,\n}\n```", "```rs\nfn signin((req, params): (HttpRequest<State>, Form<UserForm>))\n    -> FutureResponse<HttpResponse>\n{\n    let fut = post_request(\"http://127.0.0.1:8001/signin\", params.into_inner())\n        .map(move |id: UserId| {\n            req.remember(id.id);\n            HttpResponse::build_from(&req)\n            .status(StatusCode::FOUND)\n            .header(header::LOCATION, \"/comments.html\")\n            .finish()\n        });\n    Box::new(fut)\n}\n```", "```rs\n#[derive(Deserialize)]\npub struct UserId {\n    id: String,\n}\n```", "```rs\nfn new_comment((req, params): (HttpRequest<State>, Form<AddComment>))\n    -> FutureResponse<HttpResponse>\n{\n    let fut = req.identity()\n        .ok_or(format_err!(\"not authorized\").into())\n        .into_future()\n        .and_then(move |uid| {\n            let params = NewComment {\n                uid,\n                text: params.into_inner().text,\n            };\n            post_request::<_, ()>(\"http://127.0.0.1:8003/new_comment\", params)\n        })\n        .then(move |_| {\n            let res = HttpResponse::build_from(&req)\n                .status(StatusCode::FOUND)\n                .header(header::LOCATION, \"/comments.html\")\n                .finish();\n            Ok(res)\n        });\n    Box::new(fut)\n}\n```", "```rs\n#[derive(Deserialize)]\npub struct AddComment {\n    pub text: String,\n}\n\n#[derive(Serialize)]\npub struct NewComment {\n    pub uid: String,\n    pub text: String,\n}\n```", "```rs\nfn comments(_req: HttpRequest<State>) -> FutureResponse<HttpResponse> {\n    let fut = get_request(\"http://127.0.0.1:8003/list\")\n        .map(|data| {\n            HttpResponse::Ok().body(data)\n        });\n    Box::new(fut)\n}\n```", "```rs\nfn counter(req: HttpRequest<State>) -> String {\n    format!(\"{}\", req.state().0.borrow())\n}\n```", "```rs\npub struct Counter;\n\nimpl Middleware<State> for Counter {\n    fn start(&self, req: &HttpRequest<State>) -> Result<Started> {\n        let value = *req.state().0.borrow();\n        *req.state().0.borrow_mut() = value + 1;\n        Ok(Started::Done)\n    }\n\n    fn response(&self, _req: &HttpRequest<State>, resp: HttpResponse) -> Result<Response> {\n        Ok(Response::Done(resp))\n    }\n\n    fn finish(&self, _req: &HttpRequest<State>, _resp: &HttpResponse) -> Finished {\n        Finished::Done\n    }\n}\n```", "```rs\nredis = \"0.9\"\n```", "```rs\nuse actix::prelude::*;\nuse failure::Error;\nuse futures::Future;\nuse redis::{Commands, Client, RedisError};\n```", "```rs\npub struct CacheActor {\n    client: Client,\n    expiration: usize,\n}\n```", "```rs\nimpl CacheActor {\n    pub fn new(addr: &str, expiration: usize) -> Self {\n        let client = Client::open(addr).unwrap();\n        Self { client, expiration }\n    }\n}\n```", "```rs\nimpl Actor for CacheActor {\n    type Context = SyncContext<Self>;\n}\n```", "```rs\nstruct SetValue {\n    pub path: String,\n    pub content: Vec<u8>,\n}\n```", "```rs\nimpl Message for SetValue {\n    type Result = Result<(), RedisError>;\n}\n```", "```rs\nimpl Handler<SetValue> for CacheActor {\n    type Result = Result<(), RedisError>;\n\n    fn handle(&mut self, msg: SetValue, _: &mut Self::Context) -> Self::Result {\n        self.client.set_ex(msg.path, msg.content, self.expiration)\n    }\n}\n```", "```rs\nstruct GetValue {\n    pub path: String,\n}\n```", "```rs\nimpl Message for GetValue {\n    type Result = Result<Option<Vec<u8>>, RedisError>;\n}\n```", "```rs\nimpl Handler<GetValue> for CacheActor {\n    type Result = Result<Option<Vec<u8>>, RedisError>;\n\n    fn handle(&mut self, msg: GetValue, _: &mut Self::Context) -> Self::Result {\n        self.client.get(&msg.path)\n    }\n}\n```", "```rs\n#[derive(Clone)]\npub struct CacheLink {\n    addr: Addr<CacheActor>,\n}\n```", "```rs\nimpl CacheLink {\n    pub fn new(addr: Addr<CacheActor>) -> Self {\n        Self { addr }\n    }\n}\n```", "```rs\npub fn get_value(&self, path: &str) -> Box<Future<Item = Option<Vec<u8>>, Error = Error>> {\n    let msg = GetValue {\n        path: path.to_owned(),\n    };\n    let fut = self.addr.send(msg)\n        .from_err::<Error>()\n        .and_then(|x| x.map_err(Error::from));\n    Box::new(fut)\n}\n```", "```rs\npub fn set_value(&self, path: &str, value: &[u8]) -> Box<Future<Item = (), Error = Error>> {\n    let msg = SetValue {\n        path: path.to_owned(),\n        content: value.to_owned(),\n    };\n    let fut = self.addr.send(msg)\n        .from_err::<Error>()\n        .and_then(|x| x.map_err(Error::from));\n    Box::new(fut)\n}\n```", "```rs\nstruct State {\n    counter: RefCell<i64>,\n    cache: CacheLink,\n}\n```", "```rs\nimpl State {\n    fn new(cache: CacheLink) -> Self {\n        Self {\n            counter: RefCell::default(),\n            cache,\n        }\n    }\n}\n```", "```rs\nfn cache<F>(&self, path: &str, fut: F)\n    -> impl Future<Item = Vec<u8>, Error = Error>\nwhere\n    F: Future<Item = Vec<u8>, Error = Error> + 'static,\n{\n    let link = self.cache.clone();\n    let path = path.to_owned();\n    link.get_value(&path)\n        .from_err::<Error>()\n        .and_then(move |opt| {\n            if let Some(cached) = opt {\n                debug!(\"Cached value used\");\n                boxed(future::ok(cached))\n            } else {\n                let res = fut.and_then(move |data| {\n                    link.set_value(&path, &data)\n                        .then(move |_| {\n                            debug!(\"Cache updated\");\n                            future::ok::<_, Error>(data)\n                        })\n                        .from_err::<Error>()\n                });\n                boxed(res)\n            }\n        })\n}\n```", "```rs\nfn comments(req: HttpRequest<State>) -> FutureResponse<HttpResponse> {\n    let fut = get_request(\"http://127.0.0.1:8003/list\");\n    let fut = req.state().cache(\"/list\", fut)\n        .map(|data| {\n            HttpResponse::Ok().body(data)\n        });\n    Box::new(fut)\n}\n```", "```rs\nlet addr = SyncArbiter::start(3, || {\n    CacheActor::new(\"redis://127.0.0.1:6379/\", 10)\n});\nlet cache = CacheLink::new(addr);\nserver::new(move || {\n    let state = State::new(cache.clone());\n    App::with_state(state)\n    // remains part App building\n})\n```", "```rs\nuse actix::{Actor, Context, Handler, Message, Recipient};\nuse std::collections::HashSet;\nuse super::NewComment;\n```", "```rs\npub struct RepeaterActor {\n    listeners: HashSet<Recipient<RepeaterUpdate>>,\n}\n```", "```rs\nimpl RepeaterActor {\n    pub fn new() -> Self {\n        Self {\n            listeners: HashSet::new(),\n        }\n    }\n}\n```", "```rs\nimpl Actor for RepeaterActor {\n    type Context = Context<Self>;\n}\n```", "```rs\n#[derive(Clone)]\npub struct RepeaterUpdate(pub NewComment);\n```", "```rs\nimpl Message for RepeaterUpdate {\n    type Result = ();\n}\n```", "```rs\nimpl Handler<RepeaterUpdate> for RepeaterActor {\n    type Result = ();\n\n    fn handle(&mut self, msg: RepeaterUpdate, _: &mut Self::Context) -> Self::Result {\n        for listener in &self.listeners {\n            listener.do_send(msg.clone()).ok();\n        }\n    }\n}\n```", "```rs\npub enum RepeaterControl {\n    Subscribe(Recipient<RepeaterUpdate>),\n    Unsubscribe(Recipient<RepeaterUpdate>),\n}\n```", "```rs\nimpl Message for RepeaterControl {\n    type Result = ();\n}\n```", "```rs\nimpl Handler<RepeaterControl> for RepeaterActor {\n    type Result = ();\n\n    fn handle(&mut self, msg: RepeaterControl, _: &mut Self::Context) -> Self::Result {\n        match msg {\n            RepeaterControl::Subscribe(listener) => {\n                self.listeners.insert(listener);\n            }\n            RepeaterControl::Unsubscribe(listener) => {\n                self.listeners.remove(&listener);\n            }\n        }\n    }\n}\n```", "```rs\nserde_json = \"1.0\"\n```", "```rs\nuse actix::{Actor, ActorContext, AsyncContext, Handler, Recipient, StreamHandler};\nuse actix_web::ws::{Message, ProtocolError, WebsocketContext};\nuse crate::repeater::{RepeaterControl, RepeaterUpdate};\nuse std::time::{Duration, Instant};\nuse super::State;\n```", "```rs\nconst PING_INTERVAL: Duration = Duration::from_secs(20);\nconst PING_TIMEOUT: Duration = Duration::from_secs(60);\n```", "```rs\npub struct NotifyActor {\n     last_ping: Instant,\n     repeater: Recipient<RepeaterControl>,\n}\n```", "```rs\nimpl NotifyActor {\n    pub fn new(repeater: Recipient<RepeaterControl>) -> Self {\n        Self {\n            last_ping: Instant::now(),\n            repeater,\n        }\n    }\n}\n```", "```rs\nimpl Actor for NotifyActor {\n    type Context = WebsocketContext<Self, State>;\n\n    fn started(&mut self, ctx: &mut Self::Context) {\n        let msg = RepeaterControl::Subscribe(ctx.address().recipient());\n        self.repeater.do_send(msg).ok();\n        ctx.run_interval(PING_INTERVAL, |act, ctx| {\n            if Instant::now().duration_since(act.last_ping) > PING_TIMEOUT {\n                ctx.stop();\n                return;\n            }\n            ctx.ping(\"ping\");\n        });\n    }\n\n    fn stopped(&mut self, ctx: &mut Self::Context) {\n        let msg = RepeaterControl::Unsubscribe(ctx.address().recipient());\n        self.repeater.do_send(msg).ok();\n    }\n}\n```", "```rs\nimpl StreamHandler<Message, ProtocolError> for NotifyActor {\n    fn handle(&mut self, msg: Message, ctx: &mut Self::Context) {\n        match msg {\n            Message::Ping(msg) => {\n                self.last_ping = Instant::now();\n                ctx.pong(&msg);\n            }\n            Message::Pong(_) => {\n                self.last_ping = Instant::now();\n            }\n            Message::Text(_) => { },\n            Message::Binary(_) => { },\n            Message::Close(_) => {\n                ctx.stop();\n            }\n        }\n    }\n}\n```", "```rs\nimpl Handler<RepeaterUpdate> for NotifyActor {\n    type Result = ();\n\n    fn handle(&mut self, msg: RepeaterUpdate, ctx: &mut Self::Context) -> Self::Result {\n        let RepeaterUpdate(comment) = msg;\n        if let Ok(data) = serde_json::to_string(&comment) {\n            ctx.text(data);\n        }\n    }\n}\n```", "```rs\npub struct State {\n     counter: RefCell<i64>,\n     cache: CacheLink,\n     repeater: Addr<RepeaterActor>,\n }\n```", "```rs\nfn new(cache: CacheLink, repeater: Addr<RepeaterActor>) -> Self {\n     Self {\n         counter: RefCell::default(),\n         cache,\n         repeater,\n     }\n }\n```", "```rs\nlet repeater = RepeaterActor::new().start();\n\n server::new(move || {\n     let state = State::new(cache.clone(), repeater.clone());\n     App::with_state(state)\n         .resource(\"/ws\", |r| r.method(http::Method::GET).f(ws_connect))\n         // other\n })\n```", "```rs\nfn ws_connect(req: &HttpRequest<State>) -> Result<HttpResponse, Error> {\n     let repeater = req.state().repeater.clone().recipient();\n     ws::start(req, NotifyActor::new(repeater))\n }\n```", "```rs\nfn new_comment((req, params): (HttpRequest<State>, Form<AddComment>)) -> FutureResponse<HttpResponse> {\n     let repeater = req.state().repeater.clone();\n     let fut = req.identity()\n         .ok_or(format_err!(\"not authorized\").into())\n         .into_future()\n         .and_then(move |uid| {\n             let new_comment = NewComment {\n                 uid,\n                 text: params.into_inner().text,\n             };\n             let update = RepeaterUpdate(new_comment.clone());\n             repeater\n                 .send(update)\n                 .then(move |_| Ok(new_comment))\n         })\n         .and_then(move |params| {\n             post_request::<_, ()>(\"http://127.0.0.1:8003/new_comment\", params)\n         })\n         .then(move |_| {\n             let res = HttpResponse::build_from(&req)\n                 .status(StatusCode::FOUND)\n                 .header(header::LOCATION, \"/comments.html\")\n                 .finish();\n             Ok(res)\n         });\n     Box::new(fut)\n }\n```"]