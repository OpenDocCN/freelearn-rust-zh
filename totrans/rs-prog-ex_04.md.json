["```rs\n    let sdl_context = sdl2::init().expect(\"SDL initialization \n      failed\");\n    let video_subsystem = sdl_context.video().expect(\"Couldn't get\n       SDL video subsystem\");\n    let width = 600;\n    let height = 800;\n```", "```rs\n    let sdl_context = sdl2::init().expect(\"SDL initialization\n      failed\");\n    let mut tetris = Tetris::new();\n    let mut timer = SystemTime::now();\n\n    let mut event_pump = sdl_context.event_pump().expect(\"Failed to\n      get SDL event pump\");\n\n    let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;\n    let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;\n```", "```rs\n    let window = video_subsystem.window(\"Tetris\", width, height)\n        .position_centered() // to put it in the middle of the screen\n        .build() // to create the window\n        .expect(\"Failed to create window\");\n\n    let mut canvas = window.into_canvas()\n        .target_texture()\n        .present_vsync() // To enable v-sync.\n        .build()\n        .expect(\"Couldn't get window's canvas\");\n\n    let texture_creator: TextureCreator<_> = canvas.texture_creator();\n\n    let grid = create_texture_rect(&mut canvas,\n        &texture_creator,\n        0, 0, 0,\n        TETRIS_HEIGHT as u32 * 10,\n        TETRIS_HEIGHT as u32 * 16).expect(\"Failed to create\n           a texture\");\n\n    let border = create_texture_rect(&mut canvas,\n        &texture_creator,\n        255, 255, 255,\n        TETRIS_HEIGHT as u32 * 10 + 20,\n        TETRIS_HEIGHT as u32 * 16 + 20).expect(\"Failed to create \n          a texture\");\n\n    macro_rules! texture {\n      ($r:expr, $g:expr, $b:expr) => (\n        create_texture_rect(&mut canvas,\n          &texture_creator,\n          $r, $g, $b,\n          TETRIS_HEIGHT as u32,\n          TETRIS_HEIGHT as u32).unwrap()\n      )\n    }\n\n    let textures = [texture!(255, 69, 69), texture!(255, 220, 69), \n        texture!(237, 150, 37),texture!(171, 99, 237), texture!(77, 149, \n        239), texture!(39, 218, 225), texture!(45, 216, 47)];\n```", "```rs\n    let window = video_subsystem.window(\"Tetris\", width, height)\n       .position_centered()\n       .build()\n       .expect(\"Failed to create window\");\n\n    let mut canvas = window.into_canvas()\n       .target_texture()\n       .present_vsync()\n       .build()\n       .expect(\"Couldn't get window's canvas\");\n\n    let texture_creator: TextureCreator<_> = canvas.texture_creator();\n```", "```rs\n    let grid = create_texture_rect(&mut canvas,\n       &texture_creator,\n       0, 0, 0,\n       TETRIS_HEIGHT as u32 * 10,\n       TETRIS_HEIGHT as u32 * 16).expect(\"Failed to create a texture\");\n\n    let border = create_texture_rect(&mut canvas,\n       &texture_creator,\n       255, 255, 255,\n       TETRIS_HEIGHT as u32 * 10 + 20,\n       TETRIS_HEIGHT as u32 * 16 + 20).expect(\"Failed to create a texture\");\n```", "```rs\n    macro_rules! texture {\n      ($r:expr, $g:expr, $b:expr) => (\n        create_texture_rect(&mut canvas,\n           &texture_creator,\n           $r, $g, $b,\n           TETRIS_HEIGHT as u32,\n           TETRIS_HEIGHT as u32).unwrap()\n      )\n    }\n```", "```rs\n    let textures = [texture!(255, 69, 69), texture!(255, 220, 69), \n         texture!(237, 150, 37), texture!(171, 99, 237), texture!(77, 149,\n          239), texture!(39, 218, 225), texture!(45, 216, 47)];\n```", "```rs\n    canvas.set_draw_color(Color::RGB(255, 0, 0));\n    canvas.clear();\n    canvas.copy(&border,\n        None,\n        Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,\n        (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,\n        TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))\n        .expect(\"Couldn't copy texture into window\");\n         canvas.copy(&grid,\n         None,\n         Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2,\n         (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,\n         TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))\n         .expect(\"Couldn't copy texture into window\");\n```", "```rs\n    Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,\n       (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,\n       TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20)\n```", "```rs\n    TETRIS_HEIGHT as u32 * 10\n```", "```rs\n    width - TETRIS_HEIGHT as u32 * 10\n```", "```rs\n    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2\n```", "```rs\n    (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10\n```", "```rs\n    TETRIS_HEIGHT as u32 * 10\n```", "```rs\n    TETRIS_HEIGHT as u32 * 10 + 20\n```", "```rs\n    if !handle_events(&mut tetris, &mut quit, &mut timer, &mut\n      event_pump) {\n      if let Some(ref mut piece) = tetris.current_piece {\n        for (line_nb, line) in piece.states[piece.current_state\n           as usize].iter().enumerate() {\n          for (case_nb, case) in line.iter().enumerate() {\n            if *case == 0 {\n              continue\n            }\n            // The new part is here:\n              canvas.copy(&textures[*case as usize - 1],\n                None,\n                Rect::new(grid_x + (piece.x + case_nb as isize) as \n                  i32 * TETRIS_HEIGHT as i32, grid_y + (piece.y + \n                  line_nb) as i32 * TETRIS_HEIGHT as i32, TETRIS_HEIGHT\n                  as u32, TETRIS_HEIGHT as u32))\n                  .expect(\"Couldn't copy texture into window\");\n          }\n        }\n      }\n    }\n```", "```rs\n    for (line_nb, line) in tetris.game_map.iter().enumerate() {\n      for (case_nb, case) in line.iter().enumerate() {\n        if *case == 0 {\n            continue\n        }\n        canvas.copy(&textures[*case as usize - 1],\n          None, Rect::new(grid_x + case_nb as i32 * TETRIS_HEIGHT\n          as i32, grid_y + line_nb as i32 * TETRIS_HEIGHT as i32,\n          TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))\n          .expect(\"Couldn't copy texture into window\");\n      }\n    }\n    canvas.present();\n```", "```rs\n    canvas.present();\n```", "```rs\ncargo run --release\n```", "```rs\n    fn main() {\n      let sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n      let video_subsystem = sdl_context.video().expect(\"Couldn't get \n          SDL video subsystem\");\n      let width = 600;\n      let height = 800;\n      let mut timer = SystemTime::now();\n      let mut event_pump = sdl_context.event_pump().expect(\"Failed to get\n          SDL event pump\");\n\n      let grid_x = (width - TETRIS_HEIGHT as u32 * 10) as i32 / 2;\n      let grid_y = (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2;\n      let mut tetris = Tetris::new();\n\n      let window = video_subsystem.window(\"Tetris\", width, height)\n                                .position_centered()\n                                .build()\n                                .expect(\"Failed to create window\");\n\n      let mut canvas = window.into_canvas()\n                           .target_texture()\n                           .present_vsync()\n                           .build()\n                           .expect(\"Couldn't get window's canvas\");\n\n      let texture_creator: TextureCreator<_> = canvas.texture_creator();\n\n      let grid = create_texture_rect(&mut canvas,\n               &texture_creator,\n               0, 0, 0,\n               TETRIS_HEIGHT as u32 * 10,\n               TETRIS_HEIGHT as u32 * 16).expect(\"Failed to create\n                 a texture\");\n\n      let border = create_texture_rect(&mut canvas,\n               &texture_creator,\n               255, 255, 255,\n               TETRIS_HEIGHT as u32 * 10 + 20,\n               TETRIS_HEIGHT as u32 * 16 + 20).expect(\"Failed to create\n                 a texture\");\n\n      macro_rules! texture {\n        ($r:expr, $g:expr, $b:expr) => (\n            create_texture_rect(&mut canvas,\n                                &texture_creator,\n                                $r, $g, $b,\n                                TETRIS_HEIGHT as u32,\n                                TETRIS_HEIGHT as u32).unwrap()\n        )\n      }\n\n      let textures = [texture!(255, 69, 69), texture!(255, 220, 69),\n         texture!(237, 150, 37), texture!(171, 99, 237), \n         texture!(77, 149, 239), texture!(39, 218, 225),\n         texture!(45, 216, 47)];\n\n      loop {\n        if is_time_over(&tetris, &timer) {\n          let mut make_permanent = false;\n          if let Some(ref mut piece) = tetris.current_piece {\n            let x = piece.x;\n            let y = piece.y + 1;\n            make_permanent = !piece.change_position(&tetris.game_map,\n               x, y);\n          }\n          if make_permanent {\n            tetris.make_permanent();\n          }\n          timer = SystemTime::now();\n        }\n\n        canvas.set_draw_color(Color::RGB(255, 0, 0));\n        canvas.clear();\n\n        canvas.copy(&border,\n           None,\n           Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2 - 10,\n           (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,\n           TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))\n           .expect(\"Couldn't copy texture into window\");\n        canvas.copy(&grid,\n           None,\n           Rect::new((width - TETRIS_HEIGHT as u32 * 10) as i32 / 2,\n           (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,\n           TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))\n           .expect(\"Couldn't copy texture into window\");\n\n        if tetris.current_piece.is_none() {\n            let current_piece = tetris.create_new_tetrimino();\n            if !current_piece.test_current_position(&tetris.game_map) {\n                print_game_information(&tetris);\n                break\n            }\n            tetris.current_piece = Some(current_piece);\n        }\n        let mut quit = false;\n        if !handle_events(&mut tetris, &mut quit, &mut timer,\n           &mut event_pump) {\n         if let Some(ref mut piece) = tetris.current_piece {\n           for (line_nb, line) in piece.states[piece.current_state \n               as usize].iter().enumerate() {\n             for (case_nb, case) in line.iter().enumerate() {\n               if *case == 0 {\n                 continue\n               }\n               canvas.copy(&textures[*case as usize - 1],\n                  None,\n                  Rect::new(grid_x + (piece.x + case_nb as isize) \n                    as i32 * TETRIS_HEIGHT as i32,\n                  grid_y + (piece.y + line_nb) as i32 * TETRIS_HEIGHT \n                    as i32,\n                    TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))\n                  .expect(\"Couldn't copy texture into window\");\n             }\n           }\n         }\n        }\n        if quit {\n          print_game_information(&tetris);\n            break\n        }\n\n        for (line_nb, line) in tetris.game_map.iter().enumerate() {\n          for (case_nb, case) in line.iter().enumerate() {\n             if *case == 0 {\n                continue\n             }\n             canvas.copy(&textures[*case as usize - 1],\n                None,\n                Rect::new(grid_x + case_nb as i32 * TETRIS_HEIGHT as i32,\n                grid_y + line_nb as i32 * TETRIS_HEIGHT as i32,\n                TETRIS_HEIGHT as u32, TETRIS_HEIGHT as u32))\n                .expect(\"Couldn't copy texture into window\");\n          }\n        }\n        canvas.present();\n\n        sleep(Duration::new(0, 1_000_000_000u32 / 60));\n      }\n    }\n```", "```rs\n    [features]\n    default = [\"sdl2/ttf\"]\n```", "```rs\n    let ttf_context = sdl2::ttf::init().expect(\"SDL TTF initialization\n        failed\");\n```", "```rs\nbrew install sdl2_ttf\n```", "```rs\nsudo apt-get install libsdl2-ttf-dev\n```", "```rs\n     let font = ttf_context.load_font(\"assets/lucida.ttf\", 128).expect(\"\n       Couldn't load the font\");\n```", "```rs\n    font.set_style(sdl2::ttf::STYLE_BOLD);\n```", "```rs\n    fn create_texture_from_text<'a>(texture_creator: &'a \n       TextureCreator<WindowContext>,\n       font: &sdl2::ttf::Font,\n       text: &str,\n       r: u8, g: u8, b: u8,\n       ) -> Option<Texture<'a>> {\n         if let Ok(surface) = font.render(text)\n           .blended(Color::RGB(r, g, b)) {\n          texture_creator.create_texture_from_surface(&surface).ok()\n         } else {\n               None\n           }\n       }\n```", "```rs\n     let rendered_text = create_texture_from_text(&texture_creator,\n        &font, \"test\", 255, 255, 255).expect(\"Cannot render text\");\n     canvas.copy(&rendered_text, None, Some(Rect::new(width as i32 - \n        40, 0, 40, 30)))\n    .expect(\"Couldn't copy text\");\n```", "```rs\n     fn get_rect_from_text(text: &str, x: i32, y: i32) -> Option<Rect> {\n        Some(Rect::new(x, y, text.len() as u32 * 20, 30))\n     }\n```", "```rs\n    fn display_game_information<'a>(tetris: &Tetris,\n       canvas: &mut Canvas<Window>,\n       texture_creator: &'a TextureCreator<WindowContext>,\n       font: &sdl2::ttf::Font,\n       start_x_point: i32) {\n     let score_text = format!(\"Score: {}\", tetris.score);\n     let lines_sent_text = format!(\"Lines sent: {}\", tetris.nb_lines);\n     let level_text = format!(\"Level: {}\", tetris.current_level);\n\n     let score = create_texture_from_text(&texture_creator, &font,\n        &score_text, 255, 255, 255)\n        .expect(\"Cannot render text\");\n     let lines_sent = create_texture_from_text(&texture_creator, &font,\n        &lines_sent_text, 255, 255, 255)\n        .expect(\"Cannot render text\");\n     let level = create_texture_from_text(&texture_creator, &font,\n        &level_text, 255, 255, 255)\n        .expect(\"Cannot render text\");\n\n     canvas.copy(&score, None, get_rect_from_text(&score_text, \n       start_x_point, 90))\n          .expect(\"Couldn't copy text\");\n    canvas.copy(&lines_sent, None, get_rect_from_text(&score_text,\n       start_x_point, 125))\n          .expect(\"Couldn't copy text\");\n    canvas.copy(&level, None, get_rect_from_text(&score_text, \n       start_x_point, 160))\n          .expect(\"Couldn't copy text\");\n    }\n```", "```rs\n    display_game_information(&tetris, &mut canvas, &texture_creator, &font,\n       width as i32 - grid_x - 10);\n```", "```rs\n    let grid_x = 20;\n```", "```rs\n     canvas.copy(&border,\n            None,\n            Rect::new(10,\n                      (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2 - 10,\n                      TETRIS_HEIGHT as u32 * 10 + 20, TETRIS_HEIGHT as u32 * 16 + 20))\n      .expect(\"Couldn't copy texture into window\");\n     canvas.copy(&grid,\n       None,\n       Rect::new(20,\n       (height - TETRIS_HEIGHT as u32 * 16) as i32 / 2,\n        TETRIS_HEIGHT as u32 * 10, TETRIS_HEIGHT as u32 * 16))\n      .expect(\"Couldn't copy texture into window\");\n```"]