- en: '*Chapter 7*: Implementing Terminal I/O in Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*: 在Rust中实现终端I/O'
- en: In the previous chapter, we looked at how to work with files and directories.
    We also built a shell command in Rust that generates consolidated source code
    metrics for Rust source files in a project directory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何处理文件和目录。我们还构建了一个Rust中的shell命令，用于生成项目目录中Rust源代码的汇总源代码度量。
- en: In this chapter, we will look at building **terminal-based applications** in
    Rust. Terminal applications are an integral part of many software programs, including
    **games**, **text editors**, and **terminal emulators**. For developing these
    types of programs, it helps to understand how to build customized terminal interface-based
    applications. This is the focus of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在Rust中构建**基于终端的应用程序**。终端应用程序是许多软件程序的重要组成部分，包括**游戏**、**文本编辑器**和**终端模拟器**。对于开发这些类型的程序，了解如何构建基于自定义终端界面的应用程序非常有帮助。这是本章的重点。
- en: For this chapter, we will review the basics of how terminals work, and then
    look at how to perform various types of actions on a terminal, such as setting
    colors and styles, performing cursor operations (such as clearing and positioning),
    and working with keyboard and mouse inputs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将回顾终端的基本工作原理，然后探讨如何在终端上执行各种类型的操作，例如设置颜色和样式，执行光标操作（如清除和定位），以及处理键盘和鼠标输入。
- en: 'We will cover the topics in the following order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序介绍这些主题：
- en: Introducing terminal I/O fundamentals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍终端I/O基础知识
- en: Working with the terminal UI (size, color, styles) and cursors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与终端UI（大小、颜色、样式）和光标一起工作
- en: Processing keyboard inputs and scrolling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理键盘输入和滚动
- en: Processing mouse inputs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理鼠标输入
- en: A bulk of this chapter will be dedicated to explaining these concepts through
    a practical example. We will build a mini text viewer that will demonstrate key
    concepts of working with terminals. The text viewer will be able to load a file
    from disk and display its contents on the terminal interface. It will also allow
    a user to scroll through the contents using the various arrow keys on the keyboard,
    and display information on the header and footer bar.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将致力于通过一个实际示例来解释这些概念。我们将构建一个迷你文本查看器，以展示与终端一起工作的关键概念。该文本查看器将能够从磁盘加载文件并在终端界面上显示其内容。它还将允许用户使用键盘上的各种箭头键滚动内容，并在页眉和页脚栏上显示信息。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中代码的Git仓库可以在[https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui)找到。
- en: For those working on the Windows platform, a virtual machine needs to be installed
    for this chapter, as the third-party crate used for terminal management does not
    support the Windows platform (at the time of writing this book). It is recommended
    to install a virtual machine such as VirtualBox or equivalent running Linux for
    working with the code in this chapter. Instructions to install VirtualBox can
    be found at [https://www.virtualbox.org](https://www.virtualbox.org).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Windows平台上工作的开发者，需要为本章安装一个虚拟机，因为用于终端管理的第三方crate不支持Windows平台（在撰写本书时）。建议安装一个如VirtualBox或等效的运行Linux的虚拟机来处理本章中的代码。安装VirtualBox的说明可以在[https://www.virtualbox.org](https://www.virtualbox.org)找到。
- en: For working with terminals, Rust provides several features to read keypresses
    and to control *standard input* and *standard output* for a process. When a user
    types characters in the command line, the bytes generated are available to the
    program when the user presses the *Enter* key. This is useful for several types
    of programs. But for some types of programs, such as games or text editors, which
    require more fine-grained control, the program must process each character as
    it is typed by the user, which is also known as **raw mode**. There are several
    third-party crates available that make raw mode processing easy. We will be using
    one such crate, **Termion**, in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与终端一起工作，Rust提供了几个功能来读取按键，并控制进程的*标准输入*和*标准输出*。当用户在命令行中键入字符时，当用户按下*Enter*键时，生成的字节对程序可用。这对于多种类型的程序都很有用。但对于某些类型的程序，如游戏或文本编辑器，它们需要更精细的控制，程序必须处理用户键入的每个字符，这也就是所谓的**原始模式**。有几个第三方库可以轻松处理原始模式。在本章中，我们将使用这样一个库，**Termion**。
- en: Introducing terminal I/O fundamentals
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍终端I/O基础
- en: In this section, we'll cover the key characteristics of terminals, see an overview
    of the Termion crate, and define the scope of what we will be building in this
    project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍终端的关键特性，概述Termion库，并定义本项目我们将要构建的范围。
- en: Let's first look at some fundamentals of terminals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看终端的一些基础知识。
- en: Characteristics of terminals
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端的特性
- en: Terminals are devices with which users can interact with a computer. Using a
    terminal, a user can get command-line access to interact with the computer's operating
    system. A shell typically acts as the controlling program to drive the terminal
    on one hand and the interface with the operating system on the other hand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 终端是用户可以与之交互的设备。使用终端，用户可以获取命令行访问权限以与计算机的操作系统交互。shell通常充当控制程序，一方面驱动终端，另一方面与操作系统接口。
- en: Originally, UNIX systems were accessed using a terminal (also called a console)
    connected to a serial line. These terminals typically had a *24 x 80* row x column
    character-based interface, or in some cases, had rudimentary graphics capabilities.
    In order to perform operations on the terminal, such as clearing the screen or
    moving the cursor, specific escape sequences were used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，UNIX系统是通过连接到串行线的终端（也称为控制台）进行访问的。这些终端通常具有*24 x 80*行列的字符界面，或者在某些情况下具有基本的图形功能。为了在终端上执行操作，如清除屏幕或移动光标，使用了特定的转义序列。
- en: 'There are two modes in which terminals can operate:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 终端可以以两种模式运行：
- en: '**Canonical mode**: In canonical mode, the inputs from the user are processed
    line by line, and the user has to press the *Enter* key for the characters to
    be sent to the program for processing.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范模式**：在规范模式下，用户的输入按行处理，用户必须按下*Enter*键才能将字符发送到程序进行处理。'
- en: '**Noncanonical or raw mode**: In raw mode, terminal input is not collected
    into lines, but the program can read each character as it is typed by the user.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非规范或原始模式**：在原始模式下，终端输入不会被收集成行，但程序可以读取用户键入的每个字符。'
- en: Terminals can be either physical devices or virtual devices. Most terminals
    today are **pseudo-terminals**, which are virtual devices that are connected to
    a terminal device on one side, and to a program that drives the terminal device
    on the other end. Pseudo-terminals help us write programs where a user on one
    host machine can execute a *terminal-oriented program* on another host machine
    using network communications. An example of a pseudo-terminal application is **SSH**,
    which allows a user to log in to a remote host over a network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 终端可以是物理设备或虚拟设备。如今的大多数终端都是**伪终端**，它们是一端连接到终端设备，另一端连接到驱动终端设备的程序的虚拟设备。伪终端帮助我们编写程序，使得一台主机上的用户可以通过网络通信在另一台主机上执行**面向终端的程序**。一个伪终端应用的例子是**SSH**，它允许用户通过网络登录到远程主机。
- en: 'Terminal management includes the ability to perform the following things on
    a terminal screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 终端管理包括在终端屏幕上执行以下操作的能力：
- en: '**Color management**: Setting various foreground and background colors on the
    terminal and resetting the colors to default values.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色管理**：在终端上设置各种前景和背景颜色，并将颜色重置为默认值。'
- en: '**Style management**: Setting the style of text to *bold*, *italics*, *underline*,
    and so on.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式管理**：设置文本的样式为*粗体*、*斜体*、*下划线*等。'
- en: '**Cursor management**: Setting the cursor at a particular position, saving
    the current cursor position, showing and hiding a cursor, and other special features,
    such as blinking cursors.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光标管理**: 设置光标在特定位置，保存当前光标位置，显示和隐藏光标，以及其他特殊功能，如闪烁光标。'
- en: '**Event handling**: Listening and responding to keyboard and mouse events.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**: 监听并响应键盘和鼠标事件。'
- en: '**Screen handling**: Switching from main to alternate screens and clearing
    the screen.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕处理**: 从主屏幕切换到备用屏幕并清除屏幕。'
- en: '**Raw mode**: Switching a terminal to raw mode.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始模式**: 将终端切换到原始模式。'
- en: In this chapter, we will use a combination of the Rust standard library and
    the Termion crate to develop a terminal-oriented application. Let's see an overview
    of the Termion crate in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合使用Rust标准库和Termion crate来开发面向终端的应用程序。让我们在下一节中查看Termion crate的概述。
- en: The Termion crate
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Termion crate
- en: The Termion crate provides the features listed in the previous section, while
    also providing the user with easy-to-use command-line interfaces. We will be using
    many of these features in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Termion crate提供了上一节中列出的功能，同时也为用户提供易于使用的命令行界面。我们将在本章中使用许多这些功能。
- en: Why use an external crate for terminal management?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用外部crate进行终端管理？
- en: While it is technically possible to work at the byte level using the Rust standard
    library, it is cumbersome. External crates such as Termion help us group individual
    bytes to keypresses, and also implement many of the commonly used terminal management
    functions, which allows us to focus on the higher-level, user-directed functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上可以使用Rust标准库在字节级别工作，但这很麻烦。像Termion这样的外部crate帮助我们将单个字节分组为按键，并实现许多常用的终端管理功能，这使得我们可以专注于更高层次的、面向用户的功能。
- en: Let's discuss a few terminal management features of the Termion crate. The official
    documentation of the crate can be found at [https://docs.rs/termion/](https://docs.rs/termion/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论Termion crate的一些终端管理功能。该crate的官方文档可以在[https://docs.rs/termion/](https://docs.rs/termion/)找到。
- en: 'The Termion crate has the following key modules:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Termion crate具有以下关键模块：
- en: '`cursor`: For moving cursors'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cursor`: 用于移动光标'
- en: '`event`: For handling key and mouse events'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`: 用于处理键盘和鼠标事件'
- en: '`raw`: To switch the terminal to raw mode'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raw`: 用于将终端切换到原始模式'
- en: '`style`: To set various styles on text'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`: 用于设置文本的各种样式'
- en: '`clear`: To clear the entire screen or individual lines'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`: 用于清除整个屏幕或单独的行'
- en: '`color`: To set various colors to text'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`: 用于设置文本的各种颜色'
- en: '`input`: To handle advanced user input'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`: 用于处理高级用户输入'
- en: '`scroll`: To scroll across the screen'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scroll`: 用于在屏幕上滚动'
- en: 'To include the Termion crate, start a new project and add the following entry
    to `cargo.toml`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含Termion crate，开始一个新的项目并在`cargo.toml`中添加以下条目：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A few examples of Termion usage are shown through code snippets here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里通过代码片段展示了Termion的一些使用示例：
- en: 'To get the terminal size, use the following:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取终端大小，请使用以下命令：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To set the foreground color, use the following:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置前景颜色，请使用以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To set the background color and then reset the background color to the original
    state, use the following:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置背景颜色然后重置背景颜色到原始状态，请使用以下命令：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To set bold style, use the following:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置粗体样式，请使用以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To set the cursor to a particular position, use the following:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标设置到特定位置，请使用以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To clear the screen, use the following:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清除屏幕，请使用以下命令：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will use these terminal management features in a practical example in the
    upcoming sections. Let's now define what we are going to build in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中通过实际示例使用这些终端管理功能。现在，让我们定义本章将要构建的内容。
- en: What will we build?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将构建什么？
- en: We will develop a mini text viewer application. This application provides a
    terminal text interface to load a document from a directory location and view
    the document. The user can scroll through the document using keyboard keys. We'll
    build this project progressively over multiple iterations of code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个迷你文本查看器应用程序。此应用程序提供终端文本界面，从目录位置加载文档并查看文档。用户可以使用键盘键滚动文档。我们将逐步构建这个项目，通过多次代码迭代。
- en: '*Figure 7.1* shows the screen layout of what we will build in this chapter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1* 展示了我们将在本章中构建的屏幕布局：'
- en: '![Figure 7.1 – Text viewer screen layout](img/Figure_7.1_B16405.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 文本查看器屏幕布局](img/Figure_7.1_B16405.jpg)'
- en: Figure 7.1 – Text viewer screen layout
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 文本查看器屏幕布局
- en: 'There are three components in the terminal interface of the text viewer:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文本查看器的终端界面中有三个组件：
- en: '**Header bar**: This contains the title of the text editor.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题栏**：包含文本编辑器的标题。'
- en: '**Text area**: This contains the lines of text to be displayed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本区域**：包含要显示的文本行。'
- en: '**Footer bar**: This displays the position of the cursor, the number of lines
    of text in the file, and the name of the file being displayed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页脚栏**：显示光标位置、文件中的文本行数以及正在显示的文件名。'
- en: 'The text viewer will allow the user to perform the following actions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文本查看器将允许用户执行以下操作：
- en: Users can provide a filename as a command-line argument to display. This should
    be a valid filename that already exists. If the file does not exist, the program
    will display an error message and exit.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过命令行参数提供一个文件名来显示。这应该是一个已存在的有效文件名。如果文件不存在，程序将显示错误消息并退出。
- en: The text viewer will load the file contents and display them on the terminal.
    If the number of lines in a file is more than the terminal height, the program
    will allow the user to scroll through the document, and repaint the next set of
    lines.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本查看器将加载文件内容并在终端上显示它们。如果文件中的行数超过终端高度，程序将允许用户滚动文档，并重新绘制下一组行。
- en: Users can use the up, down, left, and right keys to scroll through the terminal.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以使用上、下、左、右键在终端中滚动。
- en: Users can press *Ctrl* + *Q* to exit the text viewer.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以按*Ctrl* + *Q*退出文本查看器。
- en: A popular text viewer would have a lot more features, but this core scope provides
    an adequate opportunity for us to learn about developing a terminal-oriented application
    in Rust.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的文本查看器会有更多功能，但这个核心范围为我们提供了足够的机会来学习如何在Rust中开发面向终端的应用程序。
- en: In this section, we've learned what terminals are and what kinds of features
    they support. We also saw an overview of how to work with the Termion crate and
    defined what we will be building as part of the project in this chapter. In the
    next section, we'll develop the first iteration of the text viewer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了终端是什么以及它们支持哪些功能。我们还概述了如何使用Termion crate，并定义了在本章项目中我们将构建的内容。在下一节中，我们将开发文本查看器的第一个迭代版本。
- en: Working with the terminal UI (size, color, styles) and cursors
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与终端UI（大小、颜色、样式）和光标一起工作
- en: In this section, we will build the first iteration of the text viewer. At the
    end of this section, we will have a program that will accept a filename from the
    command line, display its contents, and display a header and footer bar. We will
    use a Termion crate to set the color and style, get the terminal size, position
    the cursor at specific coordinates, and clear the screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建文本查看器的第一个迭代版本。在本节结束时，我们将有一个程序，它将从命令行接受文件名，显示其内容，并显示标题栏和页脚栏。我们将使用Termion
    crate来设置颜色和样式，获取终端大小，将光标定位在特定坐标，并清除屏幕。
- en: 'The code in this section is organized as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码组织如下：
- en: Writing data structures and the `main()` function
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写数据结构和`main()`函数
- en: Initializing the text viewer and getting the terminal size
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化文本查看器和获取终端大小
- en: Displaying a document and styling the terminal color, styles, and cursor position
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示文档并设置终端颜色、样式和光标位置
- en: Exiting the text viewer
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出文本查看器
- en: Let's start with data structures and the `main()` function of the text viewer
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数据结构和文本查看器的`main()`函数开始
- en: Writing data structures and the main() function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写数据结构和`main()`函数
- en: 'In this section, we''ll define the data structures needed to represent the
    text viewer in memory. We''ll also write the `main()` function, which coordinates
    and invokes various other functions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义在内存中表示文本查看器所需的数据结构。我们还将编写`main()`函数，该函数协调和调用各种其他函数：
- en: 'Create a new project and switch to the directory with the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目并使用以下命令切换到目录：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following to `cargo.toml`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`cargo.toml`中：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s first import the required modules from the standard library and the
    Termion crate:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从标准库和Termion crate中导入所需的模块：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s next define the data structures to represent a text viewer:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来定义表示文本查看器的数据结构：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code shows three data structures defined for the text viewer:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码显示了为文本查看器定义的三个数据结构：
- en: The document that will be displayed in the viewer is defined as a `Doc` struct,
    which is a vector of strings.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在查看器中显示的文档定义为`Doc`结构体，它是一个字符串向量。
- en: To store cursor position *x* and *y* coordinates and to record the current size
    of the terminal (the total number of rows and columns of characters), we have
    defined a `Coordinates` struct.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了存储光标位置 *x* 和 *y* 坐标以及记录当前终端的大小（字符的总行数和列数），我们定义了一个 `Coordinates` 结构体。
- en: The `TextViewer` struct is the main data structure representing the text viewer.
    The number of lines contained in the file being viewed is captured in the `doc_length`
    field. The name of the file to be shown in the viewer is recorded in the `file_name`
    field.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TextViewer` 结构体是表示文本查看器的主要数据结构。正在查看的文件中的行数被捕获在 `doc_length` 字段中。要在查看器中显示的文件名记录在
    `file_name` 字段中。'
- en: 'Let''s now define the `main()` function, which is the entry point for the text
    viewer application:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来定义 `main()` 函数，它是文本查看器应用程序的入口点：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `main()` function accepts a filename as a command-line parameter and exits
    the program if the file does not exist. Furthermore, if a filename is not provided
    as a command-line parameter, it displays an error message and exits the program.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main()` 函数接受一个文件名作为命令行参数，如果文件不存在则退出程序。此外，如果没有提供文件名作为命令行参数，它将显示错误消息并退出程序。'
- en: 'If the file is found, the `main()` function does the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到文件，`main()` 函数执行以下操作：
- en: It first calls the `init()` method on the `TextViewer` struct to initialize
    the variables.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它首先在 `TextViewer` 结构体上调用 `init()` 方法来初始化变量。
- en: Then, it invokes the `show_document()` method to display the contents of the
    file on the terminal screen.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，它调用 `show_document()` 方法来在终端屏幕上显示文件内容。
- en: Lastly, the `run()` method is called, which waits for user inputs to the process.
    If the user presses *Ctrl* + *Q*, the program exits.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，调用 `run()` 方法，该方法等待用户输入到进程。如果用户按下 *Ctrl* + *Q*，程序将退出。
- en: 'We will now write three method signatures – `init()`, `show_document()`, and
    `run()`. These three methods should be added to the `impl` block of the `TextViewer`
    struct, as shown:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将编写三个方法签名 – `init()`、`show_document()` 和 `run()`。这三个方法应该添加到 `TextViewer`
    结构体的 `impl` 块中，如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So far, we've defined the data structures and written the `main()` function
    with placeholders for the other functions. In the next section, let's write the
    function to initialize the text viewer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了数据结构并编写了带有其他函数占位符的 `main()` 函数。在下一节中，我们将编写初始化文本查看器的函数。
- en: Initializing the text viewer and getting the terminal size
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化文本查看器和获取终端大小
- en: When a user starts the text viewer with a document name, we have to initialize
    the text viewer with some information and perform startup tasks. This is the purpose
    of the `init()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用文档名启动文本查看器时，我们必须用一些信息初始化文本查看器并执行启动任务。这就是 `init()` 方法的用途。
- en: 'Here is the complete code for the `init()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `init()` 方法的完整代码：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code annotations in the `init()` method are described here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 方法中的代码注释在此处描述：'
- en: Initialize the buffer that is used to store the file contents.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化用于存储文件内容的缓冲区。
- en: Read the file contents as a string.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容作为字符串读取。
- en: Read each line from the file and store it in the `Doc` buffer.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取每一行并将其存储在 `Doc` 缓冲区中。
- en: Initialize the `doc_length` variable with the number of lines in the file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件中的行数初始化 `doc_length` 变量。
- en: Use the `termion` crate to get the terminal size.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `termion` 包来获取终端大小。
- en: Create a new struct of the `TextViewer` type and return it from the `init()`
    method.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `TextViewer` 类型的结构体，并在 `init()` 方法中返回它。
- en: We've written the initialization code for the text viewer. Next, we'll write
    the code to display the document contents on the terminal screen, and also display
    the header and footer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了文本查看器的初始化代码。接下来，我们将编写在终端屏幕上显示文档内容以及显示页眉和页脚的代码。
- en: Displaying a document and styling the terminal color, styles, and cursor position
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示文档并设置终端颜色、样式和光标位置
- en: We saw earlier the layout of the text viewer that we would like to build. There
    are three main parts of the text viewer screen layout – the header, the document
    area, and the footer. In this section, we'll write the primary function and supporting
    function to display the contents as per the defined screen layout.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了我们想要构建的文本查看器布局。文本查看器屏幕布局有三个主要部分 – 页眉、文档区域和页脚。在本节中，我们将编写显示内容的主体函数和支持函数，按照定义的屏幕布局。
- en: 'Let''s look at the `show_document()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `show_document()` 方法：
- en: src/bin/text-viewer1.rs
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer1.rs
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code annotations for the `show_document()` method are described here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述了`show_document()`方法的代码注释：
- en: Store the current positions of the cursor *x* and *y* coordinates in temp variables.
    This will be used to restore the cursor position in a later step.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标当前的*x*和*y*坐标存储在临时变量中。这将在后续步骤中用于恢复光标位置。
- en: Using the Termion crate, clear the entire screen and move the cursor to row
    1 and column 1 on the screen.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Termion crate，清除整个屏幕并将光标移动到屏幕的第1行第1列。
- en: Print the header bar of the text viewer. A background color of black and a foreground
    color of white is used to print text.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印文本查看器的标题栏。使用黑色背景和白色前景色打印文本。
- en: Display each line from the internal document buffer to the terminal screen.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内部文档缓冲区中的每一行显示到终端屏幕上。
- en: Move the cursor to the bottom of the screen (using the terminal size *y* coordinate)
    to print the footer.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移动到屏幕底部（使用终端大小*y*坐标）以打印页脚。
- en: Print the footer text in red and with bold style. Print the number of lines
    in the document and filename to the footer.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以红色和粗体样式打印页脚文本。在页脚中打印文档的行数和文件名。
- en: Reset the cursor to the original position (which was saved to temporary variable
    in *step 1*).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标重置到原始位置（在*步骤1*中保存到临时变量中）。
- en: 'Let''s look at the `set_pos()` helper method used by the `show_document()`
    method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`show_document()`方法使用的`set_pos()`辅助方法：
- en: src/bin/text-viewer1.rs
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer1.rs
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This helper method synchronizes the internal cursor tracking field (the `cur_pos`
    field of the `TextViewer` struct) and the on-screen cursor position.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助方法同步内部光标跟踪字段（`TextViewer`结构体的`cur_pos`字段）和屏幕上的光标位置。
- en: We now have the code to initialize the text viewer and to display the document
    on the screen. With this, a user can open a document in the text viewer and view
    its contents. But how does the user exit the text viewer? We'll find out in the
    next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了初始化文本查看器和在屏幕上显示文档的代码。有了这个，用户就可以在文本查看器中打开文档并查看其内容。但用户如何退出文本查看器？我们将在下一节中找到答案。
- en: Exiting the text viewer
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出文本查看器
- en: Let's say that a key combination of *Ctrl* + *Q* will let the user exit the
    text viewer program. How can we implement this code?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*Ctrl* + *Q*的键组合可以让用户退出文本查看器程序。我们如何实现这段代码？
- en: 'To achieve this, we need a way to listen for user key strokes, and when a particular
    key combination is pressed, we should exit the program. As discussed earlier,
    we need to get the terminal into raw mode of operation, where each character is
    available for the program to evaluate, rather than wait for the user to press
    the *Enter* key. Once we get the raw characters, the rest of it becomes fairly
    straightforward. Let''s write the code to do this in the `run()` method, within
    the `impl TextViewer` block, as shown:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要一种监听用户按键的方法，当按下特定的键组合时，程序应该退出。如前所述，我们需要将终端设置为原始操作模式，其中每个字符都可供程序评估，而不是等待用户按下*Enter*键。一旦我们获取了原始字符，其余的操作就相对简单。让我们在`impl
    TextViewer`块中的`run()`方法中编写代码来完成这个操作，如下所示：
- en: src/bin/text-viewer1.rs
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer1.rs
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the code shown, we use the `stdin.keys()` method to listen for user inputs
    in a loop. `stdout()` is used to display text to the terminal. When *Ctrl* + *Q*
    is pressed, the program exits.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们使用`stdin.keys()`方法在循环中监听用户输入。`stdout()`用于在终端显示文本。当按下*Ctrl* + *Q*时，程序退出。
- en: 'We can now run the program with the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令运行程序：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we have not implemented scrolling yet, pass a filename to the program
    that has 24 lines or less of content (this is typically the default height of
    a standard terminal in terms of the number of rows). You will see the text viewer
    *open up* and the *header bar*, *footer bar*, and *file contents* printed to the
    terminal. Type *Ctrl* + *Q* to exit. Note that you have to specify the filename
    with the full file path as a command-line argument.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未实现滚动，请将包含24行或更少内容的文件名传递给程序（这在行数方面通常是标准终端的默认高度）。您将看到文本查看器*打开*，并且*标题栏*、*页脚栏*和*文件内容*被打印到终端。按*Ctrl*
    + *Q*退出。请注意，您必须指定完整的文件路径作为命令行参数。
- en: In this section, we learned how to get the terminal size, set the foreground
    and background colors, and apply bold style using the Termion crate. We also learned
    how to position the cursor onscreen at specified coordinates, and how to clear
    the screen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Termion crate获取终端大小、设置前景和背景颜色以及应用粗体样式。我们还学习了如何在指定坐标上定位屏幕上的光标，以及如何清除屏幕。
- en: In the next section, we will look at processing keystrokes for user navigation
    within the document displayed in the text editor and how to implement scrolling.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在文本编辑器中处理用户在文档内导航的按键以及如何实现滚动。
- en: Processing keyboard inputs and scrolling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理键盘输入和滚动
- en: In the previous section, we built the first iteration of our text viewer terminal-oriented
    application. We were able to display a file with fewer than 24 lines and see the
    header and footer bar containing some information. Finally, we were able to exit
    the program with *Ctrl* + *Q*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了我们面向文本的终端应用程序的第一个迭代版本。我们能够显示少于24行的文件，并看到包含一些信息的页眉和页脚栏。最后，我们能够通过*Ctrl*
    + *Q*退出程序。
- en: 'In this section, we will add the following features to the text viewer:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向文本查看器添加以下功能：
- en: Provide the ability to display files of any size.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供显示任何大小文件的能力。
- en: Provide the ability for the user to scroll through the document using arrow
    keys.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户使用箭头键滚动文档的能力。
- en: Add cursor position coordinates to the footer bar.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标位置坐标添加到页脚栏。
- en: Let's begin by creating a new version of the code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建代码的新版本开始。
- en: 'Copy the original code to a new file, as shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始代码复制到新文件中，如下所示：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This section is organized into three parts. First, we''ll implement the logic
    to respond to the following keystrokes from a user: up, down, left, right, and
    backspace. Next, we''ll implement the functionality to update the cursor position
    in internal data structures, and simultaneously update the cursor position onscreen.
    Lastly, we''ll allow scrolling through a multi-page document.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为三个部分。首先，我们将实现响应用户以下按键的逻辑：上、下、左、右和退格。接下来，我们将实现更新内部数据结构中光标位置的功能，并同时更新屏幕上的光标位置。最后，我们将允许在多页文档中滚动。
- en: We'll begin with handling user keystrokes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从处理用户按键开始。
- en: Listening to keystrokes from the user
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听用户的按键
- en: 'Let''s modify the `run()` method to act on user inputs and scroll through the
    document. We also want to record and display the current cursor position in the
    footer bar. The code is shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`run()`方法以响应用户输入并滚动文档。我们还想记录并显示当前光标位置在页脚栏中。代码如下所示：
- en: src/bin/text-viewer2.rs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer2.rs
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lines in bold show the changes to the `run()` method from the earlier version.
    In this code, we are listening for up, down, left, right, and backspace keys.
    For any of these keypresses, we are incrementing the *x* or *y* coordinate appropriately
    using one of the following methods: `inc_x()`, `inc_y()`, `dec_x()`, or `dec_y()`.
    For example, if the right arrow is pressed, the *x* coordinate of the cursor position
    is incremented using the `inc_x()` method, and if the down arrow is pressed, only
    the *y* coordinate is incremented using the `inc_y()` method. The changes to coordinates
    are recorded in the internal data structure (the `cur_pos` field of the `TextViewer`
    struct). Also, the cursor is repositioned on the screen. All these are achieved
    by the `inc_x()`, `inc_y()`, `dec_x()`, and `dec_y()` methods.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体行显示了从早期版本中`run()`方法的更改。在这段代码中，我们正在监听上、下、左、右和退格键。对于这些按键中的任何一种，我们都会使用以下方法之一：`inc_x()`、`inc_y()`、`dec_x()`或`dec_y()`适当地增加*x*或*y*坐标。例如，如果按下右箭头，光标位置的*x*坐标将使用`inc_x()`方法增加，如果按下下箭头，则仅使用`inc_y()`方法增加*y*坐标。坐标的更改记录在内部数据结构（`TextViewer`结构体的`cur_pos`字段）中。此外，光标在屏幕上重新定位。所有这些操作都是通过`inc_x()`、`inc_y()`、`dec_x()`和`dec_y()`方法实现的。
- en: After updating the cursor position, the screen is refreshed fully and repainted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更新光标位置后，屏幕将完全刷新并重新绘制。
- en: Let's look at implementing the four methods to update cursor coordinates, and
    reposition the cursor on the screen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现四个更新光标坐标并重新定位屏幕上光标的方法。
- en: Positioning the terminal cursor
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位终端光标
- en: 'Let''s write the code for the `inc_x()`, `inc_y()`, `dec_x()`, and `dec_y()`
    methods. These should be added as a part of the `impl TextViewer` block of code
    like the other methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`inc_x()`、`inc_y()`、`dec_x()`和`dec_y()`方法的代码。这些方法应作为`impl TextViewer`代码块的一部分添加，就像其他方法一样：
- en: src/bin/text-viewer2.rs
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer2.rs
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The structure of all these four methods is similar and each performs only two
    steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这四种方法的结构相似，每个方法只执行两个步骤：
- en: Depending on the keypress, the corresponding coordinate (*x* or *y*) is incremented
    or decremented and recorded in the `cur_pos` internal variable.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据按键，相应的坐标(*x*或*y*)将增加或减少，并记录在`cur_pos`内部变量中。
- en: The cursor is repositioned on the screen at the new coordinates.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光标被重新定位到屏幕上的新坐标。
- en: We now have a mechanism to update the cursor coordinates whenever the user presses
    the up, down, left, right, or backspace keys. But that's not enough. The cursor
    should be repositioned on the screen to the latest cursor coordinates. For this,
    we will have to update the `show_document()` method, which we will do in the next
    section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个机制，当用户按下上、下、左、右或退格键时更新光标坐标。但这还不够。光标应该被重新定位到屏幕上的最新光标坐标。为此，我们将不得不更新`show_document()`方法，我们将在下一节中这样做。
- en: Enabling scrolling on the terminal
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在终端上启用滚动
- en: We have so far implemented the code to listen for user keystrokes and reposition
    the cursor onscreen. Now, let's turn our attention to another major issue in the
    code. If we load a document that has fewer lines than the terminal height, then
    the code works fine. But consider a situation where the terminal has the capacity
    to display 24 rows of characters, and there are 50 lines in the document to be
    displayed on text viewer. Our code cannot handle it. We're going to fix it in
    this section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了监听用户按键并重新定位光标在屏幕上的代码。现在，让我们将注意力转向代码中的另一个主要问题。如果我们加载一个行数少于终端高度的文档，代码运行良好。但考虑一种情况，即终端可以显示24行字符，而要显示在文本查看器上的文档有50行。我们的代码无法处理这种情况。我们将在本节中修复它。
- en: 'To display more lines than is possible for the screen size, it is not enough
    to reposition the cursor. We will have to repaint the screen to fit a portion
    of the document in the terminal screen depending on the cursor location. Let''s
    see the modifications needed to the `show_document()` method to enable scrolling.
    Look for the following lines of code in the `show_document()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示比屏幕尺寸允许的更多行，仅仅重新定位光标是不够的。我们必须重新绘制屏幕，以便根据光标位置在终端屏幕上显示文档的一部分。让我们看看需要修改`show_document()`方法以启用滚动的修改。在`show_document()`方法中查找以下代码行：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Replace the preceding with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下代码：
- en: src/bin/text-viewer2.rs
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: src/bin/text-viewer2.rs
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The code annotations in the `show_document()` method snippet are described
    here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_document()`方法代码片段中的代码注释在此处描述：'
- en: First, check whether the number of lines in the input document is less than
    the terminal height. If so, display all lines from the input document on the terminal
    screen.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查输入文档中的行数是否少于终端高度。如果是这样，则在终端屏幕上显示输入文档中的所有行。
- en: If the number of lines in the input document is greater than the terminal height,
    we have to display the document in parts. Initially, the first set of lines from
    the document are displayed onscreen corresponding to the number of rows that will
    fit into the terminal height. For example, if we allocate 21 lines to the text
    display area, then as long as the cursor is within these lines, the original set
    of lines is displayed. If the user scrolls down further, then the next set of
    lines is displayed onscreen.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入文档中的行数大于终端高度，我们必须分部分显示文档。最初，屏幕上显示的是与终端高度能容纳的行数相对应的文档的第一组行。例如，如果我们为文本显示区域分配21行，那么只要光标位于这些行内，就会显示原始的行集。如果用户继续向下滚动，则下一组行会在屏幕上显示。
- en: 'Let''s run the program with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下命令运行程序：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can try two kinds of file inputs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试两种类型的文件输入：
- en: A file where the number of lines is less than the terminal height
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行数少于终端高度的文件
- en: A file where the number of lines is more than the terminal height
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行数多于终端高度的文件
- en: You can use the up, down, left, and right arrows to scroll through the document
    and see the contents. You will also see the current cursor position (both *x*
    and *y* coordinates) displayed on the footer bar. Type *Ctrl* + *Q* to exit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上、下、左和右箭头在文档中滚动并查看内容。你还会在页脚栏中看到当前光标位置（*x*和*y*坐标）。按*Ctrl* + *Q*退出。
- en: This concludes the text viewer project for this chapter. You have built a functional
    text viewer that can display files of any size, and can scroll through its contents
    using the arrow keys. You can also view the current position of the cursor along
    with the filename and number of lines in the footer bar.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本章的文本查看器项目。你已经构建了一个功能性的文本查看器，可以显示任何大小的文件，并且可以使用箭头键滚动其内容。你还可以在页脚栏中查看光标当前位置、文件名和行数。
- en: Note on the text viewer
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文本查看器的说明
- en: Note that what we have implemented is a mini version of a text viewer in under
    200 lines of code. While it demonstrates the key functionality, additional features
    and edge cases can be implemented by you to enhance the application and improve
    its usability. Furthermore, this viewer can also be converted into a full-fledged
    text editor. These are left to you, the reader, as an exercise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实现的是一个少于 200 行代码的迷你文本查看器版本。虽然它展示了关键功能，但你可以通过实现额外的功能和边缘情况来增强应用程序并提高其可用性。此外，这个查看器也可以转换成一个完整的文本编辑器。这些留给读者作为练习。
- en: We've completed the implementation of the text viewer project in this section.
    The text viewer is a classic command-line application and does not have a GUI
    interface where mouse inputs are needed. But it is important to learn how to handle
    mouse events, for developing GUI-based terminal interfaces. We'll learn how to
    do that in the next section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经完成了文本查看器项目的实现。文本查看器是一个经典的命令行应用程序，它没有需要鼠标输入的GUI界面。但是，学习如何处理鼠标事件对于开发基于GUI的终端界面非常重要。我们将在下一节中学习如何做到这一点。
- en: Processing mouse inputs
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理鼠标输入
- en: Like keyboard events, the Termion crate also supports the ability to listen
    for mouse events, track the mouse cursor location, and react to it in code. Let's
    see how to do this here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与键盘事件一样，Termion crate 也支持监听鼠标事件、跟踪鼠标光标位置并在代码中对其做出反应的能力。让我们看看如何在这里实现这一点。
- en: Create a new source file called `mouse-events.rs` under `src/bin`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/bin` 下创建一个名为 `mouse-events.rs` 的新源文件。
- en: 'Here is the code logic:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码逻辑：
- en: Import the needed modules.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块。
- en: Enable mouse support in the terminal.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中启用鼠标支持。
- en: Clear the screen.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除屏幕。
- en: Create an iterator over incoming events.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对传入事件进行迭代的迭代器。
- en: Listen to mouse presses, release and hold events, and display the mouse cursor
    location on the terminal screen.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听鼠标按下、释放和保持事件，并在终端屏幕上显示鼠标光标位置。
- en: The code is explained in snippets corresponding to each of these points.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在每个这些点的片段中进行解释。
- en: 'Let''s first look at module imports:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看模块导入：
- en: 'We''re importing the `termion` crate modules for switching to raw mode, detecting
    the cursor position, and listening to mouse events:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在导入 `termion` crate 模块以切换到原始模式、检测光标位置和监听鼠标事件：
- en: '[PRE24]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `main()` function, let''s enable mouse support as shown:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，让我们按照以下方式启用鼠标支持：
- en: '[PRE25]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To ensure that previous text on the terminal screen does not interfere with
    this program, let''s clear the screen, as shown here:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保终端屏幕上的先前文本不会干扰此程序，让我们按照以下方式清除屏幕：
- en: '[PRE26]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, let''s create an iterator over incoming events and listen to mouse events.
    Display the location of the mouse cursor on the terminal:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个对传入事件进行迭代的迭代器，并监听鼠标事件。在终端上显示鼠标光标的位置：
- en: '[PRE27]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the code shown, we are listening to both keyboard events and mouse events.
    In keyboard events, we are specifically looking for the *Q* key, which exits the
    program. We are also listening to mouse events – press, release, and hold. In
    this case, we position the cursor at the specified coordinates and also print
    out the coordinates to the terminal screen.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们正在监听键盘事件和鼠标事件。在键盘事件中，我们特别寻找 *Q* 键，用于退出程序。我们也在监听鼠标事件——按下、释放和保持。在这种情况下，我们将光标定位在指定的坐标上，并在终端屏幕上打印出坐标。
- en: 'Run the program with the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE28]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Click around the screen with the mouse, and you will see the cursor position
    coordinates displayed on the terminal screen. Press `q` to exit.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标在屏幕上点击，你将看到光标位置坐标在终端屏幕上显示。按 `q` 退出。
- en: With this, we conclude the section on working with mouse events on the terminal.
    This also concludes the chapter on terminal I/O management using Rust.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了关于在终端上处理鼠标事件的章节。这也结束了使用 Rust 进行终端 I/O 管理的章节。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned the basics of terminal management by writing a mini
    text viewer. We learned how to use the Termion library to get the terminal size,
    set the foreground and background colors, and set styles. After this, we learned
    how to work with cursors on the terminal, including clearing the screen, positioning
    the cursor at a particular set of coordinates, and keeping track of the current
    cursor position.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过编写一个迷你文本查看器学习了终端管理的基础知识。我们学习了如何使用 Termion 库获取终端大小、设置前景和背景颜色以及设置样式。之后，我们学习了如何在终端上处理光标，包括清除屏幕、将光标定位在特定的坐标集上以及跟踪当前光标位置。
- en: We learned how to listen to user inputs and track the keyboard arrow keys for
    scrolling operations, including left, right, up, and down. We wrote code to display
    document contents dynamically as the user scrolls through it, keeping the constraints
    of the terminal size in mind. As an exercise, you can refine the text viewer,
    and also add functionality to convert the text viewer into a full-fledged editor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何监听用户输入并跟踪键盘箭头键以进行滚动操作，包括左、右、上和下。我们编写了代码，在用户滚动文档时动态显示文档内容，同时考虑到终端大小的限制。作为练习，你可以改进文本查看器，还可以添加将文本查看器转换为完整编辑器的功能。
- en: Learning these features is important to write applications such as terminal-based
    games, editing and viewing applications and terminal graphical interfaces, and
    to provide terminal-based dashboards.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些功能对于编写基于终端的游戏、编辑和查看应用程序以及终端图形界面，以及提供基于终端的仪表板非常重要。
- en: In the next chapter, we will learn the basics of process management using Rust,
    including starting and stopping processes and handling errors and signals.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用 Rust 进行进程管理的基础知识，包括启动和停止进程以及处理错误和信号。
