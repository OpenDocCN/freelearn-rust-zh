- en: '*Chapter 7*: Implementing Terminal I/O in Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to work with files and directories.
    We also built a shell command in Rust that generates consolidated source code
    metrics for Rust source files in a project directory.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at building **terminal-based applications** in
    Rust. Terminal applications are an integral part of many software programs, including
    **games**, **text editors**, and **terminal emulators**. For developing these
    types of programs, it helps to understand how to build customized terminal interface-based
    applications. This is the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will review the basics of how terminals work, and then
    look at how to perform various types of actions on a terminal, such as setting
    colors and styles, performing cursor operations (such as clearing and positioning),
    and working with keyboard and mouse inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the topics in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing terminal I/O fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the terminal UI (size, color, styles) and cursors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing keyboard inputs and scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing mouse inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bulk of this chapter will be dedicated to explaining these concepts through
    a practical example. We will build a mini text viewer that will demonstrate key
    concepts of working with terminals. The text viewer will be able to load a file
    from disk and display its contents on the terminal interface. It will also allow
    a user to scroll through the contents using the various arrow keys on the keyboard,
    and display information on the header and footer bar.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Git repo for the code in this chapter can be found at [https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui](https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter07/tui).
  prefs: []
  type: TYPE_NORMAL
- en: For those working on the Windows platform, a virtual machine needs to be installed
    for this chapter, as the third-party crate used for terminal management does not
    support the Windows platform (at the time of writing this book). It is recommended
    to install a virtual machine such as VirtualBox or equivalent running Linux for
    working with the code in this chapter. Instructions to install VirtualBox can
    be found at [https://www.virtualbox.org](https://www.virtualbox.org).
  prefs: []
  type: TYPE_NORMAL
- en: For working with terminals, Rust provides several features to read keypresses
    and to control *standard input* and *standard output* for a process. When a user
    types characters in the command line, the bytes generated are available to the
    program when the user presses the *Enter* key. This is useful for several types
    of programs. But for some types of programs, such as games or text editors, which
    require more fine-grained control, the program must process each character as
    it is typed by the user, which is also known as **raw mode**. There are several
    third-party crates available that make raw mode processing easy. We will be using
    one such crate, **Termion**, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing terminal I/O fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll cover the key characteristics of terminals, see an overview
    of the Termion crate, and define the scope of what we will be building in this
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at some fundamentals of terminals.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of terminals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminals are devices with which users can interact with a computer. Using a
    terminal, a user can get command-line access to interact with the computer's operating
    system. A shell typically acts as the controlling program to drive the terminal
    on one hand and the interface with the operating system on the other hand.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, UNIX systems were accessed using a terminal (also called a console)
    connected to a serial line. These terminals typically had a *24 x 80* row x column
    character-based interface, or in some cases, had rudimentary graphics capabilities.
    In order to perform operations on the terminal, such as clearing the screen or
    moving the cursor, specific escape sequences were used.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two modes in which terminals can operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canonical mode**: In canonical mode, the inputs from the user are processed
    line by line, and the user has to press the *Enter* key for the characters to
    be sent to the program for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noncanonical or raw mode**: In raw mode, terminal input is not collected
    into lines, but the program can read each character as it is typed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminals can be either physical devices or virtual devices. Most terminals
    today are **pseudo-terminals**, which are virtual devices that are connected to
    a terminal device on one side, and to a program that drives the terminal device
    on the other end. Pseudo-terminals help us write programs where a user on one
    host machine can execute a *terminal-oriented program* on another host machine
    using network communications. An example of a pseudo-terminal application is **SSH**,
    which allows a user to log in to a remote host over a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminal management includes the ability to perform the following things on
    a terminal screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Color management**: Setting various foreground and background colors on the
    terminal and resetting the colors to default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Style management**: Setting the style of text to *bold*, *italics*, *underline*,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cursor management**: Setting the cursor at a particular position, saving
    the current cursor position, showing and hiding a cursor, and other special features,
    such as blinking cursors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handling**: Listening and responding to keyboard and mouse events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen handling**: Switching from main to alternate screens and clearing
    the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw mode**: Switching a terminal to raw mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use a combination of the Rust standard library and
    the Termion crate to develop a terminal-oriented application. Let's see an overview
    of the Termion crate in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Termion crate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Termion crate provides the features listed in the previous section, while
    also providing the user with easy-to-use command-line interfaces. We will be using
    many of these features in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why use an external crate for terminal management?
  prefs: []
  type: TYPE_NORMAL
- en: While it is technically possible to work at the byte level using the Rust standard
    library, it is cumbersome. External crates such as Termion help us group individual
    bytes to keypresses, and also implement many of the commonly used terminal management
    functions, which allows us to focus on the higher-level, user-directed functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss a few terminal management features of the Termion crate. The official
    documentation of the crate can be found at [https://docs.rs/termion/](https://docs.rs/termion/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Termion crate has the following key modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cursor`: For moving cursors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: For handling key and mouse events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raw`: To switch the terminal to raw mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: To set various styles on text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`: To clear the entire screen or individual lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: To set various colors to text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input`: To handle advanced user input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scroll`: To scroll across the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To include the Termion crate, start a new project and add the following entry
    to `cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A few examples of Termion usage are shown through code snippets here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the terminal size, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the foreground color, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the background color and then reset the background color to the original
    state, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set bold style, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the cursor to a particular position, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To clear the screen, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use these terminal management features in a practical example in the
    upcoming sections. Let's now define what we are going to build in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What will we build?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a mini text viewer application. This application provides a
    terminal text interface to load a document from a directory location and view
    the document. The user can scroll through the document using keyboard keys. We'll
    build this project progressively over multiple iterations of code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.1* shows the screen layout of what we will build in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Text viewer screen layout](img/Figure_7.1_B16405.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Text viewer screen layout
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three components in the terminal interface of the text viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header bar**: This contains the title of the text editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text area**: This contains the lines of text to be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Footer bar**: This displays the position of the cursor, the number of lines
    of text in the file, and the name of the file being displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The text viewer will allow the user to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can provide a filename as a command-line argument to display. This should
    be a valid filename that already exists. If the file does not exist, the program
    will display an error message and exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text viewer will load the file contents and display them on the terminal.
    If the number of lines in a file is more than the terminal height, the program
    will allow the user to scroll through the document, and repaint the next set of
    lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can use the up, down, left, and right keys to scroll through the terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can press *Ctrl* + *Q* to exit the text viewer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A popular text viewer would have a lot more features, but this core scope provides
    an adequate opportunity for us to learn about developing a terminal-oriented application
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned what terminals are and what kinds of features
    they support. We also saw an overview of how to work with the Termion crate and
    defined what we will be building as part of the project in this chapter. In the
    next section, we'll develop the first iteration of the text viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the terminal UI (size, color, styles) and cursors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build the first iteration of the text viewer. At the
    end of this section, we will have a program that will accept a filename from the
    command line, display its contents, and display a header and footer bar. We will
    use a Termion crate to set the color and style, get the terminal size, position
    the cursor at specific coordinates, and clear the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this section is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing data structures and the `main()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the text viewer and getting the terminal size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a document and styling the terminal color, styles, and cursor position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the text viewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with data structures and the `main()` function of the text viewer
  prefs: []
  type: TYPE_NORMAL
- en: Writing data structures and the main() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll define the data structures needed to represent the
    text viewer in memory. We''ll also write the `main()` function, which coordinates
    and invokes various other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and switch to the directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to `cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s first import the required modules from the standard library and the
    Termion crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s next define the data structures to represent a text viewer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code shows three data structures defined for the text viewer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The document that will be displayed in the viewer is defined as a `Doc` struct,
    which is a vector of strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To store cursor position *x* and *y* coordinates and to record the current size
    of the terminal (the total number of rows and columns of characters), we have
    defined a `Coordinates` struct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `TextViewer` struct is the main data structure representing the text viewer.
    The number of lines contained in the file being viewed is captured in the `doc_length`
    field. The name of the file to be shown in the viewer is recorded in the `file_name`
    field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now define the `main()` function, which is the entry point for the text
    viewer application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `main()` function accepts a filename as a command-line parameter and exits
    the program if the file does not exist. Furthermore, if a filename is not provided
    as a command-line parameter, it displays an error message and exits the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the file is found, the `main()` function does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It first calls the `init()` method on the `TextViewer` struct to initialize
    the variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, it invokes the `show_document()` method to display the contents of the
    file on the terminal screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, the `run()` method is called, which waits for user inputs to the process.
    If the user presses *Ctrl* + *Q*, the program exits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now write three method signatures – `init()`, `show_document()`, and
    `run()`. These three methods should be added to the `impl` block of the `TextViewer`
    struct, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far, we've defined the data structures and written the `main()` function
    with placeholders for the other functions. In the next section, let's write the
    function to initialize the text viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the text viewer and getting the terminal size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user starts the text viewer with a document name, we have to initialize
    the text viewer with some information and perform startup tasks. This is the purpose
    of the `init()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code for the `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code annotations in the `init()` method are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the buffer that is used to store the file contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the file contents as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read each line from the file and store it in the `Doc` buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the `doc_length` variable with the number of lines in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `termion` crate to get the terminal size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new struct of the `TextViewer` type and return it from the `init()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've written the initialization code for the text viewer. Next, we'll write
    the code to display the document contents on the terminal screen, and also display
    the header and footer.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a document and styling the terminal color, styles, and cursor position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw earlier the layout of the text viewer that we would like to build. There
    are three main parts of the text viewer screen layout – the header, the document
    area, and the footer. In this section, we'll write the primary function and supporting
    function to display the contents as per the defined screen layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `show_document()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer1.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code annotations for the `show_document()` method are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: Store the current positions of the cursor *x* and *y* coordinates in temp variables.
    This will be used to restore the cursor position in a later step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Termion crate, clear the entire screen and move the cursor to row
    1 and column 1 on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the header bar of the text viewer. A background color of black and a foreground
    color of white is used to print text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display each line from the internal document buffer to the terminal screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the cursor to the bottom of the screen (using the terminal size *y* coordinate)
    to print the footer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the footer text in red and with bold style. Print the number of lines
    in the document and filename to the footer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the cursor to the original position (which was saved to temporary variable
    in *step 1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the `set_pos()` helper method used by the `show_document()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer1.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This helper method synchronizes the internal cursor tracking field (the `cur_pos`
    field of the `TextViewer` struct) and the on-screen cursor position.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the code to initialize the text viewer and to display the document
    on the screen. With this, a user can open a document in the text viewer and view
    its contents. But how does the user exit the text viewer? We'll find out in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting the text viewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that a key combination of *Ctrl* + *Q* will let the user exit the
    text viewer program. How can we implement this code?
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need a way to listen for user key strokes, and when a particular
    key combination is pressed, we should exit the program. As discussed earlier,
    we need to get the terminal into raw mode of operation, where each character is
    available for the program to evaluate, rather than wait for the user to press
    the *Enter* key. Once we get the raw characters, the rest of it becomes fairly
    straightforward. Let''s write the code to do this in the `run()` method, within
    the `impl TextViewer` block, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer1.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the code shown, we use the `stdin.keys()` method to listen for user inputs
    in a loop. `stdout()` is used to display text to the terminal. When *Ctrl* + *Q*
    is pressed, the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the program with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we have not implemented scrolling yet, pass a filename to the program
    that has 24 lines or less of content (this is typically the default height of
    a standard terminal in terms of the number of rows). You will see the text viewer
    *open up* and the *header bar*, *footer bar*, and *file contents* printed to the
    terminal. Type *Ctrl* + *Q* to exit. Note that you have to specify the filename
    with the full file path as a command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to get the terminal size, set the foreground
    and background colors, and apply bold style using the Termion crate. We also learned
    how to position the cursor onscreen at specified coordinates, and how to clear
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at processing keystrokes for user navigation
    within the document displayed in the text editor and how to implement scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: Processing keyboard inputs and scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we built the first iteration of our text viewer terminal-oriented
    application. We were able to display a file with fewer than 24 lines and see the
    header and footer bar containing some information. Finally, we were able to exit
    the program with *Ctrl* + *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will add the following features to the text viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide the ability to display files of any size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the ability for the user to scroll through the document using arrow
    keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add cursor position coordinates to the footer bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by creating a new version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the original code to a new file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This section is organized into three parts. First, we''ll implement the logic
    to respond to the following keystrokes from a user: up, down, left, right, and
    backspace. Next, we''ll implement the functionality to update the cursor position
    in internal data structures, and simultaneously update the cursor position onscreen.
    Lastly, we''ll allow scrolling through a multi-page document.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin with handling user keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to keystrokes from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s modify the `run()` method to act on user inputs and scroll through the
    document. We also want to record and display the current cursor position in the
    footer bar. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer2.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines in bold show the changes to the `run()` method from the earlier version.
    In this code, we are listening for up, down, left, right, and backspace keys.
    For any of these keypresses, we are incrementing the *x* or *y* coordinate appropriately
    using one of the following methods: `inc_x()`, `inc_y()`, `dec_x()`, or `dec_y()`.
    For example, if the right arrow is pressed, the *x* coordinate of the cursor position
    is incremented using the `inc_x()` method, and if the down arrow is pressed, only
    the *y* coordinate is incremented using the `inc_y()` method. The changes to coordinates
    are recorded in the internal data structure (the `cur_pos` field of the `TextViewer`
    struct). Also, the cursor is repositioned on the screen. All these are achieved
    by the `inc_x()`, `inc_y()`, `dec_x()`, and `dec_y()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: After updating the cursor position, the screen is refreshed fully and repainted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at implementing the four methods to update cursor coordinates, and
    reposition the cursor on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the terminal cursor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the code for the `inc_x()`, `inc_y()`, `dec_x()`, and `dec_y()`
    methods. These should be added as a part of the `impl TextViewer` block of code
    like the other methods:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer2.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of all these four methods is similar and each performs only two
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the keypress, the corresponding coordinate (*x* or *y*) is incremented
    or decremented and recorded in the `cur_pos` internal variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cursor is repositioned on the screen at the new coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a mechanism to update the cursor coordinates whenever the user presses
    the up, down, left, right, or backspace keys. But that's not enough. The cursor
    should be repositioned on the screen to the latest cursor coordinates. For this,
    we will have to update the `show_document()` method, which we will do in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling scrolling on the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have so far implemented the code to listen for user keystrokes and reposition
    the cursor onscreen. Now, let's turn our attention to another major issue in the
    code. If we load a document that has fewer lines than the terminal height, then
    the code works fine. But consider a situation where the terminal has the capacity
    to display 24 rows of characters, and there are 50 lines in the document to be
    displayed on text viewer. Our code cannot handle it. We're going to fix it in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display more lines than is possible for the screen size, it is not enough
    to reposition the cursor. We will have to repaint the screen to fit a portion
    of the document in the terminal screen depending on the cursor location. Let''s
    see the modifications needed to the `show_document()` method to enable scrolling.
    Look for the following lines of code in the `show_document()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: src/bin/text-viewer2.rs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The code annotations in the `show_document()` method snippet are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check whether the number of lines in the input document is less than
    the terminal height. If so, display all lines from the input document on the terminal
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of lines in the input document is greater than the terminal height,
    we have to display the document in parts. Initially, the first set of lines from
    the document are displayed onscreen corresponding to the number of rows that will
    fit into the terminal height. For example, if we allocate 21 lines to the text
    display area, then as long as the cursor is within these lines, the original set
    of lines is displayed. If the user scrolls down further, then the next set of
    lines is displayed onscreen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the program with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try two kinds of file inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: A file where the number of lines is less than the terminal height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file where the number of lines is more than the terminal height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the up, down, left, and right arrows to scroll through the document
    and see the contents. You will also see the current cursor position (both *x*
    and *y* coordinates) displayed on the footer bar. Type *Ctrl* + *Q* to exit.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the text viewer project for this chapter. You have built a functional
    text viewer that can display files of any size, and can scroll through its contents
    using the arrow keys. You can also view the current position of the cursor along
    with the filename and number of lines in the footer bar.
  prefs: []
  type: TYPE_NORMAL
- en: Note on the text viewer
  prefs: []
  type: TYPE_NORMAL
- en: Note that what we have implemented is a mini version of a text viewer in under
    200 lines of code. While it demonstrates the key functionality, additional features
    and edge cases can be implemented by you to enhance the application and improve
    its usability. Furthermore, this viewer can also be converted into a full-fledged
    text editor. These are left to you, the reader, as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We've completed the implementation of the text viewer project in this section.
    The text viewer is a classic command-line application and does not have a GUI
    interface where mouse inputs are needed. But it is important to learn how to handle
    mouse events, for developing GUI-based terminal interfaces. We'll learn how to
    do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing mouse inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like keyboard events, the Termion crate also supports the ability to listen
    for mouse events, track the mouse cursor location, and react to it in code. Let's
    see how to do this here.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new source file called `mouse-events.rs` under `src/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the needed modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable mouse support in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an iterator over incoming events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen to mouse presses, release and hold events, and display the mouse cursor
    location on the terminal screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is explained in snippets corresponding to each of these points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at module imports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re importing the `termion` crate modules for switching to raw mode, detecting
    the cursor position, and listening to mouse events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, let''s enable mouse support as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure that previous text on the terminal screen does not interfere with
    this program, let''s clear the screen, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create an iterator over incoming events and listen to mouse events.
    Display the location of the mouse cursor on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code shown, we are listening to both keyboard events and mouse events.
    In keyboard events, we are specifically looking for the *Q* key, which exits the
    program. We are also listening to mouse events – press, release, and hold. In
    this case, we position the cursor at the specified coordinates and also print
    out the coordinates to the terminal screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click around the screen with the mouse, and you will see the cursor position
    coordinates displayed on the terminal screen. Press `q` to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we conclude the section on working with mouse events on the terminal.
    This also concludes the chapter on terminal I/O management using Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of terminal management by writing a mini
    text viewer. We learned how to use the Termion library to get the terminal size,
    set the foreground and background colors, and set styles. After this, we learned
    how to work with cursors on the terminal, including clearing the screen, positioning
    the cursor at a particular set of coordinates, and keeping track of the current
    cursor position.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to listen to user inputs and track the keyboard arrow keys for
    scrolling operations, including left, right, up, and down. We wrote code to display
    document contents dynamically as the user scrolls through it, keeping the constraints
    of the terminal size in mind. As an exercise, you can refine the text viewer,
    and also add functionality to convert the text viewer into a full-fledged editor.
  prefs: []
  type: TYPE_NORMAL
- en: Learning these features is important to write applications such as terminal-based
    games, editing and viewing applications and terminal graphical interfaces, and
    to provide terminal-based dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the basics of process management using Rust,
    including starting and stopping processes and handling errors and signals.
  prefs: []
  type: TYPE_NORMAL
