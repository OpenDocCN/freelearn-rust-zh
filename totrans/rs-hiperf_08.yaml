- en: Must-Have Macro Crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most useful features of Rust is its crate ecosystem. In languages
    such as C/C++, it''s sometimes troublesome to find the proper library to use,
    and then it can be difficult to actually use it. This is almost straightforward
    in Rust, and in this  chapter, we will see some of the most interesting crates,
    which give us great metaprogramming primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serde**: Data serialization and deserialization support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nom**: Zero-copy byte-level parser creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy static**: Lazily initialized static variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Derive builder**: Derive the common builder pattern for your structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failure**: Easy error handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log and env_logger**: Logging for your software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLAP**: Creating command-line interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maud**: Compile-time templates with huge performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diesel**: MySQL/MariaDB, PostgreSQL, and SQLite database management, and
    ORM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rocket**: Nightly only high-performance web framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with external data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we do not have complete control of our software stack. Usually, if
    you want to create a project, you will need to contact external data sources,
    which can lead to many issues, since achieving compatibility between your code
    and external APIs or sources can be difficult. Moreover, it can lead to performance
    loss, which we should avoid as much as possible. Let's check some efficient and
    easy-to-use solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Data serialization and deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to data serialization and deserialization in Rust, there is no
    doubt we are talking about serde ([https://crates.io/crates/serde](https://crates.io/crates/serde)).
    Serde, from *serialization and deserialization*, gives us a unique tool to be
    able to transform our data structures to JSON, TOML, XML, or any other serializable
    format. Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a simple structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add `serde` and `serde_derive` as dependencies to our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `main.rs` file, we just need to import the crates using `extern
    crate` and derive the `Serialize` trait for our structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need a *frontend* for our serializable structure. This is because
    `serde` by itself only gives our structure the ability to be serialized, but not
    the language into which it will get serialized. Let''s use JSON as an example,
    since it''s a very well-known object notation language. We first add the dependency
    to the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we import it in our `main.rs` file and check the data serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute `cargo run`, we will see that the output of this code is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a73ee9dc-390d-42d1-9736-d48313fb7755.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a perfectly formatted and prettified JSON structure. OK, so how can
    we convert that string back into our data structure? We need to derive `Deserialize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71155785-3f5e-49bc-97e7-b49549eacd88.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we can go back and forward, from JSON to a memory structure,
    really easily! But, of course this only works for direct structure `<->` object
    serialization/deserialization. It won't work if any of them have different fields
    or names for fields. Or does it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, not directly of course, but we can ask `serde` to modify some parameters
    of our structure when serializing or deserializing it. For example, since in Rust
    we should use snake case for our structure fields, and *pascal* case for enumeration
    and structure names, we might think it's not possible to deserialize structures
    with pascal case fields or enumerations with snake case variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the `serde` crate provides some attributes to personalize this
    behaviour. For example, let''s suppose we want to represent the following structure
    in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to first create a Rust structure that will hold this information, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we derive the appropriate traits. To rename the fields, we need to
    use the `#[serde]` attribute with the `rename_all` directive at the structure
    level, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, you will see that the output is exactly as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccb30b4f-49aa-46cc-832b-db6e1d11355c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can choose between `"lowercase"`, `"PascalCase"`, `"camelCase"`, `"snake_case"`,
    `"SCREAMING_SNAKE_CASE"`, and `"kebab-case"`. You can also rename one particular
    field, which is especially useful if the original structure has a reserved keyword
    (such as `type`). In this case, you can use `#[serde(rename = "type")]` in the
    field and use the name you want in your Rust structure.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing complex structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you might want to serialize or deserialize complex data structures.
    Most of the time, you will have a crate that does this for you (such as the *chrono*
    crate for dates and times). But in some cases this is not enough. Suppose you
    have a data structure that has a field that can take a value of either 1 or 2,
    and that each of them means something different. In Rust, you would use an enumeration
    for it, but we may not always have control of external APIs, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s say we have some code, almost ready to compile, which represents
    this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we will need to define that `NaiveDateTime` structure. We will
    need to add the following to our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add the imports at the top of the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left is to implement `Serialize` and `Deserialize` for `DateType`.
    But what if this enumeration is not part of our crate and we cannot modify it?
    We can, in this case, specify a way of making it work by using a function in our
    crate, adding the function name as a serde `deserialize_with` attribute in the
    `MyDate` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will need to implement that function. It is required that the function
    has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it''s as simple as using the `Deserializer` and `Serializer` traits.
    You can get the full API documentation by running `cargo doc`, but we will find
    out how to do it for this particular case. Let''s start with the `Serialize` implementation,
    since it''s simpler than the `Deserialize` implementation. You will just need
    to call the `serialize_u8()` (or any other integer) method with the appropriate
    value, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just serialize an integer depending on the variant of the
    date type. To select which integer to serialize, we just match the enumeration.
    The `Deserializer` trait uses the visitor pattern, though, so we also need to implement
    a small structure that implements the `Visitor` trait. This is not very difficult,
    but can be a bit complex the first time we do it. Let''s check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I implemented the `visit_u64()` function for `Visitor`. This
    is because `serde_json` seems to use that function when serializing and deserializing
    integers. You can implement the rest if you want `Visitor` to be compatible with
    other serialization and deserialization frontends (such as XML, TOML, and others).
    You can see that the structure and the `Visitor` trait implementations are defined
    inside the function, so we do not pollute the namespace outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to test it with a new `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It should show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e541b3dd-ef75-4e98-98ad-eb5e59060045.png)'
  prefs: []
  type: TYPE_IMG
- en: You can of course implement the `Serialize` and `Deserialize` traits for full
    structures and enumerations, if the `serde` attributes are not enough for your
    needs. Their implementation is close to the ones seen in these functions, but
    you will need to check the API for more complex data serialization and deserialization.
    You can find a great guide at [https://serde.rs/](https://serde.rs/) explaining
    the specific options for this crate.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing byte streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might want to parse byte streams or byte slices to get valuable
    data. An example could be parsing a TCP byte stream to get HTTP data. Thanks to
    `Rust` and the `Nom` crate, we have an extremely efficient parser generator, which
    will not add extra overhead by copying data within your crate.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Nom` crate, you create functions that will read the input data byte
    by byte and return the parsed data. The aim in this section is not to master the
    `Nom` crate, but to understand its power and point you to the appropriate documentation.
    So, let's see the adapted example from Zbigniew Siciarz's 24 days of Rust ([https://siciarz.net/24-days-rust-nom-part-1/](https://siciarz.net/24-days-rust-nom-part-1/)),
    where he showed a short example of how to parse the first line of the HTTP protocol.
    You can read more complex tutorials on his blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define what the first line of the protocol looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `first_line` variable is a byte array (denoted by the `b`
    before the string). It just has the method as the first word, in this case `GET`,
    but it could be `POST`, `PUT`, `DELETE`, or any of the rest methods. We will stick
    to these four for simplicity. Then, we can read the URL the client is trying to
    get, and finally, the HTTP protocol version which will be `1.1` in this case.
    The line ends with a carriage return and a new line.
  prefs: []
  type: TYPE_NORMAL
- en: '`Nom` uses a macro called `named!()`, where you define a parser function. The
    name of the macro comes from the fact that you are giving a name to the function
    and then its implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to start checking the first HTTP line, we will need to parse the
    `request` method. To do that, we have to tell the parser that the first line can
    be any of the possible `request` methods. We can do this by using the `alt!()`
    macro with multiple `tag!()` macros, one per protocol. Let''s add `Nom` to our
    `Cargo.toml` file and start coding the method parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here? This seems like just a bunch of numbers, one after the
    other. Well, as we mentioned earlier, `Nom` works byte by byte, and does not care
    (unless we tell it) about the string representation of things. In this case, it
    has correctly found a `GET`, bytes 71, 69, and 84 in ASCII, and the rest is still
    not parsed. It returns a tuple with the unparsed data first and the parsed data
    second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tell `Nom` that we want to read the actual `GET` string by mapping the
    result to the `str::from_utf8` function. Let''s change the parser accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, apart from adding the `map_res!()` macro, I had to specify
    that the `parse_method` returns `&str` after parsing the input, since `Nom` assumes
    that your parsers will return byte slices by default. This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even create an enumeration and map it directly, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine multiple parsers and create variables in one parser that will
    be reused in the next one. This is useful, for example, when some parts of the
    data contain information for parsing the rest. This is the case with the HTTP
    content length header, which lets you know how much you should parse later. Let''s
    use it to parse the complete request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what's happening here. We created the structure to store the line
    data and then we created a parser by using the `ws!()` macro (which will automatically
    consume spacers between tokens). The `do_parse!()` macro allows us to create a
    sequence of many parsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `parse_method()` parser we just created for the request method
    and then we just store the other two strings as variables. We then just need to
    create the structure with the variables. Note that I also changed the call in
    the `main()` function. Let''s see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are no more bytes to parse, and the `Request` structure
    has been properly generated. You can generate parsers for extremely complex structures
    and you could, for example, parse the URL to get the segments, or the version
    number to get the major and minor version numbers, and so on. The only limitations
    are your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we did some copying when calling `to_owned()` for the two strings,
    but we needed it if we wanted to generate an owned field. You can use explicit
    lifetimes to avoid a lot of copying if you require faster processing.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about useful small crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While data handling probably creates some of the most bug-prone code, we should
    also learn about some small libraries that make our lives much easier. This is
    the case for the following crates, where some macros can prevent us from writing
    lots of error-prone or potentially non-optimal code, making our final executables
    faster and easier to develop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating lazily evaluated statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in previous chapters how, in nightly Rust, it is possible to call
    some trivial constant functions that are evaluated at compile time. Nevertheless,
    this might not be enough for our needs, and we might not even want to use nightly
    Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use a great crate, and the macro with the same name—`lazy_static`.
    This macro allows us to create static variables that will run the code to be generated
    on their first use. Let''s check it, for example, for a `HashMap`. Creating a
    `HashMap` or adding values to it cannot be done during compile time. As we saw
    in previous chapters, this can be improved by using the `phf` crate. But what
    if we want to add values to the `HashMap` based on some environment variable?
    This is where `lazy_static!{}` comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we create a `HashMap` at runtime the first time we use it, so
    it will not be defined until we call `MyMap.iter()`, and if we were to use it
    again, it wouldn't need to be recreated. Not only that, it depends on the `GEN_MAP`
    environment variable. So, if we run the program with `cargo run`, it won't show
    anything; but if we run it with `GEN_MAP=true cargo run`, it will show the two
    key-values.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, this will create a new type that implements `Deref` to `HashMap`.
    This will call to the `initialize()` function the first time it tries to get to
    the underlying type, generating the actual `HashMap`. This is very efficient if
    you only want one initialization of something you will be using more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding boilerplate code for the builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one is pretty straightforward. If you know about the builder pattern,
    you will know that it''s a very useful pattern to create structures. We can avoid
    writing the whole new builder structure by using the `derive_builder` crate. So,
    let''s add it to our `Cargo.toml` file and check how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just added `#[derive(Build)]` to the structure and added
    some extra parameters, such as allowing the use of default values for non-initialized
    fields and allowing generic parameters (`Into<T>`) for setters. Note that it requires
    the structure to implement the `Default` trait.
  prefs: []
  type: TYPE_NORMAL
- en: This enables us to initialize the structure with mere `&str` variables, for
    example, and then the builder will do the rest. As you can see, it will create
    a `{your_structure}Builder` structure that you will use to build the main one.
    Make sure you check all the little options that let you adapt the builder to your
    needs on the crate page at [crates.io](https://crates.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Managing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have used multiple libraries in Rust, you will probably have noticed
    that managing errors is not straightforward. We have the awesome `?` operator,
    but if a function has multiple errors, it's not so easy to use. We can create
    our own error types, have variants for each of them, and have an `Into` trait
    implementation for each of the errors we might encounter. This is a tedious approach,
    but until recently it was the only way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we have a crate that can help us with that. This crate provides us
    with a `Fail` trait, which already guarantees thread safety and already provides
    default conversion implementations from all standard library error types. It also
    gives us some macros that help us with some boilerplate code. Let''s see an example
    of how this would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we get the first characters of the `Cargo.toml` file.
    As you can see, we are returning `std::io::Errors` converted into `failure::Errors`
    with the `?` operator. Then, we can iterate over the errors if they exist. If
    something goes wrong, this will be the output of the code. We have added some
    context for each of the potential errors, so that the output gets properly printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0894515a-9967-4fbd-9b0b-14375bcd09ec.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also create your error traits and derive the `Fail` trait, thanks to
    the `failure_derive` crate. I recommend checking the complete documentation and
    using it for all your new projects. It brings many advantages over doing it yourself
    and even using the predecessor `error-chain` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Logging efficiently in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is one of the most important parts of many applications and it's good
    to know that Rust has us covered in this regard. The default go-to crate should
    be the `log` crate, which provides us with useful macros for logging. Then, you
    can use the backend you want for the loggers, such as the `env_logger` crate or
    the `log4rs` crate.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` crate gives us some macros, mainly `trace!()`, `debug!()`, `info!()`,
     `warn!()`, and `error!()`, in ascending order of relevance, which we can use
    to log events that happen in our application. It provides some more boilerplate,
    but that is basically it, you will now have to configure how those macros behave.
    For that, you have the actual implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want an easy to use, common logger, you should go for `env_logger`.
    It has a small footprint and can be configured with environment variables. If
    you need extra configuration for things such as multiple outputs, both console
    and files, and extra configuration, you should go for an alternative such as `log4rs`.
    Let''s check a small `env_logger` example to see the power of this logging mechanism.
    You will need to add `log` and `env_logger` to your `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run that using `cargo run`, we will see this output, since errors are
    shown by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f1c3606-53c0-41c1-8fa4-1be168be5de5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But we can run it with a different `RUST_LOG` environment variable, such as
    `RUST_LOG=trace cargo run`. This should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb3286b2-07a9-4f1f-a77e-3a898745014f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, colors denote the importance of the message. Note that running
    `cargo` with the `RUST_LOG` variable will show a lot of extra output, since cargo
    itself uses `env_logger`. I recommend you read the full documentation of this
    crate, since it enables you to change formatters, loggers, and much more besides
    the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating command-line interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a command-line interface is not always easy. In C/C++, you need to
    start parsing arguments and then decide which flags are set and whether they comply
    with all the conditions. This is a non-issue in Rust thanks to **Command-Line
    Argument Parser** (**CLAP**). The CLAP crate, enables us to create very complex
    command-line interfaces with just a bit of code.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that; it will create the help menus for us and it will also be maintainable
    since it will be easy to add or remove parameters and flags. It will ensure that
    the input we receive is valid and it will even create command-line completion
    scripts for the most-used shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate the complete CLI with macros, but I personally prefer to use
    simple Rust code. It has a few `helper` macros, though, to gather some information.
    Remember to add `clap` to your `Cargo.toml` file and let''s see how we would create
    a simple command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we defined a CLI with the crate name, description, version,
    and authors, which will be taken from the `Cargo.toml` file at compile time so
    that we do not need to update it for every change. It then defines a required
    `user` argument, which takes a value and uses it to print the value. The `expect()`
    here is safe because `clap` makes sure that the argument is provided, since we
    asked it to with `required(true)`. If we simply execute `cargo run`, we will see
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ac17912-ba27-4605-9f41-23b2b5caa043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It tells us that it needs the `username` parameter and points us to the `--help`
    flag, automatically added by `clap` along with the `-V` flag, to show the crate
    version information. If we run it with `cargo run -- --help`, we will see the
    `help` output. Note that any argument to cargo after a double dash will be passed
    as an argument to the executable. Let''s check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/821db47c-3714-4b34-949b-8475481ee21b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, it shows really well-formatted help text. If we want to actually
    see the result of passing a proper username, we can execute it with `cargo run
    -- -u {username}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae79cfa0-f144-4de3-bd1f-1aa8db50ad1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Rust for web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might think that Rust is only meant to be used for complex system development,
    or that it should be used where security is the number one concern. Thinking of
    using it for web development might sound to you like huge overkill. We already
    have proven web-oriented languages that have worked until now, such as PHP or
    JavaScript, right?
  prefs: []
  type: TYPE_NORMAL
- en: This is far from true. Many projects use the web as their platform and for them,
    it's sometimes more important to be able to receive a lot of traffic without investing
    in expensive servers rather than using legacy technologies, especially in new
    products. This is where Rust comes in handy. Thanks to its speed and some really
    well thought out web-oriented frameworks, Rust performs even better than the legacy
    web programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is even trying to replace some of the JavaScript on the client side of
    applications, since Rust can compile to WebAssembly, making it extremely powerful
    for heavy client-side web workloads. We will not learn how to compile for web
    clients in this book, but we will learn about some crates that allow you work
    on efficient web development with Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Creating extremely efficient templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that Rust is a really efficient language and as you have seen in
    the last two chapters, metaprogramming allows for the creation of even more efficient
    code. Rust has great templating language support, such as Handlebars and Tera.
    Rust's Handlebars implementation is much faster than the JavaScript implementation,
    while Tera is a template engine created for Rust based on Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, you define a template file and then you use Rust to parse it.
    Even though this will be reasonable for most web development, in some cases, it
    might be slower than pure Rust alternatives. This is where the Maud crate comes
    in. We will see how it works and how it achieves orders of magnitude faster performance
    than its counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Maud, you will need nightly Rust, since it uses procedural macros. As
    we saw in previous chapters, if you are using `rustup` you can simply run `rustup
    override set nightly`. Then, you will need to add Maud to your `Cargo.toml` file
    in the `[dependencies]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Maud brings an `html!{}` procedural macro that enables you to write HTML in
    Rust. You will therefore need to import the necessary crate and macro in your
    `main.rs` or `lib.rs` file, as you will see in the following code. Remember to
    also add the procedural macro feature at the beginning of the crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now be able to use the `html!{}` macro in your `main()` function.
    This macro will return a `Markup` object, which you can then convert to a `String`
    or return to Rocket or Iron for your website implementation (you will need to
    use the relevant Maud features in that case). Let''s see what a short template
    implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems like a complex template, but it contains just the basic information
    a new website should have. We first add a doctype, making sure it will not escape
    the content (that is what the `PreEscaped` is for) and then we start the HTML
    document with two parts: the `head` and the `body`. In the `head`, we add the
    required title and the `charset` `meta` element to tell the browser that we will
    be using UTF-8.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `body` contains the three usual sections, even though this can of
    course be modified. One `header`, one `main` section, and one `footer`. I added
    some example information in each of the sections and showed you how to add a dynamic
    variable in the `main` section inside a paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting syntax here is that you can create elements with attributes,
    such as the `meta` element, even without content, by finishing it early with a
    semicolon. You can use any HTML tag and add variables. The generated code will
    be escaped, except if you ask for non-escaped data, and it will be minified so
    that it occupies the least space when being transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the parentheses, you can call any function or variable that returns a
    type that implements the `Display` trait and you can even add any Rust code if
    you add braces around it, with the last statement returning a `Display` element.
    This works on attributes too.
  prefs: []
  type: TYPE_NORMAL
- en: This gets processed at compile time, so that at runtime it will only need to
    perform the minimum possible amount of work, making it extremely efficient. And
    not only that; the template will be typesafe thanks to Rust's compile-time guarantees,
    so you won't forget to close a tag or an attribute. There is a complete guide
    to the templating engine that can be found at [https://maud.lambda.xyz/](https://maud.lambda.xyz/).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to use SQL/relational databases in Rust, there is no other crate
    to think about than Diesel. If you need access to NoSQL databases such as Redis
    or MongoDB, you will also find proper crates, but since the most used databases
    are relational databases, we will check Diesel here.
  prefs: []
  type: TYPE_NORMAL
- en: Diesel makes working with MySQL/MariaDB, PostgreSQL, and SQLite very easy by
    providing a great ORM and typesafe query builder. It prevents all potential SQL
    injections at compile time, but is still extremely fast. In fact, it's usually
    faster than using prepared statements, due to the way it manages connections to
    databases. Without entering into technical details, we will check how this stable
    framework works.
  prefs: []
  type: TYPE_NORMAL
- en: The development of Diesel has been impressive and it's already working in stable
    Rust. It even has a stable 1.x version, so let's check how we can map a simple
    table. Diesel comes with a command-line interface program, which makes it much
    easier to use. To install it, run `cargo install diesel_cli`. Note that, by default, this will
    try to install it for PostgreSQL, MariaDB/MySQL, and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this short tutorial, you need to have SQLite 3 development files installed,
    but if you want to avoid installing all MariaDB/MySQL or PostgreSQL files, you
    should run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, since we will be using SQLite for our short test, add a file named `.env`
    to the current directory, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run `diesel setup` and `diesel migration generate initial_schema`.
    This will create the `test.sqlite` SQLite database and a `migrations` folder,
    with the first empty initial schema migration. Let''s add this to the initial
    schema `up.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In its counterpart `down.sql` file, we will need to drop the created table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute `diesel migration run` and check that everything went
    smoothly. We can execute `diesel migration redo` to check that the rollback and
    recreation worked properly. We can now start using the ORM. We will need to add
    diesel, `diesel_infer_schema`, and `dotenv` to our `Cargo.toml`. The `dotenv`
    crate will read the `.env` file to generate the environment variables. If you
    want to avoid using all the MariaDB/MySQL or PostgreSQL features, you will need
    to configure `diesel` for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a structure that we will be able to use to retrieve data
    from the database. We will also need some boilerplate code to make everything
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `establish_connection()` function will call `dotenv()` so that the
    variables in the `.env` file get to the environment, and then it uses that `DATABASE_URL`
    variable to establish the connection with the SQLite database and returns the
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: The schema module will contain the schema of the database. The `infer_schema!()`
    macro will get the `DATABASE_URL` variable and connect to the database at compile
    time to generate the schema. Make sure you run all the migrations before compiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now develop a small `main()` function with the basics to list all of
    the users from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will just load all of the users from the database into a list. Notice the
    `use` statement at the beginning of the function. This retrieves the required
    information from the schema for the `users` table so that we can then call `users.load()`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the guides at [diesel.rs](http://diesel.rs/guides/), you can
    also generate `Insertable` objects, which might not have some of the fields with
    default values, and you can perform complex queries by filtering the results in
    the same way you would write a `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a complete web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple web frameworks for Rust. Some of them work in stable Rust,
    such as Iron and Nickel Frameworks, and some don't, such as Rocket. We will talk
    about the latter since, even if it forces you to use the latest nightly branch,
    it's so much more powerful than the rest that it really makes no sense to use
    any of the others if you have the option to use Rust nightly.
  prefs: []
  type: TYPE_NORMAL
- en: Using Diesel with Rocket, apart from the funny wordplay joke, works seamlessly.
    You will probably be using the two of them together, but in this section we will
    learn how to create a small Rocket server without any further complexity. There
    are some boilerplate code implementations that add database, cache, OAuth, templating,
    response compression, JavaScript minification, and SASS minification to the website,
    such as my Rust web template ([https://github.com/Razican/Rust-web-template](https://github.com/Razican/Rust-web-template))
    in GitHub if you need to start developing a real-life Rust web application.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket trades that nightly instability, which will break your code more often
    than not, for simplicity and performance. Developing a Rocket application is really
    easy and the performance of the results is astonishing. It's even faster than
    using some other, seemingly simpler frameworks, and of course, it's much faster
    than most of the frameworks in other languages. So, how does it feel to develop
    a Rocket application?
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding the latest `rocket` and `rocket_codegen` crates to our `Cargo.toml`
    file and adding a nightly override to our current directory by running `rustup
    override set nightly`. The `rocket` crate contains all the code to run the server,
    while the `rocket_codegen` crate is actually a compiler plugin that modifies the
    language to adapt it for web development. We can now write the default `Hello,
    world!` Rocket example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see how we ask Rust to let us use plugins to then import
    the `rocket_codegen` plugin. This will enable us to use attributes such as `#[get]`
    or `#[post]` with request information that will generate boilerplate code when
    compiled, leaving our code fairly simple for our development. Also, note that
    this code has been checked with Rocket 0.3 and it might fail in a future version,
    since the library is not stable yet.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can see that the `index()` function will respond to any `GET`
    request with a base URL. This can be modified to accept only certain URLs, or
    to get the path of something from the URL. You can also have overlapping routes
    with different priorities, so that if one is not taken for a request guard, the
    next will be tried.
  prefs: []
  type: TYPE_NORMAL
- en: And, talking about request guards, you can create objects that can be generated
    when processing a request that will only let the request process a given function
    if they are properly built. This means that you can, for example, create a `User`
    object that will get generated by checking the cookies in the request and comparing
    them in a Redis database, only allowing the execution of the function for logged-in
    users. This easily prevents many logic flaws.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function ignites the Rocket and mounts the index route at `/`.
    This means that you can have multiple routes with the same path mounted at different
    route paths and they do not need to know about the whole path in the URL. In the
    end, it will launch the Rocket server and if you run it with `cargo run`, it will
    show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c271111-1912-48b4-812f-e78e5fb32511.png)'
  prefs: []
  type: TYPE_IMG
- en: If you go to the URL, you will see the `Hello, World!` message. Rocket is highly
    configurable. It has a `rocket_contrib` crate which offers templates and further
    features, and you can create responders to add GZip compression to responses.
    You can also create your own error responders when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure the behavior of Rocket by using the `Rocket.toml` file
    and environment variables. As you can see in this last output, it is running in
    development mode, which adds some debugging information. You can configure different
    behaviors for staging and production modes and make them perform faster. Also,
    make sure that you compile the code in `--release` mode in production.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to develop a web application in Rocket, make sure you check [https://rocket.rs/](https://rocket.rs/)
    for further information. Future releases also look promising. Rocket will implement
    native CSRF and XSS prevention, which, in theory, should prevent all XSS and CSRF
    attacks at compile time. It will also make further customizations to the engine
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about many crates that will make your life writing
    Rust code much easier. You learned how they can not only allow you to write less
    code, but that they can help you write faster code. We also saw how easy it is
    to use a crate from [https://crates.io/](https://crates.io/), which gives us superpowers
    when using code written by others.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to develop your own macros, similar
    to the ones seen here, and you will also learn how to create your own procedural
    macros and plugins.
  prefs: []
  type: TYPE_NORMAL
