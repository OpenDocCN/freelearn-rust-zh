<html><head></head><body>
		<div><h1 id="_idParaDest-41"><em class="italic">Chapter 2</em>: <a id="_idTextAnchor041"/>A Tour of the Rust Programming Language</h1>
			<p>In the previous chapter, we looked at the Rust tooling ecosystem for build and dependency management, testing, and documentation. These are critical and highly developer-friendly tools that give us a strong foundation for starting to work on Rust projects. In this chapter, we will build a working example that will serve to act as a refresher, and also strengthen key Rust programming concepts.</p>
			<p>The goal of this chapter is to get more proficient in core Rust concepts. This is essential before diving into the specifics of systems programming in Rust. We will achieve this by designing and developing a <strong class="bold">command-line interface </strong>(<strong class="bold">CLI</strong>) in Rust.</p>
			<p>The application we will be building is an <strong class="bold">arithmetic expression evaluator</strong>. Since this is a mouthful, let's see an example.</p>
			<p>Let's assume the user enters the following arithmetic expression on the command line:</p>
			<pre>1+2*3.2+(4/2-3/2)-2.11+2^4</pre>
			<p>The tool will print out the result <strong class="bold">21.79</strong>.</p>
			<p>For the user, it appears to be a calculator, but there is a lot involved to implement this. This example project will introduce you to the core computer science concepts used in parsers and compiler design. It is a non-trivial project that allows us to test the depths of core Rust programming, but is not so overly complex that it will intimidate you.</p>
			<p>Before you continue reading, I would recommend that you clone the code repository, navigate to the <code>chapter2</code> folder, and execute the <code>cargo run</code> command. At the command-line prompt, enter a few arithmetic expressions and see the results returned by the tool. You can exit the tool with <em class="italic">Ctrl</em> + <em class="italic">C</em>. This would give you a better appreciation for what you are going to build in this chapter.</p>
			<p>The following are the key learning steps for this chapter, which correspond to the various stages of building our project:</p>
			<ul>
				<li>Analyzing the problem domain</li>
				<li>Modeling system behavior</li>
				<li>Building the tokenizer</li>
				<li>Building the parser</li>
				<li>Building the evaluator</li>
				<li>Dealing with errors </li>
				<li>Building a command-line application</li>
			</ul>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Technical requirements</h1>
			<p>You should have Rustup and Cargo installed in your local development environment.</p>
			<p>The GitHub repository for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter02</a>.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Analyzing the problem domain</h1>
			<p>In <a id="_idIndexMarker118"/>this section, we will define the scope of the project and the technical challenges that we need to address.</p>
			<p>Understanding and analyzing the problem domain is the first step in building any system. It is important to unambiguously articulate the problem we are trying to solve, and the boundaries of the system. These can be captured in the form of system requirements.</p>
			<p>Let's look at the requirements for the CLI tool we are going to build. </p>
			<p>The tool should accept an arithmetic expression as input, evaluate it, and provide the numerical output as a floating-point number. For example, the expression <em class="italic">1+2*3.2+(4/2-3/2)-2.11+2^4</em> should evaluate to <em class="italic">21.79</em>.</p>
			<p>The arithmetic operations in scope are <strong class="bold">addition</strong> (<strong class="bold">+</strong>), <strong class="bold">subtraction</strong> (<strong class="bold">-</strong>), <strong class="bold">multiplication</strong> (<strong class="bold">*</strong>), <strong class="bold">division</strong> (<strong class="bold">/</strong>), <strong class="bold">power</strong> (<strong class="bold">^</strong>), the <strong class="bold">negative prefix</strong> (<strong class="bold">-</strong>), and expressions enclosed in <strong class="bold">parentheses</strong> <strong class="bold">()</strong>.</p>
			<p>Mathematical functions such as trigonometric and logarithmic functions, absolute, square roots, and so on are <em class="italic">not</em> in scope.</p>
			<p>With such an expression, the challenges that need to be resolved are as follows:</p>
			<ul>
				<li>The user should be able to input an arithmetic expression as <em class="italic">free text</em> on the command line. Numbers, arithmetic operators, and parentheses (if any) should be segregated and processed with different sets of rules.</li>
				<li>The rules of <em class="italic">operator precedence</em> must be taken into account (for example, multiplication takes precedence over addition).</li>
				<li>Expressions enclosed within <em class="italic">parentheses ()</em> must be given <em class="italic">higher precedence</em>.</li>
				<li>The user <a id="_idIndexMarker119"/>may not give spaces between the number and operator, but still the program must be capable of <em class="italic">parsing inputs with or without spaces</em> between the characters.</li>
				<li>If numbers contain a <em class="italic">decimal point</em>, continue reading the rest of the number until an operator or parenthesis is encountered.</li>
				<li><em class="italic">Invalid inputs</em> should be dealt with and the program should abort with a suitable error message. Here are some examples of invalid input:<p><strong class="bold">Invalid input 1</strong>: Since we don't deal with variables in this program, if a character is entered, the program should exit with a suitable error message (for example, <em class="italic">2 *</em> <em class="italic">a</em> is invalid input).</p><p><strong class="bold">Invalid input 2</strong>: If only a single parenthesis is encountered (without a matching closing parenthesis), the program should exit with an error message.</p><p><strong class="bold">Invalid input 3</strong>: If the arithmetic operator is not recognized, the program should exit with an error message.</p></li>
			</ul>
			<p>There are clearly other types of edge cases that can cause errors. But we will focus only on these. The reader is encouraged to implement other error conditions as a further exercise.</p>
			<p>Now that we know the scope of what we are going to build, let's design the system.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Modeling the system behavior</h1>
			<p>In the last section, we<a id="_idIndexMarker120"/> confirmed the system requirements. Let's now design the logic for processing the arithmetic expression. The components of the system are shown in <em class="italic">Figure 2.1</em>:</p>
			<div><div><img src="img/Figure_2.1_B16405.jpg" alt="Figure 2.1 – Design of an arithmetic expression evaluator"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Design of an arithmetic expression evaluator</p>
			<p>The components shown in the preceding figure work together as follows:</p>
			<ol>
				<li>The user enters an arithmetic expression at the command-line input and presses the <em class="italic">Enter</em> key.</li>
				<li>The user input is scanned in its entirety and stored in a local variable.</li>
				<li>The arithmetic expression (from the user) is scanned. The numbers are stored as tokens of the <code>Numeric</code> type. Each arithmetic operator is stored as a token of that appropriate type. For example, the <code>+</code> symbol will be represented as a token of type <code>Add</code>, and the number <code>1</code> will be stored as a token of type <code>Num</code> with a value of <code>1</code>. This is done by the <code>Lexer</code> (or <code>Tokenizer</code>) module.</li>
				<li>An <code>1+2*3</code>, the product of <code>2</code> and <code>3</code> must be evaluated before the addition operator. Also, any sub-expressions enclosed within parentheses must be evaluated on a higher priority. The final AST will reflect all such processing rules. This is done by the <code>Parser</code> module.</li>
				<li>From the constructed AST, the last step is to evaluate each node of the AST in the right sequence, and aggregate them to arrive at the final value of the complete expression. This is done by the <code>Evaluator</code> module.</li>
				<li>The final computed value of the expression is displayed on the command line as a program output to the user. Alternatively, any error in processing is displayed as an error message.</li>
			</ol>
			<p>This is the broad sequence of steps for processing. We will now take a look at translating this design into Rust code.</p>
			<p class="callout-heading">Differences between lexers, parsers, and ASTs</p>
			<p class="callout"><em class="italic">Lexers</em> and <em class="italic">parsers</em> are <a id="_idIndexMarker123"/>concepts used in computer science to build <em class="italic">compilers</em> and <em class="italic">interpreters</em>. A <em class="italic">lexer</em> (also called a <em class="italic">tokenizer</em>) splits text (source code) into words and assigns a <em class="italic">lexical</em> meaning<a id="_idIndexMarker124"/> to it such as <em class="italic">keyword</em>, <em class="italic">expression</em>, <em class="italic">operator</em>, <em class="italic">function call</em>, and so on. <em class="italic">Lexers</em> generate tokens (hence the name <em class="italic">tokenizer</em>).</p>
			<p class="callout">A <em class="italic">parser</em> takes the<a id="_idIndexMarker125"/> output of the <em class="italic">lexer</em> and<a id="_idIndexMarker126"/> arranges the tokens into a tree structure (a tree is a type of data structure). Such a tree structure is also called an <em class="italic">AST</em>. With the <em class="italic">AST</em>, the <a id="_idIndexMarker127"/>compiler can generate machine code and the interpreter can evaluate an instruction. <em class="italic">Figure 2.7</em> of this chapter shows an illustration of an <em class="italic">AST</em>.</p>
			<p class="callout">The lexing and parsing phases are two different steps in the compilation process, but in some cases they are combined. Note that concepts such as <em class="italic">lexers</em>, <em class="italic">parsers</em>, and <em class="italic">ASTs</em> have a broader range of applications beyond just compilers or interpreters, such as to render HTML web pages or SVG images.</p>
			<p>We've so far seen the <a id="_idIndexMarker128"/>high-level design of the system. Let's now understand how the code will be organized. A visual representation of the project structure is shown here:</p>
			<div><div><img src="img/Figure_2.2_B16405.jpg" alt="Figure 2.2 – Code structure for the project"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Code structure for the project</p>
			<p>Let's check each one of those paths:</p>
			<ul>
				<li><code>src/parsemath</code>: The module containing the core processing logic</li>
				<li><code>src/parsemath/ast.rs</code>: Contains the AST code</li>
				<li><code>src/parsemath/parser.rs</code>: Contains code for the parser</li>
				<li><code>src/parsemath/tokenizer.rs</code>: Contains code for the tokenizer</li>
				<li><code>src/parsemath/token.rs</code>: Contains the data structures for token and operator precedence</li>
				<li><code>src/main.rs</code>: The main command-line application</li>
			</ul>
			<p>Let's now set up the project as follows:</p>
			<ol>
				<li value="1">Create a new project with <code>cargo new chapter2 &amp;&amp; cd chapter2</code>.</li>
				<li>Create a folder <a id="_idIndexMarker129"/>named <code>parsemath</code> under the <code>src</code> folder.</li>
				<li>Create the following files within the <code>src/parsemath</code> folder: <code>ast.rs</code>, <code>token.rs</code>, <code>tokenizer.rs</code>, <code>parser.rs</code>, and <code>mod.rs</code>.</li>
				<li>Add the following to <code>src/parsemath/mod.rs</code>:<pre>pub mod ast;
pub mod parser;
pub mod token;
pub mod tokenizer;</pre></li>
			</ol>
			<p>Note that the Rust module system was used to structure this project. All functionality related to parsing is in the <code>parsemath</code> folder. The <code>mod.rs</code> file in this folder indicates this is a Rust module. The <code>mod.rs</code> file exports the functions in the various files contained in this folder and makes it available to the <code>main()</code> function. In the <code>main()</code> function, we then register the <code>parsemath</code> module so that the module tree is constructed by the Rust compiler. Overall, the Rust module structure helps us organize code in different files in a way that is flexible and maintainable.</p>
			<p class="callout-heading">Important note on code snippets in this chapter</p>
			<p class="callout">This chapter goes through the design of the command-line tool in detail, supplemented by illustrations with diagrams. The code snippets for all the key methods are also provided with explanations. However, in some places, a few elements to complete the code, such as module imports, test scripts, and definitions of <code>impl</code> blocks, are not included here but can be directly found in the GitHub repo. Please keep this in mind if you choose to code along. Otherwise, you can follow the explanations in this chapter in conjunction with the completed code in the code repository. </p>
			<p class="callout">Also a heads-up that you will see usage of the <code>?</code> operator in the upcoming sections on building the tokenizer, parser, and evaluator. Just bear in mind that <em class="italic">?</em> is a shortcut for error handling, in order to propagate errors automatically from a given function to its calling function. This will be explained in the later <em class="italic">Dealing with errors</em> section.</p>
			<p>We're set now. Let's get started.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Building the tokenizer</h1>
			<p>The <strong class="bold">tokenizer</strong> is the <a id="_idIndexMarker130"/>module in our system design that reads one or more characters from an arithmetic expression and translates it into a <em class="italic">token</em>. In other words, <em class="italic">input</em> is a set of characters and <em class="italic">output</em> is a set of tokens. In case you are wondering, examples of tokens are <em class="italic">Add</em>, <em class="italic">Subtract</em>, and <em class="italic">Num(2.0)</em>.</p>
			<p>We have to first create a data structure for two things:</p>
			<ul>
				<li>To store the <em class="italic">input</em> arithmetic expression from the user</li>
				<li>To represent the <em class="italic">output</em> tokens</li>
			</ul>
			<p>In the following section, we will delve into how to determine the right data structures for the <code>tokenizer</code> module.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Tokenizer data structure</h2>
			<p>To store the input arithmetic expression, we can<a id="_idIndexMarker131"/> choose among the following data types:</p>
			<ul>
				<li>String slice</li>
				<li>String</li>
			</ul>
			<p>We will choose the <code>&amp;str</code> type, as we do not need to own the value or dynamically increase the size of the expression. This is because the user will provide the arithmetic expression once, and then the expression won't change for the duration of processing.</p>
			<p>Here is one possible representation of the <code>Tokenizer</code> data structure:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>pub struct Tokenizer {
expr: &amp;str 
}</pre>
			<p>If we took this approach, we may run into a problem. To understand the problem, let's understand how tokenization takes place.</p>
			<p>For the expression <em class="italic">1+21*3.2</em>, the individual characters scanned will appear as eight separate values, <em class="italic">1, +, 2, 1, *, 3, ., 2</em>.</p>
			<p>From this, we will have to extract the following five tokens:</p>
			<p><em class="italic">Num(1.0)</em>, <em class="italic">Add</em>, <em class="italic">Num(21.0)</em>, <em class="italic">Multiply</em>, <em class="italic">Num(3.2)</em></p>
			<p>In order to accomplish this, we not only need to read a character to convert it into a token, but also take a look at the character beyond the next one. For example, given the input expression <em class="italic">1+21*3.2</em>, to tokenize number <em class="italic">21</em> into <em class="italic">Num(21)</em>, we need to read character <em class="italic">2</em>, followed by <em class="italic">1</em>, followed by <em class="italic">*</em> in order to conclude that the second operand for the first addition operation has a value of <em class="italic">21</em>.</p>
			<p>In order to accomplish this, we have to convert the string slice into an iterator, which not only allows us to iterate through the string slice to read each character, but also allows us to <em class="italic">peek</em> ahead<a id="_idIndexMarker132"/> and see value of the character following that.</p>
			<p>Let's see how to implement an iterator over the string slice. Rust incidentally has a built-in type for this. It's a part of the <code>str</code> module in the standard library and the struct is called <code>Chars</code>.</p>
			<p>So, the definition of our <code>Tokenizer</code> struct could look as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>pub struct Tokenizer {
expr: std::str::Chars
}</pre>
			<p>Note that we have changed the type of the <code>expr</code> field from a string slice (<code>&amp;str</code>) to an iterator type (<code>Chars</code>). <code>Chars</code> is an iterator over the characters of a string slice. This will allow us to do iterations on <code>expr</code> such as <code>expr.next()</code>, which will give the value of the next character in the expression. But we also need to take a peek at the character following the next character in the input expression, for reasons we mentioned earlier.</p>
			<p>For this, the Rust standard library has a struct called <code>Peekable</code> , which has a <code>peek()</code> method. The usage of <code>peek()</code> can be illustrated with an example. Let's take the arithmetic expression <code>1+2</code>:</p>
			<pre>let expression = '1+2';</pre>
			<p>Because we will store this expression in the <code>expr</code> field of <code>Tokenizer</code>, which is of the <code>peekable iterator</code> type, we<a id="_idIndexMarker133"/> can perform <code>next()</code> and <code>peek()</code> methods on it in sequence, as shown here:</p>
			<ol>
				<li value="1"><code>expression.next()</code> returns <code>1</code>. The iterator now points to character <code>1</code>.</li>
				<li>Then, <code>expression.peek()</code> returns <code>+</code> but does not consume it, and the iterator still points to character <code>1</code>.</li>
				<li>Then, <code>expression.next()</code> returns <code>+</code>, and the iterator now points to character <code>+</code>.</li>
				<li>Then, <code>expression.next()</code> returns <code>2</code>, and the iterator now points to character <code>2</code>.</li>
			</ol>
			<p>To enable such an iteration operation, we will define our <code>Tokenizer</code> struct as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>use std::iter::Peekable;
use std::str::Chars;
pub struct Tokenizer {
expr: Peekable&lt;Chars&gt; 
}</pre>
			<p>We are still not done with the <code>Tokenizer</code> struct. The earlier definition would throw a compiler error asking to add a lifetime parameter. <em class="italic">Why is this?,</em> you may ask.</p>
			<p>Structs in Rust can hold references. But Rust needs explicit lifetimes to be specified when working with structs that contain references. That is the reason we get the compiler error on the <code>Tokenizer</code> struct. To fix this, let's add lifetime annotation:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>pub struct Tokenizer&lt;'a&gt; {
expr: Peekable&lt;Chars&lt;'a&gt;&gt; 
}</pre>
			<p> You can see that the <code>Tokenizer</code> struct has been given a lifetime annotation of <code>'a</code>. We have done this by declaring the name of the generic lifetime parameter <code>'a</code> inside angle brackets after the name of the struct. This tells the Rust compiler that any reference to the Tokenizer<a id="_idIndexMarker134"/> struct cannot outlive the reference to the characters it contains.</p>
			<p class="callout-heading">Lifetimes in Rust</p>
			<p class="callout">In system languages such as C/C++, operations on references can lead to unpredictable results or failures, if the value associated with the reference has been freed in memory.</p>
			<p class="callout">In Rust, every reference<a id="_idIndexMarker135"/> has a lifetime, which is the scope for which the lifetime is valid. The Rust compiler (specifically, the borrow checker) verifies that the lifetime of the reference is not longer than the lifetime of the underlying value pointed to by the reference.</p>
			<p class="callout">How does the compiler know the lifetime of references? Most of the time, the compiler tries to infer the lifetime of<a id="_idIndexMarker136"/> references (called <strong class="bold">elision</strong>). But where this is not possible, the compiler expects the programmer to annotate the lifetime of the reference explicitly. Common situations where the compiler expects explicit lifetime annotations are in <em class="italic">function signatures</em> where two or more arguments are references, and in <em class="italic">structs</em> where one or more members of the struct are reference types.</p>
			<p class="callout">More details can be found in the Rust documentation, at <a href="https://doc.rust-lang.org/1.9.0/book/lifetimes.html">https://doc.rust-lang.org/1.9.0/book/lifetimes.html</a>.</p>
			<p>As explained, the <code>Tokenizer</code> struct, we pass the string reference to it, which contains the arithmetic expression. As per the conventional rules of variable scoping (common to most programming languages), the <code>expr</code> variable needs to be valid for the duration that the <code>Tokenizer</code> object is in existence. If the value corresponding to the <code>expr</code> reference is deallocated while the <code>Tokenizer</code> object is in existence, then it constitutes a dangling (invalid) reference scenario. To prevent this, we tell the compiler through the lifetime annotation of <code>&lt;'a&gt;</code> that the <code>Tokenizer</code> object cannot outlive the reference it holds in the <code>expr</code> field.</p>
			<p>The following<a id="_idIndexMarker138"/> screenshot shows the <code>Tokenizer</code> data struct:</p>
			<div><div><img src="img/Figure_2.3_B16405.jpg" alt="Figure 2.3 – The Tokenizer struct"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – The Tokenizer struct</p>
			<p>We've seen so far how to define the <code>Tokenizer</code> struct, which contains the reference to input arithmetic expression. We will next take a look at how to represent the tokens generated as output from the <code>Tokenizer</code>.</p>
			<p>To be able to represent the list of tokens that can be generated, we have to first consider the data type of these tokens. Since the tokens can be of the <code>Num</code> type or one of the operator types, we have to pick a data structure that can accommodate multiple data types. The data type options are tuples, HashMaps, structs, and enums. If we add the constraint that the type of data in a token can be one of many predefined <em class="italic">variants</em> (allowed values), that leaves us with just one option—<em class="italic">enums</em>. We will define the tokens using the <code>enum</code> data structure.</p>
			<p>The representation of tokens in the <code>enum</code> data structure is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.4_B16405.jpg" alt="Figure 2.4 – Token enum"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Token enum</p>
			<p>Here is the <a id="_idIndexMarker139"/>explanation for what value gets stored in the <code>Token enum</code>:</p>
			<ul>
				<li>If the <code>+</code> character is encountered, the <code>Add</code> token is generated.</li>
				<li>If the <code>-</code> character is encountered, the <code>Subtract</code> token is generated.</li>
				<li>If the <code>*</code> character is encountered, the <code>Multiply</code> token is generated.</li>
				<li>If the <code>/</code> character is encountered, the <code>Divide</code> token is generated.</li>
				<li>If the <code>^</code> character is encountered, the <code>Caret</code> token is generated.</li>
				<li>If the <code>(</code> character is encountered, the <code>LeftParen</code> token is generated.</li>
				<li>If the <code>)</code> character is encountered, the <code>RightParen</code> token is generated.</li>
				<li>If any number <code>x</code> is encountered, the <code>Num(x)</code> token is generated.</li>
				<li>If <code>EOF</code> is encountered (at the end of scanning the entire expression), the <code>EOF</code> token is generated.</li>
			</ul>
			<p>Now that we have defined the data structures to capture the <em class="italic">input </em>(arithmetic expression) and <em class="italic">outputs</em> (tokens) for the <code>Tokenizer</code> module, we now can write the code to do the actual processing.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>Tokenizer data processing</h2>
			<p>The following <a id="_idIndexMarker140"/>screenshot shows the <code>Tokenizer</code> with its data elements and methods:</p>
			<div><div><img src="img/Figure_2.5_B16405.jpg" alt="Figure 2.5 – The Tokenizer with its methods"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The Tokenizer with its methods</p>
			<p>The <code>Tokenizer</code> has two public methods:</p>
			<ul>
				<li><code>new()</code>: Creates a new tokenizer using the arithmetic expression provided by the user</li>
				<li><code>next()</code>: Reads the characters in the expression and return the next token</li>
			</ul>
			<p>The following screenshot shows the full design of the <code>Tokenizer</code> module:</p>
			<div><div><img src="img/Figure_2.6_B16405.jpg" alt="Figure 2.6 – Tokenizer module design"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Tokenizer module design</p>
			<p>The <a id="_idIndexMarker141"/>code for the <code>new()</code> method is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>impl<strong class="bold">&lt;'a&gt;</strong> Tokenizer&lt;'a&gt; {
    pub fn new(new_expr: &amp;'a str) -&gt; Self {
        Tokenizer {
            expr: new_expr.chars().peekable(),
        }
    }
}</pre>
			<p>You'll notice that we are declaring a lifetime for <code>Tokenizer</code> in the <code>impl</code> line. We are repeating <code>'a</code> twice. <code>Impl&lt;'a&gt;</code> declares the lifetime <code>'a</code>, and <code>Tokenizer&lt;'a&gt;</code> uses it.</p>
			<p class="callout-heading">Observations on lifetimes</p>
			<p class="callout"> You've seen that for <code>Tokenizer</code>, we declare its<a id="_idIndexMarker142"/> lifetime in three places:</p>
			<p class="callout">1) The declaration of the <code>Tokenizer</code> struct</p>
			<p class="callout">2) The declaration of the <code>impl</code> block for the <code>Tokenizer</code> struct</p>
			<p class="callout">3) The method signature within the <code>impl</code> block</p>
			<p class="callout">This may seem verbose, but Rust expects us to be specific about lifetimes because that's how we can avoid memory-safety issues such as <em class="italic">dangling pointers </em>or <em class="italic">use-after-free</em> errors.</p>
			<p>The <code>impl</code> keyword<a id="_idIndexMarker143"/> allows us to add functionality to the <code>Tokenizer</code> struct. The <code>new()</code> method accepts a string slice as a parameter that contains a reference to the arithmetic expression input by the user. It constructs a new <code>Tokenizer</code> struct initialized with the supplied arithmetic expression, and returns it from the function.</p>
			<p>Note that the arithmetic expression is not stored in the struct as a string slice, but as a  peekable iterator over the string slice.</p>
			<p>In this code, <code>new_expr</code> represents the string slice, <code>new_expr.chars()</code> represents an iterator over the string slice, and <code>new_expr.chars().peekable()</code> creates a peekable iterator over the string slice.</p>
			<p>The difference between a regular iterator and peekable iterator is that in the former, we can consume the next character in the string slice using the <code>next()</code> method, while in the latter we can also optionally peek into the next character in the slice <em class="italic">without consuming it</em>. You will see how this works as we write the code for the <code>next()</code> method of the <code>Tokenizer</code>.</p>
			<p>We will write the code for the <code>next()</code> method on the <code>Tokenizer</code> by implementing the <code>Iterator</code> trait on the <code>Tokenizer</code> struct. Traits enable us to add behaviors to structs (and enums). The <code>Iterator</code> trait in the standard library (<code>std::iter::Iterator</code>) has a method that is required to be implemented with the following signature:</p>
			<pre>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</pre>
			<p>The method signature <a id="_idIndexMarker144"/>specifies that this method can be called on an instance of the <code>Tokenizer</code> struct and it returns <code>Option&lt;Token&gt;</code>. This means that it either returns <code>Some(Token)</code> or <code>None</code>.</p>
			<p>Here is the code to implement the <code>Iterator</code> trait on the <code>Tokenizer</code> struct:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/tokenizer.rs</p>
			<pre>impl&lt;'a&gt; <strong class="bold">Iterator</strong> for Tokenizer&lt;'a&gt; {
    type Item = Token;
 
    fn <strong class="bold">next</strong>(&amp;mut self) -&gt; Option&lt;Token&gt; {
        let next_char = <strong class="bold">self.expr.next()</strong>;
 
        match next_char {
            Some('0'..='9') =&gt; {
                let mut number = next_char?.to_string();
 
                while let Some(next_char) = self.expr.peek() {
                    if next_char.is_numeric() || next_char == 
                        &amp;'.' {
                        number.push(self.expr.next()?);
                    } else if next_char == &amp;'(' {
                        return None;
                    } else {
                        break;
                    }
                }
 
                Some(Token::Num(number.parse::&lt;f64&gt;().                    unwrap()))
            },
            Some('+') =&gt; Some(Token::Add),
            Some('-') =&gt; Some(Token::Subtract),
            Some('*') =&gt; Some(Token::Multiply),
            Some('/') =&gt; Some(Token::Divide),
            Some('^') =&gt; Some(Token::Caret),
            Some('(') =&gt; Some(Token::LeftParen),
            Some(')') =&gt; Some(Token::RightParen),
            None =&gt; Some(Token::EOF),
            Some(_) =&gt; None,
        }
    }
}</pre>
			<p>Notice how there are two<a id="_idIndexMarker145"/> iterators at play here:</p>
			<ul>
				<li>The <code>next()</code> method on <code>expr</code> (which is a field within the <code>Tokenizer</code> struct) returns the next character (we achieved this by assigning a type of <code>Peekable&lt;Chars&gt;</code> to the <code>expr</code> field ).</li>
				<li>The <code>next()</code> method on the <code>Tokenizer</code> struct returns a token (we achieved this by implementing the <code>Iterator</code> trait on the <code>Tokenizer</code> struct).</li>
			</ul>
			<p>Let's understand stepwise <a id="_idIndexMarker146"/>what happens when the <code>next()</code> method is called on <code>Tokenizer</code>:</p>
			<ul>
				<li>The calling program instantiates the <code>Tokenizer</code> struct first by calling the <code>new()</code> method, and then invokes the <code>next()</code> method on it. The <code>next()</code> method on the <code>Tokenizer</code> struct reads the next character in the stored arithmetic expression by calling <code>next()</code> on the <code>expr</code> field, which returns the next character in the expression.</li>
				<li>The returned character is then evaluated using a <code>match</code> statement. Pattern matching is used to determine what token to return, depending on what character is read from the string slice reference in the <code>expr</code> field.</li>
				<li>If the character returned from string slice is an arithmetic operator (<em class="italic">+</em>, <em class="italic">-</em>, <em class="italic">*</em>, <em class="italic">/</em>, <em class="italic">^</em>) or if it is a parenthesis, the appropriate <code>Token</code> from the <code>Token</code> <code>enum</code> is returned. There is a one-to-one correspondence between the <em class="italic">character</em> and <code>Token</code> here.</li>
				<li>If the character returned is a number, then there is some additional processing needed. The reason is, a number may have multiple digits. Also, a number may be decimal, in which case it could be of the form <em class="italic">xxx.xxx,</em> where the amounts of digits before and after the decimal are completely unpredictable. So, for numbers, we should use the <code>peekable</code> iterator on the arithmetic expression to consume the next character and <em class="italic">peek</em> into the character after that to determine whether to continue reading the number.</li>
			</ul>
			<p>The complete code for the <code>Tokenizer</code> can be found in the <code>tokenizer.rs</code> file in the code folder on GitHub.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Building the parser</h1>
			<p>The <strong class="bold">parser</strong> is the <a id="_idIndexMarker147"/>module in our project that constructs the AST, which is a tree of nodes with each node representing a token (a number or an arithmetic operator). The AST is a recursive tree structure of token nodes, that is, the root node is a token, which contains child nodes that are also tokens.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Parser data structure</h2>
			<p>The <code>parser</code> is a higher-level <a id="_idIndexMarker148"/>entity compared to the <code>Tokenizer</code>. While the <code>Tokenizer</code> converts user input into fine-grained tokens (for example, various arithmetic operators), the parser uses the <code>Tokenizer</code> outputs to construct an overall AST, which is a hierarchy of nodes. The structure of the <code>AST</code> constructed from the parser is illustrated in the following diagram:</p>
			<div><div><img src="img/Figure_2.7_B16405.jpg" alt="Figure 2.7 – Our AST"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Our AST</p>
			<p>In the preceding figure, each of the following are nodes:</p>
			<ul>
				<li><em class="italic">Number(2.0)</em></li>
				<li><em class="italic">Number(3.0)</em></li>
				<li><em class="italic">Multiply(Number(2.0),Number(3.0))</em></li>
				<li><em class="italic">Number(6.0)</em></li>
				<li><em class="italic">Add(Multiply(Number(2.0),Number(3.0)),Number(6.0))</em></li>
			</ul>
			<p>Each of these <a id="_idIndexMarker149"/>nodes is stored in a <code>Box</code> variable as part of the <code>Node</code> enum.</p>
			<p>The overall design of the <code>Parser</code> struct is as follows:</p>
			<div><div><img src="img/Figure_2.8_B16405.jpg" alt="Figure 2.8 – Design of the Parser struct"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Design of the Parser struct</p>
			<p>As shown in the <a id="_idIndexMarker150"/>preceding figure, <code>Parser</code> will have two data elements: an instance of <code>Tokenizer</code> (that we built in the previous section), and the current token to indicate up to which point we have evaluated the arithmetic expression.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Parser methods</h2>
			<p>The <code>Parser</code> struct will <a id="_idIndexMarker151"/>have two public methods:</p>
			<ul>
				<li><code>new()</code>: To create a new instance of the parser. This <code>new()</code> method will create a tokenizer instance passing in the arithmetic expression, and then stores the first token (returned from <code>Tokenizer</code>) in its <code>current_token</code> field.</li>
				<li><code>parse()</code>: To generate the <code>AST</code> (the node tree) from the tokens, which is the main output of the parser.</li>
			</ul>
			<p>Here is the code for the <code>new()</code> method. The code is self-explanatory, it creates a new instance of <code>Tokenizer</code>, initializing it with the arithmetic expression, and then tries to retrieve the first token from the expression. If successful, the token is stored in the <code>current_token</code> field. If not, <code>ParseError</code> is returned:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>// Create a new instance of Parserpub fn <strong class="bold">new</strong>(expr: &amp;'a str) -&gt; Result&lt;Self, ParseError&gt; {
    let mut lexer = Tokenizer::new(expr);
    let cur_token = match lexer.next() {
        Some(token) =&gt; token,
        None =&gt; return Err(ParseError::InvalidOperator
            ("Invalid character".into())),
    };
    Ok(Parser {
        tokenizer: lexer,
        current_token: cur_token,
    })
}</pre>
			<p>The following is the <a id="_idIndexMarker152"/>code for the public <code>parse()</code> method. It invokes a private <code>generate_ast()</code> method that does the processing recursively and returns an AST (a tree of nodes). If successful, it returns the Node tree; if not, it propagates the error received:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>// Take an arithmetic expression as input and return an AST
pub fn parse(&amp;mut self) -&gt; Result&lt;Node, ParseError&gt; {
    let ast = self.generate_ast(OperPrec::DefaultZero);
    match ast {
        Ok(ast) =&gt; Ok(ast),
        Err(e) =&gt; Err(e),
    }
}</pre>
			<p>The following image lists all <a id="_idIndexMarker153"/>the private and public methods in the <code>Parser</code> struct:</p>
			<div><div><img src="img/Figure_2.9_B16405.jpg" alt="Figure 2.9 – Parser methods overview"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Parser methods overview</p>
			<p>Let's now look at <a id="_idIndexMarker154"/>the code for the <code>get_next_token()</code> method. This method retrieves the next token from the arithmetic expression using the <code>Tokenizer</code> struct and updates the <code>current_token</code> field of the <code>Parser</code> struct. If unsuccessful, it returns <code>ParseError</code>:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>fn <strong class="bold">get_next_token</strong>(&amp;mut self) -&gt; Result&lt;(), ParseError&gt; {
    let next_token = match self.tokenizer.next() {
        Some(token) =&gt; token,
        None =&gt; return Err(ParseError::InvalidOperator
            ("Invalid character".into())),
    };
    self.current_token = next_token;
    Ok(())
}</pre>
			<p>Note the empty tuple <code>()</code> returned in <code>Result&lt;(),</code> <code>ParseError&gt;</code>. This means if nothing goes wrong, no concrete value is returned.</p>
			<p>Here's the code<a id="_idIndexMarker155"/> for the <code>check_paren()</code> method. This is a helper method used to check whether there are matching pairs of parentheses in the expression. Otherwise, an error is returned:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>fn <strong class="bold">check_paren</strong>(&amp;mut self, expected: Token) -&gt; Result&lt;(), ParseError&gt; {
    if expected == self.current_token {
        self.get_next_token()?;
        Ok(())
    } else {
        Err(ParseError::InvalidOperator(format!(
            "Expected {:?}, got {:?}",
            expected, self.current_token
        )))
    }
}</pre>
			<p>Let's now look at the remaining three private methods that do the bulk of the parser processing.</p>
			<p>The <code>parse_number()</code> method takes the current token, and checks for three things:</p>
			<ul>
				<li>Whether the token is a number of the form <em class="italic">Num(i)</em>.</li>
				<li>Whether the token has a sign, in case it is a negative number. For example, the expression <em class="italic">-2.2 + 3.4</em> is parsed into AST as <em class="italic">Add(Negative(Number(2.2)), Number(3.4))</em>.</li>
				<li>Pairs of parenthesis: If an expression is found within pairs of parenthesis, it treats it as a multiplication operation. For example, <em class="italic">1*(2+3)</em> is parsed as <em class="italic">Multiply(Number(1.0), Add(Number(2.0), Number(3.0)))</em>.</li>
			</ul>
			<p>In case of errors in <a id="_idIndexMarker156"/>any of the preceding operations, <code>ParseError</code> is returned.</p>
			<p>Here is the code for the <code>parse_number()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>// Construct AST node for numbers, taking into account 
// negative prefixes while handling parenthesis
fn <strong class="bold">parse_number</strong>(&amp;mut self) -&gt; Result&lt;Node, ParseError&gt; {
    let token = self.current_token.clone();
    match token {
        Token::Subtract =&gt; {
            self.get_next_token()?;
            let expr = self.generate_ast(OperPrec::Negative)?;
            Ok(Node::Negative(Box::new(expr)))
        }
        Token::Num(i) =&gt; {
            self.get_next_token()?;
            Ok(Node::Number(i))
        }
        Token::LeftParen =&gt; {
            self.get_next_token()?;
            let expr = self.generate_ast
                (OperPrec::DefaultZero)?;
            self.check_paren(Token::RightParen)?;
            if self.current_token == Token::LeftParen {
                let right = self.generate_ast
                    (OperPrec::MulDiv)?;
                return Ok(Node::Multiply(Box::new(expr), 
                    Box::new(right)));
            }
 
            Ok(expr)
        }
        _ =&gt; Err(ParseError::UnableToParse("Unable to 
            parse".to_string())),
    }
}</pre>
			<p>The <code>generate_ast()</code> method <a id="_idIndexMarker157"/>is the main workhorse of the module and is invoked recursively. It does its processing in the following sequence:</p>
			<ol>
				<li value="1">It processes numeric tokens, negative number tokens, and expressions in parentheses using the <code>parse_number()</code> method.</li>
				<li>It parses each token from the arithmetic expression in a sequence within a loop to check if the precedence of the next two operators encountered, and constructs <code>AST</code> by calling the <code>convert_token_to_node()</code> method in such a way that the expression containing an operator with higher precedence is executed before an expression containing an operator with lower precedence. For example, the expression <em class="italic">1+2*3</em> is evaluated as <em class="italic">Add(Number(1.0), Multiply(Number(2.0), Number(3.0)))</em>, whereas the expression <em class="italic">1*2+3</em> is evaluated as <em class="italic">Add(Multiply(Number(1.0), Number(2.0)), Number(3.0))</em>.</li>
			</ol>
			<p>Let's now<a id="_idIndexMarker158"/> look at the code for the <code>generate_ast()</code> method:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>fn <strong class="bold">generate_ast</strong>(&amp;mut self, oper_prec: OperPrec) -&gt; Result&lt;Node, ParseError&gt; {
    let mut left_expr = self.parse_number()?;
 
    while oper_prec &lt; self.current_token.get_oper_prec() {
        if self.current_token == Token::EOF {
            break;
        }
        let right_expr = self.convert_token_to_node
            (left_expr.clone())?;
        left_expr = right_expr;
    }
    Ok(left_expr)
}</pre>
			<p>We have seen the various methods associated with the parser. Let's now look at another key aspect when dealing with arithmetic operators—<em class="italic">operator precedence</em>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Operator precedence</h2>
			<p><code>enum</code> for operator precedence is as follows:</p>
			<div><div><img src="img/Figure_2.10_B16405.jpg" alt="Figure 2.10 – Operator precedence enum"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Operator precedence enum</p>
			<p>The operator precedence <code>enum</code> has the<a id="_idIndexMarker160"/> following values:</p>
			<ul>
				<li><code>DefaultZero</code>: The default precedence (lowest priority)</li>
				<li><code>AddSub</code>: The precedence applied if the arithmetic operation is addition or subtraction</li>
				<li><code>MulDiv</code>: The precedence applied if the arithmetic operation is multiplication or division</li>
				<li><code>Power</code>: The precedence applied if the caret (<code>^</code>) operator is encountered</li>
				<li><code>Negative</code>: The precedence applied for the negative (<code>-</code>) prefix before a number</li>
			</ul>
			<p>The precedence order <a id="_idIndexMarker161"/>increases from top to bottom, that is, <code>DefaultZero</code> &lt; <code>AddSub</code> &lt;<code> MulDiv</code> &lt; <code>Power</code> &lt; <code>Negative</code>.</p>
			<p>Define the operator precedence <code>enum</code> as shown:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/token.rs</p>
			<pre>#[derive(Debug, PartialEq, PartialOrd)]
/// Defines all the OperPrec levels, from lowest to highest.
pub enum OperPrec {
    DefaultZero,
    AddSub,
    MulDiv,
    Power,
    Negative,
}</pre>
			<p>The <code>get_oper_prec()</code> method is used to get the operator precedence given an operator. The following is the code that shows this method in action. Define this method in the <code>impl</code> block of the <code>Token</code> struct:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/token.rs</p>
			<pre>impl Token {
    pub fn <strong class="bold">get_oper_prec</strong>(&amp;self) -&gt; OperPrec {
        use self::OperPrec::*;
        use self::Token::*;
        match *self {
            Add | Subtract =&gt; AddSub,
            Multiply | Divide =&gt; MulDiv,
            Caret =&gt; Power,
 
            _ =&gt; DefaultZero,
        }
    }
}</pre>
			<p>Now, let's look at the<a id="_idIndexMarker162"/> code for <code>convert_token_to_node()</code>. This method basically constructs the operator-type <code>AST</code> nodes by checking whether the token is <code>Add</code>, <code>Subtract</code>, <code>Multiply</code>, <code>Divide</code>, or <code>Caret</code>. In the case of an error, <code>ParseError</code> is returned:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>fn <strong class="bold">convert_token_to_node</strong>(&amp;mut self, left_expr: Node) -&gt; Result&lt;Node, ParseError&gt; {
    match self.current_token {
        Token::Add =&gt; {
            self.get_next_token()?;
            //Get right-side expression
            let right_expr = self.generate_ast
                (OperPrec::AddSub)?;
            Ok(Node::Add(Box::new(left_expr), 
                Box::new(right_expr)))
        }
        Token::Subtract =&gt; {
            self.get_next_token()?;
            //Get right-side expression
            let right_expr = self.generate_ast
                (OperPrec::AddSub)?;
            Ok(Node::Subtract(Box::new(left_expr), 
                Box::new(right_expr)))
        }
        Token::Multiply =&gt; {
            self.get_next_token()?;
            //Get right-side expression
            let right_expr = self.generate_ast
                (OperPrec::MulDiv)?;
            Ok(Node::Multiply(Box::new(left_expr), 
                Box::new(right_expr)))
        }
        Token::Divide =&gt; {
            self.get_next_token()?;
            //Get right-side expression
            let right_expr = self.generate_ast
                (OperPrec::MulDiv)?;
            Ok(Node::Divide(Box::new(left_expr), 
                Box::new(right_expr)))
        }
        Token::Caret =&gt; {
            self.get_next_token()?;
            //Get right-side expression
            let right_expr = self.generate_ast
                (OperPrec::Power)?;
            Ok(Node::Caret(Box::new(left_expr), 
                Box::new(right_expr)))
        }
        _ =&gt; Err(ParseError::InvalidOperator(format!(
            "Please enter valid operator {:?}",
            self.current_token
        ))),
    }
}</pre>
			<p>We will look in detail at error handling later in the chapter in the <em class="italic">Dealing with errors</em> section. The complete code for <code>Parser</code> can be found in the <code>parser.rs</code> file in the GitHub folder for the chapter.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Building the evaluator</h1>
			<p>Once the <code>AST</code> (node tree) is constructed<a id="_idIndexMarker163"/> in the parser, evaluating the numeric value from <code>AST</code> is a straightforward operation. The evaluator function parses each node in the <code>AST</code> tree recursively and arrives at the final value.</p>
			<p>For example, if the <code>AST</code> node is <em class="italic">Add(Number(1.0),Number(2.0))</em>, it evaluates to <em class="italic">3.0</em>. </p>
			<p>If the <code>AST</code> node is <em class="italic">Add(Number(1.0),Multiply(Number(2.0),Number(3.0))</em>:</p>
			<ul>
				<li>It evaluates value of <em class="italic">Number(1.0)</em> to <em class="italic">1.0</em>.</li>
				<li>Then it evaluates <em class="italic">Multiply(Number(2.0), Number(3.0))</em> to <em class="italic">6.0</em>. </li>
				<li>It then adds <em class="italic">1.0</em> and <em class="italic">6.0</em> to get the final value of <em class="italic">7.0</em>.</li>
			</ul>
			<p>Let's now look at the code for the <code>eval()</code> function:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/ast.rs</p>
			<pre>pub fn <strong class="bold">eval</strong>(expr: Node) -&gt; Result&lt;f64, Box&lt;dyn error::Error&gt;&gt; {
    use self::Node::*;
    match expr {
        Number(i) =&gt; Ok(i),
        Add(expr1, expr2) =&gt; Ok(eval(*expr1)? + 
            eval(*expr2)?),
        Subtract(expr1, expr2) =&gt; Ok(eval(*expr1)? – 
            eval(*expr2)?),
        Multiply(expr1, expr2) =&gt; Ok(eval(*expr1)? * 
            eval(*expr2)?),
        Divide(expr1, expr2) =&gt; Ok(eval(*expr1)? / 
            eval(*expr2)?),
        Negative(expr1) =&gt; Ok(-(eval(*expr1)?)),
        Caret(expr1, expr2) =&gt; Ok(eval(*expr1)?
            .powf(eval(*expr2)?)),
    }
}</pre>
			<p class="callout-heading">Trait objects</p>
			<p class="callout">In the <code>eval()</code> method, you will notice that the<a id="_idIndexMarker164"/> method returns <code>Box&lt;dyn error::Error&gt;</code> in case of errors. This is an example of a <strong class="bold">trait object</strong>. We will explain this now.</p>
			<p class="callout">In the Rust standard library, <code>error:Error</code> is a trait. Here, we are telling the compiler that the <code>eval()</code> method should return something that implements the <code>Error</code> trait. We don't know at compile time what the exact type being returned is; we just know that whatever is returned will implement the <code>Error</code> trait. The underlying error type is only known at runtime and is not statically determined. Here, <code>dyn error::Error</code> is a trait object. The use of the <code>dyn</code> keyword indicates it is a trait object.</p>
			<p class="callout">When we use trait objects, the compiler does not know at compile time which method to call on which types. This is only known at runtime, hence it is called <em class="italic">dynamic-dispatch</em> (when the compiler knows what method to call at compile time, it is called <em class="italic">static dispatch</em>).</p>
			<p class="callout">Note also that we are boxing the error with <code>Box&lt;dyn error::Error&gt;</code>. This is because we don't know the size of the error type at runtime, so boxing is a way to get around this problem (<code>Box</code> is a reference type that has a known size at compile time). The Rust standard library helps in boxing our errors by having <code>Box</code> implement conversion from any type that implements the <code>Error</code> trait into the trait object <code>Box&lt;Error&gt;</code>. </p>
			<p class="callout">More details can be found in the Rust documentation, at <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">https://doc.rust-lang.org/book/ch17-02-trait-objects.html</a>.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Dealing with errors</h1>
			<p>Error handling deals with<a id="_idIndexMarker165"/> the question: <em class="italic">how do we communicate program errors to users?</em></p>
			<p>In our project, errors can occur due to two main reasons—there could be a programming error, or an error could occur due to invalid inputs. Let's first discuss the Rust approach to error handling.</p>
			<p>In Rust, errors are first-class citizens in that an error is a data type in itself, just like an <code>integer</code>, <code>string</code>, or <code>vector</code>. Because <code>error</code> is a data type, type checking can happen at compile time. The Rust standard library has a <code>std::error::Error</code> trait implemented by all errors in the Rust standard library. Rust does not use exception handling, but a unique approach where a computation can return a <code>Result</code> type:</p>
			<pre>enum Result&lt;T, E&gt; {   Ok(T),   Err(E),}</pre>
			<p><code>Result&lt;T, E&gt;</code> is an <code>enum</code> with two variants, where <code>Ok(T)</code> represents <em class="italic">success</em> and <code>Err(E)</code> represents the <em class="italic">error</em> returned. Pattern matching is used to handle the two types of return values from a function.</p>
			<p>To gain greater control over error handling and to provide more user-friendly errors for application users, it is recommended to use a custom error type that implements the <code>std::error::Error</code> trait. All types of errors from different modules in the program can then be converted to this custom error type for uniform error handling. This is a very effective way to deal with errors in Rust.</p>
			<p>A lightweight approach to error handling could be to use <code>Option&lt;T&gt;</code> as the return value from a function, where <code>T</code> is any generic type:</p>
			<pre>pub enum Option&lt;T&gt; {    None,    Some(T),}</pre>
			<p>The <code>Option</code> type is an <code>enum</code> with two variants, <code>Some(T)</code> and <code>None</code>. If processing is successful, a <code>Some(T)</code> value is returned, otherwise, <code>None</code> is returned from the function.</p>
			<p>We will use <a id="_idIndexMarker166"/>both the <code>Result</code> and <code>Option</code> types for error handling in our project.</p>
			<p>The error handling approach chosen for our project is as follows:</p>
			<div><div><img src="img/Figure_2.11_B16405.jpg" alt="Figure 2.11 – Error handling approach"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Error handling approach</p>
			<p>For our project, the approach for <a id="_idIndexMarker167"/>the four modules that contain the core processing is as follows:</p>
			<ul>
				<li><code>new()</code> and <code>next()</code>. The <code>new()</code> method is fairly simple and just creates a new instance of the <code>Tokenizer</code> struct and initializes it. No error will be returned in this method. However, the <code>next()</code> method returns a <code>Token</code>, and if there is any invalid character in the arithmetic expression, we need to deal with this situation and communicate it to the calling code. We will use a lightweight error handling approach here, with <code>Option&lt;Token&gt;</code> as the return value from the <code>next()</code> method. If a valid <code>Token</code> can be constructed from the arithmetic expression, <code>Some(Token)</code> will be returned. In the case of invalid input, <code>None</code> will be returned. The calling function can then interpret <code>None</code> as an error condition and take care of the necessary handling.</li>
				<li><code>eval()</code> function that computes a numeric value given a node tree. We will return a vanilla <code>std::error::Error</code> in case of an error during processing, but it will be a <code>Boxed</code> value because otherwise, the Rust compiler will not know the size of the error value at compile time. The return type from this method is <code>Result&lt;f64, Box&lt;dyn error::Error&gt;&gt;</code>. If processing is successful, a numeric value (<code>f64</code>) is returned, else a <code>Boxed</code> error is returned. We could have defined a custom error type for this module to avoid the complex <code>Boxed</code> error signature, but this approach has been chosen to showcase the various ways to do error handling in Rust.</li>
				<li><code>get_oper_prec()</code>, which returns the operator precedence given an arithmetic operator as input. Since we do not see any possibility of errors in this simple method, there will be no error type defined in the return value of the method.</li>
				<li><code>Parser</code> module<a id="_idIndexMarker171"/> contains the bulk of the processing logic. Here, a custom error type, <code>ParseError,</code> will be defined, which has the following structure:</li>
			</ul>
			<div><div><img src="img/Figure_2.12_B16405.jpg" alt="Figure 2.12 – Custom error type"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Custom error type</p>
			<p>Our custom <a id="_idIndexMarker172"/>error type has two variants, <code>UnableToParse(String)</code> and <code>InvalidOperator(String)</code>.</p>
			<p>The first variant will be a generic error for any type of error during processing, and the second variant will be used specifically if there is an invalid arithmetic operator provided by the user; for example, <em class="italic">2=3</em>.</p>
			<p>Let's define a custom error type for the parser:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>#[derive(Debug)]
pub enum ParseError {
    UnableToParse(String),
    InvalidOperator(String),
}</pre>
			<p>To print errors, we also need to implement the <code>Display</code> trait:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>impl fmt::Display for ParseError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match &amp;self {
            self::ParseError::UnableToParse(e) =&gt; write!(f, 
                "Error in evaluating {}", e),
            self::ParseError::InvalidOperator(e) =&gt; write!(f, 
                "Error in evaluating {}", e),
        }
    }
}</pre>
			<p>Since <code>ParseError</code> will be<a id="_idIndexMarker173"/> the main error type returned from processing, and because the <code>AST</code> module returns a <code>Boxed</code> error, we can write code to automatically convert any <code>Boxed</code> error from the <code>AST</code> module into <code>ParseError</code> that gets returned by <code>Parser</code>. The code is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/parsemath/parser.rs</p>
			<pre>impl std::convert::From&lt;std::boxed::Box&lt;dyn std::error::Error&gt;&gt; for ParseError {
    fn from(_evalerr: std::boxed::Box&lt;dyn std::error::Error&gt;) 
        -&gt; Self {
        return ParseError::UnableToParse("Unable to 
            parse".into());
    }
}</pre>
			<p>This code allows us to write code such as the following: </p>
			<pre>let num_value = eval(ast)?</pre>
			<p>Note in particular the <code>?</code> operator. It is a shortcut for the following:</p>
			<ul>
				<li>If <code>eval()</code> processing is successful, store the returned value in the <code>num_value</code> field.</li>
				<li>If <a id="_idIndexMarker174"/>processing fails, convert the <code>Boxed</code> error returned by the <code>eval()</code> method into <code>ParseError</code> and propagate it further to the caller.</li>
			</ul>
			<p>This concludes the discussion on the arithmetic expression evaluator modules. In the next section, we will take a look at how to call this module from a <code>main()</code> function.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Putting it all together</h1>
			<p>We have seen in previous sections how to design and write code for the various processing modules of our project. We will now tie all of them together in a <code>main()</code> function that serves as the command-line application. This <code>main()</code> function will do the following:</p>
			<ol>
				<li value="1">Display prompts with instructions for the user to enter an arithmetic expression.</li>
				<li>Accept an arithmetic expression in the command-line input from the user.</li>
				<li>Instantiate <code>Parser</code> (returns a <code>Parser</code> object instance).</li>
				<li>Parse the expression (returns the AST representation of the expression).</li>
				<li>Evaluate the expression (computes the mathematical value of the expression).</li>
				<li>Display the result to the user in the command-line output.</li>
				<li>Invoke <code>Parser</code> and evaluate the mathematical expression.</li>
			</ol>
			<p>The code for the <code>main()</code> function is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/main.rs</p>
			<pre>fn main() {
    println!("Hello! Welcome to Arithmetic expression 
        evaluator.");
    println!("You can calculate value for expression such as 
        2*3+(4-5)+2^3/4. ");
    println!("Allowed numbers: positive, negative and 
        decimals.");
    println!("Supported operations: Add, Subtract, Multiply, 
        Divide, PowerOf(^). ");
    println!("Enter your arithmetic expression below:");
    loop {
        let mut input = String::new();
        match io::stdin().read_line(&amp;mut input) {
            Ok(_) =&gt; {
                match evaluate(input) {
                    Ok(val) =&gt; println!("The computed number 
                        is {}\n", val),
                    Err(_) =&gt; {
                        println!("Error in evaluating 
                            expression. Please enter valid 
                            expression\n");
                    }
                };
            }
 
            Err(error) =&gt; println!("error: {}", error),
        }
    }
}</pre>
			<p>The <code>main()</code> function displays a prompt to the user, reads a line from <code>stdin</code> (the command line), and invokes the <code>evaluate()</code> function. If the computation is successful, it displays the computed AST and the numerical value. If unsuccessful, it prints an error message.</p>
			<p>The code for the <code>evaluate()</code> function is as follows:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/main.rs</p>
			<pre>fn evaluate(expr: String) -&gt; Result&lt;f64, ParseError&gt; {
    let expr = expr.split_whitespace().collect::&lt;String&gt;();
    // remove whitespace chars
    let mut math_parser = Parser::new(&amp;expr)?;
    let ast = math_parser.parse()?;
    println!("The generated AST is {:?}", ast);
 
    Ok(ast::eval(ast)?)
}</pre>
			<p>The <code>evaluate()</code> function instantiates a new <code>Parser</code> with the provided arithmetic expression, parses it, and then invokes the <code>eval()</code> method on the <code>AST</code> module. Note the use of the <code>?</code> operator for automated propagation of any processing errors to the <code>main()</code> function, where they are handled with a <code>println!</code> statement.</p>
			<p>Run the following command to compile and run the program:</p>
			<pre>cargo run</pre>
			<p>You can try out various combinations of positive and negative numbers, decimals, arithmetic operators, and optional sub-expressions in parentheses. You can also check how an invalid input expression will produce an error message. </p>
			<p>You can expand this project to add support for mathematical functions such as square roots, trigonometric functions, logarithmic functions, and so on. You can also add edge cases.</p>
			<p>With this, we conclude the first full-length project in this book. I hope this project has given you an idea not just of how idiomatic Rust code is written, but also of how to think in Rust terms while designing a program.</p>
			<p>The complete code for the <code>main()</code> function can be found in the <code>main.rs</code> file in the GitHub folder for this chapter.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Summary</h1>
			<p>In this chapter, we built a command-line application from scratch in Rust, without using any third-party libraries, to compute the value of the arithmetic expressions. We covered many basic concepts in Rust, including data types, how to model and design an application domain with Rust data structures, how to split code across modules and integrate them, how to structure code within a module as functions, how to expose module functions to other modules, how to do pattern matching for elegant and safe code, how to add functionality to structs and enums, how to implement traits and annotate lifetimes, how to design and propagate custom error types, how to box types to make data sizes predictable for the compiler, how to construct a recursive node tree and navigate it, how to write code that recursively evaluates an expression, and how to specify lifetime parameters for structs.</p>
			<p>Congratulations if you successfully followed along and got some working code! If you had any difficulties, you can refer to the final code in the GitHub repository. </p>
			<p>This example project establishes a strong foundation from which to dig into the details of system programming in the upcoming chapters. If you haven't fully understood every detail of the code, there is no reason to fret. We will be writing a lot more code and reinforcing the concepts of idiomatic Rust code as we go along in the coming chapters.</p>
			<p>In the next chapter, we will cover the Rust standard library, and see how it supports a rich set of built-in modules, types, traits, and functions to perform systems programming.</p>
		</div>
	</body></html>