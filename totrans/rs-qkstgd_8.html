<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Important Standard Traits</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we've seen already, traits are an important part of the Rust ecosystem. The traits that are built into the Rust standard library affect many things, including even what operators can be used on a particular data value. In this chapter, we're going to review many of these traits, and see how to implement them on our own data types.</p>
<p>In this chapter, we're going to do the following:</p>
<ul>
<li>Look at an assortment of traits defined by the Rust standard library</li>
<li>Learn about the meanings and implications of those traits</li>
<li>Learn about what traits are applied automatically</li>
<li>Learn how to use the <kbd>derive</kbd> command to generate trait implementations for select traits</li>
<li>Learn how to manually implement the remaining traits</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits that can be derived</h1>
                </header>
            
            <article>
                
<p>For some traits, the compiler itself knows how to implement them for a type. If we want them, we only have to tell it that we do, and it will take care of the rest for us.</p>
<div class="packt_tip">We still have the option of manually implementing derivable traits, but that would usually just be a waste of time.</div>
<p>Telling the compiler that we want a data type to have a derivable trait is easy.</p>
<p class="mce-root"/>
<p>Here, we're telling it that we want our <kbd>CopyExample</kbd> enumeration to implement <kbd>Copy</kbd> and <kbd>Clone</kbd>:</p>
<pre>#[derive(Copy, Clone)]<br/>pub enum CopyExample {<br/>    Good,<br/>    Bad,<br/>}</pre>
<p>A trait can only be derived if the people who created the trait were able to write a program to generate the trait implementation. When we write <kbd>#[derive(Copy, Clone)]</kbd>, we're telling the compiler to go find those programs for deriving <kbd>Copy</kbd> and <kbd>Clone</kbd> in the source code of the packages where the traits were defined, and run those programs to generate the source code for the trait implementations before it continues compiling. If the decisions that need to be made to implement a trait are too complex for a program to make without user input, the trait can't be derived.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Clone</h1>
                </header>
            
            <article>
                
<p>The <kbd>Clone</kbd> trait means that it is possible to make an explicit copy of a data value. The compiler won't ever do it automatically, but when we want to copy a value, we can do so by calling its <kbd>Clone</kbd> function.</p>
<p>Deriving the <kbd>Clone</kbd> trait looks like this:</p>
<pre>#[derive(Clone)]<br/>pub enum CloneExample {<br/>    Good,<br/>    Bad,<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Copy</h1>
                </header>
            
            <article>
                
<p>The <kbd>Copy</kbd> trait means that creating a copy of the data value is just a matter of copying the bits that make up its representation. If the data value contains any borrows or uses heap memory, it can't have the <kbd>Copy</kbd> trait. </p>
<p><span>The compiler will automatically copy data values that have the </span><kbd>Copy</kbd><span> trait when it would have otherwise moved them.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Since anything that has the <kbd>Copy</kbd> trait can certainly be duplicated on request as well, <kbd>Copy</kbd> requires <kbd>Clone</kbd> to be implemented.</p>
<p>Deriving <kbd>Copy</kbd> looks like this:</p>
<pre>#[derive(Copy, Clone)]<br/>pub enum CopyExample {<br/>    Good,<br/>    Bad,<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Debug</h1>
                </header>
            
            <article>
                
<p>The <kbd>Debug</kbd> trait tells Rust how to format the data value for debugging output. One place this is used is if we use <kbd>{:?}</kbd> instead of <kbd>{}</kbd> as the substitution marker for the data value in <kbd>println!</kbd> or <kbd>print!</kbd>.</p>
<p>Since the debugging representation of a data value should be pretty close to the way it would be represented in the source code, Rust is able to derive it for us automatically.</p>
<p>Deriving <kbd>Debug</kbd> looks like this:</p>
<pre>#[derive(Debug)]<br/>pub enum DebugExample {<br/>    Good,<br/>    Bad,<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PartialEq</h1>
                </header>
            
            <article>
                
<p>The <kbd>PartialEq</kbd> trait represents the ability to compare the data value with another one to determine whether they are equal. It does <em>not</em> imply that a value is considered equal to itself, however.</p>
<p>The <kbd>PartialEq</kbd> trait is used by the compiler to implement the <kbd>==</kbd> comparison operation.</p>
<p>Floating point numbers are the classic example of a data type that has <kbd>PartialEq</kbd>, because the floating point representation of a <kbd>NaN</kbd> or <kbd>Not a Number</kbd> value is not considered equal to itself.</p>
<p class="mce-root"/>
<p>Deriving <kbd>PartialEq</kbd> looks like this:</p>
<pre>#[derive(PartialEq)]<br/>pub enum PartialEqSelf {<br/>    Good,<br/>    Bad,<br/>}</pre>
<p>However, that derivation only compares two <kbd>PartialEqSelf</kbd> data values. If we want to enable an equality comparison with data values of other types, we need to implement the trait manually.</p>
<p>Here, we have a manual implementation of the trait, enabling comparison with the <kbd>u32</kbd> data type:</p>
<pre>pub enum PartialEqU32 {<br/>    Good,<br/>    Bad,<br/>}<br/><br/>impl PartialEq&lt;u32&gt; for PartialEqU32 {<br/>    fn eq(&amp;self, other: &amp;u32) -&gt; bool {<br/>        match self {<br/>            PartialEqU32::Good =&gt; other % 2 == 0,<br/>            PartialEqU32::Bad =&gt; other % 2 == 1,<br/>        }<br/>    }<br/>}</pre>
<p>Here, we've arranged for the <kbd>PartialEqU32::Good</kbd> value to compare as equal to even number <kbd>u32</kbd>s, and <kbd>PartialEqU32::Bad</kbd> to compare equal to odd number <kbd>u32</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Eq</h1>
                </header>
            
            <article>
                
<p>The <kbd>Eq</kbd> trait means the same thing that <kbd>PartialEq</kbd> does, <em>except</em> that a data value is always equal to itself.</p>
<p>Implementing the <kbd>Eq</kbd> trait requires implementing the <kbd>PartialEq</kbd> trait as well, and the only thing it does beyond what <kbd>PartialEq</kbd> does is provide the compiler with the hint that it doesn't need to bother running the <kbd>Eq</kbd> function when both sides of the comparison are the same data value.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Deriving <kbd>Eq</kbd> looks like this:</p>
<pre>#[derive(Eq, PartialEq)]<br/>pub enum EqExample {<br/>    Good,<br/>    Bad,<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PartialOrd</h1>
                </header>
            
            <article>
                
<p>The <kbd>PartialOrd</kbd> trait represents the ability to define some sort of ordering between two data values, so we can say one of them is less than the other, or greater than the other, or that they're the same, <em>or</em> that the ordering relation does not apply to these values. That last one is the reason why this is a <em>partial</em> ordering.</p>
<p>Since <em>they're the same</em> is a valid result of the comparison, implementing <kbd>PartialOrd</kbd> requires the implemention of <kbd>PartialEq</kbd>.</p>
<p>As with <kbd>PartialEq</kbd>, we can derive an implementation that compares two data values of the same type, but we can also manually implement the trait to allow comparison with data of different types.</p>
<p>Here, we have the automatic derivation of the trait:</p>
<pre>#[derive(PartialOrd, PartialEq)]<br/>pub enum PartialOrdSelf {<br/>    Good,<br/>    Bad,<br/>}</pre>
<p>Here, we have implemented it manually to support comparison with a different data type:</p>
<pre>pub enum PartialOrdU32 {<br/> Good,<br/> Bad,<br/>}<br/><br/>impl PartialEq&lt;u32&gt; for PartialOrdU32 {<br/>    fn eq(&amp;self, _other: &amp;u32) -&gt; bool {<br/>        false<br/>    }<br/>}<br/><br/>impl PartialOrd&lt;u32&gt; for PartialOrdU32 {<br/>    fn partial_cmp(&amp;self, _other: &amp;u32) -&gt; Option&lt;Ordering&gt; {<br/>        match self {<br/>            PartialOrdU32::Good =&gt; Some(Ordering::Greater),<br/>            PartialOrdU32::Bad =&gt; None,<br/>        }<br/>    }<br/>}</pre>
<p>Here, we're telling Rust that a <kbd>PartialOrdU32::Good</kbd> value is always greater than any <kbd>u32</kbd> value, but a <kbd>PartialOrdU32::Bad</kbd> value does not have any relation to any <kbd>u32</kbd> value at all.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ord</h1>
                </header>
            
            <article>
                
<p><kbd>Ord</kbd> is like <kbd>PartialOrd</kbd>, except that it doesn't allow the option of returning a "no relation" value; for any pair of values, either they are equal, or one is less than the other.</p>
<p><kbd>Ord</kbd><span> is used by the compiler to implement the </span><kbd>&lt;</kbd><span> (less than), </span><kbd>&gt;</kbd><span> (greater than), </span><kbd>&lt;=</kbd><span> (less than or equal), and </span><kbd>&gt;=</kbd><span> (greater than or equal) comparison operators.</span></p>
<p>If a data type has the <kbd>Ord</kbd> trait, it has to also have the <kbd>PartialOrd</kbd>, <kbd>Eq</kbd>, and <kbd>PartialEq</kbd> traits. Like those traits, it can be manually implemented to enable comparisons between different data types, but we have to be very careful that the results returned by the various functions that are used to implement those traits agree with each other. When we derive the traits, we don't have to worry about that.</p>
<p>Here's an example of deriving <kbd>Ord</kbd>:</p>
<pre>#[derive(Ord, Eq, PartialOrd, PartialEq)]<br/>pub enum OrdExample {<br/>    Good,<br/>    Bad,<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hash</h1>
                </header>
            
            <article>
                
<p>The <kbd>Hash</kbd> trait enables a data value to be used as a key in several of Rust's standard library data structures, such as <kbd>HashMap</kbd> and <kbd>HashSet</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Deriving the <kbd>Hash</kbd> trait looks like this:</p>
<pre>#[derive(Hash)]<br/>pub enum HashExample {<br/>    Good,<br/>    Bad,<br/>}</pre>
<p>While <kbd>Eq</kbd> and <kbd>PartialEq</kbd> are not actually required to implement <kbd>Hash</kbd>, if they are implemented, they need to agree with it, which is to say that if two values are equal, their hash values should also be equal. The automatically generated implementations have this property, so we only need to worry about it if we're doing manual implementations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Default</h1>
                </header>
            
            <article>
                
<p>When the <kbd>Default</kbd> trait is implemented for a type, it makes it possible for us to request a default value for that type of data.</p>
<p>When we derive <kbd>Default</kbd> for a data type, it sets the default value for that type to be made up of the default values for all of the contained data types, so when we do this:</p>
<pre>#[derive(Default)]<br/>pub struct DefaultExample {<br/>    name: String,<br/>    value: i32,<br/>}</pre>
<p>What we're doing is setting the default for the <kbd>DefaultExample</kbd> type to be a <kbd>DefaultExample</kbd> containing the default values of a <kbd>String</kbd> and an <kbd>i32</kbd>.</p>
<p>We can request a default value like this:</p>
<pre>let x: DefaultExample = Default::default();<br/>println!("Default String is {:?}, default i32 is {:?}", x.name, x.value);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits that enable operators</h1>
                </header>
            
            <article>
                
<p>Most of the operators and the special syntax of Rust are backed up by traits, which tell the compiler how to perform the operation on the specific data type it's looking at. We've seen some of those already, but many of them can't be derived, so if we want to enable that syntax for our data types, we need to implement them manually.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">​Add, Mul, Sub, and Div</h1>
                </header>
            
            <article>
                
<p>The <kbd>Add</kbd>, <kbd>Mul</kbd>, <kbd>Sub</kbd>, and <kbd>Div</kbd> traits represent the ability to add, multiply, subtract, or divide two values. These traits are used by the compiler to implement the <kbd>+</kbd>, <kbd>*</kbd>, <kbd>-</kbd>, and <kbd>/</kbd> operators.</p>
<p>Notice that if the values of <kbd>self</kbd> and <kbd>other</kbd> do not have the <kbd>Copy</kbd> trait, they are moved into the implementation function and consumed.</p>
<p>All of these traits follow the same pattern, so here's an example implementation of <kbd>Add</kbd>:</p>
<pre>pub enum AddExample {<br/>    One,<br/>    Two,<br/>    Three,<br/>    Many,<br/>}<br/><br/>impl Add for AddExample {<br/>    type Output = AddExample;<br/><br/>    fn add(self, other: AddExample) -&gt; AddExample {<br/>        match (self, other) {<br/>            (AddExample::One, AddExample::One) =&gt; AddExample::Two,<br/>            (AddExample::One, AddExample::Two) =&gt; AddExample::Three,<br/>            (AddExample::Two, AddExample::One) =&gt; AddExample::Three,<br/>            _ =&gt; AddExample::Many,<br/>        }<br/>    }<br/>}</pre>
<p><kbd>Mul</kbd>, <kbd>Sub</kbd>, and <kbd>Div</kbd> follow the same pattern.</p>
<div class="packt_tip">What we've defined here is a very primitive form of counting, that considers any number greater than 3 to be "many".</div>
<p>Inside the <kbd>impl</kbd> block, we have <kbd>type Output = AddExample;</kbd>. That's a bit of new syntax we haven't seen before. What we're doing is setting the <kbd>Output</kbd> <em>associated type</em> for this implementation, which is fed back into the trait definition to be used in declaring the signature of the <kbd>add</kbd> function. After all, we're returning an <kbd>AddExample</kbd> here, and there was no such type when the trait was originally defined. That's not a problem, though, because the trait says that the <kbd>add</kbd> function returns a data value of type <kbd>Output</kbd>, and we've just told it that <kbd>Output</kbd> is an alias for <kbd>AddExample</kbd>.</p>
<p class="mce-root"/>
<p>We can also implement adding data of two different types together, by implementing <kbd>Add&lt;OtherType&gt; for OneType</kbd> to represent the ability to have a <kbd>OneType</kbd> value on the left side of the <kbd>+</kbd> and an <kbd>OtherType</kbd> value on the right, similarly to the way we were able to create comparisons between two different types earlier in the chapter. The same trick works for <kbd>Mul</kbd>, <kbd>Sub</kbd>, and <kbd>Div</kbd> as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">AddAssign, MulAssign, SubAssign, and DivAssign</h1>
                </header>
            
            <article>
                
<p>These traits enable the <kbd>+=</kbd>, <kbd>*=</kbd>, <kbd>-=</kbd>, and <kbd>/=</kbd> operators for the types that implement them.</p>
<p>They are similar to the <kbd>Add</kbd>, <kbd>Sub</kbd>, <kbd>Mul</kbd>, and <kbd>Div</kbd> traits, with the difference that their implementation functions take <kbd>&amp;mut self</kbd> instead of plain <kbd>self</kbd>. Instead of consuming their left-side input, they have the ability to change its contained value.</p>
<p>All of these traits follow the same pattern, so here's an example implementation of <kbd>AddAssign</kbd>:</p>
<pre>pub enum AddExample {<br/> One,<br/> Two,<br/> Three,<br/> Many,<br/>}<br/><br/>impl AddAssign for AddExample {<br/>    fn add_assign(&amp;mut self, other: AddExample) {<br/>        *self = match (&amp;self, other) {<br/>            (AddExample::One, AddExample::One) =&gt; AddExample::Two,<br/>            (AddExample::One, AddExample::Two) =&gt; AddExample::Three,<br/>            (AddExample::Two, AddExample::One) =&gt; AddExample::Three,<br/>            _ =&gt; AddExample::Many,<br/>        };<br/>    }<br/>}</pre>
<p>Apart from the differences based on assigning the new value to <kbd>&amp;mut self</kbd>, this is much like the implementation of the <kbd>add</kbd> function for the <kbd>Add</kbd> trait, which isn't very surprising.</p>
<p>In particular, while it doesn't consume its <kbd>self</kbd>, it does still consume the value on the right-hand side of the operand, assuming that value doesn't have the <kbd>Copy</kbd> trait.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitAnd</h1>
                </header>
            
            <article>
                
<p>The <kbd>BitAnd</kbd> trait enables the <kbd>&amp;</kbd> operator for types that implement it. This operator is used for computing the <em>bitwise and</em> value of two integers (hence the name), but has different meanings for various other data types.</p>
<p>Implementing <kbd>BitAnd</kbd> looks like this:</p>
<pre>pub enum BitExample {<br/>    Yes,<br/>    No,<br/>}<br/><br/>impl BitAnd for BitExample {<br/>    type Output = BitExample;<br/><br/> fn bitand(self, other: BitExample) -&gt; BitExample {<br/> match (self, other) {<br/> (BitExample::Yes, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::No,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::No,<br/>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitAndAssign</h1>
                </header>
            
            <article>
                
<p>The <kbd>BitAndAssign</kbd> trait enables the <kbd>&amp;=</kbd> operator for data types that implement it.</p>
<p>Implementing <kbd>BitAndAssign</kbd> looks like this:</p>
<pre>pub enum BitExample {<br/> Yes,<br/> No,<br/>}<br/><br/>impl BitAndAssign for BitExample {<br/>    fn bitand_assign(&amp;mut self, other: BitExample) {<br/>        *self = match (&amp;self, other) {<br/>            (BitExample::Yes, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::No,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::No,</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        };<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitOr</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>BitOr</kbd><span> </span>trait enables the<span> </span><kbd>|</kbd><span> </span>operator for types that implement it. This operator is used for computing the<span> </span><em>bitwise or</em><span> </span>value of two integers, but has different meanings for various other data types.</p>
<p>Implementing<span> </span><kbd>BitOr</kbd><span> </span>looks like this:</p>
<pre>pub enum BitExample {<br/>    Yes,<br/>    No,<br/>}<br/>impl BitOr for BitExample {<br/> type Output = BitExample;<br/><br/> fn bitor(self, other: BitExample) -&gt; BitExample {<br/>        match (self, other) {<br/>            (BitExample::Yes, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitOrAssign</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>BitOrAssign</kbd><span> </span>trait enables the<span> </span><kbd>|=</kbd><span> </span>operator for data types that implement it.</p>
<p>Implementing<span> </span><kbd>BitOrAssign</kbd><span> </span>looks like this:</p>
<pre>pub enum BitExample {<br/> Yes,<br/> No,<br/>}<br/><br/>impl BitOrAssign for BitExample {<br/>    fn bitor_assign(&amp;mut self, other: BitExample) {<br/>        *self = match (&amp;self, other) {<br/>            (BitExample::Yes, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        };<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitXor</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>BitXor</kbd><span> </span>trait enables the<span> </span><kbd>^</kbd><span> </span>operator for types that implement it. This operator is used for computing the<span> </span><em>bitwise exclusive or</em><span> </span>value of two integers, but has different meanings for various other data types.</p>
<p>Implementing<span> </span><kbd>BitXor</kbd><span> </span>looks like this:</p>
<pre>pub enum BitExample {<br/>    Yes,<br/>    No,<br/>}<br/><br/>impl BitXor for BitExample {<br/> type Output = BitExample;<br/><br/>    fn bitxor(self, other: BitExample) -&gt; BitExample {<br/>        match (self, other) {<br/>            (BitExample::Yes, BitExample::Yes) =&gt; BitExample::No,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">BitXorAssign</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>BitXorAssign</kbd><span> </span>trait enables the<span> </span><kbd>^=</kbd><span> </span>operator for data types that implement it.</p>
<p>Implementing<span> </span><kbd>BitXorAssign</kbd><span> </span>looks like this:</p>
<pre>pub enum BitExample {<br/> Yes,<br/> No,<br/>}<br/><br/>impl BitXorAssign for BitExample {<br/>    fn bitxor_assign(&amp;mut self, other: BitExample) {<br/>        *self = match (&amp;self, other) {<br/>            (BitExample::Yes, BitExample::Yes) =&gt; BitExample::No,<br/>            (BitExample::No, BitExample::Yes) =&gt; BitExample::Yes,<br/>            (BitExample::Yes, BitExample::No) =&gt; BitExample::Yes,<br/>            (BitExample::No, BitExample::No) =&gt; BitExample::No,<br/>        };<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deref</h1>
                </header>
            
            <article>
                
<p>The <kbd>Deref</kbd> trait grants the ability to dereference a value as if it were a borrow. Smart pointers implement this trait, which is why they can be used as though they were borrows of the contained data value. <kbd>String</kbd> does the same thing, which is what allows us to use a <kbd>String</kbd> value anywhere that an <kbd>&amp;str</kbd> is expected.</p>
<p>Here we have an implementation of the <kbd>Deref</kbd> trait:</p>
<pre>pub struct DerefExample {<br/> val: u32,<br/>}<br/><br/>impl Deref for DerefExample {<br/>    type Target = u32;<br/><br/>    fn deref(&amp;self) -&gt; &amp;u32 {<br/>        return &amp;self.val;<br/>    }<br/>}</pre>
<p>Notice that the implementation function doesn't actually dereference anything. Instead, it converts an <kbd>&amp;self</kbd> borrow into a borrow of something else.</p>
<p>That's what the compiler needs in order to correctly and efficiently handle dereferencing smart pointers and such, but the compiler also uses that ability to let us interact with something like a <kbd>Rc&lt;Box&lt;String&gt;&gt;</kbd> as if it were just a plain old <kbd>&amp;str</kbd>. The <kbd>Rc</kbd> has a <kbd>deref</kbd> function that returns a borrow of a <kbd>Box</kbd>, and the <kbd>Box</kbd> has a <kbd>deref</kbd> function that returns a  borrow of a <kbd>String</kbd>, and the <kbd>String</kbd> has a <kbd>deref</kbd> function that returns a borrow of a <kbd>str</kbd>, so the compiler lets us treat the whole thing as if it was an <kbd>&amp;str</kbd> for the purposes of calling its functions or using it as a parameter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DerefMut</h1>
                </header>
            
            <article>
                
<p>The <kbd>DerefMut</kbd> trait does the same thing <kbd>Deref</kbd> does, but it is used when derefencing a mutable value. The compiler decides whether to use <kbd>Deref</kbd> or <kbd>DerefMut</kbd>, so usually when we need to implement one, we need to implement them both.</p>
<p>Here we have an implementation of <kbd>DerefMut</kbd>:</p>
<pre>pub struct DerefExample {<br/>    val: u32,<br/>}<br/><br/>impl DerefMut for DerefExample {<br/>    fn deref_mut(&amp;mut self) -&gt; &amp;mut u32 {<br/>        return &amp;mut self.val;<br/>    }<br/>}</pre>
<p>The <kbd>DerefMut</kbd> trait requires that the <kbd>Deref</kbd> trait is also implemented, and that the <kbd>deref</kbd> and <kbd>deref_mut</kbd> functions have the same return type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drop</h1>
                </header>
            
            <article>
                
<p>When a data type has the <kbd>Drop</kbd> trait, the program will call the <kbd>drop</kbd> function for values of that type immediately before their lifetimes end. That's how <kbd>Rc</kbd>, <kbd>Mutex</kbd>, <kbd>RefCell</kbd>, and so on are able to keep track of how many borrows their contained value has.</p>
<p>The <kbd>drop</kbd> function is called before the data value's lifetime ends, so we don't have to worry about it being an invalid reference. Also, we don't have to worry about manually cleaning up the contained values for our data type, because they will be automatically dropped themselves after our <kbd>drop</kbd> function is finished. All we need to do is handle whatever special case led us to implement <kbd>Drop</kbd> in the first place.</p>
<p>We can't directly call the <kbd>drop</kbd> function, because that would be an extremely good way to make a mess. There is a <kbd>std::mem::drop</kbd> function we can use that consumes a data value and drops it for us, if we need to trigger this at a specific time.</p>
<p>Implementing <kbd>Drop</kbd> looks like this:</p>
<pre>pub enum DropExample {<br/> Good,<br/> Bad,<br/>}<br/><br/>impl Drop for DropExample {<br/>    fn drop(&amp;mut self) {<br/>        match self {<br/>            DropExample::Good =&gt; println!("Good DropExample dropped"),<br/>            DropExample::Bad =&gt; println!("Bad DropExample dropped"),<br/>        };<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Index</h1>
                </header>
            
            <article>
                
<p>The <kbd>Index</kbd> trait means that the data type can be used with the <kbd>x[y]</kbd> syntax, where a value is looked up inside of <kbd>x</kbd> based on the <em>index value</em> <kbd>y</kbd>.</p>
<p>When we implement <kbd>Index</kbd>, we need to identify what data type can be used for the index value, as well as what data type the operation returns, so the implementation looks like this:</p>
<pre>pub struct IndexExample {<br/> first: u32,<br/> second: u32,<br/> third: u32,<br/>}<br/><br/>impl&lt;'a&gt; Index&lt;&amp;'a str&gt; for IndexExample {<br/>    type Output = u32;<br/><br/>    fn index(&amp;self, index: &amp;'a str) -&gt; &amp;u32 {<br/>        match index {<br/>            "first" =&gt; &amp;self.first,<br/>            "second" =&gt; &amp;self.second,<br/>            "third" =&gt; &amp;self.third,<br/>            _ =&gt; &amp;0,<br/>        }<br/>    }<br/>}</pre>
<p>We've used <kbd>&amp;str</kbd> for the data type of the index, and were using <kbd>u32</kbd> for the data type of the value. Using <kbd>&amp;str</kbd> means that we need to be a little bit careful of lifetimes, but it's not too bad.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">IndexMut</h1>
                </header>
            
            <article>
                
<p>The <kbd>IndexMut</kbd> trait represents the abilities to assign to a contained value using the <kbd>x[y] = z</kbd> syntax. Like the <kbd>Index</kbd> trait, it lets us look up a contained data value by providing an index value, but it produces a mutable borrow of the contained value, which can be used to change it.</p>
<p>Implementing <kbd>IndexMut</kbd> looks like this:</p>
<pre>pub struct IndexExample {<br/> first: u32,<br/> second: u32,<br/> third: u32,<br/> junk: u32,<br/>}<br/><br/>impl&lt;'a&gt; IndexMut&lt;&amp;'a str&gt; for IndexExample {<br/>    fn index_mut(&amp;mut self, index: &amp;'a str) -&gt; &amp;mut u32 {<br/>        match index {<br/>            "first" =&gt; &amp;mut self.first,<br/>            "second" =&gt; &amp;mut self.second,<br/>            "third" =&gt; &amp;mut self.third,<br/>            _ =&gt; &amp;mut self.junk,<br/>        }<br/>    }<br/>}</pre>
<p>Notice that we've added a <kbd>junk</kbd> value to the <kbd>IndexExample</kbd> structure. We did that because there's no way to indicate that an index value doesn't map to a valid contained value; if the <kbd>index_mut</kbd> function gets called, is <em>has</em> to return a mutable borrow of the correct type, and that borrow has to have a long enough lifetime as well. Adding a junk value to the data structure is a simple way of achieving that, though there are other approaches that would save memory.</p>
<p>Any type that implements <kbd>IndexMut</kbd> has to implement <kbd>Index</kbd> as well, and the <kbd>index</kbd> and <kbd>index_mut</kbd> functions have to return a borrow and a mutable borrow of the same data type, respectively.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Neg</h1>
                </header>
            
            <article>
                
<p>The <kbd>Neg</kbd> trait enables a data type to be used with the <em>unary negation</em> operator, also known as the negative sign. When we write <kbd>-5</kbd>, we're applying the unary negation operator to the value 5, producing a negative 5 as the result.</p>
<p>Implementing <kbd>Neg</kbd> looks like this:</p>
<pre>pub enum NegExample {<br/> Yes,<br/> No,<br/>}<br/><br/>impl Neg for NegExample {<br/> type Output = NegExample;<br/><br/> fn neg(self) -&gt; NegExample {<br/> match self {<br/> NegExample::Yes =&gt; NegExample::No,<br/> NegExample::No =&gt; NegExample::Yes,<br/> }<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Not</h1>
                </header>
            
            <article>
                
<p>The <kbd>Not</kbd> trait enables the <em>logical negation</em> operator, which is written as an <kbd>!</kbd>. <kbd>Not</kbd> is both conceptually and practically similar to <kbd>Neg</kbd>, but its primary use is for Boolean logic rather than arithmetic.</p>
<p>Implementing <kbd>Not</kbd> looks like this:</p>
<pre>pub enum NotExample {<br/> True,<br/> False,<br/>}<br/><br/>impl Not for NotExample {<br/>    type Output = NotExample;<br/><br/>    fn not(self) -&gt; NotExample {<br/>        match self {<br/>            NotExample::True =&gt; NotExample::False,<br/>            NotExample::False =&gt; NotExample::True,<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rem and RemAssign</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Rem</kbd><span> </span>trait enables the<span> </span><kbd>%</kbd><span> </span>operator for types that implement it. This operator is used for computing the<span> </span><em>modulus</em><span> (also known as the remainder of a division) </span>value of two integers, but has different meanings for various other data types.</p>
<p class="mce-root">The <kbd>Rem</kbd> trait has both an <kbd>Output</kbd> associated type, and the option of implementing it to operate on different types by implementing <kbd>Rem&lt;OtherType&gt;</kbd> rather than just <kbd>Rem</kbd>.</p>
<p><kbd>RemAssign</kbd> has the same relationship to <kbd>Rem</kbd> that <kbd>AddAssign</kbd> has to <kbd>Add</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shl and ShlAssign</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Shl</kbd><span> </span>trait enables the<span> </span><kbd>&lt;&lt;</kbd><span> </span>operator for types that implement it. This operator is used for <em>left-shifting</em> an integer by a number of bits, but has different meanings for various other data types.</p>
<p class="mce-root">The<span> </span><kbd>Shl</kbd><span> </span>trait has both an output associated type, and the option of implementing it to operate on different types by implementing<span> </span><kbd>Shl&lt;OtherType&gt;</kbd><span> </span>rather than just<span> </span><kbd>Shl</kbd>.</p>
<p><kbd>ShlAssign</kbd><span> has the same relationship to </span><kbd>Shl</kbd><span> that </span><kbd>AddAssign</kbd><span> has to </span><kbd>Add</kbd><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shr and ShrAssign</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Shr</kbd><span> </span>trait enables the<span> </span><kbd>&gt;&gt;</kbd><span> </span>operator for types that implement it. This operator is used for <em>right-shifting</em> an integer by a number of bits, but has different meanings for various other data types.</p>
<p class="mce-root">The<span> </span><kbd>Shr</kbd><span> </span>trait has both an <kbd>Output</kbd> associated type, and the option of implementing it to operate on different types by implementing<span> </span><kbd>Shr&lt;OtherType&gt;</kbd><span> </span>rather than just<span> </span><kbd>Shr</kbd>.</p>
<p><kbd>ShrAssign</kbd><span> has the same relationship to </span><kbd>Shr</kbd><span> that </span><kbd>AddAssign</kbd><span> has to </span><kbd>Add</kbd><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Traits that are implemented automatically</h1>
                </header>
            
            <article>
                
<p>There are a few traits that are automatically implemented where appropriate, without even a <kbd>#[derive()]</kbd> tag. These tend to represent extremely low-level aspects of the data types in question.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sync</h1>
                </header>
            
            <article>
                
<p>The <kbd>Sync</kbd> trait is automatically applied to any data type that can safely be borrowed between threads.</p>
<p>While our data types will have the <kbd>Sync</kbd> trait automatically if they qualify for it, occasionally we want to be sure that a data type <em>does not</em> have <kbd>Sync</kbd>, even if it looks to the compiler like it should.</p>
<p>We can achieve that by implementing <kbd>!Sync</kbd> for our data type:</p>
<pre>pub enum NotSyncExample {<br/> Good,<br/> Bad,<br/>}<br/><br/>impl !Sync for NotSyncExample {}</pre>
<p>We don't actually need any functions inside of <kbd>!Sync</kbd>. All we're doing is telling the compiler that the <kbd>Sync</kbd> trait is inappropriate for this type.</p>
<div class="packt_tip">As of Rust 1.29, implementing <kbd>!Sync</kbd> is still considered an unstable feature, and is not available in the stable build of the compiler. It can be enabled in the nightly build by placing <kbd>#![feature(optin_builtin_traits)]</kbd> at the top of the file.</div>
<p>A lot of data types have the <kbd>Sync</kbd> trait, but <kbd>Rc</kbd>, <kbd>Cell</kbd>, and <kbd>RefCell</kbd> are notable examples of types that do not. <kbd>Arc</kbd>, <kbd>Mutex</kbd>, and <kbd>RwLock</kbd> do, though.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Send</h1>
                </header>
            
            <article>
                
<p>The <kbd>Send</kbd> trait is automatically applied to any data type that can safely be moved between threads. It is a close relative of <kbd>Sync</kbd>, and like <kbd>Sync</kbd>, we can implement <kbd>!Send</kbd> to tell the compiler that a data type should <em>not</em> have the trait.</p>
<p>If we don't explicitly forbid it, the compiler decides whether a type has the <kbd>Send</kbd> trait based on whether the types it contains have the trait.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sized</h1>
                </header>
            
            <article>
                
<p>The <kbd>Sized</kbd> trait is automatically applied to any data type for which the size is known by the compiler. All trait bounds automatically include <kbd>Sized</kbd> as an additional, implicit requirement, unless we instead tell it that <kbd>?Sized</kbd> is the requirement. If we explicitly declare a trait bound is <kbd>?Sized</kbd>, that means that the data type that matches the bound is allowed to be <kbd>Sized</kbd>, but not required.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fn</h1>
                </header>
            
            <article>
                
<p>The <kbd>Fn</kbd> trait is automatically applied to any function or closure that uses only immutable borrows to access data outside its own scope.</p>
<p>This is a strict requirement, and many functions and closures fail that test, so <kbd>Fn</kbd> is the least common of the function traits.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">FnMut</h1>
                </header>
            
            <article>
                
<p>The <kbd>FnMut</kbd> trait is automatically applied to any function or closure that uses mutable or immutable borrows to access data outside its own scope.</p>
<p>This is a moderate requirement, but some functions and closures fail that test, so <kbd>FnMut</kbd> is more common than <kbd>Fn</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">FnOnce</h1>
                </header>
            
            <article>
                
<p>The <kbd>FnOnce</kbd> trait is automatically applied to any function that uses mutable borrows, immutable borrows, or moved variables to access data outside its own scope.</p>
<p>The is a loose requirement, which any function or closure will satisfy, so <kbd>FnOnce</kbd> is the most common of the function traits.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have done the following:</p>
<ul>
<li>Looked at many different traits</li>
<li>Examined the traits' specific meanings and how they interact with syntax of Rust</li>
<li>Learned about the details of implementing the traits</li>
<li>Learned how to easily derive traits that support that feature</li>
</ul>
<p>We've reached the end of this quick start guide, but the journey is never over. Good luck on your next steps.</p>


            </article>

            
        </section>
    </div>



  </body></html>