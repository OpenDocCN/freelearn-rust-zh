["```rs\nlet fut = future::ok(10u64);\nlet mapped_fut = fut.map(|x| x as f64);\n```", "```rs\nlet stream = stream::iter_ok::<_, ()>(vec![-1, 0, 1, 2, 3]);\nlet filtered_stream = stream.filter(|x| x > 0);\n```", "```rs\nfn multiple() {\n    let (tx_sink, rx_stream) = mpsc::channel::<u8>(8);\n    let receiver = rx_stream.fold(0, |acc, value| {\n        future::ok(acc + value)\n    }).map(|x| {\n        println!(\"Calculated: {}\", x);\n    });\n    let send_1 = tx_sink.clone().send(1);\n    let send_2 = tx_sink.clone().send(2);\n    let send_3 = tx_sink.clone().send(3);\n    let execute_all = future::join_all(vec![\n        to_box(receiver),\n        to_box(send_1),\n        to_box(send_2),\n        to_box(send_3),\n    ]).map(drop);\n    drop(tx_sink);\n    tokio::run(execute_all);\n}\n```", "```rs\nfn to_box<T>(fut :T) -> Box<dyn Future<Item=(), Error=()> + Send>\nwhere\n    T: IntoFuture,\n    T::Future: Send + 'static,\n    T::Item: 'static,\n    T::Error: 'static,\n{\n    let fut = fut.into_future().map(drop).map_err(drop);\n    Box::new(fut)\n}\n```", "```rs\nfn single() {\n    let (tx_sender, rx_future) = oneshot::channel::<u8>();\n    let receiver = rx_future.map(|x| {\n        println!(\"Received: {}\", x);\n    });\n    let sender = tx_sender.send(8);\n    let execute_all = future::join_all(vec![\n        to_box(receiver),\n        to_box(sender),\n    ]).map(drop);\n    tokio::run(execute_all);\n}\n```", "```rs\nfn alt_udp_echo() -> Result<(), Error> {\n    let from = \"0.0.0.0:12345\".parse()?;\n    let socket = UdpSocket::bind(&from)?;\n    let framed = UdpFramed::new(socket, LinesCodec::new());\n    let (sink, stream) = framed.split();\n    let (tx, rx) = mpsc::channel(16);\n    let rx = rx.map_err(|_| other(\"can't take a message\"))\n        .fold(sink, |sink, frame| {\n            sink.send(frame)\n        });\n    let process = stream.and_then(move |args| {\n        tx.clone()\n            .send(args)\n            .map(drop)\n            .map_err(other)\n    }).collect();\n    let execute_all = future::join_all(vec![\n        to_box(rx),\n        to_box(process),\n    ]).map(drop);\n    Ok(tokio::run(execute_all))\n}\n```", "```rs\nfn other<E>(err: E) -> io::Error\nwhere\n    E: Into<Box<std::error::Error + Send + Sync>>,\n{\n    io::Error::new(io::ErrorKind::Other, err)\n}\n```", "```rs\n$ nc -vnu 0.0.0.0 12345\nNcat: Version 7.60 ( https://nmap.org/ncat )\nNcat: Connected to 0.0.0.0:12345.\nText Message\nText Message\n^C\n```", "```rs\nfn send_spawn() {\n    let (tx_sink, rx_stream) = mpsc::channel::<u8>(8);\n    let receiver = rx_stream.fold(0, |acc, value| {\n        println!(\"Received: {}\", value);\n        future::ok(acc + value)\n    }).map(drop);\n    let spawner = stream::iter_ok::<_, ()>(1u8..11u8).map(move |x| {\n        let fut = tx_sink.clone().send(x).map(drop).map_err(drop);\n        tokio::spawn(fut);\n    }).collect();\n    let execute_all = future::join_all(vec![\n        to_box(spawner),\n        to_box(receiver),\n    ]).map(drop);\n    tokio::run(execute_all);\n}\n```", "```rs\nasync fn http_get(addr: &str) -> Result<String, std::io::Error> {\n    let mut conn = await!(NetwrokStream::connect(addr))?;\n    let _ = await!(conn.write_all(b\"GET / HTTP/1.0\\r\\n\\r\\n\"))?;\n    let mut buf = vec![0;1024];\n    let len = await!(conn.read(&mut buf))?;\n    let res = String::from_utf8_lossy(&buf[..len]).to_string();\n    Ok(res)\n}\n```", "```rs\nfn main() {\n    let files = Path::new(\"./files\");\n    fs::create_dir(files).ok();\n    let addr = ([127, 0, 0, 1], 8080).into();\n    let builder = Server::bind(&addr);\n    let server = builder.serve(move || {\n        service_fn(move |req| microservice_handler(req, &files))\n    });\n    let server = server.map_err(drop);\n    hyper::rt::run(server);\n}\n```", "```rs\nfn microservice_handler(req: Request<Body>, files: &Path)\n    -> Box<Future<Item=Response<Body>, Error=std::io::Error> + Send>\n```", "```rs\nmatch (req.method(), req.uri().path().to_owned().as_ref()) {\n    (&Method::GET, \"/\") => {\n        Box::new(future::ok(Response::new(INDEX.into())))\n    },\n    _ => {\n        response_with_code(StatusCode::NOT_FOUND)\n    },\n}\n```", "```rs\nfn response_with_code(status_code: StatusCode)\n    -> Box<Future<Item=Response<Body>, Error=Error> + Send>\n{\n    let resp = Response::builder()\n        .status(status_code)\n        .body(Body::empty())\n        .unwrap();\n    Box::new(future::ok(resp))\n}\n```", "```rs\n(&Method::POST, \"/upload\") => {\n    let name: String = thread_rng().sample_iter(&Alphanumeric).take(20).collect();\n    let mut filepath = files.to_path_buf();\n    filepath.push(&name);\n    let create_file = File::create(filepath);\n    let write = create_file.and_then(|file| {\n        req.into_body()\n            .map_err(other)\n            .fold(file, |file, chunk| {\n            tokio::io::write_all(file, chunk)\n                .map(|(file, _)| file)\n        })\n    });\n    let body = write.map(|_| {\n        Response::new(name.into())\n    });\n    Box::new(body)\n}\n```", "```rs\nfn other<E>(err: E) -> Error\nwhere\n    E: Into<Box<std::error::Error + Send + Sync>>,\n{\n    Error::new(ErrorKind::Other, err)\n}\n```", "```rs\n--------------------------53164434ae464234f\nContent-Disposition: form-data; name=\"first_file\"; filename=\"file1.txt\"\nContent-Type: text/plain\nContents of the file1.txt\n--------------------------53164434ae464234f\nContent-Disposition: form-data; name=\"second_file\"; filename=\"file2.txt\"\nContent-Type: text/plain\nContents of the file2.txt\n--------------------------53164434ae464234f\n```", "```rs\nlazy_static! {\n    static ref DOWNLOAD_FILE: Regex = Regex::new(\"^/download/(?P<filename>\\\\w{20})?$\").unwrap();\n}\n```", "```rs\n(&Method::GET, path) if path.starts_with(\"/download\") => {\n    if let Some(cap) = DOWNLOAD_FILE.captures(path) {\n            let filename = cap.name(\"filename\").unwrap().as_str();\n            let mut filepath = files.to_path_buf();\n            filepath.push(filename);\n            let open_file = File::open(filepath);\n            let body = open_file.map(|file| {\n                let chunks = FileChunkStream::new(file);\n                Response::new(Body::wrap_stream(chunks))\n            });\n            Box::new(body)\n    } else {\n        response_with_code(StatusCode::NOT_FOUND)\n    }\n}\n```", "```rs\n$ curl https://www.rust-lang.org/logos/rust-logo-128x128.png | curl -X POST --data-binary @- localhost:8080/upload\n\nI4tcxkp9SnAjkbJwzy0m\n```"]