<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data Serialization, Deserialization, and Parsing</h1>
                
            
            
                
<p class="calibre2">In the previous chapter, we covered writing simple socket servers in Rust. Transport protocols such as TCP and UDP only provide mechanisms to transport messages, so it is up to a higher-level protocol to actually craft and send those messages. Also, TCP and UDP protocols always deal with bytes; we saw this when we called <kbd class="calibre11">as_bytes</kbd> on our strings before sending those out on the socket. This process of converting a piece of data into a format that can be stored or transmitted (a stream of bytes in the case of networking) is called serialization. The reverse process is deserialization, which turns a raw data format into a data structure. Any networking software must deal with serializing and deserializing data that has been received, or is about to be sent out. This simple conversion is not always possible for more complex types such as user-defined types, or even simple collection types. The Rust ecosystem has special crates that can handle these in a wide range of cases.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre7">
<li class="calibre8">Serialization and deserialization using Serde. We will start with basic usage and then move on to writing custom serializers using Serde.</li>
<li class="calibre8">Parsing textual data using nom.</li>
<li class="calibre8">The last topic will be on parsing binary data, a very frequently used technique in networking.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Serialization and deserialization using Serde</h1>
                
            
            
                
<p class="calibre2">Serde is the de-facto standard way of serializing and deserializing data in Rust. Serde supports a number of data structures that it can serialize out of the box to a number of given data formats (including JSON, and TOML, CSV). The easiest way to understand Serde is to think of it as an invertible function that transforms a given data structure into a stream of bytes. Other than standard data types, Serde also provides a few macros that can be implemented on user defined data types, making them (de)serializable.</p>
<p class="calibre2">In <a href="part0031.html#TI1E0-e803f047c8b7448c90887daa96419287" class="calibre10">Chapter 2</a>,Â <em class="calibre16">Introduction to Rust and its Ecosystem</em>, we discussed how procedural macros can be used to implement custom derives for given data types. Serde uses that mechanism to provide two custom derives, named <kbd class="calibre11">Serialize</kbd> and <kbd class="calibre11">Deserialize</kbd>, that can be implemented for user-defined data types that are composed of data types that Serde supports. Let us look at a small example of how this works. We start with creating the empty project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin serde-basic</strong></pre>
<p class="calibre2">Here is what the Cargo manifest should look like:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "serde-basic"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>serde = "1.0"<br class="title-page-name"/>serde_derive = "1.0"<br class="title-page-name"/>serde_json = "1.0"<br class="title-page-name"/>serde_yaml = "0.7.1"</pre>
<p class="calibre2">The <kbd class="calibre11">serde</kbd> crate is the core of the Serde ecosystem. The <kbd class="calibre11">serde_derive</kbd> crate provides necessary instrumentation that uses procedural macros for deriving <kbd class="calibre11">Serialize</kbd> and <kbd class="calibre11">Deserialize</kbd>. The next two crates provide Serde-specific functionality to and from JSON and YAML, respectively:</p>
<pre class="calibre17">// chapter4/serde-basic/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate serde_derive;<br class="title-page-name"/><br class="title-page-name"/>extern crate serde;<br class="title-page-name"/>extern crate serde_json;<br class="title-page-name"/>extern crate serde_yaml;<br class="title-page-name"/><br class="title-page-name"/>// We will serialize and deserialize instances of<br class="title-page-name"/>// this struct<br class="title-page-name"/>#[derive(Serialize, Deserialize, Debug)]<br class="title-page-name"/>struct ServerConfig {<br class="title-page-name"/>    workers: u64,<br class="title-page-name"/>    ignore: bool,<br class="title-page-name"/>    auth_server: Option&lt;String&gt;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let config = ServerConfig {<br class="title-page-name"/>                workers: 100, <br class="title-page-name"/>                ignore: false, <br class="title-page-name"/>                auth_server: Some("auth.server.io".to_string())<br class="title-page-name"/>            };<br class="title-page-name"/>    {<br class="title-page-name"/>        println!("To and from YAML");<br class="title-page-name"/>        let serialized = serde_yaml::to_string(&amp;config).unwrap();<br class="title-page-name"/>        println!("{}", serialized);<br class="title-page-name"/>        let deserialized: ServerConfig =<br class="title-page-name"/>        serde_yaml::from_str(&amp;serialized).unwrap();<br class="title-page-name"/>        println!("{:?}", deserialized);<br class="title-page-name"/>    }<br class="title-page-name"/>    println!("\n\n");<br class="title-page-name"/>    {<br class="title-page-name"/>        println!("To and from JSON");<br class="title-page-name"/>        let serialized = serde_json::to_string(&amp;config).unwrap();<br class="title-page-name"/>        println!("{}", serialized);<br class="title-page-name"/>        let deserialized: ServerConfig =<br class="title-page-name"/>        serde_json::from_str(&amp;serialized).unwrap();<br class="title-page-name"/>        println!("{:?}", deserialized);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Since the <kbd class="calibre11">serde_derive</kbd> crate exports macros, we will need to mark it with a <kbd class="calibre11">macro_use</kbd> declaration; we then declare all our dependencies as <kbd class="calibre11">extern</kbd> crates. Having set this up, we can define our custom data type. In this case, we are interested in a config for a server that has a bunch of parameters of different types. The <kbd class="calibre11">auth_server</kbd> parameter is optional and that is why it is wrapped in an <kbd class="calibre11">Option</kbd>. Our struct derives the two traits from Serde, and also the compiler-provided <kbd class="calibre11">Debug</kbd> trait that we will use later to display after deserialization. In our main function, we instantiate our class and call <kbd class="calibre11">serde_yaml::to_string</kbd> on it to serialize it to a string; the reverse of this is <kbd class="calibre11">serde_yaml::from_str</kbd>.</p>
<p class="calibre2">A sample run should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling serde-basic v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter4/serde-basic)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 1.88 secs<br class="title-page-name"/>     Running `target/debug/serde-basic`<br class="title-page-name"/>To and from YAML<br class="title-page-name"/>---<br class="title-page-name"/>workers: 100<br class="title-page-name"/>ignore: false<br class="title-page-name"/>auth_server: auth.server.io<br class="title-page-name"/>ServerConfig { workers: 100, ignore: false, auth_server: Some("auth.server.io") }<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>To and from JSON<br class="title-page-name"/>{"workers":100,"ignore":false,"auth_server":"auth.server.io"}<br class="title-page-name"/>ServerConfig { workers: 100, ignore: false, auth_server: Some("auth.server.io") }</pre>
<p class="calibre2">Let us move on to a more advanced example of using Serde over a network. In this example, we will set up a TCP server and a client. This part will be exactly the same as how we did it in the last chapter. But this time, our TCP server will function as a calculator that takes in a point in a 3D space with three components along the three axes, and returns its distance from the origin in the same reference frame. Let us set up our Cargo project like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin serde-server</strong></pre>
<p class="calibre2">The manifest should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "serde-server"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>serde = "1.0"<br class="title-page-name"/>serde_derive = "1.0"<br class="title-page-name"/>serde_json = "1.0"</pre>
<p class="calibre2">With this, we can then move on to defining our code. In this example, the server and the client will be in the same binary. The application will take in a flag that dictates whether it should run as the server or the client. As we did in the last chapter, in the server case, we will bind to all local interfaces on a known port and listen for incoming connections. The client case will connect to the server on that known port and wait for user input on the console. The client expects input as a comma-separated list of three integers, one for each axis. On getting the input, the client constructs a struct of a given definition, serializes it using Serde, and sends the stream of bytes to the server. The server deserializes the stream into a struct of the same type. It then computes the distance and sends back the result, which the client then displays. The code is as follows:</p>
<pre class="calibre17">// chapter4/serde-server/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate serde_derive;<br class="title-page-name"/><br class="title-page-name"/>extern crate serde;<br class="title-page-name"/>extern crate serde_json;<br class="title-page-name"/><br class="title-page-name"/>use std::net::{TcpListener, TcpStream};<br class="title-page-name"/>use std::io::{stdin, BufRead, BufReader, Error, Write};<br class="title-page-name"/>use std::{env, str, thread};<br class="title-page-name"/><br class="title-page-name"/>#[derive(Serialize, Deserialize, Debug)]<br class="title-page-name"/>struct Point3D {<br class="title-page-name"/>    x: u32,<br class="title-page-name"/>    y: u32,<br class="title-page-name"/>    z: u32,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Like previous examples of vanilla TCP servers, this function handles<br class="title-page-name"/>// a single client.<br class="title-page-name"/>fn handle_client(stream: TcpStream) -&gt; Result&lt;(), Error&gt; {<br class="title-page-name"/>    println!("Incoming connection from: {}", stream.peer_addr()?);<br class="title-page-name"/>    let mut data = Vec::new();<br class="title-page-name"/>    let mut stream = BufReader::new(stream);<br class="title-page-name"/><br class="title-page-name"/>    loop {<br class="title-page-name"/>        data.clear();<br class="title-page-name"/><br class="title-page-name"/>        let bytes_read = stream.read_until(b'\n', &amp;mut data)?;<br class="title-page-name"/>        if bytes_read == 0 {<br class="title-page-name"/>            return Ok(());<br class="title-page-name"/>        }<br class="title-page-name"/>        let input: Point3D = serde_json::from_slice(&amp;data)?;<br class="title-page-name"/>        let value = input.x.pow(2) + input.y.pow(2) + input.z.pow(2);<br class="title-page-name"/><br class="title-page-name"/>        write!(stream.get_mut(), "{}", f64::from(value).sqrt())?;<br class="title-page-name"/>        write!(stream.get_mut(), "{}", "\n")?;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let args: Vec&lt;_&gt; = env::args().collect();<br class="title-page-name"/>    if args.len() != 2 {<br class="title-page-name"/>        eprintln!("Please provide --client or --server as argument");<br class="title-page-name"/>        std::process::exit(1);<br class="title-page-name"/>    }<br class="title-page-name"/>    // The server case<br class="title-page-name"/>    if args[1] == "--server" {<br class="title-page-name"/>        let listener = TcpListener::bind("0.0.0.0:8888").expect("Could<br class="title-page-name"/>        not bind");<br class="title-page-name"/>        for stream in listener.incoming() {<br class="title-page-name"/>            match stream {<br class="title-page-name"/>                Err(e) =&gt; eprintln!("failed: {}", e),<br class="title-page-name"/>                Ok(stream) =&gt; {<br class="title-page-name"/>                    thread::spawn(move || {<br class="title-page-name"/>                        handle_client(stream).unwrap_or_else(|error|<br class="title-page-name"/>                        eprintln!("{:?}", error));<br class="title-page-name"/>                    });<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    // Client case begins here<br class="title-page-name"/>    else if args[1] == "--client" {<br class="title-page-name"/>        let mut stream = TcpStream::connect("127.0.0.1:8888").expect("Could not connect to server");<br class="title-page-name"/>        println!("Please provide a 3D point as three comma separated<br class="title-page-name"/>        integers");<br class="title-page-name"/>        loop {<br class="title-page-name"/>            let mut input = String::new();<br class="title-page-name"/>            let mut buffer: Vec&lt;u8&gt; = Vec::new();<br class="title-page-name"/>            stdin()<br class="title-page-name"/>                .read_line(&amp;mut input)<br class="title-page-name"/>                .expect("Failed to read from stdin");<br class="title-page-name"/>            let parts: Vec&lt;&amp;str&gt; = input<br class="title-page-name"/>                                    .trim_matches('\n')<br class="title-page-name"/>                                    .split(',')<br class="title-page-name"/>                                    .collect();<br class="title-page-name"/>            let point = Point3D {<br class="title-page-name"/>                x: parts[0].parse().unwrap(),<br class="title-page-name"/>                y: parts[1].parse().unwrap(),<br class="title-page-name"/>                z: parts[2].parse().unwrap(),<br class="title-page-name"/>            };<br class="title-page-name"/>            stream<br class="title-page-name"/>                .write_all(serde_json::to_string(&amp;point).unwrap().as_bytes())<br class="title-page-name"/>                .expect("Failed to write to server");<br class="title-page-name"/>            stream.write_all(b"\n").expect("Failed to write to<br class="title-page-name"/>            server");<br class="title-page-name"/><br class="title-page-name"/>            let mut reader = BufReader::new(&amp;stream);<br class="title-page-name"/>            reader<br class="title-page-name"/>                .read_until(b'\n', &amp;mut buffer)<br class="title-page-name"/>                .expect("Could not read into buffer");<br class="title-page-name"/>            let input = str::from_utf8(&amp;buffer).expect("Could not write<br class="title-page-name"/>            buffer as string");<br class="title-page-name"/>            if input == "" {<br class="title-page-name"/>                eprintln!("Empty response from server");<br class="title-page-name"/>            }<br class="title-page-name"/>            print!("Response from server {}", input);<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We start with setting up Serde as we did in the last example. We then define our 3D point as a struct of three elements. In our main function, we handle CLI arguments and branch out to the client or the server, depending on what was passed. In both cases, we signal the end of transmission by sending a newline character. The client reads a line fromÂ <kbd class="calibre11">stdin</kbd>, cleans it, and creates an instance of the struct in a loop. In both cases, we wrap our streams in a <kbd class="calibre11">BufReader</kbd> for easier handling. We run our code using Cargo. An example session on the server is as follows:</p>
<pre class="calibre17"><strong class="calibre1">server$ cargo run -- --server</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/serde-server --server`<br class="title-page-name"/>Incoming connection from: 127.0.0.1:49630</pre>
<p class="calibre2">And, on the client side, we see the following interaction with the server. As expected, the client reads input, serializes that, and sends it to the server. It then waits for a response and, when it gets one, prints the result to standard output:</p>
<pre class="calibre17"><strong class="calibre1">client$ cargo run -- --client</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/serde-server --client`<br class="title-page-name"/>Please provide a 3D point as three comma separated integers<br class="title-page-name"/>1,2,3<br class="title-page-name"/>Response from server 3.7416573867739413<br class="title-page-name"/>3,4,5<br class="title-page-name"/>Response from server 7.0710678118654755<br class="title-page-name"/>4,5,6<br class="title-page-name"/>Response from server 8.774964387392123</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Custom serialization and deserialization</h1>
                
            
            
                
<p class="calibre2">As we saw before, Serde provides built-in serialization and deserialization for all primitive data types, and a number of complex data types, via macros. In some cases, however, Serde might fail to auto-implement. This might happen for more complex data types. In those cases, you will need to implement these manually. These cases demonstrate advanced usage of Serde, which also allows renaming fields in the output. For everyday usage, using these advanced feature is almost never necessary. These might be more common for networking, to handle a new protocol, and more.</p>
<p class="calibre2">Let's say we have a struct of three fields. We will just assume that Serde fails to implement <kbd class="calibre11">Serialize</kbd> and <kbd class="calibre11">Deserialize</kbd> on this, and so we will need to implement those manually. We initialize our project using Cargo:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin serde-custom</strong></pre>
<p class="calibre2">We then declare our dependencies; the resulting Cargo config file should look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "serde-custom"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo &lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>serde = "1.0"<br class="title-page-name"/>serde_derive = "1.0"<br class="title-page-name"/>serde_json = "1.0"<br class="title-page-name"/>serde_test = "1.0"</pre>
<p class="calibre2">Our struct looks like this:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>// We will implement custom serialization and deserialization<br class="title-page-name"/>// for this struct<br class="title-page-name"/>#[derive(Debug, PartialEq)]<br class="title-page-name"/>struct KubeConfig {<br class="title-page-name"/>    port: u8,<br class="title-page-name"/>    healthz_port: u8,<br class="title-page-name"/>    max_pods: u8,<br class="title-page-name"/>}</pre>
<p class="calibre2">We need to derive <kbd class="calibre11">Debug</kbd> and <kbd class="calibre11">PartialEq</kbd> for Serde to use internally. In the real world, it might be necessary to manually implement those as well. Now, we will need to implement the <kbd class="calibre11">Serialize</kbd> trait for kubeconfig. This trait looks like this:</p>
<pre class="calibre17">pub trait Serialize {<br class="title-page-name"/>    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br class="title-page-name"/>        where S: Serializer;<br class="title-page-name"/>}</pre>
<p class="calibre2">The basic workflow for serializing our struct will simply be to serialize the struct name, then each of the elements, and then signal the end of serialization, in that order. Serde has built-in methods to serializeÂ that can work with all basic types, therefore an implementation does not need to worry about handling built-in types. Let's look at how we can serialize our struct:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>// Implementing Serialize for our custom struct defines<br class="title-page-name"/>// how instances of that struct should be serialized.<br class="title-page-name"/>// In essence, serialization of an object is equal to<br class="title-page-name"/>// sum of the serializations of it's components<br class="title-page-name"/>impl Serialize for KubeConfig {<br class="title-page-name"/>    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;<br class="title-page-name"/>        where S: Serializer<br class="title-page-name"/>    {<br class="title-page-name"/>        let mut state = serializer.serialize_struct("KubeConfig", 3)?;<br class="title-page-name"/>        state.serialize_field("port", &amp;self.port)?;<br class="title-page-name"/>        state.serialize_field("healthz_port", &amp;self.healthz_port)?;<br class="title-page-name"/>        state.serialize_field("max_pods", &amp;self.max_pods)?;<br class="title-page-name"/>        state.end()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Serialization of a struct will always begin with a call of <kbd class="calibre11">serialize_struct</kbd> with the struct name and number of fields as parameter (there are similarly named methods for other types). We then serialize each field in the order they appear while passing a key name that will be used in the resultant json. Once done, we call the special <kbd class="calibre11">end</kbd> method as a signal.</p>
<p class="calibre2">Implementing deserialization is a bit more involved, with a bit of boilerplate code. The related trait looks like this:</p>
<pre class="calibre17">pub trait Deserialize&lt;'de&gt;: Sized {<br class="title-page-name"/>    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;<br class="title-page-name"/>        where D: Deserializer&lt;'de&gt;;<br class="title-page-name"/>}</pre>
<p class="calibre2">Implementing this for a type requires implementing the visitor pattern. Serde defines a special <kbd class="calibre11">Visitor</kbd> trait, as shown in the following sample. Note that this has <kbd class="calibre11">visit_*</kbd> methods for all built-in types, those are not shown here. Also, in the following sample, we use the symbol <kbd class="calibre11">...</kbd> to indicate that there are more methods here that are not important for our discussion.</p>
<pre class="calibre17">pub trait Visitor&lt;'de&gt;: Sized {<br class="title-page-name"/>    type Value;<br class="title-page-name"/>    fn expecting(&amp;self, formatter: &amp;mut Formatter) -&gt; Result;<br class="title-page-name"/>    fn visit_bool&lt;E&gt;(self, v: bool) -&gt; Result&lt;Self::Value,<br class="title-page-name"/>     E&gt;<br class="title-page-name"/>    where<br class="title-page-name"/>        E: Error,<br class="title-page-name"/>    { }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">An implementation of this trait is used internally by the deserializer to construct the resultant type. In our case, it will look like this:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>// Implementing Deserialize for our struct defines how<br class="title-page-name"/>// an instance of the struct should be created from an<br class="title-page-name"/>// input stream of bytes<br class="title-page-name"/>impl&lt;'de&gt; Deserialize&lt;'de&gt; for KubeConfig {<br class="title-page-name"/>    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;<br class="title-page-name"/>        where D: Deserializer&lt;'de&gt;<br class="title-page-name"/>    {<br class="title-page-name"/>        enum Field { Port, HealthzPort, MaxPods };<br class="title-page-name"/><br class="title-page-name"/>        impl&lt;'de&gt; Deserialize&lt;'de&gt; for Field {<br class="title-page-name"/>            fn deserialize&lt;D&gt;(deserializer: D) -&gt;<br class="title-page-name"/>            Result&lt;Field,<br class="title-page-name"/>            D::Error&gt;<br class="title-page-name"/>                where D: Deserializer&lt;'de&gt;<br class="title-page-name"/>            {<br class="title-page-name"/>                struct FieldVisitor;<br class="title-page-name"/><br class="title-page-name"/>                impl&lt;'de&gt; Visitor&lt;'de&gt; for FieldVisitor {<br class="title-page-name"/>                    type Value = Field;<br class="title-page-name"/><br class="title-page-name"/>                    fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter)<br class="title-page-name"/>                    -&gt; fmt::Result {<br class="title-page-name"/>                        formatter.write_str("`port` or `healthz_port`<br class="title-page-name"/>                        or `max_pods`")<br class="title-page-name"/>                    }<br class="title-page-name"/><br class="title-page-name"/>                    fn visit_str&lt;E&gt;(self, value: &amp;str) -&gt;<br class="title-page-name"/>                    Result&lt;Field,<br class="title-page-name"/>                    E&gt;<br class="title-page-name"/>                        where E: de::Error<br class="title-page-name"/>                    {<br class="title-page-name"/>                        match value {<br class="title-page-name"/>                            "port" =&gt; Ok(Field::Port),<br class="title-page-name"/>                            "healthz_port" =&gt;<br class="title-page-name"/>                            Ok(Field::HealthzPort),<br class="title-page-name"/>                            "max_pods" =&gt; Ok(Field::MaxPods),<br class="title-page-name"/>                            _ =&gt; Err(de::Error::unknown_field(value, <br class="title-page-name"/>                            FIELDS)),<br class="title-page-name"/>                        }<br class="title-page-name"/>                    }<br class="title-page-name"/>                }<br class="title-page-name"/><br class="title-page-name"/>                deserializer.deserialize_identifier(FieldVisitor)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, the input to the deserializer is json, which can be treated as a map. Thus, we will only need to implement <kbd class="calibre11">visit_map</kbd> from the <kbd class="calibre11">Visitor</kbd> trait. If any non-json data is passed to our deserializer, it will error out on a call to some other function from that trait. Most of the previous implementation is boilerplate. It boils down to a few parts: implementing <kbd class="calibre11">Visitor</kbd> for the fields, and implementing <kbd class="calibre11">visit_str</kbd> (since all of our fields are strings). At this point, we should be able to deserialize individual fields. The second part is to implement <kbd class="calibre11">Visitor</kbd> for the overall struct, and to implement <kbd class="calibre11">visit_map</kbd>. Errors must be handled appropriately in all cases. In the end, we can callÂ <kbd class="calibre11">deserializer.deserialize_struct</kbd> and pass the name of the struct, the list of fields, and the visitor implementation for the whole struct.</p>
<p class="calibre2">This implementation will look like this:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>impl&lt;'de&gt; Deserialize&lt;'de&gt; for KubeConfig {<br class="title-page-name"/>    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;<br class="title-page-name"/>        where D: Deserializer&lt;'de&gt;<br class="title-page-name"/>    {<br class="title-page-name"/>        struct KubeConfigVisitor;<br class="title-page-name"/><br class="title-page-name"/>        impl&lt;'de&gt; Visitor&lt;'de&gt; for KubeConfigVisitor {<br class="title-page-name"/>            type Value = KubeConfig;<br class="title-page-name"/><br class="title-page-name"/>            fn expecting(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; <br class="title-page-name"/>            fmt::Result {<br class="title-page-name"/>                formatter.write_str("struct KubeConfig")<br class="title-page-name"/>            }<br class="title-page-name"/><br class="title-page-name"/>            fn visit_map&lt;V&gt;(self, mut map: V) -&gt;<br class="title-page-name"/>            Result&lt;KubeConfig, <br class="title-page-name"/>            V::Error&gt;<br class="title-page-name"/>                where V: MapAccess&lt;'de&gt;<br class="title-page-name"/>            {<br class="title-page-name"/>                let mut port = None;<br class="title-page-name"/>                let mut hport = None;<br class="title-page-name"/>                let mut max = None;<br class="title-page-name"/>                while let Some(key) = map.next_key()? {<br class="title-page-name"/>                    match key {<br class="title-page-name"/>                        Field::Port =&gt; {<br class="title-page-name"/>                            if port.is_some() {<br class="title-page-name"/>                                return <br class="title-page-name"/>                            Err(de::Error::duplicate_field("port"));<br class="title-page-name"/>                            }<br class="title-page-name"/>                            port = Some(map.next_value()?);<br class="title-page-name"/>                        }<br class="title-page-name"/>                        Field::HealthzPort =&gt; {<br class="title-page-name"/>                            if hport.is_some() {<br class="title-page-name"/>                                return<br class="title-page-name"/>                            Err(de::Error::duplicate_field<br class="title-page-name"/>                            ("healthz_port"));<br class="title-page-name"/>                            }<br class="title-page-name"/>                            hport = Some(map.next_value()?);<br class="title-page-name"/>                        }<br class="title-page-name"/>                        Field::MaxPods =&gt; {<br class="title-page-name"/>                            if max.is_some() {<br class="title-page-name"/>                                return <br class="title-page-name"/>                                Err(de::Error::duplicate_field<br class="title-page-name"/>                                ("max_pods"));<br class="title-page-name"/>                            }<br class="title-page-name"/>                            max = Some(map.next_value()?);<br class="title-page-name"/>                        }<br class="title-page-name"/>                    }<br class="title-page-name"/>                }<br class="title-page-name"/>                let port = port.ok_or_else(||<br class="title-page-name"/>                de::Error::missing_field("port"))?;<br class="title-page-name"/>                let hport = hport.ok_or_else(||<br class="title-page-name"/>                de::Error::missing_field("healthz_port"))?;<br class="title-page-name"/>                let max = max.ok_or_else(||<br class="title-page-name"/>                de::Error::missing_field("max_pods"))?;<br class="title-page-name"/>                Ok(KubeConfig {port: port, healthz_port: hport,<br class="title-page-name"/>                max_pods: max})<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        const FIELDS: &amp;'static [&amp;'static str] = &amp;["port",<br class="title-page-name"/>        "healthz_port", "max_pods"];<br class="title-page-name"/>        deserializer.deserialize_struct("KubeConfig", FIELDS,<br class="title-page-name"/>        KubeConfigVisitor)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Serde also provides a crate that can be used to unit test custom serializers and deserializers using a token-stream-like interface. To use it, we will need to add <kbd class="calibre11">serde_test</kbd> to our <kbd class="calibre11">Cargo.toml</kbd> and declare it as an extern crate in our main file. Here is a test for our deserializer:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[test]<br class="title-page-name"/>fn test_ser_de() {<br class="title-page-name"/>    let c = KubeConfig { port: 10, healthz_port: 11, max_pods: 12};<br class="title-page-name"/><br class="title-page-name"/>    assert_de_tokens(&amp;c, &amp;[<br class="title-page-name"/>        Token::Struct { name: "KubeConfig", len: 3 },<br class="title-page-name"/>        Token::Str("port"),<br class="title-page-name"/>        Token::U8(10),<br class="title-page-name"/>        Token::Str("healthz_port"),<br class="title-page-name"/>        Token::U8(11),<br class="title-page-name"/>        Token::Str("max_pods"),<br class="title-page-name"/>        Token::U8(12),<br class="title-page-name"/>        Token::StructEnd,<br class="title-page-name"/>    ]);<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre11">assert_de_tokens</kbd> call checksÂ if the given stream of tokens deserializes to our struct or not, thereby testing our deserializer. We can also add a main function to drive the serializer, like this:</p>
<pre class="calibre17">// chapter4/serde-custom/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let c = KubeConfig { port: 10, healthz_port: 11, max_pods: 12};<br class="title-page-name"/>    let serialized = serde_json::to_string(&amp;c).unwrap();<br class="title-page-name"/>    println!("{:?}", serialized);<br class="title-page-name"/>}</pre>
<p class="calibre2">All this can now be run using Cargo. UsingÂ <kbd class="calibre11">cargo test</kbd> should run the test we just wrote, which should pass. <kbd class="calibre11">cargo run</kbd> should run the main function and print the serialized json:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo test</strong><br class="title-page-name"/>   Compiling serde-custom v0.1.0 (file:///serde-custom)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.61 secs<br class="title-page-name"/>     Running target/debug/deps/serde_custom-81ee5105cf257563<br class="title-page-name"/><br class="title-page-name"/>running 1 test<br class="title-page-name"/>test test_ser_de ... ok<br class="title-page-name"/><br class="title-page-name"/>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling serde-custom v0.1.0 (file:///serde-custom)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.54 secs<br class="title-page-name"/>     Running `target/debug/serde-custom`<br class="title-page-name"/>    "{\"port\":10,\"healthz_port\":11,\"max_pods\":12}"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Parsing textual data</h1>
                
            
            
                
<p class="calibre2">Data parsing is a problem closely related to that of deserialization. The most common way of thinking about parsing is to start with aÂ formal grammar and construct parsers based on that. This results in a bottom-up parser where smaller rules parse smaller components of the whole input. A final combinatorial rule combines all smaller rules in a given order to form the final parser. This way of formally defining a finite set of rules is called a <strong class="calibre1">Parsing Expression Grammar</strong> (<strong class="calibre1">PEG</strong>). This ensures that parsing is unambiguous; that there is only one valid parse tree if parsing succeeds. In the Rust ecosystem, there are a few distinct ways of implementing PEGs, and each of those have their own strengths and weaknesses. The first way is using macros to define a domain-specific language for parsing.</p>
<p class="calibre2">This method integrates well with the compiler through the new macro system, and can produce fast code. However, this is often harder to debug and maintain. Since this method does not allow overloading operators, the implementation must define a DSL, which might be more of a cognitive load for a learner. The second method is using the trait system. This method helps in defining custom operators and is often easier to debug and maintain. An example of a parser that uses the first approach is nom; examples of parsers using the second approach are pom and pest.</p>
<p class="calibre2">Our use case for parsing is mostly in the context of networking applications. In these cases, sometimes it is more useful to deal with raw strings (or byte streams) and parse required information instead of deserializing to a complex data structure. A common case for this is any text-based protocol, such as HTTP. A server might receive a raw request as a stream of bytes over a socket and parse it to extract information. In this section, we will study some common parsing techniques in the Rust ecosystem.</p>
<p class="calibre2">Now, nom is a parser combinator framework, which means it can combine smaller parsers to build more powerful parsers. This is a bottom-up approach that usually starts with writing very specific parsers that parse a well-defined thing from the input. The framework then provides methods to chain these small parsers into a complete one. This approach is in contrast to a top-down approach in the case of lex and yacc, where one would start with defining the grammar. It can handle both byte streams (binary data) or strings, and provides all of Rust's usual guarantees. Let us start with parsing a simple string, which in this case is an HTTP GET or POST request. Like all cargo projects, we will first set up the structure:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin nom-http</strong></pre>
<p class="calibre2">Then we will add our dependencies (nom in this case). The resultant manifest should look like this:</p>
<pre class="calibre17"><strong class="calibre1">$ cat Cargo.toml</strong><br class="title-page-name"/>[package]<br class="title-page-name"/>name = "nom-http"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies.nom]<br class="title-page-name"/>version = "3.2.1"<br class="title-page-name"/>features = ["verbose-errors", "nightly"]</pre>
<p class="calibre2">The crate provides a few extra features that are often useful for debugging; these are disabled by default and can be turned on by passing the list to the <kbd class="calibre11">features</kbd> flag, as shown in the preceding sample. Now, let's move on to our main file:</p>
<pre class="calibre17">// chapter4/nom-http/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate nom;<br class="title-page-name"/><br class="title-page-name"/>use std::str;<br class="title-page-name"/>use nom::{ErrorKind, IResult};<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>enum Method {<br class="title-page-name"/>    GET,<br class="title-page-name"/>    POST,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>#[derive(Debug)]<br class="title-page-name"/>struct Request {<br class="title-page-name"/>    method: Method,<br class="title-page-name"/>    url: String,<br class="title-page-name"/>    version: String,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// A parser that parses method out of a HTT request<br class="title-page-name"/>named!(parse_method&lt;&amp;[u8], Method&gt;,<br class="title-page-name"/>       return_error!(ErrorKind::Custom(12), alt!(map!(tag!("GET"), |_| Method::GET) | map!(tag!("POST"), |_| Method::POST))));<br class="title-page-name"/><br class="title-page-name"/>// A parser that parses the request part<br class="title-page-name"/>named!(parse_request&lt;&amp;[u8], Request&gt;, ws!(do_parse!(<br class="title-page-name"/>    method: parse_method &gt;&gt;<br class="title-page-name"/>    url: map_res!(take_until!(" "), str::from_utf8) &gt;&gt;<br class="title-page-name"/>    tag!("HTTP/") &gt;&gt;<br class="title-page-name"/>    version: map_res!(take_until!("\r"), str::from_utf8) &gt;&gt;<br class="title-page-name"/>    (Request { method: method, url: url.into(), version: version.into() })<br class="title-page-name"/>)));<br class="title-page-name"/><br class="title-page-name"/>// Driver function for running the overall parser<br class="title-page-name"/>fn run_parser(input: &amp;str) {<br class="title-page-name"/>    match parse_request(input.as_bytes()) {<br class="title-page-name"/>      IResult::Done(rest, value) =&gt; println!("Rest: {:?} Value: {:?}",<br class="title-page-name"/>      rest, value),<br class="title-page-name"/>      IResult::Error(err) =&gt; println!("{:?}", err),<br class="title-page-name"/>      IResult::Incomplete(needed) =&gt; println!("{:?}", needed)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let get = "GET /home/ HTTP/1.1\r\n";<br class="title-page-name"/>    run_parser(get);<br class="title-page-name"/>    let post = "POST /update/ HTTP/1.1\r\n";<br class="title-page-name"/>    run_parser(post);<br class="title-page-name"/>    let wrong = "WRONG /wrong/ HTTP/1.1\r\n";<br class="title-page-name"/>    run_parser(wrong);<br class="title-page-name"/>}</pre>
<p class="calibre2">As might be obvious, nom makes heavy use of macros for code generation, the most important one being <kbd class="calibre11">named!</kbd>, which takes in a function signature and defines a parser based on that. A nom parser returns an instance of the <kbd class="calibre11">IResult</kbd> type; this is defined as an enum and has three variants:</p>
<ul class="calibre7">
<li class="calibre8">The <kbd class="calibre11">Done(rest, value)</kbd> variant represents the case where the current parser was successful. In this case, the value will have the current parsed value and the rest will have the remaining input to be parsed.</li>
<li class="calibre8">The <kbd class="calibre11">Error(Err&lt;E&gt;)</kbd> variant represents an error during parsing. The underlying error will have the error code, position in error, and more. In a large parse tree, this can also hold pointers to more errors.</li>
<li class="calibre8">The last variant, <kbd class="calibre11">Incomplete(needed)</kbd>, represents the case where parsing was incomplete for some reason. Needed is an enum that again has two variants; the first one represents the case where it is not known how much data is needed. The second one represents the exact size of data needed.</li>
</ul>
<p class="calibre2">We start with representations for HTTP methods and the full request as structs. In our toy example, we will only deal with GET and POST, and ignore everything else. We then define a parser for the HTTP method; our parser will take in a slice of bytes and return the <kbd class="calibre11">Method</kbd> enum. This is simply done by reading the input and looking for the strings GET or POST. In each case, the base parser is constructed using the <kbd class="calibre11">tag!</kbd> macro, which parses input to extract the given string. And, if the parsing was successful, we convert the result to <kbd class="calibre11">Method</kbd> using the <kbd class="calibre11">map!</kbd> macro, which maps the result of a parser to a function. Now, for parsing the method, we will either have a POST or a GET, but never both. We use the <kbd class="calibre11">alt!</kbd> macro to express the logical OR of both the parsers we constructed before. The <kbd class="calibre11">alt!</kbd> macro will construct a parser that parses the input if any one of it's constituent macros can parse the given input. Finally, all this is wrapped in the <kbd class="calibre11">return_error!</kbd> macro, which returns early if parsing fails in the current parser, instead of passing onto the next parser in the tree.</p>
<p class="calibre2">We then move on to parsing the whole request by defining <kbd class="calibre11">parse_request</kbd>. We start with trimming extra whitespace from the input using the <kbd class="calibre11">ws!</kbd> macro. We then invoke the <kbd class="calibre11">do_parse!</kbd> macro that chains multiple sub-parsers. This one is different from other combinators because this allows storing results from intermediate parsers. This is useful in constructing instances of our structs while returning results. In <kbd class="calibre11">do_parse!</kbd>, we first call <kbd class="calibre11">parse_method</kbd> and store its result in a variable. Having removed the method from a request, we should encounter empty whitespace before we find the location of the object. This is handled by the <kbd class="calibre11">take_until!(" ")</kbd> call, which consumes input till it finds an empty space. The result is converted to a <kbd class="calibre11">str</kbd> using <kbd class="calibre11">map_res!</kbd>. The next parser in the list is one that removes the sequence <kbd class="calibre11">HTTP/</kbd> using the <kbd class="calibre11">tag!</kbd> macro. Next, we parse the HTTP version by reading input till we see a <kbd class="calibre11">\r</kbd>, and map it back to a <kbd class="calibre11">str</kbd>. Once we are done with all the parsing, we construct a <kbd class="calibre11">Request</kbd> object and return it. Note the use of the <kbd class="calibre11">&gt;&gt;</kbd> symbol as a separator between parsers in the sequence.Â </p>
<p class="calibre2">We also define a helper function called <kbd class="calibre11">run_parser</kbd> to run our parsers in a given input and print the result. This function calls the parser and matches on the result to display either the resultant structure or error. We then define our main function with three HTTP requests, the first two being valid, and the last one being invalid since the method is wrong. On running this, the output is as follows:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>   Compiling nom-http v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/ch4/nom-http)<br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs<br class="title-page-name"/>     Running `target/debug/nom-http`<br class="title-page-name"/>Rest: [] Value: Request { method: GET, url: "/home/", version: "1.1" }<br class="title-page-name"/>Rest: [] Value: Request { method: POST, url: "/update/", version: "1.1" }<br class="title-page-name"/>NodePosition(Custom(128), [87, 82, 79, 78, 71, 32, 47, 119, 114, 111, 110, 103, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10], [Position(Alt, [87, 82, 79, 78, 71, 32, 47, 119, 114, 111, 110, 103, 47, 32, 72, 84, 84, 80, 47, 49, 46, 49, 13, 10])])</pre>
<p class="calibre2">In the first two cases, everything was parsed as expected and we got the result back. As expected, parsing failed in the last case with the custom error being returned.</p>
<p class="calibre2">As we discussed before, a common problem with nom is debugging, since it is much harder to debug macros. Macros also encourage the use of specific DSLs (like using the <kbd class="calibre11">&gt;&gt;</kbd> separator), which some people might find difficult to work with. At the time of writing, some error messages from nom are not helpful enough in finding what is wrong with a given parser. These will definitely improve in the future, but in the meantime, nom provides a few helper macros for debugging.</p>
<p class="calibre2">For instance,Â <kbd class="calibre11">dbg!</kbd> prints the result and the input if the underlying parser did not return a <kbd class="calibre11">Done</kbd>. TheÂ <kbd class="calibre11">dbg_dump!</kbd>Â macro is similar but also prints out a hex dump of the input buffer. In our experience, a few techniques can be used for debugging:</p>
<ul class="calibre7">
<li class="calibre8">Expanding the macro by passing compiler options to <kbd class="calibre11">rustc</kbd>. Cargo enables this using the following invocations: <kbd class="calibre11">cargo rustc -- -Z unstable-options --pretty=expanded</kbd> expands and pretty prints all macros in the given project. One might find it useful to expand the macros to trace execution and debug. A related command in Cargo, <kbd class="calibre11">rustc -- -Z trace-macros</kbd>, only expands the macros.</li>
<li class="calibre8">Running smaller parsers in isolation. Given a series of parsers and another one combining those, it might be easier to run each of the sub-parsers till one of those errors out. Then, one can go on to debug only the small parser that is failing. This is very useful in isolating faults.</li>
<li class="calibre8">Using the provided debugging macros <kbd class="calibre11">dbg!</kbd> and <kbd class="calibre11">dbg_dump!</kbd>. These can be used like debugging print statements to trace execution.</li>
</ul>
<div><kbd class="calibre31">pretty=expanded</kbd> is an unstable compiler option right now. Sometime in the future, it will be stabilized (or removed). In that case, one will not need to pass the <kbd class="calibre31">-Z unstable-options</kbd> flag to use it.</div>
<p class="calibre2">Let us look at an example of another parser combinator called <kbd class="calibre11">pom</kbd>. As we discussed before, this one relies heavily on traits and operator-overloading to implement parser combinations. As the time of writing, the current version is 1.1.0, and we will use that for our example project. Like always, the first step is to set up our project and add <kbd class="calibre11">pom</kbd> to our dependencies:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin pom-string</strong></pre>
<p class="calibre2">The <kbd class="calibre11">Cargo.toml</kbd> file will look like this:</p>
<pre class="calibre17">[package]<br class="title-page-name"/>name = "pom-string"<br class="title-page-name"/>version = "0.1.0"<br class="title-page-name"/>authors = ["Foo&lt;foo@bar.com&gt;"]<br class="title-page-name"/><br class="title-page-name"/>[dependencies]<br class="title-page-name"/>pom = "1.1.0"</pre>
<p class="calibre2">In this example, we will parse an example HTTP request, like last time. This is how it will look:</p>
<pre class="calibre17">// chapter4/pom-string/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>extern crate pom;<br class="title-page-name"/><br class="title-page-name"/>use pom::DataInput;<br class="title-page-name"/>use pom::parser::{sym, one_of, seq};<br class="title-page-name"/>use pom::parser::*;<br class="title-page-name"/><br class="title-page-name"/>use std::str;<br class="title-page-name"/><br class="title-page-name"/>// Represents one or more occurrence of an empty whitespace<br class="title-page-name"/>fn space() -&gt; Parser&lt;'static, u8, ()&gt; {<br class="title-page-name"/>    one_of(b" \t\r\n").repeat(0..).discard()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Represents a string in all lower case<br class="title-page-name"/>fn string() -&gt; Parser&lt;'static, u8, String&gt; {<br class="title-page-name"/>    one_of(b"abcdefghijklmnopqrstuvwxyz").repeat(0..).convert(String::from_utf8)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    let get = b"GET /home/ HTTP/1.1\r\n";<br class="title-page-name"/>    let mut input = DataInput::new(get);<br class="title-page-name"/>    let parser = (seq(b"GET") | seq(b"POST")) * space() * sym(b'/') *<br class="title-page-name"/>    string() * sym(b'/') * space() * seq(b"HTTP/1.1");<br class="title-page-name"/>    let output = parser.parse(&amp;mut input);<br class="title-page-name"/>    println!("{:?}", str::from_utf8(&amp;output.unwrap()));<br class="title-page-name"/>}</pre>
<p class="calibre2">We start with declaring our dependency on <kbd class="calibre11">pom</kbd>. In our main function, we define the final parser as a sequence of multiple sub-parsers. The <kbd class="calibre11">*</kbd> operator has been overloaded to make it apply multiple parsers in sequence. TheÂ <kbd class="calibre11">seq</kbd>Â operator is a built-in parser that matches the given string from input. The <kbd class="calibre11">|</kbd> operator does a logical OR of the two operands. We define a function called <kbd class="calibre11">space()</kbd> that represents empty white spaces in input. This function takes one of each empty whitespace characters, repeats it 0 or more times, and then discards it. Consequently, the function returns a <kbd class="calibre11">Parser</kbd> with no return type, indicated by <kbd class="calibre11">()</kbd>. The string function is similarly defined to be one of the characters in the English alphabet, repeated 0 or more times, and then converted to anÂ <kbd class="calibre11">std::String</kbd>.</p>
<p class="calibre2">The return type of this function is a <kbd class="calibre11">Parser</kbd> that has a <kbd class="calibre11">String</kbd>, as expected. Having set those up, our main parser will have a space, followed by the symbol <kbd class="calibre11">/</kbd>, followed by a string, a symbol <kbd class="calibre11">/</kbd>, a space again, and ending with the sequence <kbd class="calibre11">HTTP/1.1</kbd>. And, as expected, when we parse an example string with the parser we wrote, it produces an <kbd class="calibre11">Ok</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo run</strong><br class="title-page-name"/>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br class="title-page-name"/>     Running `target/debug/pom-string`<br class="title-page-name"/>Ok("HTTP/1.1")</pre>
<p class="calibre2">PEG-based parser combinators can be easier to debug and to work with. They also tend to produce better error messages, but, unfortunately, those are not mature enough right now. The community around them is not as large as the community around nom. Consequently, it is often easier to get help with nom issues. At the end of the day, it is up to the programmer to choose something that works for them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Parsing binary data</h1>
                
            
            
                
<p class="calibre2">A related problem is that of parsing binary data. Common cases where this is applicable include parsing binary files and binary protocols. Let us look at how <kbd class="calibre11">nom</kbd> can be used to parse binary data. In our toy example, we will write a parser for the IPv6 header. Our <kbd class="calibre11">Cargo.toml</kbd> will look exactly the same as last time. Set up the project using the CLI:</p>
<pre class="calibre17"><strong class="calibre1">$ cargo new --bin nom-ipv6</strong></pre>
<p class="calibre2">Our main file will look like this:</p>
<pre class="calibre17">// chapter4/nom-ipv6/src/main.rs<br class="title-page-name"/><br class="title-page-name"/>#[macro_use]<br class="title-page-name"/>extern crate nom;<br class="title-page-name"/><br class="title-page-name"/>use std::net::Ipv6Addr;<br class="title-page-name"/><br class="title-page-name"/>use nom::IResult;<br class="title-page-name"/><br class="title-page-name"/>// Struct representing an IPv6 header<br class="title-page-name"/>#[derive(Debug, PartialEq, Eq)]<br class="title-page-name"/>pub struct IPv6Header {<br class="title-page-name"/>    version: u8,<br class="title-page-name"/>    traffic_class: u8,<br class="title-page-name"/>    flow_label: u32,<br class="title-page-name"/>    payload_length: u16,<br class="title-page-name"/>    next_header: u8,<br class="title-page-name"/>    hop_limit: u8,<br class="title-page-name"/>    source_addr: Ipv6Addr,<br class="title-page-name"/>    dest_addr: Ipv6Addr,<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Converts a given slice of [u8] to an array of 16 u8 given by<br class="title-page-name"/>// [u8; 16]<br class="title-page-name"/>fn slice_to_array(input: &amp;[u8]) -&gt; [u8; 16] {<br class="title-page-name"/>    let mut array = [0u8; 16];<br class="title-page-name"/>    for (&amp;x, p) in input.iter().zip(array.iter_mut()) {<br class="title-page-name"/>        *p = x;<br class="title-page-name"/>    }<br class="title-page-name"/>    array<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Converts a reference to a slice [u8] to an instance of<br class="title-page-name"/>// std::net::Ipv6Addr<br class="title-page-name"/>fn to_ipv6_address(i: &amp;[u8]) -&gt; Ipv6Addr {<br class="title-page-name"/>    let arr = slice_to_array(i);<br class="title-page-name"/>    Ipv6Addr::from(arr)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Parsers for each individual section of the header<br class="title-page-name"/>named!(parse_version&lt;&amp;[u8], u8&gt;, bits!(take_bits!(u8, 4)));<br class="title-page-name"/>named!(parse_traffic_class&lt;&amp;[u8], u8&gt;, bits!(take_bits!(u8, 8)));<br class="title-page-name"/>named!(parse_flow_label&lt;&amp;[u8], u32&gt;, bits!(take_bits!(u32, 20)));<br class="title-page-name"/>named!(parse_payload_length&lt;&amp;[u8], u16&gt;, bits!(take_bits!(u16, 16)));<br class="title-page-name"/>named!(parse_next_header&lt;&amp;[u8], u8&gt;, bits!(take_bits!(u8, 8)));<br class="title-page-name"/>named!(parse_hop_limit&lt;&amp;[u8], u8&gt;, bits!(take_bits!(u8, 8)));<br class="title-page-name"/>named!(parse_address&lt;&amp;[u8], Ipv6Addr&gt;, map!(take!(16), to_ipv6_address));<br class="title-page-name"/><br class="title-page-name"/>// The primary parser<br class="title-page-name"/>named!(ipparse&lt;&amp;[u8], IPv6Header&gt;,<br class="title-page-name"/>       do_parse!(<br class="title-page-name"/>            ver: parse_version &gt;&gt;<br class="title-page-name"/>            cls: parse_traffic_class &gt;&gt;<br class="title-page-name"/>            lbl: parse_flow_label &gt;&gt;<br class="title-page-name"/>            len: parse_payload_length &gt;&gt;<br class="title-page-name"/>            hdr: parse_next_header &gt;&gt;<br class="title-page-name"/>            lim: parse_hop_limit &gt;&gt;<br class="title-page-name"/>            src: parse_address &gt;&gt;<br class="title-page-name"/>            dst: parse_address &gt;&gt;<br class="title-page-name"/>              (IPv6Header {<br class="title-page-name"/>                  version: ver,<br class="title-page-name"/>                  traffic_class: cls,<br class="title-page-name"/>                  flow_label: lbl,<br class="title-page-name"/>                  payload_length: len,<br class="title-page-name"/>                  next_header: hdr,<br class="title-page-name"/>                  hop_limit: lim,<br class="title-page-name"/>                  source_addr: src,<br class="title-page-name"/>                  dest_addr : dst<br class="title-page-name"/>              })<br class="title-page-name"/>));<br class="title-page-name"/><br class="title-page-name"/>// Wrapper for the parser<br class="title-page-name"/>pub fn parse_ipv6_header(i: &amp;[u8]) -&gt; IResult&lt;&amp;[u8], IPv6Header&gt; {<br class="title-page-name"/>    ipparse(i)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fn main() {<br class="title-page-name"/>    const EMPTY_SLICE: &amp;'static [u8] = &amp;[];<br class="title-page-name"/>    let bytes = [0x60,<br class="title-page-name"/>                 0x00,<br class="title-page-name"/>                 0x08, 0x19,<br class="title-page-name"/>                 0x80, 0x00, 0x14, 0x06,<br class="title-page-name"/>                 0x40,<br class="title-page-name"/>                 0x2a, 0x02, 0x0c, 0x7d, 0x2e, 0x5d, 0x5d, 0x00,<br class="title-page-name"/>                 0x24, 0xec, 0x4d, 0xd1, 0xc8, 0xdf, 0xbe, 0x75,<br class="title-page-name"/>                 0x2a, 0x00, 0x14, 0x50, 0x40, 0x0c, 0x0c, 0x0b,<br class="title-page-name"/>                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd<br class="title-page-name"/>                 ];<br class="title-page-name"/><br class="title-page-name"/>    let expected = IPv6Header {<br class="title-page-name"/>        version: 6,<br class="title-page-name"/>        traffic_class: 0,<br class="title-page-name"/>        flow_label: 33176,<br class="title-page-name"/>        payload_length: 20,<br class="title-page-name"/>        next_header: 6,<br class="title-page-name"/>        hop_limit: 64,<br class="title-page-name"/>        source_addr:<br class="title-page-name"/>        "2a02:c7d:2e5d:5d00:24ec:4dd1:c8df:be75".parse().unwrap(),<br class="title-page-name"/>        dest_addr: "2a00:1450:400c:c0b::bd".parse().unwrap(),<br class="title-page-name"/>    };<br class="title-page-name"/>    assert_eq!(ipparse(&amp;bytes), IResult::Done(EMPTY_SLICE, expected));<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, we start with declaring a struct for the IPv6 fixed header, as defined in RFC 2460Â (<a href="https://tools.ietf.org/html/rfc2460" class="calibre10">https://tools.ietf.org/html/rfc2460</a>). We first define a helper function called <kbd class="calibre11">to_ipv6_address</kbd> that takes in a slice of <kbd class="calibre11">u8</kbd>Â and converts to an IPv6 address. To do that, we need another helper function that converts a slice to a fixed-size array (<kbd class="calibre11">16</kbd> in this case). Having set those up, we define a number of parsers for parsing each of the members of the struct using the <kbd class="calibre11">named!</kbd> macro.</p>
<p class="calibre2">The <kbd class="calibre11">parse_version</kbd> function takes in a slice of bytes and returns the version as a <kbd class="calibre11">u8</kbd>. This is done by reading 4 bits from the input as a <kbd class="calibre11">u8</kbd>, using the <kbd class="calibre11">take_bits!</kbd> macro. That is then wrapped in the <kbd class="calibre11">bits!</kbd> macro which transforms the input to a bit stream for the underlying parser. In the same way, we go on to define parsers for all the other fields in the header structure. For each one, we take the number of bits they occupy according to the RFC and convert to a type large enough to hold it. The last case of parsing the address is different. Here, we read 16 bytes using the <kbd class="calibre11">take!</kbd> macro and map it to theÂ <kbd class="calibre11">to_ipv6_address</kbd> function to convert the byte stream, using the <kbd class="calibre11">map!</kbd> macro.</p>
<p class="calibre2">At this point, all small pieces to parse the whole struct are ready, and we can define a function using the <kbd class="calibre11">do_parse!</kbd> macro. In there, we accumulate results in temporary variables and construct an instance of theÂ <kbd class="calibre11">IPv6Header</kbd> struct, which is then returned. In our main function, we have an array of bytes that was taken from a IPv6 packet dump and should represent a valid IPv6 header. We parse that using the parser we defined and assert that the output matches what is expected. Thus, a successful run of our parser previously will not throw an exception.</p>
<p class="calibre2">Let us recap all the macros from <kbd class="calibre11">nom</kbd> that we used so far:</p>
<table class="calibre33">
<tbody class="calibre34">
<tr class="calibre35">
<td class="calibre36"><strong class="calibre1">Macro</strong></td>
<td class="calibre36"><strong class="calibre1">Purpose</strong></td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">named!</kbd></td>
<td class="calibre36">Creates a parsing function by combining smaller functions. This (or a variant) is always the top-level call in a chain.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">ws!</kbd></td>
<td class="calibre36">Enables a parser to consume all whitespaces (<kbd class="calibre37">\t</kbd>, <kbd class="calibre37">\r</kbd> and <kbd class="calibre37">\n</kbd>) between tokens.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">do_parse!</kbd></td>
<td class="calibre36">Applies subparsers in a given sequence, can store intermediate results.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">tag!</kbd></td>
<td class="calibre36">Declares a static sequence of bytes that the enclosing parser should recognize.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">take_until!</kbd></td>
<td class="calibre36">Consumes input till the given tag.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">take_bits!</kbd></td>
<td class="calibre36">Consumes the given number of bits from the input and casts them to the given type.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">take!</kbd></td>
<td class="calibre36">Consumes the specified number of bytes from input.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">map_res!</kbd></td>
<td class="calibre36">Maps a function (returning a result) on the output of a parser.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">map!</kbd></td>
<td class="calibre36">Maps a function to the output of a parser.</td>
</tr>
<tr class="calibre35">
<td class="calibre36"><kbd class="calibre37">bits!</kbd></td>
<td class="calibre36">Transforms the given slice to a bit stream.</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this section, we studied handling data in more detail. Specifically, (de)serializing and parsing. At the time of writing, Serde and related crates are the community-supported way of (de)serializing data in Rust, while <kbd class="calibre11">nom</kbd> is the most frequently used parser combinator. These tools tend to produce better error messages on the nightly compiler, and with a few feature flags turned on, since they often depend on a few cutting edge night-only features. With time, these features will be available in the stable compiler, and these tools will work seamlessly.</p>
<p class="calibre2">In the next chapter, we will talk about the next steps after having made sense of incoming data on a socket. More often than not, this involves dealing with application-level protocols.</p>


            

            
        
    </body></html>