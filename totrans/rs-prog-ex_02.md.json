["```rs\n$ sudo apt-get install libsdl2-dev\n```", "```rs\n$ sudo dnf install SDL2-devel\n```", "```rs\n$ yum install SDL2-devel\n```", "```rs\n$ brew install sdl2\n```", "```rs\n        gnu-mingw\\dll\\32\n        gnu-mingw\\dll\\64\n        gnu-mingw\\lib\\32\n        gnu-mingw\\lib\\64\n        msvc\\dll\\32\n        msvc\\dll\\64\n        msvc\\lib\\32\n        msvc\\lib\\64\n```", "```rs\nSDL2-devel-2.0.x-mingw.tar.gz\\SDL2-2.0.x\\i686-w64-mingw32\\bin    ->     gnu-mingw\\dll\\32\nSDL2-devel-2.0.x-mingw.tar.gz\\SDL2-2.0.x\\x86_64-w64-mingw32\\bin  ->     gnu-mingw\\dll\\64\nSDL2-devel-2.0.x-mingw.tar.gz\\SDL2-2.0.x\\i686-w64-mingw32\\lib    ->     gnu-mingw\\lib\\32\nSDL2-devel-2.0.x-mingw.tar.gz\\SDL2-2.0.x\\x86_64-w64-mingw32\\lib  ->     gnu-mingw\\lib\\64\nSDL2-devel-2.0.5-VC.zip\\SDL2-2.0.x\\lib\\x86\\*.dll                 ->     msvc\\dll\\32\nSDL2-devel-2.0.5-VC.zip\\SDL2-2.0.x\\lib\\x64\\*.dll                 ->     msvc\\dll\\64\nSDL2-devel-2.0.5-VC.zip\\SDL2-2.0.x\\lib\\x86\\*.lib                 ->     msvc\\lib\\32\nSDL2-devel-2.0.5-VC.zip\\SDL2-2.0.x\\lib\\x64\\*.lib                 ->     msvc\\lib\\64\n```", "```rs\n        build = \"build.rs\"\n```", "```rs\n      use std::env;\n      use std::path::PathBuf;\n\n      fn main() {\n        let target = env::var(\"TARGET\").unwrap();\n        if target.contains(\"pc-windows\") {\n          let manifest_dir = \n            PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n          let mut lib_dir = manifest_dir.clone();\n        let mut dll_dir = manifest_dir.clone();\n        if target.contains(\"msvc\") {\n            lib_dir.push(\"msvc\");\n            dll_dir.push(\"msvc\");\n        } else {\n            lib_dir.push(\"gnu-mingw\");\n            dll_dir.push(\"gnu-mingw\");\n        }\n        lib_dir.push(\"lib\");\n        dll_dir.push(\"dll\");\n        if target.contains(\"x86_64\") {\n            lib_dir.push(\"64\");\n            dll_dir.push(\"64\");\n        } else {\n            lib_dir.push(\"32\");\n            dll_dir.push(\"32\");\n        }\n        println!(\"cargo:rustc-link-search=all={}\", \n          lib_dir.display());\n        for entry in std::fs::read_dir(dll_dir).expect(\"Can't\n          read DLL dir\")  {\n         let entry_path = entry.expect(\"Invalid fs entry\").path();\n         let file_name_result = entry_path.file_name();\n         let mut new_file_path = manifest_dir.clone();\n         if let Some(file_name) = file_name_result {\n           let file_name = file_name.to_str().unwrap();\n           if file_name.ends_with(\".dll\") {\n             new_file_path.push(file_name);\n           std::fs::copy(&entry_path,\n           new_file_path.as_path()).expect(\"Can't copy \n             from DLL dir\");\n           }\n         }\n        }\n        }\n      }\n```", "```rs\n /*.dll\n```", "```rs\n SDL2-devel-2.0.x-mingw\\SDL2-2.0.x\\x86_64-w64-mingw32\\lib\n```", "```rs\n C:\\Program Files\\Rust\\lib\\rustlib\\x86_64-pc-windows-gnu\\lib\n```", "```rs\n LIBRARY_PATH = C:\\your\\rust\\library\\folder\n```", "```rs\n C:\\Users\\{Your Username}.multirust\\toolchains\\{current\n         toolchain}\\lib\\rustlib\\{current toolchain}\\lib\n```", "```rs\n SDL2-devel-2.0.x-mingw\\SDL2-2.0.x\\x86_64-w64-mingw32\\bin\n```", "```rs\n SDL2-devel-2.0.x-VC\\SDL2-2.0.x\\lib\\x64\\\n```", "```rs\n C:\\Program Files\\Rust\\lib\\rustlib\\x86_64-pc-windows-msvc\\lib\n```", "```rs\n LIB = C:\\your\\rust\\library\\folder\n```", "```rs\n SDL2-devel-2.0.x-VC\\SDL2-2.0.x\\lib\\x64\\\n```", "```rs\n cargo new tetris --bin\n```", "```rs\n     tetris/\n     |\n     |- Cargo.toml\n     |- src/\n         |\n         |- main.rs\n```", "```rs\n    [package]\n    name = \"tetris\"\n    version = \"0.0.1\"\n\n    [dependencies]\n    sdl2 = \"0.30.0\"\n```", "```rs\n[dependencies]\nsdl2 = { git = \"https://github.com/Rust-SDL2/rust-sdl2\" }\n```", "```rs\n|- src/\n    |\n    |- main.rs\n    |- another_file.rs\n```", "```rs\n    mod another_file;\n```", "```rs\n|- src/\n    |\n    |- main.rs\n    |- subfolder/\n        |- another_file.rs\n```", "```rs\n    pub mod another_file;\n```", "```rs\n    mod subfolder;\n```", "```rs\n    use subfolder::another_file::some_function;\n```", "```rs\n    mod a_module {\n      pub struct Foo;\n   }\n```", "```rs\n    extern crate sdl2;\n\n    use sdl2::pixels::Color;\n    use sdl2::event::Event;\n    use sdl2::keyboard::Keycode;\n    use std::time::Duration;\n    use std::thread::sleep;\n\n    pub fn main() {\n      let sdl_context = sdl2::init().expect(\"SDL initialization   \n      failed\");\n      let video_subsystem = sdl_context.video().expect(\"Couldn't get \n       SDL video subsystem\");\n\n      let window = video_subsystem.window(\"rust-sdl2 demo: Video\", 800,\n            600)\n        .position_centered()\n        .opengl()\n        .build()\n        .expect(\"Failed to create window\");\n\n      let mut canvas = window.into_canvas().build().expect(\"Failed to\n        convert window into canvas\");\n\n      canvas.set_draw_color(Color::RGB(255, 0, 0));\n      canvas.clear();\n      canvas.present();\n      let mut event_pump = sdl_context.event_pump().expect(\"Failed to\n        get SDL event pump\");\n\n      'running: loop {\n         for event in event_pump.poll_iter() {\n            match event {\n              Event::Quit { .. } |\n              Event::KeyDown { keycode: Some(Keycode::Escape), .. } =>  \n              {\n                break 'running\n              },\n              _ => {}\n            }\n         }\n         sleep(Duration::new(0, 1_000_000_000u32 / 60));\n      }\n    }\n```", "```rs\n    ::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n```", "```rs\n$ cargo run\n```", "```rs\n    extern crate sdl2;\n```", "```rs\n    let sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n```", "```rs\n    let video_subsystem = sdl_context.video().expect(\"Couldn't get SDL \n      video subsystem\");\n```", "```rs\n    let window = video_subsystem.window(\"Tetris\", 800, 600)\n                            .position_centered()\n                            .opengl()\n                            .build()\n                            .expect(\"Failed to create window\");\n```", "```rs\n    use sdl2::event::Event;\n    use sdl2::keyboard::Keycode;\n\n    use std::thread::sleep;\n    use std::time::Duration;\n```", "```rs\n    let mut event_pump = sdl_context.event_pump().expect(\"Failed to\n       get SDL event pump\");\n```", "```rs\n    'running: loop {\n      for event in event_pump.poll_iter() {\n        match event {\n            Event::Quit { .. } |\n            Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n                break 'running // We \"break\" the infinite loop.\n            },\n            _ => {}\n        }\n      }\n    sleep(Duration::new(0, 1_000_000_000u32 / 60));\n    }\n```", "```rs\n    'running: loop {\n      break 'running\n```", "```rs\n    let mut canvas = window.into_canvas()\n                       .target_texture()\n                       .present_vsync()\n                       .build()\n                       .expect(\"Couldn't get window's canvas\");\n```", "```rs\n    use sdl2::render::{Canvas, Texture, TextureCreator};\n```", "```rs\n    let texture_creator: TextureCreator<_> = canvas.texture_creator();\n```", "```rs\n    const TEXTURE_SIZE: u32 = 32;\n```", "```rs\n    let mut square_texture: Texture =\n        texture_creator.create_texture_target(None, TEXTURE_SIZE,\n          TEXTURE_SIZE)\n        .expect(\"Failed to create a texture\");\n```", "```rs\n    use sdl2::pixels::Color;\n```", "```rs\n    canvas.with_texture_canvas(&mut square_texture, |texture| {\n      texture.set_draw_color(Color::RGB(0, 255, 0));\n      texture.clear();\n    });\n```", "```rs\n    use sdl2::rect::Rect;\n```", "```rs\n    canvas.set_draw_color(Color::RGB(255, 0, 0));\n    canvas.clear();\n```", "```rs\n    canvas.copy(&square_texture,\n            None,\n            Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n        .expect(\"Couldn't copy texture into window\");\n```", "```rs\n     canvas.present();\n```", "```rs\n    extern crate sdl2;\n\n    use sdl2::event::Event;\n    use sdl2::keyboard::Keycode;\n    use sdl2::pixels::Color;\n    use sdl2::rect::Rect;\n    use sdl2::render::{Texture, TextureCreator};\n\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    fn main() {\n      let sdl_context = sdl2::init().expect(\"SDL initialization  \n       failed\");\n      let video_subsystem = sdl_context.video().expect(\"Couldn't get\n         SDL video subsystem\");\n\n      // Parameters are: title, width, height\n      let window = video_subsystem.window(\"Tetris\", 800, 600)\n        .position_centered() // to put it in the middle of the screen\n        .build() // to create the window\n        .expect(\"Failed to create window\");\n\n      let mut canvas = window.into_canvas()\n        .target_texture()\n        .present_vsync() // To enable v-sync.\n        .build()\n        .expect(\"Couldn't get window's canvas\");\n\n      let texture_creator: TextureCreator<_> =  \n       canvas.texture_creator();\n       // To make things easier to read, we'll create a constant \n          which will be the texture's size.\n      const TEXTURE_SIZE: u32 = 32;\n\n      // We create a texture with a 32x32 size.\n      let mut square_texture: Texture =\n        texture_creator.create_texture_target(None, TEXTURE_SIZE,\n            TEXTURE_SIZE)\n          .expect(\"Failed to create a texture\");\n\n      // We use the canvas to draw into our square texture.\n      canvas.with_texture_canvas(&mut square_texture, |texture| {\n        // We set the draw color to green.\n        texture.set_draw_color(Color::RGB(0, 255, 0));\n        // We \"clear\" our texture so it'll be fulfilled with green.\n        texture.clear();\n      }).expect(\"Failed to color a texture\");\n\n      // First we get the event handler:\n      let mut event_pump = sdl_context.event_pump().expect(\"Failed \n        to get SDL event pump\");\n\n      // Then we create an infinite loop to loop over events:\n      'running: loop {\n        for event in event_pump.poll_iter() {\n          match event {\n          // If we receive a 'quit' event or if the user press the\n              'ESC' key, we quit.\n          Event::Quit { .. } |\n          Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n              break 'running // We \"break\" the infinite loop.\n          },\n          _ => {}\n        }\n      }\n\n      // We set fulfill our window with red.\n      canvas.set_draw_color(Color::RGB(255, 0, 0));\n      // We draw it.\n      canvas.clear();\n      // Copy our texture into the window.\n      canvas.copy(&square_texture,\n        None,\n        // We copy it at the top-left of the window with a 32x32 size.\n        Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n        .expect(\"Couldn't copy texture into window\");\n        // We update window's display.\n        canvas.present();\n\n        // We sleep enough to get ~60 fps. If we don't call this, \n           the program will take\n        // 100% of a CPU time.\n        sleep(Duration::new(0, 1_000_000_000u32 / 60));\n      }\n    }\n```", "```rs\n    use sdl2::video::{Window, WindowContext};\n```", "```rs\n    #[derive(Clone, Copy)]\n    enum TextureColor {\n      Green,\n      Blue,\n    }\n```", "```rs\n    fn create_texture_rect<'a>(canvas: &mut Canvas<Window>,\n       texture_creator: &'a TextureCreator<WindowContext>,\n       color: TextureColor, size: u32) -> Option<Texture<'a>> {\n       // We'll want to handle failures outside of this function.\n      if let Ok(mut square_texture) =\n         texture_creator.create_texture_target(None, size, size) {\n           canvas.with_texture_canvas(&mut square_texture, |texture| {\n             match color {\n                TextureColor::Green => \n                  texture.set_draw_color(Color::RGB(0, 255, 0)),\n                TextureColor::Blue => \n                  texture.set_draw_color(Color::RGB(0, 0, 255)),\n             }\n             texture.clear();\n           }).expect(\"Failed to color a texture\");\n            Some(square_texture)\n         } else {\n             None\n           }\n       }\n```", "```rs\n    fn divide(nb: u32, divider: u32) -> Option<u32> {\n      if divider == 0 {\n        None\n      } else {\n          Some(nb / divider)\n        }\n    }  \n```", "```rs\n    let x = divide(10, 3);\n    let y = divide(10, 0);\n```", "```rs\n    let mut blue_square = create_texture_rect(&mut canvas,\n        &texture_creator,\n        TextureColor::Blue,\n        TEXTURE_SIZE).expect(\"Failed to create a texture\");\n```", "```rs\n    extern crate sdl2;\n\n    use sdl2::event::Event;\n    use sdl2::keyboard::Keycode;\n    use sdl2::pixels::Color;\n    use sdl2::rect::Rect;\n    use sdl2::render::{Canvas, Texture, TextureCreator};\n    use sdl2::video::{Window, WindowContext};\n\n    use std::thread::sleep;\n    use std::time::{Duration, SystemTime};\n\n    // To make things easier to read, we'll create a constant which\n       will be the texture's size.\n    const TEXTURE_SIZE: u32 = 32;\n\n    #[derive(Clone, Copy)]\n    enum TextureColor {\n      Green,\n      Blue,\n   }\n\n   fn create_texture_rect<'a>(canvas: &mut Canvas<Window>,\n     texture_creator: &'a TextureCreator<WindowContext>,\n     color: TextureColor,\n     size: u32) -> Option<Texture<'a>> {\n      // We'll want to handle failures outside of this function.\n    if let Ok(mut square_texture) =\n      texture_creator.create_texture_target(None, size, size) {\n        canvas.with_texture_canvas(&mut square_texture, |texture| {\n          match color {\n            // For now, TextureColor only handles two colors.\n            TextureColor::Green => texture.set_draw_color(Color::RGB(0,\n                255, 0)),\n            TextureColor::Blue => texture.set_draw_color(Color::RGB(0,\n                0, 255)),\n          }\n          texture.clear();\n        }).expect(\"Failed to color a texture\");\n        Some(square_texture)\n      } \n      else {\n       // An error occured so we return nothing and let the function\n           caller handle the error.\n       None\n      }\n    }\n\n    fn main() {\n      let sdl_context = sdl2::init().expect(\"SDL initialization  \n       failed\");\n      let video_subsystem = sdl_context.video().expect(\"Couldn't get \n          SDL video subsystem\");\n\n      // Parameters are: title, width, height\n      let window = video_subsystem.window(\"Tetris\", 800, 600)\n        .position_centered() // to put it in the middle of the screen\n        .build() // to create the window\n        .expect(\"Failed to create window\");\n\n      let mut canvas = window.into_canvas()\n        .target_texture()\n        .present_vsync() // To enable v-sync.\n        .build()\n        .expect(\"Couldn't get window's canvas\");\n\n      let texture_creator: TextureCreator<_> =  \n       canvas.texture_creator();\n\n      // We create a texture with a 32x32 size.\n      let green_square = create_texture_rect(&mut canvas,\n         &texture_creator,\n         TextureColor::Green,\n         TEXTURE_SIZE).expect(\"Failed to create a texture\");\n      let blue_square = create_texture_rect(&mut canvas,\n          &texture_creator,\n          TextureColor::Blue,\n          TEXTURE_SIZE).expect(\"Failed to create a texture\");\n\n      let timer = SystemTime::now();\n\n      // First we get the event handler:\n      let mut event_pump = sdl_context.event_pump().expect(\"Failed\n         to get SDL event pump\");\n\n      // Then we create an infinite loop to loop over events:\n      'running: loop {\n        for event in event_pump.poll_iter() {\n          match event {\n             // If we receive a 'quit' event or if the user press the\n                    'ESC' key, we quit.\n             Event::Quit { .. } |\n             Event::KeyDown { keycode: Some(Keycode::Escape), .. } => {\n                break 'running // We \"break\" the infinite loop.\n             },\n             _ => {}\n          }\n        }\n\n        // We fill our window with red.\n        canvas.set_draw_color(Color::RGB(255, 0, 0));\n        // We draw it.\n        canvas.clear();\n\n        // The rectangle switch happens here:\n        let display_green = match timer.elapsed() {\n            Ok(elapsed) => elapsed.as_secs() % 2 == 0,\n            Err(_) => {\n                // In case of error, we do nothing...\n                true\n            }\n        };\n        let square_texture = if display_green {\n            &green_square\n        } else {\n            &blue_square\n        };\n        // Copy our texture into the window.\n        canvas.copy(square_texture,\n           None,\n            // We copy it at the top-left of the window with a 32x32  \n               size.\n            Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n            .expect(\"Couldn't copy texture into window\");\n           // We update window's display.\n           canvas.present();\n\n        // We sleep enough to get ~60 fps. If we don't call this, \n            the program will take\n        // 100% of a CPU time.\n        sleep(Duration::new(0, 1_000_000_000u32 / 60));\n      }\n    }\n```", "```rs\n$ brew install SDL2_image\n```", "```rs\n $ sudo apt-get install libsdl2-image-2.0-0-dev\n```", "```rs\n $ sudo dnf install SDL2_image-devel\n```", "```rs\n $ yum install SDL2_image-devel\n```", "```rs\n    [features]\n    default = [\"sdl2/image\"]\n```", "```rs\n    [features]\n    network = []\n    default = [\"network\"]\n```", "```rs\n    [features]\n    network_v1 = []\n    network_v2 = [\"network_v1\"]\n    network_v3 = [\"network_v2\"]\n    v1 = [\"network_v1\"]\n    v2 = [\"v1\", \"network_v2\"]\n    v3 = [\"v2\", \"network_v3\"]\n```", "```rs\n    use sdl2::image::{LoadTexture, INIT_PNG, INIT_JPG};\n```", "```rs\n    sdl2::image::init(INIT_PNG | INIT_JPG).expect(\"Couldn't initialize\n         image context\");\n```", "```rs\n    let image_texture =  \n     texture_creator.load_texture(\"assets/my_image.png\")\n         .expect(\"Couldn't load image\");\n```", "```rs\n    canvas.copy(&Image_texture, None, None).expect(\"Render failed\");\n```", "```rs\n|- your_project/\n    |\n    |- Cargo.toml\n    |- src/\n    |   |\n    |   |- main.rs\n    |- assets/\n        |\n        |- my_image.png\n```", "```rs\n    extern crate sdl2;\n    use sdl2::pixels::Color;\n    use sdl2::event::Event;\n    use sdl2::keyboard::Keycode;\n    use sdl2::render::TextureCreator;\n    use sdl2::image::{LoadTexture, INIT_PNG, INIT_JPG};\n    use std::time::Duration;\n\n    pub fn main() {\n      let sdl_context = sdl2::init().expect(\"SDL initialization \n       failed\");\n      let video_subsystem = sdl_context.video().expect(\"Couldn't \n         get SDL video subsystem\");\n\n      sdl2::image::init(INIT_PNG | INIT_JPG).expect(\"Couldn't  \n      initialize\n        image context\");\n\n      let window = video_subsystem.window(\"rust-sdl2 image demo\", 800,  \n        600)\n        .position_centered()\n        .opengl()\n        .build()\n        .expect(\"Failed to create window\");\n\n      let mut canvas = window.into_canvas().build().expect(\"Failed to \n        convert window into canvas\");\n\n      let texture_creator: TextureCreator<_> = \n       canvas.texture_creator();\n      let image_texture = \n        texture_creator.load_texture(\"assets/my_image.png\")\n         .expect(\"Couldn't load image\");\n\n      let mut event_pump = sdl_context.event_pump().expect(\"Failed to\n         get SDL event pump\");\n\n     'running: loop {\n        for event in event_pump.poll_iter() {\n            match event {\n                Event::Quit { .. } |\n                Event::KeyDown { keycode: Some(Keycode::Escape), .. } \n             => {\n                    break 'running\n                },\n                _ => {}\n            }\n        }\n        canvas.set_draw_color(Color::RGB(0, 0, 0));\n        canvas.clear();\n        canvas.copy(&image_texture, None, None).expect(\"Render \n         failed\");\n        canvas.present();\n        ::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n     }\n   }\n```", "```rs\n    use std::fs::File;\n    use std::io::{self, Write};\n\n    fn write_into_file(content: &str, file_name: &str) -> io::Result<()> {\n      let mut f = File::create(file_name)?;\n      f.write_all(content.as_bytes())\n    }\n```", "```rs\n    use std::fs::File;\n```", "```rs\n   use std::io::{self, Write};\n```", "```rs\n   fn write_into_file(content: &str, file_name: &str) -> io::Result<()> {\n```", "```rs\n    type Result<T> = Result<T, Error>;\n```", "```rs\n    let mut f = File::create(file_name)?;\n```", "```rs\n    match result {\n      Ok(value) => value,\n     Err(error) => return Err(error),\n    }\n```", "```rs\n    use std::fs::File;\n    use std::io::{self, Write};\n\n    fn write_into_file(content: &str, file_name: &str) -> \n    io::Result<()> {\n      let mut f = try!(File::create(file_name));\n      f.write_all(content.as_bytes())\n    }\n```", "```rs\n    use std::fs::File;\n    use std::io::{self, Write};\n\n   fn write_into_file(content: &str, file_name: &str) -> io::Result<()>   \n   {\n     let mut f = match File::create(file_name) {\n        Ok(value) => value,\n        Err(error) => return Err(error),\n     };\n     f.write_all(content.as_bytes())\n   }\n```", "```rs\n    f.write_all(content.as_bytes())\n```", "```rs\n    use std::fs::File;\n    use std::io::{self, Read};\n\n    fn read_from_file(file_name: &str) -> io::Result<String> {\n      let mut f = File::open(file_name)?;\n      let mut content = String::new();\n      f.read_to_string(&mut content)?;\n      Ok(content)\n    }\n```", "```rs\n    fn read_from_file(file_name: &str) -> io::Result<String> {\n```", "```rs\n    let mut f = File::open(file_name)?;\n    let mut content = String::new();\n    f.read_to_string(&mut content)?;\n```", "```rs\n    Ok(content)\n```", "```rs\n    fn slice_to_string(slice: &[u32]) -> String {\n      slice.iter().map(|highscore| highscore.to_string()).\n        collect::<Vec<String>>().join(\" \")\n    }\n\n    fn save_highscores_and_lines(highscores: &[u32], \n       number_of_lines: &[u32]) -> bool {\n      let s_highscores = slice_to_string(highscores);\n      let s_number_of_lines = slice_to_string(number_of_lines);\n      write_into_file(format!(\"{}\\n{}\\n\", s_highscores, \n         s_number_of_lines)).is_ok()\n    }\n```", "```rs\n    slice.iter().map(|highscore| highscore.to_string()).\n      collect::<Vec<String>>().join(\" \")\n```", "```rs\n    slice.iter()\n       .map(|highscore| highscore.to_string())\n       .collect::<Vec<String>>()\n       .join(\" \")\n```", "```rs\n     slice.iter()\n```", "```rs\n    .map(|highscore| highscore.to_string())\n```", "```rs\n    .collect::<Vec<String>>()\n```", "```rs\n    .join(\" \")\n```", "```rs\n    fn save_highscores_and_lines(highscores: &[u32], \n        number_of_lines: &[u32]) -> bool {\n      let s_highscores = slice_to_string(highscores);\n      let s_number_of_lines = slice_to_string(number_of_lines);\n      write_into_file(format!(\"{}\\n{}\\n\", s_highscores, \n         s_number_of_lines), \"scores.txt\").is_ok()\n    }\n```", "```rs\nfn line_to_slice(line: &str) -> Vec<u32> {\n    line.split(\" \").filter_map(|nb| nb.parse::<u32>().ok()).collect()\n}\n\nfn load_highscores_and_lines() -> Option<(Vec<u32>, Vec<u32>)> {\n    if let Ok(content) = read_from_file(\"scores.txt\") {\n        let mut lines = content.splitn(2, \"\\n\").map(|line| \n           line_to_slice(line)).collect::<Vec<_>>();\n        if lines.len() == 2 {\n            let (number_lines, highscores) = (lines.pop().unwrap(), \n             lines.pop().unwrap());\n            Some((highscores, number_lines))\n        } else {\n         None\n        }\n    } else {\n        None\n    }\n}\n```", "```rs\nfn line_to_slice(line: &str) -> Vec<u32> {\n```", "```rs\n    line.split(\" \").filter_map(|nb| nb.parse::<u32>().ok()).collect()\n```", "```rs\n    line.split(\" \")\n      .filter_map(|nb| nb.parse::<u32>().ok())\n      .collect()\n```", "```rs\n     line.split(\" \")\n```", "```rs\n    .filter_map(|nb| nb.parse::<u32>().ok())\n```", "```rs\n    nb.parse::<u32>().ok()\n```", "```rs\n    .collect()\n```", "```rs\n    fn load_highscores_and_lines() -> Option<(Vec<u32>, Vec<u32>)> {\n```", "```rs\n    if let Ok(content) = read_from_file(\"scores.txt\") {\n```", "```rs\n    let mut lines = content.splitn(2, \"\\n\").map(|line| \n       line_to_slice(line)).collect::<Vec<_>>();\n```", "```rs\n    let mut lines = content.splitn(2, \"\\n\")\n         .map(|line| line_to_slice(line))\n         .collect::<Vec<_>>();\n```", "```rs\n    content.splitn(2, \"\\n\")\n```", "```rs\n    .map(|line| line_to_slice(line))\n```", "```rs\n    .collect::<Vec<_>>();\n```", "```rs\n    if lines.len() == 2 {\n```", "```rs\n    let (number_lines, highscores) = (lines.pop().unwrap(), \n        lines.pop().unwrap());\n```", "```rs\n    Some((highscores, number_lines))\n```"]