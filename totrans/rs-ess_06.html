<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Pointers and Memory Safety</h1></div></div></div><p>This is probably the most important chapter of this book. Here, we describe in detail the unique way in which the Rust borrow-checker mechanism detects problems at compile time to prevent memory safety errors. This is fundamental to everything else in Rust as the language is focused on these concepts of ownership and borrowing. Some of the material has already been discussed earlier, but here, we will strengthen that foundation. We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Pointers and references</li><li class="listitem">Ownership and borrowing</li><li class="listitem">Boxes</li><li class="listitem">Reference counting</li></ul></div><p>Trying out and experimenting with the examples is the key here as there are many concepts that you may not be familiar with yet.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Pointers and references </h1></div></div></div><p>The <em>The stack and the heap</em> section<a id="id192" class="indexterm"/> of <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <em>Using Variables and Types</em> gave us the basic information<a id="id193" class="indexterm"/> that we needed to understand memory layout of Rust. Let's recap the information and fill in some gaps.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>The stack and the heap</h2></div></div></div><p>When a program starts, by <a id="id194" class="indexterm"/>default a 2 MB chunk of memory called the stack is granted to it. The <a id="id195" class="indexterm"/>program will use its stack to store all its local variables and function parameters; for example, an <code class="literal">i32</code> variable takes 4 bytes of the stack. When our program calls a function, a new stack frame is allocated to it. Through this mechanism, the stack knows the order in which the functions are called so that the functions return correctly to the calling code and possibly return values as well.</p><p>Dynamically sized types, such as strings or arrays, can't be stored on the stack. For these values, a program can request memory space on its heap, so this is a potentially much bigger piece of memory than the stack.</p><div><h3 class="title"><a id="tip05"/>Tip</h3><p>When possible, stack allocation is preferred over heap allocation because accessing the stack is a lot more efficient.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec01"/>Lifetimes</h3></div></div></div><p>All variables in a Rust code have a lifetime. Suppose we declare an <code class="literal">n</code> variable with the let <code class="literal">n = 42u32;</code> binding. Such a value is valid from where it is declared to when it is no longer referenced, which is called the lifetime<a id="id196" class="indexterm"/> of the variable. This is illustrated in the following code snippet:</p><div><pre class="programlisting">// see code in Chapter 6/code/lifetimes.rs	
fn main() {
let n = 42u32;
let n2 = n; // a copy of the value from n to n2
life(n);
println!("{}", m);  // error: unresolved name `m`.
println!("{}", o);  // error: unresolved name `o`.
}

fn life(m: u32) -&gt; u32 {
    let o = m;
    o
}</pre></div><p>The lifetime of <code class="literal">n</code> ends when <code class="literal">main()</code> ends; in general, the start and end of a lifetime happen in the same scope. The words lifetime and scope are synonymous, but we generally use the word lifetime to refer to the extent of a reference. As in other languages, local variables or parameters declared in a function do not exist anymore after the function has finished executing; in Rust, we say that their lifetime has ended. This is the case for the <code class="literal">m</code> and <code class="literal">o</code> variables in the preceding code snippet, which are only known in the <code class="literal">life</code> function.</p><p>Likewise, the lifetime of a variable declared in a nested block is restricted to that block, like <code class="literal">phi</code> in the following example:</p><div><pre class="programlisting">{
    let phi = 1.618;
}
println!("The value of phi is {}", phi); // is error</pre></div><p>Trying to use <code class="literal">phi</code> when its lifetime is over results in an error: <code class="literal">unresolved name 'phi'</code>.</p><p>The lifetime of a value can be indicated in the code by an annotation, for example <code class="literal">'a</code>, which reads as lifetime where <code class="literal">a</code> is simply an indicator; it could also be written as <code class="literal">'b</code>, <code class="literal">'n</code>, or <code class="literal">'life</code>. It's common to see single letters being used to represent lifetimes. In the preceding example, an explicit lifetime indication was not necessary since there were no references involved. All <a id="id197" class="indexterm"/>values tagged with the same lifetime have the same maximum lifetime. We already know this notation from <code class="literal">'static</code>, which, as we saw in the <em>Global constants</em> section of <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <em>Using Variables and Types</em>, is the lifetime of things that last for the entire length of the program, so only use <code class="literal">'static</code> when you need the value that long.</p><p>In the following example, we have a <code class="literal">transform</code> function that explicitly declares the lifetime of its <code class="literal">s</code> parameter to be <code class="literal">'a</code>:</p><div><pre class="programlisting">
<strong>fn transform&lt;'a&gt;(s: &amp;'a str) { /* ... */ }</strong>
</pre></div><p>Note the <code class="literal">&lt;'a&gt;</code> indication after the name of the function. In nearly all cases, this explicit indication is not needed because the compiler is smart enough to deduce the lifetimes, so we can simply write this:</p><div><pre class="programlisting">fn transform_without_lifetime(s: &amp;str) { /* ... */ }</pre></div><p>Here is an example where even when we indicate a lifetime specifier <code class="literal">'a</code>, the compiler does not allow our code. Let's suppose that we define a <code class="literal">Magician</code> struct as follows:</p><div><pre class="programlisting">struct Magician {
  name: &amp;'static str,
  power: u32
}</pre></div><p>We will get an error message if we try to construct the following function:</p><div><pre class="programlisting">fn return_magician&lt;'a&gt;() -&gt; &amp;'a Magician {
  let mag = Magician { name: "Gandalf", power: 4625};
  &amp;mag 
}</pre></div><p>The error message is error: <code class="literal">'mag' does not live long enough</code>. Why does this happen? The lifetime of the <code class="literal">mag</code> value ends when the <code class="literal">return_magician</code> function ends, but this function nevertheless tries to return a reference to the <code class="literal">Magician</code> value, which no longer exists. Such an invalid reference is known as a <em>dangling pointer</em>. This is a situation that would clearly lead to errors and cannot be allowed.</p><p>The lifespan of a pointer must always be shorter than or equal to than that of the value which it points to, thus avoiding dangling (or null) references.</p><p>In some situations, the decision to determine whether the lifetime of an object has ended is complicated, but in almost all cases, the borrow checker does this for us automatically by inserting lifetime annotations in the intermediate code; so, we don't have to do it. This is known as <em>lifetime elision</em>.</p><p>For example, when working with structs, we can safely assume that the struct instance and its fields have the same lifetime. Only when the borrow checker is not completely sure, we need to indicate the lifetime explicitly; however, this happens only on rare occasions, mostly when references are returned.</p><p>One example is when we have a struct with fields that are references. The following code snippet explains this:</p><div><pre class="programlisting">struct MagicNumbers {
  magn1: &amp;u32,
  magn2: &amp;u32
}</pre></div><p>This won't compile and will give us the following error: <code class="literal">missing lifetime specifier [E0106]</code>.</p><p>Therefore, we have to change the code as follows:</p><div><pre class="programlisting">struct MagicNumbers&lt;'a&gt; {
  magn1: &amp;'a u32,
  magn2: &amp;'a u32
}</pre></div><p>This specifies that<a id="id198" class="indexterm"/> both the struct and the fields have the lifetime as <code class="literal">'a</code>.</p><p>Perform the following exercise:</p><p>Explain why the following code won't compile:</p><div><pre class="programlisting">// see code in Chapter 6/exercises/dangling_pointer.rs:
fn main() {
    let m: &amp;u32 = { 
        let n = &amp;5u32; 
        &amp;*n
    }; 
    let o = *m;
}</pre></div><p>Answer the same question for this code snippet as well:</p><div><pre class="programlisting">let mut x = &amp;3;
{
  let mut y = 4;
  x = &amp;y; 
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec02"/>Copying values and the Copy trait</h3></div></div></div><p>In the code that we discussed in <a id="id199" class="indexterm"/>earlier section (see <code class="literal">Chapter 6/code/lifetimes.rs</code>) the value <a id="id200" class="indexterm"/>of <code class="literal">n</code> is copied to a new location each time <code class="literal">n</code> is assigned via a new <code class="literal">let</code> binding or passed as a function argument:</p><div><pre class="programlisting">let n = 42u32;
// no move, only a copy of the value:
let n2 = n;
life(n);
fn life(m: u32) -&gt; u32 {
    let o = m;
    o
}</pre></div><p>At a certain moment in the program's execution, we would have four memory locations that contain the copied value <code class="literal">42</code>, which we can visualize as follows:</p><div><img src="img/image00180.jpeg" alt="Copying values and the Copy trait"/></div><p style="clear:both; height: 1em;"> </p><p>Each value disappears (and its memory location is freed) when the lifetime of its corresponding variable ends, which happens at the end of the function or code block in which it is defined. Nothing much can go wrong with this <em>Copy</em> behavior, in which the value (its bits) is simply copied to another location on the stack. Many built-in types, such as <code class="literal">u32</code> and <code class="literal">i64</code>, work similar to this, and this copy-value behavior is defined in Rust as the <code class="literal">Copy</code> trait, which <code class="literal">u32</code> and <code class="literal">i64</code> implement.</p><p>You can also implement the <code class="literal">Copy</code> trait for your own type, provided all of its fields or items implement <code class="literal">Copy</code>. For example, the <code class="literal">MagicNumber</code> struct, which contains a field of the <code class="literal">u64</code> type, can have the same behavior. There are two ways to indicate this:</p><div><ul class="itemizedlist"><li class="listitem">One way is to explicitly name the <code class="literal">Copy</code> implementation as follows:<div><pre class="programlisting">struct MagicNumber {
    value: u64
}
impl Copy for MagicNumber {}</pre></div></li><li class="listitem">Otherwise, we can annotate it with a <code class="literal">Copy</code> attribute:<div><pre class="programlisting">#[derive(Copy)]
struct MagicNumber {
    value: u64
}</pre></div></li></ul></div><p>This now means that <a id="id201" class="indexterm"/>we can create two different copies, <code class="literal">mag</code> and <code class="literal">mag2</code>, of a <code class="literal">MagicNumber</code> <a id="id202" class="indexterm"/>by assignment:</p><div><pre class="programlisting">let mag = MagicNumber {value: 42};
let mag2 = mag;</pre></div><p>They are copies because they have different memory addresses (the values shown will differ at each execution):</p><div><pre class="programlisting">println!("{:?}", &amp;mag as *const MagicNumber); // address is 0x23fa88
println!("{:?}", &amp;mag2 as *const MagicNumber); // address is 0x23fa80</pre></div><p>The <code class="literal">(*const</code> function is a so-called raw pointer; refer to <a class="link" title="Chapter 9. Programming at the Boundaries" href="part0069.xhtml#aid-21PMQ1">Chapter 9</a>, <em>Programming at the Boundaries</em> for more details about it). A type that does not implement the <code class="literal">Copy</code> trait is called non-copyable.</p><p>Another way to accomplish this is by letting <code class="literal">MagicNumber</code> implement the <code class="literal">Clone</code> trait:</p><div><pre class="programlisting">#[derive(Clone)]
struct MagicNumber {
    value: u64
}</pre></div><p>Then, we can use <code class="literal">clone() mag</code> into a different object called <code class="literal">mag3</code>, effectively making a copy as follows:</p><div><pre class="programlisting">let mag3 = mag.clone();
println!("{:?}", &amp;mag3 as *const MagicNumber); // address is 0x23fa78</pre></div><p>
<code class="literal">mag3</code>  is a new pointer referencing a new copy of the value of <code class="literal">mag</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec03"/>Pointers</h3></div></div></div><p>The <code class="literal">n</code> variable in <a id="id203" class="indexterm"/>the <code class="literal">let n = 42i32;</code> binding is stored on the stack. Values on the stack or the heap can be accessed by pointers. A pointer is a variable that contains the memory address of some value. To access the value it points to, dereference the pointer with <code class="literal">*</code>. This happens automatically in simple cases such as in <code class="literal">println!</code> or when a pointer is given as a parameter to a method. For example, in the following code, <code class="literal">m</code> is a pointer containing the address of <code class="literal">n</code>:</p><div><pre class="programlisting">// see code in Chapter 6/code/references.rs:
<strong>let m = &amp;n;</strong>
<strong>println!("The address of n is {:p}", m);</strong>
println!("The value of n is {}", *m);
println!("The value of n is {}", m);</pre></div><p>This prints out the following output, which differs for each program run:</p><div><pre class="programlisting">The address of n is 0x23fb34 
The value of n is 42
The value of n is 42</pre></div><p>So, why do we need pointers? When we work with dynamically allocated values, such as a <code class="literal">String</code>, that can change in size, the memory address of that value is not known at compile time. Due to this, the memory address needs to be calculated at runtime. So, to be able to keep track of it, we need a pointer for it whose value will change when the location of <code class="literal">String</code> in memory changes.</p><p>The compiler automatically takes care of the memory allocation of pointers and the freeing up of memory when their lifetime ends. You don't have to do this yourself like in C/C++, where you could mess up by freeing memory at the wrong moment or at multiple times.</p><p>The incorrect use of pointers in languages such as C++ leads to all kinds of problems.</p><p>However, Rust enforces a strong set of rules at compile time called the borrow checker, so we are protected against them. We have already seen them in action, but from here onwards, we'll explain the logic behind their rules.</p><p>Pointers can also be <a id="id204" class="indexterm"/>passed as arguments to functions, and they can be returned from functions, but the compiler severely restricts their usage.</p><p>When passing a pointer value to a function, it is always better to use the reference-dereference <code class="literal">&amp;*</code> mechanism, as shown in this example:</p><div><pre class="programlisting">  let q = &amp;42;
  println!("{}", square(q)); // 1764
fn square(k: &amp;i32) -&gt; i32 {
    *k * *k
}</pre></div><p>Rust has many kinds of pointers, which we will explore in this chapter. All pointers (except raw pointers, which are discussed in <a class="link" title="Chapter 9. Programming at the Boundaries" href="part0069.xhtml#aid-21PMQ1">Chapter 9</a>, <em>Programming at the Boundaries</em>) are guaranteed to be non-null (that is, they point to a valid location in the memory) and are automatically cleaned up.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec04"/>References</h3></div></div></div><p>In our previous example, <code class="literal">m</code>, which had the <code class="literal">&amp;n</code> value, is the<a id="id205" class="indexterm"/> simplest form of pointer, and it is called a reference (or borrowed pointer); <code class="literal">m</code> is a reference to the stack-allocated <code class="literal">n</code> variable and has the <code class="literal">&amp;i32</code> type because it points to a value of the <code class="literal">i32</code> type.</p><div><h3 class="title"><a id="note06"/>Note</h3><p>In general, when <code class="literal">n</code> is a value of the <code class="literal">T</code> type, then the <code class="literal">&amp;n</code> reference is of the <code class="literal">&amp;T</code> type.</p></div><p>Here, <code class="literal">n</code> is immutable, so <code class="literal">m</code> is also immutable; for example, if you try to change the value of <code class="literal">n</code> through <code class="literal">m</code> with <code class="literal">*m = 7;</code> you will get a <code class="literal">cannot assign to immutable borrowed content '*m'</code> error. Contrary to C, Rust does not let you change an immutable variable via its pointer.</p><p>Since there is no danger of changing the value of <code class="literal">n</code> through a reference, multiple references to an immutable value are allowed; they can only be used to read the value, for example:</p><div><pre class="programlisting">let o = &amp;n;
println!("The address of n is {:p}", o);
println!("The value of n is {}", *o); </pre></div><p>It prints out as described earlier:</p><div><pre class="programlisting">The address of n is 0x23fb34
The value of n is 42</pre></div><p>We could represent this situation in the memory as follows:</p><div><img src="img/image00181.jpeg" alt="References"/></div><p style="clear:both; height: 1em;"> </p><p>It is clear that working with pointers such as this or in much more complex situations necessitates much stricter rules than the <code class="literal">Copy</code> behavior. For example, the memory can only be freed when there are no variables or pointers associated with it anymore. And when the value is mutable, can it be changed through any of its pointers? These stricter rules, described by the ownership and borrowing system discussed in the next section, are enforced by the compiler.</p><p>Mutable references do exist, and <a id="id206" class="indexterm"/>they are declared as <code class="literal">let m = &amp;mut n</code>. However, <code class="literal">n</code> also has to be a mutable value. When <code class="literal">n</code> is immutable, the compiler rejects the <code class="literal">m</code> mutable reference binding with the error, <code class="literal">cannot borrow immutable local variable 'n' as mutable</code>. This makes sense since immutable variables cannot be changed even when you know their memory location.</p><p>To reiterate, in order to change a value through a reference, both the variable and its reference have to be mutable, as shown in the following code snippet:</p><div><pre class="programlisting">
<strong>  let mut u = 3.14f64;</strong>
<strong>  let v = &amp;mut u;</strong>
  *v = 3.15;
  println!("The value of u is now {}", *v);</pre></div><p>This will print: <code class="literal">The value of u is now 3.15</code>.</p><p>Now, the value at the memory location of <code class="literal">u</code> is changed to <code class="literal">3.15</code>.</p><p>However, note that we now cannot change (or even print) that value anymore by using the <code class="literal">u: u = u * 2.0;</code> variable gives us a compiler error: <code class="literal">cannot assign to 'u' because it is borrowed</code> (we explain why this is so in the <em>Ownership and Borrowing</em> section of this chapter). We say that borrowing a variable (by making a reference to it) freezes that variable; the original <code class="literal">u</code> variable is frozen (and no longer usable) until the reference goes out of scope.</p><p>In addition, we can only have one mutable reference: <code class="literal">let w = &amp;mut u;</code> which results in the error: <code class="literal">cannot borrow 'u' as mutable more than once at a time</code>. The compiler even adds the following note to the previous code line with: <code class="literal">let v = &amp;mut u;</code> note: <code class="literal">previous borrow of 'u' occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `u` until the borrow ends</code>. This is logical; the compiler is (rightfully) concerned that a change to the value of <code class="literal">u</code> through one reference might change its memory location because <code class="literal">u</code> might change in size, so it will not fit anymore within its previous location and would have to be relocated to another address. This would render all other references to <code class="literal">u</code> as invalid, and even dangerous, because through them we might inadvertently change another variable that has taken up the previous location of <code class="literal">u</code>!</p><p>A mutable value can <a id="id207" class="indexterm"/>also be changed by passing its address as a mutable reference to a function, as shown in this example:</p><div><pre class="programlisting">let mut m = 7;
add_three_to_magic(&amp;mut m);
println!("{}", m);  // prints out 10</pre></div><p>With the function <code class="literal">add_three_to_magic</code> declared as follows:</p><div><pre class="programlisting">
<strong>fn add_three_to_magic(num: &amp;mut i32) {</strong>
    *num += 3;  // value is changed in place through +=
}</pre></div><div><h3 class="title"><a id="note07"/>Note</h3><p>To summarize, when <code class="literal">n</code> is a mutable value of the <code class="literal">T</code> type, then only one mutable reference to it (of the <code class="literal">&amp;mut T</code> type) can exist at any time. Through this reference, the value can be changed.</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec05"/>Using ref in a match</h3></div></div></div><p>If you want to get a <a id="id208" class="indexterm"/>reference to a matched variable inside a <code class="literal">match</code> function, use the <code class="literal">ref</code> keyword, as <a id="id209" class="indexterm"/>shown in the <a id="id210" class="indexterm"/>following example:</p><div><pre class="programlisting">// see code in Chapter 6/code/ref.rs	
fn main() {
  let n = 42;
  match n {
<strong>      ref r =&gt; println!("Got a reference to {}", r),</strong>
  }
  let mut m = 42;
  match m {
<strong>      ref mut mr =&gt; {</strong>
        println!("Got a mutable reference to {}", mr);
        *mr = 43;
      },
  }
  println!("m has changed to {}!", m);
}</pre></div><p>Which prints out:</p><div><pre class="programlisting">Got a reference to 42
Got a mutable reference to 42
m has changed to 43!</pre></div><p>The <code class="literal">r</code> variable inside the <code class="literal">match</code> has the <code class="literal">&amp;i32</code> type. In other words, the <code class="literal">ref</code> keyword creates a reference for use in the pattern. If you need a mutable reference, use <code class="literal">ref mut</code>.</p><p>We can also use <code class="literal">ref</code> to get a reference to a field of a struct or tuple in a destructuring via a <code class="literal">let</code> binding. For example, while reusing the <code class="literal">Magician</code> struct, we can extract the name of <code class="literal">mag</code> by using <code class="literal">ref</code> and then return it from the match:</p><div><pre class="programlisting">let mag = Magician { name: "Gandalf", power: 4625};
let name = {
    let Magician { name: ref ref_to_name, power: _ } = mag;
    *ref_to_name
};
println!("The magician's name is {}", name);</pre></div><p>Which prints: <code class="literal">The magician's name is Gandalf</code>.</p><p>References are the <a id="id211" class="indexterm"/>most common<a id="id212" class="indexterm"/> pointer type and have the most possibilities; other <a id="id213" class="indexterm"/>pointer types should only be applied in very specific use cases.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Ownership and borrowing</h1></div></div></div><p>In the previous section, the word <em>borrowed</em> was mentioned in most error messages. What's this all about? What is the logic behind this borrow-checker mechanism?</p><p>Every program, whatever<a id="id214" class="indexterm"/> it does, whether reading data from a database or making a<a id="id215" class="indexterm"/> computation, is concerned with handling resources. The most common resource in a program is the memory space allocated to its variables. Other resources could be files, network connections, database connections, and so on. Every resource is given a name when we make a binding to it with <code class="literal">let</code>; in Rust's language, we say that the resource gets an owner, for example, in the following code snippet, <code class="literal">klaatu</code> owns a piece of memory that is taken up by the <code class="literal">Alien</code> struct instance:</p><div><pre class="programlisting">// see code in Chapter 6/code/ownership1.rs
struct Alien {
  planet: String,
  n_tentacles: u32
}

fn main() {
  let mut klaatu = Alien{ planet: "Venus".to_string(),
  n_tentacles: 15 };
}</pre></div><p>Only the owner can change the object it points to, and there can only be one owner at a time, because the owner is responsible for freeing the object's resources. When a reference goes out of scope, it will not deallocate the underlying memory, because the reference is not the owner of the value. This makes sense; if an object could have many owners, its resources could be freed more than once, which would lead to problems. When the owner's lifetime has passed, the compiler frees the memory automatically.</p><p>The owner can move the ownership of the object to another variable as follows: </p><div><pre class="programlisting">let kl2 = klaatu;</pre></div><p>Here, the ownership has<a id="id216" class="indexterm"/> moved from <code class="literal">klaatu</code> to <code class="literal">kl2</code>, but no data is actually copied. The original owner <code class="literal">klaatu</code> cannot be used anymore:</p><div><pre class="programlisting">println!("{}", klaatu.planet); </pre></div><p>It gives the compiler error as: <code class="literal">use of moved value 'klaatu.planet'</code>.</p><p>On the other hand, we can borrow the resource by making a (in this example mutable) reference <code class="literal">kl2</code> to <code class="literal">klaatu</code> with <code class="literal">let kl2 = &amp;mut klaatu;</code>. A borrow is a temporary reference that passes the address of the data structure through <code class="literal">&amp;</code>.</p><p>Now, <code class="literal">kl2</code> can change the object, for instance, when our alien loses a tentacle in a battle:</p><div><pre class="programlisting">  kl2.n_tentacles = 14;
  println!("{} - {}", kl2.planet, kl2.n_tentacles);</pre></div><p>This prints out: <code class="literal">Venus – 14</code>.</p><p>However, we will get an error message if we try to change the alien's planet through the following code:</p><div><pre class="programlisting">  klaatu.planet = "Pluto".to_string();</pre></div><p>The error message is <a id="id217" class="indexterm"/>
<code class="literal">error: </code>
<code class="literal">cannot assign to `klaatu.planet` because it is borrowed;</code> it was indeed borrowed by <code class="literal">kl2</code>. Similar to everyday life, while an object is borrowed, the owner does not have access to it as it is no longer in their possession. In order to change the resource, <code class="literal">klaatu</code> needs to own it, without the resource being borrowed at the same time.</p><p>Rust even explains this to us with the note that it adds: <code class="literal">borrow of 'klaatu.planet' occurs here ownership.rs:8   let kl2 = &amp;mut klaatu;</code>.</p><p>Since <code class="literal">kl2</code> borrows the resource, Rust also even forbids us to access the instance with its former name, <code class="literal">klaatu</code>:</p><div><pre class="programlisting">  println!("{} - {}", klaatu.planet, klaatu.n_tentacles);</pre></div><p>The compiler then throws this error message: <code class="literal">error: cannot borrow 'klaatu.planet' as immutable because 'klaatu' is also borrowed as mutable</code>.</p><p>When a resource is moved or borrowed, the previous owner can no longer use it. This prevents the memory problem that is known as a dangling pointer, which is the use of a pointer that points to an invalid memory location.</p><p>But here is a revelation: if we isolate the borrowing by <code class="literal">kl2</code> in its own block, as follows:</p><div><pre class="programlisting">// see code in Chapter 6/code/ownership2.rs
fn main() {
  let mut klaatu = Alien{ planet: "Venus".to_string(), n_tentacles: 15 };
  {
    let kl2 = &amp;mut klaatu;
    kl2).n_tentacles = 14;
    println!("{} - {}", kl2.planet, kl2.n_tentacles); 
// prints: Venus - 14
  }
}</pre></div><p>The former problems <a id="id218" class="indexterm"/>have disappeared! After the block, we can now do for example:</p><div><pre class="programlisting">  println!("{} - {}", klaatu.planet, klaatu.n_tentacles);  klaatu.planet = "Pluto".to_string();
  println!("{} - {}", klaatu.planet, klaatu.n_tentacles); </pre></div><p>This prints:</p><div><pre class="programlisting">Venus – 10
Pluto – 10.</pre></div><p>Why does this happen? Because <a id="id219" class="indexterm"/>after the closing <code class="literal">}</code> of the code block in which <code class="literal">kl2</code> was bound, its lifetime ended. The borrowing was over (a borrow has to end sometime) and <code class="literal">klaatu</code> reclaimed full ownership, and thus the right to change. When the compiler detects that the lifetime of the original owner, <code class="literal">klaatu</code> , has eventually ended, the memory occupied by the struct instance is automatically freed.</p><p>In fact, this is a general rule in Rust; whenever an object goes out of scope and it doesn't have an owner anymore, its destructor is automatically called and the resources owned by it are freed so that there can never be any memory (or other resource) leaks. In other words, Rust obeys the<a id="id220" class="indexterm"/> <strong>Resource Acquisition Is Initialization</strong> (<strong>RAII</strong>) rule. For more information, go to <a class="ulink" href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization</a>.</p><p>As we experimented in the <em>References</em> section, a resource can be immutably borrowed many times, but while it is immutably borrowed, the original data can't be mutably borrowed.</p><p>Another way to move a resource (and transfer the ownership) is to pass it as an argument to a function; try this out in the following exercise:</p><div><ul class="itemizedlist"><li class="listitem">Examine the situation (<code class="literal">let kl2 = &amp;klaatu;</code>) when <code class="literal">kl2</code> is not a mutable reference. Can you change the instance through <code class="literal">kl2</code>? Can you change the instance through <code class="literal">klaatu</code>? Explain the error with what you know about ownership and borrowing (refer to <code class="literal">Chapter 6/exercises/ownership3.rs</code>).</li><li class="listitem">What will happen in the previous program if we do <code class="literal">let klaatuc = klaatu;</code> before we define the <code class="literal">let kl2 = &amp;klaatu;</code> binding?</li><li class="listitem">Examine if you <a id="id221" class="indexterm"/>can change the mutability of a resource by moving from an <a id="id222" class="indexterm"/>immutable owner to a mutable owner.</li><li class="listitem">For our <code class="literal">Alien</code> struct, write a <code class="literal">grow_a_tentacle</code> method that increases the number of tentacles by one (refer to <code class="literal">Chapter 6/exercises/grow_a_tentacle.rs</code>).</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Boxes</h1></div></div></div><p>Another pointer type in Rust is called the boxed pointer, <code class="literal">Box&lt;T&gt;</code>, which can be defined for a value of a generic <code class="literal">T</code> type. A <a id="id223" class="indexterm"/>box is a non-copyable value. This pointer type is used to allocate objects on the heap. For example, here we allocate an <code class="literal">Alien</code> value on the heap by using the following code:</p><div><pre class="programlisting">// see code in Chapter 6/code/boxes1.rs	
<strong>let mut a1 = Box::new(Alien{ planet: "Mars".to_string(), n_tentacles: 4 });</strong>
println!("{}", a1.n_tentacles); // 4</pre></div><p>The <code class="literal">a1</code> variable is the only owner of this memory resource that may read from and write to it.</p><p>We can make a reference to the value pointed to by the box pointer, and if both the original box and this new reference are mutable, we can change the object through this reference:</p><div><pre class="programlisting">let a2 = &amp;mut a1;
println!("{}", a2.planet ); // Mars
a2.n_tentacles = 5;</pre></div><p>After such a borrowing, the usual ownership rules as specified earlier hold, since <code class="literal">a1</code> no longer has access, not even for reading:</p><div><pre class="programlisting">// error: cannot borrow `a1.n_tentacles` as immutable because `a1` is also borrowed as mutable
// println!("{}", a1.n_tentacles); // is error!
// error: cannot assign to `a1.planet` because it is borrowed
a1.planet = "Pluto".to_string();  // is error!</pre></div><p>We can also use this mechanism to put simple values on the heap as follows:</p><div><pre class="programlisting">  let n = Box::new(42);</pre></div><p>As always, <code class="literal">n</code> points by default to an immutable value and any attempt to change this with:</p><div><pre class="programlisting">      *n = 67; </pre></div><p>Provokes the error: <code class="literal">cannot assign to immutable 'Box' content '*n'</code>.</p><p>Another reference can also point to the dereferenced <code class="literal">Box</code> value:</p><div><pre class="programlisting">
<strong>let q = &amp;*n;</strong>
println!("{}", q); // 42</pre></div><p>In the following example, we again see a boxed value pointed to by <code class="literal">n</code>, but the ownership of the value is now given to a mutable pointer, <code class="literal">m</code>:</p><div><pre class="programlisting">// see code in Chapter 6/code/boxes2.rs	
let n = Box::new(42);
let mut m = n;
*m = 67;
// println!("{}", n); // error: use of moved value: `n`
println!("{}", m); // 67</pre></div><p>By dereferencing <code class="literal">m</code> and <a id="id224" class="indexterm"/>assigning a new value to <code class="literal">m</code>, this value is entered into the memory location that was originally pointed to by <code class="literal">n</code>. Of course, <code class="literal">n</code> cannot be used anymore; we get the error: <code class="literal">use of moved value: 'n' message because n is no longer the owner of the value</code>.</p><p>Here is another example where the ownership has clearly has moved from <code class="literal">a1</code> to <code class="literal">a2</code>:</p><div><pre class="programlisting">let mut a1 = Box::new(Alien{ planet: "Mars".to_string(), n_tentacles: 4 });
let a2 = a1;
println!("{}", a2.n_tentacles); // 4</pre></div><p>No data being copied here, except the address of the struct value. After the move, <code class="literal">a1</code> can no longer be used to access the data, and <code class="literal">a2</code> is responsible for freeing the memory.</p><p>If <code class="literal">a2</code> is given as an argument to a function such as <code class="literal">use_alien</code> in the following code snippet, <code class="literal">a2</code> also gives up the ownership, which is then transferred to the function:</p><div><pre class="programlisting">use_alien(a2);
// Following line gives the error: use of moved value: `a2.n_tentacles`
// println!("{}", a2.n_tentacles); 
} // end of main() function

fn use_alien(a: Box&lt;Alien&gt;) {
  println!("An alien from planet {} is freed after the closing brace", a.planet);
}</pre></div><p>This prints out: <code class="literal">An alien from planet Mars is freed</code>.</p><p>Indeed, when <code class="literal">use_alien()</code> has finished executing, the memory allocation for that value is freed. However, in general, you must always let your function take a simple reference as a parameter (in a similar way to the <code class="literal">square</code> function explained earlier), rather than take a parameter of the <code class="literal">Box</code> type. We could improve our example by calling a <code class="literal">use_alien2</code> function as follows:</p><div><pre class="programlisting">fn use_alien2(a: &amp;Alien) {
  println!("An alien from planet {} is freed", a.planet);
}</pre></div><p>And calling it with: <code class="literal">use_alien2(&amp;*a2);</code>.</p><p>Sometimes, your program may need to manipulate a recursive data structure that refers to itself, as shown in the following struct:</p><div><pre class="programlisting">struct Recurs {
    list: Vec&lt;u8&gt;,
    rec_list: Option&lt;Box&lt;Recurs&gt;&gt;
}</pre></div><p>This represents a list <a id="id225" class="indexterm"/>of lists of bytes. The <code class="literal">rec_list</code> function is either a <code class="literal">Some&lt;Box&lt;Recurs&gt;&gt;</code> function containing a <code class="literal">Box</code> pointer to another list or a <code class="literal">None</code> value, which means that the list of lists ends there. Since the number of items in this list (and thus its size) is only known at runtime such structures must be always constructed as a <code class="literal">Box</code> type. For other use cases, you must prefer references over Boxes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Reference counting</h1></div></div></div><p>Sometimes, you need several references <a id="id226" class="indexterm"/>to an immutable value at the same time; this is also called shared ownership. <code class="literal">Box&lt;T&gt;</code> can't help us out here because this type has a single owner by definition. For this, Rust provides the generic reference counted box, <code class="literal">Rc&lt;T&gt;</code>, where multiple references can share the same resource. The <code class="literal">std::rc</code> module provides a way to share ownership of the same value between different <code class="literal">Rc</code> pointers; the value remains alive as long as there is least one pointer referencing it.</p><p>In the following example, we have aliens that have a number of tentacles. Each <code class="literal">Tentacle</code> has to indicate to which <code class="literal">Alien</code> it belongs; besides this, it also has other properties (such as a degree of poison), so we define it also as a struct. A first attempt at this could be the following code, which however does not compile (from <code class="literal">Chapter 6/code/refcount_not_good.rs</code>):</p><div><pre class="programlisting">struct Alien {
    name: String,
    n_tentacles: u8
}

struct Tentacle {
    poison: u8,
    owner: Alien
}

fn main() {
let dhark = Alien { name: "Dharkalen".to_string(), n_tentacles: 7 };
   // defining dhark's tentacles:
    for i in 1u8..dhark.n_tentacles {
        Tentacle { poison: i * 3, owner: dhark }; // &lt;- error!
    }
}</pre></div><p>The compiler gives the following error for the line in the for loop: <code class="literal">error: use of moved value 'dhark' - note: 'dhark' moved here because it has type 'Alien', which is non-copyable</code>. </p><p>When it is defined, each <code class="literal">Alien Tentacle</code> seemingly tries to make a copy of the <code class="literal">Alien</code> instance as its owner, which<a id="id227" class="indexterm"/> makes no sense and is not allowed.</p><p>The correct version defines the owner in the <code class="literal">Tentacle</code> struct to have the <code class="literal">Rc&lt;Alien&gt;</code> type:</p><div><pre class="programlisting">// see code in Chapter 6/code/refcount.rs
<strong>use std::rc::Rc;</strong>
#[derive(Debug)]
struct Alien {
    name: String,
    n_tentacles: u8
}
#[derive(Debug)]
struct Tentacle {
    poison: u8,
<strong>    owner: Rc&lt;Alien&gt;</strong>
}

fn main() {
  let dhark = Alien { name: "Dharkalen".to_string(), no_tentacles: 7 };
<strong>  let dhark_master = Rc::new(dhark);</strong>
  for i in 1u8..dhark_master.n_tentacles {
<strong>    let t = Tentacle { poison: i * 3, owner: dhark_master.clone() };</strong>
<strong>    println!("{:?}", t);</strong>
  }
}</pre></div><p>This prints the following:</p><div><pre class="programlisting">Tentacle { poison: 3, owner: Alien { name: "Dharkalen", n_tentacles: 7 } }
Tentacle { poison: 6, owner: Alien { name: "Dharkalen", n_tentacles: 7 } }
…
Tentacle { poison: 18, owner: Alien { name: "Dharkalen", n_tentacles: 7 } }</pre></div><p>We envelop our <code class="literal">Alien</code> instance in an <code class="literal">Rc&lt;T&gt;</code> type with <code class="literal">Rc::new(dhark)</code>. Applying the <code class="literal">clone()</code> method on this <code class="literal">Rc</code> object provides each <code class="literal">Tentacle</code> with its own reference to the <code class="literal">Alien</code> object. Note that <code class="literal">clone()</code> here copies the <code class="literal">Rc</code> pointer, not the <code class="literal">Alien</code> struct. We also annotate the structs with <code class="literal">#[derive(Debug)]</code> so that we can print out their instances through a <code class="literal">println!("{:?}", t);</code>.</p><p>If we want mutability inside our <code class="literal">Rc</code> type, we have to either use a <em>Cell</em> pointer if the value implements the <em>Copy</em> trait or a <em>RefCell</em> pointer. Both these smart pointers are found in the <code class="literal">std:cell</code> module.</p><p>However, the <code class="literal">Rc</code> pointer <a id="id228" class="indexterm"/>type can only be used inside one thread of execution. If you need shared ownership across multiple threads, you need to use the <code class="literal">Arc&lt;T&gt;</code> pointer (short for <a id="id229" class="indexterm"/>
<strong>atomic reference counted box</strong>), which is the thread-safe counterpart of <code class="literal">Rc</code> (refer to the <em>Atomic reference counting</em> section of <a class="link" title="Chapter 8. Concurrency and Parallelism" href="part0065.xhtml#aid-1TVKI2">Chapter 8</a>, <em>Concurrency and Parallelism</em>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>An overview of pointers</h1></div></div></div><p>In the following table, we <a id="id230" class="indexterm"/>summarize the different pointers used in Rust. <code class="literal">T</code> represents a generic type. We haven't yet encountered the <code class="literal">Arc</code>, <code class="literal">*const</code>, and <code class="literal">*mut</code> pointers, but they are included here for completeness.</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Pointers</p>
</th><th valign="bottom">
<p>Pointer names</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">&amp;T</code>
</p>
</td><td valign="top">
<p>Reference</p>
</td><td valign="top">
<p>This allows one or more references to read <code class="literal">T</code>.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">&amp;mut T</code>
</p>
</td><td valign="top">
<p>Mutable reference</p>
</td><td valign="top">
<p>This allows a single reference to read and write <code class="literal">T</code>.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Box&lt;T&gt;</code>
</p>
</td><td valign="top">
<p>Box</p>
</td><td valign="top">
<p>This is a heap-allocated <code class="literal">T</code> with a single owner that may read and write <code class="literal">T</code>.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Rc&lt;T&gt;</code>
</p>
</td><td valign="top">
<p>Rc pointer</p>
</td><td valign="top">
<p>This is a heap-allocated <code class="literal">T</code> with many readers.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Arc&lt;T&gt;</code>
</p>
</td><td valign="top">
<p>Arc pointer</p>
</td><td valign="top">
<p>This is like <code class="literal">Rc&lt;T&gt;</code>, but enables safe mutable sharing across threads (refer to <a class="link" title="Chapter 8. Concurrency and Parallelism" href="part0065.xhtml#aid-1TVKI2">Chapter 8</a>, <em>Concurrency and Parallelism</em>).</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">*const T</code>
</p>
</td><td valign="top">
<p>Raw pointer</p>
</td><td valign="top">
<p>This allows unsafe read access to <code class="literal">T</code> (refer to <a class="link" title="Chapter 9. Programming at the Boundaries" href="part0069.xhtml#aid-21PMQ1">Chapter 9</a>, <em>Programming at the Boundaries</em>).</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">*mut T</code>
</p>
</td><td valign="top">
<p>Mutable raw pointer</p>
</td><td valign="top">
<p>This allows unsafe read and write access to <code class="literal">T</code> (refer to <a class="link" title="Chapter 9. Programming at the Boundaries" href="part0069.xhtml#aid-21PMQ1">Chapter 9</a>, <em>Programming at the Boundaries</em>).</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we learned the intelligence behind the Rust compiler, which is embodied in the principles of ownership, moving values, and borrowing. We saw the different pointers that Rust advocates: references, boxes, and reference counters. Now that we have a grasp on how this all works together, we will understand the errors, warnings, and messages the compiler may throw at us in a much better way.</p><p>In the following chapter, we will expose the bigger units of code organization in code, such as modules and crates, and how we can write macros to make coding less repetitive.</p></div></body></html>