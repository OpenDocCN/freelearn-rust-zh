["```rs\nstruct Point { \n    x: f64, \n    y: f64 \n} \n\nimpl Point { \n    fn origin() -> Point { \n        Point {x: 0.0, y: 0.0 } \n    } \n\n    fn new(my_x: f64, my_y: f64) -> Point { \n        Point { x: my_x, y: my_y } \n    } \n} \n```", "```rs\nprintln!(\"{}\", a); \nConsole.WriteLine(\"{0}\", a); \na on the line. In this case, a can be of any type that supports conversion to a formatted output. The same applies to Rust. A line is output with the value of a.\n```", "```rs\n#include <stdio.h> \n#include <stdlib> \nusing System.Collections.Generic; \n```", "```rs\nlet mut my_hashmap: std::collections::HashMap<String, u8> =  \n    std::collections::HashMap::new(); \nmy_hashmap.insert(\"one\".to_owned(), 1); \n```", "```rs\nuse std::collections::HashMap; \nlet mut my_hashmap: HashMap<String, u8> = HashMap::new(); \nmy_hashmap.insert(\"one\".to_owned(), 1); \n```", "```rs\nvar myString = string.Format(\"Hello {0}, I am a {1}{1}{2} computer model {1}\", name, \"B\", \"C\"); \n```", "```rs\nformat!(\"{} {}\", 2, 10); // output 2 10 \nformat!(\"{1} {} {0} {}\", \"B\", \"A\"); \n```", "```rs\nformat!(\"{b} {a} {} {t}\", b = \"B\", a = 'a', t = 33); \n```", "```rs\nlet my_number = format!(\"{:.3}\", 3.1415927); \n```", "```rs\n// 03/readline/src/main.rs\nuse std::io; \nfn main() {     \n    let reader: io::Stdin = io::stdin(); \n    let mut input_text: String = String::new(); \n\n    reader.read_line(&mut input_text).expect(\"Reading failed\"); \n    println!(\"Read {}\", input_text); \n} \n```", "```rs\n    let result: Result<usize, io::Error> = reader.read_line(&mut input_text); \n    if result.is_err() { \n        println!(\"failed to read from stdin\"); \n        return; \n    } \n```", "```rs\n    let trimmed = input_text.trim(); \n    let option: Option<i32> = trimmed.parse::<i32>().ok(); \n```", "```rs\nmatch option { \n        Some(i) => println!(\"your integer input: {}\", i), \n        None => println!(\"this was not an integer: {}\", trimmed) \n    }; \n\n```", "```rs\nman ffmpeg \n```", "```rs\nint main(int argc, char *argv[])\n```", "```rs\n// 03/args/src/main.rs\nuse std::env; \nfn main() { \n    let args: Vec<String> = env::args().collect(); \n    println!(\"There was {:?} arguments passed in. They were {:?}.\", args.len() - 1, &args[1..]); \n} \n```", "```rs\nlet file = try!(File::open(\"my_file.txt\")) \n```", "```rs\nlet file = match File::open(\"my_file.txt\") { \n    Ok(file) => file, \n    Err(..) => panic!(\"boom\"), \n} \n```", "```rs\nlet mut reader = BufReader::new(&file); \nlet buffer_string = &mut String::new(); \nreader.read_line(buffer_string); \nprintln!(\"Line read in: {}\", buffer_string); \n```", "```rs\nlet file: Result<File,Error> = options.open(path); \n\n```", "```rs\nlet mut writer = BufWriter::new(&file); \nwriter.write_all(b\"hello text file\\n\"); \n```", "```rs\nlet file: Result<File, Error> = options.open(\"my_file.txt\").expect(\"Opening the file failed\"); \n```", "```rs\nlet file = File::open(\"my_xmlfile.xml\").unwrap();\nlet reader =BufferedReader::new(file);\n```", "```rs\nlet mut xml_parser = EventReader::new(reader); \n```", "```rs\nfor e in xml_parser.events() { \n     match e { \n         StartElement { name, .. } => { \n              println!(\"{}\", name); \n         } \n         EndElement {name} => { \n             println!(\"{}\", name); \n         } \n         Error(e) => { \n             println!(\"Error in file: {}\", e); \n      } \n      _ => {} \n   } \n} \n_ => {} essentially means that you don't care what is left, do something with it (in this case, the something is nothing). You will see the symbol _ quite a bit in Rust. Commonly, it is used in loops where the variable being acted on is never used, for example:\n```", "```rs\nfor _ in something() {...} \n```", "```rs\nlet mut file = File::create(\"myxml_file.xml).unwrap(); \nlet mut output = io::stdout(); \nlet mut input = io::stdin(); \n```", "```rs\nlet mut writer = EmitterConfig::new().preform_indent(true).create_writer(&mut file); \n```", "```rs\nloop { \n    print!(\"> \"); \n    output.flush().unwrap(); \n    let mut line = String::new(); \n    match input.readline(&mut line) { \n         Ok(0) => break, \n         Ok(_) => match handle_event(&mut writer, line) { \n              Ok(_) => {} \n              Err(e) => panic!(\"XML write error: {}\", e) \n         } \n         Err(e) => panic!(\"Input error: {}\", e); \n    } \n} \n```", "```rs\nfn handle_event<W: Write>(w: &mut EventWriter<W>, line: String) -> Result<()> { \n```", "```rs\nResult handle_result<T>(EventWriter<T> w, string line) where T:Write \n```", "```rs\nlet line = line.trim(); \n```", "```rs\nlet event: XmlEvent = if line.starts_with(\"+\") && line.len() > 1 { \n    XmlEvent::start_element(&line[1..]).into() \n} else if line.starts_with(\"-\") { \n    XmlEvent::end_element().into() \n} else { \n    XmlEvent::characters(&line).into() \n   }; \n    w.write(&line).into(); \n} \n```"]